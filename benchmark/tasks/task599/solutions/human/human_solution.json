[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main {\n\n  case class Point(x: Double = 0, y: Double = 0) {\n\n    def +(p: Point): Point = Point(this.x + p.x, this.y + p.y)\n\n    def -(p: Point): Point = Point(this.x - p.x, this.y - p.y)\n\n    def *(a: Double): Point = Point(this.x * a, this.y * a)\n\n    def /(a: Double): Point = {\n      assert(a != 0)\n      Point(this.x / a, this.y / a)\n    }\n\n    def norm(): Double = this.x * this.x + this.y * this.y\n\n    def abs(): Double = scala.math.sqrt(norm())\n\n    def <(p: Point): Boolean = this.x < p.x && this.y < p.y\n\n\n    def ==(p: Point): Boolean = scala.math.abs(this.x - p.x) < Cgl0A.EPS &&\n      scala.math.abs(this.y - p.y) < Cgl0A.EPS\n\n\n  }\n  \n  case class Circle(center: Point, r: Int)\n\n  case class Segment(p1: Point, p2: Point)\n\n  case class Line(p1: Point, p2: Point)\n\n  type GeoVector = Point\n\n  object Cgl0A {\n    val EPS: Double = scala.math.pow(10, -10)\n\n    // 内積\n    def dot(a: Point, b: Point): Double = a.x * b.x + a.y * b.y\n\n    def isOrthogonal(a: GeoVector, b: GeoVector): Boolean = dot(a, b) == 0.0\n\n    def isOrthogonal(a1: Point, a2: Point, b1: Point, b2: Point): Boolean = {\n      isOrthogonal(a1 - a2, b1 - b2)\n    }\n\n    def isOrthogonal(s1: Segment, s2: Segment): Boolean = {\n      dot(s1.p2 - s1.p1, s2.p2 - s2.p1) == 0.0\n    }\n\n    // 外積\n    def cross(a: Point, b: Point): Double = a.x * b.y - a.y * b.x\n\n    def isParallel(a: GeoVector, b: GeoVector): Boolean = cross(a, b) == 0.0\n\n    def isParallel(a1: Point, a2: Point, b1: Point, b2: Point): Boolean = {\n      isParallel(a1 - a2, b1 - b2)\n    }\n\n    def isParallel(s1: Segment, s2: Segment): Boolean = {\n      cross(s1.p2 - s1.p1, s2.p2 - s2.p1) == 0.0\n    }\n\n    def project(s: Segment, p: Point): Point = {\n      val base: GeoVector = s.p2 - s.p1\n      val r: Double = Cgl0A.dot(p - s.p1, base) / base.norm()\n      s.p1 + base * r\n    }\n\n    def reflect(s: Segment, p: Point): Point = {\n      p + (project(s, p) - p) * 2.0\n    }\n\n    def getDistance(a: Point, b: Point): Double = (a - b).abs()\n\n    def getDistanceLP(l: Line, a: Point): Double = {\n      scala.math.abs(cross(l.p2 - l.p1, a - l.p1) / (l.p2 - l.p1).abs())\n    }\n\n    def getDistanceSP(s: Segment, a: Point): Double = {\n      if (dot(s.p2 - s.p1, a - s.p1) < 0.0) (a - s.p1).abs()\n      else if (dot(s.p1 - s.p2, a - s.p2) < 0.0) (a - s.p2).abs()\n      else getDistanceLP(Line(s.p1, s.p2), a)\n    }\n\n    def getDistance(s1: Segment, s2: Segment): Double = {\n      if (intersect(s1, s2)) {\n        0.0\n      }\n      else {\n        math.min(math.min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n          math.min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)))\n      }\n    }\n\n    val COUNTER_CLOCKWISE: Int = 1\n    val CLOCKWISE: Int = -1\n    val ONLINE_BACK: Int = 2\n    val ONLINE_FRONT: Int = -2\n    val ON_SEGMENT: Int = 0\n\n    def ccw(p0: Point, p1: Point, p2: Point): Int = {\n      val a: GeoVector = p1 - p0\n      val b: GeoVector = p2 - p0\n\n      if (cross(a, b) > EPS) COUNTER_CLOCKWISE\n      else if (cross(a, b) < -1 * EPS) CLOCKWISE\n      else if (dot(a, b) < -1 * EPS) ONLINE_BACK\n      else if (a.norm() < b.norm()) ONLINE_FRONT\n      else ON_SEGMENT\n\n    }\n\n    def intersect(p1: Point, p2: Point, p3: Point, p4: Point): Boolean = {\n      Cgl0A.ccw(p1, p2, p3) * Cgl0A.ccw(p1, p2, p4) <= 0 &&\n        Cgl0A.ccw(p3, p4, p1) * Cgl0A.ccw(p3, p4, p2) <= 0\n    }\n\n    def intersect(s1: Segment, s2: Segment): Boolean = {\n      Cgl0A.intersect(s1.p1, s1.p2, s2.p1, s2.p2)\n    }\n    \n    def getCrossPoint(s1: Segment, s2: Segment): Point = {\n      val base: GeoVector = s2.p2 - s2.p1\n      val d1 = scala.math.abs(cross(base, s1.p1 - s2.p2))\n      val d2 = scala.math.abs(cross(base, s1.p2 - s2.p1))\n      val t = d1 / (d1 + d2)\n      s1.p1 + (s1.p2 - s1.p1) * t\n    }\n    \n    def getCrossPoint(c: Circle, l: Line): Array[Point] = {\n      val pr: GeoVector = project(Segment(l.p1, l.p2), c.center)\n      val e: GeoVector = (l.p2 - l.p1) / (l.p2 - l.p1).abs()\n      val base: Double = scala.math.sqrt(c.r*c.r - (pr - c.center).norm())\n      Array(pr + e*base, pr - e * base).sortBy(p => (p.x, p.y))\n    }\n  }\n\n\n  def main(args: Array[String]): Unit = {\n    val c = StdIn.readLine().split(' ').map(_.toInt)\n    val circle = Circle( Point(c(0), c(1)), c(2))\n    val q = StdIn.readLine().toInt\n    (0 until q).foreach { i =>\n      val a = StdIn.readLine().split(' ').map(_.toDouble)\n      val l = Line(Point(a(0), a(1)),Point(a(2), a(3)))\n      val r = Cgl0A.getCrossPoint(circle, l)\n      \n      println(f\"${r(0).x}%.10f ${r(0).y}%.10f ${r(1).x}%.10f ${r(1).y}%.10f\")\n      \n    }\n\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#include <iostream>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() {return x * x + y * y; }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment {\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\n public:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  Vector pr = project(l, c.c);\n  double base = sqrt(c.r * c.r - (pr - c.c).norm());\n  return make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n  Circle c;\n  cin >> c.c.x >> c.c.y >> c.r;\n  int n;\n  cin >> n;\n  cout << fixed;\n  for (int i = 0; i < n; i++) {\n    Line l;\n    cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n    pair<Point, Point> result = getCrossPoints(c, l);\n    if (result.first.x < result.second.x) {\n      cout << setprecision(10) << result.first.x << \" \" << result.first.y << \" \" << result.second.x << \" \" << result.second.y << endl;\n    } else if (result.first.x == result.second.x && result.first.y < result.second.y) {\n      cout << setprecision(10) << result.first.x << \" \" << result.first.y << \" \" << result.second.x << \" \" << result.second.y << endl;\n    } else {\n      cout << setprecision(10) << result.second.x << \" \" << result.second.y << \" \" << result.first.x << \" \" << result.first.y << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-13)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\nP projection(P a1, P a2, P p) {\n    return a1 + dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// ??´??? a1, a2 ??¨??? C ??¨?????????\nvector<P> crossp_lc(P a1, P a2, C c) {\n    vector<P> ps;\n    double r = c.second;\n    P ft = projection(a1, a2, c.first);\n    if(!GEQ(r*r, norm(ft-c.first))) return ps;\n\n    P dir = sqrt(max(r*r - norm(ft-c.first), 0.0)) / abs(a2-a1) * (a2-a1);\n    ps.push_back(ft + dir);\n    if(!EQ(r*r, norm(ft-c.first))) ps.push_back(ft - dir);\n    return ps;\n}\n\nint main() {\n    C a;\n    cin >> a.fr.X >> a.fr.Y >> a.sc;\n    int n; cin >> n;\n    rep(i,0,n) {\n        P x, y;\n        cin >> x.X >> x.Y >> y.X >> y.Y;\n        vector<P> ans = crossp_lc(x, y, a);\n        if(ans.size() == 1) {\n            printf(\"%.10f %.10f %.10f %.10f\\n\", ans[0].X, ans[0].Y, ans[0].X, ans[0].Y);\n        }\n        else {\n            sort(ans.begin(), ans.end());\n            printf(\"%.10f %.10f %.10f %.10f\\n\", ans[0].X, ans[0].Y, ans[1].X, ans[1].Y);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\n//END CUT HERE\n\n//Projection\nsigned AOJ_CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned AOJ_CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned AOJ_CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned AOJ_CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned AOJ_CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//cross point\nsigned AOJ_CGL2C(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<getCrossPointSS(Segment(p0,p1),Segment(p2,p3))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=jp\n*/\n\n//distanceSS\nsigned AOJ_CGL2D(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    printf(\"%.12f\\n\",getDistanceSS(Segment(p0,p1),Segment(p2,p3)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=jp\n*/\n\n//area of Polygon\nsigned AOJ_CGL3A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.1f\\n\",area(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=jp\n*/\n\n\n//isConvex\nsigned AOJ_CGL3B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<isConvex(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=jp\n*/\n\n\n\n//contains\nsigned AOJ_CGL3C(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  int q;\n  cin>>q;\n  while(q--){\n    Point r;\n    cin>>r;\n    cout<<contains(p,r)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n*/\n\n\n//convex hull\nsigned AOJ_CGL4A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=convex_hull(p);\n  cout<<q.size()<<endl;\n  for(Point v:q) cout<<v.x<<\" \"<<v.y<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n*/\n\n//diameter of Polygon\nsigned AOJ_CGL4B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n*/\n\n//convexCut:\nsigned AOJ_CGL4C(){\n  int n;\n  cin>>n;\n  Polygon g(n);\n  for(int i=0;i<n;i++) cin>>g[i];\n  Polygon p=andrewScan(g);\n  int q;\n  cin>>q;\n  while(q--){\n    Line l;\n    cin>>l.p1>>l.p2;\n    printf(\"%.12f\\n\",area(convexCut(p,l)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=jp\n*/\n\n\n//intersectCC\nsigned AOJ_CGL7A(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  cout<<intersectCC(c1,c2)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\n*/\n\n\n//getCrossPointCL\nsigned AOJ_CGL7D(){\n  Circle c;\n  int q;\n  cin>>c>>q;\n  while(q--){\n    Line l;\n    cin>>l;\n    auto pp=getCrossPointCL(c,l);\n    if(pp.size()==1u) pp.emplace_back(pp[0]);\n    if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n    cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=jp\n*/\n\n//Common Tangent\nsigned AOJ_CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  //AOJ_CGL4B();\n  //AOJ_CGL4C();\n\n  \n  //AOJ_CGL7A();\n  AOJ_CGL7D();\n  //AOJ_CGL7E();\n  //AOJ_CGL7G();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double inf = 1e20;\nconst double eps = 1e-8;\nconst int N = 2e5 + 100;\nint sgn (double x) {\n    if (fabs (x) < eps) return 0;\n    if (x < 0) return -1;\n    return 1;\n}\nstruct point {\n    double x, y;\n    point () {}\n    point (double _x, double _y) {\n        x = _x, y = _y;\n    }\n    void input () {\n        scanf (\"%lf %lf\", &x, &y);\n    }\n    point operator - (const point &b) const {\n        return point (x - b.x, y - b.y);\n    }\n    bool operator == (const point &b) const {\n        return sgn (x - b.x) == 0 && sgn (y - b.y) == 0;\n    }\n    bool operator < (const point &b) const {\n        if (sgn (x - b.x) == 0) return y < b.y;\n        return x < b.x;\n    }\n    double operator * (const point &b) const {\n        return x * b.x + y * b.y;\n    }\n    double operator ^ (const point &b) const {\n        return x * b.y - y * b.x;\n    }\n    point operator / (const double &b) const {\n        return point (x / b, y / b);\n    }\n    point operator * (const double &b) const {\n        return point (x * b, y * b);\n    }\n    point operator + (const point &b) const {\n        return point (x + b.x, y + b.y);\n    }\n    double cross (point a, point b) {\n        return (point (a - *this) ^ point (b - *this));\n    }\n    double dot (point a, point b) {\n        return (point (a - *this) * point (b - *this));\n    }\n    double len () {\n        return hypot (x, y);\n    }\n    bool on_seg (point a, point b) {///点是否在线段ab上\n        return sgn (cross (a, b)) == 0 && dot (a, b) <= 0;\n    }\n} s, e;\n///两线段的交点\npoint spp (point s1, point e1, point s, point e) {\n    if (s.dot (e, s1) > s.dot (e, e1)) swap (s1, e1);\n    point p = e - s;\n    double len = p.len ();\n    double a = fabs (s.cross (e, s1)) / len;\n    double b = fabs (s.cross (e, e1)) / len;\n    double a1 = s.dot (e, s1) / len;\n    double b1 = s.dot (e, e1) / len;\n    double k = a1 + fabs(a1 - b1) / (a + b) * a;\n    p = p / len, p = p * k, p = p + s;\n    return p;\n}\n///两线段是否相交\nbool seg (point a, point b, point c, point d) {\n    if (a.on_seg (c, d)) return true;\n    if (a.cross (b, d) * a.cross (b, c) < 0 && c.cross (d, b) * c.cross (d, a) < 0) return true;\n    return false;\n}\n/// 点的投影是否在线段ab上\nbool check (point p, point a, point b) {\n    point x = b - a;\n    double k = x.len ();\n    double u = a.dot (p, b) / k;\n    x = (x / k) * u;\n    x = x + a;\n    if (x.on_seg (a, b)) return true;\n    return false;\n}\n//struct polygon {\n//    int n;\n//    point ps[N];\n//    void input () {\n//        cin >> n;\n//        for (int i = 0; i < n; i++) ps[i].input ();\n//    }\n//    ///排序规则\n//    struct cmp {\n//        point p;\n//        cmp (point _p) {\n//            p = _p;\n//        }\n//        bool operator () (const point &aa, const point &bb) {\n//            point a = aa, b = bb;\n//            int d = sgn (p.cross (a, b));\n//            if (d == 0) return point (a - p).len () < point (b - p).len ();\n//            else return d > 0;\n//        }\n//    };\n//    ///排序\n//    void norm () {\n//        point mi = ps[0];\n//        for (int i = 0; i < n; i++) mi = min (mi, ps[i]);\n//        sort (ps, ps + n, cmp (mi));\n//    }\n//    ///求凸包\n////    void getconvex (polygon &convex) {\n////        sort (ps, ps + n);\n////        int &top = convex.n;\n////        top = 0;\n////        convex.ps[top++] = ps[0];\n////        for (int i = 1; i < n; i++) {\n////            while (top >= 2 && convex.ps[top - 2].cross (convex.ps[top - 1], ps[i]) < 0) top--;\n////            convex.ps[top++] = ps[i];\n////        }\n////        int t = 0;\n////        for (int i = n - 2; i >= 0; i--) {\n////            while (t && convex.ps[top - 2].cross (convex.ps[top - 1], ps[i]) < 0) top--, t--;\n////            if (!i) break;\n////            convex.ps[top++] = ps[i];\n////            t++;\n////        }\n////    }\n//    ///几何面积\n//    double mianji () {\n//        if (n < 2) return 0;\n//        double ans = 0;\n//        ps[n] = ps[0];\n//        for (int i = 1; i <= n; i++) ans += point (0, 0).cross (ps[i - 1], ps[i]);\n//        return ans;\n//    }\n//} dd, ans;\nstruct circle {\n    point p;\n    double r;\n    circle () {}\n    circle (point _p, double _r) {\n        p = _p, r = _r;\n    }\n    void input () {\n        p.input ();\n        scanf (\"%lf\", &r);\n    }\n} cr;\nint main () {\n//    freopen (\"in.txt\", \"r\", stdin);\n    int Q;\n    cr.input ();\n    cin >> Q;\n    while (Q --) {\n        s.input (), e.input ();\n        double len = fabs (s.cross (e, cr.p)) / point (e - s).len ();\n        if (sgn (len - cr.r) == 0) {\n            point a = e - s;\n            double u = a.len ();\n            double k = s.dot (e, cr.p) / u;\n            a = a / u * k;\n            a = a + s;\n//            cout << \"****\" << endl;\n            printf (\"%.8f %.8f %.8f %.8f\\n\", a.x, a.y, a.x, a.y);\n            continue;\n        }\n        point a = e - s;\n        double len1 = fabs (s.cross (e, cr.p)) / a.len ();\n        double len2 = s.dot (e, cr.p) / a.len ();\n        double u = sqrt (cr.r * cr.r - len1 * len1);\n        double k1 = len2 - u, k2 = len2 + u, k3 = a.len ();\n        point ans1 = a / k3 * k1;\n        point ans2 = a / k3 * k2;\n        ans1 = ans1 + s;\n        ans2 = ans2 + s;\n        if (ans2 < ans1) swap (ans1, ans2);\n        printf (\"%.8f %.8f %.8f %.8f\\n\", ans1.x, ans1.y, ans2.x, ans2.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\n// circle\nstruct C {\n\tP p; double r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint intersectCC(const C& a, const C& b) {\n\tdouble dist = sqrt(norm(a.p-b.p)), r1 = a.r + b.r, r2 = abs(a.r - b.r);\n\tif(r1 < dist) return 4;\t\t//??\\?????????\n\tif(dist == r1) return 3;\t//?????\\\n\tif(r2 < dist && dist < r1) return 2; //?????????\n\tif(dist == r2) return 1; //?????\\\n\treturn 0;\t//??????\n}\n\nvector<P> crossPointCL(C c, L l) {\n\tdouble d = distanceLP(l, c.p), r = c.r;\n\tP m = projection(l, c.p);\n\tP x = sqrt(r*r-d*d)/(l[1]-l[0])*(l[1]-l[0]);\n\tvector<P> ret(2,m);\n\tret[0] -= x;\n\tret[1] += x;\n\treturn ret;\n}\n\nint main() {\n\tdouble x1, y1, r1;\n\tcin >> x1 >> y1 >> r1;\n\tC c1(P{x1, y1}, r1);\n\tint q;\n\tcin >> q;\n\tfor(int i=0; i<q; ++i) {\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tL l(P{x1, y1}, P{x2, y2});\n\t\tvector<P> ans = crossPointCL(c1, l);\n\t\tsort(ans.begin(), ans.end());\n\t\tcout << fixed << setprecision(15) << ans[0].real() << \" \" << ans[0].imag() << \" \" << ans[1].real() << \" \" << ans[1].imag() << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// 円と直線の交点\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#include<queue>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 22点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\n// 点とベクトルの表現は同じ\ntypedef Point Vector;\n// 線分と直線の表現は同じ\ntypedef Segment Line;\n\n// 円を表すくらす\nclass Circle\n{\n    public :\n        Point c;    // 中心\n        double r;   // 半径\n\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble cross_point(Line line, Point pp);\nVector projection(Vector a, Vector b, Vector p);\nPoint project(Segment s, Point p);\ndouble getDistanceLP(Line l, Point p);\nint ccw(Point p0, Point p1, Point p2);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point, Point> getCircleLineCrossPoint(Circle circle, Line l);\n\nint main(void)\n{\n    int q;\n    Point center, p0, p1;\n    double r;\n    pair<Point, Point> p_pair;\n\n    cin >> center.x >> center.y >> r;\n\n    // 円の定義\n    Circle circle(center, r);\n\n    cin >> q;\n\n    for(int i = 0; i < q; i++)\n    {\n        // 各点の格納\n        cin >> p0.x >> p0.y >> p1.x >> p1.y;\n        // 直線の作成\n        Line line(p0, p1);\n\n        p_pair = getCircleLineCrossPoint(circle, line);\n\n        printf(\"%.8lf %.8lf %.8lf %.8lf\\n\",\n        \t\t\tp_pair.first.x, p_pair.first.y, p_pair.second.x, p_pair.second.y);\n    }\n\n    return 0;\n}\n\n// 内積の計算をする関数\ndouble dot(Vector a, Vector b)\n{\n    return ( ( a.x * b.x ) + ( a.y * b.y ) );\n}\n\n// 外積の計算をする関数\ndouble cross(Vector a, Vector b)\n{\n    return ( ( a.x * b.y ) - ( a.y * b.x ) );\n}\n\n// 外積の計算をする関数 2\n// 直線 : line に対する点pの外積の演算\ndouble cross_point(Line line, Point pp)\n{\n    return ( line.p2.x - line.p1.x ) * ( pp.y - line.p1.y ) - ( pp.x - line.p1.x ) * ( line.p2.y - line.p1.y );\n}\n\n// 正射影ベクトルを求める関数\n// p : 垂線の始点となる点\nVector projection(Vector a, Vector b, Vector p)\n{\n    // 正射影ベクトルの考え方より\n    // 正射影ベクトル = ( ( a, bベクトルの内積 ) / aベクトルの大きさの2乗 ) * aベクトル\n    return ( ( a * ( dot(a, b) / pow( a.distance(), 2.0 ) ) ) + p );\n}\n\n// 正射影ベクトルを求める関数 2\n// p : 垂線の始点となる点\n// 戻り値 : pからの垂線と直線：sの交点\nPoint project(Segment s, Point p)\n{\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    Point tp = base * r;\n    return s.p1 + tp;\n}\n\n\n// 点と直線の距離を求める関数\ndouble getDistanceLP(Line l, Point p)\n{\n    if( dot( l.p2 - l.p1, p - l.p1 ) < 0.0 )\n    {\n        // 内積の値が負の場合, 2つの線分のなす角が90°以上のため,\n        // 距離は, p と l.p1 の距離そのものになる\n        return ( p - l.p1 ).distance();\n    }\n\n    if( dot( l.p1 - l.p2, p - l.p2 ) < 0.0 )\n    {\n        // 内積の値が負の場合, 2つの線分のなす角が90°以上のため,\n        // 距離は, p と l.p2 の距離そのものになる\n        return ( p - l.p2 ).distance();\n    }\n\n    // 2つの線分のなす角が90°以内の時\n    return abs( cross(l.p2 - l.p1, p - l.p1) / ( l.p2 - l.p1 ).distance() );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// 3点の関係を調査する関数\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if( cross(a, b) > EPS )\n    {\n        // P2が半時計回りの方向にいる\n        return COUNTER_CLOCKWISE;\n    }\n    else if( cross(a, b) < -EPS )\n    {\n        // P2が時計回りの方向にいる\n        return CLOCKWISE;\n    }\n    else if( dot(a, b) < -EPS )\n    {\n        // P2が, 直線：p0p1に対して, 180°反対方向にいる\n        return ONLINE_BACK;\n    }\n    else if( a.norm() < b.norm() )\n    {\n        // p0, p1, p2 の順で同一直線上に点が並んでいる\n        return ONLINE_FRONT;\n    }\n\n    // p0, p2, p1 の順で同一直線上に点が並んでいる\n    return ON_SEGMENT;\n}\n\n// 線分の交点を求める関数\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tPoint p0;\n    double d1, d2, t;\n\n    Vector base = s2.p2 - s2.p1;\n\n    // 外積(平行四辺形の面積)から, 点と直線の距離を求める\n    d1 = abs( cross(base, s1.p1 - s2.p1) / base.distance() );\n    d2 = abs( cross(base, s1.p2 - s2.p1) / base.distance() );\n\n    t = d1 / ( d1 + d2 );\n\n    p0 = ( s1.p2 - s1.p1 ) * t;\n\n    return s1.p1 + p0;\n}\n\n// 円と直線の交点を求める関数\npair<Point, Point> getCircleLineCrossPoint(Circle circle, Line l)\n{\n    Point p0, p1;\n\n    // 円の中心からの垂線と直線：lの交点：prを求める\n    Vector pr = project(l, circle.c);\n\n    if( ( pr - circle.c ).distance() > circle.r )\n    {\n        // 円と直線に交点が存在しない時\n        return make_pair(p0, p1);\n    }\n\n    // 直線上の単位ベクトルを求める\n    Vector e = ( l.p2 - l.p1 ) / ( l.p2 - l.p1 ).distance();\n    // 交点：prと、円と直線の交点までの距離を求める\n    double base = sqrt( circle.r * circle.r - ( pr - circle.c ).norm() );\n    // 円と直線の交点を求める\n    Point eb = e * base;\n    p0 = pr - eb;\n    p1 = pr + eb;\n\n    if( p1 < p0 )\n    {\n        // 点の大小関係の調整\n        p0 = pr + eb;\n        p1 = pr - eb;\n    }\n\n    return make_pair(p0, p1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cmath>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include<vector>\n#include<cstring>\n#include<set>\n#include <cstdio>\n#include<queue>\n#include<map>\n#define WHITE 0\n#define GRAY  1\n#define BLACK 2\n#define endl '\\n'\n#define forup(i,a,n) for( int i =a; i < n; i++)\n#define llforup(i,a,n) for( ll i =a; i < n; i++)\n#define fordown(i,a,n) for( int i =a; i >= n; i--)\n#define fornot(i,a,n) for( int i=a;!n;i++)\n#define mod  (ll)(1e9+7)\n#define putnum(a) printf(\"%d\\n\",a)\nusing namespace std;\ntypedef long long ll;\ninline int readnum()\n{\n\tint p, data = 0; char ch = 0;\n\twhile ((ch != '-') &&( ch < '0' || ch>'9') )//注意运算优先级，逻辑与大于逻辑非\n\t\tch = getchar();//相当于正则表达式的搜索，跳过不需要的字符\n\tif (ch == '-')\n\t\tp = -1, ch = getchar();//不能与if平行放置，不懂为什么，可能是bug\n\telse p = 1;\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + ch - '0', ch = getchar();//搜索需要的字符\n\treturn data * p;\n}\ninline int ReadPossitive()\n{\n\tchar ch; int data = 0;\n\tch = getchar();\n\twhile (ch == ' ' || ch == '\\n')ch = getchar();\n\twhile (ch != ' ' && ch != '\\n' && ch != EOF)\n\t{\n\t\tdata = data * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn data;\n}\n//并查集模板\nclass DisjointSet {\nprivate:\n\tvector<int>rank, parent;\npublic:\n\tDisjointSet(){}\n\tDisjointSet(int size)\n\t{\n\t\trank.resize(size, 0);//默认初始化为0，养成习惯写完整\n\t\tparent.resize(size, 0);\n\t\tforup(i, 0, size)MakeSet(i);\n\t}\n\tvoid MakeSet(int x)\n\t{\n\t\tparent[x] = x;\n\t\trank[x] = 0;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn Findroot(x) == Findroot(y);\n\t}\n\tvoid unite(int x, int y)\n\t{\n\t\tlink(Findroot(x), Findroot(y));\n\t}\n\tinline int Findroot(int x)\n\t{\n\t\twhile (x != parent[x])\n\t\t{\n\t\t\tx = parent[x];\n\t\t}\n\t\treturn x;\n\t}\n\tvoid link(int rootx, int rooty)\n\t{\n\t\tif (rank[rootx] < rank[rooty])parent[rootx] = parent[rooty];\n\t\telse\n\t\t{\n\t\t\tparent[rooty] = parent[rootx];\n\t\t\tif (rank[rootx] == rank[rooty])\n\t\t\t\trank[rootx]++;\n\t\t}\n\t}\n};\n\n//计算几何模板\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)//保留整数0\nclass Point {\npublic:\n\tdouble x, y;\npublic:\n\tPoint() {};\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint operator +(Point p) { return Point(x + p.x, y + p.y);}//p不能为引用的问题怎么解决？\n\tPoint operator -(Point p) { return Point(x - p.x, y - p.y);}\n\tPoint operator *(double a) { return Point(a * x, a * y); }\n\tPoint operator /(double a) { return Point(x / a, y / a); }\n\tinline double abs() { return sqrt(norm()); }\n\tinline double norm() { return x * x + y * y; }\n\tbool operator <(const Point& p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator ==(const Point& p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\n\nclass Line {\npublic:\n\tPoint p1, p2;\npublic:\n\tLine() {};\n\tLine(int p1x, int p1y, int p2x, int p2y)\n\t{\n\t\tp1.x = p1x; p1.y = p1y;\n\t\tp2.x = p2x; p2.y = p2y;\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c; double r;\npublic:\n\tCircle() {}\n\tCircle(Point c,double r):c(c),r(r){}\n\tCircle(double cx, double cy, double cr)\n\t{\n\t\tc.x = cx; c.y = cy; r = cr;\n\t}\n};\n\nclass VectorOperation {//操作符不必继承\npublic:\n\tdouble dot(Point a, Point b)//点乘\n\t{\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\tdouble cross(Point a, Point b)//叉乘\n\t{\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\tdouble abs(Point s)\n\t{\n\t\treturn sqrt(s.norm());\n\t}\n\tdouble getDistance(Point a, Point b)\n\t{\n\t\treturn abs(a - b);\n\t}\n\tint rotation(Point p0, Point p1, Point p2)\n\t{\n#define COUNTER_CLOCKWISE -1\n#define CLOCKWISE 1\n#define ONLINE_BACK -2\n#define ONLINE_FRONT 2\n#define ON_SEGMENT 0\n\t\tVector a = p1 - p0;Vector b = p2 - p0;\n\t\tdouble Cross = cross(a, b);\n\t\tif (Cross > 0.0)return COUNTER_CLOCKWISE;\n\t\tif (Cross < 0.0)return CLOCKWISE;\n\t\tif (dot(a, b) < 0.0)return ONLINE_BACK;\n\t\tif (a.norm() < b.norm())return ONLINE_FRONT;\n\n\t\treturn ON_SEGMENT;\n#undef COUNTER_CLOCKWISE -1\n#undef CLOCKWISE 1\n#undef ONLINE_BACK -2\n#undef ONLINE_FRONT 2\n#undef ON_SEGMENT 0\n\t}\n};\n\nclass LineOperation :public VectorOperation{\npublic:\t\n\tbool isOrthogonal(Line s1, Line s2)\n\t{\n\t\treturn equals(dot(s1.p2-s1.p1, s2.p2 - s2.p1), 0.0);//操作符重载的返回值的内存分配机制尚不可知，似乎返回值没有分配内存，dot的参数不能用引用，否则报错。\n\t}\n\tbool isParallel(Line s1, Line s2)\n\t{\n\t\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);//外积判断平行，内积判断垂直。\n\t}\n\tbool intersectSS(Line s1, Line s2)\n\t{\n\t\treturn (rotation(s1.p1, s1.p2, s2.p1) * rotation(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\t    rotation(s2.p1, s2.p2, s1.p1) * rotation(s2.p1, s2.p2, s1.p2) <= 0);//即对两条线段都有另一条线段的两个端点必须在当前线段的两侧\n\t}//可以证明如果一条线段的计算结果是负二，另一个线段的计算结果必定大于0\n\tPoint projection(Line s, Point p)\n\t{\n\t\tVector base = s.p1 - s.p2;\n\t\tdouble r = dot(p - s.p1, base) /base.norm();\n\t\treturn s.p1 + base * r;\n\t}\n\tPoint reflection(Line s, Point p)\n\t{\n\t\treturn p + (projection(s, p)-p) * 2.0;\n\t}\n\tdouble getDistanceLP(Line s, Point p)//点与直线\n\t{\n\t\treturn fabs(cross(s.p2 - s.p1, p - s.p1)) / abs(s.p2 - s.p1);\n\t}\n\tdouble getDistanceSP(Line s, Point p)//点与线段\n\t{\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return abs(p - s.p1);//与点p1成钝角\n\t\telse if (dot(s.p2 - s.p1, p - s.p2) > 0.0)return abs(p - s.p2);\n\t\telse return getDistanceLP(s, p);\n\t}\n\tdouble getDistanceSS(Line s1, Line s2)//线段与线段\n\t{\n\t\t//考虑\n\t\t// --\n\t\t//----\n\t\tif (intersectSS(s1, s2))return 0.0;//如果枚举优化需要16次逻辑，采用分治法的效率和直接使用min函数一样\n\t\telse\n\t\t\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n\t}\n\tPoint getCrossPointSS(Line s1, Line s2)\n\t{\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = fabs(cross(base, s1.p1 - s2.p1));//除以abs(base)这步因为在t中base被消去所以没有写，提升效率\n\t\tdouble d2 = fabs(cross(base, s1.p2 - s2.p1));\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n};\n\nclass CircleOperation :public VectorOperation{\npublic:\n\tint intersectCL(Line s,Circle c)\n\t{\n\t\tLineOperation op;\n\t\tdouble distance = op.getDistanceLP(s, c.c);\n\t\tdouble comparation = distance - c.r;\n\t\tif (comparation < EPS)return 1;\n\t\tif (comparation < 0.0)return 2;\n\t\tif (comparation > 0.0)return 0;\n\t}\n\tint intersectCC(Circle c1, Circle c2)\n\t{\n\t\tdouble distanceR = c1.r + c2.r;\n\t\tdouble distancePR = getDistance(c1.c, c2.c);\n\t\tdouble comparation = distancePR - distanceR;\n\t\tif (comparation < EPS)return 1;\n\t\tif (comparation > 0.0)return 0;\n\t\tif (comparation < 0.0)return 2;\n\t}\n\tpair<Point,Point> getCrossPointCL(Circle c,Line s)\n\t{\n\t\tLineOperation op;\n\t\tPoint CLprojection = op.projection(s, c.c);\n\t\tVector CL = CLprojection - c.c;\n\t\tVector e = (s.p2 - s.p1) / abs(s.p2 - s.p1);\n\t\tdouble base = sqrt(c.r * c.r - CL.norm());\n\t\treturn make_pair(CLprojection + e * base, CLprojection - e * base);\n\t\t//可以处理仅有一个交点的情况base是0产生两个同解。sqrt要求必须是正数，使用前必须进行有解性判断。\n\t}\n};\n//E-mail 374656045@qq.com\n\nclass solve {\nprivate:\n\tint n;\npublic://采用邻接表建图,带权无向图\n\tsolve()\n\t{\n\t\tint cx, cy, r;\n\t\tint x1, y1, x2, y2;\n\t\tcx = readnum(); cy = readnum(); r = readnum();\n\t\tCircle c(cx, cy, r);//为什么不能用初始化列表解决？\n\t\tn = readnum();\n\t\tCircleOperation op;\n\t\tforup(i, 0, n)\n\t\t{\n\t\t\tx1 = readnum(); y1 = readnum();\n\t\t\tx2 = readnum(); y2 = readnum();\n\t\t\tLine s(x1, y1, x2, y2);\n\t\t\tpair<Point, Point> ans = op.getCrossPointCL(c, s);\n\t\t\tif (ans.first < ans.second)printf(\"%.10f %.10f %.10f %.10f\\n\", ans.first.x, ans.first.y, ans.second.x, ans.second.y);\n\t\t\telse printf(\"%.10f %.10f %.10f %.10f\\n\", ans.second.x, ans.second.y, ans.first.x, ans.first.y);\n\t\t}\n\t}\n};\nint main(void)\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);//慎用，cin和scanf混用会导致非MSC++WA\n#ifdef DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tsolve solution;\n#ifdef DEBUG\n\tfclose(stdin);//关闭文件 \n\tfclose(stdout);//关闭文件 \n#endif\n\treturn 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\nbool equals(double a, double b){ return (fabs(a) - fabs(b)) < EPS;};\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstatic const int NOTCROSS = 4;\nstatic const int CIRCUMSCRIBED = 3; \nstatic const int INTERSECT = 2;\nstatic const int INSCRIBED = 1;\nstatic const int INCLUDE = 0;\n\nclass Point{\npublic:\n\tdouble x, y;\n\t\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint(const Point &p) { x = p.x; y = p.y;};\n\t\n\tPoint operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (const double &a) { return Point(x * a, y * a); }\n\tPoint operator / (const double &a) { return Point(x / a, y / a); }\n\t\n\tPoint & operator = (const Point& p) {x = p.x; y = p.y; return *this;};\n\tPoint & operator += (const Point& p) {x += p.x; y += p.y; return *this;};\n\tPoint & operator -= (const Point& p) {x -= p.x; y -= p.y; return *this;};\n\tPoint & operator *= (const Point& p) {x *= p.x; y *= p.y; return *this;};\n\tPoint & operator /= (const Point& p) {x /= p.x; y /= p.y; return *this;};\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\t\n\tbool operator > (const Point &p) const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\t\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\t\n\tdouble abs() { return sqrt(norm()); };\n\tdouble norm() { return x * x + y * y;};\n};\n\ntypedef Point Vector;\n\n\ndouble norm(Vector a){\n\treturn a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct Segment{\n\tPoint p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\n\n\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isPrallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < - EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\t\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\n\nint intersect(Circle c1, Circle c2){\n\tdouble dis = abs(c1.c - c2.c);\n\t\n\tif(dis > c1.r + c2.r + EPS) return NOTCROSS;\n\tif(fabs(dis - c1.r - c2.r) < EPS) return CIRCUMSCRIBED;\n\tif(dis > fabs(c1.r - c2.r) + EPS) return INTERSECT;\n\tif(fabs(dis - fabs(c1.r - c2.r)) < EPS) return INSCRIBED;\n\treturn INCLUDE;\n}\n\ndouble getDistace(Point a, Point b){\n\treturn abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / abs(l.p2 - l.p1);\n}\n\ndouble getDistanceSP(Segment s, Point p){\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrosPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l){\n\treturn getDistanceLP(l, c.c) < c.r + EPS;\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l){\n\tassert(intersect(c,l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e *base);\n}\n\n// int getCrosPoint(Circle c1, Circle c2, Point &res1, Point &res2){\n\t// int ins = intersect(c1, c2);\n\t// if(ins == NOTCROSS || ins == INCLUDE) return 0;\n\t// if(ins == CIRCUMSCRIBED){\n\t\t// Vector v = c2.c - c1.c;\n\t\t// res1 = v*c1.r/(c1.r + c2.r) + c1.c;\n\t\t// return 1;\n\t// }\n\t// if(ins == INSCRIBED) {\n\t\t\n\t\t// if(fabs(c1.r - c2.r) < EPS){\n\t\t\t// return -1;// infinity\n\t\t// }\n\t\t\n\t\t// if(c1.r > c2.r){\n\t\t\t// swap(c1, c2);\n\t\t// }\n\t\t\n\t\t// Vector v = c1.c - c2.c;\n\t\t// res1 = v*(c2.r - c1.r)/c1.r + c2.c;\n\t\t\n\t\t// return 1;\n\t// }\n// }\n\n\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tCircle c;\n\tLine L;\n\tint ans, q;\n\t\n\tcin>>c.c.x>>c.c.y>>c.r;\n\t\n\tcin>>q;\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tpair<Point,Point> ans;\n\t\tcin>>L.p1.x>>L.p1.y>>L.p2.x>>L.p2.y;\n\t\t\n\t\tans = getCrossPoint(c,L);\n\t\t\n\t\tif(ans.first > ans.second) swap(ans.first, ans.second);\n\t\t\n\t\tcout<<ans.first.x<<\" \"<<ans.first.y<<\" \"<<ans.second.x<<\" \"<<ans.second.y<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <string>\n\n#define ll long long\n#define Int ll\n#define loop(x, start, end) for(Int x = start; x < end; x++)\n#define loopdown(x, start, end) for(int x = start; x > end; x--)\n#define span(a,x,y) a.begin()+x,a.begin()+y\n#define span_all(a) a.begin(),a.end()\n#define len(x) (x.size())\n#define last(x) (*(x.end()-1))\n\nusing namespace std;\n\n#define EPS 0.00000001\n#define fequals(a,b) (fabs((a) - (b)) < EPS)\n\nclass Vector2 {\npublic:\n  double x, y;\n  \n  Vector2(double x = 0, double y = 0): x(x), y(y) {}\n  \n  Vector2 operator + (const Vector2 v) const { return Vector2(x + v.x, y + v.y); }\n  Vector2 operator - (const Vector2 v) const { return Vector2(x - v.x, y - v.y); }\n  Vector2 operator * (const double k) const { return Vector2(x * k, y * k); }\n  Vector2 operator / (const double k) const { return Vector2(x / k, y / k); }\n  \n  double length() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n  double dot (Vector2 const v) { return x * v.x + y * v.y; }\n  double cross (Vector2 const v) { return x * v.y - y * v.x; }\n  \n  bool parallel(Vector2 &other) {\n    return fequals(fabs(dot(other)), length() * other.length());\n  }\n  \n  bool orthogonal(Vector2 &other) {\n    return fequals(0, dot(other));\n  }\n  \n  bool operator < (const Vector2 &v) {\n    return x != v.x ? x < v.x : y < v.y;\n  }\n  \n  bool operator == (const Vector2 &v) {\n    return fabs(x - v.x) < EPS && fabs(y - v.y) < EPS;\n  }\n};\n\nostream & operator << (ostream & out, Vector2 const & v) { \n  out<< \"Vector2(\" << v.x << \", \" << v.y << ')';\n  return out;\n}\n\nistream & operator >> (istream & in, Vector2 & v) { \n  double x, y;\n  in >> x;\n  in >> y;\n  v.x = x;\n  v.y = y;\n  return in;\n}\n\nInt N;\ndouble R;\nVector2 C, p1, p2;\n\n\nVector2 project(Vector2 start_, Vector2 end_, Vector2 p) {\n    Vector2 v = end_ - start_;\n    return start_ + v * (v.dot(p - start_) / v.norm());\n}\n\nVector2 unitVec(Vector2 v) {\n  return v / v.length();\n}\n\npair<Vector2, Vector2> crossPoints() {\n  Vector2 p = project(p1, p2, C);\n  Vector2 e = unitVec(p2 - p1);\n  double len = sqrt(R*R - (p - C).norm());\n  Vector2 x1 = p + e * len;\n  Vector2 x2 = p + e * (-len);\n  if (fabs(x1.x) < EPS) x1.x = 0.0;\n  if (fabs(x1.y) < EPS) x1.y = 0.0;\n  if (fabs(x2.x) < EPS) x2.x = 0.0;\n  if (fabs(x2.y) < EPS) x2.y = 0.0;\n  if (x1 < x2) return make_pair(x1, x2);\n  return make_pair(x2, x1);\n}\n\nvoid solve() {\n  auto points = crossPoints();\n  cout << points.first.x << ' ' << points.first.y << ' ';\n  cout << points.second.x << ' ' << points.second.y << endl;\n}\n\nvoid input() {\n  cin >> C >> R >> N;\n  while (cin >> p1 >> p2) {\n    solve();\n  }\n}\n\nint main() {\n  cout.precision(15);\n  input();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n\n// Circle // verified: AOJ 1183 \nenum RCC{OUT=2,ON_OUT=1,ISC=0,ON_IN=-1,IN=-2};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\n\n// cross point between circle and line \n// verified: AOJ CGL_7_D\nP cir(C c,R t){return c.c+polar(c.r,t);}\nVP cross(C c, L l){\n\tP h=proj(l,c.c),e=polar(sq(norm(c.r)-norm(h-c.c)),arg(l.t-l.s));\n\treturn VP{h-e,h+e};\n}\n\nint main(void){\n\tint q;\n\tC c;\n\tcin >> c.c >> c.r;\n\t\t\n\tcin >> q;\n\tcout.precision(20);\n\trep(i,q){\n\t\tP a,b;\n\t\tcin >> a >> b;\n\t\tL l={a,b};\n\t\tVP res=cross(c,l);\n\t\tif(real(res[0])>real(res[1])) swap(res[0],res[1]);\n\t\tif(sgn(real(res[0])-real(res[1]))==0 and imag(res[0])>imag(res[1])) swap(res[0],res[1]);\n\t\tcout << fixed << res[0] << \" \" << res[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#ifndef Geometry_Complex_hpp\n#define Geometry_Complex_hpp\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n//BEGIN CUT HERE\nnamespace Geometry{\n#define F first\n#define S second\n  typedef long double D;\n  typedef complex<long double> P;\n  typedef pair<P,D> C;\n\n  const D EPS=1e-9;\n  const D PI=asin(1)*2;\n  const D INF=1e18;\n\n  static bool comp(const P &p1,const P &p2){\n    if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n    return p1.real()<p2.real();\n  }\n\n  static bool comp_y(const P &p1,const P &p2){\n    if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n    return p1.imag()<p2.imag();\n  }\n\n  static bool eqls(const P &p1,const P &p2){\n    return abs(p1-p2)<EPS;\n  }\n\n  D dot(P p1,P p2){\n    return p1.real()*p2.real()+p1.imag()*p2.imag();\n  }\n\n  D cross(P p1,P p2){\n    return p1.real()*p2.imag()-p1.imag()*p2.real();\n  }\n\n  P project(P vec,P x){\n    return vec*(x/vec).real();\n  }\n\n  P project(P p1,P p2,P x){\n    return p1+project(p2-p1,x-p1);\n  }\n\n  P reflect(P vec,P x){\n    return vec*conj(x/vec);\n  }\n\n  P reflect(P p1,P p2,P x){\n    return p1+reflect(p2-p1,x-p1);\n  }\n\n  bool intersectSL(P p1,P p2,P vec){\n    vec/=abs(vec); p1/=vec; p2/=vec;\n    return (p1.imag()<EPS && p2.imag()>-EPS)\n      || (p1.imag()>-EPS && p2.imag()<EPS);\n  }\n\n  bool intersectSL(P p1,P p2,P p3,P p4){\n    return intersectSL(p1-p4,p2-p4,p3-p4);\n  }\n\n  bool intersectSS(P p1,P p2,P p3,P p4){\n    if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n    if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n    return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n  }\n\n  D distLP(P vec,P x){\n    return abs((x/vec).imag())*abs(vec);\n  }\n\n  D distLP(P p1,P p2,P x){\n    return distLP(p2-p1,x-p1);\n  }\n\n  D distSP(P p1,P p2,P x){\n    if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n    if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n    return distLP(p1,p2,x);\n  }\n\n  D distSS(P p1,P p2,P p3,P p4){\n    if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n    return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n                distSP(p3,p4,p1),distSP(p3,p4,p2)});\n  }\n\n  P crosspointLL(P p1,P p2,P vec){\n    if(abs(cross(p2-p1,vec))<EPS){return vec;}\n    return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n  }\n\n  P crosspointLL(P p1,P p2,P p3,P p4){\n    return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n  }\n\n  P crosspointSS(P p1,P p2,P p3,P p4){\n    if(distSP(p1,p2,p3)<EPS){return p3;}\n    if(distSP(p1,p2,p4)<EPS){return p4;}\n    return crosspointLL(p1,p2,p3,p4);\n  }\n\n  bool intersectShL(P p1,P p2,P vec){\n    vec/=abs(vec);\n    return intersectSL(p1,p2,vec) &&\n      crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n  }\n\n  bool intersectShL(P p1,P p2,P p3,P p4){\n    return intersectShL(p1-p3,p2-p3,p4-p3);\n  }\n\n  //1::in,0::on edge,-1::out\n  int contain(const vector<P> &poly,const P &p){\n    vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},\n                 {-93763,-78049},{56957,10007}};\n    int s=A.size();\n    vector<bool> cnt(s,false);\n    for(int i=0;i<(int)poly.size();i++){\n      int k=(i+1)%poly.size();\n      if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n      for(int j=0;j<s;j++){\n        if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n      }\n    }\n    int in=0;\n    for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n    return in>s/2?1:-1;\n  }\n\n  vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n    vector<P> ret;\n    for(int i=0;i<(int)poly.size();i++){\n      int j=(i+1)%poly.size();\n      if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n      if(intersectSL(poly[i],poly[j],p1,p2) &&\n         distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n        ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n      }\n    }\n    return ret;\n  }\n\n  D area(const vector<P> &poly){\n    D ans=0;\n    for(int i=2;i<(int)poly.size();i++){\n      ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n    }\n    return abs(ans)/2;\n  }\n\n  vector<P> convexhull(vector<P> pts){\n    vector<P> ret;\n    sort(pts.begin(),pts.end(),comp);\n    auto fnc=\n      [&](){\n        for(auto &I:pts){\n          if(!ret.empty() && abs(I-ret.back())<EPS){continue;}\n          while(ret.size()>1){\n            P A=ret.back()-ret[ret.size()-2];\n            P B=I-ret.back();\n            if(cross(A,B)<-EPS){\n              ret.pop_back();\n            }else if(abs(cross(A,B))<EPS && dot(A,B)>EPS){\n              ret.pop_back();\n            }else{\n              break;\n            }\n          }\n          ret.push_back(I);\n        }\n      };\n    fnc();\n    reverse(pts.begin(),pts.end());\n    fnc();\n    if(ret.size()>1 && ret[0]==ret.back()){ret.pop_back();}\n    return ret;\n  }\n\n  //4::seperate,3::circumscribe,2::intersect,\n  //1::inscribe,0::contain,-1::same\n  int intersectCC(C c1,C c2){\n    D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n    if(d<EPS && dif<EPS){return -1;}\n    if(d-r>EPS){return 4;}\n    if(d-r>-EPS){return 3;}\n    if(d-dif>EPS){return 2;}\n    if(d-dif>-EPS){return 1;}\n    return 0;\n  }\n\n  vector<P> crosspointLC(P p1,P p2,C c){\n    vector<P> ret;\n    P pr=project(p1,p2,c.F);\n    D d=distLP(p1,p2,c.F);\n    if(d-c.S>EPS){return ret;}\n    if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n    P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n    ret.push_back(pr-vec);\n    ret.push_back(pr+vec);\n    return ret;\n  }\n\n  vector<P> crosspointSC(P p1,P p2,C c){\n    vector<P> ret;\n    for(auto &I:crosspointLC(p1,p2,c)){\n      if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n    }\n    return ret;\n  }\n\n  vector<P> crosspointCC(C c1,C c2){\n    vector<P> ret;\n    P vec=c2.F-c1.F;\n    D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n    D h=sqrt(c1.S*c1.S-base*base);\n    vec/=abs(vec);\n    ret.push_back(c1.F+vec*P(base,-h));\n    ret.push_back(c1.F+vec*P(base,h));\n    return ret;\n  }\n\n  vector<P> tangentCP(C c,P p){\n    return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n  }\n\n  vector<pair<P,P>> tangentCC(C c1,C c2){\n    vector<pair<P,P>> ret;\n    P d=c2.F-c1.F;\n    for(D i:{-1,1}){\n      D r=c1.S+c2.S*i;\n      if(intersectCC(c1,c2)>i+1){\n        for(P s:{-1i,1i}){\n          P p=r+s*sqrt(norm(d)-norm(r));\n          ret.emplace_back(c1.F+d*c1.S/norm(d)*p,\n                           c2.F-d*i*c2.S/norm(d)*p);\n        }\n      }\n    }\n    return ret;\n  }\n\n  D area(const vector<P> &poly,C c){\n    D ret=0;\n    for(int i=0;i<(int)poly.size();i++){\n      P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n      if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){\n        ret+=cross(a,b);\n      }else{\n        vector<P> A=crosspointSC(a,b,{0,c.S});\n        if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n        else{\n          ret+=(abs(a)<c.S?\n                cross(a,A[0]):\n                c.S*c.S*arg(A[0]/a));\n          ret+=(abs(b)<c.S?\n                cross(A.back(),b):\n                c.S*c.S*arg(b/A.back()));\n          ret+=cross(A[0],A.back());\n        }\n      }\n    }\n    return abs(ret)/2;\n  }\n\n  //counter-clockwise\n  D diameter(const vector<P> &poly){\n    D ret=0;\n    ll l=0,r=0,n=poly.size();\n    if(n==2){return abs(poly[0]-poly[1]);}\n    for(int i=0;i<n;i++){\n      if(comp(poly[l],poly[i])){l=i;}\n      if(comp(poly[i],poly[r])){r=i;}\n    }\n    ll sl=r,sr=l;\n    while(sl!=l || sr!=r){\n      ret=max(ret,abs(poly[r]-poly[l]));\n      if(cross(poly[(l+1)%n]-poly[l],\n               poly[(r+1)%n]-poly[r])<0){\n        (++l)%=n;\n      }else{\n        (++r)%=n;\n      }\n    }\n    return ret;\n  }\n\n  D closestpair(vector<P> pt){\n    sort(pt.begin(),pt.end(),comp);\n    D ret=INF;\n    int N=pt.size();\n    for(int i=1;i<N;i<<=1){\n      for(int j=0;i+j<N;j+=i*2){\n        int m=i+j;\n        vector<P> R;\n        D l=-INF,r=INF;\n        for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n        for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n        for(int k=0;m+k<N && k<i;k++){\n          if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n        }\n        int idx=0;\n        for(int k=j;k<m;k++){\n          if(r-pt[k].real()>ret){continue;}\n          int M=R.size();\n          while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n          for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n            ret=min(ret,abs(R[s]-pt[k]));\n          }\n        }\n        auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n        inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n      }\n    }\n    return ret;\n  }\n\n  P centerofgravity(const vector<P> &pt){\n    P ret(0,0);\n    D wt=0;\n    for(int i=2;i<(int)pt.size();i++){\n      D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n      P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n      wt+=w2;\n      ret+=p*w2;\n    }\n    return ret/wt;\n  }\n\n  void segment_arrangement(const vector<pair<P,P>> &L,\n                           vector<pair<int,int>> &seg,vector<P> &pt){\n    int N=L.size();\n    for(int i=0;i<N;i++){\n      pt.push_back(L[i].F);\n      pt.push_back(L[i].S);\n      for(int j=i+1;j<N;j++){\n        if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n          pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n        }\n      }\n    }\n    auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n    sort(pt.begin(),pt.end(),le);\n    pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n    for(auto &I:L){\n      vector<pair<D,int>> on;\n      for(int j=0;j<(int)pt.size();j++){\n        if(distSP(I.F,I.S,pt[j])<EPS){\n          on.emplace_back(abs(pt[j]-I.F),j);\n        }\n      }\n      sort(on.begin(),on.end());\n      for(int j=1;j<(int)on.size();j++){\n        seg.emplace_back(on[j-1].S,on[j].S);\n      }\n    }\n    sort(seg.begin(),seg.end());\n    seg.erase(unique(seg.begin(),seg.end()),seg.end());\n  }\n\n  vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n    vector<pair<int,int>> seg;\n    vector<P> pt;\n    segment_arrangement(L,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n      edge[I.F].push_back(I.S);\n      edge[I.S].push_back(I.F);\n    }\n    vector<P> ret;\n    function<void(int,int)> dfs=\n      [&](int v,int pre){\n        if(pre!=-1 && v==0){return;}\n        ret.push_back(pt[v]);\n        vector<pair<D,int>> nx;\n        for(auto &u:edge[v]){\n          P dom=(pre==-1||eqls(pt[v],pt[pre]))?P(1):pt[v]-pt[pre];\n          D a=arg((pt[u]-pt[v])/dom);\n          if(abs(a+PI)<EPS){a=PI;}\n          nx.emplace_back(a,u);\n        }\n        sort(nx.begin(),nx.end());\n        dfs(nx[0].S,v);\n      };\n    dfs(0,-1);\n    return ret;\n  }\n\n  istream & operator >> (istream &i,P &p){\n    D x,y; i>>x>>y; p={x,y}; return i;\n  }\n  istream & operator >> (istream &i,C &p){\n    D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;\n  }\n};\n\nusing namespace Geometry;\n//END CUT HERE\n\n\n#endif /*Geometry_Complex_hpp*/\n\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\"\n#define ERROR \"0.00000001\"\n\nint main(){\n    cout<<fixed<<setprecision(12);\n    C c1;\n    cin>>c1;\n    ll q;\n    cin>>q;\n    while(q--){\n        P p1,p2;\n        cin>>p1>>p2;\n        vector<P> ans=crosspointLC(p1,p2,c1);\n        assert(!ans.empty());\n        if(ans.size()==1){ans.push_back(ans[0]);}\n        sort(ans.begin(),ans.end(),comp);\n        cout<<ans[0].real()<<\" \"<<ans[0].imag()<<\" \"<<ans[1].real()<<\" \"<<ans[1].imag()<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <array>\n#include <algorithm>\n#include <cassert>\n\nusing Number = double;\n\nconst Number EPS = 1e-10;\nconst Number INF = 1e10;\nconst Number PI = acos(-1.0);\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\n// change between degree and radian\ninline Number to_radian(const Number degree) { return degree * PI / 180.0; }\ninline Number to_degree(const Number radian) { return radian * 180.0 / PI; }\n\n\n/**\n * Point in two dimensional\n */\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    // Arithmetic operator between points\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(const Point &rhs) const { // cross product between points\n        return Point(this->x * rhs.x - this->y * rhs.y,\n                     this->x * rhs.x + this->y * rhs.x);\n    }\n\n    // Unary operator and compound assignment operator\n    Point operator-() const {\n        return Point(-this->x, -this->y);\n    }\n    Point& operator+=(const Point &rhs) {\n        return *this = *this + rhs;\n    }\n    Point& operator-=(const Point &rhs) {\n        return *this = *this - rhs;\n    }\n\n    // Arithmetic operator between point and number\n    Point operator*(Number rhs) const {\n        return Point(this->x * rhs, this->y * rhs);\n    }\n    Point operator/(Number rhs) const {\n        return Point(this->x / rhs, this->y / rhs);\n    }\n\n    // Comparison operation\n    bool operator==(const Point &rhs) const {\n        return sign(this->x - rhs.x) == 0 && sign(this->y - rhs.y) == 0;\n    }\n    bool operator<(const Point &rhs) const {\n        return (this->x < rhs.x) || (this->x == rhs.x && this->y < rhs.y);\n    }\n\n    // Other operator\n    Number abs(void) const {\n        return sqrt(this->x * this->x + this->y * this->y);\n    }\n    Number abs2(void) const {\n        return this->x * this->x + this->y * this->y;\n    }\n    Number arg(void) const {\n        return atan2(this->y, this->x);\n    }\n    Number dot(const Point &rhs) {\n        return this->x * rhs.x + this->y * rhs.y;\n    }\n    Point rotate90(void) const {\n        return Point(-this->y, this->x);\n    }\n    Point rotate(double angle) const {\n        return Point(cos(angle) * this->x - sin(angle) * this->y,\n                     sin(angle) * this->x + cos(angle) * this->y);\n    }\n\n};\ninline Number dot(const Point &p1, const Point &p2) {\n    return p1.x * p2.x + p1.y * p2.y;\n}\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n// Output of a point\nstd::ostream& operator<<(std::ostream &os, const Point &p) {\n    return os <<  p.x << ' ' << p.y;\n}\n// Input of a point\nstd::istream& operator>>(std::istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\n\n// Counter-Clockwise predicate (a, b, c)\nenum CCW {\n    COUNTER_CLOCKWISE = 1,      // counter clockwise\n    CLOCKWISE         = -1,     // clockwise\n    ONLINE_FRONT      = 2,      // a--c--b on line\n    ONLINE_BACK       = -2,      // c--a--b on line\n    ON_SEGMENT        = 0,     // a--b--c on line\n};\nCCW ccw(const Point &a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (abs_cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (abs_cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0)       return ONLINE_BACK;\n    if (b.abs2() < c.abs2())   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n/**\n * Line in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0] >> l[1];\n}\ninline CCW ccw(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p);\n}\n\n\n/**\n * Segment in two dimensional\n */\nclass Segment : public Line {\npublic:\n    Segment() {}\n    Segment(const Point &p1, const Point &p2) : Line(p1, p2) {}\n};\n\n\n/**\n * Circle in two dimensional\n */\nclass Circle : public Point {\npublic:\n    Number r;\n    Circle() {}\n    Circle(const Point &p, Number r = 0.0) : Point(p), r(r) {}\n};\n// Input of a circle\nstd::istream& operator>>(std::istream &is, Circle &c) {\n    return is >> c.x >> c.y >> c.r;\n}\n\n\n\n/**\n * Intersection testing\n */\nPoint Projection(const Line &l, const Point &p) {\n    Point dir = l[1] - l[0];\n    Number t = dot(p - l[0], dir) / dir.abs2();\n    return l[0] + dir * t;\n}\ninline Point Reflection(const Line &l, const Point &p) {\n    return Projection(l, p) * 2.0 - p;\n}\n\ninline bool IsOrthogonal(const Line &l1, const Line &l2) {\n    return equal(dot(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\ninline bool IsIntersect(const Line &l, const Point &p) {\n    return abs(ccw(l[0], l[1], p)) != 1;\n}\ninline bool IsIntersect(const Segment &s, const Point &p) {\n    return ccw(s[0], s[1], p) == 0;\n}\ninline bool IsIntersect(const Line &l1, const Line l2) {\n    return !IsParallel(l1, l2) || IsParallel(l1, Line(l1[0], l2[0]));\n}\ninline bool IsIntersect(const Line &l, const Segment &s) {\n    return abs_cross(l[1] - l[0], s[0] - l[0]) *\n        abs_cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\ninline bool IsIntersect(const Segment &s1, const Segment &s2) {\n    return ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n        ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\ninline bool IsIntersect(const Circle &c, const Point &p) { // p is in interior or boundary\n    return (c - p).abs() <= c.r + EPS;\n}\ninline bool IsIntersect(const Circle &c, const Line &l) {\n    return IsIntersect(c, Projection(l, c));\n}\ninline bool IsIntersect(const Circle &c1, const Circle &c2) {\n    return (c1 - c2).abs() <= c1.r + c2.r && abs(c1.r - c2.r) <= (c1 - c2).abs();\n}\n\n\n/**\n * Distance and Intersection point\n */\ninline Number Distance(const Point &p1, const Point &p2) {\n    return (p1 - p2).abs();\n}\ninline Number Distance(const Line &l, const Point &p) {\n    return (p - Projection(l, p)).abs();\n}\ninline Number Distance(const Segment &s, const Point &p) {\n    if (sign(dot(s[1] - s[0], p - s[0])) == -1) return (p - s[0]).abs();\n    if (sign(dot(s[0] - s[1], p - s[1])) == -1) return (p - s[1]).abs();\n    return (p - Projection(s, p)).abs();\n}\ninline Number Distance(const Line &l1, const Line &l2) {\n    return IsIntersect(l1, l2) ? 0 : Distance(l1, l2[0]);\n}\ninline Number Distance(const Line &l, const Segment &s) {\n    if (IsIntersect(l, s)) return 0.0;\n    return std::min(Distance(l, s[0]), Distance(l, s[1]));\n}\ninline Number Distance(const Segment &s1, const Segment &s2) {\n    if (IsIntersect(s1, s2)) return 0.0;\n    return std::min({Distance(s1, s2[0]), Distance(s1, s2[1]),\n                Distance(s2, s1[0]), Distance(s2, s1[1])});\n}\n\nPoint CrossPoint(const Line &s1, const Line &s2) {\n    Point base = s2[1] - s2[0];\n    Number d1 = abs(abs_cross(base, s1[0] - s2[0]));\n    Number d2 = abs(abs_cross(base, s1[1] - s2[0]));\n    Number t = d1 / (d1 + d2);\n    return s1[0] + (s1[1] - s1[0]) * t;\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c1, const Circle &c2) {\n    Number d = Distance(c1, c2);\n    Number rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2.0 * d);\n    Number rs = sqrt(c1.r * c1.r - rc * rc);\n    Point diff = (c2 - c1) / d;\n    return std::make_pair(c1 + diff * Point(rc, rs), c1 + diff * Point(rc, -rs));\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c, const Line &l) {\n    assert(true);\n    Point mid = Projection(l, c);\n    Point e = (l[1] - l[0]) / (l[1] - l[0]).abs();\n    Number len = sqrt(c.r * c.r - (mid - c).abs2());\n    return std::make_pair(mid + e * len, mid - e * len);\n}\n\n\nint main()\n{\n    std::cout << std::fixed << std::setprecision(15);\n\n    Circle c;\n    Line l;\n    int q;\n\n    std::cin >> c >> q;\n\n    while (q--) {\n        std::cin >> l;\n        auto ans = CrossPoint(c, l);\n        std::cout << ans.first << ' ' << ans.second << '\\n';\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, int> pci;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 100010;\n\nconstexpr double eps=1e-9;\n\ninline int sgn(double x){\n    if(x<-eps) return -1;\n    if(x>eps) return 1;\n    return 0;\n}\n\ninline bool EQ(double x, double y){\n    return sgn(x-y)==0;\n}\n\ninline bool GE(double x, double y){\n    return sgn(x-y)==1;\n}\n\ninline bool LE(double x, double y){\n    return sgn(x-y)==-1;\n}\n\ninline bool GEQ(double x, double y){\n    return sgn(x-y)>=0;\n}\n\ninline bool LEQ(double x, double y){\n    return sgn(x-y)<=0;\n}\n\nstruct Point{\n    double x, y;\n    Point(double x, double y): x(x), y(y){}\n\n    Point operator+(const Point &p){\n        return {x+p.x, y+p.y};\n    }\n\n    Point operator-(const Point &p){\n        return {x-p.x, y-p.y};\n    }\n\n    Point operator*(const double k){\n        return {k*x, k*y};\n    }\n\n    Point operator/(const double k){\n        return {x/k, y/k};\n    }\n\n    double operator*(const Point &p){\n        return x*p.x+y*p.y;\n    }\n\n    double operator^(const Point &p){\n        return x*p.y-y*p.x;\n    }\n\n    bool operator==(const Point &p){\n        return EQ(x, p.x) && EQ(y, p.y);\n    }\n};\n\nusing Vec=Point;\nusing Polygon=vector<Point>;\n\ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n\ndouble abs(Point p){\n    return sqrt(norm(p));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nPoint proj(Point a, Vec v, Point p){\n    double t=v*(p-a)/norm(v);\n    return a+v*t;\n}\n\nPoint refl(Point a, Vec v, Point p){\n    return proj(a, v, p)*2-p;\n}\n\nconstexpr int CCW_COUNTER_CLOCKWISE=1;\nconstexpr int CCW_CLOCKWISE=-1;\nconstexpr int CCW_ONLINE_BACK=-2;\nconstexpr int CCW_ONLINE_FRONT=2;\nconstexpr int CCW_ON_SEGMENT=0;\n\ninline int ccw(Point a, Point b, Point c){\n    Vec v=b-a, w=c-a;\n    if(GE(v^w, 0)) return CCW_COUNTER_CLOCKWISE;\n    if(LE(v^w, 0)) return CCW_CLOCKWISE;\n    if(LE(v*w, 0)) return CCW_ONLINE_BACK;\n    if(LE((a-b)*(c-b), 0)) return CCW_ONLINE_FRONT;\n    return CCW_ON_SEGMENT;\n}\n\nbool isParallel(Vec v, Vec w){\n    return EQ(v^w, 0);\n}\n\nbool isOrthogonal(Vec v, Vec w){\n    return EQ(v*w, 0);\n}\n\nbool intersectSS(Point a, Point b, Point c, Point d){\n    return ccw(a, b, c)*ccw(a, b, d)<=0 && ccw(c, d, a)*ccw(c, d, b)<=0;\n}\n\nPoint getCrossPointLL(Point a, Vec v, Point b, Vec w){\n    double t=((b-a)^w)/(v^w);\n    return a+v*t;\n}\n\ndouble getDistanceLP(Point a, Vec v, Point p){\n    return abs(v^(p-a)/abs(v));\n}\n\ndouble getDistanceSP(Point a, Point b, Point p){\n    if(LE((b-a)*(p-a), 0)) return abs(p-a);\n    if(LE((a-b)*(p-b), 0)) return abs(p-b);\n    return getDistanceLP(a, b-a, p);\n}\n\ndouble getDistanceLL(Point a, Vec v, Point b, Vec w){\n    if(isParallel(v, w)) return getDistanceLP(a, v, b);\n    return 0;\n}\n\ndouble getDistanceLS(Point a, Vec v, Point c, Point d){\n    Point b=a+v;\n    if(ccw(a, b, c)*ccw(a, b, d)<=0) return 0;\n    return min(getDistanceLP(a, v, c), getDistanceLP(a, v, d));\n}\n\ndouble getDistanceSS(Point a, Point b, Point c, Point d){\n    if(intersectSS(a, b, c, d)) return 0;\n    return min({getDistanceSP(a, b, c), getDistanceSP(a, b, d),\n                getDistanceSP(c, d, a), getDistanceSP(c, d, b)});\n}\n\nint intersectCC(Point c1, double r1, Point c2, double r2){\n    if(r1<r2){\n        swap(c1, c2);\n        swap(r1, r2);\n    }\n    double d=abs(c1-c2), r=r1+r2;\n    if(GE(d, r)) return 4;\n    if(EQ(d, r)) return 3;\n    if(EQ(d+r2, r1)) return 1;\n    if(LE(d+r2, r1)) return 0;\n    return 2;\n}\n\nbool intersectCL(Point c, double r, Point a, Vec v){\n    return LEQ(getDistanceLP(a, v, c), r);\n}\n\nbool intersectCS(Point c, double r, Point a, Point b){\n    return LEQ(getDistanceSP(a, b, c), r) && GEQ(max(abs(a-c), abs(b-c)), r);\n}\n\nPolygon getCrossPointCL(Point c, double r, Point a, Vec v){\n    Polygon ps;\n    Point p=proj(a, v, c);\n    double t=sqrt(max(0.0, (r*r-norm(p-c))/norm(v)));\n    ps.push_back(p+v*t);\n    if(!EQ(t, 0)) ps.push_back(p-v*t);\n    return ps;\n}\n\nint main(){\n    double cx, cy, r;\n    scanf(\"%lf%lf%lf\", &cx, &cy, &r);\n    Point c(cx, cy);\n    int q;\n    scanf(\"%d\\n\", &q);\n    while(q--){\n        double x1, y1, x2, y2;\n        scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n        Point a(x1, y1), b(x2, y2);\n        Polygon ps=getCrossPointCL(c, r, a, b-a);\n        if(ps.size()==1){\n            printf(\"%.20lf %.20lf %.20lf %.20lf\\n\", ps[0].x, ps[0].y, ps[0].x, ps[0].y);\n        }\n        else{\n            if(EQ(ps[0].x, ps[1].x) && GE(ps[0].y, ps[1].y)) swap(ps[0], ps[1]);\n            if(GE(ps[0].x, ps[1].x)) swap(ps[0], ps[1]);\n            printf(\"%.20lf %.20lf %.20lf %.20lf\\n\", ps[0].x, ps[0].y, ps[1].x, ps[1].y);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Point Vector;\ntypedef Segment Line;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/abs(base);\n  return s.p1+base*t;\n}\n\nPoint p;\ndouble r;\nSegment s;\n\nPoint rotate( Point a, double si,double co){\n  return Point(a.x*co-a.y*si,a.x*si+a.y*co);\n}\n\nvector<Point> solve(){\n  vector<Point> res;\n  Point q=project(s,p);\n  double d=sqrt(r*r-abs(p-q)*abs(p-q));\n  Vector base=s.p1-s.p2;\n  res.push_back(q+base*(d/abs(base)));\n  res.push_back(q-base*(d/abs(base)));\n  return res;\n}\n\nint main(){\n  cin>>p.x>>p.y>>r;\n  int tc;\n  cin>>tc;\n  for(int i=0;i<tc;i++){\n    cin>>s.p1.x>>s.p1.y>>s.p2.x>>s.p2.y;\n    vector<Point> t=solve();\n    printf(\"%.8f %.8f %.8f %.8f\\n\",t[0].x,t[0].y,t[1].x,t[1].y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct point{\n    double  x,y;\n    point(){};\n    point(double x,double y):x(x),y(y){}\n    point operator + (point p){\n        return point(x+p.x,y+p.y);\n    }\n    point operator - (point p){\n        return point(x-p.x,y-p.y);\n    }\n    point operator * (double k){\n        return point(x*k,y*k);\n    }\n    point operator / (double k){\n        return point(x/k,y/k);\n    }\n};\n\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(point a,point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(point p)\n{\n    return p.x*p.x+p.y*p.y;\n}\ndouble ABS(point p)\n{\n    return sqrt(norm(p));\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/norm(base);\n    return a+(base*r);\n}\n\npair<point,point>getcrosspoints(point a,int r,point b,point c)\n{\n    point pr=project(b,c,a);\n    point e=(b-c)/ABS(b-c);\n    double base=sqrt(r*r*1.0-norm(pr-a));\n    e=e*base;\n    return make_pair(pr+e,pr-e);\n}\n\nint main()\n{\n    point a;\n    int temp;\n    cin>>a.x>>a.y>>temp;\n    int q;\n    cin>>q;\n    point c,d;\n    for(int i=0;i<q;i++){\n        cin>>c.x>>c.y>>d.x>>d.y;\n        pair<point,point>res=getcrosspoints(a,temp,c,d);\n        printf(\"%.7f %.7f %.7f %.7f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´?????????????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶????????????????????¬\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°????????????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//?????¨??´???????????????2??????\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//????´???°2D///////////A???)///////////\ntypedef complex<double> comp;\ntypedef vector<comp> cvec;\n//????´???????\ndouble dot(comp a,comp b){return real(b*conj(a));}\n//????´???????\ndouble cross(comp a,comp b){return imag(b*conj(a));}\ndouble Area(cvec &a){\n  double b=0;int n=a.size();\n  for(int i=0;i<n;i++)\n    b+=cross(a[i],a[(i+1==n?0:i+1)]);\n  return abs(b/2.0);\n}\n////how to use(exp)/////////////////////\n//  double a,b; cvec t; cin>>n;       //\n// while(n--){                        //\n//    cin>>a>>b;                      //\n//    t.push_back(comp(a,b));         //\n//  }printf(\"%.11f\\n\",Area(t));       //\n////////////////////////////////////////\nseg scan(){\n  seg a;\n  scanf(\"%lf%lf%lf%lf\",&a.p1.x,&a.p1.y,&a.p2.x,&a.p2.y);\n  return a;\n}\n\nint main(){\n  Circle o;\n  cin>>o.c.x>>o.c.y>>o.r;\n  int n;\n  cin>>n;\n  while(n--){\n    seg a;\n    a=scan();\n    seg p=getCrossPoint(o,a);\n    if(p.p1.x>p.p2.x){\n      Point t;\n      t=p.p1;\n      p.p1=p.p2;\n      p.p2=t;\n    }\n    else if(p.p1.x==p.p2.x&&p.p1.y>p.p2.y){\n      Point t;\n      t=p.p1;\n      p.p1=p.p2;\n      p.p2=t;\n    }\n    printf(\"%.9f %.9f %.9f %.9f\\n\",p.p1.x,p.p1.y,p.p2.x,p.p2.y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn(s1.p1 + (s1.p2 - s1.p1) * t);\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn(make_pair(pr - e * base, pr + e * base));\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tCircle circle;\n\tcin >> circle.c.x >> circle.c.y >> circle.r;\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tLine line;\n\t\tcin >> line.p1.x >> line.p1.y >> line.p2.x >> line.p2.y;\n\t\tpair<Point, Point> pp = getCrossPoints(circle, line);\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", pp.first.x, pp.first.y, pp.second.x, pp.second.y);\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(::abs(x), ::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n\n//robust less\nbool rless(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    if (sgn(cross(l.vec(), m.vec())) == 0) {\n        r = l.s;\n        if (ccw(l.s, l.t, m.s) % 2 == 0) return -1;\n        return 0;\n    }\n    D t = cross(l.vec(), l.t - m.s) / cross(l.vec(), m.vec());\n    r = m.s + m.vec() * t;\n    return 1;\n}\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / (v.x*v.x + v.y*v.y));\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v+di, v-di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n//共通内接線\nint internal_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(c.r + d.r, di) == 1) return 0;\n    D th = acos((c.r+d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p - P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p - P::polar(d.r, ar+th);\n    if (sgn(di, c.r + d.r) == 0) return 1;\n    return 2;\n}\n\n//共通外接線\nint external_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(abs(c.r - d.r), di) == 1) return 0;\n    assert(sgn(di)); // prohibit same circles\n    D th = acos((c.r-d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p + P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p + P::polar(d.r, ar+th);\n    if (sgn(di, abs(c.r - d.r)) == 0) return 1;\n    return 2;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    D x, y, r;\n    cin >> x >> y >> r;\n    C c = C(P(x, y), r);\n    \n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        P p1, p2;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        L l;\n        crossLC(L(p1, p2), c, l);\n        if (!rless(l.s, l.t)) swap(l.s, l.t);\n        cout << l.s.x << \" \" << l.s.y << \" \" << l.t.x << \" \" << l.t.y << endl;\n    }\n    \n/*    C c1, c2;\n    D x, y, r;\n    cin >> x >> y >> r; c1 = C(P(x, y), r);\n    cin >> x >> y >> r; c2 = C(P(x, y), r);\n\n    L l1, l2;\n    int z;\n    V<P> res;\n    z = internal_tangent(c2, c1, l1, l2);\n    if (z >= 1) res.push_back(l1.t);\n    if (z >= 2) res.push_back(l2.t);\n    z = external_tangent(c2, c1, l1, l2);\n    if (z >= 1) res.push_back(l1.t);\n    if (z >= 2) res.push_back(l2.t);\n\n    sort(begin(res), end(res), rless);\n    for (auto p: res) {\n        cout << p.x << \" \" << p.y << endl;\n    }*/\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\n\nclass Point {\npublic:\n\tld x, y;\n\tPoint() {\n\t\tx = y = 0.0;\n\t}\n\tPoint(ld x, ld y) :\n\t\t\tx(x), y(y) {\n\t}\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(ld a) {\n\t\treturn Point(x * a, y * a);\n\t}\n\tPoint operator /(ld a) {\n\t\treturn Point(x / a, y / a);\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c;\n\tld r;\n\tCircle(Point c = Point(), ld r = 0.0) :\n\t\t\tc(c), r(r) {\n\t}\n};\n\nld dot(Point p1, Point p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\n\nld norm(Point p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nld abs(Point p) {\n\treturn sqrt(norm(p));\n}\n\nPoint project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tld r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Segment l) {\n\tPoint pr = project(l, c.c);\n\tPoint e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tld base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n\n\tint cx, cy, r;\n\tscanf(\"%d %d %d\", &cx, &cy, &r);\n\tPoint cp(cx, cy);\n\tCircle c(cp, r);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint p1x, p1y, p2x, p2y;\n\t\tscanf(\"%d %d %d %d\", &p1x, &p1y, &p2x, &p2y);\n\t\tPoint p1(p1x, p1y);\n\t\tPoint p2(p2x, p2y);\n\t\tSegment s(p1, p2);\n\t\tpair<Point, Point> pair = getCrossPoints(c, s);\n\n\t\tcout << fixed << setprecision(10) << pair.first.x << \" \" << pair.first.y << pair.second.x << \" \" << pair.second.y << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y = 0.0): x(x),y(y) {}\n\tPoint operator + (Point p){\n\t\treturn Point(x + p.x,y + p.y);\n\t}\n\tPoint operator - (Point p){\n\t\treturn Point(x - p.x,y - p.y);\n\t}\n\tPoint operator * (double lambda){\n\t\treturn Point(x * lambda,y * lambda);\n\t}\n\tPoint operator / (double lambda){\n\t\treturn Point(x / lambda,y / lambda);\n\t}\n\tPoint neg(){\n\t\treturn Point(-x,-y);\n\t}\n\tdouble norm(){\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs_(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator == (const Point &p)const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point &p)const\n\t{\n\t\tif(abs(x - p.x) < EPS) return y < p.y;\n\t\telse return x < p.x;\n\t}\n};\ntypedef Point Vector;\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1 = Point(),Point p2 = Point()): p1(p1),p2(p2) {}\n};\ntypedef Segment Line;\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(),double r = 0.0): c(c),r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble dot(Vector a,Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble det(Vector a,Vector b){\n\treturn a.x * b.y - b.x * a.y;\n}\nbool vertical(Line l1,Line l2){\n\treturn abs(dot(l1.p2 - l1.p1,l2.p2 - l2.p1)) < EPS;\n}\nbool parallel(Line l1,Line l2){\n\treturn abs(det(l1.p2 - l1.p1,l2.p2 - l2.p1)) < EPS;\n}\nPoint proj(Point p,Line l){\n\tVector a = l.p2 - l.p1;\n\tdouble r = dot(a,p - l.p1) / a.norm();\n\treturn l.p1 + a * r;\n}\nPoint ref(Point p,Line l){\n\tPoint A = proj(p,l);\n\treturn A + (A - p);\n}\nint ccw(Segment/*Directed Segment*/ s,Point p){//\n\tVector a = s.p2 - s.p1,b = p - s.p1;\n\tif(det(a,b) > EPS) return 1;//COUNTER_CLOCKWISE\n\telse if(det(a,b) < -EPS) return -1;//CLOCKWISE\n\telse if(dot(a,b) < -EPS) return 2;//ONLINE_BACK\n\telse if(a.norm() < b.norm() - EPS) return -2;//ONLINE_FRONT\n\telse return 0;//ON_SEGMENT\n}\nbool intersect(Segment s1,Segment s2){\n\treturn ccw(s1,s2.p1) * ccw(s1,s2.p2) <= 0 && ccw(s2,s1.p1) * ccw(s2,s1.p2) <= 0;\n}\ndouble disSP(Segment s,Point p){\n\tVector a = s.p2 - s.p1;\n\tif(dot(a,p - s.p1) < EPS) return (p - s.p1).abs_();\n\tif(dot(a.neg(),p - s.p2) < EPS) return (p - s.p2).abs_();\n\treturn abs(det(a,p - s.p1) / a.abs_());\n}\ndouble disSS(Segment s1,Segment s2){\n\tif(intersect(s1,s2)) return 0;\n\treturn min(min(disSP(s1,s2.p1),disSP(s1,s2.p2)),min(disSP(s2,s1.p1),disSP(s2,s1.p2)));\n}\nPoint crossSS(Segment s1,Segment s2){//make sure s1 intersect s2!\n\tVector a = s2.p2 - s2.p1;\n\tdouble d1 = abs(det(a,s1.p1 - s2.p1));\n\tdouble d2 = abs(det(a,s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\nvector <Point> crossCL(Circle o,Line l){\n\tPoint A = proj(o.c,l);\n\tVector a = l.p2 - l.p1, e = a / a.abs_();\n\tdouble AP = sqrt(o.r * o.r - (A - o.c).norm());\n\tvector <Point> res;\n\tres.push_back(A + e * AP);\n\tres.push_back(A - e * AP);\n\treturn res;\n}\nint main(){\n\tCircle o; Line l;\n\tscanf(\"%lf%lf%lf\",&o.c.x,&o.c.y,&o.r);\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tscanf(\"%lf%lf%lf%lf\",&l.p1.x,&l.p1.y,&l.p2.x,&l.p2.y);\n\t\tvector <Point> ans = crossCL(o,l);\n\t\tsort(ans.begin(),ans.end());\n\t\tfor(int i=0;i<(int)ans.size();i++){\n\t\t\tprintf(\"%.10f %.10f%c\",ans[i].x,ans[i].y,i == (int)ans.size() - 1 ? '\\n' : ' ');\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (lt(a,b) || equal(a,b))\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\nPoint operator * (const Point &a,const Point &b){ return Point(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); }\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Line{\n  Point s,t;\n  Line(){}\n  Line(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Line &l,const Point &p){\n  Vector b = l.t-l.s;\n  double t = dot(p-l.s,b)/norm(b);\n  return l.s+b*t;\n}\n\ndouble distanceLP(const Line &l,const Point &p){\n  return abs(p-projection(l,p));\n}\n\nstruct Circle{\n  Point p;\n  double r;\n  Circle(){}\n  Circle(Point p,double r) : p(p),r(r) {}\n};\n\nvector<Point> crosspointCL(const Circle &c,const Line &l){\n  vector<Point> res;\n  double d = distanceLP(l,c.p);\n  if(le(d,c.r)){\n    Point p = projection(l,c.p);\n    Vector v = (l.t - l.s) / abs(l.t - l.s);\n    d = sqrt(c.r*c.r-d*d);\n    res.push_back(p - v*d);\n    res.push_back(p + v*d);\n  }\n  return res;\n}\n\nint main(){\n  Circle c;\n  int Q;\n  cin >> c.p >> c.r >> Q;\n  while(Q--){\n    Line l;\n    cin >> l.s >> l.t;\n    vector<Point> cp = crosspointCL(c,l);\n    printf(\"%.10f %.10f %.10f %.10f\\n\",cp[0].x,cp[0].y,cp[1].x,cp[1].y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\ndouble getDistanceLP(Line, Point);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q;\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\n\t\tif (ans.first.x < ans.second.x) {\n\t\t\tans.first.show();\n\t\t\tcout << \" \";\n\t\t\tans.second.show();\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tif (equals(ans.first.x - ans.second.x, 0.0)) {\n\t\t\t\tif (ans.first.y < ans.second.y) {\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}else {\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tans.second.show();\n\t\t\t\tcout << \" \";\n\t\t\t\tans.first.show();\n\t\t\t\tcout << endl;\n\t\t\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <complex>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ninline bool equals(double a, double b) { return abs(b - a) < EPS; }\n\nusing Point = complex<double>;\nnamespace std { bool operator < (const Point &a, const Point &b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); } }\ninline double dot(const Point &a, const Point &b) { return real(a) * real(b) + imag(a) * imag(b); }\ninline double cross(const Point &a, const Point &b) { return real(a) * imag(b) - imag(a) * real(b); }\n\nstruct Line\n{\n    Point a, b;\n    Line(Point a, Point b) : a(a), b(b) {}\n};\nstruct Segment : Line { Segment(Point a, Point b) : Line(a, b) {} };\nstruct Circle\n{\n    Point p; double r;\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\ninline bool isParallel(const Line &a, const Line &b) { return equals(cross(a.b - a.a, b.b - b.a), 0.0); }\ninline bool isOrthogonal(const Line &a, const Line &b) { return equals(dot(a.a - a.b, b.a - b.b), 0.0); }\ntemplate<typename T = Line>\ninline Point getProjection(const T &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\ninline Point getReflection(const Line &l, const Point &p) { return p + (getProjection(l, p) - p) * 2.0; }\n//位置関係\ninline int ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n//点、直線、線分の交差\ninline bool isIntersect(const Line &l, const Point &p) { return abs(ccw(l.a, l.b, p)) != 1; }\ninline bool isIntersect(const Line &l, const Line &m) { return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS; }\ninline bool isIntersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }\ninline bool isIntersect(const Line &l, const Segment &s) { return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS; }\ninline bool isIntersect(const Segment &s, const Segment &t) { return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0; }\n//距離\ninline double getDistance(const Point &a, const Point &b) { return abs(a - b); }\ninline double getDistance(const Line &l, const Point &p) { return abs(p - getProjection(l, p)); }\ninline double getDistance(const Segment &s, const Point &p)\n{\n    Point r = getProjection(s, p);\n    if(isIntersect(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\ninline double getDistance(const Line &l, const Line &m) { return isIntersect(l, m) ? 0 : getDistance(l, m.a); }\ninline double getDistance(const Segment &s1, const Segment &s2)\n{\n    if(isIntersect(s1, s2)) return 0;\n    return min({getDistance(s1, s2.a), getDistance(s1, s2.b), getDistance(s2, s1.a), getDistance(s2, s1.b)});\n}\ninline double getDistance(const Line &l, const Segment &s)\n{\n    if(isIntersect(l, s)) return 0;\n    return min(getDistance(l, s.a), getDistance(l, s.b));\n}\ninline bool isIntersect(const Circle &c, const Point &p) { return abs(abs(p - c.p) - c.r) < EPS; }\ninline bool isIntersect(const Circle &c, const Line &l) { return getDistance(l, c.p) <= c.r + EPS; }\ninline int isIntersect(const Circle &c, const Segment &l)\n{\n    if(norm(getProjection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n    auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = getProjection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n}\n//２つの円の共通接線の数\ninline int isIntersect(Circle c1, Circle c2)\n{\n    if(c1.r < c2.r) swap(c1, c2);\n    double d = abs(c1.p - c2.p);\n    if(c1.r + c2.r < d) return 4; //離れている\n    if(equals(c1.r + c2.r, d)) return 3; //外接する\n    if(c1.r - c2.r < d) return 2;//交わる\n    if(equals(c1.r - c2.r, d)) return 1;//内接する\n    return 0;//どちらかが内包する\n}\n//交差する点\ninline Point getCrossPoint(const Line &l, const Line &m)\n{\n    double a = cross(l.b - l.a, m.b - m.a), b = cross(l.b - l.a, l.b - m.a);\n    if(equals(abs(a), 0.0) and equals(abs(b), 0.0)) return m.a;\n    return m.a + (m.b - m.a) * b / a;\n}\ninline Point getCrossPoint(const Segment &l, const Segment &m) { return getCrossPoint(Line(l), Line(m)); }\npair<Point, Point> getCrossPoint(const Circle &c, const Line l) // 円と直線の交点\n{\n    assert(isIntersect(c, l));\n    Point pr = getProjection(l, c.p);\n    Point e = (l.b - l.a) / abs(l.b - l.a);\n    if(equals(getDistance(l, c.p), c.r)) return make_pair(pr, pr);\n    double base = sqrt(c.r * c.r - norm(pr - c.p));\n    return make_pair(pr - e * base, pr + e * base);\n}\npair<Point, Point> getCrossPoint(const Circle &c, const Segment &l) //円と線分の交点\n{\n    Line aa = Line(l.a, l.b);\n    if(isIntersect(c, l) == 2) return getCrossPoint(c, aa);\n    auto res = getCrossPoint(c, aa);\n    if(dot(l.a - res.first, l.b - res.first) < 0) res.second = res.first;\n    else res.first = res.second;\n    return res;\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(8);\n    double x, y, r; cin >> x >> y >> r;\n    Circle c = Circle(Point(x, y), r);\n    int q; cin >> q;\n    while(q--)\n    {\n        double x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n        auto res = getCrossPoint(c, Line(Point(x1, y1), Point(x2, y2)));\n        Point a = res.first, b = res.second;\n        if(a < b) {}\n        else swap(a, b);\n        cout << a.real() << \" \" << a.imag() << \" \" << b.real() << \" \" << b.imag() << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tld d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nint main()\n{\n\tint q;\n\tld x, y, r, x1, x2, y1, y2;\n\tcout << fixed << setprecision(9);\n\tcin >> x >> y >> r;\n\tCircle c = { (Point) { x, y }, r };\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tLine l = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tauto res = is_lc(c, l);\n\t\tsort(res.begin(), res.end(), [](const Point& l, const Point& r) { return l.real() < r.real() ? true : l.real() == l.real() && l.imag() < r.imag() ? true : false; });\n\t\tcout << res[0].real() << ' ' << res[0].imag() << ' ' << res[1].real() << ' ' << res[1].imag() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vd = vector<double>;\nusing vvi = vector<vi>;\n\nconstexpr int MOD = 1000000007;\n\n// Data structures.\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point(const Point& p) : x(p.x), y(p.y) {}\n\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n\n    bool operator<(const Point& p) const { return x != p.x ? x < p.x : y < p.y; }\n    bool operator==(const Point& p) const { return fabs(x - p.x) < 1e-10 && fabs(y - p.y) < 1e-10; }\n\n    static double norm(const Point& p) { return sqrt(p.x * p.x + p.y * p.y); }\n    static double dot(const Point& p1, const Point& p2) { return p1.x * p2.x + p1.y * p2.y; }\n    static double cross(const Point& p1, const Point& p2) { return p1.x * p2.y - p1.y * p2.x; }\n};\n\nstruct Segment {\n    Point s, t;\n};\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(double cx = 0.0, double cy = 0.0, double r = 0.0) : c(cx, cy), r(r) {}\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ndouble distance(const Line& l, const Point& p) {\n    return abs(Point::cross(l.t - l.s, p - l.s)) / Point::norm(l.t - l.s);\n}\n\nPoint norm_vector(const Point& v) {\n    double norm = Point::norm(v);\n    return Point(v.y / norm, -v.x / norm);\n}\n\nPoint project(const Point& p1, const Point& p2, const Point& p) {\n    double dot = Point::dot(p2 - p1, p - p1);\n    double norm = Point::norm(p2 - p1);\n    return Point(p2 - p1) * dot / (norm * norm) + p1;\n}\n\nvector<Point> cross_point(const Circle& c, const Line& l) {\n    vector<Point> ans;\n\n    double d = distance(l, c.c);\n    Point vec = Point(l.t - l.s) / Point::norm(l.t - l.s);\n    Point mid = project(l.s, l.t, c.c);\n    double norm = sqrt(c.r * c.r - d * d);\n\n    ans.push_back(mid + vec * norm);\n    ans.push_back(mid - vec * norm);\n\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n    Circle c(cx, cy, r);\n\n    int q;\n    cin >> q;\n\n    rep(i, 0, q) {\n        Line l;\n        cin >> l.s.x >> l.s.y >> l.t.x >> l.t.y;\n        vector<Point> ps = cross_point(c, l);\n        sort(ps.begin(), ps.end());\n        printf(\"%.10f %.10f %.10f %.10f\\n\", ps[0].x, ps[0].y, ps[1].x, ps[1].y);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef long long lint;\ntypedef pair<int,int> P;\nconst int    INF=(int)1e9;\nconst int    MOD=(int)1e9+7;\nconst double EPS=(double)1e-10;\nconst int    dx[]={-1,0,0,1};\nconst int    dy[]={0,-1,1,0};\nstruct Accelerate_Cin{\n    Accelerate_Cin(){\n        cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);\n    };\n};\n\n//幾何学テンプレート\n\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\n//点\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0):x(x), y(y){};\n\n  Point operator + (Point p) {return Point (x+p.x, y+p.y);}\n  Point operator - (Point p) {return Point (x-p.x, y-p.y);}\n  Point operator * (double a) {return Point(a*x, a*y);}\n  Point operator / (double a) {return Point(x/a,y/a);}\n\n  double abs(){return sqrt(norm());}\n  double norm(){return x*x+y*y;}\n\n  bool operator < (const Point &p)const{\n    return x!=p.x ? x<p.x:y<p.y;\n  }\n  bool operator > (const Point &p)const{\n    return x!=p.x ? x>p.x:y>p.y;\n  }\n  bool operator == (const Point &p)const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\n//ベクトル\ntypedef Point Vector;\n\n//内積\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\n\n//外積\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\n//線分\nstruct Segment{Point p1,p2;};\n\n//直線\ntypedef Segment Line;\n\n//円\nclass Circle{\npublic:\n  Point c;   //中心\n  double r;  //半径\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\n//多角形\ntypedef vector<Point> Polygon;\n\n\n//円と直線の交点を求める。\n\n//二つの線分の交差判定をする。\n//3点の位置関係を調べる。\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>EPS)   return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)  return CLOCKWISE;\n  if(dot(a,b)<-EPS)    return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//ある点から、直線/線分に対する射影を求める。\nPoint project(Segment s, Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/base.norm();\n  return s.p1+base*r;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n  double base=sqrt(c.r*c.r-(pr-c.c).norm());\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\nsigned main(){\n  double cx,cy,r;cin>>cx>>cy>>r;\n  Circle c={Point{cx,cy},r};\n  int q;cin>>q;\n  for(int i=0;i<q;i++){\n    double x0,y0,x1,y1;cin>>x0>>y0>>x1>>y1;\n    Point p1={x0,y0},p2={x1,y1};\n    Line l={p1,p2};\n    Point ans1,ans2;\n    tie(ans1,ans2)=getCrossPoints(c,l);\n    vector<Point>v;\n    v.push_back(ans1);\n    v.push_back(ans2);\n    sort(v.begin(),v.end());\n    cout<<fixed<<setprecision(15)<<v[0].x<<\" \"<<v[0].y<<\" \"<<v[1].x<<\" \"<<v[1].y<<endl;\n\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nstruct Point{\n    double x,y;\n    Point(double _x=0,double _y=0):x(_x),y(_y){}\n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    double norm(){return x*x+y*y;}//模的平方\n    double ABS() {return sqrt(norm());}//模\n};\n//线段\nstruct Segment{\n    Point p1,p2;\n};\n//点积\ndouble dot(Point a,Point b){\n    return a.x*b.x+a.y*b.y;\n}\n//叉积\ndouble cross(Point a,Point b){\n    return a.x*b.y-a.y*b.x;\n}\nPoint Projection(Point p,Segment s){\n    Point alp=p-s.p1;\n    Point beta=s.p2-s.p1;\n    double res=dot(alp,beta)/beta.norm();\n    return s.p1+(beta*res);\n}\n//点到直线的距离\ndouble PLDis(Point a,Segment s){\n    double A=s.p1.y-s.p2.y;\n    double B=s.p2.x-s.p1.x;\n    double C=(s.p1.x-s.p2.x)*s.p1.y-(s.p1.y-s.p2.y)*s.p1.x;\n    return fabs(A*a.x+B*a.y+C)/sqrt((A*A+B*B));\n}\nbool cmp(Point a,Point b){\n    if(a.x==b.x) return a.y<b.y;\n    return a.x<b.x;\n}\n//计算圆和直线的交点\nvector<Point> CCL(Segment s,Point o,double r){\n    vector<Point> res;\n    Point x=Projection(o,s);\n    double dis=PLDis(o,s);\n    if(dis>r){//距离>r没有交点\n        return res;\n    }\n    if(dis==r){\n        res.push_back(x);\n        res.push_back(x);\n    }\n    double beta=sqrt(r*r-dis*dis);\n    Point pp=s.p2-s.p1;\n    pp=pp/pp.ABS();//单位向量\n    Point ans1=x-pp*beta;\n    Point ans2=x+pp*beta;\n    res.push_back(ans1);\n    res.push_back(ans2);\n    return res;\n}\nint main(){\n    Point c;\n    double r;\n    scanf(\"%lf %lf %lf\",&c.x,&c.y,&r);\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n        Segment s;\n        scanf(\"%lf %lf %lf %lf\",&s.p1.x,&s.p1.y,&s.p2.x,&s.p2.y);\n        vector<Point> ans=CCL(s,c,r);\n        sort(ans.begin(),ans.end(),cmp);\n        printf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\n#include <cstdio>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repc(i, s, n) for (int i = (s); i <= (n); i++)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define rrepc(i, s, n) for (int i = (s); i >= (n); i--)\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n/*================================================\n\tGeometry\n================================================*/\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment { Point p1, p2; };\ntypedef Segment Line;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0); }\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n\ndouble Distance_PP(Point a, Point b) { return (a - b).abs(); }\ndouble Distance_PL(Point p, Line l) { return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs(); }\ndouble Distance_PS(Point p, Segment s) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn Distance_PL(p, s);\n}\ndouble Distance_SS(Segment s1, Segment s2) {\n\tdouble op1, op2, op3, op4, distance;\n\n\tif (intersect(s1, s2)) return 0.0;\n\n\top1 = Distance_PS(s1.p1, s2);\n\top2 = Distance_PS(s1.p2, s2);\n\top3 = Distance_PS(s2.p1, s1);\n\top4 = Distance_PS(s2.p2, s1);\n\n\tdistance = min(op1, op2);\n\tdistance = min(distance, op3);\n\tdistance = min(distance, op4);\n\n\treturn distance;\n}\nPoint CrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\npair<Point, Point> CrossPoint(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\nint main()\n{\n\tint q;\n\tpair<Point, Point> ans;\n\tCircle c;\n\tLine l;\n\n\tcin >> c.c.x >> c.c.y >> c.r;\n\tcin >> q;\n\trep(i, q) {\n\t\tcin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n\t\tans = CrossPoint(c, l);\n\t\tif (ans.first.x < ans.second.x ||\n\t\t\t(ans.first.x == ans.second.x) && (ans.first.y < ans.second.y)) {\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\", ans.first.x, ans.first.y, ans.second.x, ans.second.y);\n\t\t}\n\t\telse printf(\"%.10lf %.10lf %.10lf %.10lf\\n\", ans.second.x, ans.second.y, ans.first.x, ans.first.y);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Header {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long readtype;\ntypedef long long var;\ntypedef long double let;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n\n#ifdef LOCAL_LOGGER\n#define logger(...) fprintf(stderr, __VA_ARGS__)\n#define abortif(v, ...) if (v) {logger(\"Error in Line %d, Function '%s()'.\\nInfo: \", __LINE__, __FUNCTION__); logger(__VA_ARGS__); exit(0);}\n#else\n#define logger(...);\n#define abortif(v, ...);\n#endif\n/* }}} */\n\nconst let eps = 1e-8;\n\nint sign(let x) { return (x < -eps) ? -1 : (x > eps ? 1 : 0); }\n\nstruct Point {\n  let x, y;\n  friend bool operator < (Point a, Point b) {\n    if (sign(a.x - b.x) == 0) return sign(a.y - b.y) < 0; \n    return sign(a.x - b.x) < 0;\n  }\n  friend Point operator + (Point a, Point b) {\n    return (Point) {a.x + b.x, a.y + b.y};\n  }\n  friend Point operator - (Point a, Point b) {\n    return (Point) {a.x - b.x, a.y - b.y};\n  }\n  Point operator ~ () {\n    return (Point) {x, -y};\n  }\n\n  Point Rotate(let sink, let cosk) {\n    return (Point) {\n      x * cosk - y * sink, x * sink + y * cosk\n    };\n  }\n\n  let dist() {\n    return sqrt(x * x + y * y);\n  }\n\n  Point Rotate(Point k) {\n    let z = k.dist();\n    return Rotate(k.y / z, k.x / z);\n  }\n\n  void EchoWith(char c) {\n    printf(\"%.8Lf %.8Lf\", x, y);\n    putchar(c);\n  }\n};\n\ntypedef Point Vec;\n\nstruct Line {\n  Point p;\n  Vec v;\n\n  Line(Point a, Point b) {\n    p = a, v = b - a;\n  }\n  \n  Line operator - (Vec k) {\n    return (Line) {p - k, v};\n  }\n\n  Line Rotate(let sink, let cosk) {\n    return (Line) {\n      p.Rotate(sink, cosk), v.Rotate(sink, cosk)\n    };\n  }\n\n  Line Rotate(Vec v) {\n    let z = v.dist();\n    return Rotate(v.y / z, v.x / z);\n  }\n\n};\n\nstruct Circle {\n  Point o;\n  let r;\n  friend pair<Point, Point> Cross(Circle c, Line l) {\n    Point a = (l.p - c.o).Rotate(~l.v);\n    if (sign(a.y - c.r) > 0 || sign(a.y + c.r) < 0) {\n    }\n      \n    if (sign(a.y - c.r) == 0) {\n      Point res = ((Point) {0, c.r}).Rotate(l.v) + c.o;\n      return make_pair(res, res);\n    }\n\n    if (sign(a.y + c.r) == 0) {\n      Point res = ((Point) {0, -c.r}).Rotate(l.v) + c.o;\n      return make_pair(res, res);\n    }\n\n    let y = a.y, xp = sqrt(c.r * c.r - y * y);\n    Point lc = (Point) {-xp, y}.Rotate(l.v) + c.o, \n          rc = (Point) {xp, y}.Rotate(l.v) + c.o;\n    return make_pair(lc, rc);\n  }\n};\n\nPoint ReadPoint() {\n  Point p;\n  scanf(\"%Lf%Lf\", &p.x, &p.y);\n  return p;\n}\n\nLine ReadLine() {\n  Point a = ReadPoint(), b = ReadPoint();\n  return (Line) {a, b};\n}\n\nCircle ReadCircle() {\n  Point p = ReadPoint();\n  let c;\n  scanf(\"%Lf\", &c);\n  return (Circle) {p, c};\n}\n\nint main() {\n// #ifndef ONLINE_JUDGE\n//   freopen(\"CGL_7_D.in\", \"r\", stdin);\n//   freopen(\"CGL_7_D.out\", \"w\", stdout);\n// #endif\n// #ifdef LOCAL_LOGGER\n//   freopen(\"CGL_7_D.log\", \"w\", stderr);\n// #endif\n  Circle c = ReadCircle();\n  int q = read();\n  while (q--) {\n    Line l = ReadLine();\n    pair<Point, Point> res = Cross(c, l);\n    if (res.second < res.first) \n      swap(res.first, res.second);\n    res.first.EchoWith(' ');\n    res.second.EchoWith('\\n');\n  }\n  return 0;\n}\n\n/* ==== Makefile ==== {{{\nCompileAndRun:\n\tmake Compile\n\tmake Run\n\nCompile:\n\tg++ -o CGL_7_D CGL_7_D.cpp -g -Wall -DLOCAL_LOGGER\n\nCompileUF:\n\tg++ -o CGL_7_D CGL_7_D.cpp -g -Wall -DLOCAL_LOGGER -fsanitize=undefined\n\nRun:\n\t./CGL_7_D < CGL_7_D.in > CGL_7_D.out\n==================\n}}} */\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n#define Rep(i,a,b)  for (int i=(a);i<(b);i++)\n#define rep(i,n)    for (int i=0;i<(n);i++)\n#define all(x)      (x).begin(), (x).end()\n\n#define ll long long\n\ntuple<double, double, double, double> cross_point(double cx, double cy, double r, double lx1, double ly1, double lx2, double ly2) {\n\tdouble a = ly2 - ly1;\n\tdouble b = lx1 - lx2;\n\tdouble c = -(a * lx1 + b * ly1);\n\tdouble l = sqrt(pow(lx2 - lx1, 2.0) + pow(ly2 - ly1, 2.0));\n\tdouble ex = (lx2 - lx1) / l;\n\tdouble ey = (ly2 - ly1) / l;\n\tdouble vx = -ey;\n\tdouble vy = ex;\n\tdouble k = -(a * cx + b * cy + c) / (a * vx + b * vy);\n\tdouble xp = cx + k * vx;\n\tdouble yp = cy + k * vy;\n\tdouble s = sqrt(r * r - k * k);\n\tdouble x1  = xp - s * ex;\n\tdouble y1  = yp - s * ey;\n\tdouble x2  = xp + s * ex;\n\tdouble y2  = yp + s * ey;\n\treturn make_tuple(x1, y1, x2, y2);\n}\n\nint main()\n{\n\tdouble cx, cy, r;\n\tint q;\n\tdouble lx1, lx2, ly1, ly2;\n\tcin >> cx >> cy >> r >> q;\n\trep (i, q) {\n\t\tcin >> lx1 >> ly1 >> lx2 >> ly2;\n\t\tif (lx1 > lx2 || (lx1 == lx2 && ly1 > ly2) ) {\n\t\t\tswap(lx1, lx2);\n\t\t\tswap(ly1, ly2);\n\t\t}\n\t\tauto ret = cross_point(cx, cy, r, lx1, ly1, lx2, ly2);\n\t\tdouble ans[4];\n\t\tans[0] = get<0>(ret);\n\t\tans[1] = get<1>(ret);\n\t\tans[2] = get<2>(ret);\n\t\tans[3] = get<3>(ret);\n\t\tstring space = \"\";\n\t\trep (i, 4) {\n\t\t\tcout << fixed << setprecision(8) << space << ans[i];\n\t\t\tspace = \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct point{\n    double  x,y;\n    point(){};\n    point(double x,double y):x(x),y(y){}\n    point operator + (point p){\n        return point(x+p.x,y+p.y);\n    }\n    point operator - (point p){\n        return point(x-p.x,y-p.y);\n    }\n    point operator * (double k){\n        return point(x*k,y*k);\n    }\n    point operator / (double k){\n        return point(x/k,y/k);\n    }\n};\n\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(point a,point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(point p)\n{\n    return p.x*p.x+p.y*p.y;\n}\ndouble ABS(point p)\n{\n    return sqrt(norm(p));\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/norm(base);\n    return a+(base*r);\n}\n\npair<point,point>getcrosspoints(point a,double r,point b,point c)\n{\n    point pr=project(b,c,a);\n    point e=(b-c)/ABS(b-c);\n    double base=sqrt(r*r-norm(pr-a));\n    e=e*base;\n    return make_pair(pr+e,pr-e);\n}\n\nint main()\n{\n    point a;\n    double temp;\n    cin>>a.x>>a.y>>temp;\n    int q;\n    cin>>q;\n    point c,d;\n    for(int i=0;i<q;i++){\n        cin>>c.x>>c.y>>d.x>>d.y;\n        pair<point,point>res=getcrosspoints(a,temp,c,d);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\nusing Point = complex< double >;\n\nPoint operator*(const Point &p, const double &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() {}\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(double A, double B, double C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() {}\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() {}\n\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\ndouble cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ndouble distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  double d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\ndouble distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\ndouble distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr + e * base, pr - e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nbool merge_if_able(Segment &s1, Segment s2) {\n  if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid merge_segments(vector< Segment > &segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\ndouble area2(const Polygon &p) {\n  double A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\ndouble convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\ndouble closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n\n  function< double(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return 1e18;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  double g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    double h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  Circle c;\n  cin >> c.p >> c.r;\n  int N;\n  cin >> N;\n  while(N--) {\n    Line l;\n    cin >> l;\n    auto pp = crosspoint(c, l);\n    if(pp.second < pp.first)swap(pp.first, pp.second);\n    cout << fixed << setprecision(10);\n    cout << real(pp.first) << \" \" << imag(pp.first) << \" \" << real(pp.second) << \" \" << imag(pp.second) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<float.h>\n#include<cstdio>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) fabs((a)-(b))<DBL_EPSILON*fmax(1,fmax(fabs(a),fabs(b)))\n//点のクラス\nclass Point{\n    public:\n        double x,y;\n        Point(double x=0,double y=0):x(x),y(y){}\n\n        Point operator + (Point p){return Point(x+p.x,y+p.y);}\n        Point operator - (Point p){return Point(x-p.x,y-p.y);}\n        Point operator * (double a){return Point(a*x,a*y);}\n        Point operator / (double a){return Point(x/a,y/a);}\n\n        double norm(Point p){return p.x*p.x+p.y*p.y;}\n        double abs(Point p){return sqrt(norm(p));}    \n        bool operator < (const Point &p)const{\n            return x!=p.x?x<p.x:y<p.y;\n        }\n        bool operator == (const Point &p)const{\n            return equals(x,p.x)&&equals(y,p.y);\n        }\n};\ntypedef Point Vector;\nstruct Segment{ Point p1,p2; };\ntypedef Segment Line;\ndouble norm(Vector v){return v.x*v.x+v.y*v.y;} \ndouble abs(Vector v){return sqrt(norm(v));}    \n//円\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n//多角形\ntypedef vector<Point> Polygon;\n//内積\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\n//外戚\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n//直交\nbool isOrthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){ return isOrthogonal(a1-a2,b1-b2); }\nbool isOrthogonal(Segment s1,Segment s2){ return equals(dot(s1.p1-s1.p2,s2.p1-s2.p2),0.0); }\n//平行\nbool isParallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\nbool isParallel(Point a1,Point a2,Point b1,Point b2){ return isParallel(a1-a2,b1-b2); }\nbool isParallel(Segment s1,Segment s2){ return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); }\n//射影\nPoint project(Segment s,Point p){ //射影　p377\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n//反射　p379\nPoint reflect(Segment s,Point p){return p+(project(s,p)-p)*2.0;}\n//ベクトルa,bの位置関係\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return 1;//p0,p1,p2が反時計回り\n    if(cross(a,b)<-EPS) return -1;//p0,p1,p2が時計回り\n    if(dot(a,b)<-EPS) return 2;//p1,p0,p2の順で一直線\n    if(norm(a)<norm(b)) return -2;//p0,p1,p2の順で一直線\n    return 0; //p0,p2,p1の順で一直線\n}\n//交差判定　p389\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);//p1,p2,p3,p4の順で一直線になるのを除く\n}\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//交点の座標　p392\nPoint getCrossPoint(Segment s1,Segment s2){ \n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n//距離p380\ndouble getDistance(Point a,Point b){ return abs(a-b);} //点aと点b\ndouble getDistanceLP(Line l,Point p){//直線lと点p\n\treturn abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\ndouble getDistanceSP(Segment s,Point p){//線分sと点p\n\tif(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n\tif(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\treturn getDistanceLP(s,p);\n}\ndouble getDistance(Segment s1,Segment s2){ //線分s1と線分s2\n\tif(intersect(s1,s2))return 0.0;\n\treturn min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t\t\t  min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//円　交点\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    //asert(intersect(c,l));   交点を持つことの確認\n\tVector pr =project(l,c.c);\n\tVector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\nint main(){\n    int q;\n    Point p1,p2;\n    Circle c;\n    cin>>c.c.x>>c.c.y>>c.r;\n    cin>>q;\n    pair<Point,Point> pp;\n    Line l;\n    for(int i=0;i<q;i++){\n        cin>>p1.x>>p1.y>>p2.x>>p2.y;\n        l.p1=p1; l.p2=p2;\n        pp=getCrossPoints(c,l);                                 \n        if(pp.first.x>pp.second.x)swap(pp.first,pp.second);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",pp.first.x,pp.first.y,pp.second.x,pp.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 1e16;\nconst ll mod = 1000000007;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ntemplate<class T> inline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate<class T> inline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint ctoi(char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  }\n  return 0;\n}\nll factorial(ll n) {\n  if (n == 1) {\n    return 1;\n  }\n  ll ans = factorial(n-1);\n  return ans*n;\n}\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\nll lcm(ll a, ll b) {\n  return (a/gcd(a, b))*b;\n}\nbool is_prime(ll n) {\n  for (ll i = 2; i*i <= n; i++) {\n    if (n%i == 0) return false;\n  }\n  return n != 1;\n}\nll mod_pow(ll x, ll n, ll mod) {\n  if (n == 0) return 1;\n  ll res = mod_pow(x*x%mod, n/2, mod);\n  if (n & 1) res = res * x % mod;\n  return res;\n}\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\n  public:\n  double x, y;\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n  double norm() { return x*x + y*y; }\n  double abs() { return pow(norm(), 0.5); }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n};\ntypedef Point Vector;\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n}\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p-s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\ndouble cross(Point a, Point b) {\n  return a.x*b.y - a.y*b.x;\n}\nll ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0, b = p2 - p0;\n  if (cross(a, b) > EPS) return 1;\n  if (cross(a, b) < -EPS) return -1;\n  if (dot(a, b) < -EPS) return 2;\n  if (a.norm() < b.norm()) return -2;\n  return 0;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return ccw(p1, p2, p3)*ccw(p1, p2, p4)<=0 && ccw(p3, p4, p1)*ccw(p3, p4, p2)<=0;\n}\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2-l.p1, p-l.p1) / (l.p2-l.p1).abs());\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if (dot(s.p2-s.p1, p-s.p1) < 0.0) return (p - s.p1).abs();\n  if (dot(s.p1-s.p2, p-s.p2) < 0.0) return (p - s.p2).abs();\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p2-s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2-s1.p1) * t;\n}\nclass Circle {\n  public:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\npair <Point, Point> getCrossPoints(Circle c, Line l) {\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  double base = c.r*c.r - (pr-c.c).norm();\n  base = pow(base, 0.5);\n  return make_pair(pr+e*base, pr-e*base);\n}\n\nint main() {\n  Circle c;\n  cin >> c.c.x >> c.c.y >> c.r;\n  ll n;\n  cin >> n;\n  cout << fixed << setprecision(10);\n  rep(i, n) {\n    Line l;\n    cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n    pair <Point, Point> p = getCrossPoints(c, l);\n    if (p.first.x > p.second.x) {\n      Point tmp = p.first;\n      p.first = p.second;\n      p.second = tmp;\n    } else if (p.first.x == p.second.x) {\n      if (p.first.y > p.second.y) {\n        Point tmp = p.first;\n        p.first = p.second;\n        p.second = tmp;\n      }\n    }\n    cout << p.first.x << ' ' << p.first.y << ' ' << p.second.x << ' ' << p.second.y << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <iostream>\n#define X real()\n#define Y imag()\n#define EPS 1e-10\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nP projection(P a, P b){\n  return dot(a,b)/norm(b)*b;\n}\n\ndouble p_to_l_dist(P p, L l){\n  return abs(cross(l.second-l.first,p-l.first))/abs(l.first-l.second);\n}\n\nvector<P> sort_comp(vector<P> a){\n  int l = a.size();\n  vector< pair<double, double> > t(l);\n  for(int i = 0; i < l; ++i){\n    t[i].first = a[i].X;\n    t[i].second = a[i].Y;\n  }\n  sort(t.begin(),t.end());\n  for(int i = 0; i < l; ++i){\n    a[i] = P(t[i].first,t[i].second);\n  }\n  return a;\n}\n\nvector<P> cpcl(C c, L l){\n  double d = p_to_l_dist(c.first,l), r = c.second;\n  P m = l.first + projection(c.first-l.first,l.second-l.first);\n  P x = sqrt(r*r-d*d)/abs(l.second-l.first)*(l.second-l.first);\n  vector<P> cp(2,m);\n  cp[0] -= x;\n  cp[1] += x;\n  return cp;\n}\n\nint main(){\n  double x1, y1, x2, y2, r;\n  cin >> x1 >> y1 >> r;\n  C c = C(P(x1,y1),r);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i){\n    cin >> x1 >> y1 >> x2 >> y2;\n    L l;\n    l.first = P(x1,y1);\n    l.second = P(x2,y2);\n    vector<P> cp = sort_comp(cpcl(c,l));\n    printf(\"%.10lf %.10lf %.10lf %.10lf\\n\", cp[0].X, cp[0].Y, cp[1].X, cp[1].Y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\t\n\texplicit Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n\treturn sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n\treturn abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n\treturn abs(a-b);\t\n}\n\nReal dist(const Line &l,const Point &p){\n\tconst Point a = l[1]-l[0];\n\tconst Point b = p-l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n\tif(intersect(l,s)) return 0;\n\treturn min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n\tif(intersect(a,b)) return 0;\n\treturn dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n\tif(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n\tif(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n\treturn dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n\tif(intersect(a,b)) return 0;\n\treturn min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nbool intersect(const Circle &a,const Circle &b){\n\treturn sign(dist(a.c,b.c)-(a.r+b.r)) <=0\n\t\t\t&& sign(dist(a.c,b.c)-abs(a.r-b.r)) >= 0;\n}\n\nbool intersect(const Circle &c,const Segment &s){\n\treturn sign(dist(s,c.c)-c.r)<=0;\n}\n\nbool intersect(const Circle &c,const Line &l){\n\treturn sign(dist(l,c.c)-c.r)<=0;\n}\n\nbool contain(const Circle &c,const Point &p){\n\treturn sign(dist(c.c,p)-c.r) <=0;\n}\n\nPoint crosspoint(const Line &a,const Line &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs) == 0) return a[0];\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\n\n//??¬??¢?????????????????¨?????°?????????????????????Intersect?????????\nPoint crosspoint(const Segment &a,const Segment &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs)==0){\n\t\tif(intersect(a,b[0])) return b[0];\n\t\tif(intersect(a,b[1])) return b[1];\n\t\tif(intersect(b,a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h-c.r)==1){\n\t\t//nothing\n\t}else if(sign(h-c.r)==0){\n\t\tres.emplace_back(p);\t\n\t}else{\n\t\tconst Real b = sqrt(c.r*c.r-h*h);\n\t\tconst Point e = (l[1]-l[0])/abs(l[1]-l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tReal r;\n\tPoint p;\n\tcin >> p >> r;\n\tCircle c(p,r);\n\tint q;\n\tcin >> q;\n\trep(i,q){\n\t\tPoint p1,p2;\n\t\tcin >> p1 >> p2;\n\t\tvector<Point> result = crosspoint(c,Line(p1,p2));\n\t\n\t\tassert(!result.empty());\n\t\tsort(begin(result),end(result));\n\t\n\t\tcout << result.front().x << \" \" << result.front().y << \" \" << result.back().x << \" \"  << result.back().y << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#define ESP (1e-13)\nusing namespace std;\n\n//??§?¨????????§???????\ntypedef struct Point {\n\tdouble x; \n\tdouble y;\n\n\tPoint() { }\n\n\tPoint(double x, double y) :x(x), y(y) { }\n\n\tPoint operator+(const Point& p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\n\tPoint operator-(const Point& p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\n\tPoint operator*(const double& a) {\n\t\treturn Point(x*a, y*a);\n\t}\n\n\tPoint operator/(const double& a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tPoint operator=(const Point& p1) {\n\t\treturn Point(p1.x,p1.y);\n\t}\n\n};\n\n//??´??§?????????????§???????\ntypedef Point Vector;\n\n//??´???????§???????\n struct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(const Point& a,const Point& b) : p1(a),p2(b) { }\n};\n\n //??????????§???????\n typedef Line Segment;\n\n //???????§???????\n struct Circle {\n\t Point c;\n\t double r;\n\t Circle(){ }\n\t Circle(const Point& p,const double& r) : c(p),r(r) { }\n };\n\n//2??????????????¢????±?????????¢??°\ndouble abs(Point p1, Point p2) {\n\tdouble norm = (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);\n\treturn sqrt(norm);\n}\n\n//????????¢??°\ndouble product(Vector v1, Vector v2) {\n\treturn v1.x*v2.x + v1.y*v2.y;\n}\n\n//????????¢??°\ndouble cross(Vector p1, Vector p2) {\n\treturn p1.x*p2.y - p1.y*p2.x;\n}\n\n//3??????????????¢???????±?????????¢??°\nint ccw(Point p0, Point p1, Point p2) {\n\tVector v0 = p1 - p0;\n\tVector v1 = p2 - p0;\n\tif (cross(v0, v1) > ESP) return 1;   //p0,p1,p2??????????¨???????\n\tif (cross(v0, v1) < -ESP) return -1;   //p0,p1,p2???????¨???????\n\tif (product(v0, v1) < -ESP) return 2;  //p2,p0,p1????????§????????´??????\n\tif (abs(p0, p1) < abs(p0, p2)) return -2;  //p0,p1,p2????????§????????´??????\n\treturn 0;   //p2?????????(p0,p1)???\n}\n\n//??????????????´????????????????°???±?????§?¨?????±?????????¢??°\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble x = abs(base, Point(0.0, 0.0))*abs(base, Point(0.0, 0.0));\n\tdouble r = product(p - s.p1, base) / x;\n\treturn s.p1 + base*r;\n}\n\n//????????????????±??????¨??????????????????????§°????????§?¨?????±?????????¢??°\nPoint reflect(Segment s, Point p) {\n\treturn (project(s, p) - p)*2.0 + p;\n}\n\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n\treturn (ccw(p0, p1, p2)*ccw(p0, p1, p3) <= 0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n\t//?????????????????????????????¶\n}\n\n//????????????????????£??????????????????????????¢??°\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//??´?????¨???????????¢????±?????????¢??°\ndouble DistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)/abs(l.p1,l.p2));\n}\n\n//????????¨???????????¢????±?????????¢??°\ndouble DistanceSP(Segment s, Point p) {\n\tif (product(s.p2 - s.p1, p - s.p1) < -ESP) return abs(p, s.p1);\n\tif (product(s.p1 - s.p2, p - s.p2) < -ESP) return abs(p, s.p2);\n\treturn DistanceLP(s, p);\n}\n\n//2??????????????¢????±?????????¢??°\ndouble DistanceSS(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(DistanceSP(s1, s2.p1), DistanceSP(s1,s2.p2)), min(DistanceSP(s2, s1.p1), DistanceSP(s2, s1.p2)));\n}\n\n//?????´???????\\???¢????±?????????¢??°\nPoint CrossPoint(Line s1,Line s2) {\n\tdouble d1=DistanceLP(s2, s1.p1);\n\tdouble d2 = DistanceLP(s2, s1.p2);\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//?????¨??´?????????????????????????????¢??°\nbool intersect(Circle c, Line l) {\n\treturn DistanceLP(l, c.c) < c.r;\n}\n\n//?????¨??´????????????????±?????????¢??°\npair<Point, Point> CrossPoints(Circle c, Line l) {\n\tVector prpr = project(l, c.c);\n\tVector hshs = (l.p2 - l.p1)/abs(l.p2 ,l.p1);\n\tdouble base = sqrt(c.r*c.r - abs(c.c, prpr)*abs(c.c, prpr));\n\treturn make_pair(prpr - hshs*base, prpr + hshs*base);\n}\n\n//2??´??????????????¢???????±?????????¢??°???\n   //??´?????????\nbool isOrth(Vector a, Vector b) {\n\treturn abs(product(a, b)) < ESP;\n   }\nbool isOrth(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrth(a1 - a2, b1 - b2);\n}\nbool isOrth(Segment s1, Segment s2) {\n\treturn isOrth(s1.p2, s1.p1, s2.p2, s2.p1);\n}\n    //????????????\nbool isPara(Vector a, Vector b) {\n\treturn abs(cross(a, b)) < ESP;\n}\nbool isPara(Point a1, Point a2, Point b1, Point b2) {\n\treturn isPara(a1 - a2, b1 - b2);\n}\nbool isPara(Segment s1, Segment s2) {\n\treturn isPara(s1.p2, s1.p1, s2.p2, s2.p1);\n}\n\n\nint main() {\n\tCircle c;\n\tint q;\n\tcin >> c.c.x; cin >> c.c.y; cin >> c.r;\n\tcin >> q;\n\tfor (int i = 0;i < q;i++) {\n\t\tLine l;\n\t\tcin >> l.p1.x; cin >> l.p1.y;\n\t\tcin >> l.p2.x; cin >> l.p2.y;\n\t\tpair<Point, Point> crs = CrossPoints(c, l);\n\t\tcout << setprecision(12);\n\t\tif (abs(crs.first.x) < ESP) crs.first.x = 0;\n\t\tif (abs(crs.first.y) < ESP) crs.first.y = 0;\n\t\tif (abs(crs.second.x) < ESP) crs.second.x = 0;\n\t\tif (abs(crs.second.y) < ESP) crs.second.y = 0;\n\n\t\tif(crs.first.x<crs.second.x)\n\t\tcout << crs.first.x << \" \" << crs.first.y << \" \" << crs.second.x << \" \" << crs.second.y << endl;\n\t\telse if (crs.first.x>crs.second.x)\n\t\tcout << crs.second.x << \" \" << crs.second.y << \" \" << crs.first.x << \" \" << crs.first.y << endl;\n\t\telse if(crs.first.y<crs.second.y)\n\t\tcout << crs.first.x << \" \" << crs.first.y << \" \" << crs.second.x << \" \" << crs.second.y << endl;\n\t\telse\n\t\tcout << crs.second.x << \" \" << crs.second.y << \" \" << crs.first.x << \" \" << crs.first.y << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(::abs(x), ::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n\n//robust less\nbool rless(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    if (sgn(cross(l.vec(), m.vec())) == 0) {\n        r = l.s;\n        if (ccw(l.s, l.t, m.s) % 2 == 0) return -1;\n        return 0;\n    }\n    D t = cross(l.vec(), l.t - m.s) / cross(l.vec(), m.vec());\n    r = m.s + m.vec() * t;\n    return 1;\n}\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / (v.x*v.x + v.y*v.y));\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u - c.r);\n    if (si == 1) return 0;\n/*    P v = (l.t-l.s) / l.abs() * P(0, -1); //lに直行する単位ベクトル\n    v *= u;\n    if (ccw(l.s, l.t, c.p) < 0) v *= -1;*/\n    P v = project(l, c.p);\n    //vは円の中心からlへと向かう方向のベクトル\n    if (si == 0) {\n        r.s = r.t = v;\n        return 1;\n    }\n    r.s = v+P::polar(sqrt(c.r*c.r - u*u), l.arg());\n    r.t = v-P::polar(sqrt(c.r*c.r - u*u), l.arg());\n    return 2;\n}\n\n//共通内接線\nint internal_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(c.r + d.r, di) == 1) return 0;\n    D th = acos((c.r+d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p - P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p - P::polar(d.r, ar+th);\n    if (sgn(di, c.r + d.r) == 0) return 1;\n    return 2;\n}\n\n//共通外接線\nint external_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(abs(c.r - d.r), di) == 1) return 0;\n    assert(sgn(di)); // prohibit same circles\n    D th = acos((c.r-d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p + P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p + P::polar(d.r, ar+th);\n    if (sgn(di, abs(c.r - d.r)) == 0) return 1;\n    return 2;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    D x, y, r;\n    cin >> x >> y >> r;\n    C c = C(P(x, y), r);\n    \n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        P p1, p2;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        L l;\n        crossLC(L(p1, p2), c, l);\n        if (!rless(l.s, l.t)) swap(l.s, l.t);\n        cout << l.s.x << \" \" << l.s.y << \" \" << l.t.x << \" \" << l.t.y << endl;\n    }\n    \n/*    C c1, c2;\n    D x, y, r;\n    cin >> x >> y >> r; c1 = C(P(x, y), r);\n    cin >> x >> y >> r; c2 = C(P(x, y), r);\n\n    L l1, l2;\n    int z;\n    V<P> res;\n    z = internal_tangent(c2, c1, l1, l2);\n    if (z >= 1) res.push_back(l1.t);\n    if (z >= 2) res.push_back(l2.t);\n    z = external_tangent(c2, c1, l1, l2);\n    if (z >= 1) res.push_back(l1.t);\n    if (z >= 2) res.push_back(l2.t);\n\n    sort(begin(res), end(res), rless);\n    for (auto p: res) {\n        cout << p.x << \" \" << p.y << endl;\n    }*/\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < (EPS))\n#define SQR(n) ((n) * (n))\n\n#define COUNTER_CLOCKWISE (1)\n#define CLOCKWISE (-1)\n#define ONLINE_BACK (2)\n#define ONLINE_FRONT (-2)\n#define ON_SEGMENT (0)\n\nstruct Point \n{\n  double x, y;\n  \n  Point() {}\n  \n  Point(double x, double y) : x(x), y(y) {}\n  \n  void input() { scanf(\"%lf %lf\", &x, &y); }\n  void output() { printf(\"%.10f %.10f\", x, y); }\n  void outputspace() { output(); putchar(' '); }\n  void outputln() { output(); putchar('\\n'); }\n  \n  double abs() { return (sqrt(norm())); }\n  double norm() { return (x * x + y * y); }\n  \n  Point operator + (Point d) { return (Point(x + d.x, y + d.y)); }\n  Point operator - (Point d) { return (Point(x - d.x, y - d.y)); }\n  Point operator - () { return (Point(-x, -y)); }\n  Point operator * (double a) { return (Point(x * a, y * a)); }\n  Point operator / (double a) { return (Point(x / a, y / a)); }\n  \n};\n\nstruct Segment\n{\n  Point p1, p2;\n  \n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\n  void input() { p1.input(); p2.input(); }\n  \n};\n\nstruct Circle\n{\n  Point c;\n  double r;\n  Circle() {}\n  Circle(Point c, double r) : c(c), r(r) {}\n  \n  void inputcr() { c.input(); scanf(\"%lf\", &r); }\n  \n};\n\ntypedef pair < Point, Point > TwoPoint;\ntypedef Point Vector;\ntypedef vector < Point > Polygon;\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b)\n{\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n  return (a.x * b.y - a.y * b.x);\n}\n\nPoint project(Line l, Point p)\n{\n  Vector base = l.p2 - l.p1;\n  return (l.p1 + base * (dot(p - l.p1, base) / base.norm()));\n}\n\nPoint reflect(Line l, Point p)\n{\n  return (-p + project(l, p) * 2.0);\n}\n\n\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0, b = p2 - p0;\n  \n  if(cross(a, b) > EPS) return (COUNTER_CLOCKWISE);\n  if(cross(a, b) < -EPS) return (CLOCKWISE);\n  if(dot(a, b) < -EPS) return (ONLINE_BACK);\n  if(a.norm() < b.norm()) return (ONLINE_FRONT);\n  \n  return (ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n  return (intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\n\ndouble getDistanceLP(Line l, Point p)\n{\n  return (abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return ((p - s.p1).abs());\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return ((p - s.p2).abs());\n  return (getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n  double ans;\n\n  if(intersect(s1, s2)) {\n    ans = 0.0;\n  } else {\n    ans = min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n    ans = min(ans, min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)));\n  }\n\n  return (ans);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  double d1 = getDistanceLP(s2, s1.p1);\n  double d2 = getDistanceLP(s2, s1.p2);\n  \n  return (s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2)));\n}\n\nbool intersect(Circle c, Line l)\n{\n  return (getDistanceLP(l, c.c) - c.r > EPS);\n}\n\nTwoPoint getCrossPoints(Circle c, Line l)\n{\n  Vector pr, e;\n  double base;\n  if(intersect(c, l)) abort();\n  \n  pr = project(l, c.c);\n  base = sqrt(SQR(c.r) - (pr - c.c).norm());\n  e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  \n  return (make_pair(pr + (e * base), pr - (e * base)));\n}\n\nmain()\n{\n  int n;\n  Circle c;\n  \n  c.inputcr(); cin >> n;\n  for(int i = 0; i < n; i++) {\n    Line l;\n    TwoPoint tp;\n    \n    l.input();\n    tp = getCrossPoints(c, l);\n\n    tp.first.outputspace(); tp.second.outputln();\n  }\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\n\nclass Point {\npublic:\n\tld x, y;\n\tPoint() {\n\t\tx = y = 0.0;\n\t}\n\tPoint(ld x, ld y) :\n\t\t\tx(x), y(y) {\n\t}\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(ld a) {\n\t\treturn Point(x * a, y * a);\n\t}\n\tPoint operator /(ld a) {\n\t\treturn Point(x / a, y / a);\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c;\n\tld r;\n\tCircle(Point c = Point(), ld r = 0.0) :\n\t\t\tc(c), r(r) {\n\t}\n};\n\nld dot(Point p1, Point p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\n\nld norm(Point p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nld abs(Point p) {\n\treturn sqrt(norm(p));\n}\n\nPoint project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tld r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Segment l) {\n\tPoint pr = project(l, c.c);\n\tPoint e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tld base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr - e * base, pr + e * base);\n}\n\nint main() {\n\n\tint cx, cy, r;\n\tscanf(\"%d %d %d\", &cx, &cy, &r);\n\tPoint cp(cx, cy);\n\tCircle c(cp, r);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint p1x, p1y, p2x, p2y;\n\t\tscanf(\"%d %d %d %d\", &p1x, &p1y, &p2x, &p2y);\n\t\tPoint p1(p1x, p1y);\n\t\tPoint p2(p2x, p2y);\n\t\tSegment s(p1, p2);\n\t\tpair<Point, Point> pair = getCrossPoints(c, s);\n\n\t\tcout << fixed << setprecision(10) << pair.first.x << \" \" << pair.first.y << pair.second.x << \" \" << pair.second.y << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\ntypedef Segment Line;                               //??´???\ntypedef struct Circle{Point c; double r;}Circle;    //???\ntypedef vector<Point> Polygon;                      //????§???¢\n//????????????a????????????\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n//????????????a?????§??????\ndouble absolute(Vector a){\n    return sqrt(norm(a));\n}\n\n//????????????a,b?????????\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n//????????????a,b?????????\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\n//????????????a??¨b?????´?????????\n//a??¨b?????´????????´??????????????????0?????????\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a,b), 0.0);\n}\n\n//????????????a??¨b???????????????\n//a??¨b?????´????????´??????????????????0?????????\nbool isParallel(Vector a , Vector b){\n    return equals(cross(a,b), 0.0);\n}\n\n//??????s(p1p2)???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\n//??????s(p1p2)???????§°?????¨?????????p???????±????\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\n//???a,???b???????????¢\ndouble getDistance(Point a, Point b){\n    return absolute(a - b);\n}\n\n//??´???s??¨???p????????¢\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / absolute(l.p2 - l.p1));\n}\n\n//??????s(p1p2)??¨???p????????¢d????±???????\n//??\\???????????????????????§??´?????????\n//??????????????????p2-p1??¨???????????????p-p1??????????§???????90???????????§????????´???????????????-90?????????????°?????????´?????????d??????p??¨???p1??¨????????¢\n//??????????????????p1-p2??¨???????????????p-p2??????????§???????90???????????§????????´???????????????-90?????????????°?????????´?????????d??????p??¨???p2??¨????????¢\n//??????????????\\???????????????????????´??????d??????p??¨??´???p1p2????????¢\ndouble getDistanceSP(Segment s, Point p){\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absolute(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absolute(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\n\n//??????p0, p1, p2???????????????????????????p0p1???????????????p2??????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//??????S1(p1p2)??¨??????s2(p2p3)????????????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return  ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n            &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p1);\n}\n\n//??????s1??¨??????s2????????¢\n//??\\????????????????????¢????????§????????????????????????\n//????????????s1??¨??????s2????§????s2.p1????????¢\n//????????????s1??¨??????s2?????????s2.p2????????¢\n//????????????s2??¨??????s1????§????s1.p1????????¢\n//????????????s2??¨??????s1?????????s1.p2????????¢\ndouble getDistance(Segment s1, Segment s2){\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(\n               min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n               );\n}\n\n//??????s1??¨??????s2?????????????±???????\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//?????¨??????l?????????????±???????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / absolute(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????????±???????\nVector polar(double a, double r){\n    //??????a,?§????r???point????±???????\n    return Point(cos(r) * a, sin(r) * a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    Vector v = c2.c - c1.c;\n    double d = absolute(v);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d) );\n    double t = atan2(v.y, v.x);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\n\n\nint main(){\n    \n    int cx, cy;\n    double r;\n    int q;\n    int x1, y1, x2, y2;\n    \n    cin >> cx >> cy >> r >> q;\n    \n    Circle c = {Point(cx, cy), r};\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        \n        Line l = {Point(x1, y1), Point(x2, y2)};\n        \n        pair<Point, Point> ans = getCrossPoints(c, l);\n        bool flag = (ans.first.x == ans.second.x) ? ans.first.y < ans.first.y : (ans.first.x < ans.second.x) ? false : true;\n        if(flag) swap(ans.first, ans.second);\n        \n        printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", ans.first.x, ans.first.y, ans.second.x, ans.second.y);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-10\n#define Vector Point\n#define Points vector<Point>\n#define INF 2000000000\n#define DOUBLE_INF 1e50\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\n\n// Geometry Library\n// written by okuraofvegetable\n\ninline double add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint() {}\n\tPoint(double x,double y) : x(x),y(y){}\n\tPoint operator + (Point p){return Point(add(x,p.x),add(y,p.y));}\n\tPoint operator - (Point p){return Point(add(x,-p.x),add(y,-p.y));}\n\tPoint operator * (double d){return Point(x*d,y*d);}\n\tdouble dot(Point p){return add(x*p.x,y*p.y);}\n\tdouble det(Point p){return add(x*p.y,-y*p.x);}\n\tdouble norm(){return sqrt(x*x+y*y);}\n\tdouble norm2(){return x*x+y*y;}\n\tdouble dist(Point p){return ((*this)-p).norm();}\n\tdouble dist2(Point p){return sq(x-p.x)+sq(y-p.y);}\n\tVector normalize(){return (*this)*(1.0/norm());}\n\tPoint vert(){return Point(y,-x);}\n\tvoid dump(const char* msg=\"\"){printf(\"%s%.12f %.12f\\n\",msg,x,y);return;}\n\t\n\t// following functions for vector operation\n\n\t// signed area of triange (0,0) (x,y) (p.x,p.y)\n\tdouble area(Point p){\n\t\treturn (x*p.y-p.x*y)/2.0;\n\t}\n};\n// direction a -> b -> c\n// verified AOJ CGL_1_C\nenum {\n\tCOUNTER_CLOCKWISE,\n\tCLOCKWISE,\n\tONLINE_BACK,\n\tONLINE_FRONT,\n\tON_SEGMENT\n};\nint ccw(Point a,Point b,Point c){\n\tVector p = b-a;\n\tVector q = c-a;\n\tif(p.det(q)>0.0)return COUNTER_CLOCKWISE; // counter clockwise\n\tif(p.det(q)<0.0)return CLOCKWISE; // clockwise\n\tif(p.dot(q)<0.0)return ONLINE_BACK; // c--a--b online_back\n\tif(p.norm()<q.norm())return ONLINE_FRONT; // a--b--c online_front \n\treturn ON_SEGMENT;// a--c--b on_segment\n}\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point a,Point b):a(a),b(b){}\n\tbool on(Point q){\n\t\treturn (a-q).det(b-q)==0; \n\t}\n\t// folloing 2 functions verified AOJ CGL_2_A\n\tbool is_parallel(Line l){return (a-b).det(l.a-l.b)==0;}\n\tbool is_orthogonal(Line l){return (a-b).dot(l.a-l.b)==0;}\n\tPoint intersection(Line l){\n\t\tassert(!is_parallel(l));\n\t\treturn a+(b-a)*((l.b-l.a).det(l.a-a)/(l.b-l.a).det(b-a));\n\t}\n\t// projection of p to this line\n\t// verified AOJ CGL_1_A\n\tPoint projection(Point p){\n\t\treturn (b-a)*((b-a).dot(p-a)/(b-a).norm2())+a;\n\t}\n\tdouble distance(Point p){\n\t\tPoint q = projection(p);\n\t\treturn p.dist(q);\n\t}\n\t// reflection point of p onto this line\n\t// verified AOJ CGL_1_B\n\tPoint refl(Point p){\n\t\tPoint proj = projection(p);\n\t\treturn p+((proj-p)*2.0);\n\t}\n};\nstruct Segment{\n\tPoint a,b;\n\tSegment(){}\n\tSegment(Point a,Point b):a(a),b(b){}\n\tLine line(){\n\t\treturn Line(a,b);\n\t}\n\tbool on(Point q){\n\t\treturn ((a-q).det(b-q)==0&&(a-q).dot(b-q)<=0); \n\t}\n\t// verified AOJ CGL_2_B\n\tbool is_intersect(Segment s){\n\t\tif(line().is_parallel(s.line())){\n\t\t\tif(on(s.a)||on(s.b))return true;\n\t\t\tif(s.on(a)||s.on(b))return true;\n\t\t\treturn false;\n\t\t}\n\t\tPoint p = line().intersection(s.line());\n\t\tif(on(p)&&s.on(p))return true;\n\t\telse return false;\n\t}\n\tbool is_intersect(Line l){\n\t\tif(line().is_parallel(l)){\n\t\t\tif(l.on(a)||l.on(b))return true;\n\t\t\telse return false;\n\t\t}\n\t\tPoint p = line().intersection(l);\n\t\tif(on(p))return true;\n\t\telse return false;\n\t}\n\t// following 2 distance functions verified AOJ CGL_2_D\n\tdouble distance(Point p){\n\t\tdouble res = DOUBLE_INF;\n\t\tPoint q = line().projection(p);\n\t\tif(on(q))res = min(res,p.dist(q));\n\t\tres = min(res,min(p.dist(a),p.dist(b)));\n\t\treturn res;\n\t}\n\tdouble distance(Segment s){\n\t\tif(is_intersect(s))return 0.0;\n\t\tdouble res = DOUBLE_INF;\n\t\tres = min(res,s.distance(a));\n\t\tres = min(res,s.distance(b));\n\t\tres = min(res,this->distance(s.a));\n\t\tres = min(res,this->distance(s.b));\n\t\treturn res;\n\t}\n};\n\n// Polygon \n\ntypedef vector<Point> Polygon;\n// verified AOJ CGL_3_A\n// Polygon don't need to be convex\ndouble area(Polygon& pol){\n\tPoints vec;\n\tdouble res = 0.0;\n\tint M = pol.size();\n\tfor(int i=0;i<M;i++){\n\t\tres += (pol[i]-pol[0]).area(pol[(i+1)%M]-pol[0]);\t\n\t}\n\treturn res;\n}\nbool is_convex(Polygon& pol){\n\tint n = pol.size();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ccw(pol[i],pol[i+1],pol[(i+2)%n])==CLOCKWISE){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n// vecrified AOJ CGL_3_C\nenum {OUT,ON,IN};\nint contained(Polygon& pol,Point p){\n\tint n = pol.size();\n\tPoint outer(1e9,p.y);\n\tSegment s = Segment(outer,p);\n\tint cnt = 0;\n\tfor(int i=0;i<n;i++){\n\t\tSegment e = Segment(pol[i],pol[(i+1)%n]);\n\t\tif(e.on(p))return ON;\n\t\tVector a = pol[i]-p;\n\t\tVector b = pol[(i+1)%n]-p;\n\t\tif(a.y>b.y)swap(a,b);\n\t\tif(a.y<=0.0&&b.y>0.0){\n\t\t\tif(a.det(b)<0.0)cnt++;\n\t\t}\n\t}\n\tif((cnt&1)==1)return IN;\n\telse return OUT;\n}\n// compare function for convex_hull\n// sort points by (x-y) lexicographical order.\n// you can change (y-x) order with no change in convex_hull\nbool comp(const Point& p,const Point& q){\n\tif(p.x!=q.x)return p.x<q.x;\n\telse return p.y<q.y;\n}\n// Convex hull\n// if you want not to contain points on boundary,\n// change while(....<=0.0)\n// verified AOJ CGL_4_A\nPolygon convex_hull(vector<Point> ps){\n\tsort(all(ps),comp);\n\tint k = 0;\n\tint n = ps.size();\n\tPolygon qs(2*n);\n\tfor(int i=0;i<n;i++){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0.0)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0.0)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n// Caliper method\n// verified AOJ CGL_4_B\ndouble convex_diameter(Polygon& cv){\n\tint i=0,j=0;\n\tint n = cv.size();\n\tfor(int k=0;k<n;k++){\n\t\tif(!comp(cv[i],cv[k]))i=k;\n\t\tif(comp(cv[j],cv[k]))j=k;\n\t}\n\tint si=i,sj=j;\n\tdouble res = 0.0;\n\twhile(i!=sj||j!=si){\n\t\tres = max(res,cv[i].dist(cv[j]));\n\t\tif((cv[(i+1)%n]-cv[i]).det(cv[(j+1)%n]-cv[j])<0.0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn res;\n}\n// Cut conovex polygon by a line and return left polygon\n// verified AOJ CGL_4_C\nPolygon convex_cut(Polygon& cv,Line l){\n\tint n = cv.size();\n\tPolygon left; \n\tfor(int i=0;i<n;i++){\n\t\tSegment e = Segment(cv[i],cv[(i+1)%n]);\n\t\tif(ccw(l.a,l.b,cv[i])!=CLOCKWISE)left.pb(cv[i]);\n\t\tif(e.is_intersect(l)){\n\t\t\tif(!e.line().is_parallel(l)){\n\t\t\t\tleft.pb(e.line().intersection(l));\n\t\t\t}\n\t\t}\n\t}\n\treturn left;\n}\n// distance between closest pair\n// verified CGL_5_A\nbool comp_y(const Point& p,const Point& q){\n\treturn p.y<q.y;\n}\ndouble closest_pair(vector<Point>::iterator a,int n){\n\tif(n<=1)return DOUBLE_INF;\n\tint m = n/2;\n\tdouble x = (a+m)->x;\n\tdouble d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n\tinplace_merge(a,a+m,a+n,comp_y);\n\tvector<Point> b;\n\tfor(int i=0;i<n;i++){\n\t\tdouble ax = (a+i)->x;\n\t\tdouble ay = (a+i)->y;\n\t\tif(abs(ax-x)>=d)continue;\n\t\tfor(int j=0;j<b.size();j++){\n\t\t\tdouble dx = ax-b[b.size()-1-j].x;\n\t\t\tdouble dy = ay-b[b.size()-1-j].y;\n\t\t\tif(dy>=d)break;\n\t\t\td = min(d,sqrt(dx*dx+dy*dy));\n\t\t}\n\t\tb.pb(*(a+i));\n\t}\n\treturn d;\n}\ndouble closest_pair(vector<Point> a){\n\tsort(all(a),comp);\n\treturn closest_pair(a.begin(),(int)a.size());\n}\n\n// Circle\n\n// relation between two circles\n// each value as integer corresponds to\n// the number of common tangent lines\nenum {\n\tINCLUDE,\n\tINSCRIBED,         // in japanese \"naisetsu\"\n\tINTERSECT,\n\tCIRCUMSCRIBED,     // in japanese \"gaisetsu\"\n\tNOT_CROSS,\n};\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(){}\n\tCircle(Point c,double r):center(c),r(r){}\n\t// verified AOJ CGL_7_A\n\tint is_intersect(Circle c){\n\t\tdouble cd = center.dist(c.center);\n\t\tif(EQ(cd,r+c.r))return CIRCUMSCRIBED;\n\t\tif(EQ(cd,abs(r-c.r)))return INSCRIBED;\n\t\tif(cd>r+c.r)return NOT_CROSS;\n\t\telse if(cd>abs(r-c.r))return INTERSECT;\n\t\telse return INCLUDE;\n\t}\n\tPoints intersection(Line l){\n\t\tPoints res;\n\t\tdouble d = l.distance(center);\n\t\tif(EQ(d,r)){\n\t\t\tres.pb(l.projection(center));\n\t\t}else if(d<r){\n\t\t\tdouble k = sqrt(r*r-d*d);\n\t\t\tVector v = (l.a-l.b).normalize()*k;\n\t\t\tres.pb(l.projection(center)+v);\n\t\t\tres.pb(l.projection(center)-v);\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// for input\nPoint input_point(){\n\tPoint p;\n\tcin >> p.x >> p.y;\n\treturn p;\n}\nSegment input_segment(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Segment(a,b);\n}\nLine input_line(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Line(a,b);\n}\nCircle input_circle(){\n\tPoint c = input_point();\n\tdouble d;\n\tcin >> d;\n\treturn Circle(c,d);\n}\n\nint main(){\n\tCircle c1 = input_circle();\n\tint q;\n\tcin >> q;\n\tfor(int i=0;i<q;i++){\n\t\tLine l = input_line();\n\t\tPoints ans = c1.intersection(l);\n\t\tsort(all(ans),comp);\n\t\tif(ans.size()==1){\n\t\t\tprintf(\"%.12f %.12f %.12f %.12f\\n\",ans[0].x,ans[0].y,ans[0].x,ans[0].y);\n\t\t}else if(ans.size()==2){\n\t\t\tprintf(\"%.12f %.12f %.12f %.12f\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k * x, k * y);\n\t}\n\tPoint operator / (double k) {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {};\n\n\tdouble norm() {\n\t\treturn (p2 - p1).x * (p2 - p1).x + (p2 - p1).y * (p2 - p1).y;\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tPoint project(Point p) { \n\t\tVector a = Vector(p.x - p1.x, p.y - p1.y);\n\t\tVector b = Vector(p2.x - p1.x, p2.y - p1.y);\n\t\treturn p1 + (p2 - p1) * (dot(a, b) / b.norm()); //???????????????\n\t}\n\n\tPoint refrect(Point p) {\n\t\tPoint pro = project(p);\n\t\treturn pro * 2 - p;\n\t}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tdouble cx, cy, r;\n\tCircle(double cx, double cy, double r): cx(cx), cy(cy), r(r) {}\n\t\n\tSegment crossPoints(Line l) {\n\t\tPoint c = Point(cx, cy);\n\t\tPoint p = l.project(c);\n\t\tdouble d2 = (p - c).norm();\n\t\tdouble t = sqrt(r * r - d2);\n\t\tPoint p1 = p - (l.p2 - l.p1) / l.abs() * t;\n\t\tPoint p2 = p + (l.p2 - l.p1) / l.abs() * t;\n\t\tif (p1 < p2) return Segment(p1, p2);\n\t\telse return Segment(p2, p1);\n\t}\n};\n\nint main() {\n\tint cx, cy, r, q;\n\tcin >> cx >> cy >> r >> q;\n\tCircle C = Circle(cx, cy, r);\n\tint x0, y0, x1, y1;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1;\n\t\tLine l = Segment(Point(x0, y0), Point(x1, y1));\n\t\tSegment s = C.crossPoints(l);\n\t\tcout << fixed << setprecision(6) << s.p1.x << ' ' << s.p1.y << ' ' << s.p2.x << ' ' << s.p2.y << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/geometry/cross_circle_line.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\"\n#define ERROR 1e-6\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\n#line 1 \"test/geometry/../../library/geometry/geometry.cpp\"\nconst double eps = 1e-10;\ninline bool eq(double a, double b) { return fabs(a - b) < eps; }\nconst double pi = acos(-1);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(x * k, y * k); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n};\nistream &operator>>(istream &is, Point &p) {\n    is >> p.x >> p.y;\n    return is;\n}\nostream &operator<<(ostream &os, Point p) {\n    os << fixed << setprecision(10) << p.x << \" \" << p.y;\n    return os;\n}\nbool sort_x(Point a, Point b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool sort_y(Point a, Point b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nbool sort_t(Point a, Point b) { return atan2(a.y, a.x) < atan2(b.y, a.y); }\nPoint rotate(double theta, const Point &p) {\n    return Point(cos(theta) * p.x - sin(theta) * p.y, sin(theta) * p.x + cos(theta) * p.y);\n}\ndouble radian_to_degree(double r) { return (r * 180.0 / pi); }\ndouble degree_to_radian(double d) { return (d * pi / 180.0); }\n\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Line(double A, double B, double C) { // Ax + By = C\n        if (eq(A, 0))\n            a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0))\n            a = Point(C / A, 0), b = Point(C / A, 1);\n        else\n            a = Point(0, C / B), b = Point(C / A, 0);\n    }\n    Point vec() const { return b - a; }\n};\nstruct Segment : Line {\n    Segment() {}\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(Point p, double r) : p(p), r(r) {}\n};\ndouble norm(const Point &a) { return a.x * a.x + a.y * a.y; }\ndouble abs(const Point &a) { return sqrt(norm(a)); }\ndouble cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\n\nPoint project(Line l, Point p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\nPoint reflect(Line l, Point p) { return p + (project(l, p) - p) * 2; }\nbool parallel(Line a, Line b) { return eq(cross(a.vec(), b.vec()), 0.0); }\nbool orthogonal(Line a, Line b) { return eq(dot(a.vec(), b.vec()), 0.0); }\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > eps)\n        return +1; // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -eps)\n        return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0)\n        return +2; // \"ONLINE_BACK\"\n    if (norm(b) < norm(c))\n        return -2; // \"ONLINE_FRONT\"\n    return 0;      // \"ON_SEGMENT\"\n}\nbool intersect(const Line &l, const Point &p) { return abs(ccw(l.a, l.b, p)) != 1; }\nbool intersect(const Line &l, const Line &m) { return !parallel(l, m) || abs(cross(l.vec(), m.b - l.a)) < eps; }\nbool intersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }\nbool intersect(const Line &l, const Segment &s) { return cross(l.vec(), s.a - l.a) * cross(l.vec(), s.b - l.a) < eps; }\ndouble distance(const Line &l, const Point &p);\nbool intersect(const Circle &c, const Line &l) { return distance(l, c.p) <= c.r + eps; }\nbool intersect(const Circle &c, const Point &p) { return abs(abs(p - c.p) - c.r) < eps; }\nbool intersect(const Segment &s, const Segment &t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nint intersect(const Circle &c, const Segment &l) {\n    if (norm(project(l, c.p) - c.p) - c.r * c.r > eps)\n        return 0;\n    auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n    if (d1 < c.r + eps && d2 < c.r + eps)\n        return 0;\n    if ((d1 < c.r - eps && d2 > c.r + eps) || (d1 > c.r + eps && d2 < c.r - eps))\n        return 1;\n    const Point h = project(l, c.p);\n    if (dot(l.a - h, l.b - h) < 0)\n        return 2;\n    return 0;\n}\nint intersect(Circle c1, Circle c2) {\n    if (c1.r < c2.r)\n        swap(c1, c2);\n    double d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d)\n        return 4; // do not cross\n    if (eq(c1.r + c2.r, d))\n        return 3; // circumscribed\n    if (c1.r - c2.r < d)\n        return 2; // intersect\n    if (eq(c1.r - c2.r, d))\n        return 1; // inscribed\n    return 0;     // one circle includes another\n}\n\ndouble distance(const Point &a, const Point &b) { return abs(a - b); }\ndouble distance(const Line &l, const Point &p) { return abs(p - project(l, p)); }\ndouble distance(const Line &l, const Line &m) { return intersect(l, m) ? 0 : distance(l, m.a); }\ndouble distance(const Segment &s, const Point &p) {\n    Point r = project(s, p);\n    if (intersect(s, r))\n        return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\ndouble distance(const Segment &a, const Segment &b) {\n    if (intersect(a, b))\n        return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\ndouble distance(const Line &l, const Segment &s) {\n    if (intersect(l, s))\n        return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\nPoint crosspoint(const Line &l, const Line &m) {\n    double A = cross(l.vec(), m.vec());\n    double B = cross(l.vec(), l.b - m.a);\n    if (eq(abs(A), 0.0) && eq(abs(B), 0.0))\n        return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\nPoint crosspoint(const Segment &l, const Segment &m) { return crosspoint(Line(l), Line(m)); }\npair<Point, Point> crosspoint(const Circle &c, const Line l) {\n    Point pr = project(l, c.p);\n    Point e  = (l.b - l.a) / abs(l.b - l.a);\n    if (eq(distance(l, c.p), c.r))\n        return {pr, pr};\n    double base = sqrt(c.r * c.r - norm(pr - c.p));\n    return {pr - e * base, pr + e * base};\n}\npair<Point, Point> crosspoint(const Circle &c, const Segment &l) {\n    Line aa = Line(l.a, l.b);\n    if (intersect(c, l) == 2)\n        return crosspoint(c, aa);\n    auto ret = crosspoint(c, aa);\n    if (dot(l.a - ret.first, l.b - ret.first) < 0)\n        ret.second = ret.first;\n    else\n        ret.first = ret.second;\n    return ret;\n}\npair<Point, Point> crosspoint(const Circle &c1, const Circle &c2) {\n    double d = abs(c1.p - c2.p);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = atan2(c2.p.y - c1.p.y, c2.p.x - c1.p.x);\n    Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n    Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n    return {p1, p2};\n}\nvector<Point> convex_hull(vector<Point> &p) {\n    int n = (int)p.size(), k = 0;\n    if (n <= 2)\n        return p;\n    sort(p.begin(), p.end(), sort_x);\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n        while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < -eps)\n            --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < -eps)\n            --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n#line 9 \"test/geometry/cross_circle_line.test.cpp\"\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    Circle c;\n    cin >> c.p.x >> c.p.y >> c.r;\n    int q;\n    cin >> q;\n    vector<Line> ls;\n    for (int i = 0; i < q; ++i) {\n        Point a, b;\n        cin >> a >> b;\n        ls.emplace_back(a, b);\n    }\n    for (int i = 0; i < q; ++i) {\n        auto ret = crosspoint(c, ls[i]);\n        if (!sort_x(ret.first, ret.second))\n            swap(ret.first, ret.second);\n        cout << fixed << setprecision(8) << ret.first << \" \" << ret.second << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <array>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nusing Number = double;\n\nconst Number EPS = 1e-10;\nconst Number INF = 1e10;\nconst Number PI = acos(-1.0);\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\n// change between degree and radian\ninline Number to_radian(const Number degree) { return degree * PI / 180.0; }\ninline Number to_degree(const Number radian) { return radian * 180.0 / PI; }\n\n\n/**\n * Point in two dimensional\n */\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    // Arithmetic operator between points\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(const Point &rhs) const { // cross product between points\n        return Point(this->x * rhs.x - this->y * rhs.y,\n                     this->x * rhs.y + this->y * rhs.x);\n    }\n\n    // Unary operator and compound assignment operator\n    Point operator-() const {\n        return Point(-this->x, -this->y);\n    }\n    Point& operator+=(const Point &rhs) {\n        return *this = *this + rhs;\n    }\n    Point& operator-=(const Point &rhs) {\n        return *this = *this - rhs;\n    }\n\n    // Arithmetic operator between point and number\n    Point operator*(Number rhs) const {\n        return Point(this->x * rhs, this->y * rhs);\n    }\n    Point operator/(Number rhs) const {\n        return Point(this->x / rhs, this->y / rhs);\n    }\n\n    // Comparison operation\n    bool operator==(const Point &rhs) const {\n        return sign(this->x - rhs.x) == 0 && sign(this->y - rhs.y) == 0;\n    }\n    bool operator<(const Point &rhs) const {\n        return (this->x < rhs.x) || (this->x == rhs.x && this->y < rhs.y);\n    }\n\n    // Other operator\n    Number abs(void) const {\n        return sqrt(this->x * this->x + this->y * this->y);\n    }\n    Number abs2(void) const {\n        return this->x * this->x + this->y * this->y;\n    }\n    Number arg(void) const {\n        return atan2(this->y, this->x);\n    }\n    Number dot(const Point &rhs) {\n        return this->x * rhs.x + this->y * rhs.y;\n    }\n    Point rotate90(void) const {\n        return Point(-this->y, this->x);\n    }\n    Point rotate(double angle) const {\n        return Point(cos(angle) * this->x - sin(angle) * this->y,\n                     sin(angle) * this->x + cos(angle) * this->y);\n    }\n\n};\ninline Number dot(const Point &p1, const Point &p2) {\n    return p1.x * p2.x + p1.y * p2.y;\n}\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n// Output of a point\nstd::ostream& operator<<(std::ostream &os, const Point &p) {\n    return os << p.x << ' ' << p.y;\n}\n// Input of a point\nstd::istream& operator>>(std::istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\n\n// Counter-Clockwise predicate (a, b, c)\nenum CCW {\n    COUNTER_CLOCKWISE = 1,      // counter clockwise\n    CLOCKWISE         = -1,     // clockwise\n    ONLINE_FRONT      = 2,      // a--c--b on line\n    ONLINE_BACK       = -2,      // c--a--b on line\n    ON_SEGMENT        = 0,     // a--b--c on line\n};\nCCW ccw(const Point &a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (abs_cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (abs_cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0)       return ONLINE_BACK;\n    if (b.abs2() < c.abs2())   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n/**\n * Line in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0] >> l[1];\n}\nstd::ostream& operator<<(std::ostream &os, const Line &l) {\n    return os << l[0] << ' ' << l[1];\n}\ninline CCW ccw(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p);\n}\n\n\n/**\n * Segment in two dimensional\n */\nclass Segment : public Line {\npublic:\n    Segment() {}\n    Segment(const Point &p1, const Point &p2) : Line(p1, p2) {}\n};\n\n\n/**\n * Circle in two dimensional\n */\nclass Circle : public Point {\npublic:\n    Number r;\n    Circle() {}\n    Circle(const Point &p, Number r = 0.0) : Point(p), r(r) {}\n};\n// Input of a circle\nstd::istream& operator>>(std::istream &is, Circle &c) {\n    return is >> c.x >> c.y >> c.r;\n}\n\n\n\n/**\n * Intersection testing\n */\nPoint Projection(const Line &l, const Point &p) {\n    Point dir = l[1] - l[0];\n    Number t = dot(p - l[0], dir) / dir.abs2();\n    return l[0] + dir * t;\n}\ninline Point Reflection(const Line &l, const Point &p) {\n    return Projection(l, p) * 2.0 - p;\n}\n\ninline bool IsOrthogonal(const Line &l1, const Line &l2) {\n    return equal(dot(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\ninline bool IsIntersect(const Line &l, const Point &p) {\n    return abs(ccw(l[0], l[1], p)) != 1;\n}\ninline bool IsIntersect(const Segment &s, const Point &p) {\n    return ccw(s[0], s[1], p) == 0;\n}\ninline bool IsIntersect(const Line &l1, const Line l2) {\n    return !IsParallel(l1, l2) || IsParallel(l1, Line(l1[0], l2[0]));\n}\ninline bool IsIntersect(const Line &l, const Segment &s) {\n    return abs_cross(l[1] - l[0], s[0] - l[0]) *\n        abs_cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\ninline bool IsIntersect(const Segment &s1, const Segment &s2) {\n    return ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n        ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\ninline bool IsIntersect(const Circle &c, const Point &p) { // p is in interior or boundary\n    return (c - p).abs() <= c.r + EPS;\n}\ninline bool IsIntersect(const Circle &c, const Line &l) {\n    return IsIntersect(c, Projection(l, c));\n}\ninline bool IsIntersect(const Circle &c1, const Circle &c2) {\n    return (c1 - c2).abs() <= c1.r + c2.r && abs(c1.r - c2.r) <= (c1 - c2).abs();\n}\n\n\n/**\n * Distance and Intersection point\n */\ninline Number Distance(const Point &p1, const Point &p2) {\n    return (p1 - p2).abs();\n}\ninline Number Distance(const Line &l, const Point &p) {\n    return (p - Projection(l, p)).abs();\n}\ninline Number Distance(const Segment &s, const Point &p) {\n    if (sign(dot(s[1] - s[0], p - s[0])) == -1) return (p - s[0]).abs();\n    if (sign(dot(s[0] - s[1], p - s[1])) == -1) return (p - s[1]).abs();\n    return (p - Projection(s, p)).abs();\n}\ninline Number Distance(const Line &l1, const Line &l2) {\n    return IsIntersect(l1, l2) ? 0 : Distance(l1, l2[0]);\n}\ninline Number Distance(const Line &l, const Segment &s) {\n    if (IsIntersect(l, s)) return 0.0;\n    return std::min(Distance(l, s[0]), Distance(l, s[1]));\n}\ninline Number Distance(const Segment &s1, const Segment &s2) {\n    if (IsIntersect(s1, s2)) return 0.0;\n    return std::min({Distance(s1, s2[0]), Distance(s1, s2[1]),\n                Distance(s2, s1[0]), Distance(s2, s1[1])});\n}\n\nPoint CrossPoint(const Line &s1, const Line &s2) {\n    Point base = s2[1] - s2[0];\n    Number d1 = abs(abs_cross(base, s1[0] - s2[0]));\n    Number d2 = abs(abs_cross(base, s1[1] - s2[0]));\n    Number t = d1 / (d1 + d2);\n    return s1[0] + (s1[1] - s1[0]) * t;\n}\nstd::vector<Point> CrossPoint(const Circle &c, const Line &l) {\n    if (!IsIntersect(c, l))\n        return std::vector<Point>();\n    Point mid = Projection(l, c);\n    if (equal((c - mid).abs(), c.r))\n        return {mid};\n\n    Point e = (l[1] - l[0]) / (l[1] - l[0]).abs();\n    Number len = sqrt(c.r * c.r - (mid - c).abs2());\n    return {mid + e * len, mid - e * len};\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c1, const Circle &c2) {\n    assert(IsIntersect(c1, c2));\n    Number d = Distance(c1, c2);\n    Number r1_cos = (d * d + c1.r * c1.r - c2.r * c2.r) / (2.0 * d);\n    Number h = sqrt(c1.r * c1.r - r1_cos * r1_cos);\n    Point base = c1 + (c2 - c1) * r1_cos / d;\n    Point dir = (c2 - c1).rotate90() * h / d;\n    return std::make_pair(base + dir, base - dir);\n}\n\n// the tangent line from a point to a circle\nstd::vector<Point> TangentPoint(const Circle &c, const Point &p) {\n    Number x = (p - c).abs2();\n    Number d = x - c.r * c.r;\n    if (sign(d) == -1) // no point\n        return std::vector<Point>();\n    d = std::max(d, 0.0);\n    Point q1 = (p - c) * (c.r * c.r / x);\n    Point q2 = ((p - c) * (-c.r * sqrt(d) / x)).rotate90();\n    if (q2 == Point(0, 0)) return {c + q1};\n    return {c + q1 - q2, c + q1 + q2};\n}\n// common tangent lines to two circles\nstd::vector<Line> CommonTangent(const Circle &c1, const Circle &c2) {\n    std::vector<Line> list;\n    // caluculate outer tangent\n    if (equal(c1.r, c2.r)) {\n        Point dir = c2 - c1;\n        dir = (dir * (c1.r / dir.abs())).rotate90();\n        list.emplace_back(Line(c1 + dir, c2 + dir));\n        list.emplace_back(Line(c1 - dir, c2 - dir));\n    }\n    else {\n        Point p = (c1 * (-c2.r)) + (c2 * c1.r);\n        p = p * (1 / (c1.r - c2.r));\n        std::vector<Point> ps = TangentPoint(c1, p);\n        std::vector<Point> qs = TangentPoint(c2, p);\n        const int N = std::min(ps.size(), qs.size());\n        for (int i = 0; i < N; ++i)\n            list.emplace_back(Line(ps[i], qs[i]));\n    }\n\n    // caluculate inner tangent\n    Point p = (c1 * c2.r) + (c2 * c1.r);\n    p = p * (1 / (c1.r + c2.r));\n    std::vector<Point> ps = TangentPoint(c1, p);\n    std::vector<Point> qs = TangentPoint(c2, p);\n    const int N = std::min(ps.size(), qs.size());\n    for (int i = 0; i < N; ++i)\n        list.emplace_back(Line(ps[i], qs[i]));\n\n    return list;\n}\n\n\nint main()\n{\n    std::cout << std::fixed << std::setprecision(15);\n\n    Circle c;\n    Line l;\n    int q;\n\n    std::cin >> c >> q;\n    while (q--) {\n        std::cin >> l;\n        std::vector<Point> res = CrossPoint(c, l);\n        if (res.size() == 1)\n            std::cout << res[0] << ' ' << res[0] << '\\n';\n        else if (res[0] < res[1])\n            std::cout << res[0] << ' ' << res[1] << '\\n';\n        else\n            std::cout << res[1] << ' ' << res[0] << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n\n//平面幾何\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n\n//宣言\n//--------------------------------------------\n\n//long double or double\ntypedef double Real;\n\n//ポイントクラス\ntypedef complex<Real> Point;\n\n//線分クラス\ntypedef pair<Point, Point> Line;\n\n//円\ntypedef pair<Point, Real> Circle;\n\n//ポリゴン\ntypedef vector<Point> Poly;\n\n\n//x座標優先で比較する\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n}\n\n\n//doubleの誤差\n#define EPS (1e-4)\n//double同士の比較\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n//Pointの比較\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n//角度\n//--------------------------------------------\nReal toRadian(double degree) {\n    return degree * PI / 180.0;\n}\n\nReal toDegree(double radian) {\n    return radian * 180.0 / PI;\n}\n\n\n\n\n\n\n\n//内積・外積・単位・法線\n//--------------------------------------------\n\n//ベクトルpの向きの単位ベクトルを返す\nPoint unit_vector(Point p) {\n    return p / abs(p);\n}\n\n\n//pの法線ベクトルを両方返す\npair<Point, Point> norm_vectors(Point p) {\n    return make_pair(p * Point(0, 1), p * Point(0, -1));\n}\n\n//ベクトルを反時計に回す sはラジアン\nPoint rotate_vector(Point v, double s) {\n    return Point(v.real() * cos(s) - v.imag() * sin(s), v.real() * sin(s) + v.imag() * cos(s));\n}\n\n//内積 a・b = |a||b|cosθ\ninline double dot(const Point &a, const Point &b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積 a×b = |a||b|sinθ\ninline double cross(const Point &a, const Point &b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n//三角形　角度・面積\n//--------------------------------------------\n//3点a, b, cのおける、角bacを返す\nReal args_bac(Point a, Point b, Point c) {\n    return acos(dot(b - a, c - a) / (abs(b - a) * abs(c - a)));\n}\n\n//各辺の長さがa, b, cの三角形の、aの対角の角度を返す\nReal args_bac(Real a, Real b, Real c) {\n    return acos((b * b + c * c - a * a) / (2 * b * c));\n}\n\n//三角形の面積\nReal heron_area(Real a, Real b, Real c) {\n    Real s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n//Real heron_area(Point a, Point b, Point c) {\n//    b -= a;\n//    c -= a;\n//    return (cross(b, c) / 2.0);\n//}\n\n//三角形の重心\nPoint centerOfGravity(Point a, Point b, Point c) {\n    return Point((a.real() + b.real() + c.real()) / 3.0, (a.imag() + b.imag() + c.imag()) / 3.0);\n}\n\n//三角形の外接円の半径\nReal circumScribedCircleRadius(Point a, Point b, Point c) {\n    Real edgeA = abs(b - c);\n    Real angleA = args_bac(a, b, c);\n    return (edgeA / sin(angleA) / 2.0);\n}\n\n//三角形の外接円の中心座標　外心\nPoint circumScribedCircleXY(Point a, Point b, Point c) {\n    Real angleA = args_bac(a, b, c);\n    Real angleB = args_bac(b, a, c);\n    Real angleC = args_bac(c, a, b);\n    Real A = sin(2.0 * angleA);\n    Real B = sin(2.0 * angleB);\n    Real C = sin(2.0 * angleC);\n    Point point((a.real() * A + b.real() * B + c.real() * C) / (A + B + C),\n                (a.imag() * A + b.imag() * B + c.imag() * C) / (A + B + C));\n    return point;\n}\n\n//三角形が点Pを含むか\nbool point_in_triangle(Point a, Point b, Point c, Point p) {\n    Point ab = b - a;\n    Point bp = p - b;\n\n    Point bc = c - b;\n    Point cp = p - c;\n\n    Point ca = a - c;\n    Point ap = p - a;\n\n    Real c1 = cross(ab, bp);\n    Real c2 = cross(bc, cp);\n    Real c3 = cross(ca, ap);\n\n    //内側\n    if ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0)) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\n\n//直線・線分\n//--------------------------------------------\n\n//頂点a, b, cの位置関係判定\n//別名ccw couter-clock-wise\nint points_relation(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return 1; //counter-clockwise\n    if (cross(b, c) < -EPS) return -1; //clockwise\n    if (dot(b, c) < -EPS) return 2; //c--a--b on line\n    if (abs(b) < abs(c)) return -2; //a--b--c on line\n    return 0; //on segment\n}\n\n//2直線の直行判定 Point版\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の直行判定 Line版\nbool is_orthogonal(Line line1, Line line2) {\n    return EQ(dot(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//2直線の平行判定 Point版\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の平行判定 Line版\nbool is_parallel(Line line1, Line line2) {\n    return EQ(cross(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//点cが**直線**a-b上にあるか\nbool is_point_on_long_line(Point a, Point b, Point c) {\n    return EQ(cross(b - a, c - a), 0.0);\n}\n\n//点cが**線分**a-b上にあるか\nbool is_point_on_line(Point a, Point b, Point c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//点a, bを通る**直線**と,点cとの距離d\ndouble distance_longline_point(Point a, Point b, Point c) {\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//直線と点との距離　円用\nReal line_dis(Line a, Point x) {\n    return abs(cross(a.second - a.first, x - a.first)) / abs(a.second - a.first);\n}\n\n//点a, bを端点とする**線分**と、点cとの距離d\nReal distance_line_point(Point a, Point b, Point c) {\n    if (dot(b - a, c - a) < EPS) return abs(c - a);\n    if (dot(a - b, c - b) < EPS) return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交差判定\nbool is_intersected_lines(Point a1, Point a2, Point b1, Point b2) {\n    return (points_relation(a1, a2, b1) * points_relation(a1, a2, b2) <= 0 &&\n            points_relation(b1, b2, a1) * points_relation(b1, b2, a2) <= 0);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の距離\nReal distance_line_line(Point a1, Point a2, Point b1, Point b2) {\n    if (is_intersected_lines(a1, a2, b1, b2)) {\n        return 0;\n    } else {\n        return min({\n                           distance_line_point(a1, a2, b1),\n                           distance_line_point(a1, a2, b2),\n                           distance_line_point(b1, b2, a1),\n                           distance_line_point(b1, b2, a2)\n                   });\n    }\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交点\nPoint intersection_lines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point b = b2 - b1;\n    double d1 = abs(cross(b, a1 - b1));\n    double d2 = abs(cross(b, a2 - b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2 - a1) * Point(t, 0);\n}\n\n//点a1, a2を通る直線と点b1, b2を通る直線の交点計算\nPoint intersection_longlines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1;\n    Point b = b2 - b1;\n    return a1 + a * Point(cross(b, b1 - a1), 0) / Point(cross(b, a), 0);\n}\n\n\n//直線a-bに点pから垂線をおろしたときの交点\nPoint projection_point(Point a, Point b, Point p) {\n    Real t = dot(p - a, a - b) / (abs(a - b) * abs(a - b));\n    return a + (a - b) * t;\n}\n\n//点pを線対称移動させる\nPoint reflection_point(Point a, Point b, Point p) {\n    return p + (projection_point(a, b, p) - p) * (Real) 2.0;\n}\n\n\n//多角形\n//--------------------------------------------\n\n//面積を返す 反時計回りに整列させておく\n//正なら反時計回り　負なら時計回り\nReal poly_area(Poly p) {\n    if (p.size() < 3)return 0;\n    Real res = cross(p[p.size() - 1], p[0]);\n    for (int i = 1; i < p.size(); i++) {\n        res += cross(p[i - 1], p[i]);\n    }\n    return abs(res) / 2;\n}\n\n//凸多角形か判定する\n//凸出ない場合、各辺から次の辺までの\n//時計回り・反時計回りに反対のものが出てくる\nbool is_convec_poly(Poly p) {\n    if (p.size() < 3) {\n        return false;\n    }\n\n    //sはstartのs　最初の回り方を保存する\n    int s = -3;\n    for (int i = 0; i < p.size(); i++) {\n        //2辺隣接した辺を選ぶ\n        int r = points_relation(p[i], p[(i != 0 ? i - 1 : p.size() - 1)], p[(i + 1 != p.size() ? i + 1 : 0)]);\n\n        //外積が1 時計回りか反時計なら更新\n        if (abs(r) == 1 && s == -3) s = r;\n\n        //sとrの積が-1なら異なる回り方が出てきている\n        //すべて時計回りなら-1*-1=1 反時計なら1*1=1\n        if (s * r == -1) return false;\n    }\n    return true;\n}\n\n//最遠点対　凸多角形で最も長い距離を返す\n//凸包の後に使うとよい\nReal longest_points_distance(Poly p) {\n    int n = p.size();\n    if (n == 2) {\n        return abs(p[0] - p[1]);\n    }\n\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n        if (!(p[i] < p[k])) i = k;\n        if (p[j] < p[k]) j = k;\n    }\n\n    Real res = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(p[i] - p[j]));\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n\n    return res;\n}\n\n//凸包\nvector<Point> convex_hull(vector<Point> v) {\n    int n = v.size(), k = 0;\n    sort(v.begin(), v.end());\n    vector<Point> r(2 * n);\n    for (int i = 0; i < n; i++) {\n        while (k > 1 && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        while (k > t && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    r.resize(k - 1);\n    return r;\n}\n\n//多角形をLine lで分割した際の左側の集合を返す\nPoint getcrosspointll(Line l1, Line l2) {\n    double c1 = cross(l1.first, l1.second), c2 = cross(l2.first, l2.second);\n    double de = (l1.first.imag() - l1.second.imag()) * (l2.first.real() - l2.second.real()) -\n                (l2.first.imag() - l2.second.imag()) * (l1.first.real() - l1.second.real());\n    double x = (l2.second.real() - l2.first.real()) * c1 + (l1.first.real() - l1.second.real()) * c2;\n    double y = (l2.second.imag() - l2.first.imag()) * c1 + (l1.first.imag() - l1.second.imag()) * c2;\n    return Point(x / de, y / de);\n}\n\nPoly convexcut(Poly p, Line l) {\n    int n = p.size();\n    Poly q;\n\n    for (int i = 0; i < n; i++) {\n        if (points_relation(l.first, l.second, p[i]) != -1)q.push_back(p[i]);\n        if (points_relation(l.first, l.second, p[i]) * points_relation(l.first, l.second, p[(i + 1) % n]) < 0.0) {\n            if (!is_parallel(l, Line(p[i], p[(i + 1) % n]))) {\n                q.push_back(getcrosspointll(l, Line(p[i], p[(i + 1) % n])));\n            }\n        }\n    }\n    return q;\n}\n\n//頂点pが多角形pの内外か判定する\n//2･･･in 1･･･on 0･･･out\nint point_in_poly(Poly v, Point p) {\n    bool in = false;\n    for (int i = 0; i < v.size(); ++i) {\n        Point a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n    }\n    return in ? 2 : 0;\n}\n\n\n\n//円 第一引数は中点　第二引数は半径\n//--------------------------------------------\n\n//円の面積\nReal circle_area(Circle c) {\n    return PI * c.second * c.second;\n}\n\n//円の中に点xが内部にあるか\nbool circle_in_x(Circle c, Point x) {\n    return (abs(x - c.first) + EPS < c.second);\n}\n\n//円状に点xがあるか\nbool circle_on_x(Circle c, Point x) {\n    return EQ(abs(x - c.first), c.second);\n}\n\n//2つの円a, bの関係\nint circle_relation(Circle a, Circle b) {\n    double d = abs(a.first - b.first);\n\n    if (a.second + b.second + EPS < d) return -1; //no cross point outside\n    if (b.second + d + EPS < a.second) return 1; //no cross point(inside B in A)\n    if (a.second + d + EPS < b.second) return 2; //no cross point(inside A in B)\n\n    if (abs(a.second + b.second - d) < EPS) return -3; //one cross point(outside)\n    if (abs(b.second + d - a.second) < EPS) return 3; //one cross point(inside B in A)\n    if (abs(a.second + d - b.second) < EPS) return 4; //one cross point(inside A in B)\n\n    return 0; //two cross point\n}\n\n//2円a, bの共通面積\nReal intersection_area(Circle a, Circle b) {\n    Real d = abs(a.first - b.first);\n\n    if (a.second + b.second < d + EPS) return 0;\n\n    //円aを半径が大きい方にする\n    if (a.second < b.second) swap(a, b);\n\n    //円bが円aに入ってたら\n    if (b.second + d < a.second + EPS || b.second < EPS) return circle_area(b);\n\n    Real t1 = args_bac(b.second, a.second, d);\n    Real t2 = args_bac(a.second, b.second, d);\n    Real tri = (a.second * a.second * sin(t1 * 2) + b.second * b.second * sin(t2 * 2)) / 2.0;\n    return a.second * a.second * t1 + b.second * b.second * t2 - tri;\n}\n\n//2つの円の交点を返す\nvector<Point> circle_inter_points(Circle a, Circle b) {\n    vector<Point> v;\n    int pos = circle_relation(a, b);\n    if (pos == 0) {\n        Real s = args_bac(b.second, abs(b.first - a.first), a.second);\n        Point x = a.second * unit_vector(b.first - a.first);\n        v.push_back(a.first + rotate_vector(x, s));\n        v.push_back(a.first + rotate_vector(x, -s));\n    } else if (abs(pos) >= 3) {\n        v.push_back(a.first + a.second * unit_vector(b.first - a.first));\n    }\n    return v;\n}\n\n//円と直線の交点\npair<Point, Point> circle_inter_line_points(Circle c, Line l) {\n    Real a=imag(l.first)-imag(l.second);\n    Real b=real(l.second)-real(l.first);\n    Real k=-b*imag(l.first)-a*real(l.first);\n\n    Real d=a*real(c.first)+b*imag(c.first)+k;\n    Real r=c.second;\n\n    Real R=a*a+b*b;\n    Real D=sqrt(R*r*r-d*d);\n    Point p1=c.first+polar(1/sqrt(R), atan2(b, a))*Point(-d, D);\n    Point p2=c.first+polar(1/sqrt(R), atan2(b, a))*Point(-d, -D);\n\n    if (p2 < p1)\n        swap(p1, p2);\n\n    return make_pair(p1, p2);\n//    vector<Point> v;\n//    Real d = line_dis(l, a.first);\n//    if (d < a.second + EPS) {\n//        Point x = a.second * unit_vector(l.second - l.first);\n//        if (points_relation(l.first, l.second, a.first) == 1) x = a.first + x * Point(0, -1);\n//        else x = a.first + x * Point(0, 1);\n//        if (d + EPS < a.second) {\n//            Real y = sqrt(a.second * a.second - d * d);\n//            if (d == 0) d += EPS;\n//            Real s = args_bac(y, d, a.second);\n//            v.push_back(rotate_vector(x, s));\n//            v.push_back(rotate_vector(x, -s));\n//        } else if (EQ(d, a.second)) {\n//            v.push_back(x);\n//        }\n//    }\n//    return v;\n}\n\n//点pを通る円cの接線\nvector<Line> adjust_line(Circle c, Point p) {\n    vector<Line> res;\n    if (circle_in_x(c, p)) return res;\n    if (circle_on_x(c, p)) {\n        pair<Point, Point> n = norm_vectors(c.first - p);\n        res.push_back(Line(n.first + p, p));\n        return res;\n    }\n    Real x = c.second, z = abs(c.first - p);\n    Real y = sqrt(z * z - x * x);\n    Real s = args_bac(y, x, z);\n    Point v = unit_vector(p - c.first) * c.second;\n\n    res.push_back(Line(rotate_vector(v, s) + c.first, p));\n    res.push_back(Line(rotate_vector(v, -s) + c.first, p));\n    return res;\n}\n\n//円の共通接線を求める\nvector<Line> common_adjust_line(Circle a, Circle b) {\n    vector<Line> res;\n    if (a.second + EPS < b.second) return common_adjust_line(b, a);\n    if (EQ(a.first.real(), b.first.real()) && EQ(a.first.imag(), b.first.imag()) && EQ(a.second, b.second)) return res;\n\n    Point pos = (b.first - a.first) * a.second / (a.second + b.second) + a.first;\n    if (!circle_in_x(a, pos)) res = adjust_line(a, pos);\n\n    if (EQ(a.second, b.second)) {\n        pair<Point, Point> n = norm_vectors(unit_vector(b.first - a.first) * a.second);\n        res.push_back(Line(a.first + n.first, b.first + n.first));\n        res.push_back(Line(a.first + n.second, b.first + n.second));\n    } else {\n        Real c = abs(b.first - a.first);\n        pos = unit_vector(b.first - a.first) * ((a.second * c) / (a.second - b.second)) + a.first;\n        if (!circle_in_x(a, pos)) {\n            vector<Line> tmp = adjust_line(a, pos);\n            for (int i = 0; i < tmp.size(); i++) res.push_back(tmp[i]);\n        }\n    }\n\n    return res;\n}\n\n\n//使い方\n//--------------------------------------------\n\n//xとyの取り出し型\n//a.real(); //x\n//a.imag(); //y\n\n//単位ベクトル\n//Point unit = a / abs(a);\n\n//ベクトルの長さをk倍する\n// a = a * Point(k, 0);\n\n//ベクトルaのk倍の法線ベクトル\n//P p1 = a * P(0, k);\n//P p2 = a * P(0, -k);\n\n//ベクトルaの単位法線ベクトル\n//P p1 = (a * P(0, 1)) /abs(a);\n//P p2 = (a * P(0, -1)) /abs(a);\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\n\n\nint main() {\n\n    double x, y, r;\n    scanf(\"%lf %lf %lf\", &x, &y, &r);\n    Circle c(Point(x, y), r);\n\n    size_t q;\n    scanf(\"%zu\", &q);\n\n    for (size_t i=0; i<q; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        Point p1(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p2(x, y);\n\n        Line l(p1, p2);\n        pair<Point, Point> ps=circle_inter_line_points(c, l);\n        printf(\"%.9f %.9f \", real(ps.first), imag(ps.first));\n        printf(\"%.9f %.9f\\n\", real(ps.second), imag(ps.second));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-8; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\n// VP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// // cross point between circles Verify AOJ CGL_7_E\n// VP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n/*\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}*/\n\nVP pcl(C c, L l) {\n    P h=proj(l,c.c);\n    P e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n    return VP{h-e,h+e};\n}\nVP pcc(C a,C b){\n    P d=b.c-a.c;\n    P w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n    P e=w*P(0,1);\n    return pcl(a,{w-e,w+e}); \n}\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define str string\n#define ld long double\n#define vec vector\n#define vll vec<ll>\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define rrep(i,b,a) for(ll i=b;i>=a;i--)\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n#define kai \"\\n\"\n#define yuque priority_queue\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mie min_element\n#define mae max_element\n#define tos to_string\n#define sep setprecision\n#define lob lower_bound\n#define upb upper_bound\n#define nep next_permutation\n#define MOD 1000000007ll\n#define MIN (1e-10)\n#define equal(a,b) (abs((a)-(b))<MIN)\n#define v2 ten\n#define chokusen senbun\n#define tenten senbun\n#define takaku vec<ten>\nusing namespace std;\nvoid solve();\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed;\n\tsolve();\n}\nstruct pea{\n\tll f,s;\n\tbool operator<(const pea &p)const{\n\t\treturn f!=p.f?f<p.f:s<p.s;\n\t};\n};\nstruct tri{\n\tll f,s,t;\n\tbool operator<(const tri &p)const{return f<p.f;};\n};\nclass ten{\npublic:\n\tld x,y;\n\tten operator+(ten p){return{x+p.x,y+p.y};}\n\tten operator-(ten p){return{x-p.x,y-p.y};}\n\tten operator*(ld k){return{k*x,k*y};}\n\tten operator/(ld k){return{x/k,y/k};}\n\tld abs(){return sqrt(abs2());}\n\tld abs2(){return x*x+y*y;};\n\tbool operator<(const ten &p)const{return x!=p.x?x<p.x:y<p.y;};\n\tbool operator==(const ten &p)const{return (-MIN<x-p.x)&&(x-p.x<MIN)&&(-MIN<y-p.y)&&(y-p.y<MIN);};\n\tld naiseki(v2 b){return x*b.x+y*b.y;}\n\tld gaiseki(v2 b){return x*b.y-y*b.x;}\n};\nstruct senbun{ten p1,p2;};\nstruct en{ten o;ld r;};\nten shaei(ten p,chokusen l){\n\tv2 a=l.p2-l.p1;\n\treturn l.p1+a*a.naiseki(p-l.p1)/a.abs2();\n}\nten hansha(ten p,chokusen l){return shaei(p,l)*2-p;}\nld tenchoku(ten p,chokusen l){\n\tv2 a=l.p2-l.p1;\n\treturn abs(a.gaiseki(p-l.p1))/a.abs();\n}\nld tensen(ten p,senbun s){\n\tif((p-s.p1).naiseki(s.p2-s.p1)<0)return (p-s.p1).abs();\n\tif((p-s.p2).naiseki(s.p1-s.p2)<0)return (p-s.p2).abs();\n\treturn tenchoku(p,s);\n}\nll ccw(ten p0,ten p1,ten p2){\n\tv2 a=p1-p0,b=p2-p0;\n\tif(a.gaiseki(b)>MIN)return -1;//012反時計回り\n\tif(a.gaiseki(b)<-MIN)return 1;//012時計回り\n\tif(a.naiseki(b)<-MIN)return -2;//102\n\tif(a.abs2()<b.abs2())return 2;//012\n\treturn 0;//021\n}\nbool majiwaru(senbun s,senbun t){return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2)<=0&&ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2)<=0;}\nld sensen(senbun s,senbun t){\n\tif(majiwaru(s,t))return 0;\n\treturn min({tensen(s.p1,t),tensen(s.p2,t),tensen(t.p1,s),tensen(t.p2,s)});\n}\nten koten(senbun s,senbun t){\n\tv2 a=t.p2-t.p1;\n\tld d1=abs(a.gaiseki(s.p1-t.p1));\n\tld d2=abs(a.gaiseki(s.p2-t.p1));\n\treturn s.p1+(s.p2-s.p1)*d1/(d1+d2);\n}\ntenten koten(en c,chokusen l){\n\tten h=shaei(c.o,l);\n\tld k=sqrt(c.r*c.r-(h-c.o).abs2());\n\tv2 a=(l.p1-l.p2)/(l.p1-l.p2).abs();\n\treturn {h+a*k,h-a*k};\n}\nvoid solve(){\n\ten c;cin>>c.o.x>>c.o.y>>c.r;\n\tll n;cin>>n;\n\tcout<<sep(10);\n\trep(i,0,n){\n\t\tchokusen l;\n\t\tcin>>l.p1.x>>l.p1.y>>l.p2.x>>l.p2.y;\n\t\ttenten pp=koten(c,l);\n\t\tif(pp.p1<pp.p2)cout<<pp.p1.x<<\" \"<<pp.p1.y<<\" \"<<pp.p2.x<<\" \"<<pp.p2.y<<kai;\n\t\telse cout<<pp.p2.x<<\" \"<<pp.p2.y<<\" \"<<pp.p1.x<<\" \"<<pp.p1.y<<kai;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//Cross Point of a Circle and a Line\n#include <iostream>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\n\nstatic const double ESP = 1e-10;\n\nbool equals(double a, double b) { return fabs(a - b) < ESP; }\n\nclass Point {\npublic:\n    double x, y;\n\n    explicit Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(a / x, a / y); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < ESP && fabs(y - p.y) < ESP;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    explicit Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector v1, Vector v2) {\n    return equals(cross(v1, v2), 0.0);\n}\n\nbool isOrthogonal(Vector v1, Vector v2) {\n    return equals(dot(v1, v2), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    return s.p1 + (base * (dot(base, p - s.p1) / base.norm()));\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2;\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > ESP) return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -ESP) return CLOCKWISE;\n    else if (dot(a, b) < -ESP) return ONLINE_BACK;\n    else if (a.norm() < b.norm()) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) {\n        return getDistancePP(s.p1, p);\n    } else if(dot(s.p1 - s.p2, p - s.p2) < 0) {\n        return getDistancePP(s.p2, p);\n    } else {\n        return getDistanceLP(s, p);\n    }\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if(intersect(s1, s2)) return 0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s1.p2 - s1.p1;\n    double d1 = fabs(cross(base, s2.p1 - s1.p1));\n    double d2 = fabs(cross(base, s2.p2 - s1.p1));\n    return s2.p1 + (s2.p2 - s2.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l) {\n    Vector base = l.p2 - l.p1;\n    double d = getDistanceLP(l, c.c);\n    Point m = project(l, c.c);\n    double t = sqrt(pow(c.r, 2.0) - pow(d, 2.0)) / base.abs();\n    return make_pair(m - base * t, m + base * t);\n}\n\nint main() {\n    int q;\n    double cx, cy, r, x0, y0, x1, y1;\n    cin >> cx >> cy >> r >> q;\n    Circle c = Circle(Point(cx, cy), r);\n    for(int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1;\n        Line l = Line(Point(x0, y0), Point(x1, y1));\n        pair<Point, Point> p = getCrossPoint(c, l);\n        if(p.first.x > p.second.x) swap(p.first, p.second);\n        printf(\"%.8f %.8f %.8f %.8f\\n\", p.first.x, p.first.y, p.second.x, p.second.y);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @copyright (c) 2020 Daisuke Hashimoto\n */\n\n#include <cstdint>\n#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nvoid CallCrossPointsOfCircleAndLine(std::istream &input_stream);\n\nclass Point2D {\n public:\n  Point2D() noexcept;\n  Point2D(const double x, const double y) noexcept;\n  ~Point2D() noexcept;\n  Point2D(const Point2D &obj) noexcept;\n  Point2D &operator=(const Point2D &obj) noexcept;\n  Point2D(Point2D &&obj) noexcept;\n  Point2D &operator=(Point2D &&obj) noexcept;\n\n  Point2D operator+(const Point2D &rhs) const noexcept;\n  Point2D operator-(const Point2D &rhs) const noexcept;\n  Point2D operator*(const double rhs) const noexcept;\n  double InnerProduct(const Point2D &rhs) const noexcept;\n  double OuterProduct(const Point2D &rhs) const noexcept;\n  double SquareSum() const noexcept;\n  double Norm() const noexcept;\n  double GetHeightOfParallelogram(const Point2D &hypotenuse) const;\n  double X() const noexcept;\n  double Y() const noexcept;\n\n private:\n  double x_;\n  double y_;\n};\n\nclass Line {\n public:\n  Line(const Point2D &p1, const Point2D &p2) noexcept;\n  ~Line() noexcept;\n  bool IsParallel(const Line &rhs) const noexcept;\n  bool IsOrthogonal(const Line &rhs) const noexcept;\n  bool IsOnLine(const Point2D &point) const noexcept;\n  bool operator==(const Line &rhs) const noexcept;\n  bool operator!=(const Line &rhs) const noexcept;\n  Point2D ProjectPoint(const Point2D &point) const;\n  Point2D ReflectPoint(const Point2D &point) const;\n\n  bool SegmentsAreCrossing(const Line &line) const;\n  Point2D GetCrossPointOfSegments(const Line &line) const;\n  bool PointIsOnSegment(const Point2D &point) const;\n  double GetLineSegmentDistanceFromPoint(const Point2D &point) const;\n  double GetLineSegmentDistance(const Line &line) const;\n\n private:\n  Line() = delete;\n  Line(const Line &obj) = delete;\n  Line &operator=(const Line &obj) = delete;\n  Line(Line &&obj) = delete;\n  Line &operator=(Line &&obj) = delete;\n\n private:\n  Point2D p1_;\n  Point2D p2_;\n};\n\nvoid CallCrossPointsOfCircleAndLine(std::istream &input_stream) {\n  input_stream.tie(0);\n  std::ios::sync_with_stdio(false);\n  double center_x, center_y, center_radius;\n  input_stream >> center_x >> center_y >> center_radius;\n  int32_t number_of_queries;\n  input_stream >> number_of_queries;\n  for (int32_t i = 0; i < number_of_queries; ++i) {\n    double p1_x, p1_y, p2_x, p2_y;\n    input_stream >> p1_x >> p1_y >> p2_x >> p2_y;\n    const Point2D p1(p1_x, p1_y);\n    const Point2D p2(p2_x, p2_y);\n    const Point2D direction = p2 - p1;\n    const double temp_x = p1.X() - center_x;\n    const double temp_y = p1.Y() - center_y;\n    const double a = (direction.X() * direction.X()) + (direction.Y() * direction.Y());\n    const double b = 2.0 * ((direction.X() * temp_x) + (direction.Y() * temp_y));\n    const double c = temp_x * temp_x + temp_y * temp_y - center_radius * center_radius;\n    const double temp_sq = sqrt(b * b - 4.0 * a * c);\n    constexpr double kEps = 0.0000001;\n    if (sqrt(a) < kEps) {\n      std::cerr << \"ERROR: CallCrossPointsOfCircleAndLine(): Invalid a=\" << a << std::endl;\n      throw 1;\n    }\n    const double t_1 = (-b + temp_sq) / 2.0 / a;\n    const double t_2 = (-b - temp_sq) / 2.0 / a;\n    const Point2D cross_point_1 = (p1 + (direction * t_1));\n    const Point2D cross_point_2 = (p1 + (direction * t_2));\n    if (((cross_point_1.X() - cross_point_2.X()) < kEps) && ((cross_point_1.X() - cross_point_2.X()) > -kEps)) {\n      if (cross_point_1.Y() < cross_point_2.Y()) {\n        std::cout << std::setprecision(20) << cross_point_1.X() << \" \" << cross_point_1.Y() << \" \" << cross_point_2.X()\n                  << \" \" << cross_point_2.Y() << std::endl;\n      } else {\n        std::cout << std::setprecision(20) << cross_point_2.X() << \" \" << cross_point_2.Y() << \" \" << cross_point_1.X()\n                  << \" \" << cross_point_1.Y() << std::endl;\n      }\n    } else if (cross_point_1.X() < cross_point_2.X()) {\n      std::cout << std::setprecision(20) << cross_point_1.X() << \" \" << cross_point_1.Y() << \" \" << cross_point_2.X()\n                << \" \" << cross_point_2.Y() << std::endl;\n    } else {\n      std::cout << std::setprecision(20) << cross_point_2.X() << \" \" << cross_point_2.Y() << \" \" << cross_point_1.X()\n                << \" \" << cross_point_1.Y() << std::endl;\n    }\n  }\n}\n\n// *************************************\nPoint2D::Point2D() noexcept : x_(0.0), y_(0.0) {}\n\nPoint2D::Point2D(const double x, const double y) noexcept : x_(x), y_(y) {}\n\nPoint2D::~Point2D() noexcept {}\n\nPoint2D::Point2D(const Point2D &obj) noexcept : x_(obj.x_), y_(obj.y_) {}\n\nPoint2D &Point2D::operator=(const Point2D &rhs) noexcept {\n  if (this != &rhs) {\n    this->x_ = rhs.x_;\n    this->y_ = rhs.y_;\n  }\n  return *this;\n}\n\nPoint2D::Point2D(Point2D &&obj) noexcept : x_(obj.x_), y_(obj.y_) {}\n\nPoint2D &Point2D::operator=(Point2D &&rhs) noexcept {\n  if (this != &rhs) {\n    this->x_ = rhs.x_;\n    this->y_ = rhs.y_;\n  }\n  return *this;\n}\n\nPoint2D Point2D::operator+(const Point2D &rhs) const noexcept {\n  Point2D point(this->x_ + rhs.x_, this->y_ + rhs.y_);\n  return point;\n}\n\nPoint2D Point2D::operator-(const Point2D &rhs) const noexcept {\n  Point2D point(this->x_ - rhs.x_, this->y_ - rhs.y_);\n  return point;\n}\n\nPoint2D Point2D::operator*(const double rhs) const noexcept {\n  Point2D point(this->x_ * rhs, this->y_ * rhs);\n  return point;\n}\n\ndouble Point2D::X() const noexcept {\n  return x_;\n}\n\ndouble Point2D::Y() const noexcept {\n  return y_;\n}\n\ndouble Point2D::InnerProduct(const Point2D &rhs) const noexcept {\n  return ((this->x_ * rhs.x_) + (this->y_ * rhs.y_));\n}\ndouble Point2D::OuterProduct(const Point2D &rhs) const noexcept {\n  return ((this->x_ * rhs.y_) - (this->y_ * rhs.x_));\n}\n\ndouble Point2D::SquareSum() const noexcept {\n  return (x_ * x_ + y_ * y_);\n}\n\ndouble Point2D::Norm() const noexcept {\n  return sqrt(SquareSum());\n}\n\ndouble Point2D::GetHeightOfParallelogram(const Point2D &hypotenuse) const {\n  double height;\n  try {\n    const double area_of_parallelogram = abs(OuterProduct(hypotenuse));\n    const double base_length = Norm();\n    constexpr double kEps = 0.00000001;\n    if (base_length < kEps) {\n      std::cerr << \"ERROR: GetHeightOfParallelogram(): Invalid base_length=\" << base_length << std::endl;\n      throw 1;\n    }\n    height = area_of_parallelogram / base_length;\n  } catch (...) {\n    std::cerr << \"ERROR: GetHeightOfParallelogram()\" << std::endl;\n    throw;\n  }\n  return height;\n}\n\n// ************************************************\n\nLine::Line(const Point2D &p1, const Point2D &p2) noexcept : p1_(p1), p2_(p2) {}\n\nLine::~Line() noexcept {}\n\nbool Line::IsParallel(const Line &rhs) const noexcept {\n  const Point2D this_direction = this->p2_ - this->p1_;\n  const Point2D rhs_direction = rhs.p2_ - rhs.p1_;\n  const double outer_product = this_direction.OuterProduct(rhs_direction);\n  constexpr double kEps = 0.0000001;\n  const bool is_parallel = (abs(outer_product) < kEps);\n  return is_parallel;\n}\n\nbool Line::IsOrthogonal(const Line &rhs) const noexcept {\n  const Point2D this_direction = this->p2_ - this->p1_;\n  const Point2D rhs_direction = rhs.p2_ - rhs.p1_;\n  constexpr double kEps = 0.0000001;\n  const double inner_product = this_direction.InnerProduct(rhs_direction);\n  const bool is_parallel = (abs(inner_product) < kEps);\n  return is_parallel;\n}\n\nbool Line::IsOnLine(const Point2D &point) const noexcept {\n  const Line line1(point, p1_);\n  const Line line2(point, p2_);\n  const bool is_on_line = line1.IsParallel(line2);\n  return is_on_line;\n}\n\nbool Line::operator==(const Line &rhs) const noexcept {\n  return (IsOnLine(rhs.p1_) && IsOnLine(rhs.p2_));\n}\n\nbool Line::operator!=(const Line &rhs) const noexcept {\n  return !(*this == rhs);\n}\n\nPoint2D Line::ProjectPoint(const Point2D &point) const {\n  const Point2D p2_from_p1 = p2_ - p1_;\n  const Point2D point_from_p1 = point - p1_;\n  const double square_sum = p2_from_p1.SquareSum();\n  constexpr double kEps = 0.0000001;\n  if (abs(square_sum) < kEps) {\n    std::cerr << \"ERROR: Line::ProjectPoint()\" << std::endl;\n    throw 1;\n  }\n  const double coefficient = p2_from_p1.InnerProduct(point_from_p1) / square_sum;\n  const Point2D projected_point = p1_ + (p2_from_p1 * coefficient);\n  return projected_point;\n}\n\nPoint2D Line::ReflectPoint(const Point2D &point) const {\n  Point2D reflected_point;\n  try {\n    const Point2D projected_point = ProjectPoint(point);\n    reflected_point = point + ((projected_point - point) * 2.0);\n  } catch (...) {\n    std::cerr << \"ERROR: ReflectPoint()\" << std::endl;\n  }\n  return reflected_point;\n}\n\ndouble Line::GetLineSegmentDistanceFromPoint(const Point2D &point) const {\n  double distance;\n  try {\n    const Point2D projected_point_from_point1 = ProjectPoint(point) - p1_;\n    const Point2D point2_from_point1 = p2_ - p1_;\n    bool projected_point_is_inside = ((projected_point_from_point1.SquareSum() <= point2_from_point1.SquareSum()) &&\n                                      (projected_point_from_point1.InnerProduct(point2_from_point1) >= 0.0));\n    if (projected_point_is_inside) {\n      const Point2D r = ProjectPoint(point) - point;\n      distance = r.Norm();\n    } else {\n      const Point2D diff1 = point - p1_;\n      const Point2D diff2 = point - p2_;\n      distance = fmin(diff1.Norm(), diff2.Norm());\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: GetLineSegmentDistanceFromPoint()\" << std::endl;\n    throw 1;\n  }\n  return distance;\n}\n\ndouble Line::GetLineSegmentDistance(const Line &line) const {\n  double line_segment_distance;\n  try {\n    if (SegmentsAreCrossing(line)) {\n      line_segment_distance = 0.0;\n    } else {\n      line_segment_distance =\n          fmin(fmin(GetLineSegmentDistanceFromPoint(line.p1_), GetLineSegmentDistanceFromPoint(line.p2_)),\n               fmin(line.GetLineSegmentDistanceFromPoint(p1_), line.GetLineSegmentDistanceFromPoint(p2_)));\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: GetLineSegmentDistance()\" << std::endl;\n  }\n  return line_segment_distance;\n}\n\nbool Line::PointIsOnSegment(const Point2D &point) const {\n  constexpr double kEps = 0.0000001;\n  bool point_is_on_segment;\n  try {\n    point_is_on_segment = (GetLineSegmentDistanceFromPoint(point) < kEps);\n  } catch (...) {\n    std::cerr << \"ERROR: PointIsOnSegment()\" << std::endl;\n    throw;\n  }\n  return point_is_on_segment;\n}\n\nbool Line::SegmentsAreCrossing(const Line &line) const {\n  const Point2D r1 = p2_ - p1_;\n  const Point2D diff1_1 = line.p1_ - p1_;\n  const Point2D diff1_2 = line.p2_ - p1_;\n  const bool temp_1 = ((r1.OuterProduct(diff1_1) * r1.OuterProduct(diff1_2)) < 0.0);\n\n  const Point2D r2 = line.p2_ - line.p1_;\n  const Point2D diff2_1 = p1_ - line.p1_;\n  const Point2D diff2_2 = p2_ - line.p1_;\n  const bool temp_2 = ((r2.OuterProduct(diff2_1) * r2.OuterProduct(diff2_2)) < 0.0);\n\n  const bool any_points_is_on_segment = (PointIsOnSegment(line.p1_) || PointIsOnSegment(line.p2_) ||\n                                         line.PointIsOnSegment(p1_) || line.PointIsOnSegment(p2_));\n\n  return (temp_1 && temp_2) || any_points_is_on_segment;\n}\n\nPoint2D Line::GetCrossPointOfSegments(const Line &line) const {\n  Point2D cross_point;\n  try {\n    const Point2D base_vector = p2_ - p1_;\n    const Point2D hypotenuse_vector_1 = line.p1_ - p1_;\n    double height_1 = base_vector.GetHeightOfParallelogram(hypotenuse_vector_1);\n    const Point2D hypotenuse_vector_2 = line.p2_ - p1_;\n    double height_2 = base_vector.GetHeightOfParallelogram(hypotenuse_vector_2);\n    constexpr double kEps = 0.00000001;\n    const double height_sum = height_1 + height_2;\n    if (height_sum < kEps) {\n      std::cerr << \"ERROR: GetCrossPointOfSegments(): Invalid height_sum=\" << height_sum << std::endl;\n      throw 1;\n    }\n    const double ratio = height_1 / height_sum;\n    cross_point = line.p1_ + (line.p2_ - line.p1_) * ratio;\n  } catch (...) {\n    std::cerr << \"ERROR: GetCrossPointOfSegments()\" << std::endl;\n    throw;\n  }\n  return cross_point;\n}\n\nint main(int argc, char *argv[]) {\n  try {\n    CallCrossPointsOfCircleAndLine(std::cin);\n  } catch (...) {\n    std::cerr << \"ERROR: main()\" << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Point Vector;\ntypedef Segment Line;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n  \nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\n  \nPoint p;\ndouble r;\nSegment s;\n  \nPoint rotate( Point a, double si,double co){\n  return Point(a.x*co-a.y*si,a.x*si+a.y*co);\n}\n  \nvector<Point> solve(){\n  vector<Point> res;\n  Point q=project(s,p);\n  double d=sqrt(r*r-abs(p-q)*abs(p-q));\n  Vector base=s.p1-s.p2;\n  res.push_back(q+base*(d/abs(base)));\n  res.push_back(q-base*(d/abs(base)));\n  return res;\n}\n  \nint main(){\n  cin>>p.x>>p.y>>r;\n  int tc;\n  cin>>tc;\n  for(int i=0;i<tc;i++){\n    cin>>s.p1.x>>s.p1.y>>s.p2.x>>s.p2.y;\n    vector<Point> t=solve();\nsort(t.begin(),t.end());\n    printf(\"%.8f %.8f %.8f %.8f\\n\",t[0].x,t[0].y,t[1].x,t[1].y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nnamespace Geometry\n{\n\ttypedef double Scalar;\n\t\n\tScalar Abs(Scalar x) {\n\t\treturn x > 0 ? x : -x;\n\t}\n\t\n\tconst Scalar eps = 1e-12;\n\t\n\tconst double pi = acos(-1);\n\t\n\tstruct Point;\n\ttypedef Point Vector;\n\t\n\tstruct Point\n\t{\n\t\tScalar x,y;\n\t\tScalar len() const {\n\t\t\treturn sqrt(x*x + y*y);\n\t\t}\n\t\tScalar len2() const {\n\t\t\treturn x * x + y * y;\n\t\t}\n        Vector uni() const {\n            Scalar l = len();\n            return (Vector){x / l, y / l};\n        }\n\t\tPoint operator + (const Vector &b) const {\n\t\t\treturn (Point){x + b.x, y + b.y};\n\t\t}\n\t\tVector operator - (const Point &b) const {\n\t\t\treturn (Vector){x - b.x, y - b.y};\n\t\t}\n\t\tPoint rotate(double ang) const {\n\t\t\treturn (Point){x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang)};\n\t\t}\n\t\tPoint rotate(const Point &o, double ang) const {\n\t\t\treturn (*this - o).rotate(ang) + o;\n\t\t}\n\t\tvoid print() {\n\t\t\tprintf(\"(%.3lf,%.3lf)\\n\",(double)x,(double)y);\n\t\t}\n\t};\n\t\n\tbool operator == (const Point &x, const Point &y) {\n\t\treturn Abs(x.x - y.x) <= eps && Abs(x.y - y.y) <= eps;\n\t}\n\tScalar operator * (const Vector &x, const Vector &y) {\n\t\treturn x.x * y.y - x.y * y.x;\n\t}\n\tScalar operator / (const Vector &x, const Vector &y) {\n\t\treturn x.x * y.x + x.y * y.y;\n\t}\n\tVector operator * (const Scalar &x, const Vector &y) {\n\t\treturn (Vector){x * y.x, x * y.y};\n\t}\n\tVector operator * (const Vector &y, const Scalar &x) {\n\t\treturn (Vector){x * y.x, x * y.y};\n\t}\n\tVector operator / (const Vector &x, const Scalar &y) {\n\t\treturn (Vector){x.x / y, x.y / y};\n\t}\n\t\n\tstruct Line\n\t{\n\t\tPoint o;\n\t\tVector l; // unit length\n\t};\n\t\n\tScalar dist(const Point &x, const Line &y) { //signed\n\t\treturn y.l * (x - y.o);\n\t}\n\t\n\tPoint footpoint(const Point &x, const Line &y) {\n\t\tScalar d=dist(x,y);\n\t\treturn x - d * y.l.rotate(pi / 2);\n\t}\n\t\n\tPoint intersect(const Line &x, const Line &y) {\n\t\tScalar d1 = dist(x.o, y);\n\t\tScalar d2 = dist(x.o + x.l, y);\n\t\treturn x.o + d1 / (d1 - d2) * x.l;\n\t}\n\t\n\tstruct Seg\n\t{\n\t\tPoint x,y;\n\t\tScalar len() const {\n\t\t\treturn (x - y).len();\n\t\t}\n\t};\n\t\n\tLine line(const Seg &x) {\n\t\treturn (Line){x.x, (x.y - x.x) / x.len()};\n\t}\n\t\n\tScalar dist(const Point &o, const Seg &l) {\n\t\tif(Abs((l.y - l.x) * (o - l.x)) <= eps)\n\t\t{\n\t\t\tScalar d1 = (o - l.x).len();\n\t\t\tScalar d2 = (o - l.y).len();\n\t\t\treturn (Abs(d1 + d2 - l.len()) <= eps) ? 0 : std::min(d1, d2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif((l.y - l.x) / (o - l.x) < 0) return (o - l.x).len();\n\t\t\tif((l.x - l.y) / (o - l.y) < 0) return (o - l.y).len();\n\t\t\treturn dist(o, line(l));\n\t\t} \n\t}\n\t\n\tint convexHull(Point *p, int n, Point *s) { // return # of points on the convex hull + 1\n\t\tstd::sort(p + 1, p + n + 1, [](const Point &x, const Point &y)  { return x.x != y.x ? x.x < y.x : x.y < y.y;});\n\t\tint ts;\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tif(i == 1 || !(p[i] == p[i-1]))\n\t\t\t{\n\t\t\t\twhile(ts > 1 && (p[i] - s[ts-1]) * (s[ts] - s[ts-1]) <= 0)\n\t\t\t\t\t--ts;\n\t\t\t\ts[++ts] = p[i];\n\t\t\t}\n\t\tint cl = ts;\n\t\tfor(int i = n - 1; i; ++i)\n\t\t\tif(!(p[i] == p[i+1]))\n\t\t\t{\n\t\t\t\twhile(ts > cl && (p[i] - s[ts-1]) * (s[ts] - s[ts-1]) <= 0)\n\t\t\t\t\t--ts;\n\t\t\t\ts[++ts] = p[i];\n\t\t\t}\n\t\treturn ts;\n\t}\n\t\n\tstruct Circle\n\t{\n\t\tPoint o;\n\t\tScalar r;\n\t};\n\t\n\tstd::pair<Point, Point> intersect(const Circle &c, const Line &l) {\n\t\tScalar d = dist(c.o, l);\n\t\tPoint p = footpoint(c.o, l);\n\t\tScalar k = c.r * c.r - (c.o - p).len2();\n\t\tk = k < 0 ? 0 : sqrt(k);\n\t\treturn std::make_pair(p + k * l.l, p - k * l.l);\n\t}\n\t\n\tstd::pair<Point, Point> intersect(const Circle &x, const Circle &y) {\n\t\tScalar d = (x.o - y.o).len();\n\t\tdouble ang = acos((x.r * x.r + d * d - y.r * y.r)/(2 * x.r * d));\n\t\tVector v = x.r * (y.o - x.o) / d;\n\t\treturn std::make_pair(x.o + v.rotate(ang), x.o + v.rotate(-ang));\n\t}\n\t\n\tstd::pair<Line, Line> tangentLine(const Point &x, const Circle &c) {\n\t\tif(Abs((x - c.o).len() - c.r) <= eps) {\n\t\t\tLine l = (Line){x, (x - c.o).uni().rotate(pi/2)};\n\t\t\treturn std::make_pair(l,l);\n\t\t}\n\t\tScalar d1 = (c.o - x).len();\n\t\tdouble ang = asin(c.r / d1);\n\t\tVector v = (c.o - x).uni();\n\t\treturn std::make_pair((Line){x, v.rotate(ang)}, (Line){x, v.rotate(-ang)});\n\t}\n\t\n\tstd::pair<Point, Point> tangentPoint(const Point &x, const Circle &c) {\n\t\tauto tl = tangentLine(x, c);\n\t\tScalar d1 = (c.o - x).len();\n\t\tdouble ang = asin(c.r / d1);\n\t\tScalar d2 = d1 * cos(ang);\n\t\treturn std::make_pair(x + d2 * tl.first.l, x + d2 * tl.second.l);\n\t}\n\t\n\tstd::pair<Line, Line> outerTLine(Circle x, Circle y) {\n\t\tif(x.r > y.r)std::swap(x, y);\n\t\ty.r -= x.r;\n\t\tauto p = tangentPoint(x.o, y);\n\t\tauto l = tangentLine(x.o, y);\n\t\tl.first.o = l.first.o + (p.first - y.o).uni() * (y.r + x.r) - (p.first - y.o);\n\t\tl.second.o = l.second.o + (p.second - y.o).uni() * (y.r + x.r) - (p.first - y.o);\n\t\treturn l;\n\t}\n\t\n\tstd::pair<Line, Line> innerTLine(const Circle &x, Circle y) {\n\t\ty.r += x.r;\n\t\tauto p = tangentPoint(x.o, y);\n\t\tauto l = tangentLine(x.o, y);\n\t\tl.first.o = l.first.o + (p.first - y.o).uni() * (y.r - x.r) - (p.first - y.o);\n\t\tl.second.o = l.second.o + (p.second - y.o).uni() * (y.r - x.r) - (p.first - y.o);\n\t\treturn l;\n\t} \n\tbool operator <(const Point &x,const Point &y)\n\t{\n\t    if(fabs(x.x-y.x)>1e-8)return x.x<y.x;\n\t    return x.y<y.y;\n\t}\n}\nint main()\n{\n    int cx=io::F(),cy=io::F(),r=io::F();\n    using namespace Geometry;\n    Circle c={(Point){(double)cx,(double)cy},(double)r};\n    int q=io::F();\n    while(q--)\n    {\n        int x1=io::F(),y1=io::F(),x2=io::F(),y2=io::F();\n        Point p1=(Point){(double)x1,(double)y1},p2=(Point){(double)x2,(double)y2};\n        Line l=line((Seg){p1,p2});\n        auto s=intersect(c,l);\n        if(s.second<s.first)std::swap(s.first,s.second);\n        printf(\"%.9lf %.9lf %.9lf %.9lf\\n\",s.first.x,s.first.y,s.second.x,s.second.y);\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\n\nclass Point {\npublic:\n\tld x, y;\n\tPoint() {\n\t\tx = y = 0.0;\n\t}\n\tPoint(ld x, ld y) :\n\t\t\tx(x), y(y) {\n\t}\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(ld a) {\n\t\treturn Point(x * a, y * a);\n\t}\n\tPoint operator /(ld a) {\n\t\treturn Point(x / a, y / a);\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c;\n\tld r;\n\tCircle(Point c = Point(), ld r = 0.0) :\n\t\t\tc(c), r(r) {\n\t}\n};\n\nld dot(Point p1, Point p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\n\nld norm(Point p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nld abs(Point p) {\n\treturn sqrt(norm(p));\n}\n\nPoint project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tld r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Segment l) {\n\tPoint pr = project(l, c.c);\n\tPoint e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tld base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr - e * base, pr + e * base);\n}\n\nint main() {\n\n\tint cx, cy, r;\n\tscanf(\"%d %d %d\", &cx, &cy, &r);\n\tPoint cp(cx, cy);\n\tCircle c(cp, r);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint p1x, p1y, p2x, p2y;\n\t\tscanf(\"%d %d %d %d\", &p1x, &p1y, &p2x, &p2y);\n\t\tPoint p1(p1x, p1y);\n\t\tPoint p2(p2x, p2y);\n\t\tSegment s(p1, p2);\n\t\tpair<Point, Point> pair = getCrossPoints(c, s);\n\n\t\tcout << fixed << setprecision(8) << pair.first.x << \" \" << pair.first.y << \" \" << pair.second.x << \" \" << pair.second.y << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\tdouble cx,cy,r,x1,x2,y1,y2,slope,cross_x,cross_y,k,div_x,div_y,ans1_x,ans1_y,ans2_x,ans2_y;\n\tint q;\n\tbool X_FLG,Y_FLG;\n\n\tscanf(\"%lf %lf %lf\",&cx,&cy,&r);\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf\",&x1,&y1,&x2,&y2);\n\n\t\tX_FLG = false,Y_FLG = false;\n\n\t\tif(y1 == y2){\n\t\t\tX_FLG = true;\n\t\t}else if(x1 == x2){\n\t\t\tY_FLG = true;\n\t\t}else{\n\t\t\tslope = (y2-y1)/(x2-x1);\n\t\t}\n\n\t\tif(X_FLG){\n\t\t\tcross_x = cx;\n\t\t\tcross_y = y1;\n\t\t}else if(Y_FLG){\n\t\t\tcross_x = x1;\n\t\t\tcross_y = cy;\n\t\t}else{\n\t\t\tcross_x = (cy*(x2-x1)*(y2-y1)+cx*(x2-x1)*(x2-x1)-y1*(y2-y1)*(x2-x1)+x1*(y2-y1)*(y2-y1))/((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1));\n\t\t\tcross_y = ((x1-x2)*cross_x+cy*(y2-y1)+cx*(x2-x1))/(y2-y1);\n\t\t}\n\n\t\tk = sqrt(r*r-((cx - cross_x)*(cx-cross_x)+(cy-cross_y)*(cy-cross_y)));\n\n\t\tif(X_FLG){\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",cross_x - k,y1,cross_x+k,y1);\n\t\t}else if(Y_FLG){\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",x1,cross_y-k,x1,cross_y+k);\n\t\t}else{\n\t\t\tdiv_x = k*(x2-x1)/(sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)));\n\t\t\tdiv_y = k*(y2-y1)/(sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)));\n\n\t\t\tans1_x = cross_x-div_x;\n\t\t\tans1_y = cross_y-div_y;\n\n\t\t\tans2_x = cross_x+div_x;\n\t\t\tans2_y = cross_y+div_y;\n\n\t\t\tif(ans1_x < ans2_x){\n\t\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",ans1_x,ans1_y,ans2_x,ans2_y);\n\t\t\t}else if(fabs(ans1_x-ans2_x) < 0.00000001 && ans1_y <= ans2_y){\n\t\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",ans1_x,ans1_y,ans2_x,ans2_y);\n\t\t\t}else{\n\t\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",ans2_x,ans2_y,ans1_x,ans1_y);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define eps (1e-10)\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point &p){return point(x+p.x,y+p.y);}\n    point operator - (point &p){return point(x-p.x,y-p.y);}\n    point operator * (double k){return point(x*k,y*k);}\n    point operator / (double k){return point(x/k,y/k);}\n\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n\n    bool operator < (const point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator == (const point &p){\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n//内积\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n//外积\ndouble cross(point a,point b){\n    return a.x*b.y-a.y*b.x;\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/base.norm();\n    base=base*r;\n    return a+base;\n}\n\npair<point,point>getcrosspoints(point xin,int r,point a,point b)\n{\n    point pr=project(a,b,xin);\n    point temp=b-a;\n    point e=temp/temp.abs();\n    point temp1=pr-xin;\n    double base=sqrt(r*r-(temp1).norm());\n    e=e*base;\n    return make_pair(pr-e,pr+e);\n}\n\nint main()\n{\n    point xin;\n    int r;\n    cin>>xin.x>>xin.y>>r;\n    int q;\n    cin>>q;\n    point a,b;\n    for(int i=0;i<q;i++){\n        cin>>a.x>>a.y>>b.x>>b.y;\n        pair<point,point>res=getcrosspoints(xin,r,a,b);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TemplateVersion \"3.4.0\"\n// Useful Marcos\n//====================START=====================\n// Compile use C++11 and above\n#ifdef LOCAL\n#define debug(args...)                           \\\n    {                                            \\\n        string _s = #args;                       \\\n        replace(_s.begin(), _s.end(), ',', ' '); \\\n        stringstream _ss(_s);                    \\\n        istream_iterator<string> _it(_ss);       \\\n        err(_it, args);                          \\\n    }\nvoid err(istream_iterator<string> it)\n{\n}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\n#define MSG cout << \"Finished\" << endl\n#else\n#define debug(args...)\n#define MSG\n#endif\n#if __cplusplus >= 201703L\ntemplate <typename... Args>\nvoid readln(Args &... args)\n{\n    ((cin >> args), ...);\n}\ntemplate <typename... Args>\nvoid writeln(Args... args)\n{\n    ((cout << args << \" \"), ...);\n    cout << endl;\n}\n#elif __cplusplus >= 201103L\nvoid readln()\n{\n}\ntemplate <typename T, typename... Args>\nvoid readln(T &a, Args &... args)\n{\n    cin >> a;\n    readln(args...);\n}\nvoid writeln()\n{\n    cout << endl;\n}\ntemplate <typename T, typename... Args>\nvoid writeln(T a, Args... args)\n{\n    cout << a << \" \";\n    writeln(args...);\n}\n#endif\n#if __cplusplus >= 201103L\n#define FOR(_i, _begin, _end) for (auto _i = _begin; _i < _end; _i++)\n#define FORR(_i, _begin, _end) for (auto _i = _begin; _i > _end; _i--)\n#else\n#define FOR(_i, _begin, _end) for (int _i = (int)_begin; _i < (int)_end; _i++)\n#define FORR(_i, _begin, _end) for (int _i = (int)_begin; _i > (int)_end; _i--)\n#define nullptr NULL\n#endif\n#if __cplusplus >= 201103L\n#define VIS(_kind, _name, _size) \\\n    vector<_kind> _name(_size);  \\\n    for (auto &i : _name)        \\\n        cin >> i;\n#else\n#define VIS(_kind, _name, _size)    \\\n    vector<_kind> _name;            \\\n    _name.resize(_size);            \\\n    for (int i = 0; i < _size; i++) \\\n        cin >> _name[i];\n#endif\n// alias\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define tcase() \\\n    int T;      \\\n    cin >> T;   \\\n    FOR(kase, 1, T + 1)\n// Swap max/min\ntemplate <typename T>\nbool smax(T &a, const T &b)\n{\n    if (a > b)\n        return false;\n    a = b;\n    return true;\n}\ntemplate <typename T>\nbool smin(T &a, const T &b)\n{\n    if (a < b)\n        return false;\n    a = b;\n    return true;\n}\n// ceil divide\ntemplate <typename T>\nT cd(T a, T b)\n{\n    return (a + b - 1) / b;\n}\n// min exchange\ntemplate <typename T>\nbool se(T &a, T &b)\n{\n    if (a < b)\n        return false;\n    swap(a, b);\n    return true;\n}\n// A better MAX choice\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef set<int> si;\ntypedef vector<string> cb;\n//====================END=====================\n\n// Constants here\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst double FAC = 1e-18;\n\ntypedef double db;\n\nint sgn(db x)\n{\n    if (abs(x) < EPS)\n        return 0;\n    if (x < 0)\n        return -1;\n    return 1;\n}\n\ninline db sqr(db x) { return x * x; }\n\n// Point/Vector\nstruct Point\n{\n    db x, y;\n\n    Point() : x(0.0), y(0.0) {}\n\n    Point(db _x, db _y) : x(_x), y(_y) {}\n\n    bool operator==(const Point &p)\n    {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n\n    bool operator<(const Point &p)\n    {\n        int c = sgn(x - p.x);\n        if (c)\n            return c == -1;\n        return sgn(y - p.y) == -1;\n    }\n\n    Point operator+(const Point &p) { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) { return Point(x - p.x, y - p.y); }\n    Point operator*(db d) { return Point(x * d, y * d); }\n    Point operator/(db d) { return Point(x / d, y / d); }\n\n    db operator^(const Point &p) { return x * p.y - y * p.x; }\n    db operator*(const Point &p) { return x * p.x + y * p.y; }\n\n    db dis(const Point &p) { return (*this - p).len(); }\n    db alpha() { return atan2(y, x); }\n\n    Point unit() { return *this / len(); }\n    Point scale(db r) { return unit() * r; }\n\n    Point rotCC() { return Point(-y, x); }\n    Point rotCL() { return Point(y, -x); }\n\n    Point rot(Point p, db angle)\n    {\n        Point v = *this - p;\n        db c = cos(angle), s = sin(angle);\n        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);\n    }\n\n    db len() { return hypot(x, y); }\n    db len2() { return x * x + y * y; }\n\n    db rad(Point a, Point b)\n    {\n        Point ap = a - *this, bp = b - *this;\n        return abs(atan2(abs(ap ^ bp), ap * bp));\n    }\n\n    void read() { cin >> x >> y; }\n    void write() { cout << x << ' ' << y; }\n    void Debug() { cerr << \"Point: (\" << x << \", \" << y << \")\\n\"; }\n};\n\n// Line\nstruct Line\n{\n    Point s, e;\n\n    Line(){};\n\n    Line(Point _s, Point _e) : s(_s), e(_e) {}\n\n    Line(Point p, db angle)\n    {\n        s = p;\n        if (sgn(angle - PI / 2))\n            e = (s + Point(1, tan(angle)));\n        else\n            e = (s + Point(0, 1));\n    }\n\n    //ax+by+c=0\n    Line(db a, db b, db c)\n    {\n        if (sgn(a) == 0)\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -c / b);\n        }\n        else if (sgn(b) == 0)\n        {\n            s = Point(-c / a, 0);\n            e = Point(-c / a, 1);\n        }\n        else\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -(c + a) / b);\n        }\n    }\n\n    db len() { return s.dis(e); }\n    db angle()\n    {\n        db ans = atan2(e.y - s.y, e.x - s.x);\n        if (sgn(ans) == -1)\n            ans += PI;\n        if (sgn(ans - PI) == 0)\n            ans -= PI;\n        return ans;\n    }\n\n    // 1 -> On Counter-clockwise\n    // 2 -> On Clockwise\n    // 3 -> On Line BUT MAY NOT ON THE SEGMENT!\n    int relation(Point p)\n    {\n        int c = sgn((p - s) ^ (e - s));\n        if (c < 0)\n            return 1;\n        else if (c > 0)\n            return 2;\n        return 3;\n    }\n\n    bool checkOn(Point p) { return relation(p) == 3 && sgn((p - s) ^ (p - e)) <= 0; }\n\n    bool parallel(Line l) { return sgn((e - s) ^ (l.e - l.s)) == 0; }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossSS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        int d3 = sgn((l.e - l.s) ^ (s - l.s));\n        int d4 = sgn((l.e - l.s) ^ (e - l.s));\n        if ((d1 ^ d2) == -2 && (d3 ^ d4) == -2)\n            return 2;\n        return (d1 == 0 && sgn((l.s - s) * (l.s - e)) <= 0) ||\n               (d2 == 0 && sgn((l.e - s) * (l.e - e)) <= 0) ||\n               (d3 == 0 && sgn((s - l.s) * (s - l.e)) <= 0) ||\n               (d4 == 0 && sgn((e - l.s) * (e - l.e)) <= 0);\n    }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossLS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        if ((d1 ^ d2) == -2)\n            return 2;\n        return (d1 == 0 || d2 == 0);\n    }\n\n    // 0 -> Parallel\n    // 1 -> Same\n    // 2 -> Intersect\n    int crossLL(Line l)\n    {\n        if (this->parallel(l))\n            return l.relation(s) == 3;\n        return 2;\n    }\n\n    Point intersec(Line l)\n    {\n        db a1 = (l.e - l.s) ^ (s - l.s);\n        db a2 = (l.e - l.s) ^ (e - l.s);\n        return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y * a2 - e.y * a1) / (a2 - a1));\n    }\n\n    db disPL(Point p) { return abs((p - s) ^ (e - s)) / len(); }\n    db disPS(Point p)\n    {\n        if (sgn((p - s) * (e - s)) < 0 || sgn((p - e) * (s - e)) < 0)\n            return min(p.dis(s), p.dis(e));\n        return disPL(p);\n    }\n    db disSS(Line l) { return min(min(disPS(l.s), disPS(l.e)), min(l.disPS(s), l.disPS(e))); }\n\n    Point proj(Point p) { return s + ((e - s) * ((e - s) * (p - s))) / ((e - s).len2()); }\n    Point refl(Point p)\n    {\n        Point q = proj(p);\n        return Point(2 * q.x - p.x, 2 * q.y - p.y);\n    }\n\n    bool operator==(Line l) { return s == l.s && e == l.e; }\n\n    void adjust()\n    {\n        if (e < s)\n            swap(s, e);\n    }\n\n    void read()\n    {\n        s.read();\n        e.read();\n    }\n\n    void Debug() { cerr << \"Line: Start: (\" << s.x << \", \" << s.y << \") End: (\" << e.x << \", \" << e.y << \")\\n\"; }\n};\n\n// Circle\nstruct Circle\n{\n    Point p;\n    db r;\n\n    Circle(){};\n\n    Circle(Point _p, db _r) : p(_p), r(_r) {}\n\n    Circle(db x, db y, db _r) : p({x, y}), r(_r) {}\n\n    Circle(Point a, Point b, Point c, bool in = false)\n    {\n        if (!in)\n        {\n            Line u = Line((a + b) / 2, (a + b) / 2 + (b - a).rotCC());\n            Line v = Line((b + c) / 2, (b + c) / 2 + (c - b).rotCC());\n            p = u.intersec(v);\n            r = p.dis(a);\n        }\n        else\n        {\n            Line u, v;\n            db m = atan2(b.y - a.y, b.x - a.x), n = atan2(c.y - a.y, c.x - a.x);\n            u.s = a;\n            u.e = a + Point(cos((n + m) / 2), sin((n + m) / 2));\n            v.s = b;\n            m = atan2(a.y - b.y, a.x - b.x), n = atan2(c.y - b.y, c.x - b.x);\n            v.e = b + Point(cos((n + m) / 2), sin((n + m) / 2));\n            p = u.intersec(v);\n            r = Line(a, b).disPS(p);\n        }\n    }\n\n    bool operator==(const Circle &c) { return p == c.p && sgn(r - c.r) == 0; }\n\n    bool operator<(const Circle &c) { return (p < c.p) || (p == c.p && sgn(r - c.r) < 0); }\n\n    db area() { return PI * r * r; }\n\n    db cir() { return 2 * PI * r; }\n\n    // 0 -> Outside\n    // 1 -> On\n    // 2 -> Inside\n    int relationP(Point v)\n    {\n        db dis = v.dis(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationS(Line l)\n    {\n        db dis = l.disPS(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationL(Line l)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // 1 -> Inside\n    // 2 -> Internally-tangent\n    // 3 -> Intersect\n    // 4 -> Externally-tangent\n    // 5 -> Disjoint\n    int relationC(Circle c)\n    {\n        db d = p.dis(c.p);\n        if (sgn(d - r - c.r) > 0)\n            return 5;\n        if (sgn(d - r - c.r) == 0)\n            return 4;\n        db l = abs(r - c.r);\n        if (sgn(d - r - c.r) < 0 && sgn(d - l) > 0)\n            return 3;\n        if (sgn(d - l) == 0)\n            return 2;\n        // TODO: Check if this one is necessary\n        // if (sgn(d - l) < 0)\n        return 1;\n    }\n\n    // The return value is the number of intersections\n    int crossC(Circle c, Point &p1, Point &p2)\n    {\n        int re = relationC(c);\n        if (re == 1 || re == 5)\n            return 0;\n        db d = p.dis(c.p), l = (d * d + r * r - c.r * c.r) / (2.0 * d), h = sqrt(r * r - l * l);\n        Point tmp = p + (c.p - p).scale(l);\n        p1 = tmp + (c.p - p).rotCC().scale(h);\n        p2 = tmp + (c.p - p).rotCL().scale(h);\n        if (re == 2 || re == 4)\n            return 1;\n        return 2;\n    }\n\n    // Same as above\n    int crossL(Line l, Point &p1, Point &p2)\n    {\n        if (!this->relationL(l))\n            return 0;\n        Point a = l.proj(p);\n        db d = l.disPL(p);\n        d = sqrt(r * r - d * d);\n        if (sgn(d) == 0)\n        {\n            p1 = a;\n            p2 = a;\n            return 1;\n        }\n        p1 = a + (l.e - l.s).scale(d);\n        p2 = a - (l.e - l.s).scale(d);\n        return 2;\n    }\n\n    int tangent(Point q, Line &u, Line &v)\n    {\n        int x = relationP(q);\n        if (x == 2)\n            return 0;\n        if (x == 1)\n        {\n            u = Line(q, q + (q - p).rotCC());\n            v = u;\n            return 1;\n        }\n        db d = p.dis(q);\n        db l = r * r / d;\n        db h = sqrt(r * r - l * l);\n        u = Line(q, p + ((q - p).scale(l) + (q - p).rotCC().scale(h)));\n        v = Line(q, p + ((q - p).scale(l) + (q - p).rotCL().scale(h)));\n        return 2;\n    }\n\n    // The area of intersecting space\n    // With circle c\n    db area(Circle c)\n    {\n        int re = relationC(c);\n        if (re >= 4)\n            return 0;\n        if (re <= 2)\n            return min(area(), c.area());\n        db d = p.dis(c.p);\n        db hf = (r + c.r + d) / 2.0;\n        db ss = 2 * sqrt(hf * (hf - r) * (hf - c.r) * (hf - d));\n        db a1 = acos((r * r + d * d - c.r * c.r) / (2.0 * r * d));\n        a1 = a1 * r * r;\n        db a2 = acos((c.r * c.r + d * d - r * r) / (2.0 * c.r * d));\n        a2 = a2 * c.r * c.r;\n        return a1 + a2 - ss;\n    }\n\n    // The area of intersecting space\n    // With triangle PAB\n    db area(Point a, Point b)\n    {\n        if (sgn((p - a) ^ (p - b)) == 0)\n            return 0.0;\n        Point q[5];\n        int len = 0;\n        q[len++] = a;\n        Line l(a, b);\n        Point p1, p2;\n        if (crossL(l, q[1], q[2]) == 2)\n        {\n            if (sgn((a - q[1]) * (b - q[1])) < 0)\n                q[len++] = q[1];\n            if (sgn((a - q[2]) * (b - q[2])) < 0)\n                q[len++] = q[2];\n        }\n        q[len++] = b;\n        if (len == 4 && sgn((q[0] - q[1]) * (q[2] - q[1])) > 0)\n            swap(q[1], q[2]);\n        double res = 0;\n        for (int i = 0; i < len - 1; i++)\n        {\n            if (relationP(q[i]) == 0 || relationP(q[i + 1]) == 0)\n            {\n                double arg = p.rad(q[i], q[i + 1]);\n                res += r * r * arg / 2.0;\n            }\n            else\n                res += fabs((q[i] - p) ^ (q[i + 1] - p)) / 2.0;\n        }\n        return res;\n    }\n\n    // Two circle whose center are a and b respectivelly\n    static int GetCircle(Point a, Point b, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(a, r), y(b, r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    // The circle which tangent is l and point p on it\n    static int GetCircle(Line l, Point p, db r, Circle &c1, Circle &c2)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r * 2) > 0)\n            return 0;\n        if (sgn(dis) == 0)\n        {\n            c1.p = p + ((l.e - l.s).rotCC().scale(r));\n            c2.p = p + ((l.e - l.s).rotCL().scale(r));\n            c1.r = c2.r = r;\n            return 2;\n        }\n        Line u1 = Line((l.s + (l.e - l.s).rotCC().scale(r)), (l.e + (l.e - l.s).rotCC().scale(r)));\n        Line u2 = Line((l.s + (l.e - l.s).rotCL().scale(r)), (l.e + (l.e - l.s).rotCL().scale(r)));\n        Circle cc(p, r);\n        Point p1, p2;\n        if (!cc.crossL(u1, p1, p2))\n            cc.crossL(u2, p1, p2);\n        c1 = Circle(p1, r);\n        if (p1 == p2)\n        {\n            c2 = c1;\n            return 1;\n        }\n        c2 = Circle(p2, r);\n        return 2;\n    }\n\n    // u and v are the common tangent of the four circles\n    static int GetCircle(Line u, Line v, db r, Circle &c1, Circle &c2, Circle &c3, Circle &c4)\n    {\n        if (u.parallel(v))\n            return 0;\n        Line u1 = Line(u.s + (u.e - u.s).rotCC().scale(r), u.e + (u.e - u.s).rotCC().scale(r));\n        Line u2 = Line(u.s + (u.e - u.s).rotCL().scale(r), u.e + (u.e - u.s).rotCL().scale(r));\n        Line v1 = Line(v.s + (v.e - v.s).rotCC().scale(r), v.e + (v.e - v.s).rotCC().scale(r));\n        Line v2 = Line(v.s + (v.e - v.s).rotCL().scale(r), v.e + (v.e - v.s).rotCL().scale(r));\n        c1.r = c2.r = c3.r = c4.r = r;\n        c1.p = u1.intersec(v1);\n        c2.p = u1.intersec(v2);\n        c3.p = u2.intersec(v1);\n        c4.p = u2.intersec(v2);\n        return 4;\n    }\n\n    // Tangent with circle cx and cy\n    static int GetCircle(Circle cx, Circle cy, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(cx.p, r + cx.r), y(cy.p, r + cy.r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    void read()\n    {\n        p.read();\n        cin >> r;\n    }\n\n    void Debug() { cerr << \"Circle: Center: (\" << p.x << \", \" << p.y << \") Radius: \" << r << '\\n'; }\n};\n\n// Pre-Build Function\ninline void build()\n{\n}\n\n// Actual Solver\ninline void solve()\n{\n    cout << fixed << setprecision(10);\n    Circle c;\n    c.read();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        Line l;\n        l.read();\n        Point p1, p2;\n        c.crossL(l, p1, p2);\n        se(p1, p2);\n        p1.write();\n        cout << ' ';\n        p2.write();\n        cout << '\\n';\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n#ifdef LOCAL\n    clock_t _begin = clock();\n#endif\n\n    build();\n    solve();\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << (double)(clock() - _begin) * 1000 / CLOCKS_PER_SEC << \"ms.\" << endl;\n#endif\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X)\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nnamespace Geometry{\n  #define EPS (1e-10)\n  #define equals(a,b) (fabs((a)-(b)) < EPS)\n\n  class Point{\n  public:\n    double x,y;\n\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n\n    bool operator < (const Point &p) const{\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n      return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS);\n    }\n\n    friend ostream& operator << (ostream &os,Point &p){\n      return os << p.x << \" \" << p.y;\n    }\n\n    friend istream& operator >> (istream &is,Point &p){\n      return is >> p.x >> p.y;\n    }\n  };\n  typedef Point Vector;\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &p){\n      return os << p.p1.x << \" \" << p.p1.y << \" \" << p.p2.x << \" \" << p.p2.y;\n    }\n\n    friend istream& operator >> (istream &is,Segment &p){\n      return is >> p.p1.x >> p.p1.y >> p.p2.x >> p.p2.y;\n    }\n  };\n  typedef Segment Line;\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){\n      return os << c.c.x << c.c.y << c.r;\n    }\n\n    friend istream& operator >> (istream &is,Circle &c){\n      return is >> c.c.x >> c.c.y >> c.r;\n    }\n  };\n\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){\n    return  a.x * a.x + a.y * a.y;\n  }\n\n  double abs(Vector a){\n    return sqrt(norm(a));\n  }\n\n  double dot(Vector a,Vector b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  double cross(Vector a,Vector b){\n    return a.x * b.y - a.y * b.x;\n  }\n\n  bool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n  }\n\n  bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1 - a1,b1 - b2);\n  }\n\n  bool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0);\n  }\n\n  bool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n  }\n\n  bool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1 - a2 , b1 - b2);\n  }\n\n  bool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n  }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base / norm(base));\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n\n  int ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n\n  bool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n  }\n\n  double getDistance(Vector a,Vector b){\n    return abs(a - b);\n  }\n\n  double getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1));\n  }\n\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n              min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    // cassert(intersect(c,l));\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){\n    return atan2(p.y,p.x);\n  }\n\n  Vector polar(double a,double r){\n    return Point(cos(r) * a, sin(r) * a);\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    // assert(intersect(c1,c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n\n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y < b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  Polygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0;i--){\n      for(int n = l.size();n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--)l.push_back(u[i]);\n    return l;\n  }\n\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  Circle c;\n  Line a;\n  cin >> c;\n  cin >> n;\n  while(n--){\n    cin >> a;\n    pair<Point,Point> ans = getCrossPoints(c,a);\n    if(ans.first.x < ans.second.x)fprints(8,ans.first,ans.second);\n    else if(ans.first.x == ans.second.y){\n      if(ans.first.y < ans.second.y)fprints(8,ans.first,ans.second);\n      else fprints(8,ans.second,ans.first);\n    }else{\n      fprints(8,ans.second,ans.first);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eps 1e-9\n#define nmax 200\n#define f(c,a,b) for(int c=a; c<=b; c++)\n\nusing namespace std;\ntypedef double db;\nstruct P{\n    db x, y;\n    P(){}\n    P(db x, db y) : x(x) , y(y) {}\n    P operator - (P a){ return P(x-a.x, y-a.y); }\n    db times(P a){ return x*a.y-y*a.x; }\n    db clen() { return x*x+y*y; }\n    db dot(P a){ return a.x*x + a.y*y; }\n    P operator * (db a) { return P(a*x, a*y); }\n    P operator + (P a){ return P(x+a.x, y+a.y); }\n    void swap(P& a){\n        db tx = x, ty = y;\n        x = a.x;  y = a.y;\n        a.x = tx; a.y = ty;\n    }\n    bool operator < (const P a) const { return (x==a.x)?(y<a.y):(x<a.x); }\n}po[nmax];\n\nint sign(db x) { return (x<-eps) ? -1 : x>eps; }    \n\nP projection(P a, P p, P q){ \n    P tl = q - p; \n    db ll = sqrt(tl.clen());  \n    db k = (a-p).dot(tl)/ll/ll;  \n    return P( p.x + k*tl.x, p.y + k*tl.y ); \n}\n\nvoid isCL(P c1, db r1, P p1, P q1){\n    if(q1<p1) p1.swap(q1);\n    db dis = (p1-c1).times(p1-q1)/(p1-q1).clen();\n    dis *= (p1-c1).times(p1-q1);\n    dis = sqrt( r1*r1-dis );\n    P pj = projection(c1, p1, q1);\n    P a1, a2;\n    a1 = pj+(p1-q1)*( dis/sqrt((p1-q1).clen()) );\n    a2 = pj+(q1-p1)*( dis/sqrt((q1-p1).clen()) );\n    printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", a1.x, a1.y, a2.x, a2.y);\n}\n\nint main(){\n    //freopen(\"owo.in\",\"r\",stdin);\n    P c, ip, iq;\n    db r;\n    int q;\n    cin >> c.x >> c.y >> r >> q;\n    while(q--){\n        scanf(\"%lf%lf%lf%lf\", &ip.x, &ip.y, &iq.x, &iq.y);\n        isCL(c, r, ip, iq);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nstruct Point{double x,y;}p0,p1;\nstruct Circle{Point x;double r;}c;\nPoint operator +(Point a,Point b){return (Point){a.x+b.x,a.y+b.y};}\nPoint operator -(Point a,Point b){return (Point){a.x-b.x,a.y-b.y};}\nPoint operator *(Point a,double b){return (Point){a.x*b,a.y*b};}\nPoint operator /(Point a,double b){return (Point){a.x/b,a.y/b};}\nbool operator >(Point a,Point b){return a.x>b.x||(a.x==b.x&&a.y>b.y);}\ndouble dot(Point a,Point b){return a.x*b.x+a.y*b.y;}\ndouble norm(Point a){return a.x*a.x+a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\nvoid read(Point &a){a.x=read(),a.y=read();}\nvoid read(Circle &a){read(a.x),a.r=read();}\nvoid print(Point a){printf(\"%.8lf %.8lf\",a.x,a.y);}\nPoint Project(Point p0,Point p1,Point p)\n{\n\tPoint base=p1-p0,hypo=p-p0;\n\tdouble r=dot(base,hypo)/norm(base);\n\treturn p0+base*r;\n}\npair<Point,Point>getintersection(Circle c,Point p0,Point p1)\n{\n\tPoint pr=Project(p0,p1,c.x),e=(p1-p0)/abs(p1-p0);\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.x));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\nint main()\n{\n\tread(c);\n\tint q=read();while(q--)\n\t{\n\t\tread(p0),read(p1);\n\t\tpair<Point,Point>p=getintersection(c,p0,p1);\n\t\tif(p.first>p.second)swap(p.first,p.second);\n\t\tprint(p.first);putchar(' ');print(p.second);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct point{\n    double  x,y;\n    point(){};\n    point(double x,double y):x(x),y(y){}\n    point operator + (point p){\n        return point(x+p.x,y+p.y);\n    }\n    point operator - (point p){\n        return point(x-p.x,y-p.y);\n    }\n    point operator * (double k){\n        return point(x*k,y*k);\n    }\n    point operator / (double k){\n        return point(x/k,y/k);\n    }\n};\n\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(point a,point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(point p)\n{\n    return p.x*p.x+p.y*p.y;\n}\ndouble ABS(point p)\n{\n    return sqrt(norm(p));\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/norm(base);\n    return a+(base*r);\n}\n\npair<point,point>getcrosspoints(point a,int r,point b,point c)\n{\n    point pr=project(b,c,a);\n    point e=(b-c)/ABS(b-c);\n    double base=sqrt(r*r*1.0-norm(pr-a));\n    e=e*base;\n    return make_pair(pr+e,pr-e);\n}\n\nint main()\n{\n    point a;\n    int temp;\n    cin>>a.x>>a.y>>temp;\n    int q;\n    cin>>q;\n    point c,d;\n    for(int i=0;i<q;i++){\n        cin>>c.x>>c.y>>d.x>>d.y;\n        pair<point,point>res=getcrosspoints(a,temp,c,d);\n        printf(\"%.8f %.8f %.8f %.8f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//#define ll long long\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define rep(i, n) REP(i, 0, n)\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define all(x) (x).begin(),(x).end()\nll t1,t2;\nconst ll mod = 1000000007;\nconst int INF = 1e9;\nconst ll INFLONG = 1e18;\nvoid swap(ll *x,ll *y){\n  ll tmp;\n  tmp = *x;\n  *x = *y;\n  *y = tmp;\n}\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\nclass Point {\npublic:\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point():x(0),y(0){}\n\n    Point operator + (Point p) {return Point(x + p.x,y + p.y);}\n    Point operator - (Point p ){return Point(x - p.x,y - p.y);}\n    Point operator * (double a){return Point(x*a,y*a);}\n    Point operator / (double a){return Point(x/a,y/a);}\n\n    double abs(){return sqrt(norm());}\n    double norm(){return x * x + y * y;}\n\n    bool operator < (const Point & p) const {\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n      return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n\n    void set(double x,double y) {\n      this->x = x;\n      this->y = y;\n    }\n\n    void rotateR(){\n      double xt = x;\n      double yt = y;\n      x = yt;\n      y = -xt;\n    }\n    void rotateL(){\n      double xt = x;\n      double yt = y;\n      x = -yt;\n      y = xt;\n    }\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0):c(c),r(r){}\n};\n\n\n\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble norm(Point a){\n  return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n  return sqrt(norm(a));\n}\n\nbool eq(Point a,Point b){\n  return abs(a-b) < EPS;\n}\n\ndouble dot(Vector a, Vector b){\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a,Vector b){\n  return a.x * b.y - a.y * b.x;\n}\n\n//直交\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\n//平行\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\n//射影\nPoint project(Segment s,Point p){\n  Point vec1,vec2;\n  vec1 = s.p2 - s.p1;\n  vec2 = p - s.p1;\n  return s.p1 + vec1 * dot(vec1,vec2) / vec1.norm();\n}\n\n//反射\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p) - p)* 2;\n}\n\n//位置関係(時計回りか,線分上かなど)\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(a.norm() < b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\n\n//交わるか\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistance(Point a,Point b){\n  return abs(a-b);\n}\n\n// Line : Point\ndouble getDistanceLP(Line l,Point p){\n  return abs((cross(l.p2 - l.p1,p - l.p1) / abs(l.p2 - l.p1)));\n}\n\n// Segment : Point\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2 - s.p1,p - s.p1) < 0.0){\n    return abs(p - s.p1);\n  }\n  if(dot(s.p1 - s.p2,p - s.p2) < 0.0){\n    return abs(p - s.p2);\n  }\n  return getDistanceLP(s,p);\n}\n\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)){\n    return 0.0;\n  }\n  double ans = INF;\n  chmin(ans,getDistanceSP(s1,s2.p1));\n  chmin(ans,getDistanceSP(s1,s2.p2));\n  chmin(ans,getDistanceSP(s2,s1.p1));\n  chmin(ans,getDistanceSP(s2,s1.p2));\n  return ans;\n}\n\nbool intersect(Circle c,Line l){\n  return c.r - getDistanceLP(l,c.c) > -EPS;\n}\n\n//円と直線の交点\npair<Point,Point> getCrossPoint(Line l,Circle c){\n  assert(intersect(c,l));\n  Vector pr = project(l,c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  if(e.x < 0 || (e.x < EPS && e.y < 0)){\n    e = e * -1;\n  }\n  double base = sqrt(c.r * c.r - norm(pr - c.c));\n  return make_pair(pr - e * base,pr + e * base);\n}\n\n//円と円の交点\n//pair<Point,Point> getCrossPoint(Circle c1,Circle c2){\n//\n//}\n\n//int main() {\n//  double cx,cy,r;\n//  cin >> cx >> cy >> r;\n//  Point pc1(cx,cy);\n//  cin >> cx >> cy >> r;\n//  Point pc2(cx,cy);\n//\n//  Circle c1(pc1,r),c2(pc2,r);\n//}\n\nint main() {\n  double cx,cy,r;\n  cin >> cx >> cy >> r;\n  Point pc(cx,cy);\n  Circle c(pc,r);\n  ll q;\n  double x, y;\n  cin >> q;\n  vector<Point> p(2);\n  Segment s1;\n  pair<Point,Point> pa;\n  rep(i,q){\n    rep(j,2){\n      cin >> x >> y;\n      p[j] = Point(x,y);\n    }\n    s1.p1 = p[0];\n    s1.p2 = p[1];\n    pa = getCrossPoint(s1,c);\n    printf(\"%.15f %.15f \",pa.first.x,pa.first.y);\n    printf(\"%.15f %.15f\\n\",pa.second.x,pa.second.y);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Point Vector;\ntypedef Segment Line;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\n\nPoint p;\ndouble r;\nSegment s;\n\nPoint rotate( Point a, double si,double co){\n  return Point(a.x*co-a.y*si,a.x*si+a.y*co);\n}\n\nvector<Point> solve(){\n  vector<Point> res;\n  Point q=project(s,p);\n  double d=sqrt(r*r-abs(p-q)*abs(p-q));\n  Vector base=s.p1-s.p2;\n  res.push_back(q+base*(d/abs(base)));\n  res.push_back(q-base*(d/abs(base)));\n  return res;\n}\n\nint main(){\n  cin>>p.x>>p.y>>r;\n  int tc;\n  cin>>tc;\n  for(int i=0;i<tc;i++){\n    cin>>s.p1.x>>s.p1.y>>s.p2.x>>s.p2.y;\n    vector<Point> t=solve();\n    printf(\"%.8f %.8f %.8f %.8f\\n\",t[0].x,t[0].y,t[1].x,t[1].y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nstruct Point{double x,y;}p0,p1;\nstruct Circle{Point x;double r;}c;\nPoint operator +(Point a,Point b){return (Point){a.x+b.x,a.y+b.y};}\nPoint operator -(Point a,Point b){return (Point){a.x-b.x,a.y-b.y};}\nPoint operator *(Point a,double b){return (Point){a.x*b,a.y*b};}\nPoint operator /(Point a,double b){return (Point){a.x/b,a.y/b};}\nbool operator >(Point a,Point b){return a.x>a.y||(a.x==b.x&&a.y>b.y);}\ndouble dot(Point a,Point b){return a.x*b.x+a.y*b.y;}\ndouble norm(Point a){return a.x*a.x+a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\nvoid read(Point &a){a.x=read(),a.y=read();}\nvoid read(Circle &a){read(a.x),a.r=read();}\nvoid print(Point a){printf(\"%.8lf %.8lf\",a.x,a.y);}\nPoint Project(Point p0,Point p1,Point p)\n{\n\tPoint base=p1-p0,hypo=p-p0;\n\tdouble r=dot(base,hypo)/norm(base);\n\treturn p0+base*r;\n}\npair<Point,Point>getintersection(Circle c,Point p0,Point p1)\n{\n\tPoint pr=Project(p0,p1,c.x),e=(p1-p0)/abs(p1-p0);\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.x));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\nint main()\n{\n\tread(c);\n\tint q=read();while(q--)\n\t{\n\t\tread(p0),read(p1);\n\t\tpair<Point,Point>p=getintersection(c,p0,p1);\n\t\tif(p.first>p.second)swap(p.first,p.second);\n\t\tprint(p.first);putchar(' ');print(p.second);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////\n// ???????????????\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n////////////////////\n// ??¨????????¢???\nusing D = double;\n////////////////////\n// ?????°\nconst D EPS = 1e-9;                // |EPS|???????????°???0??¨????????±???\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // 3??????????????¢???\n////////////////////\n// ?§???????\nstruct Point {\n  D x, y;\n  Point(const D d = 0.0) : x(d), y(d) {}\n  Point(const D x, const D y) : x(x), y(y) {}\n};\nstruct Segment {\n  Point initial, terminal;\n  Segment(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Segment(const D x1, const D y1, const D x2, const D y2) : initial(x1, y1), terminal(x2, y2) {}\n};\nstruct Line {\n  Point initial, terminal;\n  Line(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Line(const D x1, const D y1, const D x2, const D y2) : initial(x1, y1), terminal(x2, y2) {}\n  Line(const Segment& s) : initial(s.initial), terminal(s.terminal) {}\n};\n////////////////////\n// ????£?\nbool relative_equal(const D d1, const D d2) {return d1 == 0 ? std::abs(d2) < EPS : std::abs((d1 - d2) / d1) < EPS;}\n// ??????????????????????????????\nbool operator==(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) && relative_equal(lhs.y, rhs.y);}\nbool operator<(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y < rhs.y : lhs.x < rhs.x;}\nbool operator>(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y > rhs.y : lhs.x > rhs.x;}\nbool operator!=(const Point& lhs, const Point& rhs) {return !(lhs == rhs);}\nbool operator<=(const Point& lhs, const Point& rhs) {return !(lhs > rhs);}\nbool operator>=(const Point& lhs, const Point& rhs) {return !(lhs < rhs);}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x + rhs.x, lhs.y + rhs.y);}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x * rhs.x, lhs.y * rhs.y);}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x / rhs.x, lhs.y / rhs.y);}\nconst Point operator-(const Point& p) {return Point(-p.x, -p.y);}\n// ???\nD abs(const Point& p) {return std::hypot(p.x, p.y);}\nD norm(const Point& p) {return p.x * p.x + p.y * p.y;}\nD dot(const Point& a, const Point& b) {return a.x * b.x + a.y * b.y;}\nD cross(const Point& a, const Point& b) {return a.x * b.y - a.y * b.x;}\n// const Point normalize(const Point& p) {return p / abs(p);}\n// const Point normal(const Point& p) {return normalize(Point(-p.y, p.x));}\n// ??´???\nbool parallel(const Line& l1, const Line& l2) {return relative_equal(0.0, cross(l2.terminal - l2.initial, l1.terminal - l1.initial));}\nbool orthogonal(const Line& l1, const Line& l2) {return relative_equal(0.0, dot(l2.terminal - l2.initial, l1.terminal - l1.initial));}\n// 3??????????????¢???\nPOSITION ccw(const Point& a, const Point& b, const Point& p) {\n  Point v1 = b - a;\n  Point v2 = p - a;\n  if(cross(v1, v2) >= EPS) return COUNTER_CLOCKWISE;\n  if(cross(v1, v2) <= -EPS) return CLOCKWISE;\n  if(dot(v1, v2) <= -EPS) return ONLINE_BACK;\n  if(norm(v1) < norm(v2)) return ONLINE_FRONT;              // ????????????: norm(v1)<norm(v2)+EPS?????¨WrongAnswer\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(const Point& p1, const Point& p2) {return p1 == p2;}\nbool intersect(const Point& p, const Segment& s) {return abs(p - s.initial) + abs(p - s.terminal) - abs(s.initial - s.terminal) <= EPS;}\nbool intersect(const Segment& s, const Point& p) {return intersect(p, s);}\nbool intersect(const Point& p, const Line& l) {return !parallel(Line(p, l.initial), Line(p, l.terminal));}\nbool intersect(const Line& l, const Point& p) {return intersect(p, l);}\nbool intersect(const Segment& s1, const Segment& s2) {\n  return ccw(s1.initial, s1.terminal, s2.initial) * ccw(s1.initial, s1.terminal, s2.terminal) <= 0\n      && ccw(s2.initial, s2.terminal, s1.initial) * ccw(s2.initial, s2.terminal, s1.terminal) <= 0;\n}\nbool intersect(const Segment& s, const Line& l) {\n  auto v1 = l.terminal - l.initial;\n  auto v2 = s.initial  - l.initial;\n  auto v3 = s.terminal - l.initial;\n  return cross(v1, v2) * cross(v1, v3) <= EPS;\n}\nbool intersect(const Line& l, const Segment& s) {return intersect(s, l);}\nbool intersect(const Line& l1, const Line& l2) {return !parallel(l1, l2) || intersect(l1.initial, l2);}\n// ???????§????\nPoint rotate(const Point& p, const D a) {return Point(p.x * std::cos(a) - p.y * std::sin(a), p.x * std::sin(a) + p.y * std::cos(a));}\nPoint projection(const Point& p, const Line& l) {\n  auto v = l.initial - l.terminal;\n  return l.initial + dot(p - l.initial, v) / norm(v) * v;\n}\nPoint projection(const Line& l, const Point& p) {return projection(p, l);}\nPoint reflection(const Point& p, const Line& l) {return p + 2 * (projection(p, l) - p);}\nPoint reflection(const Line& l, const Point& p) {return reflection(p, l);}\n// ?????¢\nD distance(const Point& p1, const Point& p2) {\n  auto p = p1 - p2;\n  return hypot(p.x, p.y);\n}\nD distance(const Point& p, const Segment& s) {\n  auto r = projection(s, p);\n  return intersect(r, s) ? distance(p, r) : std::min(distance(p, s.initial), distance(p, s.terminal));\n}\nD distance(const Segment& s, const Point& p) {return distance(p, s);}\nD distance(const Point& p, const Line& l) {return distance(p, projection(p, l));}\nD distance(const Line& l, const Point& p) {return distance(p, l);}\nD distance(const Segment& s1, const Segment& s2) {\n  return intersect(s1, s2) ? 0.0 : std::min({distance(s1, s2.initial), distance(s1, s2.terminal), distance(s2, s1.initial), distance(s2, s1.terminal)});\n}\nD distance(const Segment& s, const Line& l) {return intersect(s, l) ? 0.0 : std::min(distance(s.initial, l), distance(s.terminal, l));}\nD distance(const Line& l,const Segment& s) {return distance(s, l);}\nD distance(const Line& l1, const Line& l2) {return intersect(l1, l2) ? 0.0 : distance(l1.initial, l2);}\n// ??????\nconst Point crosspoint(const Line& l1, const Line& l2) {\n  assert(intersect(l1, l2));\n  if(parallel(l1, l2)) return l1.initial;                   // ???????????¨???l1????§?????????????\n  D A = cross(l1.terminal - l1.initial, l2.terminal - l2.initial);\n  D B = cross(l1.terminal - l1.initial, l1.terminal - l2.initial);\n  return l2.initial + B / A * (l2.terminal - l2.initial);\n}\nconst Point crosspoint(const Segment& s, const Line& l) {\n  assert(intersect(s, l));\n  if(parallel(s, l)) return s.initial;\n  return crosspoint(Line(s), l);\n}\nconst Point crosspoint(const Line& l, const Segment& s) {return crosspoint(s, l);}\nconst Point crosspoint(const Segment& s1, const Segment& s2) {\n  assert(intersect(s1, s2));\n  if(parallel(s1, s2)) {                                    // ???????????¨?????????????????????????????????\n    if(intersect(s1.initial,  s2)) return s1.initial;\n    if(intersect(s1.terminal, s2)) return s1.terminal;\n    if(intersect(s2.initial,  s1)) return s2.initial;\n    if(intersect(s2.terminal, s1)) return s2.terminal;\n  }\n  return crosspoint(Line(s1), Line(s2));\n}\n// ???????????°??¨\n#include<iostream>\nstd::ostream& operator<<(std::ostream& os, const Point& p) {os<<\"point: \"; os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os;}\nstd::ostream& operator<<(std::ostream& os, const Segment& s) {os<<\"segment: \"; os<<s.initial<<\" - \"<<s.terminal; return os;}\nstd::ostream& operator<<(std::ostream& os, const Line& l) {os<<\"line: \"; os<<l.initial<<\" - \"<<l.terminal; return os;}\n////////////////////////////////////////////////////////////////////////////////\n// ???\n#include<vector>\nconst D PI = std::acos(-1);\nstruct Circle {\n  Point center;\n  D radius;\n  Circle(const Point& center = 0, const D radius = 0) : center(center), radius(radius) {}\n  Circle(const D x, const D y, const D radius) : center(x, y), radius(radius) {}\n};\nD area(const Circle& c) {return PI * c.radius * c.radius;}\nbool contain(const Circle& c, const Point& p) {\n  D d = abs(p - c.center);\n  if(relative_equal(c.radius, d)) return true;\n  return d < c.radius;\n}\nbool contain(const Point& p, const Circle& c) {return contain(c, p);}\nstd::vector<Point> crosspoint(const Circle& c, const Line& l) {\n  std::vector<Point> cp;\n  Point p = projection(c.center, l);\n  if(!contain(c, p)) return cp;\n  Point v = p - c.center;\n  if(relative_equal(abs(v), 0)) {\n    Point p = l.initial - c.center;\n    if(p == 0) p = l.terminal - c.center;\n    p = (c.radius * p / abs(p));\n    cp.push_back(c.center + p);\n    cp.push_back(c.center - p);\n    return cp;\n  }\n  D angle = acos(abs(v) / c.radius);\n  for(D a: {angle, -angle}) cp.push_back(c.center + c.radius * (rotate(v, a) / abs(v)));\n  return cp;\n}\nstd::vector<Point> crosspoint(const Line& l, const Circle& c) {return crosspoint(c, l);}\nint tangent(const Circle& c1, const Circle& c2) {\n  D d = abs(c1.center - c2.center);\n  D r = c1.radius + c2.radius;\n  if(relative_equal(d, r)) return 3;    // ?????\\\n  if(r < d) return 4;                   // ?????¢\n  r = std::abs(c1.radius - c2.radius);\n  if(relative_equal(d, r)) return 1;    // ?????\\\n  if(r < d) return 2;                   // ??????\n  return 0;                             // ??????\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ????§???¢\n//   ????????????????????°??????????????´??? ??? ?????¢???????´????edge(void)???O(????????°)???edge().begin()????????£????????????????????????????????????????????????\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<utility>\nclass Polygon {\npublic:\n  // ??¨???\n  void add(const Point& p);\n  void clear();\n  // ?????±\n  int size() const;\n  Point vertex(const int n) const;\n  Segment edge(const int n) const;\n  const std::vector<Point>& vertex() const;\n  const std::vector<Segment>& edge() const;\n  // ??????\n  bool touch(const Point& p) const;\n  bool intersect(const Point& p) const;\n  D area() const;\n  bool convex() const;\n  // ???????§???¢\n  const Polygon convex_hull() const;\n  D convex_diameter() const;\n  const Polygon convex_cut(const Line& l) const;\nprivate:\n  std::vector<Point> vertex_;\n  std::vector<Segment> edge_;\n};\n// ??¨???\nvoid Polygon::add(const Point& p) {\n  if(!vertex_.empty()) {\n    if(!edge_.empty()) edge_.pop_back();\n    edge_.push_back(Segment(vertex_.back(), p));\n    edge_.push_back(Segment(p, vertex_.front()));\n  }\n  vertex_.push_back(p);\n}\nvoid Polygon::clear() {\n  vertex_.clear();\n  edge_.clear();\n};\n// ?????±\nint Polygon::size() const {return vertex_.size();}\nPoint Polygon::vertex(const int n) const {return vertex_.at(n);}\nSegment Polygon::edge(const int n) const {return edge_.at(n);}\nconst std::vector<Point>& Polygon::vertex() const {return vertex_;}\nconst std::vector<Segment>& Polygon::edge() const {return edge_;}\n// ??????\nbool Polygon::touch(const Point& p) const {\n  return std::any_of(std::begin(edge()), std::end(edge()), [=](const Segment& s) {return ccw(s.initial, s.terminal, p) == ON_SEGMENT;});\n}\nbool Polygon::intersect(const Point& p) const {\n  bool in = false;                    // p=(x,y)??????(INF,y)???????????´?????¨????§???¢??¨????????????????????° mod 2\n  for(const auto& e: edge()) {\n    if(::intersect(p, e)) return true;\n    Point a = e.initial  - p;\n    Point b = e.terminal - p;\n    if(a.y > b.y) std::swap(a, b);\n    if(a.y < EPS && EPS <= b.y && cross(a, b) < EPS) in = !in;\n  }\n  return in;\n}\nD Polygon::area() const {\n  return std::abs(std::accumulate(std::begin(edge()), std::end(edge()), 0.0, [=](const D sum, const Segment& e){return sum + cross(e.initial, e.terminal);})) / 2.0;\n}\nbool Polygon::convex() const {\n  bool positive = false;\n  bool negative = false;\n  for(int i = 0; i < size(); ++i) {\n    auto position = ccw(vertex(i), vertex((i + 1) % size()), vertex((i + 2) % size()));\n    positive |= position == CLOCKWISE;\n    negative |= position == COUNTER_CLOCKWISE;\n    if(negative && positive) return false;\n  }\n  return true;\n}\n// ???????§???¢\n// Andrew's Monotone Chain: O(n log n)\nconst Polygon Polygon::convex_hull() const {\n  auto original = vertex();\n  std::sort(std::begin(original), std::end(original));\n  original.insert(std::end(original), original.rbegin() + 1, original.rend());\n  std::vector<Point> point;\n  for(const auto& p: original) {\n    while(point.size() >= 2 && ccw(point[point.size() - 2], point.back(), p) == CLOCKWISE) point.pop_back();\n    point.push_back(p);\n  }\n  Polygon convex_hull;\n  point.pop_back();\n  for(const auto& p: point) convex_hull.add(p);\n  return convex_hull;\n}\n// Rotating calipers: O(n)\nD Polygon::convex_diameter() const {\n  auto point = vertex();\n  int p, q, start_p, start_q, max_p, max_q;\n  p = start_p = max_p = std::min_element(std::begin(point), std::end(point)) - std::begin(point);\n  q = start_q = max_q = std::max_element(std::begin(point), std::end(point)) - std::begin(point);\n  D max_d = norm(vertex(p) - vertex(q));\n  do {\n    if(cross(vertex((p + 1) % size()) - vertex(p), vertex((q + 1) % size()) - vertex(q)) >= 0) q = (q + 1) % size();\n    else p = (p + 1) % size();\n    if(norm(vertex(p) - vertex(q)) > max_d) {\n      max_d = norm(vertex(p) - vertex(q));\n      max_p = p;\n      max_q = q;\n    }\n  } while(start_p != q || start_q != p);\n  return std::sqrt(max_d);\n}\nconst Polygon Polygon::convex_cut(const Line& l) const {\n  Polygon result;\n  for(const auto& e: edge()) {\n    if(ccw(l.initial, l.terminal, e.initial) == COUNTER_CLOCKWISE) result.add(e.initial);\n    if(::intersect(e, l)) result.add(crosspoint(e, l));\n  }\n  return result;\n}\n////////////////////////////////////////////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  Circle c;\n  cin >> c.center.x >> c.center.y >> c.radius;\n  int q;\n  cin >> q;\n  for(auto i=0;i<q;++i){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    auto cp = crosspoint(c, Line(x1, y1, x2, y2));\n    if(cp[0] > cp[1]) swap(cp[0], cp[2]);\n    cout << setprecision(8) << fixed << cp[0].x << \" \" << cp[0].y << \" \" << cp[1].x << \" \" << cp[1].y << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n#define EPS (1e-10)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point { double x, y; };//点\nstruct Segment { Point p1, p2; };//線\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ndouble dot(Point a, Point b) {//内積\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(Point a, Point b) {//外積\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(Point a) {\n    return a.x * a.x + a.y * a.y;\n}\ndouble absv(Point a) {\n    return sqrt(norm(a));\n}\nPoint project(Segment s, Point p) {\n    Point base, q;\n    Point ans;\n    base.x = s.p2.x - s.p1.x;\n    base.y = s.p2.y - s.p1.y;\n    q.x = p.x - s.p1.x;\n    q.y = p.y - s.p1.y;\n    double r = dot(q, base) / norm(base);\n    ans.x = s.p1.x + base.x * r;\n    ans.y = s.p1.y + base.y * r;\n    return ans;\n}\nPoint reflect(Segment s, Point p) {\n    Point ans;\n    ans.x = p.x + (project(s, p).x - p.x) * 2.0;\n    ans.y = p.y + (project(s, p).y - p.y) * 2.0;\n    return ans;\n}\ndouble getPointDistance(Point a, Point b) {\n    Point ans;\n    ans.x = a.x - b.x;\n    ans.y = a.y - b.y;\n    return absv(ans);\n}\ndouble getDistanceLP(Segment l, Point p) {\n    Point tmp, tmp2;\n    tmp.x = l.p2.x - l.p1.x;\n    tmp.y = l.p2.y - l.p1.y;\n    tmp2.x = p.x - l.p1.x;\n    tmp2.y = p.y - l.p1.y;\n    return abs(cross(tmp, tmp2) / absv(tmp));\n}\ndouble getDistanceSP(Segment s, Point p) {\n    Point t1, t2, t3, t4;\n    t1.x = s.p2.x - s.p1.x;\n    t1.y = s.p2.y - s.p1.y;\n    t2.x = p.x - s.p1.x;\n    t2.y = p.y - s.p1.y;\n    t3.x = s.p1.x - s.p2.x;\n    t3.y = s.p1.y - s.p2.y;\n    t4.x = p.x - s.p2.x;\n    t4.y = p.y - s.p2.y;\n    if (dot(t1, t2) < 0.0)return absv(t2);\n    if (dot(t3, t4) < 0.0)return absv(t4);\n    return getDistanceLP(s, p);\n}\nint ccw(Point p0, Point p1, Point p2) {\n    Point a, b;\n    a.x = p1.x - p0.x;\n    a.y = p1.y - p0.y;\n    b.x = p2.x - p0.x;\n    b.y = p2.y - p0.y;\n    if (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n    if (cross(a, b) < (-EPS))return CLOCKWISE;\n    if (dot(a, b) < (-EPS))return ONLINE_BACK;\n    if (norm(a) < norm(b))return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersectS(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Point base, a, b, c;\n    base.x = s2.p2.x - s2.p1.x;\n    base.y = s2.p2.y - s2.p1.y;\n    a.x = s1.p1.x - s2.p1.x;\n    a.y = s1.p1.y - s2.p1.y;\n    b.x = s1.p2.x - s2.p1.x;\n    b.y = s1.p2.y - s2.p1.y;\n    double d1 = abs(cross(base, a));\n    double d2 = abs(cross(base, b));\n    double t = d1 / (d1 + d2);\n    c.x = s1.p1.x + (s1.p2.x - s1.p1.x) * t;\n    c.y = s1.p1.y + (s1.p2.y - s1.p1.y) * t;\n    return c;\n}\ndouble getDistance(Segment s1, Segment s2) {\n    if (intersectS(s1, s2))return 0.0;\n    double a, b;\n    a = min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2));\n    b = min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n    return min(a, b);\n}\npair<Point, Point> getCrossPoints(Circle c, Segment l) {\n    Point a, b, z1, z2;\n    a.x = l.p2.x - l.p1.x;\n    a.y = l.p2.y - l.p1.y;\n    Point pr = project(l, c.c);\n    Point e;\n    e.x = a.x / absv(a);\n    e.y = a.y / absv(a);\n    b.x = pr.x - c.c.x;\n    b.y = pr.y - c.c.y;\n    double base = sqrt(c.r * c.r - norm(b));\n    z1.x = pr.x + e.x * base;\n    z1.y = pr.y + e.y * base;\n    z2.x = pr.x - e.x * base;\n    z2.y = pr.y - e.y * base;\n    return make_pair(z1, z2);\n}\nint main(void) {\n    Circle a;\n    Segment s;\n    pair<Point, Point> ans;\n    cin >> a.c.x >> a.c.y >> a.r;\n    int n; cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n        ans = getCrossPoints(a, s);\n        if (ans.first.x < ans.second.x) {\n            cout << fixed << setprecision(8) << ans.first.x << \" \";\n            cout << fixed << setprecision(8) << ans.first.y << \" \";\n            cout << fixed << setprecision(8) << ans.second.x << \" \";\n            cout << fixed << setprecision(8) << ans.second.y << endl;\n        }else if(ans.first.x == ans.second.x){\n            if(ans.first.y<ans.second.y){\n                cout << fixed << setprecision(8) << ans.first.x << \" \";\n                cout << fixed << setprecision(8) << ans.first.y << \" \";\n                cout << fixed << setprecision(8) << ans.second.x << \" \";\n                cout << fixed << setprecision(8) << ans.second.y << endl;\n            }else{\n                cout << fixed << setprecision(8) << ans.second.x << \" \";\n                cout << fixed << setprecision(8) << ans.second.y << \" \";\n                cout << fixed << setprecision(8) << ans.first.x << \" \";\n                cout << fixed << setprecision(8) << ans.first.y << endl;\n            }\n        }\n        else {\n            cout << fixed << setprecision(8) << ans.second.x << \" \";\n            cout << fixed << setprecision(8) << ans.second.y << \" \";\n            cout << fixed << setprecision(8) << ans.first.x << \" \";\n            cout << fixed << setprecision(8) << ans.first.y << endl;\n        }\n        \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-12;\n\n#define GE(n,m) (EPS > (m) - (n) )\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nVP crosspointLC(Point a1, Point a2, Point c, double r) {\n  VP ps;\n  Point ft = proj(a1, a2, c);\n  if(!GE(r*r,norm(ft-c))) assert(false);\n  Point dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  ps.push_back(ft - dir);\n  return ps;\n}\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nint main(void){\n    double cx,cy,r;\n    int q;\n    cin>>cx>>cy>>r>>q;\n    rep(i,q){\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        VP ps = crosspointLC(Point(x1,y1),Point(x2,y2),Point(cx,cy),r);\n        sort(all(ps));\n        printf(\"%.9f %.9f \" ,ps[0].X,ps[0].Y);\n        printf(\"%.9f %.9f\\n\",ps[1].X,ps[1].Y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-8; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}\n\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <valarray>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n//#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 24)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,...) [&](const t & a) -> bool { return __VA_ARGS__; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,...) [&](const t & a, const t & b) -> bool { return __VA_ARGS__; }\n#define CONVERTER(TSrc,t,TDest,...) [&](const TSrc &t)->TDest { return __VA_ARGS__; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H????????????\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\n#ifdef _DEBUG\n#define DEBUG WRITE\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\n#else\n#define DEBUG(...)\ninline void readfrom(...) { }\ninline void writeto(...) { }\n#endif\n#ifdef colored_cout\n#  define cout colored_cout\n#  define endl colored_endl\n#endif\n\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << \" \";\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1);\n\treturn out;\n}\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\n\n//// start up ////\nvoid solve();\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// geometry ////\n\n//// 2D geometry ////\n\n// ?????¢?????????????????????????????¢?????????????????????\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // ??????\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // ??????\n\tdouble sqlength() const { return x*x + y*y; } // ????????????\n\tdouble length() const { return sqrt(sqlength()); } // ??????\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // ??????????????????\n\tdouble arg() const { return atan2(y, x); }\n\tstatic P2 polar(double length, double theta) { return P2(std::polar(length, theta)); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << setprecision(16) << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); } // ??????\ninline P2 orthogonal(P2 p) { return p.orthogonal(); } // ?????´\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); } // ?????´\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// a,b ?????? ???????????? d ????????¢????????????a??¨b????????¨????????????????????????\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a ?????? a??¨b?????????\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // ??´???V?????§??????\n\tauto w = orthogonal(v) * (wl / vl); // ??´???V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a ?????? b ???????????£??????c????????????????????????\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// ??´???\nstruct Line\n{\n\tP2 p, d; // ?§?????????????\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// ??????\nstruct LineSeg\n{\n\tP2 p, d; // ?§???????????????§??????\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\n// ????????????a???????????????b???????°???±\ninline P2 projective(P2 a, P2 b)\n{\n\treturn b * (a.dot(b) / b.sqlength());\n}\n\n// ??????????¶?\ninline P2 perpendicular_foot(P2 a, Line b)\n{\n\tLine l = Line(b.p - a, b.d);\n\treturn a + l.p - projective(l.p, l.d);\n}\n\n// ??????a???b???????°???±\ninline LineSeg projective(LineSeg a, Line b)\n{\n\treturn LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d));\n}\n\n// ??????\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// ?????¬??????\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// ????????????\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// ???????????????\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn 0 + contains(a, b.p) + contains(a, b.p + b.d)\n\t\t+ contains(b, a.p) + contains(b, a.p + a.d) >= 2;\n}\n\n// ?????¢\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) {\n\tP2 h = perpendicular_foot(a, (Line) b);\n\treturn contains(b, h) ? getDistance(h, a)\n\t\t: min(getDistance(b.p, a), getDistance(b.p + b.d, a));\n}\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b)\n{\n\treturn isCross(a, b) ? 0 :\n\t\tmin(min(getDistance(a, b.p), getDistance(a, b.p + b.d)),\n\t\tmin(getDistance(a.p, b), getDistance(a.p + a.d, b)));\n}\n\n// a ?????? ta, b?????? tb ????????¢????????????ta=tb=r ?????? a??¨b????????\\?????????\ninline pair<pair<P2, P2>, pair<P2, P2>> get_distance_points(Line a, double ta, Line b, double tb)\n{\n\tassert(isCross(a, b));\n\n\tP2 va = a.d.orthogonal().direction() * ta;\n\tP2 vb = b.d.orthogonal().direction() * tb;\n\treturn make_pair(\n\t\tmake_pair(\n\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p + vb, b.d)),\n\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p - vb, b.d))\n\t\t), make_pair(\n\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p + vb, b.d)),\n\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p - vb, b.d))\n\t\t));\n}\n\n/// ???\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // ??\\??????????????????\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // ??\\??????????????????\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// ??´?????¨??????????????????????????\\??????????????¨????????????????????¨?????? contacting = false.\ninline bool isCross(const Line &l, const Circle &c, bool contacting = true)\n{\n\treturn c.r - getDistance(l, c.c) >(contacting ? -EPS : EPS);\n}\n\n// ??´?????¨????????????\ninline pair<P2, P2> crossPoint(const Line &l, const Circle &c)\n{\n\t// ??????????¶?\n\tP2 h = perpendicular_foot(c.c, l);\n\tdouble d = (h - c.c).length(); // ??????????¶??????§?????????\n\tdouble k = sqrt(c.r * c.r - d * d); // ??????????¶????????????????\n\tP2 dir = l.d.direction();\n\treturn pair<P2, P2>(h + dir * k, h - dir * k);\n}\n\n// 2??????????????????????????\\??????????????¨????????????????????¨?????? contacting = false.\ninline bool isCross(const Circle &A, const Circle &B, bool contacting = true)\n{\n\treturn (A.r + B.r) - (A.c - B.c).length() > (contacting ? -EPS : EPS);\n}\n\n// ??????????????????2????????????????±???????????§????????°??????????????????????(?????????????????£??????????¨???????)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // ???????????????????????????\n\tdouble d = v.length(); // ??????????????????????????¢\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // ??????????¶??????§????????¢\n\tP2 h = A.c + dir * lh; // ??????????¶?\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // ??????????¶??????????????????§????????¢\n\tP2 p = dir.orthogonal() * lp; // ??????????¶???????????????????????????????\n\treturn make_pair(h + p, h - p); // ???????????????\n}\n\n// 2????????\\???????±??????????\nvector<Line> getTangentialLine(Circle a, Circle b)\n{\n\tvector<Line> ret;\n\tP2 v = b.c - a.c;\n\tdouble d = v.length();\n\tdouble bt = v.arg();\n\n\tif (d - abs(a.r - b.r) > EPS) // ?????\\???2??¬\n\t{\n\t\tdouble dt = acos((a.r - b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c + P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c + P2::polar(b.r, t2)));\n\t}\n\telse if (d - abs(a.r - b.r) > -EPS) // ?????\\???1??¬ (?????\\)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\tif (d - (a.r + b.r) > EPS) // ?????\\???2??¬ (??¢????????????)\n\t{\n\t\tdouble dt = acos((a.r + b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c - P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c - P2::polar(b.r, t2)));\n\t}\n\telse if (d - (a.r + b.r) > -EPS) // ?????\\???1??¬ (??\\????????????)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\treturn ret;\n}\n\n\n/// ????????¢\nstruct Rect\n{\n\tP2 l, s;\n\tRect() : l(), s() { }\n\tRect(double x, double y, double w, double h) : l(x, y), s(w, h) { }\n\tRect(P2 location, P2 size) : l(location), s(size) { }\n\tbool Contains(const P2 &p) const { return p.x - l.x > -EPS && p.y - l.y > -EPS && p.x - (l.x + s.x) < EPS && p.y - (l.y + s.y) < EPS; } // ??\\??????????????????\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tcout << std::fixed << endl;\n\tREAD(Circle, c);\n\t\n\tREAD(int, q);\n\tREP(i, q)\n\t{\n\t\tREAD(double, x1, y1, x2, y2); \n\t\tP2 a, b;\n\t\ttie<P2>(a,b) = crossPoint(Line::From2Point(P2(x1, y1), P2(x2, y2)), c);\n\t\tif (a.x - b.x > EPS || a.x - b.x > -EPS && a.y - b.y > EPS) swap(a, b);\n\t\tWRITE(a, b);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\n/*????????????(??§?¨?)????????????*/\nclass Vector\n{\npublic:\n\tdouble x,y;\n\tVector(double x=0,double y=0):x(x),y(y){}\n\t\n\tVector operator + (Vector p){return Vector(x+p.x,y+p.y);}\n\tVector operator - (Vector p){return Vector(x-p.x,y-p.y);}\n\tVector operator * (double a){return Vector(x*a,y*a);}\n\tVector operator / (double a){return Vector(x/a,y/a);}\n\t\n\tdouble abs(){return sqrt(norm());}\n\tdouble norm(){return x*x+y*y;}\n\t\n\tbool operator <  (const Vector &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator == (const Vector &p)const{return fabs(x-p.x)<EPS && fabs(y-p.y<EPS);}\n};\n\n/*??´???????????????*/\nclass Line\n{\npublic:\n\tVector p,q;\n\tLine(Vector p=Vector(),Vector q=Vector()):p(p),q(q){}\n};\n\n/*???????????????*/\nclass Circle\n{\npublic:\n\tVector c;\n\tdouble r;\n\tCircle(Vector c=Vector(),double r=0.0):c(c),r(r){}\n};\n\n/*???????????????????¬????????????§??????*/\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-b.x*a.y;}\n\n/*??´??????????°???±*/\nVector project(Line l,Vector p)\n{\n\tVector base=l.q-l.p;\n\tdouble r=dot(p-l.p,base)/base.norm();\n\treturn l.p+base*r;\n}\n\n/*????????¨??????????????¢????????????*/\nint ccw(Vector p0,Vector p1,Vector p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;//???????¨???????\n\tif(cross(a,b)<-EPS)return -1;//????¨???????\n\tif(dot(a,b)<-EPS)return 2;//p0?????????\n\tif(a.norm()<b.norm())return -2;//p1????\\\\\n\treturn 0;//?????????\n}\n\n/*?????????????????????*/\nbool intersect(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n\treturn (ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n}\n\n/*??´?????¨??´????????????*/\nVector LLcross(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n\tdouble d1=cross(p3-p2,p0-p2);\n\tdouble d2=cross(p3-p2,p1-p3);\n\treturn p0+(p1-p0)*(d1/(d1+d2));\n}\n\n/*?????¨??´????????????*/\npair<Vector,Vector> CLcross(Circle c,Line l)\n{\n\tVector pr=project(l,c.c);\n\tVector e=(l.q-l.p)/(l.q-l.p).abs();\n\tdouble base=sqrt(c.r*c.r-(pr-c.c).norm());\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\n/*?????¨????????????*/\npair<Vector,Vector> CCcross(Circle c,Circle d)\n{\n\t\n}\n//cout<<fixed<<setprecision(10);\n////////////////////////////////////////////////\nint main()\n{\n\tCircle c;\n\tcin>>c.c.x>>c.c.y>>c.r;\n\tint n;cin>>n;\n\tLine l;\n\tcout<<fixed<<setprecision(10);\n\tREP(i,n)\n\t{\n\t\tcin>>l.p.x>>l.p.y>>l.q.x>>l.q.y;\n\t\tVector a=CLcross(c,l).first;\n\t\tVector b=CLcross(c,l).second;\n\t\tif(a<b)cout<<a.x<<\" \"<<a.y<<\" \"<<b.x<<\" \"<<b.y<<endl;\n\t\telse cout<<b.x<<\" \"<<b.y<<\" \"<<a.x<<\" \"<<a.y<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef Line Segment;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Line a, Point p){\n    Point a1 = a.first, a2 = a.second;\n    return abs(CCW(a1, a2, p)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Line a, Line b) {\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    return !IsecLP(Line(a2-a1, b2-b1), 0) || IsecLP(Line(a1, b1), b2);\n}\n\n// 直線と線分\nbool IsecLS(Line a, Segment b) {\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Segment a, Segment b) {\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Segment a, Point p) {\n    Point a1 = a.first, a2 = a.second;\n    return !CCW(a1, a2, p);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Line a, Point p){\n    Point a1 = a.first, a2 = a.second;\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Line a, Point p){\n    return 2.0L*Proj(a, p) - p;\n}\n\n// 点と点\nLD DistPP(Point p1, Point p2){\n    return abs(p1-p2);\n}\n\n// 直線と点\nLD DistLP(Line a, Point p){\n    return abs(Proj(a, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Line a, Line b) {\n    Point b1 = b.first;\n    return IsecLL(a, b) ? 0 : DistLP(a, b1);\n}\n\n// 直線と線分\nLD DistLS(Line a, Segment b) {\n    Point b1 = b.first, b2 = b.second;\n    return IsecLS(a, b) ? 0 : min(DistLP(a, b1), DistLP(a, b2));\n}\n\n// 線分と点\nLD DistSP(Segment a, Point p) {\n    Point a1 = a.first, a2 = a.second;\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Segment a, Segment b) {\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    if(IsecSS(a, b)) return 0;\n    return min(min(DistSP(a, b1), DistSP(a, b2)), min(DistSP(b, a1), DistSP(b, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Line a, Line b){\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(cpol[i]) > imag(cpol[is])) is = i;\n        if (imag(cpol[i]) < imag(cpol[js])) js = i;\n    }\n    LD maxd = norm(cpol[is]-cpol[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if(norm(cpol[i]-cpol[j]) > maxd) {\n            maxd = norm(cpol[i]-cpol[j]);\n            maxi = i; maxj = j;\n        }\n    } while(i != is || j != js);\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n\n// 凸多角形の切断 (ConvexPolygonCut) **********\nPolygon ConvexPolygonCut(Polygon cpol, Line l){\n    int n = cpol.size();\n    Point l1 = l.first, l2 = l.second;\n    Polygon q;\n    for(int i = 0; i < n; i++){\n        Point a = cpol[i], b = cpol[(i+1)%n];\n        if(CCW(l1, l2, a) != -1) q.push_back(a);\n        if(CCW(l1, l2, a) * CCW(l1, l2, b) < 0) q.push_back(CrossPointLL(Line(a, b), l));\n    }\n    return q;\n}\n// ********************************************\n\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n// 最近点対 (ClosestPair) *********************\npair<Point, Point> ClosestPair(Polygon p){\n    int n = p.size();\n    sort(p.begin(), p.end(), [](Point p, Point q) { return p.Y < q.Y; });\n    \n    auto u = p[0], v = p[1];\n    auto best = Dot(u-v, u-v);\n    auto update = [&](Point p, Point q) {\n        auto dist = Dot(p-q, p-q);\n        if (best > dist) { best = dist; u = p; v = q; }\n    };\n    set<Point> S; S.insert(u); S.insert(v);\n    for (int l = 0, r = 2; r < n; ++r) {\n        if (S.count(p[r])) return {p[r], p[r]};\n        if ((p[l].Y-p[r].Y)*(p[l].Y-p[r].Y) > best) S.erase(p[l++]);\n        auto i = S.insert(p[r]).first;\n        for (auto j = i; ; ++j) {\n            if (j == S.end() || (i->X-j->X)*(i->X-j->X) > best) break;\n            if (i != j) update(*i, *j);\n        }\n        for (auto j = i; ; --j) {\n            if (i != j) update(*i, *j);\n            if (j == S.begin() || (i->X-j->X)*(i->X-j->X) > best) break;\n        }\n    }\n    return make_pair(u, v);\n}\n// ********************************************\n\n\n//*********************************************\n//                円(Circle)                  *\n//*********************************************\ntypedef pair<Point, LD> Circle;\n\n// 円と円の交差判定 ***************************\nint IsecCC(Circle c1, Circle c2){\n    // 0: 包含, 1: 内接, 2: 2点で交わる, 3: 外接, 4: 離れている\n    enum{INCLUSION, INSCRIBED, INTERSECT, CIRCUMSCRIBED, LEAVE};\n    LD d = DistPP(c1.first, c2.first);\n    if(d > c1.second + c2.second) return LEAVE;\n    else if(EQ(d, c1.second + c2.second)) return CIRCUMSCRIBED;\n    else if(abs(c1.second - c2.second) < d && d < c1.second + c2.second) return INTERSECT;\n    else if(EQ(d, abs(c1.second - c2.second))) return INSCRIBED;\n    else return INCLUSION;\n}\n// ********************************************\n\n// 円と直線の交点 *****************************\npair<Point, Point> CrossPointCL(Circle c, Line l){\n    Point l1 = l.first, l2 = l.second, cp = c.first;\n    LD r = c.second;\n    Point ft = Proj(l, cp);\n    if(!GE(r * r, norm(ft-cp))) throw \"not exist crosspoint\";\n\n    Point dir = sqrt(max(r*r - norm(ft-cp), 0.0L)) / abs(l2-l1) * (l2-l1);\n    \n    if(!EQ(r*r, norm(ft-cp))) return make_pair(ft - dir, ft + dir);\n    else return make_pair(ft + dir, ft + dir);\n}\n\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nCircle c;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    LD xp, yp, r;\n    cin >> xp >> yp >> r;\n    c = Circle(Point(xp, yp), r);\n    cin >> q;\n    REP(i, q){\n        LD x1p, y1p, x2p, y2p;\n        cin >> x1p >> y1p >> x2p >> y2p;\n        pair<Point, Point> ans = CrossPointCL(c, Line(Point(x1p, y1p), Point(x2p, y2p)));\n        if(ans.first.X > ans.second.X) swap(ans.first, ans.second);\n        else if(ans.first.X == ans.second.X && ans.first.Y > ans.second.Y) swap(ans.first, ans.second);\n        printf(\"%.9Lf %.9Lf %.9Lf %.9Lf\\n\", ans.first.X, ans.first.Y, ans.second.X, ans.second.Y);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Vector {\npublic:\n  double x, y;\n  Vector() {}\n  Vector(double x, double y) : x(x), y(y) {}\n\n  Vector operator+(Vector v) { return Vector(x + v.x, y + v.y); }\n  Vector operator-(Vector v) { return Vector(x - v.x, y - v.y); }\n  Vector operator*(double s) { return Vector(s * x, s * y); }\n  Vector operator/(double s) { return Vector(s / x, s / y); }\n  bool operator==(Vector v) { return equals(x - v.x, 0) && equals(y - v.y, 0); }\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\n\n// inner product\ndouble dot(Vector v1, Vector v2) { return v1.x * v2.x + v1.y * v2.y; }\n\n// cross product\ndouble cross(Vector v1, Vector v2) { return v1.x * v2.y - v1.y * v2.x; }\n\nclass Line {\npublic:\n  Vector v1, v2;\n  Line() {}\n  Line(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n  // Vector unit() { return (v2 - v1) / (v2 - v1).abs(); }\n};\nclass Segment {\npublic:\n  Vector v1, v2;\n  Segment() {}\n  Segment(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n  operator Line() const { return Line(v1, v2); }\n};\n\nclass Circle {\npublic:\n  Vector v;\n  double r;\n  Circle() {}\n  Circle(Vector v, double r) : v(v), r(r) {}\n  Circle(double cx, double cy, double cr) {\n    v = Vector(cx, cy);\n    r = cr;\n  }\n};\n\nbool is_parrallel(Vector a, Vector b) { return equals(cross(a, b), 0); }\nbool is_parrallel(Line a, Line b) {\n  return is_parrallel(a.v1 - a.v2, b.v1 - b.v2);\n}\nbool is_parrallel(Segment a, Segment b) {\n  return is_parrallel((Line)a, (Line)b);\n}\n\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0); }\nbool is_orthogonal(Line a, Line b) {\n  return is_orthogonal(a.v1 - a.v2, b.v1 - b.v2);\n}\n\nVector project(Line l, Vector v) {\n  Vector a = v - l.v1;\n  Vector b = l.v2 - l.v1;\n  return l.v1 + b * (dot(a, b) / b.norm());\n}\n\nVector reflect(Line l, Vector v) { return v + (project(l, v) - v) * 2.0; }\n\ndouble distance(Line l, Vector v) { return (v - project(l, v)).abs(); }\ndouble distance(Vector v1, Vector v2) { return (v1 - v2).abs(); }\nbool in_segment(Segment s, Vector v) {\n  return dot(s.v2 - s.v1, v - s.v1) > 0 && dot(s.v1 - s.v2, v - s.v2) > 0;\n}\ndouble distance(Segment s, Vector v) {\n  auto m = project((Line)s, v);\n  if (in_segment(s, m)) {\n    return distance(m, v);\n  } else\n    return min(distance(s.v1, v), distance(s.v2, v));\n}\nbool opposite(Line l, Vector v1, Vector v2) {\n  auto a = l.v2 - l.v1;\n  auto b = v1 - l.v1;\n  auto c = v2 - l.v1;\n  return cross(a, b) * cross(a, c) < 0;\n}\nenum Direction {\n  ONLINE_FRONT = -2,\n  CLOCKWISE = -1,\n  ON_SEGMENT = 0,\n  COUNTER_CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n};\nDirection ccw(Vector v0, Vector v1, Vector v2) {\n  auto a = v1 - v0;\n  auto b = v2 - v0;\n  if (cross(a, b) > 0)\n    return COUNTER_CLOCKWISE;\n  if (cross(a, b) < 0)\n    return CLOCKWISE;\n  if (dot(a, b) < 0)\n    return ONLINE_BACK;\n  if (a.norm() < b.norm())\n    return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nvoid printd(Direction d) {\n  switch (d) {\n  case COUNTER_CLOCKWISE:\n    printf(\"COUNTER_CLOCKWISE\\n\");\n    break;\n  case CLOCKWISE:\n    printf(\"CLOCKWISE\\n\");\n    break;\n  case ONLINE_BACK:\n    printf(\"ONLINE_BACK\\n\");\n    break;\n  case ONLINE_FRONT:\n    printf(\"ONLINE_FRONT\\n\");\n    break;\n  case ON_SEGMENT:\n    printf(\"ON_SEGMENT\\n\");\n    break;\n  }\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return ccw(s1.v1, s1.v2, s2.v1) * ccw(s1.v1, s1.v2, s2.v2) <= 0 &&\n         ccw(s2.v1, s2.v2, s1.v1) * ccw(s2.v1, s2.v2, s1.v2) <= 0;\n}\n\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) {\n    return 0;\n  }\n  return min({distance(s1, s2.v1), distance(s1, s2.v2), distance(s2, s1.v1),\n              distance(s2, s1.v2)});\n}\nVector cross_point(Segment s1, Segment s2) {\n  auto a = s1.v2 - s1.v1;\n  auto d1 = abs(cross(a, s2.v1 - s1.v1));\n  auto d2 = abs(cross(a, s2.v2 - s1.v1));\n  auto r = d1 / (d1 + d2);\n  return s2.v1 + (s2.v2 - s2.v1) * r;\n}\n\npair<Vector, Vector> cross_circle_line(Circle c, Line l) {\n  auto h = project(l, c.v);\n  auto a = (h == c.v) ? c.r : sqrt(c.r * c.r - (h - c.v).norm());\n  auto lv = l.v2 - l.v1;\n  auto b = lv * (a / lv.abs());\n  return make_pair(h + b, h - b);\n}\n\nvoid sort_ans(Vector &a, Vector &b) {\n  if (equals(a.x - b.x, 0)) {\n    if (b.y < a.y)\n      swap(a, b);\n  } else {\n    if (b.x < a.x)\n      swap(a, b);\n  }\n}\n\nint main() {\n  int cx, cy, r;\n  cin >> cx >> cy >> r;\n  auto circle = Circle(cx, cy, r);\n\n  int nq;\n  cin >> nq;\n  for (int i = 0; i < nq; i++) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n    auto line = Line(Vector(x0, y0), Vector(x1, y1));\n    auto v = cross_circle_line(circle, line);\n    sort_ans(v.first, v.second);\n    printf(\"%.8f %.8f %.8f %.8f\\n\", v.first.x, v.first.y, v.second.x,\n           v.second.y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <array>\n#include <algorithm>\n#include <cassert>\n\nusing Number = double;\n\nconst Number EPS = 1e-10;\nconst Number INF = 1e10;\nconst Number PI = acos(-1.0);\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\n// change between degree and radian\ninline Number to_radian(const Number degree) { return degree * PI / 180.0; }\ninline Number to_degree(const Number radian) { return radian * 180.0 / PI; }\n\n\n/**\n * Point in two dimensional\n */\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    // Arithmetic operator between points\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(const Point &rhs) const { // cross product between points\n        return Point(this->x * rhs.x - this->y * rhs.y,\n                     this->x * rhs.x + this->y * rhs.x);\n    }\n\n    // Unary operator and compound assignment operator\n    Point operator-() const {\n        return Point(-this->x, -this->y);\n    }\n    Point& operator+=(const Point &rhs) {\n        return *this = *this + rhs;\n    }\n    Point& operator-=(const Point &rhs) {\n        return *this = *this - rhs;\n    }\n\n    // Arithmetic operator between point and number\n    Point operator*(Number rhs) const {\n        return Point(this->x * rhs, this->y * rhs);\n    }\n    Point operator/(Number rhs) const {\n        return Point(this->x / rhs, this->y / rhs);\n    }\n\n    // Comparison operation\n    bool operator==(const Point &rhs) const {\n        return sign(this->x - rhs.x) == 0 && sign(this->y - rhs.y) == 0;\n    }\n    bool operator<(const Point &rhs) const {\n        return (this->x < rhs.x) || (this->x == rhs.x && this->y < rhs.y);\n    }\n\n    // Other operator\n    Number abs(void) const {\n        return sqrt(this->x * this->x + this->y * this->y);\n    }\n    Number abs2(void) const {\n        return this->x * this->x + this->y * this->y;\n    }\n    Number arg(void) const {\n        return atan2(this->y, this->x);\n    }\n    Number dot(const Point &rhs) {\n        return this->x * rhs.x + this->y * rhs.y;\n    }\n    Point rotate90(void) const {\n        return Point(-this->y, this->x);\n    }\n    Point rotate(double angle) const {\n        return Point(cos(angle) * this->x - sin(angle) * this->y,\n                     sin(angle) * this->x + cos(angle) * this->y);\n    }\n\n};\ninline Number dot(const Point &p1, const Point &p2) {\n    return p1.x * p2.x + p1.y * p2.y;\n}\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n// Output of a point\nstd::ostream& operator<<(std::ostream &os, const Point &p) {\n    return os <<  p.x << ' ' << p.y;\n}\n// Input of a point\nstd::istream& operator>>(std::istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\n\n// Counter-Clockwise predicate (a, b, c)\nenum CCW {\n    COUNTER_CLOCKWISE = 1,      // counter clockwise\n    CLOCKWISE         = -1,     // clockwise\n    ONLINE_FRONT      = 2,      // a--c--b on line\n    ONLINE_BACK       = -2,      // c--a--b on line\n    ON_SEGMENT        = 0,     // a--b--c on line\n};\nCCW ccw(const Point &a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (abs_cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (abs_cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0)       return ONLINE_BACK;\n    if (b.abs2() < c.abs2())   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n/**\n * Line in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0] >> l[1];\n}\ninline CCW ccw(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p);\n}\n\n\n/**\n * Segment in two dimensional\n */\nclass Segment : public Line {\npublic:\n    Segment() {}\n    Segment(const Point &p1, const Point &p2) : Line(p1, p2) {}\n};\n\n\n/**\n * Circle in two dimensional\n */\nclass Circle : public Point {\npublic:\n    Number r;\n    Circle() {}\n    Circle(const Point &p, Number r = 0.0) : Point(p), r(r) {}\n};\n// Input of a circle\nstd::istream& operator>>(std::istream &is, Circle &c) {\n    return is >> c.x >> c.y >> c.r;\n}\n\n\n\n/**\n * Intersection testing\n */\nPoint Projection(const Line &l, const Point &p) {\n    Point dir = l[1] - l[0];\n    Number t = dot(p - l[0], dir) / dir.abs2();\n    return l[0] + dir * t;\n}\ninline Point Reflection(const Line &l, const Point &p) {\n    return Projection(l, p) * 2.0 - p;\n}\n\ninline bool IsOrthogonal(const Line &l1, const Line &l2) {\n    return equal(dot(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\ninline bool IsIntersect(const Line &l, const Point &p) {\n    return abs(ccw(l[0], l[1], p)) != 1;\n}\ninline bool IsIntersect(const Segment &s, const Point &p) {\n    return ccw(s[0], s[1], p) == 0;\n}\ninline bool IsIntersect(const Line &l1, const Line l2) {\n    return !IsParallel(l1, l2) || IsParallel(l1, Line(l1[0], l2[0]));\n}\ninline bool IsIntersect(const Line &l, const Segment &s) {\n    return abs_cross(l[1] - l[0], s[0] - l[0]) *\n        abs_cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\ninline bool IsIntersect(const Segment &s1, const Segment &s2) {\n    return ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n        ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\ninline bool IsIntersect(const Circle &c, const Point &p) { // p is in interior or boundary\n    return (c - p).abs() <= c.r + EPS;\n}\ninline bool IsIntersect(const Circle &c, const Line &l) {\n    return IsIntersect(c, Projection(l, c));\n}\ninline bool IsIntersect(const Circle &c1, const Circle &c2) {\n    return (c1 - c2).abs() <= c1.r + c2.r && abs(c1.r - c2.r) <= (c1 - c2).abs();\n}\n\n\n/**\n * Distance and Intersection point\n */\ninline Number Distance(const Point &p1, const Point &p2) {\n    return (p1 - p2).abs();\n}\ninline Number Distance(const Line &l, const Point &p) {\n    return (p - Projection(l, p)).abs();\n}\ninline Number Distance(const Segment &s, const Point &p) {\n    if (sign(dot(s[1] - s[0], p - s[0])) == -1) return (p - s[0]).abs();\n    if (sign(dot(s[0] - s[1], p - s[1])) == -1) return (p - s[1]).abs();\n    return (p - Projection(s, p)).abs();\n}\ninline Number Distance(const Line &l1, const Line &l2) {\n    return IsIntersect(l1, l2) ? 0 : Distance(l1, l2[0]);\n}\ninline Number Distance(const Line &l, const Segment &s) {\n    if (IsIntersect(l, s)) return 0.0;\n    return std::min(Distance(l, s[0]), Distance(l, s[1]));\n}\ninline Number Distance(const Segment &s1, const Segment &s2) {\n    if (IsIntersect(s1, s2)) return 0.0;\n    return std::min({Distance(s1, s2[0]), Distance(s1, s2[1]),\n                Distance(s2, s1[0]), Distance(s2, s1[1])});\n}\n\nPoint CrossPoint(const Line &s1, const Line &s2) {\n    Point base = s2[1] - s2[0];\n    Number d1 = abs(abs_cross(base, s1[0] - s2[0]));\n    Number d2 = abs(abs_cross(base, s1[1] - s2[0]));\n    Number t = d1 / (d1 + d2);\n    return s1[0] + (s1[1] - s1[0]) * t;\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c1, const Circle &c2) {\n    Number d = Distance(c1, c2);\n    Number rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2.0 * d);\n    Number rs = sqrt(c1.r * c1.r - rc * rc);\n    Point diff = (c2 - c1) / d;\n    return std::make_pair(c1 + diff * Point(rc, rs), c1 + diff * Point(rc, -rs));\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c, const Line &l) {\n    assert(true);\n    Point mid = Projection(l, c);\n    Point e = (l[1] - l[0]) / (l[1] - l[0]).abs();\n    Number len = sqrt(c.r * c.r - (mid - c).abs2());\n    return std::make_pair(mid + e * len, mid - e * len);\n}\n\n\nint main()\n{\n    std::cout << std::fixed << std::setprecision(15);\n\n    Circle c;\n    Line l;\n    int q;\n\n    std::cin >> c >> q;\n\n    while (q--) {\n        std::cin >> l;\n        auto ans = CrossPoint(c, l);\n        if (ans.second < ans.first)\n            std::swap(ans.first, ans.second);\n        std::cout << ans.first << ' ' << ans.second << '\\n';\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // ????????\\???\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // ????????????????????????\nld dot(Point a, Point b) { return real(conj(a) * b); } // ??????\nld cross(Point a, Point b) { return imag(conj(a) * b); } // ??????\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t // ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n/* ???????????? */\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// ????????´????????????\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// ?????????????????????\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* ?????¢ */\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tCircle c; c.p = input_point(); cin >> c.r;\n\tint q; cin >> q;\n\tfor (int i = 0; i < q;i++) {\n\t\tcout << fixed << setprecision(10);\n\t\tLine l(input_point(), input_point());\n\t\tauto ps = is_sc(c, l);\n\t\tsort(ps.begin(), ps.end());\n\t\tfor (int i = 0; i < 2;i++) {\n\t\t\tcout << ps[i].imag() << \" \" << ps[i].real();\n\t\t\tif (i == 0) cout << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\ndouble xmax, xmin, ymax, ymin;\nstruct vec{\n  double x, y;\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n  //double ppdist(vec p){ return sqrt( (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y) ); }\n  //double ppdist2(vec p){ return (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y); }\n};\nstruct line{\n  vec a, b;\n  vec getvec(){ return b - a; }\n  double size(){ return getvec().norm(); }\n  vec proj(vec p){ return a + (b - a).sca((p - a).dot(b - a) / (b - a).norm2()); }\n  vec vref(vec p){ return proj(p).sca(2.0) - p; }\n  int ccw(vec p){\n    vec q = p - a, ba = b - a;\n    if(ba.cross(q) > 0)return 1; //ccw\n    if(ba.cross(q) < 0)return -1; //cw\n    if(ba.dot(q) < 0)return -2; //back\n    if(ba.dot(ba) < q.dot(q))return 2; //front\n    return 0; //on\n  }\n  bool paral(line l){ return abs(l.getvec().cross(getvec())) < eps; }\n  bool orth(line l){ return abs(l.getvec().dot(getvec())) < eps; }\n  bool intersec(line l){\n    bool res0 = (ccw(l.a) * ccw(l.b) == 4); //syukutai\n    bool res1 = (getvec().cross(l.a - a) * getvec().cross(l.b - a)) <= eps;\n    bool res2 = (l.getvec().cross(a - l.a) * l.getvec().cross(b - l.a)) <= eps;\n    return !res0 && res1 && res2;\n  }\n  vec crosspoint(line l){\n    return a + getvec().sca((l.a - a).cross(l.getvec()) / getvec().cross(l.getvec()));\n  }\n  double pldist(vec p){\n    double res = min((a - p).norm2(), (b - p).norm2());\n    vec h = proj(p);\n    if((a - h).dot(b - h) < 0)res = min(res, (h - p).norm2());\n    return sqrt(res);\n  }\n  double lldist(line l){\n    if(intersec(l))return 0.0;\n    return min(min(pldist(l.a), pldist(l.b)), min(l.pldist(a), l.pldist(b)));\n  }\n};\nstruct polygon{\n  vector<vec> p;  //ccw\n  double area(){\n    double res = 0.0;\n    for(int i = 0;i < p.size();++i)res += p[i].cross(p[(i + 1) % p.size()]);\n    return res / 2.0;\n  }\n  bool isconv(){\n    for(int i = 0;i < p.size();++i)\n    if((p[(i + 1) % p.size()] - p[i]).cross(p[(i + 2) % p.size()] - p[i]) < -eps)return false;\n    return true;\n  }\n  int isin(vec a){\n    line l = (line){a, a + (vec){xmax - xmin, 0.0}};\n    int cnt = 0, n = p.size();\n    for(int i = 0;i < n;++i){\n      line tmp = (line){p[i], p[(i + 1) % n]};\n      if(tmp.ccw(a) == 0)return 1; //on line\n      if(l.intersec(tmp)){\n        ++cnt;\n        if(l.ccw(p[i]) == 0 && l.ccw(p[(i + 1) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        if(l.paral(tmp)){\n          ++cnt;\n          if(l.ccw(p[(i + 2) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        }\n      }\n    }\n    return (cnt & 1) * 2;  //2:in 0:out\n  }\n};\n\nstruct circle{\n  vec o;\n  double r;\n  int intersec(circle c){\n    double d = (o - c.o).norm(), rp = r + c.r, rm = abs(r - c.r);\n    if(abs(rp - d) < eps)return 3;\n    if(rp < d + eps)return 4;\n    if(abs(rm - d) < eps)return 1;\n    if(rm < d + eps)return 2;\n    return 0;\n  }\n  pair<vec, vec> clcrosspoint(line l){\n    pair<vec, vec> res;\n    vec h = l.proj(o);\n    double dist = (l.a - h).norm(), diff = sqrt(r * r - (o - h).norm2());\n    res.first = l.a + l.getvec().sca((dist + diff) / l.size());\n    res.second = l.a + l.getvec().sca((dist - diff) / l.size());\n    if(res.first.x > res.second.x ||\n      (abs(res.first.x - res.second.x) < eps && res.first.y > res.second.y))\n        swap(res.first, res.second);\n    return res;\n  }\n};\n\nsigned main(void){\n  int i, j, k, q;\n  circle c;\n  cin >> c.o.x >> c.o.y >> c.r >> q;\n  for(;q--;){\n    line l;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n    pair<vec, vec> res = c.clcrosspoint(l);\n    printf(\"%.15lf %.15lf %.15lf %.15lf\\n\", res.X.x, res.X.y, res.Y.x, res.Y.y);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a) - (b)) < EPS)\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y =0.0):x(x),y(y){}\n\tPoint operator + (const Point& p){ return Point(x+p.x,y+p.y);\t}\n\tPoint operator - (const Point& p){ return Point(x-p.x,y-p.y); }\n\tPoint operator * (double k){ return Point(x*k,y*k);\t}\n\tPoint operator / (double k){ return Point(x/k,y/k); }\n\n\tdouble norm(){return x*x+y*y;}\n\tdouble abs(){return sqrt(norm());}\n\n\tbool operator < (const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\n\n\ndouble norm(Vector a){return a.x*a.x+a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\n//??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){}\n\tSegment(double a,double b,double c,double d):p1(Point(a,b)),p2(Point(c,d)){}\n};\n\ntypedef Segment Line;\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c),r(r){}\n\tCircle(double x,double y, double r = 0.0): c(Point(x,y)),r(r){}\n};\ntypedef vector<Point> Polygon;\n\nbool isOrthgonal(Vector a, Vector b){\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isOrthgonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthgonal(a1-a2,b1-b2);\n}\n\nbool isOrthgonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p-s.p1,base)/base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s,p) - p) * 2.0;\n}\n\n\n\n//????¨???¨????????§??????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Vector a, Vector b){\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\tVector a = p2 - p1;\n\tVector b = p3 - p1;\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n//??????????????????\nbool intersect(Point p1, Point p2, Point p3,Point p4){\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect(Segment s1,Segment s2){\n\treturn intersect(s1.p1,s1.p2, s2.p1,s2.p2);\n}\n\n//??????\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base,s1.p1 - s2.p1));//?´??????§?¶????\n\tdouble d2 = abs(cross(base,s1.p2 - s2.p1));\n\tdouble t = d1 / (d1+d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//{???,??´???,??????}^2????????¢\ndouble getDistance(Point a,Point b){\n\treturn abs(a-b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p-l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(s.p2 - s.p1, p-s.p1) < 0.0) return abs(p-s.p1);\n\tif(dot(s.p1 - s.p2, p-s.p2) < 0.0) return abs(p-s.p2);\n\treturn getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n\tif(intersect(s1,s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\t\t\t min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n\npair<Point, Point> getCrossPoint(Circle c, Line l){\n\t//assert(intersect(c,l));\n\tVector pr = project(l,c.c);\n\tVector e = (l.p2 - l.p1)/abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint cx,cy,r,q;\n\tcin>>cx>>cy>>r>>q;\n\twhile(q--){\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tpair<Point,Point> ans = getCrossPoint(Circle(cx,cy,r), Line(a,b,c,d));\n\t\tif(ans.first.x > ans.second.x)swap(ans.first,ans.second);\n\t\telse if(fabs(ans.first.x -ans.second.x) < EPS && ans.first.y > ans.second.y)swap(ans.first,ans.second);\n\t\tcout << fixed <<  setprecision(8) << ans.first.x << ' ' << ans.first.y << ' ' << ans.second.x << ' ' << ans.second.y << endl;\n\t}\n\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Cross Point of a Circle and a Line\n#include <iostream>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\n\nstatic const double ESP = 1e-10;\n\nbool equals(double a, double b) { return fabs(a - b) < ESP; }\n\nclass Point {\npublic:\n    double x, y;\n\n    explicit Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(a / x, a / y); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < ESP && fabs(y - p.y) < ESP;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    explicit Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector v1, Vector v2) {\n    return equals(cross(v1, v2), 0.0);\n}\n\nbool isOrthogonal(Vector v1, Vector v2) {\n    return equals(dot(v1, v2), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    return s.p1 + (base * (dot(base, p - s.p1) / base.norm()));\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2;\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > ESP) return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -ESP) return CLOCKWISE;\n    else if (dot(a, b) < -ESP) return ONLINE_BACK;\n    else if (a.norm() < b.norm()) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) {\n        return getDistancePP(s.p1, p);\n    } else if(dot(s.p1 - s.p2, p - s.p2) < 0) {\n        return getDistancePP(s.p2, p);\n    } else {\n        return getDistanceLP(s, p);\n    }\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if(intersect(s1, s2)) return 0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s1.p2 - s1.p1;\n    double d1 = fabs(cross(base, s2.p1 - s1.p1));\n    double d2 = fabs(cross(base, s2.p2 - s1.p1));\n    return s2.p1 + (s2.p2 - s2.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l) {\n    Vector base = l.p2 - l.p1;\n    double d = getDistanceLP(l, c.c);\n    Point m = project(l, c.c);\n    double t = sqrt(pow(c.r, 2.0) - pow(d, 2.0)) / base.abs();\n    return make_pair(m - base * t, m + base * t);\n}\n\nint main() {\n    int q;\n    double cx, cy, r, x0, y0, x1, y1;\n    cin >> cx >> cy >> r >> q;\n    Circle c = Circle(Point(cx, cy), r);\n    for(int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1;\n        Line l = Line(Point(x0, y0), Point(x1, y1));\n        pair<Point, Point> p = getCrossPoint(c, l);\n        if(p.first.x < p.second.x) {\n            cout << p.first.x << \" \" << p.first.y << \" \" << p.second.x << \" \" << p.second.y << endl;\n        } else {\n            cout << p.second.x << \" \" << p.second.y << \" \" << p.first.x << \" \" << p.first.y << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<complex>\n\ntypedef complex<double> point;\n\nint main()\n{\n    point z, a, b, h;\n\tdouble cx, cy, r;\n\tint q;\n\tscanf(\"%lf %lf %lf\", &cx, &cy, &r);\n\tz.real(cx), z.imag(cy);\n\n\tdouble ax, ay, bx, by, hx, hy, scale;\n\tdouble coord[4];\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++){\n\t\tscanf(\"%lf %lf %lf %lf\", &ax, &ay, &bx, &by);\n\t\ta.real(ax), a.imag(ay), b.real(bx), b.imag(by);\n\t\th = a + (b - a) * (((z - a) / (b - a)).real());\n\t\tif(h != z){\n\t\t\tscale = sqrt((r * r) / norm(h - z) - 1);\n\t\t\thx = h.real(), hy = h.imag();\n\t\t\tcoord[0] = hx - (hy - cy) * scale;\n\t\t\tcoord[1] = hy + (hx - cx) * scale;\n\t\t\tcoord[2] = hx + (hy - cy) * scale;\n\t\t\tcoord[3] = hy - (hx - cx) * scale;\n\t\t}else{\n\t\t\tscale = r / sqrt(norm(a - b));\n\t\t\tcoord[0] = cx + (ax - bx) * scale;\n\t\t\tcoord[1] = cy + (ay - by) * scale;\n\t\t\tcoord[2] = cx - (ax - bx) * scale;\n\t\t\tcoord[3] = cy - (ay - by) * scale;\n\t\t}\n\t\tif(coord[0] > coord[2]){ swap(coord[0], coord[2]), swap(coord[1], coord[3]); }\n\t\tif(coord[0] == coord[2] && coord[1] > coord[3]){ swap(coord[1], coord[3]); }\n\t\tprintf(\"%.12f %.12f %.12f %.12f\\n\", coord[0], coord[1], coord[2], coord[3]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); i++)\n#define pb push_back\n#define all(X) X.begin(), X.end()\n\n#define X real()\n#define Y imag()\n#define x(p) real(p)\n#define y(p) imag(p)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1)%P.size()]\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n\t\t\tcross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n// enum { OUT, ON, IN };\n// int contains(const G& pol, const P& p){\n// \tif(pol.size() < 2) return OUT;\n// \tif(intersectSP({pol[0], pol[1]}, p)) return ON;\n// \tbool f = cross(pol[1]-pol[0], p - pol[0]) > 0;\n// \tfor(int i = 1; i < pol.size(); i++) {\n// \t\tauto& now = curr(pol, i);\n// \t\tauto& nxt = next(pol, i);\n// \t\tif(intersectSP({nxt, now}, p)) return ON;\n// \t\tif(f^(cross(nxt-now, p-now)>0)) return OUT;\n// \t}\n// \treturn IN;\n// }\n//??????????§???¢?????????????????????(polygon??????????¨???????)\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\nbool contains(const polygon& a, const polygon& b) {\n\trep(i, a.size()) if(contains(b, a[i]) == OUT) return false;\n\treturn true;\n}\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT, HIT, A_IN_B, B_IN_A};\nint isHit(const polygon& a, const polygon& b){\n\tif(contains(a, b)) return A_IN_B;\n\tif(contains(b, a)) return B_IN_A;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n\n//point???theta???????????¢\npoint spinP(const point& p, double theta, double ext = 1.0) {\n\treturn p*P(cos(theta),sin(theta))*ext;\n}\n\npoint makeP(double r, double arg) {return P(r*cos(arg), r*sin(arg));}\n\n//?????¨????????????????±???????\nvector<P> crossPoint(const C& a, const C& b){\n\tdouble d = abs(b.p-a.p);\n\tdouble arg = atan2(y(b.p-a.p), x(b.p-a.p));\n\tdouble arg2 = acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r));\n\tif(abs(arg2)<EPS) return {a.r*makeP(1.0, arg)+a.p};\n\tif(abs(a.r-b.r)<d && d < a.r+b.r) return {a.r*makeP(1.0, arg+arg2)+a.p, a.r*makeP(1.0, arg-arg2)+a.p};\n\treturn {};\n}\n\n//????????±?????\\???\nvector<L> comonTang(C c1, C c2) {\n\tvector<L> ret;\n\tif(c1.r > c2.r) swap(c1, c2);\n\tP sub = c1.p;\n\tc1.p -= sub;\n\tc2.p -= sub;\n\tdouble theta = atan2(c2.p.Y, c2.p.X);\n\n\tc2.p = spinP(c2.p, -theta);\n\tint signX = 0;\n\tif(c2.p.X > 0) signX = 1;\n\tif(c2.p.X < 0) signX = -1;\n\n\tdouble x = abs(c2.p.X), r1 = c1.r, r2 = c2.r;\n\tif(abs(x*x -(r2 - r1) * (r2 - r1))<EPS) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t}\n\telse if(x*x > (r2 - r1) * (r2 - r1)) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t\tret.pb({spinP({0, -r1}, -theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), -r1}, -theta2)});\n\t}\n\tif(abs(r1+r2-x)<EPS) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t}\n\telse if(x > r1+r2) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t\tret.pb({spinP({0, -r1}, -theta3), spinP({len, -r1}, theta3)});\n\t}\n\n\tfor(auto& l : ret) {\n\t\tif(signX == -1) l[1] = {-l[1].X, l[1].Y};\n\t\tl[0] = spinP(l[0], theta);\n\t\tl[1] = spinP(l[1], theta);\n\t\tl[0] += sub;\n\t\tl[1] += sub;\n\t}\n\treturn ret;\n}\n\ndouble getArea(const polygon& pol) {\n\tint n = pol.size();\n\tdouble s = 0.0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint now = i, nxt = (i + 1) % n;\n\t\ts += (pol[now].X - pol[nxt].X) * (pol[now].Y + pol[nxt].Y);\n\t}\n\treturn abs(s/2.0);\n}\n\n//?????? - convex hull\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n  \tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n  \t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  \tfor (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n  \t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  \tch.resize(k-1);\n  \treturn ch;\n}\n//???????¨??????????polygon????????????????????????\t\t\tCGL_3_B\nbool isHull(const G& g) {\n\tint n = g.size();\n\tif(n < 3) return false;\n\trep(i, n) if(ccw(prev(g, i), curr(g, i), next(g, i)) == -1) return false;\n\treturn true;\n}\nbool contains(const P& p, const C& c) {\n\treturn abs(p-c.p) < c.r+EPS;\n}\nint posRel(const L&s, const C&c){\n\tif(abs(distanceSP(s,c.p)-c.r)<EPS)\treturn 1;\t//??\\?????????\n\tif(distanceSP(s,c.p) > c.r+EPS) \treturn 0;\t//????????£????????????\n\tif(contains(s[0], c) && contains(s[1], c))\treturn 2;\t//????????????\n\tif(contains(s[0], c)||contains(s[1], c))\treturn 3;\t//?????´???????????????\n\treturn 4;\t//????????????\n}\nvector<P> crossPoint(C c, L l) {\n\tint hit = posRel(l, c);\n\tif(hit == 0) return {};\n\t\n\tdouble R = c.r;\n\tP sub = c.p;\n\tdouble theta;\n\n\tl[0] -= sub;\n\tl[1] -= sub;\n\n\ttheta = atan2(imag(l[1]-l[0]), real(l[1]-l[0]));\n\n\tl[0] = spinP(l[0], -theta);\n\tl[1] = spinP(l[1], -theta);\n\n\tassert(abs(imag(l[0]-l[1])) < EPS);\n\n\tvector<P> ret;\n\tif(abs(abs(l[0].Y) - R) < EPS) ret.pb({0.0, l[0].Y});\n\telse {\n\t\tdouble y = l[0].Y;\n\t\tdouble x = sqrt(R*R-y*y);\n\t\tret.pb({x, y});\n\t\tret.pb({-x, y});\n\t}\n\n\trep(i, ret.size()) {\n\t\tret[i] = spinP(ret[i], theta);\n\t\tret[i] += sub;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tdouble x, y, r;\n\tcin >> x >> y >> r;\n\tC c({x, y}, r);\n\tint q;\n\tcin >> q;\n\trep(i, q) {\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tL l({x1, y1}, {x2, y2});\n\t\tvector<P> a = crossPoint(c, l);\n\t\tif(a.size() == 1) a.pb(a[0]);\n\t\tsort(all(a));\n\t\tprintf(\"%.15lf %.15lf %.15lf %.15lf\\n\", a[0].X, a[0].Y, a[1].X, a[1].Y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <utility>\n#include <cassert>\n\nconst double EPS=1e-10;\n\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Vector a,Vector b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base) / norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p+(project(s,p)-p)*2.0;\n}\n\nenum CCW {\n    COUNTER_CLOCKWISE=1,\n    CLOCKWISE=-1,\n    ONLINE_BACK=2,\n    ONLINE_FRONT=-2,\n    ON_SEGMENT=0,\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return CCW::COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CCW::CLOCKWISE;\n    if(dot(a,b)<-EPS) return CCW::ONLINE_BACK;\n    if(norm(a)<norm(b)) return CCW::ONLINE_FRONT;\n\n    return CCW::ON_SEGMENT;\n}\n\ndouble getDistance(Point a,Point b) {\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2) {\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\nbool intersect(Circle c,Line l) {\n    double d=getDistanceLP(l,c.c);\n    return !(d>c.r);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2) {\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n\n    return make_pair(pr+e*base,pr-e*base);\n\n}\n\nint main() {\n    double cx,cy,r;\n    cin>>cx>>cy>>r;\n    Circle circle({Point(cx,cy),r});\n    int q; cin>>q;\n    while(q-->0) {\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        Line l=Line({Point(x1,y1),Point(x2,y2)});\n\n        auto ans=getCrossPoints(circle,l);\n        vector<pair<double,double>> vec;\n        vec.push_back(make_pair(ans.first.X,ans.first.Y));\n        vec.push_back(make_pair(ans.second.X,ans.second.Y));\n        sort(vec.begin(),vec.end());\n        printf(\"%.10f %.10f \",vec[0].first,vec[0].second);\n        printf(\"%.10f %.10f\\n\",vec[1].first,vec[1].second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k * x, k * y);\n\t}\n\tPoint operator / (double k) {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {};\n\n\tdouble norm() {\n\t\treturn (p2 - p1).x * (p2 - p1).x + (p2 - p1).y * (p2 - p1).y;\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tPoint project(Point p) { \n\t\tVector a = Vector(p.x - p1.x, p.y - p1.y);\n\t\tVector b = Vector(p2.x - p1.x, p2.y - p1.y);\n\t\treturn p1 + (p2 - p1) * (dot(a, b) / b.norm()); //???????????????\n\t}\n\n\tPoint refrect(Point p) {\n\t\tPoint pro = project(p);\n\t\treturn pro * 2 - p;\n\t}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tdouble cx, cy, r;\n\tCircle(double cx, double cy, double r): cx(cx), cy(cy), r(r) {}\n\t\n\tSegment crossPoints(Line l) {\n\t\tPoint c = Point(cx, cy);\n\t\tPoint p = l.project(c);\n\t\tdouble d2 = (p - c).norm();\n\t\tdouble t = sqrt(r * r - d2);\n\t\tPoint p1 = p - (l.p2 - l.p1) / l.abs() * t;\n\t\tPoint p2 = p + (l.p2 - l.p1) / l.abs() * t;\n\t\treturn Segment(p1, p2);\n\t}\n};\n\nint main() {\n\tint cx, cy, r, q;\n\tcin >> cx >> cy >> r >> q;\n\tCircle C = Circle(cx, cy, r);\n\tint x0, y0, x1, y1;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1;\n\t\tLine l = Segment(Point(x0, y0), Point(x1, y1));\n\t\tSegment s = C.crossPoints(l);\n\t\tcout << fixed << setprecision(6) << s.p1.x << ' ' << s.p1.y << ' ' << s.p2.x << ' ' << s.p2.y << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define eps (1e-10)\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point &p){return point(x+p.x,y+p.y);}\n    point operator - (point &p){return point(x-p.x,y-p.y);}\n    point operator * (double k){return point(x*k,y*k);}\n    point operator / (double k){return point(x/k,y/k);}\n\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n\n    bool operator < (const point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator == (const point &p){\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n//内积\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n//外积\ndouble cross(point a,point b){\n    return a.x*b.y-a.y*b.x;\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/base.norm();\n    base=base*r;\n    return a+base;\n}\n\npair<point,point>getcrosspoints(point xin,int r,point a,point b)\n{\n    point pr=project(a,b,xin);\n    point e=(b-a)/(b-a).abs();\n    double base=sqrt(r*r-(pr-xin).norm());\n    e=e*base;\n    return make_pair(pr+e,pr-e);\n}\n\nint main()\n{\n    point xin;\n    int r;\n    cin>>xin.x>>xin.y>>r;\n    int q;\n    cin>>q;\n    point a,b;\n    for(int i=0;i<q;i++){\n        cin>>a.x>>a.y>>b.x>>b.y;\n        pair<point,point>res=getcrosspoints(xin,r,a,b);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",res.second.x,res.second.y,res.first.x,res.first.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include <math.h>\n#include<algorithm>\n#include<functional>\n#define ll long long\n#define inf  999999999\n#define pa pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a) {return Point(x*a,y*a);}\n\tPoint operator / (double a) {return Point(x/a,y/a);}\n\tdouble absv() {return sqrt(norm());}\n\tdouble norm() {return x*x+y*y;}\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x<p.x: y<p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\ntypedef Point Vector;\n\nstruct Segment{\nPoint p1,p2;\n};\n\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\n//----------------kokomade temple------------\n\n\n\nint main(){\nint n;\ndouble r,c1,c2,a1,a2,a3,a4;\ncin>>c1>>c2>>r;\nPoint c,p1,p2,q,ans1,ans2;\nc.x=c1,c.y=c2;\ncin>>n;\nfor(int i=0;i<n;i++){\ncin>>a1>>a2>>a3>>a4;\np1.x=a1,p1.y=a2;\np2.x=a3,p2.y=a4;\nVector b=(p2-p1)/(p2-p1).absv();\nq=p1+b*dot(c-p1,b);\n//cout<<q.x<<\" \"<<q.y<<endl;\ndouble d=r*r-(c-q).norm();\nif(d<EPS) d=0.0;\nelse d=sqrt(d);\nans1=q+b*d;\nans2=q-b*d;\n\nif(ans1.x<ans2.x  ||(ans1.x==ans2.x && ans1.y<ans2.y )){\nprintf(\"%.10f %.10f %.10f %.10f\\n\",ans1.x,ans1.y,ans2.x,ans2.y);\n}\nelse printf(\"%.10f %.10f %.10f %.10f\\n\",ans2.x,ans2.y,ans1.x,ans1.y);\n\n}\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem\nusing namespace placeholders;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P = complex<R>;\nusing L = struct {P s, t;};\nusing VP = vector<P>;\nusing C = struct {P c; R r;};\n\n#define at(a,i) (a[(i + a.size()) % a.size()])\n\nauto& operator >> (istream& is, P& p) { R x, y; is >> x >> y, p = P(x, y); return is;}\nauto& operator << (ostream& os, P& p) { os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\t\n\tbool operator <  (const P& a, const P& b) { return sgn(real(a - b)) ? real(a - b) < 0 : sgn(imag(a - b)) < 0;}\n\tbool operator == (const P& a, const P& b) { return sgn(real(a - b)) == 0 && sgn(imag(a - b)) == 0;}\n}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline P vec(L l) {return l.t - l.s;}\nauto sdot = bind(sgn, bind(dot, _1, _2, _3));\nauto sdet = bind(sgn, bind(det, _1, _2, _3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l, P p) { R u = real((p - l.s) / vec(l)); return (1 - u) * l.s + u * l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a, L b) {return sdot(0, vec(a), vec(b)) == 0;}\nbool parallel(L a, L b) {return sdet(0, vec(a), vec(b)) == 0;}\nbool eql(L a, L b) { return parallel(a, b) and sdet(a.s, a.t, b.s) == 0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\n// crossing point\n// verified: AOJ CGL_2_C\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(0, vec(a), vec(b));\n\treturn (1 - u) * a.s + u * a.t;\n}\n\n// distance\n// verified: AOJ CGL_2_D\nR dsp(L l, P p) {\n\tP h = proj(l, p);\n\tif (sdot(l.s, l.t, p) <= 0) h = l.s;\n\tif (sdot(l.t, l.s, p) <= 0) h = l.t;\n\treturn abs(p - h);\n}\n\nR dss(L a, L b) {return iss(a, b) ? 0 : min({dsp(a, b.s), dsp(a, b.t), dsp(b, a.s), dsp(b, a.t)});}\n\n// Polygon\n\n// area\n// verified: AOJ 1100 CGL_3_A\nR area(const VP& pol) {\n\tR sum = 0.0;\n\trep(i, pol.size()) sum += det(0, at(pol, i), at(pol, i + 1));\n\treturn abs(sum / 2.0L);\n}\n\n// convex_polygon determination\n// verified: CGL_3_B\nbool is_convex(const VP& pol) {\n\trep(i, pol.size())if (sdet(at(pol, i), at(pol, i + 1), at(pol, i + 2)) < 0) return false;\n\treturn true;\n}\n\n// polygon realation determination  in  2 on 1 out 0???(possible non-convex)\n// verified: AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p) {\n\tint res = 0;\n\tauto simag = [](const P & p) {return sgn(imag(p));};\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tif (sdet(p, a, b) == 0 and sdot(p, a, b) <= 0) return 1;\n\t\tbool f = simag(p - a) >= 0, s = simag(p - b) < 0;\n\t\tif (simag(b - a)*sdet(a, b, p) == 1 and f == s) res += (2 * f - 1);\n\t}\n\treturn res ? 2 : 0;\n}\n\n// polygon realation determination???(possible non-convex)\n// verified: not AOJ 2514\nbool in_polygon(const VP& pol, const L& l) {\n\tVP check = {l.s, l.t};\n\trep(i, pol.size()) {\n\t\tL edge = {at(pol, i), at(pol, i + 1)};\n\t\tif (iss(l, edge)) check.emplace_back(cross(l, edge));\n\t}\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tsort(begin(check), end(check), cmp_x);\n\trep(i, check.size() - 1) {\n\t\tP m = (at(check, i) + at(check, i + 1)) / 2.0L;\n\t\tif (in_polygon(pol, m) == false) return false;\n\t}\n\treturn true;\n}\n\n// convex_cut\n// verified: AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tint da = sdet(l.s, l.t, a), db = sdet(l.s, l.t, b);\n\t\tif (da >= 0) res.emplace_back(a);\n\t\tif (da * db < 0) res.emplace_back(cross({a, b}, l));\n\t}\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol) {\n\tint n = pol.size(), i = 0, j = 0;\n\tif (n <= 2) return abs(pol[0] - pol[1]);\n\tR res = 0.0;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\trep(k, n) {\n\t\tif (!cmp_x(pol[i], pol[k]))i = k;\n\t\tif (cmp_x(pol[j], pol[k]))j = k;\n\t}\n\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) {\n\t\tres = max(res, abs(pol[i] - pol[j]));\n\t\tif (sdet(0, vec(L{at(pol, i), at(pol, i + 1)}), vec(L{at(pol, j), at(pol, j + 1)})) < 0)\n\t\t\ti = (i + 1) % n;\n\t\telse\n\t\t\tj = (j + 1) % n;\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR iscp(VP a, int flag = 1) {\n\tconst int n = a.size(), m = n / 2;\n\tif (n <= 1) return INF;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tif (flag) sort(begin(a), end(a), cmp_x);\n\n\tVP b(begin(a), begin(a) + m), c(begin(a) + m, end(a));\n\tR x = real(a[m]), d = min(iscp(b, 0), iscp(c, 0));\n\n\n\tauto cmp_y = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn si ? si < 0 : sr < 0;\n\t};\n\n\tsort(begin(a), end(a), cmp_y);\n\tdeque<P> e;\n\n\tfor (auto &p : a) {\n\t\tif (abs(real(p) - x) >= d) continue;\n\n\t\tfor (auto &q : e) {\n\t\t\tif (imag(p - q) >= d) break;\n\t\t\td = min(d, abs(p - q));\n\t\t}\n\t\te.push_front(p);\n\t}\n\treturn d;\n}\n\n// Circle // verified: AOJ 1183\nenum RCC {OUT = 2, ON_OUT = 1, ISC = 0, ON_IN = -1, IN = -2};\nint rcc(C a, C b) { R d = abs(a.c - b.c); return sgn(d - a.r - b.r) + sgn(d - abs(a.r - b.r));}\n\n// circle crossing determination\nbool icp(C c, P p, int end = 0) {return sgn(abs(p - c.c) - c.r) <= -end;}\nbool ics(C c, L s, int end = 0) {\n\tif (sgn(dsp(s, c.c) - c.r) > end) return false;\n\tif (icp(c, s.s, end) and icp(c, s.t, end)) return false;\n\treturn true;\n}\n// common area between circles\nR area(C a, C b) {\n\tint r = rcc(a, b);\n\tif (r >= ON_OUT) return 0.0L;\n\tif (r <= ON_IN) return min(norm(a.r), norm(b.r)) * PI;\n\tR d = abs(b.c - a.c), rc = (norm(d) + norm(a.r) - norm(b.r)) / (2.0 * d);\n\tR t = acos(rc / a.r), p = acos((d - rc) / b.r);\n\treturn norm(a.r) * t + norm(b.r) * p - d * a.r * sin(t);\n}\n\n// cross point between circle and line\n// verified: AOJ CGL_7_D\nP cir(C c, R t) {return c.c + polar(c.r, t);}\nVP cross(C c, L l) {\n\tP h = proj(l, c.c);\n\tP e = polar(sq(norm(c.r) - norm(h-c.c)), arg(vec(l)));\n\treturn VP{h - e, h + e};\n}\n\n// cross point between circles\n// verified: AOJ CGL_7_E\nVP cross(C a, C b) {\n\tP d = b.c - a.c;\n\tP w = (norm(d) + norm(a.r) - norm(b.r)) / (2.0L * norm(d)) * d; \n\treturn cross(a, {a.c + w, a.c + w + 1il * d});\n}\n\n// circle tangent\n// verified: AOJ CGL_7_F\nL tan(C c, P p) {return L{p, p + 1il * (p - c.c)};}\n\nP helper(C c, P d, R r, P j) {\n\tP tmp = sq(norm(d) - norm(r)) * j;\n\tP dir = (r + tmp) / norm(d) * d;\n\treturn c.c + c.r * dir;\n}\n\nVP contact(C c, P p) {\n\tVP ret;\n\tP d = p - c.c;\n\tfor (P j : { -1il, 1il}) ret.emplace_back(helper(c, d, c.r, j));\n\tsort(begin(ret), end(ret));\n\tret.erase(unique(begin(ret), end(ret)), end(ret));\n\treturn ret;\n}\n\n// circle tangent\n// Verified: AOJ CGL_7_G\nVP contact(C a, C b) {\n\tVP ret;\n\tP d = b.c - a.c;\n\tfor (int s : { -1, 1}) {\n\t\tif (rcc(a, b) >= s) {\n\t\t\tfor (P j : { -1i, 1i}) {\n\t\t\t\tR r = a.r + s * b.r;\n\t\t\t\tret.emplace_back(helper(a, d, r, j));\n\t\t\t}\n\t\t}\n\t}\n\tsort(begin(ret), end(ret));\n\tret.erase(unique(begin(ret), end(ret)), end(ret));\n\treturn ret;\n}\n\n// common area of circle and polygon\n// verified: AOJ CGL_7_H\nR area_helper(C c, P a, P b) {\n\tif (icp(c, a) and icp(c, b)) return det(0, a, b) / 2.0l;\n\treturn norm(c.r) * arg(conj(a)*b) / 2.0l;\n}\n\nR area(C c, P a, P b) {\n\tL l = {a, b};\n\n\tif (sgn(min({c.r, abs(a), abs(b), abs(b - a)})) == 0) return 0.0;\n\tif (ics(c, l)==false) return area_helper(c, a, b);\n\t\n\tR res = 0.0; VP ary;\n\tary.push_back(a);\n\tfor (auto &p : cross(c, l)) if(sdot(p, a, b) < 0) ary.push_back(p);\n\tary.push_back(b);\n\t\n\trep(i, ary.size()-1) res += area_helper(c, at(ary, i), at(ary, i + 1));\n\treturn res;\n}\n\nR area(C c, VP pol) {\n\tR res = 0;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i) - c.c , b = at(pol, i + 1) - c.c;\n\t\tres += area(C{0.0L, c.r}, a, b);\n\t}\n\treturn res;\n}\nint main(void){\n\tint q;\n\tC c;\n\tcin >> c.c >> c.r;\n\t\t\n\tcin >> q;\n\tcout.precision(20);\n\trep(i,q){\n\t\tP a,b;\n\t\tcin >> a >> b;\n\t\tL l={a,b};\n\t\tVP res=cross(c,l);\n\t\tif(sgn(real(res[0])-real(res[1])>0)) swap(res[0],res[1]);\n\t\tif(sgn(real(res[0])-real(res[1]))==0 and sgn(imag(res[0])-imag(res[1]))>0) swap(res[0],res[1]);\n\t\tcout << fixed << res[0] << \" \" << res[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\tdouble cx,cy,r,x1,x2,y1,y2,slope,cross_x,cross_y,k,div_x,div_y,ans1_x,ans1_y,ans2_x,ans2_y;\n\tint q;\n\tbool X_FLG,Y_FLG;\n\n\tscanf(\"%lf %lf %lf\",&cx,&cy,&r);\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf\",&x1,&y1,&x2,&y2);\n\n\t\tX_FLG = false,Y_FLG = false;\n\n\t\tif(y1 == y2){\n\t\t\tX_FLG = true;\n\t\t}else if(x1 == x2){\n\t\t\tY_FLG = true;\n\t\t}else{\n\t\t\tslope = (y2-y1)/(x2-x1);\n\t\t}\n\n\t\tif(X_FLG){\n\t\t\tcross_x = cx;\n\t\t\tcross_y = y1;\n\t\t}else if(Y_FLG){\n\t\t\tcross_x = x1;\n\t\t\tcross_y = cy;\n\t\t}else{\n\t\t\tcross_x = (cy*(x2-x1)*(y2-y1)+cx*(x2-x1)*(x2-x1)-y1*(y2-y1)*(x2-x1)+x1*(y2-y1)*(y2-y1))/((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1));\n\t\t\tcross_y = ((x1-x2)*cross_x+cy*(y2-y1)+cx*(x2-x1))/(y2-y1);\n\t\t}\n\n\t\tk = sqrt(r*r-((cx - cross_x)*(cx-cross_x)+(cy-cross_y)*(cy-cross_y)));\n\n\t\tif(X_FLG){\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",cross_x - k,y1,cross_x+k,y1);\n\t\t}else if(Y_FLG){\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",x1,cross_y-k,x1,cross_y+k);\n\t\t}else{\n\t\t\tdiv_x = k*(x2-x1)/(sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)));\n\t\t\tdiv_y = k*(y2-y1)/(sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)));\n\n\t\t\tans1_x = cross_x-div_x;\n\t\t\tans1_y = cross_y-div_y;\n\n\t\t\tans2_x = cross_x+div_x;\n\t\t\tans2_y = cross_y+div_y;\n\n\t\t\tif(ans1_x < ans2_x){\n\t\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",ans1_x,ans1_y,ans2_x,ans2_y);\n\t\t\t}else if(fabs(ans1_x-ans2_x) < 0.00000001 && ans1_y <= ans2_y){\n\t\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",ans1_x,ans1_y,ans2_x,ans2_y);\n\t\t\t}else{\n\t\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",ans2_x,ans2_y,ans1_x,ans1_y);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\ndouble getDistanceLP(Line, Point);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q, x[2], y[2];\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\t\tans.first.show();\n\t\tcout << \" \";\n\t\tans.second.show();\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (numeric_limits<double>::epsilon())\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(const Point &p) const\n    {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator-(const Point &p) const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n\n    Point operator*(const double &a) const\n    {\n        return Point(a * x, a * y);\n    }\n\n    Point operator/(const double &a) const\n    {\n        return Point(x / a, y / a);\n    }\n\n    double abs()\n    {\n        return sqrt(norm());\n    }\n\n    double norm()\n    {\n        return x * x + y * y;\n    }\n\n    bool operator<(const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const\n    {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n};\n\n\ndouble dot(Vector a, Vector b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b)\n{\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n    return equals(cross(a2 - a1, b2 - b1), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n    return equals(dot(a2 - a1, b2 - b1), 0.0);\n}\n\nPoint project(Segment s, Point p)\n{\n    Vector hypo = p - s.p1;\n    Vector base = s.p2 - s.p1;\n    return base * (dot(hypo, base) / base.norm()) + s.p1;\n}\n\nPoint reflect(Segment s, Point p)\n{\n    return (project(s, p) - p) * 2.0 + p;\n}\n\ndouble getDistance(Point a, Point b)\n{\n    return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n        return getDistance(p, s.p1);\n    else if (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n        return getDistance(p, s.p2);\n    else\n        return getDistanceLP(s, p);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > 0.0)\n        return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < 0.0)\n        return CLOCKWISE;\n    else if (dot(a, b) < 0.0)\n        return ONLINE_BACK;\n    else if (a.norm() < b.norm())\n        return ONLINE_FRONT;\n    else\n        return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3)\n{\n    return ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0\n           && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0;\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n    if (intersect(s1.p1, s1.p2, s2.p1, s2.p2))\n        return 0.0;\n    else\n        return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n                   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n    double d1 = getDistanceLP(s2, s1.p1);\n    double d2 = getDistanceLP(s2, s1.p2);\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point> CrossPoints(Circle c, Line l)\n{\n    Point foot = project(l, c.c);\n    double scale = sqrt(c.r * c.r - (foot - c.c).norm());\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    return make_pair(foot + e * scale, foot - e * scale);\n}\n\nint main()\n{\n    int cx, cy;\n    double r;\n    cin >> cx >> cy >> r;\n    Circle circle = {Point(cx, cy), r};\n    int query;\n    cin >> query;\n    Point p1, p2;\n    for (int q = 0; q < query; q++)\n    {\n        cin >> p1.x >> p1.y >> p2.x >> p2.y;\n        pair<Point, Point> points = CrossPoints(circle, Line{p1, p2});\n        Point first, second;\n        if (!equals(points.first.x, points.second.x))\n        {\n            if (points.first.x < points.second.x)\n            {\n                first = points.first;\n                second = points.second;\n            } else\n            {\n                first = points.second;\n                second = points.first;\n            }\n        } else\n        {\n            if (points.first.y < points.second.y)\n            {\n                first = points.first;\n                second = points.second;\n            } else\n            {\n                first = points.second;\n                second = points.first;\n            }\n        }\n        printf(\"%.10f %.10f %.10f %.10f\\n\", first.x, first.y, second.x, second.y);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double EPS_GIG = 1e-3;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS)   return +1;       // counter clockwise\n\tif (cross(b, c) + EPS < 0)   return -1;       // clockwise\n\tif (dot(b, c) - EPS < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\tauto a = s[0] - p;\n\tauto b = s[1] - p;\n\treturn (abs(cross(a, b)) < EPS && dot(a, b) <= EPS); // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点の交差hは考えない\nbool strictIntersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) == -1 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) == -1;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspointSS(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<point> crosspointCL(const circle &c, const segment &l) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto pro_p = projection(l, c.p);\n\tauto dist = distanceLP(l, c.p);\n\tif(abs(dist - c.r) < EPS){\n\t\tret[0] = pro_p;\n\t\treturn ret;\n\t}\n\tif(c.r < dist){\n\t\treturn ret;\n\t}\n\tpoint vec = (l[1] - l[0]) * sqrt(c.r * c.r - dist * dist) / abs(l[1] - l[0]);\n\tret[0] = pro_p + vec;\n\tret[1] = pro_p - vec;\n\treturn ret;\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nhalf-line crossing method\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) + EPS <= 0 && EPS < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a + b) * 0.5;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= EPS) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > 2 * PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointSS(segment(A, B), l));\n  }\n  return Q;\n}\n\n//扇型、中心と二つの端点\nstruct sector {\n\tpoint o;\n\tpoint a, b;\n\tdouble l;\n\tsector(){}\n\tsector(point O, point A, point B, double _l) :o(O), a(A), b(B), l(_l) {}\n};\n\ndouble L, sx, sy, gx, gy;\nint point_size = 0, n, r;\nvector<int> dist(10000);\nvector<int> goal_list;\nvector<segment> seg_list;\nvector<vector<P>> v(10000);\n// 各回転時点での点候補(点, id)\nvector<vector<pair<point, int>>> r_point_list(20);\n// 回転代表点でないものの点数\nvector<int> r_def_point_size(20);\n// 各回転時点での四角形\nvector<vector<vector<point>>> r_square_list(20);\n// 各回転時点での線分\nvector<vector<segment>> r_segment_list(20);\n// 各回転時点での扇\nvector<vector<sector>> r_sector_list(20);\n\nbool can_rotate(point p, int rad_num);\nbool check_visible(point p_a, point p_b, int rad_num);\n\nbool add_point_list(int rad_num, point p){\n\tREP(i, r_square_list[rad_num].size()){\n\t\tif(contains(r_square_list[rad_num][i], p) == 2)return false;\n\t}\n\tr_point_list[rad_num].EB(p, point_size);\n\tpoint_size++;\n\treturn true;\n}\n\nvoid make_r_segment_list_square_list(int rad_num) {\n\tdouble rad = (double)rad_num * PI / r;\n\tpoint vec = rotate(point(L, 0), rad);\n\n\tREP(i, n) {\n\t\tsegment now = seg_list[i];\n\t\tpoint A = now[0];\n\t\tpoint B = now[1];\n\t\tpoint now_v = B - A;\n\t\tvector<point> tmp;\n\t\tif (isParallel(now_v,vec)) {\n\t\t\tpoint rotated_vec = rotate(point(EPS_GIG,0),add_rad(rad,PI/2));\n\t\t\tpoint C, D;\n\t\t\tif(abs(A - (B + vec)) > abs(A - (B - vec)))C = B + vec;\n\t\t\telse C = B - vec;\n\t\t\tif(abs(B - (A + vec)) > abs(B - (A - vec)))D = A + vec;\n\t\t\telse D = A - vec;\n\n\t\t\ttmp.PB(C + rotated_vec);\n\t\t\ttmp.PB(C - rotated_vec);\n\t\t\ttmp.PB(D + rotated_vec);\n\t\t\ttmp.PB(D - rotated_vec);\n\t\t}\n\t\telse {\n\t\t\ttmp.PB(A + vec);\n\t\t\ttmp.PB(A - vec);\n\t\t\ttmp.PB(B + vec);\n\t\t\ttmp.PB(B - vec);\n\t\t}\n\t\ttmp = convex_hull(tmp);\n\t\tr_square_list[rad_num].EB(tmp);\n\t\tREP(j, 4) {\n\t\t\tr_segment_list[rad_num].EB(tmp[j], tmp[(j + 1) % 4]);\n\t\t}\n\t}\n}\n\nvoid make_r_sector_list(int rad_num){\n\tdouble rad = (double)rad_num * PI / r;\n\tdouble next_rad = (double)(rad_num + 1) * PI / r;\n\tpoint vec = rotate(point(L, 0), rad);\n\tpoint next_vec = rotate(point(L, 0), next_rad);\n\n\tREP(i, seg_list.size()){\n\t\tREP(j, 2){\n\t\t\tauto p = seg_list[i][j];\n\t\t\tr_sector_list[rad_num].EB(p, p + vec, p + next_vec, L);\n\t\t\tr_sector_list[rad_num].EB(p, p - vec, p - next_vec, L);\n\t\t}\n\t}\n}\n\nvoid make_r_point_list(int rad_num) {\n\tadd_point_list(rad_num, point(sx, sy));\n\tif(add_point_list(rad_num, point(gx, gy))){\n\t\tgoal_list.EB(point_size-1);\n\t}\n\n\tREP(i, r_segment_list[rad_num].size()){\n\t\tauto seg_a = r_segment_list[rad_num][i];\n\t\tREP(j, i){\n\t\t\tauto seg_b = r_segment_list[rad_num][j];\n\t\t\tif(!intersectSS(seg_a, seg_b))continue;\n\t\t\tauto p = crosspointSS(seg_a, seg_b);\n\t\t\tadd_point_list(rad_num, p);\n\t\t}\n\t}\n\tREP(i, r_square_list[rad_num].size()){\n\t\tREP(j, 4){\n\t\t\tadd_point_list(rad_num, r_square_list[rad_num][i][j]);\n\t\t}\n\t}\n\tr_def_point_size[rad_num] = r_point_list[rad_num].size();\n}\n\nvoid add_rotate_point(point p_a, int id_a, int rad_num){\n\tint next_rad = (rad_num + 1) % r;\n\tREP(i, r_def_point_size[rad_num]){\n\t\tauto p_b = r_point_list[rad_num][i].FI;\n\t\tauto id_b = r_point_list[rad_num][i].SE;\n\t\tif(check_visible(p_a, p_b, rad_num)){\n\t\t\tv[id_b].EB(id_a, 0);\n\t\t\tv[id_a].EB(id_b, 0);\n\t\t}\n\t}\n\tREP(i, r_def_point_size[next_rad]){\n\t\tauto p_b = r_point_list[next_rad][i].FI;\n\t\tauto id_b = r_point_list[next_rad][i].SE;\n\t\tif(check_visible(p_a, p_b, next_rad)){\n\t\t\tv[id_a].EB(id_b, 1);\n\t\t}\n\t}\n}\n\nvoid make_rotate_point(int rad_num) {\n\tint next_rad = (rad_num + 1) % r;\n\tint pre_rad = (rad_num + r - 1) % r;\n\tREP(i, r_def_point_size[rad_num]){\n\t\tauto p_a = r_point_list[rad_num][i].FI;\n\t\tauto id_a = r_point_list[rad_num][i].SE;\n\t\tif(can_rotate(p_a, rad_num)){\n\t\t\tREP(j, r_def_point_size[next_rad]){\n\t\t\t\tauto p_b = r_point_list[next_rad][j].FI;\n\t\t\t\tauto id_b = r_point_list[next_rad][j].SE;\n\t\t\t\tif(check_visible(p_a, p_b, next_rad)){\n\t\t\t\t\tv[id_a].EB(id_b, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(can_rotate(p_a, pre_rad)){\n\t\t\tREP(j, r_def_point_size[pre_rad]){\n\t\t\t\tauto p_b = r_point_list[pre_rad][j].FI;\n\t\t\t\tauto id_b = r_point_list[pre_rad][j].SE;\n\t\t\t\tif(check_visible(p_a, p_b, pre_rad)){\n\t\t\t\t\tv[id_b].EB(id_a, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, r_segment_list[rad_num].size()) {\n\t\tauto seg_a = r_segment_list[rad_num][i];\n\t\tREP(j, r_segment_list[next_rad].size()){\n\t\t\tauto seg_b = r_segment_list[next_rad][j];\n\t\t\tif(!intersectSS(seg_a, seg_b))continue;\n\t\t\tauto p_a = crosspointSS(seg_a, seg_b);\n\t\t\tif(!can_rotate(p_a, rad_num))continue;\n\t\t\tauto id_a = point_size;\n\t\t\tadd_point_list(rad_num, p_a);\n\t\t\tadd_rotate_point(p_a, id_a, rad_num);\n\t\t}\n\t}\n}\n\nbool check_visible(point p_a, point p_b, int rad_num) {\n\tsegment seg = segment(p_a, p_b);\n\tpoint mid = (p_a + p_b) * 0.5;\n\tREP(i, r_square_list[rad_num].size()){\n\t\tint cou = 0;\n\t\tbool flag = false;\n\t\tauto sq = r_square_list[rad_num][i];\n\t\tif(contains(sq, mid) == 2)return false;\n\t\tREP(j, 4){\n\t\t\tsegment tmp_seg = segment(sq[j], sq[(j+1)%4]);\n\t\t\tif(strictIntersectSS(seg, tmp_seg))return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid make_visible_graph(int rad_num) {\n\tREP(i, r_point_list[rad_num].size()){\n\t\tauto p_a = r_point_list[rad_num][i].FI;\n\t\tauto id_a = r_point_list[rad_num][i].SE;\n\t\tREP(j, i){\n\t\t\tauto p_b = r_point_list[rad_num][j].FI;\n\t\t\tauto id_b = r_point_list[rad_num][j].SE;\n\t\t\tif(check_visible(p_a, p_b, rad_num)){\n\t\t\t\tv[id_a].EB(id_b, 0);\n\t\t\t\tv[id_b].EB(id_a, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool contain_sector(sector &sec,point &p){\n\tpoint o = sec.o;\n\tpoint a = sec.a;\n\tpoint b = sec.b;\n\tif(abs(p - o) > L)return false;\n\tif(intersectSP(segment(o, a), p))return true;\n\tpoint vec = p - o;\n\tpoint vecA = a - o;\n\tpoint vecB = b - o;\n\tif(angle(vec,vecA) + EPS < angle(vecA,vecB) && angle(vec,vecB) + EPS < angle(vecA,vecB))return true;\n\treturn false;\n}\n\nbool can_rotate(point p, int rad_num) {\n\tint next_rad = (rad_num + 1) % r;\n\tREP(i, r_square_list[rad_num].size()){\n\t\tif(contains(r_square_list[rad_num][i], p) == 2)return false;\n\t}\n\tREP(i, r_square_list[next_rad].size()){\n\t\tif(contains(r_square_list[next_rad][i], p) == 2)return false;\n\t}\n\tREP(i, r_sector_list[rad_num].size()){\n\t\tif(contain_sector(r_sector_list[rad_num][i], p))return false;\n\t}\n\treturn true;\n}\n\nint Dijkstra() {\n\tpriority_queue<P, vector<P>, greater<>> pq;\n\tpq.push(MP(0, 0));\n\n\twhile(!pq.empty()){\n\t\tint d = pq.top().FI;\n\t\tint id = pq.top().SE;\n\t\tpq.pop();\n\t\tREP(i, v[id].size()){\n\t\t\tint aite = v[id][i].FI;\n\t\t\tint cost = v[id][i].SE;\n\t\t\tif(dist[aite] > d + cost){\n\t\t\t\tdist[aite] = d + cost;\n\t\t\t\tpq.push(MP(dist[aite], aite));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = INF;\n\tREP(i, goal_list.size()){\n\t\tret = min(ret, dist[goal_list[i]]);\n\t}\n\treturn ret;\n}\n\nvoid output_visible_graph() {\n\tcout << r << endl;\n\tREP(rad_num, r){\n\t\tint m = r_point_list[rad_num].size();\n\t\tcout << m << endl;\n\t\tREP(i, m){\n\t\t\tauto p = r_point_list[rad_num][i].FI;\n\t\t\tbool flag = can_rotate(p, rad_num);\n\t\t\tcout << p.real() << \" \" << p.imag() << \" \" << flag << endl;\n\t\t}\n\t\tm = r_segment_list[rad_num].size();\n\t\tcout << m << endl;\n\t\tREP(i, m){\n\t\t\tsegment seg = r_segment_list[rad_num][i];\n\t\t\tcout << seg[0].real() << \" \" << seg[0].imag() << \" \" << seg[1].real() << \" \" << seg[1].imag() << endl;\n\t\t}\n\t\tm = r_segment_list[(rad_num + 1) % r].size();\n\t\tcout << m << endl;\n\t\tREP(i, m){\n\t\t\tsegment seg = r_segment_list[(rad_num + 1) % r][i];\n\t\t\tcout << seg[0].real() << \" \" << seg[0].imag() << \" \" << seg[1].real() << \" \" << seg[1].imag() << endl;\n\t\t}\n\t\tvector<segment> g;\n\t\tREP(i, r_point_list[rad_num].size()){\n\t\t\tauto p_a = r_point_list[rad_num][i].FI;\n\t\t\tauto id_a = r_point_list[rad_num][i].SE;\n\t\t\tREP(j, i){\n\t\t\t\tauto p_b = r_point_list[rad_num][j].FI;\n\t\t\t\tauto id_b = r_point_list[rad_num][j].SE;\n\t\t\t\tif(check_visible(p_a, p_b, rad_num)){\n\t\t\t\t\tg.EB(p_a, p_b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm = g.size();\n\t\tcout << m << endl;\n\t\tREP(i, m){\n\t\t\tsegment seg = g[i];\n\t\t\tcout << seg[0].real() << \" \" << seg[0].imag() << \" \" << seg[1].real() << \" \" << seg[1].imag() << endl;\n\t\t}\n\t}\n\texit(0);\n}\n\nint main() {\n\tdouble cx, cy, r;cin >> cx >> cy >> r;\n\tcircle c = circle(point(cx, cy), r);\n\tint q;cin >> q;\n\tcout << Decimal;\n\tREP(i, q){\n\t\tdouble x1, y1, x2, y2;cin >> x1 >> y1 >> x2 >> y2;\n\t\tsegment line = segment(point(x1, y1), point(x2, y2));\n\t\tauto ans = crosspointCL(c, line);\n\t\tsort(ALL(ans));\n\t\tcout << ans[0].real() << \" \" << ans[0].imag() << \" \";\n\t\tif(abs(ans[1].real() - INF) < EPS)cout << ans[0].real() << \" \" << ans[0].imag() << endl;\n\t\telse cout << ans[1].real() << \" \" << ans[1].imag() << endl;\n\t}\n}\n\n/*\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\tcin >> L >> r;L += EPS_GIG;\n\tcin >> sx >> sy;\n\tcin >> gx >> gy;\n\n\tcin >> n;\n\tREP(i, n){\n\t\tdouble x1, y1, x2, y2;cin >> x1 >> y1 >> x2 >> y2;\n\t\tseg_list.EB(point(x1, y1), point(x2, y2));\n\t}\n\tclock_t start = clock();\n\n\tREP(i, r){\n\t\tmake_r_segment_list_square_list(i);\n\t\tmake_r_sector_list(i);\n\t}\n\tREP(i, r){\n\t\tmake_r_point_list(i);\n\t}\n\tREP(i, r){\n\t\tmake_visible_graph(i);\n\t}\n\tREP(i, r){\n\t\tmake_rotate_point(i);\n\t}\n\n\t//output_visible_graph();\n\n\tcout << \"point_size \" << point_size << endl;\n\n\tREP(i, point_size)dist[i] = INF;\n\tdist[0] = 0;\n\tint ans = Dijkstra();\n\n\tif(ans == INF)cout << -1 << endl;\n\telse cout << ans << endl;\n\tclock_t end = clock();\n\tdouble time = static_cast<double>(end - start) / CLOCKS_PER_SEC * 1000.0;\n\tcout << \"time \" << time << endl;\n\treturn 0;\n}\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //std==c++14\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a,b) ( fabs(a-b) < EPS )\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intersect Circle and Circle\nstatic const int ICC_SEPARATE = 4;//離れている\nstatic const int ICC_CIRCUMSCRIBE = 3;//外接\nstatic const int ICC_INTERSECT = 2;// 交わる\nstatic const int ICC_INSCRIBE = 1;// 内接\nstatic const int ICC_CONTAIN = 0;//内包\n\nstruct point{\n\tdouble x,y;\n\t//construct\n\tpoint() {} \n\tpoint(double x,double y):x(x),y(y){}\n\t//演算子\n\tpoint operator + (point p) { return point(x+p.x,y+p.y); }\n\tpoint operator - (point p) { return point(x-p.x,y-p.y); }\n\tpoint operator * (double k) { return point(x*k,y*k); }\n\tpoint operator / (double k) { return point(x/k,y/k); }\n\tpoint operator / (point p) { return point( (x*p.x + y*p.y)/p.norm()  , (-x*p.y + y*p.x)/p.norm() ) ; }\n\tbool operator < (point p) { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (point p) { return equals(x,p.x) && equals(y,p.y) ; }\n\t//function\n\tdouble arg() { return atan2(y,x) ; }\n\tdouble norm(){return x*x+y*y; }\n\tdouble abs() { return sqrt(norm() ) ;}\n\tdouble dot(point p) { return p.x*x + p.y*y; }\n\tdouble cross(point p) { return x*p.y - y*p.x; }\n\n\t//input output\n\tvoid input(){cin>>x>>y;}\n\tvoid polar(double r,double theta){ x = r*cos(theta), y= r*sin(theta) ; }\n\tvoid print(){cout<<x<<' '<<y<<endl;};\n\n};\n\nbool sort_x(point a,point b){\n\treturn a.x!=b.x?a.x<b.x:a.y<b.y ;\n}\nbool sort_y(point a,point b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x ;\n}\n\ntypedef vector<point> polygon;\n\nstruct segment{\n\tpoint s,t;\n\tsegment() {}\n\tsegment(point s,point t) : s(s),t(t){}\n\tvoid input(){s.input(),t.input(); }\n};\ntypedef segment line;\n\nstruct circle{\n\tpoint c;\n\tdouble r;\n\tcircle() {}\n\tcircle(point c,double r) : c(c),r(r){}\n\tvoid input(){c.input(); cin>>r; }\n};\n\ndouble norm(point a){\treturn a.norm(); }\ndouble abs(point a){ return a.abs(); }\ndouble arg(point a){ return a.arg(); }\ndouble dot(point a,point b) { return a.x*b.x + a.y*b.y ; }\ndouble cross(point a,point b) { return a.x * b.y - a.y * b.x ; }\npoint polar(double r,double theta){ point a; a.polar(r,theta); return a; }\npoint orth(point p){ return point(-p.y,p.x); }\n\n//isOrthgonal 垂直\nbool isOrthogonal(point a,point b) { return equals(dot(a,b), 0.0 ) ; }\nbool isOrthogonal(point a,point b,point c,point d) { return isOrthogonal(a-b,c-d) ; }\nbool isOrthogonal(line l1,line l2 ){ return isOrthogonal(l1.t-l1.s,l2.t-l2.s); }\n//isParallel 平行\nbool isParallel(point a,point b) { return equals(cross(a,b), 0.0) ; }\nbool isParallel(point a,point b,point c,point d) { return isParallel(a-b,c-d); }\nbool isParallel(line l1,line l2) { return isParallel(l1.t-l1.s,l2.t-l2.s) ; }\n\npoint project(line l,point p){\n\tpoint base = l.t-l.s;\n\tdouble r = dot(p-l.s,base) / norm(base) ;\n\treturn l.s + base*r;\n}\npoint reflect(line l,point p){\n\treturn p + (project(l,p) - p) *2.0;\n}\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\n\tif(cross(a,b) > EPS ) return CCW_COUNTER_CLOCKWISE ;\n\tif(cross(a,b) < -EPS ) return CCW_CLOCKWISE;\n\tif(dot(a,b) < -EPS ) return CCW_ONLINE_BACK;\n\tif(a.norm() < b.norm() ) return CCW_ONLINE_FRONT;\n\treturn CCW_ON_SEGMENT;\n}\n\n\n//intersect\nbool intersect(point p1,point p2,point p3,point p4){return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 ) ; }\nbool intersect(line l1,line l2) { return intersect(l1.s,l1.t,l2.s,l2.t) ; }\nbool intersect(polygon p,line l){\n\tint n = p.size();\n\tfor(int i=0;i<n;i++)  if(intersect(line(p[i],p[(i+1)%n] ) , l ) ) return true;\n\treturn false;\n}\nint intersect(circle c1,circle c2){\n\tif(c1.r < c2.r) swap(c1,c2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble r = c1.r + c2.r;\n\tif(equals(d,r) ) return ICC_CIRCUMSCRIBE;\n\tif(d > r ) return ICC_SEPARATE;\n\tif(equals(d+c2.r,c1.r) ) return ICC_INSCRIBE;\n\tif( d + c2.r < c1.r ) return ICC_CONTAIN;\n\treturn ICC_INTERSECT;\n}\n\n//bool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; } distanceののち\nint intersectcs(circle c,line l ){// 0\t\t1\t\t2\n\tif(norm(project(l,c.c) - c.c )  - c.r*c.r  > EPS ) return 0;\n\tdouble d1 = abs(c.c-l.s),d2  = abs(c.c-l.t);\n\tif(d1 < c.r + EPS && d2 < c.r + EPS ) return 0;\n\tif( (d1<c.r - EPS && d2 > c.r +EPS) || (d1 > c.r +EPS &&d2 < c.r -EPS ) ) return 1;\n\tpoint h = project(l,c.c) ;\n\tif(dot(l.s-h,l.t-h) < 0 ) return 2;\n\treturn 0;\n}\n\n//distance\n//line point\ndouble distancelp(line l,point p){ return abs(cross(l.t-l.s,p-l.s)/ abs(l.t-l.s)  ); }\n//segment point\ndouble distancesp(line l,point p){ \n\tif(dot(l.t-l.s,p-l.s) < 0.0 ) return abs(p-l.s);\n\tif(dot(l.s-l.t,p-l.t) < 0.0 ) return abs(p-l.t);\n\treturn distancelp(l,p);\n}\n//segment segment \ndouble distancess(line l1,line l2){\n\tif(intersect(l1,l2) ) return 0.0;\n\treturn min( min(distancesp(l1,l2.s) ,distancesp(l1,l2.t) ) , min(distancesp(l2,l1.s),distancesp(l2,l1.t)  ) );\n}\n\nbool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; }\n\n//crosspoint \n//segment segment\npoint crosspointss(line l1,line l2){\n\tfor(int k=0;k<2;k++){\n\t\tif(distancesp(l1,l2.s) < EPS ) return l2.s;\n\t\tif(distancesp(l1,l2.t) < EPS ) return l2.t;\n\t\tswap(l1,l2);\n\t}\n\tpoint base = l2.t-l2.s;\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.t-l2.s) );\n\tdouble t = d1/(d1+d2);\n\treturn l1.s + (l1.t-l1.s) * t;\n}\n//line line\npoint crosspointll(line l1,line l2){\n\tdouble a = cross(l1.t-l1.s,l2.t-l2.s);\n\tdouble b = cross(l1.t-l1.s,l1.t-l2.s);\n\tif(abs(a) < EPS && abs(b) < EPS ) return l2.s;\n\treturn l2.s + (l2.t-l2.s) * (b/a) ;\n}\n//circle line\npolygon crosspointCL(circle c,line l){\n\tpolygon ps;\n\tpoint pr = project(l,c.c);\n\tpoint e = (l.t - l.s) / abs(l.t-l.s) ;\n\tif(distancelp(l,c.c) > c.r ) return ps;//付け足した\n\tif(equals(distancelp(l,c.c),c.r) ){\n\t\tps.emplace_back(pr);\n\t}\n\tdouble base = sqrt(c.r*c.r - norm(pr-c.c) );\n\tps.emplace_back(pr + e*base ) ;\n\tps.emplace_back(pr - e*base ) ;\n\treturn ps;\n}\n//circle segment\npolygon crosspointCS(circle c,line l ){\n\tpolygon res = crosspointCL(c,l);\n\tif(intersectcs(c,l) == 2 ) return res;\n\tif(res.size() > 1u ){//一つのみ削る\n\t\tif(dot(l.s-res[0] ,l.t-res[0] ) > 0) swap(res[0],res[1] );\n\t\tres.pop_back();\n\t}\n\treturn res;\n}\npolygon crosspointcc(circle c1,circle c2){\n\tpolygon p(2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble a = acos( (c1.r *c1.r + d*d -c2.r*c2.r) /(2*c1.r*d ) );\n\tdouble t = arg(c2.c-c1.c);\n\tp[0] = c1.c + polar(c1.r,t+a);\n\tp[1] = c1.c + polar(c1.r,t-a);\n\treturn p;\n}\n\nint contains(polygon g,point p) { //IN:2 ON:1 OUT:0\n    int n = g.size();\n    bool f = false;\n    for(int i=0;i<n;i++){\n\tpoint a = g[i] - p,b = g[(i+1)%n] - p;\n\tif( fabs(cross(a,b) ) < EPS && dot(a,b) < EPS) return 1;\n\tif( a.y > b.y ) swap(a,b);\n\tif( a.y < EPS && EPS < b.y && cross(a,b) > EPS ) f = !f;\n    }\n    return (f?2:0) ;\n}\n\npolygon andrewscan(polygon &s){ //convex hull\n\tpolygon u,l;\n\tif(s.size() < 3) return s;\n\t//sort(s.begin(),s.end() );\n\t//最も左で最も右の点にする\n\tsort(s.begin(),s.end(),sort_y);\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\tfor(int i=2;i<s.size();i++){\n\t\tfor(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\n\t\t//for(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tu.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\t\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tl.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n\t//最も左で最も右の点にする\n\t/*point mini = l[0];\n\tint base = 0;\n\tfor(int i=0;i<l.size();i++)\n\t    if(mini.y > l[i].y || (mini.y==l[i].y && mini.x > l[i].x ) ){\n\t\t\tmini = l[i];\n\t\t\tbase = i;\n\t    }\n\tpolygon res;\n\tfor(int i=0;i<l.size();i++)res.push_back( l[(i+base)%l.size()] );\n\treturn res;*/\n}\n\ndouble diameter(polygon &s){\n\tpolygon p = s;\n\tint n = p.size();\n\tif(n==2) return abs(p[0]-p[1]);\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++){\n\t\tif(p[i] < p[k]) i = k;\n\t\tif(!(p[j]<p[k]) ) j = k;\n\t}\n\tdouble res = 0;\n\tint si = i,sj = j;\n\twhile( i != sj || j != si ){\n\t\tres = max(res,abs(p[i]-p[j]) );\n\t\tif(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j] ) < 0.0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\nbool isconvex(polygon p){\n\tbool f = 1;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tint t = ccw(p[(i+n-1)%n],p[i],p[(i+1)%n] );\n\t\tf&= t!=CCW_CLOCKWISE;\n\t}\n\treturn f;\n}\ndouble area(polygon p){\n\tdouble res =  0.0;\n\tfor(int i=0;i<p.size();i++) res += cross(p[i],p[ (i+1)%p.size() ]);\n\treturn res/2.0;\n}\ndouble area(circle c1,circle c2){\n\tdouble d = abs(c1.c-c2.c);\n\tif(c1.r + c2.r <= d + EPS ) return 0.0;\n\tif(d<=abs(c1.r-c2.r) ){\n\t\tdouble r = min(c1.r,c2.r);\n\t\treturn PI*r*r;\n\t}\n\tdouble rc = (d*d + c1.r*c1.r -c2.r*c2.r)/(2*d);\n\tdouble th = acos(rc/c1.r);\n\tdouble ph = acos( (d-rc)/c2.r);\n\treturn c1.r*c1.r*th + c2.r*c2.r*ph - d * c1.r * sin(th) ;\n}\n\npolygon convex_cut(polygon p,line l){\n\tpolygon q;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tpoint a = p[i] , b = p[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a) != -1 ) q.push_back(a);\n\t\tif(ccw(l.s,l.t,a) * ccw(l.s,l.t,b) < 0) q.push_back(crosspointss(line(a,b),l) );\n\t}\n\treturn q;\n}\n//[s,t) 再帰 devide and conquer\ndouble inf  = 1e10;\ndouble closest_pair_dac(polygon &p,int s,int t,double &res){\n\tif(t-s<=1)return inf;\n\tif(t-s==2){\n\t\tsort(p.begin()+s,p.begin()+t,sort_y);\n\t\treturn (p[s]-p[s+1]).abs();\n\t}\n\tint mid = (s+t)/2;\n\tdouble x = p[mid].x;\n\tres = min(closest_pair_dac(p,s,mid,res),closest_pair_dac(p,mid,t,res) );\n\tauto it = p.begin();\n\tauto its = it+s,itm = it+mid,itt = it + t;\n\tinplace_merge(its,itm,itt,sort_y);\n\tvector<point> tmp;\n\tfor(int i=s;i<t;i++){\n\t\tif(abs(p[i].x-x) >= res) continue;\n\t\tfor(int j=tmp.size()-1;j>=0;j--){\n\t\t\tpoint d = p[i]-tmp[j];\n\t\t\tif(d.y >= res) break;\n\t\t\tres = min( res , d.abs() );\n\t\t}\n\t\ttmp.push_back(p[i]);\n\t}\n\treturn res;\n}\ndouble closest_pair(polygon &p){\n\tdouble res = inf;\n\tsort(p.begin(),p.end());\n\treturn  closest_pair_dac(p,0,p.size(),res);\n}\n\nint main(){\n    \tcircle c;\n\tc.input();\n\tint q;cin>>q;\n\tfor(int i=0;i<q;i++){\n\t    \tline l;\n\t\tl.input();\n\t\tpolygon res  = crosspointCL(c,l);\n\t\tif(res.size()==1)res.push_back(res[0]);\n\t\tsort(res.begin(),res.end());\n\t\tprintf(\"%0.10lf %0.10lf %0.10lf %0.10lf\\n\",res[0].x,res[0].y,res[1].x,res[1].y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n//BEGIN\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n#define Pi 3.141592653589793238\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(const double& k) const { return Point(x * k, y * k); }\n\tPoint operator/(const double& k) const { return Point(x / k, y / k); }\n\n\tfriend istream& operator>>(istream& is, Point& p) {\n\t\tis >> p.x >> p.y;\n\t\treturn is;\n\t}\n\n\tbool operator==(const Point& p) const { return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS); }\n\tbool operator<(const Point& p) const { return (x != p.x ? x < p.x : y < p.y); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator<(const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n\n\tfriend istream& operator>>(istream& is, Segment& s) {\n\t\tis >> s.p1 >> s.p2;\n\t\treturn is;\n\t}\n};\n\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersectSS(Segment s1, Segment s2) {\n\treturn intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersectCS(Circle c, Segment s) {\n\tif (norm(project(s, c.c) - c.c) - c.r * c.r > EPS) return 0;\n\tdouble d1 = abs(c.c - s.p1), d2 = abs(c.c - s.p2);\n\tif (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n\tif ((d1 < c.r - EPS && d2 > c.r + EPS) || (d1 > c.r + EPS && d2 < c.r - EPS)) return 1;\n\tPoint h = project(s, c.c);\n\tif (dot(s.p1 - h, s.p2 - h) < 0) return 2;\n\treturn 0;\n}\n\nint intersectCC(Circle c1, Circle c2) {\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble d = abs(c1.c - c2.c);\n\tdouble r = c1.r + c2.r;\n\tif (equals(d, r)) return 3;\n\tif (d > r) return 4;\n\tif (equals(d + c2.r, c1.r)) return 1;\n\tif (d + c2.r < c1.r) return 0;\n\treturn 2;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2),\n\t\t\t   getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\nPoint getCrossPointLL(Line l1, Line l2) {\n\tdouble a = cross(l1.p2 - l1.p1, l2.p2 - l2.p1);\n\tdouble b = cross(l1.p2 - l1.p1, l1.p2 - l2.p1);\n\tif (abs(a) < EPS && abs(b) < EPS) return l2.p1;\n\treturn l2.p1 + (l2.p2 - l2.p1) * (b / a);\n}\n\nPoint getCrossPointSS(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\nvector<Point> getCrossPointCL(Circle c, Line l) {\n\tvector<Point> ps;\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tif (equals(getDistanceLP(l, c.c), c.r)) return vector<Point>{pr, pr};\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\tps.push_back(pr + e * base); ps.push_back(pr - e * base);\n\treturn ps;\n}\n\nvector<Point> getCrossPointCS(Circle c, Segment s) {\n\tLine l(s);\n\tvector<Point> ps = getCrossPointCL(c, l);\n\tif (intersectCS(c, s) == 2) return ps;\n\tif (dot(l.p1 - ps[0], l.p2 - ps[0]) < 0) ps[1] = ps[0];\n\telse ps[0] = ps[1];\n\treturn ps;\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nPoint polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nvector<Point> getCrossPointCC(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tvector<Point> ps;\n\tps.push_back(c1.c + polar(c1.r, t + a)); ps.push_back(c1.c + polar(c1.r, t - a));\n\treturn ps;\n}\n\nvector<Point> tangentCP(Circle c, Point p) {\n\treturn getCrossPointCC(c, Circle(p, sqrt(norm(c.c - p) - c.r * c.r)));\n}\n\nvector<Line> tangentCC(Circle c1, Circle c2) {\n\tvector<Line> ls;\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble g = norm(c1.c - c2.c);\n\tif (equals(g, 0)) return ls;\n\tPoint u = (c2.c - c1.c) / sqrt(g);\n\tPoint v = Point(-u.y, u.x);\n\tfor (int s = 1; s >= -1; s -= 2) {\n\t\tdouble h = (c1.r + s * c2.r) / sqrt(g);\n\t\tif (equals(1, h * h)) ls.push_back(Line(c1.c + u * c1.r, c1.c + (u + v) * c1.r));\n\t\telse if (1 - h * h > 0) {\n\t\t\tPoint uu = u * h, vv = v * sqrt(1 - h * h);\n\t\t\tls.push_back(Line(c1.c + (uu + vv) * c1.r, c2.c - (uu + vv) * c2.r * s));\n\t\t\tls.push_back(Line(c1.c + (uu - vv) * c1.r, c2.c - (uu - vv) * c2.r * s));\n\t\t}\n\t}\n\treturn ls;\n}\n\n// IN:2,ON:1,OUT:0\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\nbool isConvex(Polygon p) {\n\tint n = p.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tif (ccw(p[(i - 1 + n) % n], p[i], p[(i + 1) % n]) == CLOCKWISE) return false;\n\treturn true;\n}\n\nPolygon convexHull(Polygon p) {\n\tint n = p.size();\n\tsort(p.begin(), p.end(),\n\t\t [](const Point& a, const Point& b) {return (a.y != b.y ? a.y < b.y : a.x < b.x); });\n\tPolygon a(2 * n);\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (k > 1 && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; --i) {\n\t\twhile (k > t && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\ta.resize(k - 1);\n\treturn a;\n}\n\ndouble area(Polygon p) {\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\tres += cross(p[i], p[(i + 1) % p.size()]) / 2.0;\n\treturn res;\n}\n\ndouble area(Polygon p, Circle c) {\n\tif (p.size() < 3) return 0.0;\n\tfunction<double(Circle, Point, Point)> dfs = [&](Circle c, Point a, Point b) {\n\t\tVector va = c.c - a, vb = c.c - b;\n\t\tdouble f = cross(va, vb), res = 0;\n\t\tif (equals(f, 0.0)) return res;\n\t\tif (max(abs(va), abs(vb)) < c.r + EPS) return f;\n\t\tVector d(dot(va, vb), cross(va, vb));\n\t\tif (getDistanceSP(Segment(a, b), c.c) > c.r - EPS)\n\t\t\treturn c.r * c.r * atan2(d.y, d.x);\n\t\tauto u = getCrossPointCS(c, Segment(a, b));\n\t\tvector<Point> ps{ a,u[0],u[1],b };\n\t\tfor (int i = 1; i < ps.size(); ++i) res += dfs(c, ps[i - 1], ps[i]);\n\t\treturn res;\n\t};\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i) res += dfs(c, p[i], p[(i + 1) % p.size()]);\n\treturn res / 2;\n}\n\ndouble convexDiameter(Polygon p) {\n\tint n = p.size();\n\tif (n == 2) return abs(p[0] - p[1]);\n\tint i = 0, j = 0;\n\tfor (int k = 0; k < n; ++k) {\n\t\tif (p[i] < p[k]) i = k;\n\t\tif (!(p[j] < p[k])) j = k;\n\t}\n\tdouble res = 0;\n\tint ti = i, tj = j;\n\twhile (i != tj || j != ti) {\n\t\tres = max(res, abs(p[i] - p[j]));\n\t\tif (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0.0)\n\t\t\ti = (i + 1) % n;\n\t\telse j = (j + 1) % n;\n\t}\n\treturn res;\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\tfor (int i = 0; i < (int)p.size(); ++i) {\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE) q.push_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0)\n\t\t\tq.push_back(getCrossPointLL(Line(a, b), l));\n\t}\n\treturn q;\n}\n\ndouble closestPair(vector<Point> ps) {\n\tsort(ps.begin(), ps.end());\n\tvector<Point> a(ps.size());\n\tfunction<double(int, int)> solve = [&](int l, int r) {\n\t\tif (r - l < 2) return 1e18;\n\t\tint mid = (l + r) >> 1;\n\t\tdouble x = ps[mid].x;\n\t\tdouble d = min(solve(l, mid), solve(mid, r));\n\t\tinplace_merge(ps.begin() + l, ps.begin() + mid, ps.begin() + r,\n\t\t\t\t\t  [](const Point& a, const Point& b) {return a.y < b.y; });\n\t\tint ptr = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tif (abs(ps[i].x - x) >= d) continue;\n\t\t\tfor (int j = 0; j < ptr; ++j) {\n\t\t\t\tPoint luz = ps[i] - a[ptr - j - 1];\n\t\t\t\tif (luz.y >= d) break;\n\t\t\t\td = min(d, abs(luz));\n\t\t\t}\n\t\t\ta[ptr++] = ps[i];\n\t\t}\n\t\treturn d;\n\t};\n\treturn solve(0, ps.size());\n}\n\nint manhattanIntersection(vector<Segment> ss) {\n\tconst int INF = numeric_limits<int>::max();\n\tconst int BOTTOM = 0, LEFT = 1, RIGHT = 2, TOP = 3;\n\tint n = ss.size();\n\tvector<EndPoint> ep;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ss[i].p1.y == ss[i].p2.y) {\n\t\t\tif (ss[i].p1.x > ss[i].p2.x) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, LEFT));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, RIGHT));\n\t\t} else {\n\t\t\tif (ss[i].p1.y > ss[i].p2.y) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, BOTTOM));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, TOP));\n\t\t}\n\t}\n\tsort(ep.begin(), ep.end());\n\tset<int> st;\n\tst.insert(INF);\n\tint cnt = 0;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tif (ep[i].st == TOP) st.erase(ep[i].p.x);\n\t\telse if (ep[i].st == BOTTOM) st.insert(ep[i].p.x);\n\t\telse if (ep[i].st == LEFT) {\n\t\t\tauto b = st.lower_bound(ss[ep[i].seg].p1.x);\n\t\t\tauto e = st.upper_bound(ss[ep[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\n//END\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CGL1A() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = project(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A\n*/\nvoid CGL1B() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = reflect(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B\n*/\nvoid CGL1C() {\n\tPoint p0, p1, p2; cin >> p0 >> p1;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tcin >> p2;\n\t\tint a = ccw(p0, p1, p2);\n\t\tif (a == COUNTER_CLOCKWISE) cout << \"COUNTER_CLOCKWISE\";\n\t\telse if (a == CLOCKWISE) cout << \"CLOCKWISE\";\n\t\telse if (a == ONLINE_BACK) cout << \"ONLINE_BACK\";\n\t\telse if (a == ONLINE_FRONT) cout << \"ONLINE_FRONT\";\n\t\telse cout << \"ON_SEGMENT\";\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\n*/\nvoid CGL2A() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tVector p0, p1, p2, p3;\n\t\tcin >> p0 >> p1 >> p2 >> p3;\n\t\tif (isParallel(p1 - p0, p3 - p2)) cout << 2;\n\t\telse if (isOrthogonal(p1 - p0, p3 - p2)) cout << 1;\n\t\telse cout << 0;\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\n*/\nvoid CGL2B() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tcout << (intersectSS(s1, s2) ? 1 : 0) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B\n*/\nvoid CGL2C() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tPoint a = getCrossPointLL(s1, s2);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C\n*/\nvoid CGL2D() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tprintf(\"%.10f\\n\", getDistanceSS(s1, s2));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D\n*/\nvoid CGL3A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.1f\\n\", area(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_A\n*/\nvoid CGL3B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tcout << (isConvex(p) ? 1 : 0) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_B\n*/\nvoid CGL3C() {\n\tint n; cin >> n;\n\tPolygon g(n);\n\tfor (auto& a : g) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tcout << contains(g, p) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_C\n*/\nvoid CGL4A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tPolygon t = convexHull(p);\n\tcout << t.size() << endl;\n\tfor (auto a : t) cout << a.x << \" \" << a.y << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_A\n*/\nvoid CGL4B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", convexDiameter(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_B\n*/\nvoid CGL4C() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l;\n\t\tprintf(\"%.10f\\n\", area(convexCut(p, l)));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_C\n*/\nvoid CGL5A() {\n\tint n; cin >> n;\n\tvector<Point> ps(n);\n\tfor (auto& a : ps) cin >> a;\n\tprintf(\"%.10f\\n\", closestPair(ps));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/5/CGL_5_A\n*/\nvoid CGL6A() {\n\tint n; cin >> n;\n\tvector<Segment> ss(n);\n\tfor (auto& a : ss) cin >> a;\n\tcout << manhattanIntersection(ss) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/6/CGL_6_A\n*/\nvoid CGL7A() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tcout << intersectCC(c1, c2) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A\n*/\n\nvoid CGL7D() {\n\tCircle c; cin >> c.c.x >> c.c.y >> c.r;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l;\n\t\tauto a = getCrossPointCL(c, l);\n\t\tsort(a.begin(), a.end());\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_D\n*/\nvoid CGL7E() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tauto a = getCrossPointCC(c1, c2);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_E\n*/\nvoid CGL7F() {\n\tPoint p; cin >> p;\n\tCircle c; cin >> c.c >> c.r;\n\tauto a = tangentCP(c, p);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f\\n%.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_F\n*/\nvoid CGL7G() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tauto a = tangentCC(c1, c2);\n\tvector<Point> ps;\n\tfor (auto e : a) ps.push_back(getCrossPointCL(c1, e)[0]);\n\tsort(ps.begin(), ps.end());\n\tfor (auto e : ps) printf(\"%.10f %.10f\\n\", e.x, e.y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G\n*/\nvoid CGL7H() {\n\tint n; cin >> n;\n\tCircle c; c.c = Point(0, 0); cin >> c.r;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", area(p, c));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_H\n*/\n\nint main() {\n\t//CGL1A();\n\t//CGL1B();\n\t//CGL1C();\n\t//CGL2A();\n\t//CGL2B();\n\t//CGL2C();\n\t//CGL2D();\n\t//CGL3A();\n\t//CGL3B();\n\t//CGL3C();\n\t//CGL4A();\n\t//CGL4B();\n\t//CGL4C();\n\t//CGL5A();\n\t//CGL6A();\n\t//CGL7A();\n\tCGL7D();\n\t//CGL7E();\n\t//CGL7F();\n\t//CGL7G();\n\t//CGL7H();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<map>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; };\n\n\tbool operator < (const Point& p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator ==(const Point& p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n};\n\ntypedef Point Vector;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\ntypedef Segment  Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn fabs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = fabs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = fabs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\t//assert(intersect(c, l));\n\tVector pr = project(l,c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\nint main() {\n\tdouble x, y, r,x1,y1,x2,y2;\n\tint q;\n\tpair<Point, Point> p;\n\n\tcin >> x >> y >> r;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tp= getCrossPoints(Circle(Point(x, y), r), Line(Point(x1, y1), Point(x2, y2)));\n\t\tif (p.second < p.first)swap(p.first, p.second);\n\n\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\", p.first.x, p.first.y, p.second.x, p.second.y);\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS=1e-10;\n\nbool equals(double a,double b)\n{\n\treturn a>b?a-b<EPS:b-a<EPS;\n}\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(double inx=0.0,double iny=0.0):x(inx),y(iny){}\n\tPoint operator+(const Point &p){return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p){return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k){return Point(x*k,y*k);}\n\tPoint operator/(const double k){return Point(x/k,y/k);}\n\tPoint operator=(const Point &p){x=p.x;y=p.y;return *this;}\n\tbool operator<(const Point &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator==(const Point &p)const{return equals(x,p.x)&&equals(y,p.y);}\n\tdouble norm()\n\t{\n\t\treturn x*x+y*y;\n\t}\n\tdouble abs()\n\t{\n\t\treturn sqrt(norm());\n\t}\n};\n\ntypedef Point Vector;\n\nclass Segment\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tVector getvector()\n\t{\n\t\treturn p2-p1;\n\t}\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point inc=Point(),double inr=0.0):c(inc),r(inr){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a,Vector b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\nconst int counter_clockwise=1;\nconst int clockwise=-1;\nconst int on_segment=0;\nconst int online_back=2;\nconst int online_front=-2;\n\ndouble norm(Vector a)\n{\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a)\n{\n\treturn sqrt(norm(a));\n}\n\nbool isorthogonal(Vector a,Vector b)\n{\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isorthogonal(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isorthogonal(a1-a2,b1-b2);\n}\n\nbool isorthogonal(Segment s1,Segment s2)\n{\n\treturn equals(dot(s1.getvector(),s2.getvector()),0.0);\n}\n\nbool isparallel(Vector a,Vector b)\n{\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isparallel(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isparallel(a1-a2,b1-b2);\n}\n\nbool isparallel(Segment s1,Segment s2)\n{\n\treturn equals(cross(s1.getvector(),s2.getvector()),0.0);\n}\n\nPoint project(Segment s,Point p)\n{\n\tVector base=s.getvector();\n\tdouble r=dot(p-s.p1,base)/norm(base);\n\treturn s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p)\n{\n\treturn project(s,p)*2.0-p;//p+(project(s,p)-p)*2.0\n}\n\ndouble getdistance(Point a,Point b)\n{\n\treturn abs(a-b);\n}\n\ndouble getdistancelp(Line l,Point p)//Line,Point\n{\n\tdouble s=abs(cross(l.p2-l.p1,p-l.p1));\n\treturn s/abs(l.getvector());\n}\n\ndouble getdistancesp(Segment s,Point p)\n{\n\tif(dot(s.getvector(),p-s.p1)<0.0)return abs(p-s.p1);\n\telse if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\telse return getdistancelp(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return counter_clockwise;\n\telse if(cross(a,b)<-EPS)return clockwise;\n\telse if(dot(a,b)<-EPS)return online_back;\n\telse if(a.norm()<b.norm())return online_front;\n\telse return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersect(Segment s1,Segment s2)\n{\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getdistance(Segment s1,Segment s2)\n{\n\tif(intersect(s1,s2))return 0.0;\n\telse return min(min(getdistancesp(s1,s2.p1),getdistancesp(s1,s2.p2)),\n\t\t\tmin(getdistancesp(s2,s1.p1),getdistancesp(s2,s1.p2)));\n}\n\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n\tVector base=s2.getvector();\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+s1.getvector()*t;\n}\n\npair<Point,Point> getcrosspoint(Circle c,Line l)\n{\n\tVector pr=project(l,c.c);\n\tVector e=l.getvector()/abs(l.getvector());\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p)\n{\n\treturn atan2(p.y,p.x);\n}\n\nPoint polar(double r,double theta)\n{\n\treturn Point(r*cos(theta),r*sin(theta));\n}\n\npair<Point,Point> getcrosspoint(Circle c1,Circle c2)\n{\n\tdouble d=abs(c2.c-c1.c);\n\tdouble a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2.0*c1.r*d));\n\tdouble t=arg(c2.c-c1.c);\n\treturn make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\nconst int Bottom=0;\nconst int Left=1;\nconst int Right=2;\nconst int Top=3;\n\nclass endPoint\n{\npublic:\n\tPoint p;\n\tint seg;//id of Point\n\tint st;//kind of Point\n\tendPoint(){}\n\tendPoint(Point inp,int inseg,int inst):p(inp),seg(inseg),st(inst){}\n\tbool operator<(const endPoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;//Bottom->Left->Right->Top\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nendPoint EP[200000];\n\nint manhattanintersection(vector<Segment> s)\n{\n\tint n=s.size();\n\tdouble sto;\n\t\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tif(s[i].p1.x>s[i].p2.x)\n\t\t\t{\n\t\t\t\tsto=s[i].p1.x;\n\t\t\t\ts[i].p1.x=s[i].p2.x;\n\t\t\t\ts[i].p2.x=sto;\n\t\t\t}\n\t\t}\n\t\telse if(s[i].p1.y>s[i].p2.y)\n\t\t{\n\t\t\tsto=s[i].p1.y;\n\t\t\ts[i].p1.y=s[i].p2.y;\n\t\t\ts[i].p2.y=sto;\n\t\t}\n\t\t\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Left);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Bottom);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Top);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+2*n);\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==Top)BT.erase(EP[i].p.x);\n\t\telse if(EP[i].st==Bottom)BT.insert(EP[i].p.x);\n\t\telse if(EP[i].st==Left)\n\t\t{\n\t\t\tset<int>::iterator b=lower_bound(BT.begin(),BT.end(),s[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=upper_bound(BT.begin(),BT.end(),s[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\t\n\treturn cnt;\n}\nPolygon andrewscan(Polygon s)\n{\n\tPolygon u,l;\n\tif(s.size()<=2)return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\t\n\tfor(int i=2;i<s.size();i++)\n\t{\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor(int i=s.size()-3;i>=0;i--)\n\t{\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\t\n\treturn l;\n}\nconst int in=2;\nconst int on=1;\nconst int out=0;\n\nint contain(Polygon g,Point p)\n{\n\tint n=g.size();\n\tbool x=false;\n\tPoint a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta=g[i]-p;\n\t\tb=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return on;\n\t\tif(a.y>b.y)\n\t\t{\n\t\t\tPoint sto=a;\n\t\t\ta=b;\n\t\t\tb=sto;\n\t\t}\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n\t}\n\treturn x?in:out;\n}\nint main()\n{\n\tCircle c;\n\tcin>>c.c.x>>c.c.y>>c.r;\n\tint q;cin>>q;\n\tSegment s1;\n\tpair<Point,Point>a;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>s1.p1.x>>s1.p1.y>>s1.p2.x>>s1.p2.y;\n\t\ta=getcrosspoint(c,s1);\n\t\tif(a.first<a.second)cout<<fixed<<setprecision(8)<<a.first.x<<\" \"<<a.first.y<<\" \"<<a.second.x<<\" \"<<a.second.y<<endl;\n\t\telse cout<<fixed<<setprecision(8)<<a.second.x<<\" \"<<a.second.y<<\" \"<<a.first.x<<\" \"<<a.first.y<<endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tdouble cx = 0, cy = 0, r = 0;\n\tint q = 0;\n\tdouble x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n\n\tcin >> cx >> cy >> r >> q;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\tdouble a = 0, b = 0, s = 0, t = 0, u = 0,\n\t\t\tv1 = 0, v2 = 0, w1 = 0, w2 = 0;\n\n\t\tif (x1 == x2) {\n\t\t\tv1 = x1;\n\t\t\tv2 = x2;\n\t\t\tw1 = cy - sqrt(r * r - (x1 - cx) * (x1 - cx));\n\t\t\tw2 = cy + sqrt(r * r - (x1 - cx) * (x1 - cx));\n\t\t}\n\t\telse {\n\t\t\ta = (y2 - y1) / (x2 - x1);\n\t\t\tb = (x2 * y1 - x1 * y2) / (x2 - x1);\n\n\t\t\ts = a * a + 1;\n\t\t\tt = a * b - a * cy - cx;\n\t\t\tu = cx * cx + (b - cy) * (b - cy) - r * r;\n\n\t\t\tv1 = (-t - sqrt(t * t - s * u)) / s;\n\t\t\tv2 = (-t + sqrt(t * t - s * u)) / s;\n\t\t\tw1 = a * v1 + b;\n\t\t\tw2 = a * v2 + b;\n\t\t}\n\n\t\tcout << setiosflags(ios::fixed | ios::showpoint) << setprecision(8)\n\t\t\t << v1 << \" \" << w1 << \" \" << v2 << \" \" << w2 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#include<cstdio>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-7)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\t//cout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t\tprintf(\"%.9f %.9f %.9f %.9f\\n\", ans.first.x, ans.first.y, ans.second.x, ans.second.y);\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tdouble base = sqrt(r * r - pr.norm());\n\n\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * base;\n\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * base;\n\t\n\tif (ans1 < ans2) {\n\t\treturn make_pair(ans1, ans2);\n\t} else {\n\t\treturn make_pair(ans2, ans1);\n\t}\n\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#define ESP (1e-13)\nusing namespace std;\n\n//??§?¨????????§???????\ntypedef struct Point {\n\tdouble x; \n\tdouble y;\n\n\tPoint() { }\n\n\tPoint(double x, double y) :x(x), y(y) { }\n\n\tPoint operator+(const Point& p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\n\tPoint operator-(const Point& p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\n\tPoint operator*(const double& a) {\n\t\treturn Point(x*a, y*a);\n\t}\n\n\tPoint operator/(const double& a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tPoint operator=(const Point& p1) {\n\t\treturn Point(p1.x,p1.y);\n\t}\n\n};\n\n//??´??§?????????????§???????\ntypedef Point Vector;\n\n//??´???????§???????\n struct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(const Point& a,const Point& b) : p1(a),p2(b) { }\n};\n\n //??????????§???????\n typedef Line Segment;\n\n //???????§???????\n struct Circle {\n\t Point c;\n\t double r;\n\t Circle(){ }\n\t Circle(const Point& p,const double& r) : c(p),r(r) { }\n };\n\n//2??????????????¢????±?????????¢??°\ndouble abs(Point p1, Point p2) {\n\tdouble norm = (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);\n\treturn sqrt(norm);\n}\n\n//????????¢??°\ndouble product(Vector v1, Vector v2) {\n\treturn v1.x*v2.x + v1.y*v2.y;\n}\n\n//????????¢??°\ndouble cross(Vector p1, Vector p2) {\n\treturn p1.x*p2.y - p1.y*p2.x;\n}\n\n//3??????????????¢???????±?????????¢??°\nint ccw(Point p0, Point p1, Point p2) {\n\tVector v0 = p1 - p0;\n\tVector v1 = p2 - p0;\n\tif (cross(v0, v1) > ESP) return 1;   //p0,p1,p2??????????¨???????\n\tif (cross(v0, v1) < -ESP) return -1;   //p0,p1,p2???????¨???????\n\tif (product(v0, v1) < -ESP) return 2;  //p2,p0,p1????????§????????´??????\n\tif (abs(p0, p1) < abs(p0, p2)) return -2;  //p0,p1,p2????????§????????´??????\n\treturn 0;   //p2?????????(p0,p1)???\n}\n\n//??????????????´????????????????°???±?????§?¨?????±?????????¢??°\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble x = abs(base, Point(0.0, 0.0))*abs(base, Point(0.0, 0.0));\n\tdouble r = product(p - s.p1, base) / x;\n\treturn s.p1 + base*r;\n}\n\n//????????????????±??????¨??????????????????????§°????????§?¨?????±?????????¢??°\nPoint reflect(Segment s, Point p) {\n\treturn (project(s, p) - p)*2.0 + p;\n}\n\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n\treturn (ccw(p0, p1, p2)*ccw(p0, p1, p3) <= 0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n\t//?????????????????????????????¶\n}\n\n//????????????????????£??????????????????????????¢??°\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//??´?????¨???????????¢????±?????????¢??°\ndouble DistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)/abs(l.p1,l.p2));\n}\n\n//????????¨???????????¢????±?????????¢??°\ndouble DistanceSP(Segment s, Point p) {\n\tif (product(s.p2 - s.p1, p - s.p1) < -ESP) return abs(p, s.p1);\n\tif (product(s.p1 - s.p2, p - s.p2) < -ESP) return abs(p, s.p2);\n\treturn DistanceLP(s, p);\n}\n\n//2??????????????¢????±?????????¢??°\ndouble DistanceSS(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(DistanceSP(s1, s2.p1), DistanceSP(s1,s2.p2)), min(DistanceSP(s2, s1.p1), DistanceSP(s2, s1.p2)));\n}\n\n//?????´???????\\???¢????±?????????¢??°\nPoint CrossPoint(Line s1,Line s2) {\n\tdouble d1=DistanceLP(s2, s1.p1);\n\tdouble d2 = DistanceLP(s2, s1.p2);\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//?????¨??´?????????????????????????????¢??°\nbool intersect(Circle c, Line l) {\n\treturn DistanceLP(l, c.c) < c.r;\n}\n\n//?????¨??´????????????????±?????????¢??°\npair<Point, Point> CrossPoints(Circle c, Line l) {\n\tVector prpr = project(l, c.c);\n\tVector hshs = (l.p2 - l.p1)/abs(l.p2 ,l.p1);\n\tdouble base = sqrt(c.r*c.r - abs(c.c, prpr)*abs(c.c, prpr));\n\treturn make_pair(prpr - hshs*base, prpr + hshs*base);\n}\n\n//2??´??????????????¢???????±?????????¢??°???\n   //??´?????????\nbool isOrth(Vector a, Vector b) {\n\treturn abs(product(a, b)) < ESP;\n   }\nbool isOrth(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrth(a1 - a2, b1 - b2);\n}\nbool isOrth(Segment s1, Segment s2) {\n\treturn isOrth(s1.p2, s1.p1, s2.p2, s2.p1);\n}\n    //????????????\nbool isPara(Vector a, Vector b) {\n\treturn abs(cross(a, b)) < ESP;\n}\nbool isPara(Point a1, Point a2, Point b1, Point b2) {\n\treturn isPara(a1 - a2, b1 - b2);\n}\nbool isPara(Segment s1, Segment s2) {\n\treturn isPara(s1.p2, s1.p1, s2.p2, s2.p1);\n}\n\n\nint main() {\n\tCircle c;\n\tint q;\n\tcin >> c.c.x; cin >> c.c.y; cin >> c.r;\n\tcin >> q;\n\tfor (int i = 0;i < q;i++) {\n\t\tLine l;\n\t\tcin >> l.p1.x; cin >> l.p1.y;\n\t\tcin >> l.p2.x; cin >> l.p2.y;\n\t\tpair<Point, Point> crs = CrossPoints(c, l);\n\t\tcout << setprecision(12);\n\t\tcout << crs.first.x << \" \" << crs.first.y << \" \" << crs.second.x << \" \" << crs.second.y << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\n#define EPS 1e-10\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nVP crosspointLC(Point a1, Point a2, Point c, double r) {\n  VP ps;\n  Point ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n\n  Point dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  ps.push_back(ft - dir);\n  return ps;\n}\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nint main(void){\n    double cx,cy,r;\n    int q;\n    cin>>cx>>cy>>r>>q;\n    rep(i,q){\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        VP ps = crosspointLC(Point(x1,y1),Point(x2,y2),Point(cx,cy),r);\n        sort(all(ps));\n        printf(\"%.9f %.9f \" ,ps[0].X,ps[0].Y);\n        printf(\"%.9f %.9f\\n\",ps[1].X,ps[1].Y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n#define equals(a, b) (fabs((a)-(b)) < EPS)\nconst double EPS = (1e-10);\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (double a) {\n        return Point(x/a, y/a);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x*x + y*y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n// 内積\ndouble dot(Vector a, Vector b) {\n    return a.x*b.x + a.y*b.y;\n}\n// 外積\ndouble cross(Vector a, Vector b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    Vector hypo = p - s.p1;\n    double r = dot(hypo, base) / base.norm();\n    return s.p1 + base*r;\n}\n\nclass Circle {\npublic:\n    Point c;                    // 中心\n    double r;                   // 半径\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt(c.r*c.r - (pr-c.c).norm());\n    return make_pair(pr + e*base, pr - e*base);\n}\n\nint main(void) {\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n    Circle c(Point(cx, cy), r);\n\n    int q; cin >> q;\n    double x1, y1, x2, y2;\n    for (int i = 0; i < q; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line l(Point(x1, y1), Point(x2, y2));\n\n        pair<Point, Point> ans = getCrossPoints(c, l);\n        if (ans.first < ans.second) {\n            printf(\"%.9f %.9f %.9f %.9f\\n\", ans.first.x, ans.first.y,\n                   ans.second.x, ans.second.y);\n        } else {\n            printf(\"%.9f %.9f %.9f %.9f\\n\", ans.second.x, ans.second.y,\n                   ans.first.x, ans.first.y);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <utility>\n#define EPS 1e-10\nusing namespace std;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\treturn a+b;\n}\n\nclass P{\npublic:\n\tdouble x,y;\n\tP(double xx=0,double yy=0){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tbool operator<(const P &p)const{\n\t\tif(add(x,-p.x)==0.0)return y<p.y;\n\t\treturn x<p.x;\n\t}\n};\n\ntypedef P Vector;\n\ndouble norm(P p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\ndouble abs(P p){\n\treturn sqrt(norm(p));\n}\n\ndouble dot(Vector a,Vector b){\n\treturn add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(Vector a,Vector b){\n\treturn add(a.x*b.y,-a.y*b.x);\n}\n\nclass Segment{\npublic:\n\tP p1,p2;\n\tSegment(P pp1=P(),P pp2=P()){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\n\ntypedef Segment Line;\n\nP project(Segment s,P p){\n\tVector base=s.p2-s.p1;\n\tdouble r=dot(p-s.p1,base)/norm(base);\n\treturn s.p1+base*r;\n}\n\nclass Circle{\npublic:\n\tP c;\n\tdouble r;\n\tCircle(P cc=P(),double rr=0.0){\n\t\tc=cc;\n\t\tr=rr;\n\t}\n};\n\ndouble getDistanceLP(Line l,P p){\n\treturn abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\n\nbool intersect(Circle c,Line l){\n\treturn getDistanceLP(l,c.c)<=c.r;\n}\n\npair<P,P> getCrossPoints(Circle c,Line l){\n\tassert(intersect(c,l));\n\tVector pr=project(l,c.c);\n\tVector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\n\nint main(void){\n\tCircle c;\n\tscanf(\"%lf %lf %lf\",&c.c.x,&c.c.y,&c.r);\n\tint q;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tLine l;\n\t\tscanf(\"%lf %lf %lf %lf\",&l.p1.x,&l.p1.y,&l.p2.x,&l.p2.y);\n\t\tpair<P,P> res=getCrossPoints(c,l);\n\t\tif(res.second<res.first)swap(res.first,res.second);\n\t\tprintf(\"%.9f %.9f %.9f %.9f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\tcout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tdouble base = sqrt(r * r - pr.norm());\n\n\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * base;\n\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * base;\n\tif (equals(ans1.x, ans2.x)) {\n\t\tif (ans1.y < ans2.y) {\n\t\t\treturn make_pair(ans1, ans2);\n\t\t} else {\n\t\t\treturn make_pair(ans2, ans1);\n\t\t}\n\t}else if (ans1.x < ans2.x) {\n\t\treturn make_pair(ans1, ans2);\n\t} else {\n\t\treturn make_pair(ans2, ans1);\n\t}\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#define f first\n#define s second\n#define mp make_pair\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return (s1.p1+(s1.p2-s1.p1)*t);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nint main()\n{\n  Point A,B;\n  int q,a,b;\n  Circle C;\n\n  cin>>C.c.x>>C.c.y>>C.r;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>A.x>>A.y>>B.x>>B.y;\n    pair<Point,Point> PP=getCrossPoints(C,Line(A,B));\n    if(PP.f.x<PP.s.x+eps)\n      printf(\"%.10f %.10f %.10f %.10f\\n\",PP.f.x,PP.f.y,PP.s.x,PP.s.y);\n    else printf(\"%.10f %.10f %.10f %.10f\\n\",PP.s.x,PP.s.y,PP.f.x,PP.f.y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n// ???????????????\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n////////////////////\n// ??¨????????¢???\nusing D = double;\n////////////////////\n// ?????°\nconst D EPS = 1e-9;                // |EPS|???????????°???0??¨????????±???\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // 3??????????????¢???\n////////////////////\n// ?§???????\nstruct Point {\n  D x, y;\n  Point(const D d = 0.0) : x(d), y(d) {}\n  Point(const D x, const D y) : x(x), y(y) {}\n};\nstruct Segment {\n  Point initial, terminal;\n  Segment(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Segment(const D x1, const D y1, const D x2, const D y2) : initial(x1, y1), terminal(x2, y2) {}\n};\nstruct Line {\n  Point initial, terminal;\n  Line(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Line(const D x1, const D y1, const D x2, const D y2) : initial(x1, y1), terminal(x2, y2) {}\n  Line(const Segment& s) : initial(s.initial), terminal(s.terminal) {}\n};\n////////////////////\n// ????£?\nbool relative_equal(const D d1, const D d2) {return d1 == 0 ? std::abs(d2) < EPS : std::abs((d1 - d2) / d1) < EPS;}\n// ??????????????????????????????\nbool operator==(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) && relative_equal(lhs.y, rhs.y);}\nbool operator<(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y < rhs.y : lhs.x < rhs.x;}\nbool operator>(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y > rhs.y : lhs.x > rhs.x;}\nbool operator!=(const Point& lhs, const Point& rhs) {return !(lhs == rhs);}\nbool operator<=(const Point& lhs, const Point& rhs) {return !(lhs > rhs);}\nbool operator>=(const Point& lhs, const Point& rhs) {return !(lhs < rhs);}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x + rhs.x, lhs.y + rhs.y);}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x * rhs.x, lhs.y * rhs.y);}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x / rhs.x, lhs.y / rhs.y);}\nconst Point operator-(const Point& p) {return Point(-p.x, -p.y);}\n// ???\nD abs(const Point& p) {return std::hypot(p.x, p.y);}\nD norm(const Point& p) {return p.x * p.x + p.y * p.y;}\nD dot(const Point& a, const Point& b) {return a.x * b.x + a.y * b.y;}\nD cross(const Point& a, const Point& b) {return a.x * b.y - a.y * b.x;}\n// const Point normalize(const Point& p) {return p / abs(p);}\n// const Point normal(const Point& p) {return normalize(Point(-p.y, p.x));}\n// ??´???\nbool parallel(const Line& l1, const Line& l2) {return relative_equal(0.0, cross(l2.terminal - l2.initial, l1.terminal - l1.initial));}\nbool orthogonal(const Line& l1, const Line& l2) {return relative_equal(0.0, dot(l2.terminal - l2.initial, l1.terminal - l1.initial));}\n// 3??????????????¢???\nPOSITION ccw(const Point& a, const Point& b, const Point& p) {\n  Point v1 = b - a;\n  Point v2 = p - a;\n  if(cross(v1, v2) >= EPS) return COUNTER_CLOCKWISE;\n  if(cross(v1, v2) <= -EPS) return CLOCKWISE;\n  if(dot(v1, v2) <= -EPS) return ONLINE_BACK;\n  if(norm(v1) < norm(v2)) return ONLINE_FRONT;              // ????????????: norm(v1)<norm(v2)+EPS?????¨WrongAnswer\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(const Point& p1, const Point& p2) {return p1 == p2;}\nbool intersect(const Point& p, const Segment& s) {return abs(p - s.initial) + abs(p - s.terminal) - abs(s.initial - s.terminal) <= EPS;}\nbool intersect(const Segment& s, const Point& p) {return intersect(p, s);}\nbool intersect(const Point& p, const Line& l) {return !parallel(Line(p, l.initial), Line(p, l.terminal));}\nbool intersect(const Line& l, const Point& p) {return intersect(p, l);}\nbool intersect(const Segment& s1, const Segment& s2) {\n  return ccw(s1.initial, s1.terminal, s2.initial) * ccw(s1.initial, s1.terminal, s2.terminal) <= 0\n      && ccw(s2.initial, s2.terminal, s1.initial) * ccw(s2.initial, s2.terminal, s1.terminal) <= 0;\n}\nbool intersect(const Segment& s, const Line& l) {\n  auto v1 = l.terminal - l.initial;\n  auto v2 = s.initial  - l.initial;\n  auto v3 = s.terminal - l.initial;\n  return cross(v1, v2) * cross(v1, v3) <= EPS;\n}\nbool intersect(const Line& l, const Segment& s) {return intersect(s, l);}\nbool intersect(const Line& l1, const Line& l2) {return !parallel(l1, l2) || intersect(l1.initial, l2);}\n// ???????§????\nPoint rotate(const Point& p, const D a) {return Point(p.x * std::cos(a) - p.y * std::sin(a), p.x * std::sin(a) + p.y * std::cos(a));}\nPoint projection(const Point& p, const Line& l) {\n  auto v = l.initial - l.terminal;\n  return l.initial + dot(p - l.initial, v) / norm(v) * v;\n}\nPoint projection(const Line& l, const Point& p) {return projection(p, l);}\nPoint reflection(const Point& p, const Line& l) {return p + 2 * (projection(p, l) - p);}\nPoint reflection(const Line& l, const Point& p) {return reflection(p, l);}\n// ?????¢\nD distance(const Point& p1, const Point& p2) {\n  auto p = p1 - p2;\n  return hypot(p.x, p.y);\n}\nD distance(const Point& p, const Segment& s) {\n  auto r = projection(s, p);\n  return intersect(r, s) ? distance(p, r) : std::min(distance(p, s.initial), distance(p, s.terminal));\n}\nD distance(const Segment& s, const Point& p) {return distance(p, s);}\nD distance(const Point& p, const Line& l) {return distance(p, projection(p, l));}\nD distance(const Line& l, const Point& p) {return distance(p, l);}\nD distance(const Segment& s1, const Segment& s2) {\n  return intersect(s1, s2) ? 0.0 : std::min({distance(s1, s2.initial), distance(s1, s2.terminal), distance(s2, s1.initial), distance(s2, s1.terminal)});\n}\nD distance(const Segment& s, const Line& l) {return intersect(s, l) ? 0.0 : std::min(distance(s.initial, l), distance(s.terminal, l));}\nD distance(const Line& l,const Segment& s) {return distance(s, l);}\nD distance(const Line& l1, const Line& l2) {return intersect(l1, l2) ? 0.0 : distance(l1.initial, l2);}\n// ??????\nconst Point crosspoint(const Line& l1, const Line& l2) {\n  assert(intersect(l1, l2));\n  if(parallel(l1, l2)) return l1.initial;                   // ???????????¨???l1????§?????????????\n  D A = cross(l1.terminal - l1.initial, l2.terminal - l2.initial);\n  D B = cross(l1.terminal - l1.initial, l1.terminal - l2.initial);\n  return l2.initial + B / A * (l2.terminal - l2.initial);\n}\nconst Point crosspoint(const Segment& s, const Line& l) {\n  assert(intersect(s, l));\n  if(parallel(s, l)) return s.initial;\n  return crosspoint(Line(s), l);\n}\nconst Point crosspoint(const Line& l, const Segment& s) {return crosspoint(s, l);}\nconst Point crosspoint(const Segment& s1, const Segment& s2) {\n  assert(intersect(s1, s2));\n  if(parallel(s1, s2)) {                                    // ???????????¨?????????????????????????????????\n    if(intersect(s1.initial,  s2)) return s1.initial;\n    if(intersect(s1.terminal, s2)) return s1.terminal;\n    if(intersect(s2.initial,  s1)) return s2.initial;\n    if(intersect(s2.terminal, s1)) return s2.terminal;\n  }\n  return crosspoint(Line(s1), Line(s2));\n}\n// ???????????°??¨\n#include<iostream>\nstd::ostream& operator<<(std::ostream& os, const Point& p) {os<<\"point: \"; os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os;}\nstd::ostream& operator<<(std::ostream& os, const Segment& s) {os<<\"segment: \"; os<<s.initial<<\" - \"<<s.terminal; return os;}\nstd::ostream& operator<<(std::ostream& os, const Line& l) {os<<\"line: \"; os<<l.initial<<\" - \"<<l.terminal; return os;}\n////////////////////////////////////////////////////////////////////////////////\n// ???\n#include<vector>\nconst D PI = std::acos(-1);\nstruct Circle {\n  Point center;\n  D radius;\n  Circle(const Point& center = 0, const D radius = 0) : center(center), radius(radius) {}\n  Circle(const D x, const D y, const D radius) : center(x, y), radius(radius) {}\n};\nD area(const Circle& c) {return PI * c.radius * c.radius;}\nbool contain(const Circle& c, const Point& p) {\n  D d = abs(p - c.center);\n  if(relative_equal(c.radius, d)) return true;\n  return d < c.radius;\n}\nbool contain(const Point& p, const Circle& c) {return contain(c, p);}\n#include<bits/stdc++.h>\nusing namespace std;\nstd::vector<Point> crosspoint(const Circle& c, const Line& l) {\n  std::vector<Point> cp;\n  Point p = projection(c.center, l);\n  if(!contain(c, p)) return cp;\n  Point v = p - c.center;\n  if(relative_equal(abs(v), 0)) {\n    Point p = l.initial - c.center;\n    if(p == 0) p = l.terminal - c.center;\n    p = (c.radius * p / abs(p));\n    cp.push_back(c.center + p);\n    cp.push_back(c.center - p);\n    return cp;\n  }\n  D angle = acos(abs(v) / c.radius);\n  for(D a: {angle, -angle}) cp.push_back(c.center + c.radius * (rotate(v, a) / abs(v)));\n  return cp;\n}\nstd::vector<Point> crosspoint(const Line& l, const Circle& c) {return crosspoint(c, l);}\nint tangent(const Circle& c1, const Circle& c2) {\n  D d = abs(c1.center - c2.center);\n  D r = c1.radius + c2.radius;\n  if(relative_equal(d, r)) return 3;    // ?????\\\n  if(r < d) return 4;                   // ?????¢\n  r = std::abs(c1.radius - c2.radius);\n  if(relative_equal(d, r)) return 1;    // ?????\\\n  if(r < d) return 2;                   // ??????\n  return 0;                             // ??????\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ????§???¢\n//   ????????????????????°??????????????´??? ??? ?????¢???????´????edge(void)???O(????????°)???edge().begin()????????£????????????????????????????????????????????????\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<utility>\nclass Polygon {\npublic:\n  // ??¨???\n  void add(const Point& p);\n  void clear();\n  // ?????±\n  int size() const;\n  Point vertex(const int n) const;\n  Segment edge(const int n) const;\n  const std::vector<Point>& vertex() const;\n  const std::vector<Segment>& edge() const;\n  // ??????\n  bool touch(const Point& p) const;\n  bool intersect(const Point& p) const;\n  D area() const;\n  bool convex() const;\n  // ???????§???¢\n  const Polygon convex_hull() const;\n  D convex_diameter() const;\n  const Polygon convex_cut(const Line& l) const;\nprivate:\n  std::vector<Point> vertex_;\n  std::vector<Segment> edge_;\n};\n// ??¨???\nvoid Polygon::add(const Point& p) {\n  if(!vertex_.empty()) {\n    if(!edge_.empty()) edge_.pop_back();\n    edge_.push_back(Segment(vertex_.back(), p));\n    edge_.push_back(Segment(p, vertex_.front()));\n  }\n  vertex_.push_back(p);\n}\nvoid Polygon::clear() {\n  vertex_.clear();\n  edge_.clear();\n};\n// ?????±\nint Polygon::size() const {return vertex_.size();}\nPoint Polygon::vertex(const int n) const {return vertex_.at(n);}\nSegment Polygon::edge(const int n) const {return edge_.at(n);}\nconst std::vector<Point>& Polygon::vertex() const {return vertex_;}\nconst std::vector<Segment>& Polygon::edge() const {return edge_;}\n// ??????\nbool Polygon::touch(const Point& p) const {\n  return std::any_of(std::begin(edge()), std::end(edge()), [=](const Segment& s) {return ccw(s.initial, s.terminal, p) == ON_SEGMENT;});\n}\nbool Polygon::intersect(const Point& p) const {\n  bool in = false;                    // p=(x,y)??????(INF,y)???????????´?????¨????§???¢??¨????????????????????° mod 2\n  for(const auto& e: edge()) {\n    if(::intersect(p, e)) return true;\n    Point a = e.initial  - p;\n    Point b = e.terminal - p;\n    if(a.y > b.y) std::swap(a, b);\n    if(a.y < EPS && EPS <= b.y && cross(a, b) < EPS) in = !in;\n  }\n  return in;\n}\nD Polygon::area() const {\n  return std::abs(std::accumulate(std::begin(edge()), std::end(edge()), 0.0, [=](const D sum, const Segment& e){return sum + cross(e.initial, e.terminal);})) / 2.0;\n}\nbool Polygon::convex() const {\n  bool positive = false;\n  bool negative = false;\n  for(int i = 0; i < size(); ++i) {\n    auto position = ccw(vertex(i), vertex((i + 1) % size()), vertex((i + 2) % size()));\n    positive |= position == CLOCKWISE;\n    negative |= position == COUNTER_CLOCKWISE;\n    if(negative && positive) return false;\n  }\n  return true;\n}\n// ???????§???¢\n// Andrew's Monotone Chain: O(n log n)\nconst Polygon Polygon::convex_hull() const {\n  auto original = vertex();\n  std::sort(std::begin(original), std::end(original));\n  original.insert(std::end(original), original.rbegin() + 1, original.rend());\n  std::vector<Point> point;\n  for(const auto& p: original) {\n    while(point.size() >= 2 && ccw(point[point.size() - 2], point.back(), p) == CLOCKWISE) point.pop_back();\n    point.push_back(p);\n  }\n  Polygon convex_hull;\n  point.pop_back();\n  for(const auto& p: point) convex_hull.add(p);\n  return convex_hull;\n}\n// Rotating calipers: O(n)\nD Polygon::convex_diameter() const {\n  auto point = vertex();\n  int p, q, start_p, start_q, max_p, max_q;\n  p = start_p = max_p = std::min_element(std::begin(point), std::end(point)) - std::begin(point);\n  q = start_q = max_q = std::max_element(std::begin(point), std::end(point)) - std::begin(point);\n  D max_d = norm(vertex(p) - vertex(q));\n  do {\n    if(cross(vertex((p + 1) % size()) - vertex(p), vertex((q + 1) % size()) - vertex(q)) >= 0) q = (q + 1) % size();\n    else p = (p + 1) % size();\n    if(norm(vertex(p) - vertex(q)) > max_d) {\n      max_d = norm(vertex(p) - vertex(q));\n      max_p = p;\n      max_q = q;\n    }\n  } while(start_p != q || start_q != p);\n  return std::sqrt(max_d);\n}\nconst Polygon Polygon::convex_cut(const Line& l) const {\n  Polygon result;\n  for(const auto& e: edge()) {\n    if(ccw(l.initial, l.terminal, e.initial) == COUNTER_CLOCKWISE) result.add(e.initial);\n    if(::intersect(e, l)) result.add(crosspoint(e, l));\n  }\n  return result;\n}\n////////////////////////////////////////////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  Circle c;\n  cin >> c.center.x >> c.center.y >> c.radius;\n  int q;\n  cin >> q;\n  for(auto i = 0; i < q; ++i){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    auto cp = crosspoint(c, Line(x1, y1, x2, y2));\n    if(cp[0] > cp[1]) swap(cp[0], cp[1]);\n    cout << setprecision(8) << fixed << cp[0].x << \" \" << cp[0].y << \" \" << cp[1].x << \" \" << cp[1].y << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-6;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nusing Point = complex<double>;\nusing Polygon = vector<Point>;\n\ninline int sgn(const double &a) { return (a < -EPS ? -1 : (a > EPS ? 1 : 0)); }\n\ninline bool eq(const Point &a, const Point &b) { return abs(a - b) < EPS; }\n\nnamespace std {\ninline bool operator<(const Point &a, const Point &b) {\n    if (sgn(a.real() - b.real()))\n        return sgn(a.real() - b.real()) < 0;\n    return sgn(a.imag() - b.imag()) < 0;\n}\n} // namespace std\n\ndouble dot(const Point &a, const Point &b) { return real(conj(a) * b); }\n\ndouble det(const Point &a, const Point &b) { return imag(conj(a) * b); }\n\nstruct Line {\n    Point p1, p2;\n\n    Line(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\n    bool operator<(const Line &rhs) const {\n        if (eq(p2, rhs.p2))\n            return p1 < rhs.p1;\n        return p2 < rhs.p2;\n    }\n    bool operator==(const Line &rhs) const {\n        return (eq(p1, rhs.p1) && eq(p2, rhs.p2)) ||\n               (eq(p1, rhs.p2) && eq(p2, rhs.p1));\n    }\n};\n\ninline Point curr(const Polygon &p, const int &i) { return p[i % p.size()]; }\n\ninline Point next(const Polygon &p, const int &i) {\n    return p[(i + 1) % p.size()];\n}\n\ninline Point prev(const Polygon &p, const int &i) {\n    return p[(i + p.size() - 1) % p.size()];\n}\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle(Point p = Point(), double r = 0) : p(p), r(r) {}\n};\n\ndouble distanceLP(Line line, Point p) {\n    return abs(det(line.p2 - line.p1, p - line.p1)) / abs(line.p2 - line.p1);\n}\n\nPoint projection(Line line, Point p) {\n    Point a = line.p2 - line.p1, b = p - line.p1;\n    double r = dot(a, b) / norm(a);\n    return line.p1 + r * a;\n}\n\nvector<Point> intersection(Circle c, Line line) {\n    double d = distanceLP(line, c.p);\n    vector<Point> res;\n    if(sgn(d-c.r) > 0) return res;\n    Point p = projection(line, c.p);\n    if(eq(d, c.r)) {\n        res.push_back(p);\n        return res;\n    }\n    double len = sqrt(c.r*c.r - d*d);\n    Point e = (line.p1 - line.p2) / abs(line.p1 - line.p2);\n    res.push_back(p + len*e);\n    res.push_back(p + len*e*Point(-1, 0));\n    if(res[1] < res[0]) swap(res[0], res[1]);\n    return res;\n}\n\nint main(){\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n    Circle c(Point(cx, cy), r);\n    int q;\n    cin >> q;\n    for(int i=0;i<q;++i){\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line line(Point(x1, y1), Point(x2, y2));\n        auto v = intersection(c, line);\n        printf(\"%.10f %.10f \", v[0].real(), v[0].imag());\n        int idx = 1 % v.size();\n        printf(\"%.10f %.10f\\n\", v[idx].real(), v[idx].imag());\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\ndouble xmax, xmin, ymax, ymin;\nstruct vec{\n  double x, y;\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n  //double ppdist(vec p){ return sqrt( (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y) ); }\n  //double ppdist2(vec p){ return (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y); }\n};\nstruct line{\n  vec a, b;\n  vec getvec(){ return b - a; }\n  double size(){ return getvec().norm(); }\n  vec proj(vec p){ return a + (b - a).sca((p - a).dot(b - a) / (b - a).dot(b - a)); }\n  vec vref(vec p){ return proj(p).sca(2.0) - p; }\n  int ccw(vec p){\n    vec q = p - a, ba = b - a;\n    if(ba.cross(q) > 0)return 1; //ccw\n    if(ba.cross(q) < 0)return -1; //cw\n    if(ba.dot(q) < 0)return -2; //back\n    if(ba.dot(ba) < q.dot(q))return 2; //front\n    return 0; //on\n  }\n  bool paral(line l){ return abs(l.getvec().cross(getvec())) < eps; }\n  bool orth(line l){ return abs(l.getvec().dot(getvec())) < eps; }\n  bool intersec(line l){\n    bool res0 = (ccw(l.a) * ccw(l.b) == 4); //syukutai\n    bool res1 = (getvec().cross(l.a - a) * getvec().cross(l.b - a)) <= eps;\n    bool res2 = (l.getvec().cross(a - l.a) * l.getvec().cross(b - l.a)) <= eps;\n    return !res0 && res1 && res2;\n  }\n  vec crosspoint(line l){\n    return a + getvec().sca((l.a - a).cross(l.getvec()) / getvec().cross(l.getvec()));\n  }\n  double pldist(vec p){\n    double res = min((a - p).norm2(), (b - p).norm2());\n    vec h = proj(p);\n    if((a - h).dot(b - h) < 0)res = min(res, (h - p).norm2());\n    return sqrt(res);\n  }\n  double lldist(line l){\n    if(intersec(l))return 0.0;\n    return min(min(pldist(l.a), pldist(l.b)), min(l.pldist(a), l.pldist(b)));\n  }\n};\nstruct polygon{\n  vector<vec> p;  //ccw\n  double area(){\n    double res = 0.0;\n    for(int i = 0;i < p.size();++i)res += p[i].cross(p[(i + 1) % p.size()]);\n    return res / 2.0;\n  }\n  bool isconv(){\n    for(int i = 0;i < p.size();++i)\n    if((p[(i + 1) % p.size()] - p[i]).cross(p[(i + 2) % p.size()] - p[i]) < -eps)return false;\n    return true;\n  }\n  int isin(vec a){\n    line l = (line){a, a + (vec){xmax - xmin, 0.0}};\n    int cnt = 0, n = p.size();\n    for(int i = 0;i < n;++i){\n      line tmp = (line){p[i], p[(i + 1) % n]};\n      if(tmp.ccw(a) == 0)return 1; //on line\n      if(l.intersec(tmp)){\n        ++cnt;\n        if(l.ccw(p[i]) == 0 && l.ccw(p[(i + 1) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        if(l.paral(tmp)){\n          ++cnt;\n          if(l.ccw(p[(i + 2) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        }\n      }\n    }\n    return (cnt & 1) * 2;  //2:in 0:out\n  }\n};\n\nstruct circle{\n  vec o;\n  double r;\n  int intersec(circle c){\n    double d = (o - c.o).norm(), rp = r + c.r, rm = abs(r - c.r);\n    if(abs(rp - d) < eps)return 3;\n    if(rp < d + eps)return 4;\n    if(abs(rm - d) < eps)return 1;\n    if(rm < d + eps)return 2;\n    return 0;\n  }\n  pair<vec, vec> clpoint(line l){\n    pair<vec, vec> res;\n    vec h = l.proj(o);\n    double dist = (l.a - h).norm(), diff = sqrt(r * r - (o - h).norm2());\n    res.first = l.a + (l.b - l.a).sca((dist + diff) / l.size());\n    res.second = l.a + (l.b - l.a).sca((dist - diff) / l.size());\n    if(res.first.x + eps > res.second.x ||\n      (abs(res.first.x - res.second.x) < eps && res.first.y + eps > res.second.y))\n        swap(res.first, res.second);\n    return res;\n  }\n};\n\nsigned main(void){\n  int i, j, k, q;\n  circle c;\n  cin >> c.o.x >> c.o.y >> c.r >> q;\n  for(;q--;){\n    line l;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n    pair<vec, vec> res = c.clpoint(l);\n    printf(\"%.15lf %.15lf %.15lf %.15lf\\n\", res.X.x, res.X.y, res.Y.x, res.Y.y);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#define f first\n#define s second\n#define mp make_pair\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return (s1.p1+(s1.p2-s1.p1)*t);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nint main()\n{\n  Point A,B;\n  int q,a,b;\n  Circle C;\n\n  cin>>C.c.x>>C.c.y>>C.r;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>A.x>>A.y>>B.x>>B.y;\n    pair<Point,Point> PP=getCrossPoints(C,Line(A,B));\n    if((PP.s.x-PP.f.x)>eps)\n      printf(\"%.10f %.10f %.10f %.10f\\n\",PP.f.x,PP.f.y,PP.s.x,PP.s.y);\n    else if((PP.s.x-PP.f.x)<-eps)\n      printf(\"%.10f %.10f %.10f %.10f\\n\",PP.s.x,PP.s.y,PP.f.x,PP.f.y);\n    else {\n      if((PP.s.y-PP.f.y)<eps)\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\",PP.f.x,PP.f.y,PP.s.x,PP.s.y);\n      else \n\tprintf(\"%.10f %.10f %.10f %.10f\\n\",PP.s.x,PP.s.y,PP.f.x,PP.f.y);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <sstream>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-10;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nclass Point\n{\npublic:\n  double x,y;\n  Point(double x,double y): x(x),y(y){}\n  Point operator + (const Point &p)\n  {\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (const Point &p)\n  {\n    return Point(x-p.x,y-p.y);\n  }\n  Point operator * (double k)\n  {\n    return Point(x*k,y*k);\n  }\n  Point operator / (double k)\n  {\n    return Point(x/k,y/k);\n  }\n  bool operator < (const Point &p) const\n  {\n    return x!=p.x ? x<p.x : y<p.y;\n  }\n  bool operator == (const Point &p) const\n  {\n    return fabs(x-p.x)<eps && fabs(y-p.y) < eps;\n  }\n  double abs(){return sqrt(norm());}\n  double norm(){return x*x+y*y;}\n};\ntypedef Point Vector;\ndouble dot(Vector a,Vector b)\n{\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\ndouble norm(Point a)\n{\n  return a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a)\n{\n  return sqrt(norm(a));\n}\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1,Point p2): p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n  Point c;\n  double r;\n  Circle(Point c,double r):  c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\n\nbool isorthogonal(Vector a,Vector b)\n{\n  return fabs(dot(a,b)-0.0)<eps;\n}\n\nbool isparallel(Vector a,Vector b)\n{\n  return fabs(cross(a,b)-0.0)<eps;\n}\nPoint project(Segment s,Point p)\n{\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return  s.p1 + base*r;\n}\nPoint reflect(Segment s,Point p)\n{\n  return p+ (project(s,p)-p)*2.0;\n}\ndouble getdistance(Point a,Point b)\n{\n  return abs(a-b);\n}\ndouble getdistanceLP(Line l,Point p)\n{\n  return abs(cross(l.p2-l.p1,p-l.p1) / abs(l.p2-l.p1));\n}\ndouble getdistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) <0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) <0.0) return abs(p-s.p2);\n  return getdistanceLP(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps) return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps) return CLOCKWISE;\n  if(dot(a,b)<-eps) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1) * ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2)\n{\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n  Vector base =s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getdistanceSS(Segment s1,Segment s2)\n{\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getdistanceSP(s1,s2.p1),getdistanceSP(s1,s2.p2)),min(getdistanceSP(s2,s1.p1),getdistanceSP(s2,s1.p2)));\n}\n\npair<Point,Point> getcrosspoints(Circle c,Line l)\n{\n  //assert(intersect(c,l));\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r - norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\nint main(int argc,char const* argv[])\n{\n  double cx,cy,r;\n  cin >> cx >> cy >> r;\n  Point mid=Point(cx,cy);\n  Circle c=Circle(mid,r);\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++)\n    {\n      double p0x,p0y,p1x,p1y;\n      cin >> p0x >> p0y >> p1x >> p1y;\n      Point p0=Point(p0x,p0y);\n      Point p1=Point(p1x,p1y);\n      Line s=Segment(p0,p1);\n      pair<Point,Point> ans=getcrosspoints(c,s);\n      cout << fixed << setprecision(12) << ans.second.x << ' ' << ans.second.y << ' ' << ans.first.x << ' ' << ans.first.y << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\nstruct Point\n{\n    double x, y;\n    Point() {}\n    Point(double _x,double _y):x(_x),y(_y) {}\n    Point operator +(Point a)\n    {\n        return Point(x+a.x,y+a.y);\n    }\n    Point operator -(Point a)\n    {\n        return Point(x-a.x,y-a.y);\n    }\n    Point operator *(double d)\n    {\n        return Point(x*d,y*d);\n    }\n    Point operator /(double d)\n    {\n        return Point(x/d,y/d);\n    }\n\n};\ndouble dot(Point a,Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\ndouble norm(Point a)\n{\n    return a.x*a.x+a.y*a.y;\n}\ndouble abs(Point a)\n{\n    return sqrt(norm(a));\n}\n\nint n;\ndouble r;\nPoint p0,p1,p2,p3,p4;\nint ccw(Point p1,Point p2,Point p)\n{\n    Point a=p2-p1;\n    Point b=p-p1;\n    if(cross(a,b)<-EPS) return -1;\n    if(cross(a,b)>EPS) return 1;\n    if(dot(a,b)<-EPS) return -2;\n    if(norm(a)<norm(b)) return 2;\n    return 0;\n}\nvoid projection(Point p1,Point p2,Point p)\n{\n    Point p2p1=p2-p1;\n    Point pp1=p-p1;\n    double t=cross(p2p1,pp1);\n    double h2=t*t/norm(p2p1);\n    double d=sqrt(norm(pp1)-h2);\n\n    double m=sqrt(r*r-h2);\n    Point e=p2p1/abs(p2p1);\n    Point q=p1+e*d;\n    Point q1=q-e*m;\n    Point q2=q+e*m;\n    printf(\"%.8lf %.8lf %.8lf %.8lf\\n\",q1.x,q1.y,q2.x,q2.y);\n}\n\nbool is_insect(Point p1,Point p2,Point p3,Point p4)\n{\n    if(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0) return true;\n    return false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%lf%lf%lf\",&p0.x,&p0.y,&r);\n    scanf(\"%d\",&n);\n    while(n--)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p1.x,&p1.y,&p2.x,&p2.y);\n        projection(p1,p2,p0);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-9; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\n// VP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// // cross point between circles Verify AOJ CGL_7_E\n// VP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n/*\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}*/\n\nVP pcl(C c, L l) {\n    P h=proj(l,c.c);\n    P e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n    return VP{h-e,h+e};\n}\nVP pcc(C a,C b){\n    P d=b.c-a.c;\n    P w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n    P e=w*P(0,1);\n    return pcl(a,{w-e,w+e}); \n}\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-9;\n\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nVP crosspointLC(Point a1, Point a2, Point c, double r) {\n  VP ps;\n  Point ft = proj(a1, a2, c);\n  if(!GE(r*r,norm(ft-c))) assert(false);\n  assert(r*r >= norm(ft-c));\n  Point dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  ps.push_back(ft - dir);\n  return ps;\n}\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nint main(void){\n    double cx,cy,r;\n    int q;\n    cin>>cx>>cy>>r>>q;\n    rep(i,q){\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        VP ps = crosspointLC(Point(x1,y1),Point(x2,y2),Point(cx,cy),r);\n        sort(all(ps));\n        printf(\"%.9f %.9f \" ,ps[0].X,ps[0].Y);\n        printf(\"%.9f %.9f\\n\",ps[1].X,ps[1].Y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\tcout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tdouble base = sqrt(r * r - pr.norm());\n\n\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * base;\n\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * base;\n\tif (ans1.x < ans2.x) {\n\t\treturn make_pair(ans1, ans2);\n\t} else {\n\t\treturn make_pair(ans2, ans1);\n\t}\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#define EPS 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cassert>\nusing namespace std;\n\n// definition of turning\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\npublic:\n  double x, y;\n  Point (double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) {return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) {return Point(x - p.x, y - p.y); }\n  Point operator * (double a) {return Point(a * x, a * y); }\n  Point operator / (double a) {return Point(x / a, y / a); }\n\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator < (const Point &p) const\n  {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const\n  {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment\n{\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n  Segment(double x1, double y1, double x2, double y2)\n  {\n    p1 = Point(x1, y1);\n    p2 = Point(x2, y2);\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\n// dot and cross product\ndouble dot(Vector a, Vector b)\n{\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b)\n{\n  return a.x * b.y - a.y * b.x;\n}\n\n// orthogonality\nbool isOrthagonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\n\nbool isOrthagonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthagonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthagonal(Segment s1, Segment s2)\n{\n  return isOrthagonal(s1.p1 - s1.p2, s2.p1 - s2.p2);\n}\n\n// parallelism\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n  return isParallel(s1.p1 - s1.p2, s2.p1 - s2.p2);\n}\n\n// projection & reflection\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\n\n// distance\ndouble getDistance(Point a, Point b)\n{\n  return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p1 - l.p2, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n  if (dot(p - s.p1, s.p2 - s.p1) < 0) return getDistance(p, s.p1);\n  if (dot(p - s.p2, s.p1 - s.p2) < 0) return getDistance(p, s.p2);\n  return getDistanceLP(s, p);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\ndouble getDistanceSS(Segment s1, Segment s2)\n{\n  if (intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), \\\n            min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n//ccw\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// intersection\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \\\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// Cross point\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n// Cross points of a circle and a line\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  double base = sqrt(c.r * c.r - (pr - c.c).norm());\n  return make_pair(pr + e * base, pr - e * base);\n}\n\nint main()\n{\n  Circle c;\n  scanf(\"%lf%lf%lf\", &c.c.x, &c.c.y, &c.r);\n  int q;\n  scanf(\"%d\", &q);\n  while (q--)\n  {\n    Line l;\n    scanf(\"%lf%lf%lf%lf\", &l.p1.x, &l.p1.y, &l.p2.x, &l.p2.y);\n    Point cp1 = getCrossPoints(c, l).first;\n    Point cp2 = getCrossPoints(c, l).second;\n    if (cp2 < cp1)\n    {\n      Point temp = cp1;\n      cp1 = cp2;\n      cp2 = temp;\n    }\n    printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", cp1.x, cp1.y, cp2.x, cp2.y);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\ndouble getDistanceLP(Line, Point);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q;\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\n\t\tif (ans.first.x < ans.second.x) {\n\t\t\tans.first.show();\n\t\t\tcout << \" \";\n\t\t\tans.second.show();\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tif (equals(ans.first.x - ans.second.x, 0.0)) {\n\t\t\t\tif (ans.first.y < ans.second.y) {\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}else{\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n\n// Circle // verified: AOJ 1183 \nenum RCC{OUT=2,ON_OUT=1,ISC=0,ON_IN=-1,IN=-2};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\n\n// cross point between circle and line \n// verified: AOJ CGL_7_D\nP cir(C c,R t){return c.c+polar(c.r,t);}\nVP cross(C c, L l){\n\tP h=proj(l,c.c),e=polar(sq(norm(c.r)-norm(h-c.c)),arg(l.t-l.s));\n\treturn VP{h-e,h+e};\n}\n\nint main(void){\n\tint q;\n\tC c;\n\tcin >> c.c >> c.r;\n\t\t\n\tcin >> q;\n\tcout.precision(20);\n\trep(i,q){\n\t\tP a,b;\n\t\tcin >> a >> b;\n\t\tL l={a,b};\n\t\tVP res=cross(c,l);\n\t\tif(sgn(real(res[0])-real(res[1])>0)) swap(res[0],res[1]);\n\t\tif(sgn(real(res[0])-real(res[1]))==0 and sgn(imag(res[0])-imag(res[1]))>0) swap(res[0],res[1]);\n\t\tcout << fixed << res[0] << \" \" << res[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\n// VP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// // cross point between circles Verify AOJ CGL_7_E\n// VP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n/*\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}*/\n\nVP pcl(C c, L l) {\n    P h=proj(l,c.c);\n    P e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n    return VP{h-e,h+e};\n}\nVP pcc(C a,C b){\n    P d=b.c-a.c;\n    P w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n    P e=w*P(0,1);\n    return pcl(a,{w-e,w+e}); \n}\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <math.h>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double _x = 0., double _y = 0.) : x(_x), y(_y) {}\n};\n\nistream& operator >> (istream& in, Point& P)\n{\n    in >> P.x >> P.y;\n    return in;\n}\n\nostream& operator << (ostream& out, const Point& P)\n{\n    out << P.x << \" \" << P.y;\n    return out;\n}\n\ndouble Dist(const Point& P, const Point& Q)\n{\n    double dx = P.x - Q.x;\n    double dy = P.y - Q.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(const Point& _c = Point(), double _r = 0.) : c(_c), r(_r) {}\n};\n\nistream& operator >> (istream& in, Circle& C)\n{\n    in >> C.c >> C.r;\n    return in;\n}\n\nint CircStatus(const Circle& C1, const Circle& C2)\n{\n    double d = Dist(C1.c, C2.c);\n    if (d > C1.r + C2.r + eps) {\n        return 4;\n    } else if (d > C1.r + C2.r -eps) {\n        return 3;\n    } else if (d > fabs(C1.r - C2.r) + eps) {\n        return 2;\n    } else if (d > fabs(C1.r - C2.r) - eps) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nclass Vector {\npublic:\n    double x, y;\n    Vector(double _x = 0., double _y = 0.) : x(_x), y(_y) {}\n    Vector(const Point& P) : x(P.x), y(P.y) {}\n    Vector(const Point& St, const Point& End) : x(End.x - St.x), y(End.y - St.y) {}\n    inline double InnerProd(const Vector& V)\n    {\n        return x * V.x + y * V.y;\n    }\n    inline double OuterProd(const Vector& V)\n    {\n        return x * V.y - y * V.x;\n    }\n    inline double Length()\n    {\n        return sqrt((*this).InnerProd(*this));\n    }\n};\n\nVector operator+(const Vector& V1, const Vector& V2)\n{\n    return Vector(V1.x + V2.x, V1.y + V2.y);\n}\n\nVector operator*(double d, const Vector& V)\n{\n    return Vector(d * V.x, d * V.y);\n}\n\nVector operator/(const Vector&V, double d)\n{\n    return Vector(V.x / d, V.y / d);\n}\n\nbool operator<(const Vector& V1, const Vector& V2)\n{\n    return V1.x < V2.x || (V1.x == V2.x && V1.y < V2.y);\n}\n\nostream& operator<<(ostream& out, const Vector V)\n{\n    out << V.x << \" \" << V.y;\n    return out;\n}\n\nvoid PrintCross(const Circle& C, const Point& St, const Point& End)\n{\n    Vector LineVec(St, End);\n    Vector LineUnitVec = LineVec / LineVec.Length();\n    Vector RefVec(St, C.c);\n    double ParaDist = LineUnitVec.InnerProd(RefVec);\n    double PerpDist = fabs(LineUnitVec.OuterProd(RefVec));\n    double ParaDistDiff = sqrt(C.r * C.r - PerpDist * PerpDist);\n    Vector Res1 = St + (ParaDist - ParaDistDiff) * LineUnitVec;\n    Vector Res2 = St + (ParaDist + ParaDistDiff) * LineUnitVec;\n    if (Res2 < Res1) {\n        swap(Res1, Res2);\n    }\n    cout << Res1 << \" \" << Res2 << endl;\n}\n\nint main()\n{\n    Circle C;\n    cin >> C;\n    int q;\n    cin >> q;\n    Point St, End;\n    cout << fixed << setprecision(10);\n    for (int i = 0; i < q; ++i) {\n        cin >> St >> End;\n        PrintCross(C, St, End);\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;   // 許容誤差。問題によって変える\ntypedef complex<double> P; // Point\n//点の座標は複素数で持つ\n#define X real()\n#define Y imag()\n\nnamespace std{\nbool operator<(const P p1, const P p2)\n{\n    return p1.X != p2.X ? p1.X < p2.X : p1.Y < p2.Y;\n}\nP operator+(const P p1, const P p2) { return P(p1.X + p2.X, p1.Y + p2.Y); }\nP operator-(const P p1, const P p2) { return P(p1.X - p2.X, p1.Y - p2.Y); }\nP operator*(const P p, double k) { return P(p.X * k, p.Y * k); }\nP operator/(const P p, double k) { return P(p.X / k, p.Y / k); }\n} // namespace std\n//ここまで写経必須\n\n//Segment/L\nstruct Segment{\n    P p1, p2;\n    Segment() {}\n    Segment(P p1, P p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment L;\n\n//Circle\nstruct Circle{\n    P p;\n    double r;\n    Circle(const P &p, double r) : p(p), r(r) {}\n};\ntypedef Circle C;\n\ntypedef vector<P> G;\n//ノルム\n//二点a,bを投げるとノルム(a1-b1)^2+(a2-b2)^2を返す\ndouble norm(P &p1, P &p2){\n    return (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);\n}\n\n//外積cross(a,b) = |a||b|sinθ=a1b2-a2b1\n//二点a,bを投げると外積を返す\ndouble cross(const P &a, const P &b){\n    return (conj(a) * b).Y;\n}\n\n//内積dot(a,b) = |a||b|cosθ=a1b1+a2b2\n//二点a,bを投げると内積を返す\ndouble dot(const P &a, const P &b){\n    return (conj(a) * b).X;\n}\n\n//射影\n//L(又はS)と点Pを投げるとLへPを射影した座標を返す\n//依存:dot,norm\nP Projection(L l, P p){\n    P base = l.p2 - l.p1;                        //始点\n    double r = dot(p - l.p1, base) / norm(base); //線分に対する倍率の計算\n    return l.p1 + base * r;\n}\n\n//鏡映\n//L(又はS)と点Pを投げるとLを軸としたPの鏡像座標を返す\n//依存:Projection,dot,norm\nP Reflection(L l, P p){\n    return p + (Projection(l, p) - p) * 2.0;\n}\n\n//位置関係判定(線分abを軸にcがどちら側にあるか)\n//三点a,b,cを投げることで，a-bを軸として\n//時計回りの場合:1,反時計回りの場合:-1,c-a-bの並び:2,a-b-cの並び:-2\n//その他（重なってる等）:0\n//依存:cross,dot,norm\nint ccw(P a, P b, P c)\n{\n    b -= a;\n    c -= a; //aからの向きを考える\n    if (cross(b, c) > EPS)\n        return +1; //clockwise\n    else if (cross(b, c) < -EPS)\n        return -1; //counter clockwise\n    else if (dot(b, c) < -EPS)\n        return +2; //c-a-b\n    else if (norm(b) < norm(c))\n        return -2; //a-b-c\n    else\n        return 0; //他\n}\n\n//Intersection Determination\n//L,S,Pそれぞれのペアの交差判定，PPは直接比較できるのでないです\n//それぞれのペアを投げる,引数の順番は関数名に記載\n//交差又は含まれている場合true,そうでない場合falseを返す\n\n//依存:cross\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l.p2 - l.p1, m.p2 - m.p1)) > EPS || // non-parallel\n           abs(cross(l.p2 - l.p1, m.p1 - l.p1)) < EPS;   // same L\n}\n//依存:cross\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l.p2 - l.p1, s.p1 - l.p1) * // s.p1 is left of l\n               cross(l.p2 - l.p1, s.p2 - l.p1) <\n           EPS; // s.p2 is right of l\n}\n//依存:cross\nbool intersectLP(const L &l, const P &p)\n{\n    return abs(cross(l.p2 - p, l.p1 - p)) < EPS;\n}\n//依存:ccw,cross,dot,norm\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s.p1, s.p2, t.p1) * ccw(s.p1, s.p2, t.p2) <= 0 &&\n           ccw(t.p1, t.p2, s.p1) * ccw(t.p1, t.p2, s.p2) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p)\n{\n    return abs(s.p1 - p) + abs(s.p2 - p) - abs(s.p2 - s.p1) < EPS; // triangle inequality\n}\n\n//distance\n//L,S,Pについてペアを投げるとその距離を計算\n//引数の順番は関数名参照\n\n//依存:Projection,dot,norm\ndouble distanceLP(const L &l, const P &p)\n{\n    return abs(p - Projection(l, p));\n}\n//依存:intersectLL,cross,distanceLP,Projection,dot,norm\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n//依存:intersectLS,cross,distanceLP,Projection,dot,norm\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s))\n        return 0;\n    return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n//依存:intersectSP,Projection,dot,norm\ndouble distanceSP(const L &s, const P &p)\n{\n    const P r = Projection(s, p);\n    if (intersectSP(s, r))\n        return abs(r - p);\n    return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n//依存:intersectSS,ccw,cross,dot,norm,distanceSP,intersectSP,Projection\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t))\n        return 0;\n    return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n               min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\ndouble distancePP(const P &p1, const P &p2)\n{\n    return abs(p1 - p2);\n}\n//二本のL(又はS)を投げると交点座標を返す\n//一致している場合は一本目のp1を返します\n//交わっていない場合はfalseを返します\n//依存:cross\nP crosspoint(const L &l, const L &m)\n{\n    double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n    double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return l.p1; // same line\n    if (abs(A) < EPS)\n        assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m.p1 + B / A * (m.p2 - m.p1);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i + 1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\ndouble ConvDia(const G &g)\n{\n    const int n = g.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; i++)\n    {\n        if (imag(g[i]) > imag(g[is])) //点対はy座標の大きいものと小さいもののセット\n            is = i;\n        if (imag(g[i]) < imag(g[js]))\n            js = i;\n    }\n    double ans = abs(g[is] - g[js]);\n    int i = is, maxi = is, j = js, maxj = js;\n    do\n    {\n        if (cross(diff(g, i), diff(g, j)) >= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n        if (abs(g[i] - g[j]) > ans)\n        {\n            ans = abs(g[i] - g[j]);\n            maxi = i;\n            maxj = j;\n        }\n    }while (i != is or j != js);\n    return ans;\n}\ndouble area(const G &g){\n    double ans = 0;\n    for (int i = 0; i < g.size(); i++)\n        ans += cross(g[i], g[(i + 1) % g.size()]);\n    return abs(ans / 2);\n}\n//円に関するもの置き場\n\n//円と直線の交点\n//円と直線を投げるとその交点二つを返す\n//依存:Projection,diatanceLP\nvector<P> crosspointCL(const C &c, const L &l)\n{\n    vector<P> res;\n    double d = distanceLP(l, c.p); // 中心と直線の距離\n    if (abs(d - c.r) < EPS)\n    { // 触れている\n        res.push_back(Projection(l, c.p));\n        return res;\n    }\n    if (d > c.r)\n        return res; // 離れている\n    P h = Projection(l, c.p);\n    P u = sqrt(c.r * c.r - d * d) * (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    res.push_back(h + u);\n    res.push_back(h - u);\n    return res;\n}\n\n//円と円の交差判定\n//円を二つ投げると値を返します\n//離れている:0 外接:-2 c1＞c2内接:-1 c2>c1内接:1 c1inc2:3 c2inc1:-3 交点二つ:2\nint intersectCC(const C &c1, const C &c2)\n{\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if (r1 + r2 < d)\n        return 0; // 離れている\n    if (abs(r1 + r2 - d) < EPS)\n        return -2; // 外接\n    if (abs(d + r1 - r2) < EPS)\n        return +1; // c1 が c2 の中で内接\n    if (abs(d + r2 - r1) < EPS)\n        return -1; // c2 が c1 の中で内接\n    if (d + r1 < r2)\n        return +3; // c1 が c2 の中\n    if (d + r2 < r1)\n        return -3; // c2 が c1 の中\n    return 2;      // 2つの交点を持つ\n}\n\n//円と円の交点\n//円を二つ投げると交点が入ったvectorを返す\n//交点なしor一致の場合空で返す\nvector<P> crosspointCC(const C &c1, const C &c2){\n    vector<P> res;\n    double r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    if (d<EPS)\n        return res; // 中心が同じ\n    int i = intersectCC(c1, c2);\n    if (i == +1 || i == -1)\n    { // 内接\n        if (r2 < r1)\n            res.push_back(c1.p + r1 / d * (c2.p - c1.p));\n        else\n            res.push_back(c2.p + r2 / d * (c1.p - c2.p));\n        return res;\n    }if (i == -2){ // 外接\n        res.push_back((c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r));\n        return res;\n    }if (i == 0 || i == +3 || i == -3){ // 共通部分なし || 内部\n        return res;\n    }\n    // 2つの交点を持つ\n    P p = c1.p - c2.p;\n    double A = -2. * p.real(), B = 2 * p.imag(),x;\n    double C = norm(c1.p) - norm(c2.p) - r1 * r1 + r2 * r2;\n    L l;\n    if (abs(A) < EPS)\n    {\n        l = L(P(0, -C / B), P(1, -C / B));\n        x = 1;\n    }\n    else if (abs(B) < EPS)\n    {\n        l = L(P(-C / A, 0), P(-C / A, 1));\n        x = 2;\n    }\n    else\n    {\n        l = L(P(0, -C / B), P(-C / A, 0));\n        x = 3;\n    }\n    cout << x << endl;\n    return crosspointCL(c1,l); // Ax + By + C = 0\n}\nint main(){\n    double x1,y1,r1;\n    cin>>x1>>y1>>r1;\n    C c = C(P(x1, y1), r1);\n    //vector<P> ans = crosspointCC(c1, c2);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n;i++){\n        double x1, x2, y1, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        L l = L(P(x1, y1), P(x2, y2));\n        vector<P> ans = crosspointCL(c, l);\n        if (ans.size() == 2)\n        {\n            if (ans[0] < ans[1])\n            {\n                printf(\"%.16f %.16f %.16f %.16f\\n\", ans[0].X, ans[0].Y, ans[1].X, ans[1].Y);\n            }\n            else\n            {\n                printf(\"%.16f %.16f %.16f %.16f\\n\", ans[1].X, ans[1].Y, ans[0].X, ans[0].Y);\n            }\n        }\n        else\n        {\n            printf(\"%.16f %.16f %.16f %.16f\\n\", ans[0].X, ans[0].Y, ans[0].X, ans[0].Y);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> Point, Vector;\ntypedef pair<Point, Point> Segment, Line;\ntypedef vector<Point> Polygon;\ntypedef pair<Point, double> Circle;\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nnamespace std{\n    bool operator<(const Point &a, const Point &b){\n        return !equals(a.X, b.X) ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\ndouble norm(Vector a){\n    return a.X * a.X + a.Y * a.Y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.X * b.X + a.Y * b.Y;\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.second - s.first;\n    double r = dot(p - s.first, base) / norm(base);\n    return s.first + base * r;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.first);\n    Vector e = (l.second - l.first) / abs(l.second - l.first);\n    double base = sqrt(c.second * c.second - norm(pr - c.first));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint main(){\n    double cx, cy, r; cin>>cx>>cy>>r;\n    Circle c1 = {Point(cx, cy), r};\n    int q; cin>>q;\n    while(q--){\n        double x1, y1, x2, y2; cin>>x1>>y1>>x2>>y2;\n        Line l1 = {Point(x1, y1), Point(x2, y2)};\n        pair<Point, Point> ansp = getCrossPoints(c1, l1);\n        Point p1 = min(ansp.first, ansp.second);\n        Point p2 = max(ansp.first, ansp.second);\n        printf(\"%.10f %.10f %.10f %.10f\\n\", p1.X, p1.Y, p2.X, p2.Y);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n\n//平面幾何\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n\n//宣言\n//--------------------------------------------\n\n//long double or double\ntypedef double Real;\n\n//ポイントクラス\ntypedef complex<Real> Point;\n\n//線分クラス\ntypedef pair<Point, Point> Line;\n\n//円\ntypedef pair<Point, Real> Circle;\n\n//ポリゴン\ntypedef vector<Point> Poly;\n\n\n//x座標優先で比較する\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n}\n\n\n//doubleの誤差\n#define EPS (1e-4)\n//double同士の比較\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n//Pointの比較\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n//角度\n//--------------------------------------------\nReal toRadian(double degree) {\n    return degree * PI / 180.0;\n}\n\nReal toDegree(double radian) {\n    return radian * 180.0 / PI;\n}\n\n\n\n\n\n\n\n//内積・外積・単位・法線\n//--------------------------------------------\n\n//ベクトルpの向きの単位ベクトルを返す\nPoint unit_vector(Point p) {\n    return p / abs(p);\n}\n\n\n//pの法線ベクトルを両方返す\npair<Point, Point> norm_vectors(Point p) {\n    return make_pair(p * Point(0, 1), p * Point(0, -1));\n}\n\n//ベクトルを反時計に回す sはラジアン\nPoint rotate_vector(Point v, double s) {\n    return Point(v.real() * cos(s) - v.imag() * sin(s), v.real() * sin(s) + v.imag() * cos(s));\n}\n\n//内積 a・b = |a||b|cosθ\ninline double dot(const Point &a, const Point &b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積 a×b = |a||b|sinθ\ninline double cross(const Point &a, const Point &b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n//三角形　角度・面積\n//--------------------------------------------\n//3点a, b, cのおける、角bacを返す\nReal args_bac(Point a, Point b, Point c) {\n    return acos(dot(b - a, c - a) / (abs(b - a) * abs(c - a)));\n}\n\n//各辺の長さがa, b, cの三角形の、aの対角の角度を返す\nReal args_bac(Real a, Real b, Real c) {\n    return acos((b * b + c * c - a * a) / (2 * b * c));\n}\n\n//三角形の面積\nReal heron_area(Real a, Real b, Real c) {\n    Real s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n//Real heron_area(Point a, Point b, Point c) {\n//    b -= a;\n//    c -= a;\n//    return (cross(b, c) / 2.0);\n//}\n\n//三角形の重心\nPoint centerOfGravity(Point a, Point b, Point c) {\n    return Point((a.real() + b.real() + c.real()) / 3.0, (a.imag() + b.imag() + c.imag()) / 3.0);\n}\n\n//三角形の外接円の半径\nReal circumScribedCircleRadius(Point a, Point b, Point c) {\n    Real edgeA = abs(b - c);\n    Real angleA = args_bac(a, b, c);\n    return (edgeA / sin(angleA) / 2.0);\n}\n\n//三角形の外接円の中心座標　外心\nPoint circumScribedCircleXY(Point a, Point b, Point c) {\n    Real angleA = args_bac(a, b, c);\n    Real angleB = args_bac(b, a, c);\n    Real angleC = args_bac(c, a, b);\n    Real A = sin(2.0 * angleA);\n    Real B = sin(2.0 * angleB);\n    Real C = sin(2.0 * angleC);\n    Point point((a.real() * A + b.real() * B + c.real() * C) / (A + B + C),\n                (a.imag() * A + b.imag() * B + c.imag() * C) / (A + B + C));\n    return point;\n}\n\n//三角形が点Pを含むか\nbool point_in_triangle(Point a, Point b, Point c, Point p) {\n    Point ab = b - a;\n    Point bp = p - b;\n\n    Point bc = c - b;\n    Point cp = p - c;\n\n    Point ca = a - c;\n    Point ap = p - a;\n\n    Real c1 = cross(ab, bp);\n    Real c2 = cross(bc, cp);\n    Real c3 = cross(ca, ap);\n\n    //内側\n    if ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0)) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\n\n//直線・線分\n//--------------------------------------------\n\n//頂点a, b, cの位置関係判定\n//別名ccw couter-clock-wise\nint points_relation(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return 1; //counter-clockwise\n    if (cross(b, c) < -EPS) return -1; //clockwise\n    if (dot(b, c) < -EPS) return 2; //c--a--b on line\n    if (abs(b) < abs(c)) return -2; //a--b--c on line\n    return 0; //on segment\n}\n\n//2直線の直行判定 Point版\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の直行判定 Line版\nbool is_orthogonal(Line line1, Line line2) {\n    return EQ(dot(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//2直線の平行判定 Point版\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の平行判定 Line版\nbool is_parallel(Line line1, Line line2) {\n    return EQ(cross(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//点cが**直線**a-b上にあるか\nbool is_point_on_long_line(Point a, Point b, Point c) {\n    return EQ(cross(b - a, c - a), 0.0);\n}\n\n//点cが**線分**a-b上にあるか\nbool is_point_on_line(Point a, Point b, Point c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//点a, bを通る**直線**と,点cとの距離d\ndouble distance_longline_point(Point a, Point b, Point c) {\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//直線と点との距離　円用\nReal line_dis(Line a, Point x) {\n    return abs(cross(a.second - a.first, x - a.first)) / abs(a.second - a.first);\n}\n\n//点a, bを端点とする**線分**と、点cとの距離d\nReal distance_line_point(Point a, Point b, Point c) {\n    if (dot(b - a, c - a) < EPS) return abs(c - a);\n    if (dot(a - b, c - b) < EPS) return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交差判定\nbool is_intersected_lines(Point a1, Point a2, Point b1, Point b2) {\n    return (points_relation(a1, a2, b1) * points_relation(a1, a2, b2) <= 0 &&\n            points_relation(b1, b2, a1) * points_relation(b1, b2, a2) <= 0);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の距離\nReal distance_line_line(Point a1, Point a2, Point b1, Point b2) {\n    if (is_intersected_lines(a1, a2, b1, b2)) {\n        return 0;\n    } else {\n        return min({\n                           distance_line_point(a1, a2, b1),\n                           distance_line_point(a1, a2, b2),\n                           distance_line_point(b1, b2, a1),\n                           distance_line_point(b1, b2, a2)\n                   });\n    }\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交点\nPoint intersection_lines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point b = b2 - b1;\n    double d1 = abs(cross(b, a1 - b1));\n    double d2 = abs(cross(b, a2 - b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2 - a1) * Point(t, 0);\n}\n\n//点a1, a2を通る直線と点b1, b2を通る直線の交点計算\nPoint intersection_longlines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1;\n    Point b = b2 - b1;\n    return a1 + a * Point(cross(b, b1 - a1), 0) / Point(cross(b, a), 0);\n}\n\n\n//直線a-bに点pから垂線をおろしたときの交点\nPoint projection_point(Point a, Point b, Point p) {\n    Real t = dot(p - a, a - b) / (abs(a - b) * abs(a - b));\n    return a + (a - b) * t;\n}\n\n//点pを線対称移動させる\nPoint reflection_point(Point a, Point b, Point p) {\n    return p + (projection_point(a, b, p) - p) * (Real) 2.0;\n}\n\n\n//多角形\n//--------------------------------------------\n\n//面積を返す 反時計回りに整列させておく\n//正なら反時計回り　負なら時計回り\nReal poly_area(Poly p) {\n    if (p.size() < 3)return 0;\n    Real res = cross(p[p.size() - 1], p[0]);\n    for (int i = 1; i < p.size(); i++) {\n        res += cross(p[i - 1], p[i]);\n    }\n    return abs(res) / 2;\n}\n\n//凸多角形か判定する\n//凸出ない場合、各辺から次の辺までの\n//時計回り・反時計回りに反対のものが出てくる\nbool is_convec_poly(Poly p) {\n    if (p.size() < 3) {\n        return false;\n    }\n\n    //sはstartのs　最初の回り方を保存する\n    int s = -3;\n    for (int i = 0; i < p.size(); i++) {\n        //2辺隣接した辺を選ぶ\n        int r = points_relation(p[i], p[(i != 0 ? i - 1 : p.size() - 1)], p[(i + 1 != p.size() ? i + 1 : 0)]);\n\n        //外積が1 時計回りか反時計なら更新\n        if (abs(r) == 1 && s == -3) s = r;\n\n        //sとrの積が-1なら異なる回り方が出てきている\n        //すべて時計回りなら-1*-1=1 反時計なら1*1=1\n        if (s * r == -1) return false;\n    }\n    return true;\n}\n\n//最遠点対　凸多角形で最も長い距離を返す\n//凸包の後に使うとよい\nReal longest_points_distance(Poly p) {\n    int n = p.size();\n    if (n == 2) {\n        return abs(p[0] - p[1]);\n    }\n\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n        if (!(p[i] < p[k])) i = k;\n        if (p[j] < p[k]) j = k;\n    }\n\n    Real res = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(p[i] - p[j]));\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n\n    return res;\n}\n\n//凸包\nvector<Point> convex_hull(vector<Point> v) {\n    int n = v.size(), k = 0;\n    sort(v.begin(), v.end());\n    vector<Point> r(2 * n);\n    for (int i = 0; i < n; i++) {\n        while (k > 1 && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        while (k > t && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    r.resize(k - 1);\n    return r;\n}\n\n//多角形をLine lで分割した際の左側の集合を返す\nPoint getcrosspointll(Line l1, Line l2) {\n    double c1 = cross(l1.first, l1.second), c2 = cross(l2.first, l2.second);\n    double de = (l1.first.imag() - l1.second.imag()) * (l2.first.real() - l2.second.real()) -\n                (l2.first.imag() - l2.second.imag()) * (l1.first.real() - l1.second.real());\n    double x = (l2.second.real() - l2.first.real()) * c1 + (l1.first.real() - l1.second.real()) * c2;\n    double y = (l2.second.imag() - l2.first.imag()) * c1 + (l1.first.imag() - l1.second.imag()) * c2;\n    return Point(x / de, y / de);\n}\n\nPoly convexcut(Poly p, Line l) {\n    int n = p.size();\n    Poly q;\n\n    for (int i = 0; i < n; i++) {\n        if (points_relation(l.first, l.second, p[i]) != -1)q.push_back(p[i]);\n        if (points_relation(l.first, l.second, p[i]) * points_relation(l.first, l.second, p[(i + 1) % n]) < 0.0) {\n            if (!is_parallel(l, Line(p[i], p[(i + 1) % n]))) {\n                q.push_back(getcrosspointll(l, Line(p[i], p[(i + 1) % n])));\n            }\n        }\n    }\n    return q;\n}\n\n//頂点pが多角形pの内外か判定する\n//2･･･in 1･･･on 0･･･out\nint point_in_poly(Poly v, Point p) {\n    bool in = false;\n    for (int i = 0; i < v.size(); ++i) {\n        Point a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n    }\n    return in ? 2 : 0;\n}\n\n\n\n//円 第一引数は中点　第二引数は半径\n//--------------------------------------------\n\n//円の面積\nReal circle_area(Circle c) {\n    return PI * c.second * c.second;\n}\n\n//円の中に点xが内部にあるか\nbool circle_in_x(Circle c, Point x) {\n    return (abs(x - c.first) + EPS < c.second);\n}\n\n//円状に点xがあるか\nbool circle_on_x(Circle c, Point x) {\n    return EQ(abs(x - c.first), c.second);\n}\n\n//2つの円a, bの関係\nint circle_relation(Circle a, Circle b) {\n    double d = abs(a.first - b.first);\n\n    if (a.second + b.second + EPS < d) return -1; //no cross point outside\n    if (b.second + d + EPS < a.second) return 1; //no cross point(inside B in A)\n    if (a.second + d + EPS < b.second) return 2; //no cross point(inside A in B)\n\n    if (abs(a.second + b.second - d) < EPS) return -3; //one cross point(outside)\n    if (abs(b.second + d - a.second) < EPS) return 3; //one cross point(inside B in A)\n    if (abs(a.second + d - b.second) < EPS) return 4; //one cross point(inside A in B)\n\n    return 0; //two cross point\n}\n\n//2円a, bの共通面積\nReal intersection_area(Circle a, Circle b) {\n    Real d = abs(a.first - b.first);\n\n    if (a.second + b.second < d + EPS) return 0;\n\n    //円aを半径が大きい方にする\n    if (a.second < b.second) swap(a, b);\n\n    //円bが円aに入ってたら\n    if (b.second + d < a.second + EPS || b.second < EPS) return circle_area(b);\n\n    Real t1 = args_bac(b.second, a.second, d);\n    Real t2 = args_bac(a.second, b.second, d);\n    Real tri = (a.second * a.second * sin(t1 * 2) + b.second * b.second * sin(t2 * 2)) / 2.0;\n    return a.second * a.second * t1 + b.second * b.second * t2 - tri;\n}\n\n//2つの円の交点を返す\nvector<Point> circle_inter_points(Circle a, Circle b) {\n    vector<Point> v;\n    int pos = circle_relation(a, b);\n    if (pos == 0) {\n        Real s = args_bac(b.second, abs(b.first - a.first), a.second);\n        Point x = a.second * unit_vector(b.first - a.first);\n        v.push_back(a.first + rotate_vector(x, s));\n        v.push_back(a.first + rotate_vector(x, -s));\n    } else if (abs(pos) >= 3) {\n        v.push_back(a.first + a.second * unit_vector(b.first - a.first));\n    }\n    return v;\n}\n\n//円と直線の交点\nvector<Point> circle_inter_line_points(Circle a, Line l) {\n//    vector<Point> v;\n//    Real d = line_dis(l, a.first);\n//    if (d < a.second + EPS) {\n//        Point x = a.second * unit_vector(l.second - l.first);\n//        if (points_relation(l.first, l.second, a.first) == 1) x = a.first + x * Point(0, -1);\n//        else x = a.first + x * Point(0, 1);\n//        if (d + EPS < a.second) {\n//            Real y = sqrt(a.second * a.second - d * d);\n//            if (d == 0) d += EPS;\n//            Real s = args_bac(y, d, a.second);\n//            v.push_back(rotate_vector(x, s));\n//            v.push_back(rotate_vector(x, -s));\n//        } else if (EQ(d, a.second)) {\n//            v.push_back(x);\n//        }\n//    }\n    vector<Point> res;\n    Real d = distance_line_point(l.first, l.second, a.first);\n    if (d > a.second + EPS) return res;\n    Real len = (d > a.second) ? 0.0 : sqrt(a.second * a.second - d * d);\n    Point nor = (l.first - l.second) / abs(l.first - l.second);\n    res.push_back(projection_point(l.first, l.second, a.first) + len * nor);\n    res.push_back(projection_point(l.first, l.second, a.first) - len * nor);\n    return res;\n    //return v;\n}\n\n//点pを通る円cの接線\nvector<Line> adjust_line(Circle c, Point p) {\n    vector<Line> res;\n    if (circle_in_x(c, p)) return res;\n    if (circle_on_x(c, p)) {\n        pair<Point, Point> n = norm_vectors(c.first - p);\n        res.push_back(Line(n.first + p, p));\n        return res;\n    }\n    Real x = c.second, z = abs(c.first - p);\n    Real y = sqrt(z * z - x * x);\n    Real s = args_bac(y, x, z);\n    Point v = unit_vector(p - c.first) * c.second;\n\n    res.push_back(Line(rotate_vector(v, s) + c.first, p));\n    res.push_back(Line(rotate_vector(v, -s) + c.first, p));\n    return res;\n}\n\n//円の共通接線を求める\nvector<Line> common_adjust_line(Circle a, Circle b) {\n    vector<Line> res;\n    if (a.second + EPS < b.second) return common_adjust_line(b, a);\n    if (EQ(a.first.real(), b.first.real()) && EQ(a.first.imag(), b.first.imag()) && EQ(a.second, b.second)) return res;\n\n    Point pos = (b.first - a.first) * a.second / (a.second + b.second) + a.first;\n    if (!circle_in_x(a, pos)) res = adjust_line(a, pos);\n\n    if (EQ(a.second, b.second)) {\n        pair<Point, Point> n = norm_vectors(unit_vector(b.first - a.first) * a.second);\n        res.push_back(Line(a.first + n.first, b.first + n.first));\n        res.push_back(Line(a.first + n.second, b.first + n.second));\n    } else {\n        Real c = abs(b.first - a.first);\n        pos = unit_vector(b.first - a.first) * ((a.second * c) / (a.second - b.second)) + a.first;\n        if (!circle_in_x(a, pos)) {\n            vector<Line> tmp = adjust_line(a, pos);\n            for (int i = 0; i < tmp.size(); i++) res.push_back(tmp[i]);\n        }\n    }\n\n    return res;\n}\n\n\n//使い方\n//--------------------------------------------\n\n//xとyの取り出し型\n//a.real(); //x\n//a.imag(); //y\n\n//単位ベクトル\n//Point unit = a / abs(a);\n\n//ベクトルの長さをk倍する\n// a = a * Point(k, 0);\n\n//ベクトルaのk倍の法線ベクトル\n//P p1 = a * P(0, k);\n//P p2 = a * P(0, -k);\n\n//ベクトルaの単位法線ベクトル\n//P p1 = (a * P(0, 1)) /abs(a);\n//P p2 = (a * P(0, -1)) /abs(a);\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\n\n\nint main() {\n\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n\n    Circle circle(Point(cx, cy), r);\n\n    int q;\n    cin >> q;\n\n    for (int i = 0; i < q; i++) {\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        auto ans = circle_inter_line_points(circle, Line(Point(x1, y1), Point(x2, y2)));\n\n        if (ans.size() >= 2) {\n            sort(ans.begin(), ans.end());\n            for (int i = 0; i < 2; i++) {\n                cout << fixed << setprecision(10) << ans[i].real() << \" \" << ans[i].imag() << \" \";\n            }\n        } else {\n            for (int i = 0; i < 2; i++) {\n                cout << fixed << setprecision(10) << ans[0].real() << \" \" << ans[0].imag() << \" \";\n            }\n        }\n\n        EL();\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X)\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nnamespace Geometry{\n  #define EPS (1e-10)\n  #define equals(a,b) (fabs((a)-(b)) < EPS)\n\n  class Point{\n  public:\n    double x,y;\n\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n\n    bool operator < (const Point &p) const{\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n      return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS);\n    }\n\n    friend ostream& operator << (ostream &os,Point &p){\n      return os << p.x << \" \" << p.y;\n    }\n\n    friend istream& operator >> (istream &is,Point &p){\n      return is >> p.x >> p.y;\n    }\n  };\n  typedef Point Vector;\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &p){\n      return os << p.p1.x << \" \" << p.p1.y << \" \" << p.p2.x << \" \" << p.p2.y;\n    }\n\n    friend istream& operator >> (istream &is,Segment &p){\n      return is >> p.p1.x >> p.p1.y >> p.p2.x >> p.p2.y;\n    }\n  };\n  typedef Segment Line;\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){\n      return os << c.c.x << c.c.y << c.r;\n    }\n\n    friend istream& operator >> (istream &is,Circle &c){\n      return is >> c.c.x >> c.c.y >> c.r;\n    }\n  };\n\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){\n    return  a.x * a.x + a.y * a.y;\n  }\n\n  double abs(Vector a){\n    return sqrt(norm(a));\n  }\n\n  double dot(Vector a,Vector b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  double cross(Vector a,Vector b){\n    return a.x * b.y - a.y * b.x;\n  }\n\n  bool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n  }\n\n  bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1 - a1,b1 - b2);\n  }\n\n  bool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0);\n  }\n\n  bool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n  }\n\n  bool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1 - a2 , b1 - b2);\n  }\n\n  bool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n  }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base / norm(base));\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n\n  int ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n\n  bool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n  }\n\n  double getDistance(Vector a,Vector b){\n    return abs(a - b);\n  }\n\n  double getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1));\n  }\n\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n              min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    // assert(intersect(c,l));\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){\n    return atan2(p.y,p.x);\n  }\n\n  Vector polar(double a,double r){\n    return Point(cos(r) * a, sin(r) * a);\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    // assert(intersect(c1,c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n\n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y < b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  Polygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0;i--){\n      for(int n = l.size();n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--)l.push_back(u[i]);\n    return l;\n  }\n\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  Circle c;\n  Line a;\n  cin >> c;\n  cin >> n;\n  while(n--){\n    cin >> a;\n    pair<Point,Point> ans = getCrossPoints(c,a);\n    fprints(10,ans.second,ans.first);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    double cx, cy, r, x1, x2, y1, y2, slope, cross_x, cross_y, k, div_x, div_y,\n        ans1_x, ans1_y, ans2_x, ans2_y;\n    int  q;\n    bool X_FLG, Y_FLG;\n\n    scanf(\"%lf %lf %lf\", &cx, &cy, &r);\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n\n        X_FLG = false, Y_FLG = false;\n\n        if (y1 == y2) {\n            X_FLG = true;\n        } else if (x1 == x2) {\n            Y_FLG = true;\n        } else {\n            slope = (y2 - y1) / (x2 - x1);\n        }\n\n        if (X_FLG) {\n            cross_x = cx;\n            cross_y = y1;\n        } else if (Y_FLG) {\n            cross_x = x1;\n            cross_y = cy;\n        } else {\n            cross_x =\n                (cy * (x2 - x1) * (y2 - y1) + cx * (x2 - x1) * (x2 - x1) -\n                 y1 * (y2 - y1) * (x2 - x1) + x1 * (y2 - y1) * (y2 - y1)) /\n                ((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));\n            cross_y = ((x1 - x2) * cross_x + cy * (y2 - y1) + cx * (x2 - x1)) /\n                      (y2 - y1);\n        }\n\n        k = sqrt(r * r - ((cx - cross_x) * (cx - cross_x) +\n                          (cy - cross_y) * (cy - cross_y)));\n\n        if (X_FLG) {\n            printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", cross_x - k, y1, cross_x + k,\n                   y1);\n        } else if (Y_FLG) {\n            printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", x1, cross_y - k, x1,\n                   cross_y + k);\n        } else {\n            div_x = k * (x2 - x1) /\n                    (sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)));\n            div_y = k * (y2 - y1) /\n                    (sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)));\n\n            ans1_x = cross_x - div_x;\n            ans1_y = cross_y - div_y;\n\n            ans2_x = cross_x + div_x;\n            ans2_y = cross_y + div_y;\n\n            if (ans1_x < ans2_x) {\n                printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", ans1_x, ans1_y, ans2_x,\n                       ans2_y);\n            } else if (fabs(ans1_x - ans2_x) < 0.00000001 && ans1_y <= ans2_y) {\n                printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", ans1_x, ans1_y, ans2_x,\n                       ans2_y);\n            } else {\n                printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", ans2_x, ans2_y, ans1_x,\n                       ans1_y);\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble EPS = 0.00000001;\nint sign(double x){\n\tif (x > EPS){\n\t\treturn 1;\n\t} else if (x < -EPS){\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\nbool equals(double x, double y){\n\treturn abs(x - y) < EPS;\n}\nstruct point{\n\tdouble x;\n\tdouble y;\n\tpoint(){\n\t\tx = 0;\n\t\ty = 0;\n\t}\n\tpoint(double X, double Y){\n\t\tx = X;\n\t\ty = Y;\n\t}\n\tpoint operator +(){\n\t\treturn point(x, y);\n\t}\n\tpoint operator -(){\n\t\treturn point(-x, -y);\n\t}\n\tpoint operator +(point P){\n\t\treturn point(x + P.x, y + P.y);\n\t}\n\tpoint operator -(point P){\n\t\treturn point(x - P.x, y - P.y);\n\t}\n\tpoint& operator +=(point P){\n\t\tx += P.x;\n\t\ty += P.y;\n\t\treturn *this;\n\t}\n\tpoint& operator -=(point P){\n\t\tx -= P.x;\n\t\ty -= P.y;\n\t\treturn *this;\n\t}\n\tpoint operator *(double k){\n\t\treturn point(x * k, y * k);\n\t}\n\tpoint operator /(double k){\n\t\treturn point(x / k, y / k);\n\t}\n\tpoint& operator *=(double k){\n\t\tx *= k;\n\t\ty *= k;\n\t\treturn *this;\n\t}\n\tpoint& operator /=(double k){\n\t\tx /= k;\n\t\ty /= k;\n\t\treturn *this;\n\t}\n\tbool operator <(point P){\n\t\treturn sign(P.x - x) == 1 || equals(x, P.x) && sign(P.y - y) == 1;\n\t}\n\tbool operator >(point P){\n\t\treturn (P < *this);\n\t}\n};\nistream& operator >>(istream &is, point &p){\n\tdouble x, y;\n\tis >> x >> y;\n\tp = point(x, y);\n\treturn is;\n}\nostream& operator <<(ostream &os, point p){\n\tos << p.x << ' ' << p.y;\n\treturn os;\n}\ndouble norm(point P){\n\treturn P.x * P.x + P.y * P.y;\n}\ndouble abs(point P){\n\treturn sqrt(norm(P)); \n}\ndouble dot(point P, point Q){\n\treturn P.x * Q.x + P.y * Q.y;\n}\ndouble cross(point P, point Q){\n  return P.x * Q.y - P.y * Q.x;\n}\nstruct line{\n\tpoint A;\n\tpoint B;\n\tline(){\n\t}\n\tline(point P){\n\t  B = P;\n\t}\n\tline(point P, point Q){\n\t\tA = P;\n\t\tB = Q;\n\t}\n};\nistream& operator >>(istream &is, line &L){\n\tpoint A, B;\n\tis >> A >> B;\n\tL = line(A, B);\n\treturn is;\n}\npoint vec(line L){\n\treturn L.B - L.A;\n}\npoint unit(line L){\n\treturn vec(L) / abs(vec(L));\n}\npoint projection(point P, line L){\n\treturn L.A + vec(L) * dot(P - L.A, vec(L)) / norm(vec(L));\n}\ndouble point_line_distance(point P, line L){\n\treturn abs(cross(P - L.A, vec(L))) / abs(vec(L));\n}\nstruct circle{\n  point c;\n  double r;\n  circle(){\n  }\n\tcircle(point C, double R){\n\t\tc = C;\n\t\tr = R;\n\t}\n};\nistream& operator >>(istream &is, circle &C){\n    point P;\n    double r;\n    cin >> P >> r;\n    C = circle(P, r);\n    return is;\n}\nint line_circle_intersection_count(line L, circle C){\n\treturn sign(C.r - point_line_distance(C.c, L)) + 1;\n}\nvector<point> line_circle_intersection(line L, circle C){\n\tint count = line_circle_intersection_count(L, C);\n\tvector<point> ans;\n\tif (count == 0){\n\t\treturn ans;\n\t} else if (count == 1) {\n\t\tans.push_back(projection(C.c, L));\n\t\treturn ans;\n\t} else {\n\t\tpoint P = projection(C.c, L);\n\t\tdouble d = sqrt(pow(C.r, 2) - pow(point_line_distance(C.c, L), 2));\n\t\tans.push_back(P + unit(L) * d);\n\t\tans.push_back(P - unit(L) * d);\n\t\treturn ans;\n\t}\n}\nint main(){\n  cout << fixed << setprecision(15);\n  circle C;\n  cin >> C;\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++){\n    line L;\n    cin >> L;\n    vector<point> ans = line_circle_intersection(L, C);\n    sort(ans.begin(), ans.end());\n    if (ans.size() == 1){\n      cout << ans[0] << ' ' << ans[0] << endl;\n    } else {\n      cout << ans[0] << ' ' << ans[1] << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\n//定義系\n\ndouble EPS = 1e-10;\n\n//誤差を考慮して足し算を行う\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\n\n//Point\nstruct Point {\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {\n\t}\n\tPoint operator + (Point p) {\n\t\treturn Point(add(x, p.x), add(y, p.y));\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(add(x, -p.x), add(y, -p.y));\n\t}\n\tPoint operator * (double d) {\n\t\treturn Point(x*d, y*d);\n\t}\n\tPoint operator / (double d) {\n\t\treturn Point(x / d, y / d);\n\t}\n\t//内積\n\tdouble dot(Point p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\t//外積\n\tdouble det(Point p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\t//点の大小比較\n\tbool operator <(const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator ==(const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS;\n\t}\n};\n\n//ベクトル。使い分けるといいかも\ntypedef Point Vector;\n\n//ベクトルの大きさの2乗\ndouble norm(Vector p) {\n\treturn p.x*p.x + p.y*p.y;\n}\n\n//ベクトルの大きさ\ndouble abs(Vector p) {\n\treturn sqrt(norm(p));\n}\n\n//線分\nstruct Segment {\n\tPoint p1, p2;\n};\n\n//直線\ntypedef Segment Line;\n\n//中心c,半径rの円\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\n//多角形\ntypedef vector<Point> Polygon;\n\n//頂点集合\ntypedef vector<Point> Points;\n\n\n\n\n//計算・アルゴリズム系\n\n\n//反時計回りCCW\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (a.det(b) > EPS)return COUNTER_CLOCKWISE;\n\tif (a.det(b) < -EPS)return CLOCKWISE;\n\tif (a.dot(b) < -EPS)return ONLINE_BACK;\n\tif (norm(a)<norm(b))return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルa,bの直交判定\nbool isOrthogonal(Vector a, Vector b) {\n\treturn a.dot(b) == 0.0;\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).dot(s2.p2 - s2.p1) == 0.0;\n}\n\n//ベクトルa,bの並行判定\nbool isParallel(Vector a, Vector b) {\n\treturn a.det(b) == 0.0;\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).det(s2.p2 - s2.p1) == 0.0;\n}\n\n//射影(点p1と点p2を通る直線に点pから垂線を引いた交点xを求める)\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = (p - s.p1).dot(base) / norm(base);\n\treturn s.p1 + base*r;\n}\n\n//反射(点p1と点p2を通る直線を対象軸として点pと線対称の位置にある点xを求める)\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\n//点aと点bの距離\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n//直線lと点pの距離\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs((l.p2 - l.p1).det(p - l.p1) / abs(l.p2 - l.p1));\n}\n\n//線分sと点pの距離\ndouble getDistanceSP(Segment s, Point p) {\n\tif ((s.p2 - s.p1).dot(p - s.p1) < 0.0)return abs(p - s.p1);\n\tif ((s.p1 - s.p2).dot(p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n//線分s1と線分s2の距離\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(base.det(s1.p1 - s2.p1));\n\tdouble d2 = abs(base.det(s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//円cと線分lの交点\npair<Point, Point>getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\n//距離の二乗\ndouble dist(Point p, Point q) {\n\treturn (p - q).dot(p - q);\n}\n\n//辞書順で比較\nbool cmp_x(const Point& p, const Point& q) {\n\tif (p.x != q.x)return  p.x < q.x;\n\treturn p.y < q.y;\n}\n\n//凸包を求める\nvector<Point> convex_hull(Point* ps, int n) {\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;//凸法の頂点数\n\tvector<Point> qs(n * 2);//構築中の凸包\n\n\t\t\t\t\t\t//下限凸包の作成\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\n\t//上限凸包の作成\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nint main() {\n\tCircle c;\n\tLine l;\n\tcin >> c.c.x >> c.c.y >> c.r;\n\tint q;\n\tcin >> q;\n\tREP(qqq, q) {\n\t\tcin >> l.p1.x >> l.p1.y >> l.p2.x>>l.p2.y;\n\t\tpair<Point, Point> p = getCrossPoints(c, l);\n\t\tif (p.second < p.first)swap(p.first, p.second);\n\t\tcout <<fixed<<setprecision(13)<< p.first.x << \" \" << p.first.y << \" \" << p.second.x << \" \" << p.second.y << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n向量a ,向量b\nc=a-b c的方向指向的是a  指向的是被减数 \n*/\n#include<bits/stdc++.h>\n#define eps (1e-10)\nusing namespace std;\nclass Point\n{\n\tpublic:\n\tdouble x,y;\n\tPoint(double _x=0,double _y=0):x(_x),y(_y){}\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y);} \n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){return Point(a*x,a*y);} \n\tPoint operator / (double a){return Point(x/a,y/a);}\n\tdouble norm(){return x*x+y*y;}\n\tdouble ABS(){return sqrt(norm());} //相当于向量的大小 \n\tbool operator <(const Point &p) const{\n\t\treturn x!=p.x?x<p.x:y<p.y;\n\t}\n\tbool operator ==(const Point &p) const{\n\t\treturn abs(x-p.x)<eps&&(y-p.y)<eps;\n\t}\n};\nclass Segment\n{\n\tpublic:\n\tPoint p1,p2;\t\n\tSegment(){}\n\tSegment(Point _p1=Point(0.0),Point _p2=Point(0.0)):p1(_p1),p2(_p2){}\n\tdouble norm(){return (p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y); }\n\tdouble ABS(){return sqrt(norm());}//线段的长度 和用Point里的ABS函数求的是一样的 \n};\nclass Circle\n{\n\tpublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point _c=Point(0.0),double _r=0.0):c(_c),r(_r){}\n};\ndouble dot(Point a,Point b)//求内积 就是向量a*b \n{\n\treturn a.x*b.x+a.y*b.y;\n}\n//外积的值为a与b向量构成的平行四边形面积的值 \ndouble cross(Point a,Point b)//求外积 \n{\n\treturn a.x*b.y-a.y*b.x;\n} \n\n\n//判断是否正交 向量内积：a*b=|a||b|*cos(Y) 当cos为0时正交(90,-90垂直) \n//a*b=a.x*b.x+a.y*b.y;\nbool solve1(Point a,Point b)//是否正交 \n{\n\tdouble f=a.x*b.x+a.y*b.y; \n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n//判断是否平行  向量外积：|a*b|=|a||b|sin(Y) 当sin为0时平行(180,0平行)\n//|a*b|=|a|*|b|*sin(Y) \nbool solve2(Point a,Point b)//是否平行 \n{\n\tdouble f=a.x*b.y-a.y*b.x;\n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n\n/*\n求垂足x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线引一条垂线\nbase=p2-p1;\nhypo=p-p1;\n x=s.p1+base*(hypo*base/|base|^2); hypo*base 可以用向量内积求 \n*/\nPoint solve3(Segment s,Point p)//求投影点 \n{\n\tPoint base=s.p2-s.p1;\n\tdouble r=dot(p-s.p1,base)/base.norm();\n\treturn s.p1+base*r; \n}\n/*\n求投影点x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线为对称轴与点p\n成线对称点为x \n通过求solve3的垂足延长一倍就可以求x \n*/\nPoint solve4(Segment s,Point p)//求映象 \n{\n\treturn p+(solve3(s,p)-p)*2.0;\n}\n\n/*\nPoint a=p1-p0;\nPoint b=p2-p0;\n1.外积大小cross(a,b)为正时,可确定b在a的逆时针方向\n\tsin(Y)（Y在0-180）所以是正数\n2. 外积大小cross(a,b)为负时,可确定b在a的顺时针方向\n3.（1,2）不符合 表示p2在直线p0p1上(注意是直线),cos(Y)大于90或小于-90\n\t度时为负，因此a与b的内积dot(a,b)负时，可确定p2位于线段p0p1后方\n\t即p2->p0->p1\n4.不是3时，有俩种p0->p1-p2或者p0->p2->p1如果b的大小大于a的大小，即为\n\tp0->p1->p2;\n5.不符合4，可以确定p2位于线段p0p1上 \n*/ \nint ccw(Point p0,Point p1,Point p2)//判断三个点相对位置 \n{\n\tPoint a=p1-p0;\n\tPoint b=p2-p0;\n\tif(cross(a,b)>eps) return 1;//p0,p1,p2成逆时针方向 \n\tif(cross(a,b)<-eps) return -1;//p0,p1,p2成顺时针方向 \n\tif(dot(a,b)<-eps) return 2;//p2 p0 p1一次排列在同一直线上 \n\tif(a.norm()<b.norm()) return -2;// p0 p1 p2一次排列在同一直线上 \n\treturn 0;//p2在线段p0p1上 \n\t\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)//判断线段是否相交 通过ccw来判断 \n{\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\n\n\n/*\n点a与点b之间的距离等于向量a-b或b-a的绝对值。 \n*/ \ndouble getdis(Point a,Point b)//求俩点间的距离                    \n{\n\treturn (a-b).ABS();\n} \n\n/*\n设直线p1 p2上的向量为a=p2-p1,p与p1构成的向量b=p-p1\n则点p与直线p1p2的距离d就等于a,b构成的平行四边形的高\n用a与b外积的大小(平行四边形的面积)除以a的大小|a|即可求出高d\nd=|a*b|/|a|=|(p2-p1)*(p-p1)|/|p2-p1|; \n*/\n//注意：这里Segmet s是不规范的应该是 Line s 才对 \ndouble getdis_Li(Segment s,Point p)//点与直线的距离 \n{\n\treturn abs(cross(s.p2-s.p1,p-s.p1)/(s.p2-s.p1).ABS());\n}\n\ndouble getdis_sp(Segment s,Point p)//点与线段的距离 \n{\n\tif(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).ABS();\n\tif(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).ABS();\n\treturn getdis_Li(s,p);\n}\n\ndouble getdis_ss(Segment s1,Segment s2)//线段与线段之间的距离 \n{\n\tif(intersect(s1.p1,s1.p2,s2.p1,s2.p2)) return 0.0;\n\treturn min(min(getdis_sp(s1,s2.p1),getdis_sp(s1,s2.p2)),min(getdis_sp(s2,s1.p1),getdis_sp(s2,s1.p2)));\n}\n\n/*\nt：线段s1的长度与点s1.p1到交点的x的距离之比为t\nd1：s1 和s2.p1构成的平行四边形的高\nd2:同理\n则：d1:d2=t:(t-1)\nx=s1.p1+(s1.p2-s1.p1)*t; \n*/ \nPoint get_s1s2_point(Segment s1,Segment s2)//在s1和s2有交点的情况下，求s1和s2的交点 \n{\n\tPoint base=s2.p2-s2.p1;\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+(s1.p2-s1.p1)*t;\n} \npair<Point,Point>getCrossPoint(Circle c,Segment s)\n{\n\tPoint pr=solve3(s,c.c);\n\tPoint e=(s.p2-s.p1)/(s.p2-s.p1).ABS();\n\tdouble base=sqrt(c.r*c.r-(pr-c.c).norm());\n\treturn make_pair(pr+e*base,pr-e*base);\n}\nint main()\n{\n\tdouble a,b,r;\n\tscanf(\"%lf %lf %lf\",&a,&b,&r);\n\tCircle c(Point(a,b),r);\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tdouble x1,y1,x2,y2;scanf(\"%lf %lf %lf %lf\",&x1,&y1,&x2,&y2);\n\t\tSegment s(Point(x1,y1),Point(x2,y2));\n\t\tpair<Point,Point>pi=getCrossPoint(c,s);\n\t\tif(pi.first<pi.second){\n\t\t\tprintf(\"%.6f %.6f %.6f %.6f\\n\",pi.first.x,pi.first.y,pi.second.x,pi.second.y);\n\t\t} \n\t\telse{\n\t\t\tprintf(\"%.6f %.6f %.6f %.6f\\n\",pi.second.x,pi.second.y,pi.first.x,pi.first.y);\n\t\t}\n\t\t      \n\t} \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <utility>\n#include <cassert>\n\nconst double EPS=1e-10;\n\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Vector a,Vector b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base) / norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p+(project(s,p)-p)*2.0;\n}\n\nenum CCW {\n    COUNTER_CLOCKWISE=1,\n    CLOCKWISE=-1,\n    ONLINE_BACK=2,\n    ONLINE_FRONT=-2,\n    ON_SEGMENT=0,\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return CCW::COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CCW::CLOCKWISE;\n    if(dot(a,b)<-EPS) return CCW::ONLINE_BACK;\n    if(norm(a)<norm(b)) return CCW::ONLINE_FRONT;\n\n    return CCW::ON_SEGMENT;\n}\n\ndouble getDistance(Point a,Point b) {\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2) {\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\nbool intersect(Circle c,Line l) {\n    double d=getDistanceLP(l,c.c);\n    return !(d>c.r);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2) {\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n\n    return make_pair(pr+e*base,pr-e*base);\n\n}\n\nint main() {\n    double cx,cy,r;\n    cin>>cx>>cy>>r;\n    Circle circle({Point(cx,cy),r});\n    int q; cin>>q;\n    while(q-->0) {\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        Line l=Line({Point(x1,y1),Point(x2,y2)});\n\n        auto ans=getCrossPoints(circle,l);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",ans.first.X,ans.first.Y,ans.second.X,ans.second.Y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n//using P = pair<int, int>;\nusing namespace std;\n\nconst double eps = 1e-10;\n#define equals(a, b) (fabs((a)-(b)) < eps)\n\n// 点\nstruct Point\n{\n    double x, y;\n    Point(double x=0, double y=0): x(x), y(y) {}\n    double norm()\n    {\n        return x*x+y*y;\n    }\n    double abs()\n    {\n        return sqrt(norm());\n    }\n\n    Point operator+(const Point& p)const\n    {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator-(const Point& p)const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator*(const double k)const\n    {\n        return Point(x * k, y * k);\n    }\n    Point operator/(const double k)const\n    {\n        return Point(x / k, y / k);\n    }\n    bool operator<(const Point& p)const\n    {\n        if (x != p.x)\n        {\n            return x < p.x;\n        }\n        return y < p.y;\n    }\n    bool operator==(const Point& p)const\n    {\n        return fabs(x - p.x) < eps and fabs(y - p.y) < eps;\n    }\n};\n\nusing Vector = Point;\n\n// 内積\ndouble dot(Vector a, Vector b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n// 外積\ndouble cross(Vector a, Vector b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n// 線分\nstruct Segment\n{\n    Segment(Point a=Point(), Point b=Point()):p1(a), p2(b) {}\n    Point p1, p2;\n};\nusing Line = Segment;\n\n// 円\nclass Circle\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 多角形\nusing Polygon = vector<Point>;\n\n\n// ベクトルaとbの直行判定\n// Verify\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n// ベクトルaとbの平行判定\n// Verify\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n// 射影\n// verify\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\n// 反射\n// verify\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\n// ２点間の距離\ndouble getDistance(Point a, Point b) {\n    return (a-b).abs();\n}\n\n// 直線Lと、点Pの距離\n// verify\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.p2 - l.p1, p - l.p1) / Point(l.p2 - l.p1).abs());\n}\n\n// 線分sと点pの距離\ndouble getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p-s.p1) < 0.0) return (p - s.p1).abs();\n    if (dot(s.p1 - s.p2, p-s.p2) < 0.0) return (p - s.p2).abs();\n    return getDistanceLP((Line)s, p);\n}\n\n\n// 反時計回り\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// verify\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > eps) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -eps) return CLOCKWISE;\n    if (dot(a, b) < -eps) return ONLINE_BACK;\n    if (a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// 線分の交差判定\n// verify\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n// verify\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 線分s1と線分s2の距離\n//verify\ndouble getDistance(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 線分の交点\n// verify\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\n// 円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    //assert(intersect(c, l)); ?\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt(c.r * c.r - (pr - c.c).norm());\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n// 円と円の交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n    // assert(intersect(c1, c2));\n    double d = (c1.c - c2.c).abs();\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2  * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t-a));\n}\n\n// 点の内包\n// IN 2, ON 1, OUT 0\n\nint contains(Polygon g, Point p) {\n    int n = g.size();\n    bool x = false;\n    for (int i = 0; i < n; ++i) {\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if (abs(cross(a, b)) < eps and dot(a, b) < eps) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y < eps and eps < b.y and cross(a, b) > eps) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\n// 凸包\nPolygon andrewScan(Polygon s) {\n    Polygon u, l;\n    if (s.size() < 3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n\n    for (int i = 2; i < s.size(); ++i) {\n        for (int n = u.size(); n >= 2 and ccw(u[n-2], u[n-1], s[i]) != CLOCKWISE; --n) {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for (int i = s.size()-3; i>=0; --i) {\n        for (int n = l.size(); n>=2 and ccw(l[n-2], l[n-1], s[i]) != CLOCKWISE; --n) {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n    return l;\n}\n\n// 平面走査\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n    bool operator<(const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return st < ep.st;\n        }else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; ++i) {\n        if (S[i].p1.y == S[i].p2.y) {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if (S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\n        if (S[i].p1.y == S[i].p2.y) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(100000001); // 番兵\n    int cnt = 0;\n\n    for (int i = 0; i < 2 * n; ++i) {\n        if (EP[i].st == TOP) {\n            BT.erase(EP[i].p.x);\n        }\n        else if (EP[i].st == BOTTOM) {\n            BT.insert(EP[i].p.x);\n        }\n        else if (EP[i].st == LEFT) {\n            auto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n            auto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n\n}\n\nint main() {\n    int cx, cy, r;\n    cin >> cx >> cy >> r;\n    Circle c(Point(cx, cy), r);\n    int q;\n    cin >> q;\n    rep(i, q) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line l(Point(x1, y1), Point(x2, y2));\n        auto ret = getCrossPoints(c, l);\n\n        if (ret.first.x > ret.second.x or (ret.first.x == ret.second.x and ret.first.y > ret.second.y)) {\n            printf(\"%.10f %.10f %.10f %.10f\\n\", ret.second.x, ret.second.y, ret.first.x, ret.first.y);\n        }\n        else {\n            printf(\"%.10f %.10f %.10f %.10f\\n\", ret.first.x, ret.first.y, ret.second.x, ret.second.y);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(n);i++)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);i--)\n#define mp make_pair\n#define pb push_back\n\ntypedef double db;\n\nconst db EPS = 1e-8;\n\ninline int sign(db a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\ninline int cmp(db a, db b){\n\treturn sign(a-b);\n}\n\nstruct P {\n\tdb x, y;\n\tP() {\n\t}\n\tP(db _x, db _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(P p) {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(P p)  {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(db d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(db d) {\n\t\treturn P(x / d, y / d);\n\t}\n\tbool operator<(P p) const {\n\t\tint c = sign(x - p.x);\n\t\tif (c)\n\t\t\treturn c == -1;\n\t\treturn sign(y - p.y) == -1;\n\t}\n\tdb dot(P p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdb det(P p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb distTo(P p) { return (*this-p).abs(); }\n\n\tdb alpha() {\n\t\treturn atan2(y, x);\n\t}\n\tvoid read() {\n\t\tcin>>x>>y;\n\t}\n\tdb abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdb abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP rot90(){\n\t\treturn P(-y,x);\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nP isLL(P p1, P p2, P q1, P q2) {\n\tdb a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nbool intersect(db l1,db r1,db l2,db r2){\n\tif(l1>r1) swap(l1,r1); if(l2>r2) swap(l2,r2); \n\treturn !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );\n}\n\nbool isSS(P p1, P p2, P q1, P q2){\n    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) && \n    crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n            * crossOp(q1,q2,p2) <= 0;\n}\n\nbool isMiddle(db a, db m, db b) {\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n \nbool isMiddle(P a, P m, P b) {\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\nbool onSeg(P p1, P p2, P q){\n\treturn crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);\n}\n\nP proj(P p1, P p2, P q) {\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\nP reflect(P p1, P p2, P q){\n\treturn proj(p1,p2,q) * 2 - q;\n}\n\ndb nearest(P p1,P p2,P q){\n\tP h = proj(p1,p2,q);\n\tif(isMiddle(p1,h,p2))\n\t\treturn q.distTo(h);\n\treturn min(p1.distTo(q),p2.distTo(q));\n}\n\ndb disSS(P p1, P p2, P q1, P q2){\n\tif(isSS(p1,p2,q1,q2)) return 0;\n\treturn min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)) );\n}\n\ndb getrad(P p1,P p2){\n\treturn atan2l(p1.det(p2),p1.dot(p2));\n}\n\ndb incircle(P p1, P p2, P p3){\n\tdb A = p1.distTo(p2);\n\tdb B = p2.distTo(p3);\n\tdb C = p3.distTo(p1);\n\treturn sqrtl(A*B*C/(A+B+C));\n}\n\n//polygon\n\ndb area(vector<P> ps){\n\tdb ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]); \n\treturn abs(ret/2);\n}\n\nint contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside\n\tint n = ps.size(), ret = 0;\t\n\trep(i,0,n){\n\t\tP u=ps[i],v=ps[(i+1)%n];\n\t\tif(onSeg(u,v,p)) return 1;\n\t\tif(cmp(u.y,v.y)<=0) swap(u,v);\n\t\tif(cmp(p.y,u.y) >0 || cmp(p.y,v.y) <= 0) continue;\n\t\tret ^= crossOp(p,u,v) > 0;\n\t}\n\treturn ret*2;\n}\n\nvector<P> convexHull(vector<P> ps) {\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++]) \n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n       \twhile (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\nvector<P> convexHullNonStrict(vector<P> ps) {\n\t//caution: need to unique the points first\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++]) \n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n       \twhile (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\ndb convexDiameter(vector<P> ps){\n\tint n = ps.size(); if(n <= 1) return 0;\n\tint is = 0, js = 0; rep(k,1,n) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;\n\tint i = is, j = js;\n\tdb ret = ps[i].distTo(ps[j]);\n\tdo{\n\t\tif((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)\n\t\t\t(++j)%=n;\n\t\telse\n\t\t\t(++i)%=n;\n\t\tret = max(ret,ps[i].distTo(ps[j]));\n\t}while(i!=is || j!=js);\n\treturn ret;\n}\n\nvector<P> convexCut(const vector<P>&ps, P q1, P q2) {\n\tvector<P> qs;\n\tint n = ps.size();\n\trep(i,0,n){\n\t\tP p1 = ps[i], p2 = ps[(i+1)%n];\n\t\tint d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);\n\t\tif(d1 >= 0) qs.push_back(p1);\n\t\tif(d1 * d2 < 0) qs.push_back(isLL(p1,p2,q1,q2));\n\t}\n\treturn qs;\n}\n\n//min_dist\n\ndb min_dist(vector<P>&ps,int l,int r){\n\tif(r-l<=5){\n\t\tdb ret = 1e100;\n\t\trep(i,l,r) rep(j,l,i) ret = min(ret,ps[i].distTo(ps[j]));\n\t\treturn ret;\n\t}\n\tint m = (l+r)>>1;\n\tdb ret = min(min_dist(ps,l,m),min_dist(ps,m,r));\n\tvector<P> qs; rep(i,l,r) if(abs(ps[i].x-ps[m].x)<= ret) qs.push_back(ps[i]);\n\tsort(qs.begin(), qs.end(),[](P a,P b) -> bool {return a.y<b.y; });\n\trep(i,1,qs.size()) for(int j=i-1;j>=0&&qs[j].y>=qs[i].y-ret;--j) ret = min(ret,qs[i].distTo(qs[j]));\n\treturn ret;\n}\n\nint type(P o1,db r1,P o2,db r2){\n\tdb d = o1.distTo(o2);\n\tif(cmp(d,r1+r2) == 1) return 4;\n\tif(cmp(d,r1+r2) == 0) return 3;\n\tif(cmp(d,abs(r1-r2)) == 1) return 2;\n\tif(cmp(d,abs(r1-r2)) == 0) return 1;\n\treturn 0;\n}\n\nvector<P> isCL(P o,db r,P p1,P p2){\n\tdb x = (p1-o).dot(p2-p1), y = (p2-p1).abs2(), d = x * x - y * ((p1-o).abs2() - r*r);\n\tvector<P> ret; if(sign(d) < 0) return ret;\n\td = max(d,0.0); P m = p1 - (p2-p1)*(x/y), dr = (p2-p1)*(sqrt(d)/y);\n\tret.pb(m-dr);ret.push_back(m+dr); return ret;\n}\n\nint main(){\n\tP o1;db r1;\n\to1.read();cin>>r1;\n\tint n;cin>>n;\n\trep(i,0,n){\n\t\tP p1,p2;p1.read(),p2.read();\n\t\tvector<P> ret = isCL(o1,r1,p1,p2);\n\t\tsort(ret.begin(), ret.end());\n\t\tfor(auto p : ret) printf(\"%0.10f %0.10f \",p.x,p.y);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??´???\n  L(){};\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const P &p,const P &q){\n  return abs(p - q) ;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\npair<P,P> crosspoint(const C &a,const C &b){\n  P m = (a.p+b.p)/2.0;\n  P vv = verticalvector(a.p,b.p);\n  double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n  P A = m + u * vv,B = m - u * vv;\n  return mp(A,B);\n}\npair<P,P> crosspoint(const C &a,const L &l){\n  P p = projection(l,a.p);\n  P q = l[1] - l[0];\n  P v = q / abs(q);\n  double d = sqrt(a.r * a.r - norm(a.p - p));\n  P e = p + d * v,f = p - d * v;\n  if(e < f){\n    return mp(e,f);\n  }\n  return mp(f,e);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  double x,y,r;\n  cin >> x >> y >> r;\n  C c1(P(x,y),r); \n  ll q;\n  cin >> q;\n  rep(i,q){\n    cin >> x >> y;\n    P a(x,y); \n    cin >> x >> y;\n    P b(x,y); \n    L l(a,b);\n    auto res = crosspoint(c1,l);\n    fcout(10) << real(res.fi) << ' ' << imag(res.fi) << ' ' << real(res.se) << ' ' << imag(res.se) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    double x,y;\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(double d){\n        return (vec){x*d,y*d};\n    }\n    double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\npair<vec,vec> cross_point(vec& C, double r, vec& p1, vec& p2){\n    vec P1,P2,P;\n    P=(p2-p1)*((p2-p1).dot(C-p1)/(p2-p1).dot(p2-p1))+p1;\n    P1=P+(p2-p1)*(sqrt(r*r-(P-C).dot(P-C))/(p2-p1).norm());\n    P2=P-(p2-p1)*(sqrt(r*r-(P-C).dot(P-C))/(p2-p1).norm());\n    if(P1.x==P2.x){\n        if(P1.y<P2.y) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }else{\n        if(P1.x<P2.x) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }\n}\n\nint main(){\n    vec C,p1,p2;\n    double r;\n    int q;\n    cin >> C.x >> C.y >> r >> q;\n    cout.precision(8);\n    cout << fixed;\n    while(q--){\n        cin >> p1.x >> p1.y >> p2.x >> p2.y;\n        pair<vec,vec> P = cross_point(C,r,p1,p2);\n        cout << P.first.x << \" \" << P.first.y << \" \" << P.second.x << \" \" << P.second.y << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n// ???????????????\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n////////////////////\n// ??¨????????¢???\nusing D = double;\n////////////////////\n// ?????°\nconst D EPS = 1e-9;                // |EPS|???????????°???0??¨????????±???\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // 3??????????????¢???\n////////////////////\n// ?§???????\nstruct Point {\n  D x, y;\n  Point(const D d = 0.0) : x(d), y(d) {}\n  Point(const D x, const D y) : x(x), y(y) {}\n};\nstruct Segment {\n  Point initial, terminal;\n  Segment(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Segment(const D x1, const D y1, const D x2, const D y2) : initial(x1, y1), terminal(x2, y2) {}\n};\nstruct Line {\n  Point initial, terminal;\n  Line(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Line(const D x1, const D y1, const D x2, const D y2) : initial(x1, y1), terminal(x2, y2) {}\n  Line(const Segment& s) : initial(s.initial), terminal(s.terminal) {}\n};\n////////////////////\n// ????£?\nbool relative_equal(const D d1, const D d2) {return d1 == 0 ? std::abs(d2) < EPS : std::abs((d1 - d2) / d1) < EPS;}\n// ??????????????????????????????\nbool operator==(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) && relative_equal(lhs.y, rhs.y);}\nbool operator<(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y < rhs.y : lhs.x < rhs.x;}\nbool operator>(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y > rhs.y : lhs.x > rhs.x;}\nbool operator!=(const Point& lhs, const Point& rhs) {return !(lhs == rhs);}\nbool operator<=(const Point& lhs, const Point& rhs) {return !(lhs > rhs);}\nbool operator>=(const Point& lhs, const Point& rhs) {return !(lhs < rhs);}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x + rhs.x, lhs.y + rhs.y);}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x * rhs.x, lhs.y * rhs.y);}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x / rhs.x, lhs.y / rhs.y);}\nconst Point operator-(const Point& p) {return Point(-p.x, -p.y);}\n// ???\nD abs(const Point& p) {return std::hypot(p.x, p.y);}\nD norm(const Point& p) {return p.x * p.x + p.y * p.y;}\nD dot(const Point& a, const Point& b) {return a.x * b.x + a.y * b.y;}\nD cross(const Point& a, const Point& b) {return a.x * b.y - a.y * b.x;}\n// const Point normalize(const Point& p) {return p / abs(p);}\n// const Point normal(const Point& p) {return normalize(Point(-p.y, p.x));}\n// ??´???\nbool parallel(const Line& l1, const Line& l2) {return relative_equal(0.0, cross(l2.terminal - l2.initial, l1.terminal - l1.initial));}\nbool orthogonal(const Line& l1, const Line& l2) {return relative_equal(0.0, dot(l2.terminal - l2.initial, l1.terminal - l1.initial));}\n// 3??????????????¢???\nPOSITION ccw(const Point& a, const Point& b, const Point& p) {\n  Point v1 = b - a;\n  Point v2 = p - a;\n  if(cross(v1, v2) >= EPS) return COUNTER_CLOCKWISE;\n  if(cross(v1, v2) <= -EPS) return CLOCKWISE;\n  if(dot(v1, v2) <= -EPS) return ONLINE_BACK;\n  if(norm(v1) < norm(v2)) return ONLINE_FRONT;              // ????????????: norm(v1)<norm(v2)+EPS?????¨WrongAnswer\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(const Point& p1, const Point& p2) {return p1 == p2;}\nbool intersect(const Point& p, const Segment& s) {return abs(p - s.initial) + abs(p - s.terminal) - abs(s.initial - s.terminal) <= EPS;}\nbool intersect(const Segment& s, const Point& p) {return intersect(p, s);}\nbool intersect(const Point& p, const Line& l) {return !parallel(Line(p, l.initial), Line(p, l.terminal));}\nbool intersect(const Line& l, const Point& p) {return intersect(p, l);}\nbool intersect(const Segment& s1, const Segment& s2) {\n  return ccw(s1.initial, s1.terminal, s2.initial) * ccw(s1.initial, s1.terminal, s2.terminal) <= 0\n      && ccw(s2.initial, s2.terminal, s1.initial) * ccw(s2.initial, s2.terminal, s1.terminal) <= 0;\n}\nbool intersect(const Segment& s, const Line& l) {\n  auto v1 = l.terminal - l.initial;\n  auto v2 = s.initial  - l.initial;\n  auto v3 = s.terminal - l.initial;\n  return cross(v1, v2) * cross(v1, v3) <= EPS;\n}\nbool intersect(const Line& l, const Segment& s) {return intersect(s, l);}\nbool intersect(const Line& l1, const Line& l2) {return !parallel(l1, l2) || intersect(l1.initial, l2);}\n// ???????§????\nPoint rotate(const Point& p, const D a) {return Point(p.x * std::cos(a) - p.y * std::sin(a), p.x * std::sin(a) + p.y * std::cos(a));}\nPoint projection(const Point& p, const Line& l) {\n  auto v = l.initial - l.terminal;\n  return l.initial + dot(p - l.initial, v) / norm(v) * v;\n}\nPoint projection(const Line& l, const Point& p) {return projection(p, l);}\nPoint reflection(const Point& p, const Line& l) {return p + 2 * (projection(p, l) - p);}\nPoint reflection(const Line& l, const Point& p) {return reflection(p, l);}\n// ?????¢\nD distance(const Point& p1, const Point& p2) {\n  auto p = p1 - p2;\n  return hypot(p.x, p.y);\n}\nD distance(const Point& p, const Segment& s) {\n  auto r = projection(s, p);\n  return intersect(r, s) ? distance(p, r) : std::min(distance(p, s.initial), distance(p, s.terminal));\n}\nD distance(const Segment& s, const Point& p) {return distance(p, s);}\nD distance(const Point& p, const Line& l) {return distance(p, projection(p, l));}\nD distance(const Line& l, const Point& p) {return distance(p, l);}\nD distance(const Segment& s1, const Segment& s2) {\n  return intersect(s1, s2) ? 0.0 : std::min({distance(s1, s2.initial), distance(s1, s2.terminal), distance(s2, s1.initial), distance(s2, s1.terminal)});\n}\nD distance(const Segment& s, const Line& l) {return intersect(s, l) ? 0.0 : std::min(distance(s.initial, l), distance(s.terminal, l));}\nD distance(const Line& l,const Segment& s) {return distance(s, l);}\nD distance(const Line& l1, const Line& l2) {return intersect(l1, l2) ? 0.0 : distance(l1.initial, l2);}\n// ??????\nconst Point crosspoint(const Line& l1, const Line& l2) {\n  assert(intersect(l1, l2));\n  if(parallel(l1, l2)) return l1.initial;                   // ???????????¨???l1????§?????????????\n  D A = cross(l1.terminal - l1.initial, l2.terminal - l2.initial);\n  D B = cross(l1.terminal - l1.initial, l1.terminal - l2.initial);\n  return l2.initial + B / A * (l2.terminal - l2.initial);\n}\nconst Point crosspoint(const Segment& s, const Line& l) {\n  assert(intersect(s, l));\n  if(parallel(s, l)) return s.initial;\n  return crosspoint(Line(s), l);\n}\nconst Point crosspoint(const Line& l, const Segment& s) {return crosspoint(s, l);}\nconst Point crosspoint(const Segment& s1, const Segment& s2) {\n  assert(intersect(s1, s2));\n  if(parallel(s1, s2)) {                                    // ???????????¨?????????????????????????????????\n    if(intersect(s1.initial,  s2)) return s1.initial;\n    if(intersect(s1.terminal, s2)) return s1.terminal;\n    if(intersect(s2.initial,  s1)) return s2.initial;\n    if(intersect(s2.terminal, s1)) return s2.terminal;\n  }\n  return crosspoint(Line(s1), Line(s2));\n}\n// ???????????°??¨\n#include<iostream>\nstd::ostream& operator<<(std::ostream& os, const Point& p) {os<<\"point: \"; os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os;}\nstd::ostream& operator<<(std::ostream& os, const Segment& s) {os<<\"segment: \"; os<<s.initial<<\" - \"<<s.terminal; return os;}\nstd::ostream& operator<<(std::ostream& os, const Line& l) {os<<\"line: \"; os<<l.initial<<\" - \"<<l.terminal; return os;}\n////////////////////////////////////////////////////////////////////////////////\n// ???\n#include<vector>\nconst D PI = std::acos(-1);\nstruct Circle {\n  Point center;\n  D radius;\n  Circle(const Point& center = 0, const D radius = 0) : center(center), radius(radius) {}\n  Circle(const D x, const D y, const D radius) : center(x, y), radius(radius) {}\n};\nD area(const Circle& c) {return PI * c.radius * c.radius;}\nbool contain(const Circle& c, const Point& p) {\n  D d = abs(p - c.center);\n  if(relative_equal(c.radius, d)) return true;\n  return d < c.radius;\n}\nbool contain(const Point& p, const Circle& c) {return contain(c, p);}\nstd::vector<Point> crosspoint(const Circle& c, const Line& l) {\n  std::vector<Point> cp;\n  Point p = projection(c.center, l);\n  if(!contain(c, p)) return cp;\n  Point v = p - c.center;\n  if(relative_equal(abs(v), 0)) {\n    Point p = l.initial - c.center;\n    if(p == 0) p = l.terminal - c.center;\n    p = (c.radius * p / abs(p));\n    cp.push_back(c.center + p);\n    cp.push_back(c.center - p);\n    return cp;\n  }\n  D angle = acos(abs(v) / c.radius);\n  for(D a: {angle, -angle}) cp.push_back(c.center + c.radius * (rotate(v, a) / abs(v)));\n  return cp;\n}\nstd::vector<Point> crosspoint(const Line& l, const Circle& c) {return crosspoint(c, l);}\nint tangent(const Circle& c1, const Circle& c2) {\n  D d = abs(c1.center - c2.center);\n  D r = c1.radius + c2.radius;\n  if(relative_equal(d, r)) return 3;    // ?????\\\n  if(r < d) return 4;                   // ?????¢\n  r = std::abs(c1.radius - c2.radius);\n  if(relative_equal(d, r)) return 1;    // ?????\\\n  if(r < d) return 2;                   // ??????\n  return 0;                             // ??????\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ????§???¢\n//   ????????????????????°??????????????´??? ??? ?????¢???????´????edge(void)???O(????????°)???edge().begin()????????£????????????????????????????????????????????????\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<utility>\nclass Polygon {\npublic:\n  // ??¨???\n  void add(const Point& p);\n  void clear();\n  // ?????±\n  int size() const;\n  Point vertex(const int n) const;\n  Segment edge(const int n) const;\n  const std::vector<Point>& vertex() const;\n  const std::vector<Segment>& edge() const;\n  // ??????\n  bool touch(const Point& p) const;\n  bool intersect(const Point& p) const;\n  D area() const;\n  bool convex() const;\n  // ???????§???¢\n  const Polygon convex_hull() const;\n  D convex_diameter() const;\n  const Polygon convex_cut(const Line& l) const;\nprivate:\n  std::vector<Point> vertex_;\n  std::vector<Segment> edge_;\n};\n// ??¨???\nvoid Polygon::add(const Point& p) {\n  if(!vertex_.empty()) {\n    if(!edge_.empty()) edge_.pop_back();\n    edge_.push_back(Segment(vertex_.back(), p));\n    edge_.push_back(Segment(p, vertex_.front()));\n  }\n  vertex_.push_back(p);\n}\nvoid Polygon::clear() {\n  vertex_.clear();\n  edge_.clear();\n};\n// ?????±\nint Polygon::size() const {return vertex_.size();}\nPoint Polygon::vertex(const int n) const {return vertex_.at(n);}\nSegment Polygon::edge(const int n) const {return edge_.at(n);}\nconst std::vector<Point>& Polygon::vertex() const {return vertex_;}\nconst std::vector<Segment>& Polygon::edge() const {return edge_;}\n// ??????\nbool Polygon::touch(const Point& p) const {\n  return std::any_of(std::begin(edge()), std::end(edge()), [=](const Segment& s) {return ccw(s.initial, s.terminal, p) == ON_SEGMENT;});\n}\nbool Polygon::intersect(const Point& p) const {\n  bool in = false;                    // p=(x,y)??????(INF,y)???????????´?????¨????§???¢??¨????????????????????° mod 2\n  for(const auto& e: edge()) {\n    if(::intersect(p, e)) return true;\n    Point a = e.initial  - p;\n    Point b = e.terminal - p;\n    if(a.y > b.y) std::swap(a, b);\n    if(a.y < EPS && EPS <= b.y && cross(a, b) < EPS) in = !in;\n  }\n  return in;\n}\nD Polygon::area() const {\n  return std::abs(std::accumulate(std::begin(edge()), std::end(edge()), 0.0, [=](const D sum, const Segment& e){return sum + cross(e.initial, e.terminal);})) / 2.0;\n}\nbool Polygon::convex() const {\n  bool positive = false;\n  bool negative = false;\n  for(int i = 0; i < size(); ++i) {\n    auto position = ccw(vertex(i), vertex((i + 1) % size()), vertex((i + 2) % size()));\n    positive |= position == CLOCKWISE;\n    negative |= position == COUNTER_CLOCKWISE;\n    if(negative && positive) return false;\n  }\n  return true;\n}\n// ???????§???¢\n// Andrew's Monotone Chain: O(n log n)\nconst Polygon Polygon::convex_hull() const {\n  auto original = vertex();\n  std::sort(std::begin(original), std::end(original));\n  original.insert(std::end(original), original.rbegin() + 1, original.rend());\n  std::vector<Point> point;\n  for(const auto& p: original) {\n    while(point.size() >= 2 && ccw(point[point.size() - 2], point.back(), p) == CLOCKWISE) point.pop_back();\n    point.push_back(p);\n  }\n  Polygon convex_hull;\n  point.pop_back();\n  for(const auto& p: point) convex_hull.add(p);\n  return convex_hull;\n}\n// Rotating calipers: O(n)\nD Polygon::convex_diameter() const {\n  auto point = vertex();\n  int p, q, start_p, start_q, max_p, max_q;\n  p = start_p = max_p = std::min_element(std::begin(point), std::end(point)) - std::begin(point);\n  q = start_q = max_q = std::max_element(std::begin(point), std::end(point)) - std::begin(point);\n  D max_d = norm(vertex(p) - vertex(q));\n  do {\n    if(cross(vertex((p + 1) % size()) - vertex(p), vertex((q + 1) % size()) - vertex(q)) >= 0) q = (q + 1) % size();\n    else p = (p + 1) % size();\n    if(norm(vertex(p) - vertex(q)) > max_d) {\n      max_d = norm(vertex(p) - vertex(q));\n      max_p = p;\n      max_q = q;\n    }\n  } while(start_p != q || start_q != p);\n  return std::sqrt(max_d);\n}\nconst Polygon Polygon::convex_cut(const Line& l) const {\n  Polygon result;\n  for(const auto& e: edge()) {\n    if(ccw(l.initial, l.terminal, e.initial) == COUNTER_CLOCKWISE) result.add(e.initial);\n    if(::intersect(e, l)) result.add(crosspoint(e, l));\n  }\n  return result;\n}\n////////////////////////////////////////////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  Circle c;\n  cin >> c.center.x >> c.center.y >> c.radius;\n  int q;\n  cin >> q;\n  for(auto i=0;i<q;++i){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    auto cp = crosspoint(c, Line(x1, y1, x2, y2));\n    cout<<cp.size()<<endl;\n    if(cp[0] > cp[1]) swap(cp[0], cp[2]);\n    cout << setprecision(8) << fixed << cp[0].x << \" \" << cp[0].y << \" \" << cp[1].x << \" \" << cp[1].y << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-8; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}\n\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tsort(_all(res));\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAX = 1e2 + 5;\nconst int L = 2;\nconst LL MOD = 10000;\nconst int dir[MAX][MAX] = {{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,1},{1,-1}};\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tPoint o;\n\tdouble r;\n\tscanf(\"%lf%lf%lf\", &o.x, &o.y, &r);\n\tint T;\n\tsfi(T);\n\twhile(T--)\n\t{\n\t\tLine l;\n\t\tscanf(\"%lf%lf%lf%lf\", &l.a.x, &l.a.y, &l.b.x, &l.b.y);\n\t\tPoint ret[3];\n\t\tint num;\n\t\tcircle_cross_line(l.a, l.b, o, r, ret, num);\n\t\tif(num == 1)\n\t\t\tret[1].x = ret[0].x, ret[1].y = ret[0].y;\n\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", ret[0].x, ret[0].y, ret[1].x, ret[1].y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // ????????\\???\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // ????????????????????????\nld dot(Point a, Point b) { return real(conj(a) * b); } // ??????\nld cross(Point a, Point b) { return imag(conj(a) * b); } // ??????\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t // ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n/* ???????????? */\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// ????????´????????????\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// ?????????????????????\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* ?????¢ */\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tCircle c; c.p = input_point(); cin >> c.r;\n\tint q; cin >> q;\n\tfor (int i = 0; i < q;i++) {\n\t\tcout << fixed << setprecision(10);\n\t\tLine l(input_point(), input_point());\n\t\tauto ps = is_sc(c, l);\n\t\tsort(ps.begin(), ps.end());\n\t\tfor (int i = 0; i < 2;i++) {\n\t\t\tcout << ps[i].real() << \" \" << ps[i].imag();\n\t\t\tif (i == 0) cout << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\tcout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tif (equals(pr.abs(), r)) {\n\t\tVector ans = center + pr;\n\t\treturn make_pair(ans, ans);\n\t} else {\n\t\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * r;\n\t\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * r;\n\t\tif (ans1.x < ans2.x) {\n\t\t\treturn make_pair(ans1, ans2);\n\t\t} else {\n\t\t\treturn make_pair(ans2, ans1);\n\t\t}\n\t}\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return a.X==b.X?a.Y<b.Y:a.X<b.X;\n  }\n}\nbool cmp_x(const P& a,const P& b){ return abs(a.X-b.X)<eps?a.Y<b.Y:a.X<b.X; }\nbool cmp_y(const P& a,const P& b){ return abs(a.Y-b.Y)<eps?a.X<b.X:a.Y<b.Y; }\nbool cmp_a(const P& a,const P& b){ return arg(a)==arg(b)?norm(a)<norm(b):arg(a)<arg(b); }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD toRag(D deg){ return deg*PI/180.0; }\nP rot(P base,P a,D theta){ return base+polar(abs(a-base),arg(a-base)+theta); }\n\nstruct L : public vector<P> { // line and segment\n  L(P a,P b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nstruct C{\n  P p; D r;\n  C(P p,D r):p(p),r(r){}\n};\n\nenum RELATION{SAME=1,CONTAINED=2,OVER=4,NO_CROSS=8,ONE_CROSS=16,ONE_CONTAINED_CROSS=32,ONE_OVER_CROSS=64,TWO_CROSS=128};\nint cRel(C c1, C c2) {\n  D d=abs(c1.p-c2.p);\n  D dr1=c1.r-c2.r,dr2=c2.r-c1.r;\n  D ar=c1.r+c2.r;\n  if(d<eps&&c1.r==c2.r)return SAME;\n  if(d<dr1)return OVER;\n  if(d<dr2)return CONTAINED;\n  if(d==dr1)return ONE_OVER_CROSS;\n  if(d==dr2)return ONE_CONTAINED_CROSS;\n  if(d==ar)return ONE_CROSS;\n  if(d>ar)return NO_CROSS;\n  return TWO_CROSS;\n}\n\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\n\nvector<P> crosspointCL(C c,L l){\n  vector<P> res;\n  P q=projection(l,c.p);\n  double d=sqrt(c.r*c.r-abs(c.p-q)*abs(c.p-q));\n  P base=l[1]-l[0];\n  res.push_back(q+base*(d/abs(base)));\n  res.push_back(q-base*(d/abs(base)));\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  D cx,cy,cr;\n  cin>>cx>>cy>>cr;\n  C c1=C(P(cx,cy),cr);\n\n  int q;\n  cin>>q;\n  while(q--){\n    D x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    vector<P> res=crosspointCL(c1,L(P(x1,y1),P(x2,y2)));\n    sort(all(res),cmp_x);\n    printf(\"%.10Lf %.10Lf %.10Lf %.10Lf\\n\", res[0].X,res[0].Y,res[1].X,res[1].Y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr ll mod = 1e9 + 7;\n\ntemplate <class T> inline bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <class T> inline bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point operator+(const Point &p) { return Point{x + p.x, y + p.y}; }\n    Point operator-(const Point &p) { return Point{x - p.x, y - p.y}; }\n    Point operator*(const double k) { return Point{x * k, y * k}; }\n    Point operator/(const double k) { return Point{x / k, y / k}; }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n};\ntypedef Point Vector;\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector v) { return v.x * v.x + v.y * v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nbool isOrthogonal(Vector a, Vector b) { return dot(a, b) == 0; }\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Line l1, Line l2) {\n    return isOrthogonal(l1.p2, l1.p1, l2.p2, l2.p1);\n}\n\nbool isParallel(Vector a, Vector b) { return cross(a, b) == 0; }\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Line l1, Line l2) {\n    return isParallel(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\nPoint project(Line l, Point p) {\n    Vector base = l.p2 - l.p1;\n    double r = dot(p - l.p1, base) / base.norm();\n    return l.p1 + base * r;\n}\nPoint reflect(Line l, Point p) { return p + (project(l, p) - p) * 2; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > 0) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < 0) return CLOCKWISE;\n    if(dot(a, b) < 0) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n           ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < 0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n    if(intersect(s1, s2)) return 0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2),\n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\nPoint getCrossPoint(Line l1, Line l2) {\n    Vector base = l2.p2 - l2.p1;\n    double d1 = abs(cross(base, l1.p1 - l2.p1));\n    double d2 = abs(cross(base, l1.p2 - l2.p1));\n    double t = d1 / (d1 + d2);\n    return l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n    Circle c;\n    cin >> c.c.x >> c.c.y >> c.r;\n    int n;\n    cin >> n;\n    while(n--) {\n        Line l;\n        cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n        pair<Point, Point> ret = getCrossPoints(c, l);\n        Point a = ret.first, b = ret.second;\n        if(a.x == b.x ? a.y > b.y : a.x > b.x) swap(a, b);\n        printf(\"%.10f %.10f %.10f %.10f\\n\", a.x, a.y, b.x, b.y);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <utility>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n  double x, y;\n  Point() {};\n  Point(double x, double y): x(x), y(y) {}\n\n  Point operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n  Point operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double d) { return Point(d * x, d * y); }\n  Point operator / (double d) { return Point(x / d, y / d); }\n\n  bool operator < (const Point &p) const {\n    return (x == p.x ? y < p.y : x < p.x);\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend ostream& operator << (ostream &os, Point &p) {\n    return os << \"Point(\" << p.x << \", \" << p.y << \")\";\n  }\n};\n\nclass Circle {\npublic:\n  Point center;\n  double radius;\n  Circle(double x, double y, double r): center(x, y), radius(r) {}\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n  Point p1, p2;\n};\n\ndouble norm(Point p) {\n  return p.x * p.x + p.y * p.y;\n}\n\ndouble abs(Point p) {\n  return sqrt(norm(p));\n}\n\ndouble dot(Vector v1, Vector v2) {\n  return v1.x * v2.x + v1.y * v2.y;\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n\npair<Point, Point> cross_points(Circle c, Segment s) {\n  Vector pr = project(s, c.center);\n  Vector unit_v = (s.p2 - s.p1) / abs(s.p2 - s.p1);\n  double base = sqrt(c.radius * c.radius - norm(pr - c.center));\n\n  Point cp0 = pr + unit_v * base;\n  Point cp1 = pr - unit_v * base;\n\n  if (cp0.x < cp1.x || (cp0.x == cp1.x && cp0.y <= cp1.y))\n    return make_pair(cp0, cp1);\n\n  return make_pair(cp1, cp0);\n}\n\nint main() {\n  int x, y, r; cin >> x >> y >> r;\n  Circle c(x, y, r);\n\n  int q; cin >> q;\n\n  while (q--) {\n    double x1, y1, x2, y2;\n\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    Segment s;\n    s.p1 = Point(x1, y1);\n    s.p2 = Point(x2, y2);\n\n    pair<Point, Point> ps = cross_points(c, s);\n\n    cout << fixed << setprecision(10)\n         << ps.first.x << ' ' << ps.first.y\n         << ' ' << ps.second.x << ' ' << ps.second.y\n         << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X)\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nnamespace Geometry{\n  #define EPS (1e-10)\n  #define equals(a,b) (fabs((a)-(b)) < EPS)\n\n  class Point{\n  public:\n    double x,y;\n\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n\n    bool operator < (const Point &p) const{\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n      return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS);\n    }\n\n    friend ostream& operator << (ostream &os,Point &p){\n      return os << p.x << \" \" << p.y;\n    }\n\n    friend istream& operator >> (istream &is,Point &p){\n      return is >> p.x >> p.y;\n    }\n  };\n  typedef Point Vector;\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &p){\n      return os << p.p1.x << \" \" << p.p1.y << \" \" << p.p2.x << \" \" << p.p2.y;\n    }\n\n    friend istream& operator >> (istream &is,Segment &p){\n      return is >> p.p1.x >> p.p1.y >> p.p2.x >> p.p2.y;\n    }\n  };\n  typedef Segment Line;\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){\n      return os << c.c.x << c.c.y << c.r;\n    }\n\n    friend istream& operator >> (istream &is,Circle &c){\n      return is >> c.c.x >> c.c.y >> c.r;\n    }\n  };\n\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){\n    return  a.x * a.x + a.y * a.y;\n  }\n\n  double abs(Vector a){\n    return sqrt(norm(a));\n  }\n\n  double dot(Vector a,Vector b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  double cross(Vector a,Vector b){\n    return a.x * b.y - a.y * b.x;\n  }\n\n  bool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n  }\n\n  bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1 - a1,b1 - b2);\n  }\n\n  bool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0);\n  }\n\n  bool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n  }\n\n  bool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1 - a2 , b1 - b2);\n  }\n\n  bool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n  }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base / norm(base));\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n\n  int ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n\n  bool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n  }\n\n  double getDistance(Vector a,Vector b){\n    return abs(a - b);\n  }\n\n  double getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1));\n  }\n\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n              min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    // cassert(intersect(c,l));\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){\n    return atan2(p.y,p.x);\n  }\n\n  Vector polar(double a,double r){\n    return Point(cos(r) * a, sin(r) * a);\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    // assert(intersect(c1,c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n\n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y < b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  Polygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0;i--){\n      for(int n = l.size();n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--)l.push_back(u[i]);\n    return l;\n  }\n\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  Circle c;\n  Line a;\n  cin >> c;\n  cin >> n;\n  while(n--){\n    cin >> a;\n    pair<Point,Point> ans = getCrossPoints(c,a);\n    if(ans.first.x < ans.second.x)fprints(10,ans.first,ans.second);\n    else if(ans.first.x == ans.second.y){\n      if(ans.first.y < ans.second.y)fprints(10,ans.first,ans.second);\n      else fprints(10,ans.second,ans.first);\n    }else{\n      fprints(10,ans.second,ans.first);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\n// BEGIN CUT HERE\nstruct C { P o; R r; };\nV<P> intxnCL(C c, L l) {\n  int s = sgn(distPL(c.o, l), c.r);\n  if (s > 0) return {};\n  P p = proj(c.o, l);\n  if (!s) return {p};\n  P q = sqrt(c.r * c.r - norm(p - c.o)) * l.vec() / l.abs();\n  return {p - q, p + q};\n}\n// END CUT HERE\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  C c; cin >> c.o >> c.r;\n  int q; cin >> q;\n  while (q--) {\n    L l; cin >> l.s >> l.t;\n    auto ps = intxnCL(c, l);\n    if (ps.size() < 2) ps.push_back(ps.back());\n    sort(begin(ps), end(ps), cmp);\n    cout << ps[0] << ' ' << ps[1] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\nstruct circle { point p; double r; };\nstruct line { point p, q; };\n\nconst double eps = 1e-9;\n\ndouble sign(double x) { return x < -eps ? -1 : x > eps; }\n\ndouble dot(point a, point b) { return real(conj(a) * b); }\n\n// circle-line intersection\nvector<point> intersect(line L, circle C)\n{\n\tpoint u = L.p - L.q, v = L.p - C.p;\n\tdouble a = dot(u, u), b = dot(u, v), c = dot(v, v) - C.r*C.r;\n\tdouble det = b*b - a*c;\n\tif (sign(det) < 0) return {};              // no solution\n\tif (sign(det) == 0) return {L.p - b/a*u}; // touch\n\treturn {L.p + (-b + sqrt(det))/a*u,\n\t\t\tL.p + (-b - sqrt(det))/a*u};\n}\n\npoint read(){\n\tdouble x, y; cin >> x >> y;\n\treturn point(x, y);\n}\n\nnamespace std\n{\n\tbool operator<(point a, point b)\n\t{\n\t\tif (a.real() != b.real())\n\t\t\treturn a.real() < b.real();\n\t\treturn a.imag() < b.imag();\n\t}\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tpoint c = read(); \n\tdouble r; cin >> r;\n\tcircle cir = {c, r};\n\n\tint n; cin >> n;\n\n\tfor (int i = 0; i < n; ++i){\n\t\tpoint p = read(), q = read();\n\t\tline l = {p, q};\n\t\tauto ans = intersect(l, cir);\n\t\tif (ans.size() == 1) ans.push_back(ans[0]);\n\t\tsort(ans.begin(), ans.end());\n\t\tcout.precision(20);\n\t\tfor (auto pp : ans)\n\t\t\tcout << fixed << pp.real() << \" \" << pp.imag() << \" \";\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\nP projection(P a1, P a2, P p) {\n    return a1 + dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// ??´??? a1, a2 ??¨??? C ??¨?????????\nvector<P> crossp_lc(P a1, P a2, C c) {\n    vector<P> ps;\n    double r = c.second;\n    P ft = projection(a1, a2, c.first);\n    if(!GE(r*r, norm(ft-c.first))) return ps;\n\n    P dir = sqrt(max(r*r - norm(ft-c.first), 0.0)) / abs(a2-a1) * (a2-a1);\n    ps.push_back(ft + dir);\n    if(!EQ(r*r, norm(ft-c.first))) ps.push_back(ft - dir);\n    return ps;\n}\n\nint main() {\n    C a;\n    cin >> a.fr.X >> a.fr.Y >> a.sc;\n    int n; cin >> n;\n    rep(i,0,n) {\n        P x, y;\n        cin >> x.X >> x.Y >> y.X >> y.Y;\n        vector<P> ans = crossp_lc(x, y, a);\n        if(ans.size() == 1) {\n            printf(\"%.10f %.10f %.10f %.10f\\n\", ans[0].X, ans[0].Y, ans[0].X, ans[0].Y);\n        }\n        else {\n            sort(ans.begin(), ans.end());\n            printf(\"%.10f %.10f %.10f %.10f\\n\", ans[0].X, ans[0].Y, ans[1].X, ans[1].Y);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct point{\n    double  x,y;\n    point(){};\n    point(double x,double y):x(x),y(y){}\n    point operator + (point p){\n        return point(x+p.x,y+p.y);\n    }\n    point operator - (point p){\n        return point(x-p.x,y-p.y);\n    }\n    point operator * (double k){\n        return point(x*k,y*k);\n    }\n    point operator / (double k){\n        return point(x/k,y/k);\n    }\n};\n\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(point a,point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(point p)\n{\n    return p.x*p.x+p.y*p.y;\n}\ndouble ABS(point p)\n{\n    return sqrt(norm(p));\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/norm(base);\n    return a+(base*r);\n}\n\npair<point,point>getcrosspoints(point a,int r,point b,point c)\n{\n    point pr=project(b,c,a);\n    point e=(b-c)/ABS(b-c);\n    double base=sqrt(r*r*1.0-norm(pr-a));\n    e=e*base;\n    return make_pair(pr+e,pr-e);\n}\n\nint main()\n{\n    point a;\n    int temp;\n    cin>>a.x>>a.y>>temp;\n    int q;\n    cin>>q;\n    point c,d;\n    for(int i=0;i<q;i++){\n        cin>>c.x>>c.y>>d.x>>d.y;\n        pair<point,point>res=getcrosspoints(a,temp,c,d);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n\nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n\ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n\nP Vector(L a){\n  return a.second-a.first;\n}\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n\ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n\n\nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n\nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n\nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n\nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n\nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n\nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n\nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n\nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n\ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n\ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n\ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n\nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\n\n \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvecP cutConvex(vecP &t,L l){\n  P a=l.first, b=l.second;\n  int N=t.size();\n  vecP res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C==-D&&abs(C)==1)res.push_back(getCrossLL( l ,L(c,d) ));\n  }\n  return res;\n}\n\nP getVector(const vecP &t, int id){\n  int n=t.size();\n  return t[ (id+1)%n ] - t[id%n];\n}\n\ndouble convex_diameter(vecP &t) {\n  int n = t.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(t[i]) > imag(t[is])) is = i;\n    if (imag(t[i]) < imag(t[js])) js = i;\n  }\n  double maxd = norm(t[is]-t[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    \n    if (cross( getVector(t,i), getVector(t,j)) >= 0) j = (j+1) % n;\n    \n    else i = (i+1) % n;\n    if (norm(t[i]-t[j]) > maxd) {\n      maxd = norm(t[i]-t[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nbool compare_y(const P &a,const P &b){\n  return a.imag() < b.imag();\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return 1e30;\n  int m = n / 2;\n  double x = a[m].real();\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if( abs(a[i].real() - x) >= d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dx = real(a[i] - b[b.size() - j - 1]);\n      double dy = imag(a[i] - b[b.size() - j - 1]);\n      if(dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nP _pool[200005];\ndouble minDist(vecP &t){\n  int n=t.size();\n  for(int i=0;i<n;i++)_pool[i]=t[i];\n  sort( _pool, _pool+n);\n  return closest_pair(_pool, n);\n}\n\nint getStateCC(C a,C b){\n  double ar=a.second, br=b.second;\n  double dist=abs(a.first-b.first);\n  if(dist>ar+br+eps)return 4;\n  if(dist>ar+br-eps)return 3;\n  if(dist>abs(ar-br)+eps)return 2;\n  if(dist>abs(ar-br)-eps)return 1;\n  return 0;\n}\n\nP getCrossCC(C a,C b){\n  P p1=a.first, p2=a.second;\n  double r1=a.second, r2=b.second;\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,Sqrt(1.0-cA*cA));\n}\n\nS getTangentCP(C a,P p){\n  P base=a.first-p;\n  double ar=a.second;\n  double w=Sqrt(norm(base)-ar*ar);\n  P s=p+base*P(w,ar)/norm(base)*w;\n  P t=p+base*P(w,-ar)/norm(base)*w;\n  return S(s,t);\n}\n\nS getInTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double w=ar+br;\n  double h=Sqrt(norm(base)-w*w);\n  P k=base*P(w,h*flg)/norm(base);\n  return S(ap+k*ar,bp-k*br);\n}\n  \nS getOutTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double h=br-ar;\n  \n  double w=Sqrt(norm(base)-h*h);\n  P k=base*P(w,h*flg)/norm(base)*P(0,flg);\n  return S(ap+k*ar,bp+k*br);\n}\n  \nvector<S> getTangent(C a,C b){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  vector<S> res;\n  double dist=abs(ap-bp);\n    \n  if(dist>ar+br+eps)\n    res.push_back(getInTangent(a,b,1));\n  \n  if(dist>ar+br-eps)\n    res.push_back(getInTangent(a,b,-1));\n  \n  if(dist>abs(ar-br)+eps)\n    res.push_back(getOutTangent(a,b,1));\n  \n  if(dist>abs(ar-br)-eps)\n    res.push_back(getOutTangent(a,b,-1));\n  \n  return res;\n}\n\n\nvecP getCrossCL(C cir,L l){\n  P a=l.first, b=l.second;\n  double cr=cir.second;\n  P cp=cir.first;\n  \n  vecP res;\n  P base=b-a,  target=project(a,b,cp);\n  \n  double length=abs(base), h=abs(cp-target);\n  base/=length;\n  \n  if(cr+eps<h)return res;\n  double w=Sqrt(cr*cr-h*h);\n  double L=getTime( normal(b-a) ,target-a)-w,  R=L+w*2.0;\n  \n  res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  res.push_back(a+base*R);\n\n  return res;\n}\n\nvecP getCrossCS(C cir,S s){\n  vecP tmp=getCrossCL(cir,s);\n  vecP res;\n  for(int i=0;i<(int)tmp.size();i++)\n    if( ccw(s.first,s.second, tmp[i] ) == 0)\n      res.push_back(tmp[i]);\n  return res;\n}\n\ndouble getArea(C c,P a,P b){\n  P cp=c.first;\n  double cr=c.second;\n  \n  P va=cp-a,  vb=cp-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=distSP( S(a,b) ,cp), res=0;\n  \n  if( eq(0, f ) )return 0;\n  if(A<cr+eps&&B<cr+eps)return f*0.5;\n  if(d>cr-eps)return cr*cr*PI*getArg(va,vb)/PI2;\n   \n  vecP u=getCrossCS(c, S(a,b) );\n  \n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getCrossArea(vecP t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\n\ndouble calcArea(const vecP &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++){\n    res+= cross( t[ (i+1)%n ],t[i] );\n  }\n  return abs(res)*0.5;\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\nvoid pr(P p,string str){\n  printf(\"%.10f %.10f\",p.real(),p.imag());\n  cout<<str;\n}\n\n\nint main(){\n\n  C a,b;\n  a.first=input();\n  cin>>a.second;\n\n  int n;\n  cin>>n;\n  while(n--){\n    P s=input();\n    P t=input();\n    vecP ans = getCrossCS( a, L(s,t));\n    if(ans.size()==1)ans.push_back(ans[0]);\n    sort(ans.begin(),ans.end());\n    pr(ans[0],\" \");\n    pr(ans[1],\"\\n\"); \n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\n// common\n#define X real()\n#define Y imag()\n\nusing Vector2 = complex<double>;\nusing Line = pair<Vector2, Vector2>;\nusing Segment = pair<Vector2, Vector2>;\nconst double EPS = 1e-10;\nconst double PI = 3.14159265359;\n\nbool equals(double a, double b){\n    if(abs(a - b) < EPS){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\n// struct\n\nstruct Circle{\n    Vector2 c;\n    double r;\n    Circle(Vector2 c, double r){\n        this->c = c;\n        this->r = r;\n    }\n};\n\n// Vector2\ndouble abs(Vector2 v){\n    return sqrt(norm(v));\n}\n\ndouble dot(Vector2 a, Vector2 b){\n    return (a.X * b.X + a.Y * b.Y);\n}\n\ndouble cross(Vector2 a, Vector2 b){\n    return (a.X * b.Y - a.Y * b.X);\n}\n\nVector2 project(Line l, Vector2 p){\n    Vector2 base = l.second - l.first;\n    double r = dot(p - l.first, base) / norm(base);\n    return l.first + base * r;\n}\n\npair<Vector2, Vector2> crossPoints(Circle c, Line l){\n    Vector2 pr = project(l, c.c);\n    Vector2 e = (l.second - l.first) / abs(l.second - l.first);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint main(){\n\n    int cx, cy, r;\n    cin >> cx >> cy >> r;\n    Circle c(Vector2(cx, cy), r);\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; i++){\n        int x0, y0, x1, y1;\n        cin >> x0 >> y0 >> x1 >> y1;\n        Line l(Vector2(x0, y0), Vector2(x1, y1));\n        \n        auto ans = crossPoints(c, l);\n        Vector2 ansMin, ansMax;\n        if(equals(ans.first.X, ans.second.X)){\n            if(ans.first.Y < ans.second.Y){\n                ansMin = ans.first;\n                ansMax = ans.second;\n            }\n            else{\n                ansMin = ans.second;\n                ansMax = ans.first;\n            }\n        }\n        else{\n            if(ans.first.X < ans.second.X){\n                ansMin = ans.first;\n                ansMax = ans.second;\n            }\n            else{\n                ansMin = ans.second;\n                ansMax = ans.first;\n            }\n        }\n\n        cout << fixed << setprecision(8) << ansMin.X << \" \" << ansMin.Y << \" \" << ansMax.X << \" \" << ansMax.Y << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n \nint main()\n{\n    double cx = 0, cy = 0, r = 0;\n    int q = 0;\n    double x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n \n    cin >> cx >> cy >> r >> q;\n \n    for (int i = 0; i < q; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n \n        double a = 0, b = 0, s = 0, t = 0, u = 0,\n            v1 = 0, v2 = 0, w1 = 0, w2 = 0;\n \n        if (x1 == x2) {\n            v1 = x1;\n            v2 = x2;\n            w1 = cy - sqrt(r * r - (x1 - cx) * (x1 - cx));\n            w2 = cy + sqrt(r * r - (x1 - cx) * (x1 - cx));\n        }\n        else {\n            a = (y2 - y1) / (x2 - x1);\n            b = (x2 * y1 - x1 * y2) / (x2 - x1);\n \n            s = a * a + 1;\n            t = a * b - a * cy - cx;\n            u = cx * cx + (b - cy) * (b - cy) - r * r;\n \n            v1 = (-t - sqrt(t * t - s * u)) / s;\n            v2 = (-t + sqrt(t * t - s * u)) / s;\n            w1 = a * v1 + b;\n            w2 = a * v2 + b;\n        }\n \n        cout << setiosflags(ios::fixed | ios::showpoint) << setprecision(8)\n             << v1 << \" \" << w1 << \" \" << v2 << \" \" << w2 << endl;\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std; int DIGITS = 14;\nlong double X, Y, R, X1, Y1, X2, Y2; int Q;\nstruct Point { long double px, py; }; struct Segment { Point p1, p2; };\nPoint Minus(Point a, Point b) { Point G; G.px = a.px - b.px; G.py = a.py - b.py; return G; }\nPoint Times(Point a, long double b) { Point J; J.px = a.px*b; J.py = a.py*b; return J; }\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint prj(Segment a, Point b) {\n\tPoint c = Minus(a.p2, a.p1); Point D = Times(c, dot(Minus(b, a.p1), c));\n\tD = Times(D, 1.0 / norm(c)); return Minus(D, Times(a.p1, -1));\n}\nint main() {\n\tcin >> X >> Y >> R >> Q; Point H; H.px = X; H.py = Y;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> X1 >> Y1 >> X2 >> Y2; Point A1, A2; A1.px = X1; A1.py = Y1; A2.px = X2; A2.py = Y2;\n\t\tSegment S; S.p1 = A1; S.p2 = A2; Point I = prj(S, H); Point K = Minus(A2, A1); K = Times(K, 1 / sqrt(norm(K)));\n\t\tdouble base = sqrt(R*R - norm(Minus(I, H))); K = Times(K, base);\n\t\tPoint L[2]; L[0] = Minus(I, K); L[1] = Minus(I, Times(K, -1));\n\t\tif (L[0].px > L[1].px) { swap(L[0], L[1]); }\n\t\telse if (L[0].px == L[1].px && L[0].py > L[1].py) { swap(L[0], L[1]); }\n\t\tcout << fixed << setprecision(DIGITS) << L[0].px << ' ' << fixed << setprecision(DIGITS) << L[0].py << ' ';\n\t\tcout << fixed << setprecision(DIGITS) << L[0].px << ' ' << fixed << setprecision(DIGITS) << L[0].py << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\npair<Point,Point>getCrossPoints(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\nint main(){\n    Circle c;\n    getCircle(c);\n\n    int q;\n    scanf(\"%d\",&q);\n\n    while(q--){\n\n        Line l;\n        getLine(l);\n        pair<Point,Point>x=getCrossPoints(c,l);\n        if(!cmpx(x.first,x.second))swap(x.first,x.second);\n        printf(\"%.20lf %.20lf %.20lf %.20lf\\n\",x.first.real(),x.first.imag(),x.second.real(),x.second.imag());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\nstruct point{\n    int x,y;\n};\n\nstruct line{\n    point s,t;\n};\nstruct bec{\n    int x,y;\n};\nstruct circle{\n    point p;\n    int r;\n};\n\n\n\nvoid solve(circle o, line l){\n    double d;\n    bec p1p,p1p2;\n    p1p.x=o.p.x-l.s.x; p1p.y=o.p.y-l.s.y;\n    p1p2.x=l.t.x-l.s.x; p1p2.y=l.t.y-l.s.y;\n    double c,dp,dp2,k,ansx,ansy;\n    dp=sqrt((double)p1p.x*(double)p1p.x+(double)p1p.y*(double)p1p.y);\n    dp2=sqrt((double)p1p2.x*(double)p1p2.x+(double)p1p2.y*(double)p1p2.y);\n    if(dp==0){\n        d=0;\n        ansx=o.p.x;\n        ansy=o.p.y;\n    }\n    else{\n    c=((double)p1p.x*(double)p1p2.x+(double)p1p.y*(double)p1p2.y)/(dp*dp2);\n    k=dp*c;\n    ansx=l.s.x+k*(p1p2.x/dp2);\n    ansy=l.s.y+k*(p1p2.y/dp2);\n    d = sqrt((o.p.x-ansx)*(o.p.x-ansx)+(o.p.y-ansy)*(o.p.y-ansy));\n    }\n    \n    \n    double co = sqrt(1-(d/o.r)*(d/o.r));\n    double ansx1,ansx2,ansy1,ansy2;\n\n\n    ansx1 = ansx-(o.r*co)*(p1p2.x/dp2);\n    ansx2 = ansx+(o.r*co)*(p1p2.x/dp2);\n    ansy1 = ansy-(o.r*co)*(p1p2.y/dp2);\n    ansy2 = ansy+(o.r*co)*(p1p2.y/dp2);\n    if(ansx1<ansx2) printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n    else if(ansx1==ansx2){\n        if(ansy1<ansy2) printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n        else printf(\"%.8f %.8f %.8f %.8f\\n\",ansx2,ansy2,ansx1,ansy1);\n    }\n    else printf(\"%.8f %.8f %.8f %.8f\\n\",ansx2,ansy2,ansx1,ansy1);\n}\n\nint main(){\n    int cx,cy,x1,x2,y1,y2,n,r;\n    point p,s,t;\n    line l;\n    circle o;\n\n    cin>>cx>>cy>>r;\n    p.x=cx;\n    p.y=cy;\n    o.p=p; o.r=r;\n\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>x1>>y1>>x2>>y2;\n        s.x=x1; s.y=y1;\n        t.x=x2; t.y=y2;\n        l.s=s; l.t=t;\n        solve(o,l);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n#define equals (fabs((a)-(b)<EPS)\nint n;\n\nstruct Point\n{\n    double x, y;\n    Point() {}\n    Point(double x,double y):x(x),y(y) {}\n    Point operator +(Point a)\n    {\n        return Point(x+a.x,y+a.y);\n    }\n    Point operator -(Point a)\n    {\n        return Point(x-a.x,y-a.y);\n    }\n    Point operator *(double a)\n    {\n        return Point(x*a,y*a);\n    }\n    Point operator /(double a)\n    {\n        return Point(x/a,y/a);\n    }\n\n    double norm()\n    {\n        return x*x+y*y;\n    }\n    double abs()\n    {\n        return sqrt(norm());\n    }\n\n};\n\ndouble r;\nPoint PO,p1,p2;\ndouble cross(Point a,Point b)\n{\n    return a.x*b.y-b.x*a.y;\n}\ndouble dot(Point a,Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\nPoint projection()\n{\n    Point a=p2-p1;\n    Point b=PO-p1;\n    double c_ab=cross(a,b);\n    double p1q=sqrt(b.norm()-c_ab*c_ab/a.norm());\n    return p1+a*p1q/a.abs();\n}\nvoid solve()\n{\n    Point a=p2-p1;\n    Point b=PO-p1;\n     double c_ab=cross(a,b);\n    double h2=c_ab*c_ab/a.norm();\n    double d=sqrt(r*r-h2);\n    Point q=projection();\n    Point e=a/a.abs();\n    Point x1=q-e*d;\n    Point x2=q+e*d;\n    printf(\"%.8lf %.8lf %.8lf %.8lf\\n\",x1.x,x1.y,x2.x,x2.y);\n\n\n\n}\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n\n    scanf(\"%lf%lf%lf\",&PO.x,&PO.y,&r);\n     scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p1.x,&p1.y,&p2.x,&p2.y);\n        solve();\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mm(a,b) memset(a,b,sizeof(a))\n#define ACCELERATE (ios::sync_with_stdio(false),cin.tie(0))\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define pll pair<long long,long long>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define rush() int T;scanf(\"%d\",&T);while(T--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define pf(x) printf(\"%d\\n\",x)\n#define pf2(x,y) printf(\"%d %d\\n\",x,y)\n#define pf3(x,y,z) printf(\"%d %d %d\\n\",x,y,z)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\n#define E exp(1.0)\n#define db double\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n//#define io\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\n//#define gc getchar\n//char buf[1<<21],*p1=buf,*p2=buf;\n//inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\n//inline int read()\n//{\n//    int ret=0,f=0;char c=gc();\n//    while(!isdigit(c)){if(c=='-')f=1;c=gc();}\n//    while(isdigit(c)){ret=ret*10+c-48;c=gc();}\n//    if(f)return -ret;return ret;\n//}\nconst int N=1e2+5;\nconst db EPS=1e-10;\ninline int sign(db a){return a<-EPS?-1:a>EPS;}\ninline int cmp(db a,db b){return sign(a-b);}\ninline db sqr(db x){return x*x;}\nstruct Point{\n    db x,y;\n    Point(){}\n    Point(db _x,db _y):x(_x),y(_y){}\n    void input(){scanf(\"%lf%lf\",&x,&y);}\n    void output(){printf(\"%.10f %.10f\\n\",x,y);}\n    bool operator == (Point b)const{\n        return sign(x-b.x)==0&&sign(y-b.y)==0;\n    }\n    bool operator < (Point b)const{\n        return sign(x-b.x)==0?sign(y-b.y)<0:x<b.x;\n    }\n    Point operator + (const Point &b)const{\n        return Point(x+b.x,y+b.y);\n    }\n    Point operator - (const Point &b)const{\n        return Point(x-b.x,y-b.y);\n    }\n    db operator ^ (const Point &b)const{\n        return x*b.y-y*b.x;\n    }\n    db operator * (const Point &b)const{\n        return x*b.x+y*b.y;\n    }\n    db len(){return hypot(x,y);}\n    db len2(){return x*x+y*y;}\n    db distance(Point p){return hypot(x-p.x,y-p.y);}\n    Point operator * (const db &k)const{\n        return Point(x*k,y*k);\n    }\n    Point operator / (const db &k)const{\n        return Point(x/k,y/k);\n    }\n    db rad(Point a,Point b){\n        Point p=*this;\n        return fabs(atan2(fabs((a-p)^(b-p)),(a-p)*(b-p)));\n    }\n    Point unit(){return *this/len();}\n    Point trunc(db r){\n        db l=len();\n        if(!sign(l))return *this;\n        r/=l;\n        return Point(x*r,y*r);\n    }\n    Point rotleft(){return Point(-y,x);}\n    Point rotright(){return Point(y,-x);}\n    Point rotate(Point p,db angle){\n        Point v=(*this)-p;\n        db c=cos(angle),s=sin(angle);\n        return Point(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n    }\n};\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\nstruct Line{\n    Point s,e;\n    Line(){}\n    Line(Point _s,Point _e):s(_s),e(_e){}\n    bool operator == (Line v){\n        return (s==v.s)&&(e==v.e);\n    }\n    Line(Point p,db angle){\n        s=p;\n        if(sign(angle-PI/2)==0)e=(s+Point(0,1));\n        else e=(s+Point(1,tan(angle)));\n    }\n    Line(db a,db b,db c){\n        if(sign(a)==0){\n            s=Point(0,-c/b);e=Point(1,-c/b);\n        }else if(sign(b)==0){\n            s=Point(-c/a,0);e=Point(-c/a,1);\n        }else{\n            s=Point(0,-c/b);e=Point(1,(-c-a)/b);\n        }\n    }\n    void input(){s.input();e.input();}\n    void adjust(){if(e<s)swap(s,e);}\n    db length(){return s.distance(e);}\n    //[0,PI)\n    db angle(){\n        db k=atan2(e.y-s.y,e.x-s.x);\n        if(sign(k)<0)k+=PI;\n        if(sign(k-PI)==0)k-=PI;\n        return k;\n    }\n    //line|1 on the left|2 on the right|3 on line|\n    int relation(Point p){\n        int c=sign((p-s)^(e-s));\n        if(c<0)return 1;\n        else if(c>0)return 2;\n        else return 3;\n    }\n    bool pointonseg(Point p){\n        return sign((p-s)^(e-s))==0&&sign((p-s)*(p-e))<=0;\n    }\n    bool parallel(Line v){\n        return sign((e-s)^(v.e-v.s))==0;\n    }\n    //|0 not intersect|1 non-standard|2 intersect|\n    int segcrossseg(Line v){\n        int d1=sign((e-s)^(v.s-s));\n        int d2=sign((e-s)^(v.e-s));\n        int d3=sign((v.e-v.s)^(s-v.s));\n        int d4=sign((v.e-v.s)^(e-v.s));\n        if((d1^d2)==-2&&(d3^d4)==-2)return 2;\n        return (d1==0&&sign((v.s-s)*(v.s-e))<=0)||\n            (d2==0&&sign((v.e-s)*(v.e-e))<=0)||\n            (d3==0&&sign((s-v.s)*(s-v.e))<=0)||\n            (d4==0&&sign((e-v.s)*(e-v.e))<=0);\n    }\n    //|0 not intersect|1 non-standard|2 intersect|\n    int linecrossseg(Line v){\n        int d1=sign((e-s)^(v.s-s));\n        int d2=sign((e-s)^(v.e-s));\n        if((d1^d2)==-2)return 2;\n        return (d1==0||d2==0);\n    }\n    //|0 parallel|1 coincides|2 intersect|\n    int linecrossline(Line v){\n        if((*this).parallel(v))return v.relation(s)==3;\n        return 2;\n    }\n    //要保证两直线不平行或重合\n    Point crosspoint(Line v){\n        db a1=(v.e-v.s)^(s-v.s);\n        db a2=(v.e-v.s)^(e-v.s);\n        return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1));\n    }\n    db dispointtoline(Point p){\n        return fabs((p-s)^(e-s))/length();\n    }\n    db dispointtoseg(Point p){\n        if(sign((p-s)*(e-s))<0||sign((p-e)*(s-e))<0)return min(p.distance(s),p.distance(e));\n        return dispointtoline(p);\n    }\n    //前提是两线段不相交，相交距离就是0了\n    db dissegtoseg(Line v){\n        return min(min(dispointtoseg(v.s),dispointtoseg(v.e)),min(v.dispointtoseg(s),v.dispointtoseg(e)));\n    }\n    Point lineprog(Point p){\n\t\treturn s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) );\n\t}\n\tPoint symmetrypoint(Point p){\n\t\tPoint q = lineprog(p);\n\t\treturn Point(2*q.x-p.x,2*q.y-p.y);\n\t}\n};\nstruct circle{\n    Point p;\n    db r;\n    circle(){}\n    circle(Point _p,db _r):p(_p),r(_r){}\n    circle(db _x,db _y,db _r){\n        p=Point(_x,_y);r=_r;\n    }\n    //三角形的外接圆\n    circle(Point a,Point b,Point c){\n        Line u=Line((a+b)/2,((a+b)/2)+((b-a).rotleft()));\n        Line v=Line((b+c)/2,((b+c)/2)+((c-b).rotleft()));\n        p=u.crosspoint(v);\n        r=p.distance(a);\n    }\n    //三角形的内切圆\n    circle(Point a,Point b,Point c,bool t){\n        Line u,v;\n        db m=atan2(b.y-a.y,b.x-a.x),n=atan2(c.y-a.y,c.x-a.x);\n        u.s=a;\n        u.e=u.s+Point(cos((n+m)/2),sin((n+m)/2));\n        m=atan2(a.y-b.y,a.x-b.x),n=atan2(c.y-b.y,c.x-b.x);\n        v.s=b;\n        v.e=v.s+Point(cos((n+m)/2),sin((n+m)/2));\n        p=u.crosspoint(v);\n        r=Line(a,b).dispointtoseg(p);\n    }\n    void input(){\n        p.input();\n        scanf(\"%lf\",&r);\n    }\n    void output(){\n        printf(\"%2.f %.2f %.2f\\n\",p.x,p.y,p,r);\n    }\n    bool operator == (circle v){\n        return (p==v.p)&&sign(r-v.r)==0;\n    }\n    bool operator < (circle v)const{\n        return ((p<v.p)||((p==v.p)&&sign(r-v.r)<0));\n    }\n    db area(){return PI*r*r;}\n    db circumference(){return 2*PI*r;}\n    //|0 not|1 on|2 in|\n    int relation(Point b){\n        db dst=b.distance(p);\n        if(sign(dst-r)<0)return 2;\n        else if(sign(dst-r)==0)return 1;\n        return 0;\n    }\n    //|0 not|1 on|2 in|\n    int relationseg(Line v){\n        db dst=v.dispointtoseg(p);\n        if(sign(dst-r)<0)return 2;\n        else if(sign(dst-r)==0)return 1;\n        return 0;\n    }\n    int relationline(Line v){\n        db dst=v.dispointtoline(p);\n        if(sign(dst-r)<0)return 2;\n        else if(sign(dst-r)==0)return 1;\n        return 0;\n    }\n    //|1 内含|2 内切|3 相交|4 外切|5 相离|\n    int relationcircle(circle v){\n        db d=p.distance(v.p);\n        if(sign(d-r-v.r)>0)return 5;\n        if(sign(d-r-v.r)==0)return 4;\n        db l=fabs(r-v.r);\n        if(sign(d-r-v.r)<0&&sign(d-l)>0)return 3;\n        if(sign(d-l)==0)return 2;\n        if(sign(d-l)<0)return 1;\n    }\n    //|0 没有交点|1 一个交点|2 两个交点|\n    int pointcrosscircle(circle v,Point &p1,Point &p2){\n        int rel=relationcircle(v);\n        if(rel==1||rel==5)return 0;\n        db d=p.distance(v.p);\n        db l=(d*d+r*r-v.r*v.r)/(2*d);\n        db h=sqrt(r*r-l*l);\n        Point tmp=p+(v.p-p).trunc(l);\n        p1 = tmp+((v.p-p).rotleft().trunc(h));\n\t\tp2 = tmp+((v.p-p).rotright().trunc(h));\n        if(rel==2||rel==4)return 1;\n        return 2;\n    }\n    int pointcrossline(Line v,Point &p1,Point &p2){\n        if(!(*this).relationline(v))return 0;\n        Point a=v.lineprog(p);\n        db d=v.dispointtoline(p);\n        d=sqrt(r*r-d*d);\n        if(sign(d)==0){\n            p1=a;p2=a;\n            return 1;\n        }\n        p1=a+(v.e-v.s).trunc(d);\n        p2=a-(v.e-v.s).trunc(d);\n        return 2;\n    }\n};\n//\t//`得到过a,b两点，半径为r1的两个圆`\n//\tint gercircle(Point a,Point b,double r1,circle &c1,circle &c2){\n//\t\tcircle x(a,r1),y(b,r1);\n//\t\tint t = x.pointcrosscircle(y,c1.p,c2.p);\n//\t\tif(!t)return 0;\n//\t\tc1.r = c2.r = r;\n//\t\treturn t;\n//\t}\n//\t//`得到与直线u相切，过点q,半径为r1的圆`\n//\t//`测试：UVA12304`\n//\tint getcircle(Line u,Point q,double r1,circle &c1,circle &c2){\n//\t\tdouble dis = u.dispointtoline(q);\n//\t\tif(sgn(dis-r1*2)>0)return 0;\n//\t\tif(sgn(dis) == 0){\n//\t\t\tc1.p = q + ((u.e-u.s).rotleft().trunc(r1));\n//\t\t\tc2.p = q + ((u.e-u.s).rotright().trunc(r1));\n//\t\t\tc1.r = c2.r = r1;\n//\t\t\treturn 2;\n//\t\t}\n//\t\tLine u1 = Line((u.s + (u.e-u.s).rotleft().trunc(r1)),(u.e + (u.e-u.s).rotleft().trunc(r1)));\n//\t\tLine u2 = Line((u.s + (u.e-u.s).rotright().trunc(r1)),(u.e + (u.e-u.s).rotright().trunc(r1)));\n//\t\tcircle cc = circle(q,r1);\n//\t\tPoint p1,p2;\n//\t\tif(!cc.pointcrossline(u1,p1,p2))cc.pointcrossline(u2,p1,p2);\n//\t\tc1 = circle(p1,r1);\n//\t\tif(p1 == p2){\n//\t\t\tc2 = c1;\n//\t\t\treturn 1;\n//\t\t}\n//\t\tc2 = circle(p2,r1);\n//\t\treturn 2;\n//\t}\n//\t//`同时与直线u,v相切，半径为r1的圆`\n//\t//`测试：UVA12304`\n//\tint getcircle(Line u,Line v,double r1,circle &c1,circle &c2,circle &c3,circle &c4){\n//\t\tif(u.parallel(v))return 0;//两直线平行\n//\t\tLine u1 = Line(u.s + (u.e-u.s).rotleft().trunc(r1),u.e + (u.e-u.s).rotleft().trunc(r1));\n//\t\tLine u2 = Line(u.s + (u.e-u.s).rotright().trunc(r1),u.e + (u.e-u.s).rotright().trunc(r1));\n//\t\tLine v1 = Line(v.s + (v.e-v.s).rotleft().trunc(r1),v.e + (v.e-v.s).rotleft().trunc(r1));\n//\t\tLine v2 = Line(v.s + (v.e-v.s).rotright().trunc(r1),v.e + (v.e-v.s).rotright().trunc(r1));\n//\t\tc1.r = c2.r = c3.r = c4.r = r1;\n//\t\tc1.p = u1.crosspoint(v1);\n//\t\tc2.p = u1.crosspoint(v2);\n//\t\tc3.p = u2.crosspoint(v1);\n//\t\tc4.p = u2.crosspoint(v2);\n//\t\treturn 4;\n//\t}\n//\t//`同时与不相交圆cx,cy相切，半径为r1的圆`\n//\t//`测试：UVA12304`\n//\tint getcircle(circle cx,circle cy,double r1,circle &c1,circle &c2){\n//\t\tcircle x(cx.p,r1+cx.r),y(cy.p,r1+cy.r);\n//\t\tint t = x.pointcrosscircle(y,c1.p,c2.p);\n//\t\tif(!t)return 0;\n//\t\tc1.r = c2.r = r1;\n//\t\treturn t;\n//\t}\n//\n//\t//`过一点作圆的切线(先判断点和圆的关系)`\n//\t//`测试：UVA12304`\n//\tint tangentline(Point q,Line &u,Line &v){\n//\t\tint x = relation(q);\n//\t\tif(x == 2)return 0;\n//\t\tif(x == 1){\n//\t\t\tu = Line(q,q + (q-p).rotleft());\n//\t\t\tv = u;\n//\t\t\treturn 1;\n//\t\t}\n//\t\tdouble d = p.distance(q);\n//\t\tdouble l = r*r/d;\n//\t\tdouble h = sqrt(r*r-l*l);\n//\t\tu = Line(q,p + ((q-p).trunc(l) + (q-p).rotleft().trunc(h)));\n//\t\tv = Line(q,p + ((q-p).trunc(l) + (q-p).rotright().trunc(h)));\n//\t\treturn 2;\n//\t}\n//\t//`求两圆相交的面积`\n//\tdouble areacircle(circle v){\n//\t\tint rel = relationcircle(v);\n//\t\tif(rel >= 4)return 0.0;\n//\t\tif(rel <= 2)return min(area(),v.area());\n//\t\tdouble d = p.distance(v.p);\n//\t\tdouble hf = (r+v.r+d)/2.0;\n//\t\tdouble ss = 2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d));\n//\t\tdouble a1 = acos((r*r+d*d-v.r*v.r)/(2.0*r*d));\n//\t\ta1 = a1*r*r;\n//\t\tdouble a2 = acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d));\n//\t\ta2 = a2*v.r*v.r;\n//\t\treturn a1+a2-ss;\n//\t}\n//\t//`求圆和三角形pab的相交面积`\n//\t//`测试：POJ3675 HDU3982 HDU2892`\n//\tdouble areatriangle(Point a,Point b){\n//\t\tif(sgn((p-a)^(p-b)) == 0)return 0.0;\n//\t\tPoint q[5];\n//\t\tint len = 0;\n//\t\tq[len++] = a;\n//\t\tLine l(a,b);\n//\t\tPoint p1,p2;\n//\t\tif(pointcrossline(l,q[1],q[2])==2){\n//\t\t\tif(sgn((a-q[1])*(b-q[1]))<0)q[len++] = q[1];\n//\t\t\tif(sgn((a-q[2])*(b-q[2]))<0)q[len++] = q[2];\n//\t\t}\n//\t\tq[len++] = b;\n//\t\tif(len == 4 && sgn((q[0]-q[1])*(q[2]-q[1]))>0)swap(q[1],q[2]);\n//\t\tdouble res = 0;\n//\t\tfor(int i = 0;i < len-1;i++){\n//\t\t\tif(relation(q[i])==0||relation(q[i+1])==0){\n//\t\t\t\tdouble arg = p.rad(q[i],q[i+1]);\n//\t\t\t\tres += r*r*arg/2.0;\n//\t\t\t}\n//\t\t\telse{\n//\t\t\t\tres += fabs((q[i]-p)^(q[i+1]-p))/2.0;\n//\t\t\t}\n//\t\t}\n//\t\treturn res;\n//\t}\n//};\ncircle c1;\nLine l;\nint main()\n{\n    #ifdef io\n    freopen(\"in.txt\",\"r\",stdin);\n    #endif\n    c1.input();\n    int q;\n    sc(q);\n    rep(i,1,q){\n        l.input();\n        Point p1,p2;\n        int t=c1.pointcrossline(l,p1,p2);\n        if(p2<p1)swap(p1,p2);\n        printf(\"%.8f %.8f %.8f %.8f\\n\",p1.x,p1.y,p2.x,p2.y);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Vector {\npublic:\n  double x, y;\n  Vector() {}\n  Vector(double x, double y) : x(x), y(y) {}\n\n  Vector operator+(Vector v) { return Vector(x + v.x, y + v.y); }\n  Vector operator-(Vector v) { return Vector(x - v.x, y - v.y); }\n  Vector operator*(double s) { return Vector(s * x, s * y); }\n  Vector operator/(double s) { return Vector(s / x, s / y); }\n  bool operator==(Vector v) { return equals(x - v.x, 0) && equals(y - v.y, 0); }\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\n\n// inner product\ndouble dot(Vector v1, Vector v2) { return v1.x * v2.x + v1.y * v2.y; }\n\n// cross product\ndouble cross(Vector v1, Vector v2) { return v1.x * v2.y - v1.y * v2.x; }\n\nclass Line {\npublic:\n  Vector v1, v2;\n  Line() {}\n  Line(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n  // Vector unit() { return (v2 - v1) / (v2 - v1).abs(); }\n};\nclass Segment {\npublic:\n  Vector v1, v2;\n  Segment() {}\n  Segment(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n  operator Line() const { return Line(v1, v2); }\n};\n\nclass Circle {\npublic:\n  Vector v;\n  double r;\n  Circle() {}\n  Circle(Vector v, double r) : v(v), r(r) {}\n  Circle(double cx, double cy, double cr) {\n    v = Vector(cx, cy);\n    r = cr;\n  }\n};\n\nbool is_parrallel(Vector a, Vector b) { return equals(cross(a, b), 0); }\nbool is_parrallel(Line a, Line b) {\n  return is_parrallel(a.v1 - a.v2, b.v1 - b.v2);\n}\nbool is_parrallel(Segment a, Segment b) {\n  return is_parrallel((Line)a, (Line)b);\n}\n\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0); }\nbool is_orthogonal(Line a, Line b) {\n  return is_orthogonal(a.v1 - a.v2, b.v1 - b.v2);\n}\n\nVector project(Line l, Vector v) {\n  Vector a = v - l.v1;\n  Vector b = l.v2 - l.v1;\n  return l.v1 + b * (dot(a, b) / b.norm());\n}\n\nVector reflect(Line l, Vector v) { return v + (project(l, v) - v) * 2.0; }\n\ndouble distance(Line l, Vector v) { return (v - project(l, v)).abs(); }\ndouble distance(Vector v1, Vector v2) { return (v1 - v2).abs(); }\nbool in_segment(Segment s, Vector v) {\n  return dot(s.v2 - s.v1, v - s.v1) > 0 && dot(s.v1 - s.v2, v - s.v2) > 0;\n}\ndouble distance(Segment s, Vector v) {\n  auto m = project((Line)s, v);\n  if (in_segment(s, m)) {\n    return distance(m, v);\n  } else\n    return min(distance(s.v1, v), distance(s.v2, v));\n}\nbool opposite(Line l, Vector v1, Vector v2) {\n  auto a = l.v2 - l.v1;\n  auto b = v1 - l.v1;\n  auto c = v2 - l.v1;\n  return cross(a, b) * cross(a, c) < 0;\n}\nenum Direction {\n  ONLINE_FRONT = -2,\n  CLOCKWISE = -1,\n  ON_SEGMENT = 0,\n  COUNTER_CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n};\nDirection ccw(Vector v0, Vector v1, Vector v2) {\n  auto a = v1 - v0;\n  auto b = v2 - v0;\n  if (cross(a, b) > 0)\n    return COUNTER_CLOCKWISE;\n  if (cross(a, b) < 0)\n    return CLOCKWISE;\n  if (dot(a, b) < 0)\n    return ONLINE_BACK;\n  if (a.norm() < b.norm())\n    return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nvoid printd(Direction d) {\n  switch (d) {\n  case COUNTER_CLOCKWISE:\n    printf(\"COUNTER_CLOCKWISE\\n\");\n    break;\n  case CLOCKWISE:\n    printf(\"CLOCKWISE\\n\");\n    break;\n  case ONLINE_BACK:\n    printf(\"ONLINE_BACK\\n\");\n    break;\n  case ONLINE_FRONT:\n    printf(\"ONLINE_FRONT\\n\");\n    break;\n  case ON_SEGMENT:\n    printf(\"ON_SEGMENT\\n\");\n    break;\n  }\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return ccw(s1.v1, s1.v2, s2.v1) * ccw(s1.v1, s1.v2, s2.v2) <= 0 &&\n         ccw(s2.v1, s2.v2, s1.v1) * ccw(s2.v1, s2.v2, s1.v2) <= 0;\n}\n\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) {\n    return 0;\n  }\n  return min({distance(s1, s2.v1), distance(s1, s2.v2), distance(s2, s1.v1),\n              distance(s2, s1.v2)});\n}\nVector cross_point(Segment s1, Segment s2) {\n  auto a = s1.v2 - s1.v1;\n  auto d1 = abs(cross(a, s2.v1 - s1.v1));\n  auto d2 = abs(cross(a, s2.v2 - s1.v1));\n  auto r = d1 / (d1 + d2);\n  return s2.v1 + (s2.v2 - s2.v1) * r;\n}\n\npair<Vector, Vector> cross_circle_line(Circle c, Line l) {\n  auto h = project(l, c.v);\n  auto a = (h == c.v) ? c.r : sqrt(c.r * c.r - (h - c.v).norm());\n  auto lv = l.v2 - l.v1;\n  auto b = lv * (a / lv.abs());\n  return make_pair(h + b, h - b);\n}\n\nint main() {\n  int cx, cy, r;\n  cin >> cx >> cy >> r;\n  auto circle = Circle(cx, cy, r);\n\n  int nq;\n  cin >> nq;\n  for (int i = 0; i < nq; i++) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n    auto line = Line(Vector(x0, y0), Vector(x1, y1));\n    auto v = cross_circle_line(circle, line);\n    if (v.first.x > v.second.x)\n      swap(v.first, v.second);\n    printf(\"%.10f %.10f %.10f %.10f\\n\", v.first.x, v.first.y, v.second.x,\n           v.second.y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i = (a); i < (b); ++i)\n#define per(i, a, b) for(int i = (b) - 1; i >= (a); --i)\n#define sz(a) (int)a.size()\n#define de(c) cout << #c << \" = \" << c << endl\n#define dd(c) cout << #c << \" = \" << c << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef db T;\nconst db eps = 1e-9 , pi = acosl(-1.);\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n  T x,y; P(){} P(T x,T y):x(x),y(y){}\n  P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n  P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n  T operator * (const P&b) const {return x*b.x+y*b.y;}\n  T operator / (const P&b) const {return x*b.y-y*b.x;}\n  P operator * (const T&k) const {return P(x*k,y*k);}\n  P operator / (const T&k) const {return P(x/k,y/k);}\n\tbool operator < (const P&b) const {return sgn(x-b.x)?x<b.x:y<b.y;}\n\tbool operator == (const P&b) const{return !sgn(x-b.x)&&!sgn(y-b.y);}\n\tP rot90(){return P(-y,x);}\n};\nT norm(P a){return a*a;}\nT abs(P a) {return sqrtl(norm(a));}\nP proj(P p,P a,P b){return (b-a)*((p-a)*(b-a)/norm(b-a))+a;}\nP reflect(P p,P a,P b){return proj(p,a,b)*2-p;}\nT cross(P o,P a,P b){return (a-o)/(b-o);}\nint crossOp(P o,P a,P b){return sgn(cross(o,a,b));}\nbool onPS(P p,P s,P t){return sgn((t-s)/(p-s))==0&&sgn((p-s)*(p-t))<=0;}\nstruct L{ P s,t;L(){} L(P s,P t):s(s),t(t){}};\nP insLL(L a,L b){ // line x line\n\tP s = a.s - b.s , v = a.t - a.s , w = b.t - b.s;\n\tdb k1 = s / w , k2 = w / v;\n\tif(sgn(k2) == 0) return abs(b.s - a.s) < abs(b.t - a.s) ? b.s : b.t;\n\treturn a.s + v * (k1 / k2);\n}\nbool isSS(L a,L b){ // seg x seg , replace x->y to accelerate\n\tT c1=(a.t-a.s)/(b.s-a.s),c2=(a.t-a.s)/(b.t-a.s);\n\tT c3=(b.t-b.s)/(a.s-b.s),c4=(b.t-b.s)/(a.t-b.s);\n\treturn sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n\t\tsgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n\t\tsgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n\t\tsgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n\t\tsgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\ndb disPL(P p,L a){return fabs((a.t-a.s)/(p-a.s)) / abs(a.t-a.s);}\ndb disPS(P p,L a){ // p x seg dis\n\tif(sgn((a.t-a.s)*(p-a.s)) == -1) return abs(p-a.s);\n\tif(sgn((a.s-a.t)*(p-a.t)) == -1) return abs(p-a.t);\n\treturn disPL(p,a);\n}\ndb disSS(L a,L b){ // seg x seg dis\n\tif(isSS(a,b)) return 0;\n\treturn min(min(disPS(a.s,b),disPS(a.t,b)),min(disPS(b.s,a),disPS(b.t,a)));\n}\ntypedef vector<P> polygon;\npolygon convex(polygon A){ // counter-clockwise , < : <=180 , <= : <180\n  int n=sz(A),m=0;\n  polygon B;B.resize(n<<1);\n  sort(all(A));\n  rep(i,0,n){\n    while(m > 1 && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  int k = m;\n  per(i,0,n-1){\n    while(m > k && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  B.resize(m);\n  if(sz(B) > 1) B.pop_back();\n  return B;\n}\nT area(polygon A) { // multiple 2 with integer type\n\tT res=0;\n\trep(i,0,sz(A)) res+=A[i]/(A[(i+1)%sz(A)]);\n\treturn fabs(res) / 2;\n}\nbool isconvex(polygon A){ // counter-clockwise\n\tbool ok=1;int n=sz(A);\n\trep(i,0,2) A.pb(A[i]);\n\trep(i,0,n) ok&=((A[i+1]-A[i])/(A[i+2]-A[i]))>=0;\n\treturn ok;\n}\nint inPpolygon(P p,polygon A){ // -1 : on , 0 : out , 1 : in\n\tint res=0;\n\trep(i,0,sz(A)){\n\t\tP u=A[i],v=A[(i+1)%sz(A)];\n\t\tif(onPS(p,u,v)) return -1;\n\t\tT cross = sgn((v-u)/(p-u)) , d1 = sgn(u.y-p.y) , d2 = sgn(v.y-p.y);\n\t\tif(cross > 0 && d1 <= 0 && d2 > 0) ++res;\n\t\tif(cross < 0 && d2 <= 0 && d1 > 0) --res;\n\t}\n\treturn res != 0;\n}\nT diameter(polygon A) { // longest distance\n  int n=sz(A);if(n <= 1) return 0;\n  int l=0,r=0;rep(i,1,n) (A[i]<A[l])&&(l=i),(A[r]<A[i])&&(r=i);\n  db res=abs(A[l]-A[r]);int i=l,j=r;\n  do (++((A[(i+1)%n]-A[i])/(A[(j+1)%n]-A[j])>=0?j:i))%=n,\n    res=max(res,abs(A[i]-A[j]));\n  while(i!=l||j!=r);\n  return res;\n}\npolygon convexCut(polygon A,P s,P t){ // counter-clockwise , left hand of st\n\tint n=sz(A);\n\tpolygon B;\n\trep(i,0,n){\n\t\tP u=A[i],v=A[(i+1)%n];\n\t\tint d1 = sgn((t-s)/(u-s)) , d2 = sgn((t-s)/(v-s));\n\t\tif(d1 >= 0) B.pb(u);\n\t\tif(d1 * d2 < 0) B.pb(insLL(L(u,v),L(s,t)));\n\t}\n\treturn B;\n}\nnamespace NearestPoints{\n  T solve(int l,int r,vector<P>&p){\n    if(l == r) return 1e100;\n    int m=(l+r)>>1;\n    T Xm = p[m].x , lim = min(solve(l,m,p) , solve(m+1,r,p));\n    inplace_merge(p.begin()+l,p.begin()+m+1,p.begin()+r+1,[&](P a,P b){return a.y<b.y;});\n    vector<P> V;\n    rep(i,l,r+1) if(fabs(p[i].x - Xm) <= lim) V.pb(p[i]);\n    rep(i,0,sz(V)) rep(j,i+1,sz(V)){\n      if(fabs(V[j].y - V[i].y) >= lim) break;\n      T dis = abs(V[i]-V[j]);\n      lim = min(lim,dis);\n    }\n    return lim;\n  }\n  T solve(vector<P> A){\n    sort(all(A),[&](P a,P b){return a.x<b.x;});\n    return solve(0,sz(A)-1,A);\n  }\n}\nstruct C{\n\tP o;T r;C(){} C(P o,T r):o(o),r(r){}\n\tbool operator == (const C&b) const {return o==b.o&&sgn(r-b.r)==0;}\n};\nint relCC(C A,C B){\n\tT dis = abs(A.o - B.o);\n\tif(sgn(dis - (A.r + B.r)) == 1) return 4;\n\tif(sgn(dis - (A.r + B.r)) == 0) return 3;\n\tif(sgn(dis - fabs(A.r - B.r)) == 1) return 2;\n\tif(sgn(dis - fabs(A.r - B.r)) == 0) return 1;\n\treturn 0;\n}\nvector<P> insCL(C c,L a){\n\tdb x = (a.s-c.o)*(a.t-a.s) , y = norm(a.t-a.s);\n\tdb d = x * x - y * (norm(a.s-c.o) - c.r*c.r);\n\tvector<P> res;\n\tif(sgn(d) < 0) return res;\n\td = max(d,0.);\n\tP mid = a.s - (a.t - a.s) * (x / y);\n\tP del = (a.t - a.s) * (sqrt(d) / y);\n\treturn {mid - del,mid + del}; // dir : a.s -> a.t\n}\n\nC o;\nP p;\ndb r;\n\nint main() {\n\tstd::ios::sync_with_stdio(0);\n\tstd::cin.tie(0);\n\t//\tfreopen(\"a.in\", \"r\", stdin);\n\t//\tfreopen(\"a.out\", \"w\", stdout);\n\tcout << setiosflags(ios::fixed);\n\tcout << setprecision(10);\n\tcin >> p.x >> p.y >> r;\n\to = C(p, r);\n\tint q;\n\tcin >> q;\n\twhile(q--) {\n\t\tP a, b;\n\t\tcin >> a.x >> a.y >> b.x >> b.y;\n\t\tvector<P> r = insCL(o, L(a, b));\na = r[0], b = r[1];\n\t\tif(b.x < a.x || (b.x == a.x && b.y < a.y)) swap(r[0], r[1]);\n\t\tcout << r[0].x << \" \" << r[0].y << \" \" << r[1].x << \" \" << r[1].y << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////\n// ???????????????\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n////////////////////\n// ??¨????????¢???\nusing D = double;\n////////////////////\n// ?????°\nconst D EPS = 1e-9;                // |EPS|???????????°???0??¨????????±???\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // 3??????????????¢???\n////////////////////\n// ?§???????\nstruct Point {\n  D x, y;\n  Point(const D d = 0.0) : x(d), y(d) {}\n  Point(const D x, const D y) : x(x), y(y) {}\n};\nstruct Segment {\n  Point initial, terminal;\n  Segment(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Segment(const D x1, const D y1, const D x2, const D y2) : initial(x1, y1), terminal(x2, y2) {}\n};\nstruct Line {\n  Point initial, terminal;\n  Line(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Line(const D x1, const D y1, const D x2, const D y2) : initial(x1, y1), terminal(x2, y2) {}\n  Line(const Segment& s) : initial(s.initial), terminal(s.terminal) {}\n};\n////////////////////\n// ????£?\nbool relative_equal(const D d1, const D d2) {return d1 == 0 ? std::abs(d2) < EPS : std::abs((d1 - d2) / d1) < EPS;}\n// ??????????????????????????????\nbool operator==(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) && relative_equal(lhs.y, rhs.y);}\nbool operator<(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y < rhs.y : lhs.x < rhs.x;}\nbool operator>(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y > rhs.y : lhs.x > rhs.x;}\nbool operator!=(const Point& lhs, const Point& rhs) {return !(lhs == rhs);}\nbool operator<=(const Point& lhs, const Point& rhs) {return !(lhs > rhs);}\nbool operator>=(const Point& lhs, const Point& rhs) {return !(lhs < rhs);}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x + rhs.x, lhs.y + rhs.y);}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x * rhs.x, lhs.y * rhs.y);}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x / rhs.x, lhs.y / rhs.y);}\nconst Point operator-(const Point& p) {return Point(-p.x, -p.y);}\n// ???\nD abs(const Point& p) {return std::hypot(p.x, p.y);}\nD norm(const Point& p) {return p.x * p.x + p.y * p.y;}\nD dot(const Point& a, const Point& b) {return a.x * b.x + a.y * b.y;}\nD cross(const Point& a, const Point& b) {return a.x * b.y - a.y * b.x;}\n// const Point normalize(const Point& p) {return p / abs(p);}\n// const Point normal(const Point& p) {return normalize(Point(-p.y, p.x));}\n// ??´???\nbool parallel(const Line& l1, const Line& l2) {return relative_equal(0.0, cross(l2.terminal - l2.initial, l1.terminal - l1.initial));}\nbool orthogonal(const Line& l1, const Line& l2) {return relative_equal(0.0, dot(l2.terminal - l2.initial, l1.terminal - l1.initial));}\n// 3??????????????¢???\nPOSITION ccw(const Point& a, const Point& b, const Point& p) {\n  Point v1 = b - a;\n  Point v2 = p - a;\n  if(cross(v1, v2) >= EPS) return COUNTER_CLOCKWISE;\n  if(cross(v1, v2) <= -EPS) return CLOCKWISE;\n  if(dot(v1, v2) <= -EPS) return ONLINE_BACK;\n  if(norm(v1) < norm(v2)) return ONLINE_FRONT;              // ????????????: norm(v1)<norm(v2)+EPS?????¨WrongAnswer\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(const Point& p1, const Point& p2) {return p1 == p2;}\nbool intersect(const Point& p, const Segment& s) {return abs(p - s.initial) + abs(p - s.terminal) - abs(s.initial - s.terminal) <= EPS;}\nbool intersect(const Segment& s, const Point& p) {return intersect(p, s);}\nbool intersect(const Point& p, const Line& l) {return !parallel(Line(p, l.initial), Line(p, l.terminal));}\nbool intersect(const Line& l, const Point& p) {return intersect(p, l);}\nbool intersect(const Segment& s1, const Segment& s2) {\n  return ccw(s1.initial, s1.terminal, s2.initial) * ccw(s1.initial, s1.terminal, s2.terminal) <= 0\n      && ccw(s2.initial, s2.terminal, s1.initial) * ccw(s2.initial, s2.terminal, s1.terminal) <= 0;\n}\nbool intersect(const Segment& s, const Line& l) {\n  auto v1 = l.terminal - l.initial;\n  auto v2 = s.initial  - l.initial;\n  auto v3 = s.terminal - l.initial;\n  return cross(v1, v2) * cross(v1, v3) <= EPS;\n}\nbool intersect(const Line& l, const Segment& s) {return intersect(s, l);}\nbool intersect(const Line& l1, const Line& l2) {return !parallel(l1, l2) || intersect(l1.initial, l2);}\n// ???????§????\nPoint rotate(const Point& p, const D a) {return Point(p.x * std::cos(a) - p.y * std::sin(a), p.x * std::sin(a) + p.y * std::cos(a));}\nPoint projection(const Point& p, const Line& l) {\n  auto v = l.initial - l.terminal;\n  return l.initial + dot(p - l.initial, v) / norm(v) * v;\n}\nPoint projection(const Line& l, const Point& p) {return projection(p, l);}\nPoint reflection(const Point& p, const Line& l) {return p + 2 * (projection(p, l) - p);}\nPoint reflection(const Line& l, const Point& p) {return reflection(p, l);}\n// ?????¢\nD distance(const Point& p1, const Point& p2) {\n  auto p = p1 - p2;\n  return hypot(p.x, p.y);\n}\nD distance(const Point& p, const Segment& s) {\n  auto r = projection(s, p);\n  return intersect(r, s) ? distance(p, r) : std::min(distance(p, s.initial), distance(p, s.terminal));\n}\nD distance(const Segment& s, const Point& p) {return distance(p, s);}\nD distance(const Point& p, const Line& l) {return distance(p, projection(p, l));}\nD distance(const Line& l, const Point& p) {return distance(p, l);}\nD distance(const Segment& s1, const Segment& s2) {\n  return intersect(s1, s2) ? 0.0 : std::min({distance(s1, s2.initial), distance(s1, s2.terminal), distance(s2, s1.initial), distance(s2, s1.terminal)});\n}\nD distance(const Segment& s, const Line& l) {return intersect(s, l) ? 0.0 : std::min(distance(s.initial, l), distance(s.terminal, l));}\nD distance(const Line& l,const Segment& s) {return distance(s, l);}\nD distance(const Line& l1, const Line& l2) {return intersect(l1, l2) ? 0.0 : distance(l1.initial, l2);}\n// ??????\nconst Point crosspoint(const Line& l1, const Line& l2) {\n  assert(intersect(l1, l2));\n  if(parallel(l1, l2)) return l1.initial;                   // ???????????¨???l1????§?????????????\n  D A = cross(l1.terminal - l1.initial, l2.terminal - l2.initial);\n  D B = cross(l1.terminal - l1.initial, l1.terminal - l2.initial);\n  return l2.initial + B / A * (l2.terminal - l2.initial);\n}\nconst Point crosspoint(const Segment& s, const Line& l) {\n  assert(intersect(s, l));\n  if(parallel(s, l)) return s.initial;\n  return crosspoint(Line(s), l);\n}\nconst Point crosspoint(const Line& l, const Segment& s) {return crosspoint(s, l);}\nconst Point crosspoint(const Segment& s1, const Segment& s2) {\n  assert(intersect(s1, s2));\n  if(parallel(s1, s2)) {                                    // ???????????¨?????????????????????????????????\n    if(intersect(s1.initial,  s2)) return s1.initial;\n    if(intersect(s1.terminal, s2)) return s1.terminal;\n    if(intersect(s2.initial,  s1)) return s2.initial;\n    if(intersect(s2.terminal, s1)) return s2.terminal;\n  }\n  return crosspoint(Line(s1), Line(s2));\n}\n// ???????????°??¨\n#include<iostream>\nstd::ostream& operator<<(std::ostream& os, const Point& p) {os<<\"point: \"; os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os;}\nstd::ostream& operator<<(std::ostream& os, const Segment& s) {os<<\"segment: \"; os<<s.initial<<\" - \"<<s.terminal; return os;}\nstd::ostream& operator<<(std::ostream& os, const Line& l) {os<<\"line: \"; os<<l.initial<<\" - \"<<l.terminal; return os;}\n////////////////////////////////////////////////////////////////////////////////\n// ???\n#include<vector>\nconst D PI = std::acos(-1);\nstruct Circle {\n  Point center;\n  D radius;\n  Circle(const Point& center = 0, const D radius = 0) : center(center), radius(radius) {}\n  Circle(const D x, const D y, const D radius) : center(x, y), radius(radius) {}\n};\nD area(const Circle& c) {return PI * c.radius * c.radius;}\nbool contain(const Circle& c, const Point& p) {\n  D d = abs(p - c.center);\n  if(relative_equal(c.radius, d)) return true;\n  return d < c.radius;\n}\nbool contain(const Point& p, const Circle& c) {return contain(c, p);}\nstd::vector<Point> crosspoint(const Circle& c, const Line& l) {\n  std::vector<Point> cp;\n  Point p = projection(c.center, l);\n  if(!contain(c, p)) return cp;\n  Point v = p - c.center;\n  if(relative_equal(abs(v), 0)) {\n    Point p = l.initial - c.center;\n    if(p == 0) p = l.terminal - c.center;\n    p = (c.radius * p / abs(p));\n    cp.push_back(c.center + p);\n    cp.push_back(c.center - p);\n    return cp;\n  }\n  D angle = acos(abs(v) / c.radius);\n  for(D a: {angle, -angle}) cp.push_back(c.center + c.radius * (rotate(v, a) / abs(v)));\n  return cp;\n}\nstd::vector<Point> crosspoint(const Line& l, const Circle& c) {return crosspoint(c, l);}\nint tangent(const Circle& c1, const Circle& c2) {\n  D d = abs(c1.center - c2.center);\n  D r = c1.radius + c2.radius;\n  if(relative_equal(d, r)) return 3;    // ?????\\\n  if(r < d) return 4;                   // ?????¢\n  r = std::abs(c1.radius - c2.radius);\n  if(relative_equal(d, r)) return 1;    // ?????\\\n  if(r < d) return 2;                   // ??????\n  return 0;                             // ??????\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ????§???¢\n//   ????????????????????°??????????????´??? ??? ?????¢???????´????edge(void)???O(????????°)???edge().begin()????????£????????????????????????????????????????????????\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<utility>\nclass Polygon {\npublic:\n  // ??¨???\n  void add(const Point& p);\n  void clear();\n  // ?????±\n  int size() const;\n  Point vertex(const int n) const;\n  Segment edge(const int n) const;\n  const std::vector<Point>& vertex() const;\n  const std::vector<Segment>& edge() const;\n  // ??????\n  bool touch(const Point& p) const;\n  bool intersect(const Point& p) const;\n  D area() const;\n  bool convex() const;\n  // ???????§???¢\n  const Polygon convex_hull() const;\n  D convex_diameter() const;\n  const Polygon convex_cut(const Line& l) const;\nprivate:\n  std::vector<Point> vertex_;\n  std::vector<Segment> edge_;\n};\n// ??¨???\nvoid Polygon::add(const Point& p) {\n  if(!vertex_.empty()) {\n    if(!edge_.empty()) edge_.pop_back();\n    edge_.push_back(Segment(vertex_.back(), p));\n    edge_.push_back(Segment(p, vertex_.front()));\n  }\n  vertex_.push_back(p);\n}\nvoid Polygon::clear() {\n  vertex_.clear();\n  edge_.clear();\n};\n// ?????±\nint Polygon::size() const {return vertex_.size();}\nPoint Polygon::vertex(const int n) const {return vertex_.at(n);}\nSegment Polygon::edge(const int n) const {return edge_.at(n);}\nconst std::vector<Point>& Polygon::vertex() const {return vertex_;}\nconst std::vector<Segment>& Polygon::edge() const {return edge_;}\n// ??????\nbool Polygon::touch(const Point& p) const {\n  return std::any_of(std::begin(edge()), std::end(edge()), [=](const Segment& s) {return ccw(s.initial, s.terminal, p) == ON_SEGMENT;});\n}\nbool Polygon::intersect(const Point& p) const {\n  bool in = false;                    // p=(x,y)??????(INF,y)???????????´?????¨????§???¢??¨????????????????????° mod 2\n  for(const auto& e: edge()) {\n    if(::intersect(p, e)) return true;\n    Point a = e.initial  - p;\n    Point b = e.terminal - p;\n    if(a.y > b.y) std::swap(a, b);\n    if(a.y < EPS && EPS <= b.y && cross(a, b) < EPS) in = !in;\n  }\n  return in;\n}\nD Polygon::area() const {\n  return std::abs(std::accumulate(std::begin(edge()), std::end(edge()), 0.0, [=](const D sum, const Segment& e){return sum + cross(e.initial, e.terminal);})) / 2.0;\n}\nbool Polygon::convex() const {\n  bool positive = false;\n  bool negative = false;\n  for(int i = 0; i < size(); ++i) {\n    auto position = ccw(vertex(i), vertex((i + 1) % size()), vertex((i + 2) % size()));\n    positive |= position == CLOCKWISE;\n    negative |= position == COUNTER_CLOCKWISE;\n    if(negative && positive) return false;\n  }\n  return true;\n}\n// ???????§???¢\n// Andrew's Monotone Chain: O(n log n)\nconst Polygon Polygon::convex_hull() const {\n  auto original = vertex();\n  std::sort(std::begin(original), std::end(original));\n  original.insert(std::end(original), original.rbegin() + 1, original.rend());\n  std::vector<Point> point;\n  for(const auto& p: original) {\n    while(point.size() >= 2 && ccw(point[point.size() - 2], point.back(), p) == CLOCKWISE) point.pop_back();\n    point.push_back(p);\n  }\n  Polygon convex_hull;\n  point.pop_back();\n  for(const auto& p: point) convex_hull.add(p);\n  return convex_hull;\n}\n// Rotating calipers: O(n)\nD Polygon::convex_diameter() const {\n  auto point = vertex();\n  int p, q, start_p, start_q, max_p, max_q;\n  p = start_p = max_p = std::min_element(std::begin(point), std::end(point)) - std::begin(point);\n  q = start_q = max_q = std::max_element(std::begin(point), std::end(point)) - std::begin(point);\n  D max_d = norm(vertex(p) - vertex(q));\n  do {\n    if(cross(vertex((p + 1) % size()) - vertex(p), vertex((q + 1) % size()) - vertex(q)) >= 0) q = (q + 1) % size();\n    else p = (p + 1) % size();\n    if(norm(vertex(p) - vertex(q)) > max_d) {\n      max_d = norm(vertex(p) - vertex(q));\n      max_p = p;\n      max_q = q;\n    }\n  } while(start_p != q || start_q != p);\n  return std::sqrt(max_d);\n}\nconst Polygon Polygon::convex_cut(const Line& l) const {\n  Polygon result;\n  for(const auto& e: edge()) {\n    if(ccw(l.initial, l.terminal, e.initial) == COUNTER_CLOCKWISE) result.add(e.initial);\n    if(::intersect(e, l)) result.add(crosspoint(e, l));\n  }\n  return result;\n}\n////////////////////////////////////////////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  Circle c;\n  cin >> c.center.x >> c.center.y >> c.radius;\n  int q;\n  cin >> q;\n  for(auto i=0;i<q;++i){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    auto cp = crosspoint(c, Line(x1, y1, x2, y2));\n    cout<<cp.size()<<endl;\n    if(cp[0] > cp[1]) swap(cp[0], cp[2]);\n    cout << setprecision(6) << fixed << cp[0].x << \" \" << cp[0].y << \" \" << cp[1].x << \" \" << cp[1].y << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); i++)\n#define pb push_back\n#define all(X) X.begin(), X.end()\n\n#define X real()\n#define Y imag()\n#define x(p) real(p)\n#define y(p) imag(p)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1)%P.size()]\n\nconst double EPS = 1e-4;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n\t\t\tcross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n// enum { OUT, ON, IN };\n// int contains(const G& pol, const P& p){\n// \tif(pol.size() < 2) return OUT;\n// \tif(intersectSP({pol[0], pol[1]}, p)) return ON;\n// \tbool f = cross(pol[1]-pol[0], p - pol[0]) > 0;\n// \tfor(int i = 1; i < pol.size(); i++) {\n// \t\tauto& now = curr(pol, i);\n// \t\tauto& nxt = next(pol, i);\n// \t\tif(intersectSP({nxt, now}, p)) return ON;\n// \t\tif(f^(cross(nxt-now, p-now)>0)) return OUT;\n// \t}\n// \treturn IN;\n// }\n//??????????§???¢?????????????????????(polygon??????????¨???????)\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\nbool contains(const polygon& a, const polygon& b) {\n\trep(i, a.size()) if(contains(b, a[i]) == OUT) return false;\n\treturn true;\n}\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT, HIT, A_IN_B, B_IN_A};\nint isHit(const polygon& a, const polygon& b){\n\tif(contains(a, b)) return A_IN_B;\n\tif(contains(b, a)) return B_IN_A;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n\n//point???theta???????????¢\npoint spinP(const point& p, double theta, double ext = 1.0) {\n\treturn p*P(cos(theta),sin(theta))*ext;\n}\n\npoint makeP(double r, double arg) {return P(r*cos(arg), r*sin(arg));}\n\n//?????¨????????????????±???????\nvector<P> crossPoint(const C& a, const C& b){\n\tdouble d = abs(b.p-a.p);\n\tdouble arg = atan2(y(b.p-a.p), x(b.p-a.p));\n\tdouble arg2 = acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r));\n\tif(abs(arg2)<EPS) return {a.r*makeP(1.0, arg)+a.p};\n\tif(abs(a.r-b.r)<d && d < a.r+b.r) return {a.r*makeP(1.0, arg+arg2)+a.p, a.r*makeP(1.0, arg-arg2)+a.p};\n\treturn {};\n}\n\n//????????±?????\\???\nvector<L> comonTang(C c1, C c2) {\n\tvector<L> ret;\n\tif(c1.r > c2.r) swap(c1, c2);\n\tP sub = c1.p;\n\tc1.p -= sub;\n\tc2.p -= sub;\n\tdouble theta = atan2(c2.p.Y, c2.p.X);\n\n\tc2.p = spinP(c2.p, -theta);\n\tint signX = 0;\n\tif(c2.p.X > 0) signX = 1;\n\tif(c2.p.X < 0) signX = -1;\n\n\tdouble x = abs(c2.p.X), r1 = c1.r, r2 = c2.r;\n\tif(abs(x*x -(r2 - r1) * (r2 - r1))<EPS) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t}\n\telse if(x*x > (r2 - r1) * (r2 - r1)) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t\tret.pb({spinP({0, -r1}, -theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), -r1}, -theta2)});\n\t}\n\tif(abs(r1+r2-x)<EPS) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t}\n\telse if(x > r1+r2) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t\tret.pb({spinP({0, -r1}, -theta3), spinP({len, -r1}, theta3)});\n\t}\n\n\tfor(auto& l : ret) {\n\t\tif(signX == -1) l[1] = {-l[1].X, l[1].Y};\n\t\tl[0] = spinP(l[0], theta);\n\t\tl[1] = spinP(l[1], theta);\n\t\tl[0] += sub;\n\t\tl[1] += sub;\n\t}\n\treturn ret;\n}\n\ndouble getArea(const polygon& pol) {\n\tint n = pol.size();\n\tdouble s = 0.0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint now = i, nxt = (i + 1) % n;\n\t\ts += (pol[now].X - pol[nxt].X) * (pol[now].Y + pol[nxt].Y);\n\t}\n\treturn abs(s/2.0);\n}\n\n//?????? - convex hull\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n  \tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n  \t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  \tfor (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n  \t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  \tch.resize(k-1);\n  \treturn ch;\n}\n//???????¨??????????polygon????????????????????????\t\t\tCGL_3_B\nbool isHull(const G& g) {\n\tint n = g.size();\n\tif(n < 3) return false;\n\trep(i, n) if(ccw(prev(g, i), curr(g, i), next(g, i)) == -1) return false;\n\treturn true;\n}\nbool contains(const P& p, const C& c) {\n\treturn abs(p-c.p) < c.r+EPS;\n}\nint posRel(const L&s, const C&c){\n\tif(abs(distanceSP(s,c.p)-c.r)<EPS)\treturn 1;\t//??\\?????????\n\tif(distanceSP(s,c.p) > c.r+EPS) \treturn 0;\t//????????£????????????\n\tif(contains(s[0], c) && contains(s[1], c))\treturn 2;\t//????????????\n\tif(contains(s[0], c)||contains(s[1], c))\treturn 3;\t//?????´???????????????\n\treturn 4;\t//????????????\n}\nvector<P> crossPoint(C c, L l) {\n\tint hit = posRel(l, c);\n\tif(hit == 0) return {};\n\t\n\tdouble R = c.r;\n\tP sub = c.p;\n\tdouble theta;\n\n\tl[0] -= sub;\n\tl[1] -= sub;\n\n\ttheta = atan2(imag(l[1]-l[0]), real(l[1]-l[0]));\n\n\tl[0] = spinP(l[0], -theta);\n\tl[1] = spinP(l[1], -theta);\n\n\tassert(abs(imag(l[0]-l[1])) < EPS);\n\n\tvector<P> ret;\n\tif(abs(abs(l[0].Y) - R) < EPS) ret.pb({0.0, l[0].Y});\n\telse {\n\t\tdouble y = l[0].Y;\n\t\tdouble x = sqrt(R*R-y*y);\n\t\tret.pb({x, y});\n\t\tret.pb({-x, y});\n\t}\n\n\trep(i, ret.size()) {\n\t\tret[i] = spinP(ret[i], theta);\n\t\tret[i] += sub;\n\t}\n\trep(i, ret.size()) {\n\t\tif(abs(ret[i].X) < EPS) ret[i] = {0.0, ret[i].Y};\n\t}\n\treturn ret;\n}\n\nint main() {\n\tdouble x, y, r;\n\tcin >> x >> y >> r;\n\tC c({x, y}, r);\n\tint q;\n\tcin >> q;\n\trep(i, q) {\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tL l({x1, y1}, {x2, y2});\n\t\tvector<P> a = crossPoint(c, l);\n\t\tif(a.size() == 1) a.pb(a[0]);\n\t\tsort(all(a));\n\t\tassert(a.size() == 2);\n\t\tprintf(\"%.15lf %.15lf %.15lf %.15lf\\n\", a[0].X, a[0].Y, a[1].X, a[1].Y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n向量a ,向量b\nc=a-b c的方向指向的是a  指向的是被减数 \n*/\n#include<bits/stdc++.h>\n#define eps (1e-10)\nusing namespace std;\nclass Point\n{\n\tpublic:\n\tdouble x,y;\n\tPoint(double _x=0,double _y=0):x(_x),y(_y){}\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y);} \n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){return Point(a*x,a*y);} \n\tPoint operator / (double a){return Point(x/a,y/a);}\n\tdouble norm(){return x*x+y*y;}\n\tdouble ABS(){return sqrt(norm());} //相当于向量的大小 \n\tbool operator <(const Point &p) const{\n\t\treturn x!=p.x?x<p.x:y<p.y;\n\t}\n\tbool operator ==(const Point &p) const{\n\t\treturn abs(x-p.x)<eps&&(y-p.y)<eps;\n\t}\n};\nclass Segment\n{\n\tpublic:\n\tPoint p1,p2;\t\n\tSegment(){}\n\tSegment(Point _p1=Point(0.0),Point _p2=Point(0.0)):p1(_p1),p2(_p2){}\n\tdouble norm(){return (p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y); }\n\tdouble ABS(){return sqrt(norm());}//线段的长度 和用Point里的ABS函数求的是一样的 \n};\nclass Circle\n{\n\tpublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point _c=Point(0.0),double _r=0.0):c(_c),r(_r){}\n};\ndouble dot(Point a,Point b)//求内积 就是向量a*b \n{\n\treturn a.x*b.x+a.y*b.y;\n}\n//外积的值为a与b向量构成的平行四边形面积的值 \ndouble cross(Point a,Point b)//求外积 \n{\n\treturn a.x*b.y-a.y*b.x;\n} \n\n\n//判断是否正交 向量内积：a*b=|a||b|*cos(Y) 当cos为0时正交(90,-90垂直) \n//a*b=a.x*b.x+a.y*b.y;\nbool solve1(Point a,Point b)//是否正交 \n{\n\tdouble f=a.x*b.x+a.y*b.y; \n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n//判断是否平行  向量外积：|a*b|=|a||b|sin(Y) 当sin为0时平行(180,0平行)\n//|a*b|=|a|*|b|*sin(Y) \nbool solve2(Point a,Point b)//是否平行 \n{\n\tdouble f=a.x*b.y-a.y*b.x;\n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n\n/*\n求垂足x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线引一条垂线\nbase=p2-p1;\nhypo=p-p1;\n x=s.p1+base*(hypo*base/|base|^2); hypo*base 可以用向量内积求 \n*/\nPoint solve3(Segment s,Point p)//求投影点 \n{\n\tPoint base=s.p2-s.p1;\n\tdouble r=dot(p-s.p1,base)/base.norm();\n\treturn s.p1+base*r; \n}\n/*\n求投影点x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线为对称轴与点p\n成线对称点为x \n通过求solve3的垂足延长一倍就可以求x \n*/\nPoint solve4(Segment s,Point p)//求映象 \n{\n\treturn p+(solve3(s,p)-p)*2.0;\n}\n\n/*\nPoint a=p1-p0;\nPoint b=p2-p0;\n1.外积大小cross(a,b)为正时,可确定b在a的逆时针方向\n\tsin(Y)（Y在0-180）所以是正数\n2. 外积大小cross(a,b)为负时,可确定b在a的顺时针方向\n3.（1,2）不符合 表示p2在直线p0p1上(注意是直线),cos(Y)大于90或小于-90\n\t度时为负，因此a与b的内积dot(a,b)负时，可确定p2位于线段p0p1后方\n\t即p2->p0->p1\n4.不是3时，有俩种p0->p1-p2或者p0->p2->p1如果b的大小大于a的大小，即为\n\tp0->p1->p2;\n5.不符合4，可以确定p2位于线段p0p1上 \n*/ \nint ccw(Point p0,Point p1,Point p2)//判断三个点相对位置 \n{\n\tPoint a=p1-p0;\n\tPoint b=p2-p0;\n\tif(cross(a,b)>eps) return 1;//p0,p1,p2成逆时针方向 \n\tif(cross(a,b)<-eps) return -1;//p0,p1,p2成顺时针方向 \n\tif(dot(a,b)<-eps) return 2;//p2 p0 p1一次排列在同一直线上 \n\tif(a.norm()<b.norm()) return -2;// p0 p1 p2一次排列在同一直线上 \n\treturn 0;//p2在线段p0p1上 \n\t\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)//判断线段是否相交 通过ccw来判断 \n{\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\n\n\n/*\n点a与点b之间的距离等于向量a-b或b-a的绝对值。 \n*/ \ndouble getdis(Point a,Point b)//求俩点间的距离                    \n{\n\treturn (a-b).ABS();\n} \n\n/*\n设直线p1 p2上的向量为a=p2-p1,p与p1构成的向量b=p-p1\n则点p与直线p1p2的距离d就等于a,b构成的平行四边形的高\n用a与b外积的大小(平行四边形的面积)除以a的大小|a|即可求出高d\nd=|a*b|/|a|=|(p2-p1)*(p-p1)|/|p2-p1|; \n*/\n//注意：这里Segmet s是不规范的应该是 Line s 才对 \ndouble getdis_Li(Segment s,Point p)//点与直线的距离 \n{\n\treturn abs(cross(s.p2-s.p1,p-s.p1)/(s.p2-s.p1).ABS());\n}\n\ndouble getdis_sp(Segment s,Point p)//点与线段的距离 \n{\n\tif(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).ABS();\n\tif(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).ABS();\n\treturn getdis_Li(s,p);\n}\n\ndouble getdis_ss(Segment s1,Segment s2)//线段与线段之间的距离 \n{\n\tif(intersect(s1.p1,s1.p2,s2.p1,s2.p2)) return 0.0;\n\treturn min(min(getdis_sp(s1,s2.p1),getdis_sp(s1,s2.p2)),min(getdis_sp(s2,s1.p1),getdis_sp(s2,s1.p2)));\n}\n\n/*\nt：线段s1的长度与点s1.p1到交点的x的距离之比为t\nd1：s1 和s2.p1构成的平行四边形的高\nd2:同理\n则：d1:d2=t:(t-1)\nx=s1.p1+(s1.p2-s1.p1)*t; \n*/ \nPoint get_s1s2_point(Segment s1,Segment s2)//在s1和s2有交点的情况下，求s1和s2的交点 \n{\n\tPoint base=s2.p2-s2.p1;\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+(s1.p2-s1.p1)*t;\n} \npair<Point,Point>getCrossPoint(Circle c,Segment s)\n{\n\tPoint pr=solve3(s,c.c);\n\tPoint e=(s.p2-s.p1)/(s.p2-s.p1).ABS();\n\tdouble base=sqrt(c.r*c.r-(pr-c.c).norm());\n\treturn make_pair(pr+e*base,pr-e*base);\n}\nint main()\n{\n\tdouble a,b,r;\n\tscanf(\"%lf %lf %lf\",&a,&b,&r);\n\tCircle c(Point(a,b),r);\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tdouble x1,y1,x2,y2;scanf(\"%lf %lf %lf %lf\",&x1,&y1,&x2,&y2);\n\t\tSegment s(Point(x1,y1),Point(x2,y2));\n\t\tpair<Point,Point>pi=getCrossPoint(c,s);\n\t\tif(pi.first<pi.second){\n\t\t\tprintf(\"%.6f %.6f %.6f %.6f\\n\",pi.first.x,pi.first.y,pi.second.x,pi.second.y);\n\t\t} \n\t\telse{\n\t\t\tprintf(\"%.6f %.6f %.6f %.6f\\n\",pi.second.x,pi.second.y,pi.first.x,pi.first.y);\n\t\t}\n\t\t      \n\t} \n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nbool operator < (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() < r.imag() : l.real() < r.real();\n}\n\nbool operator > (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() > r.imag() : l.real() > r.real();\n}\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this);\n  Circle(){}\n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto h = projection(l, c);\n  auto e = (l[1]-l[0]) / abs(l[1]-l[0]);\n  auto base = sqrt(c.r*c.r-abs(h-c)*abs(h-c));\n  return {h+e*base, h-e*base};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  Circle c; cin >> c.p >> c.r;\n  int n; cin >> n;\n  rep(i, n) {\n    P a, b; cin >> a >> b;\n    auto cp = crosspoint(c, Line(a, b));\n    if(cp.first > cp.second) { swap(cp.first, cp.second); }\n    printf(\"%.10f %.10f %.10f %.10f\\n\", cp.first.real(), cp.first.imag(), cp.second.real(), cp.second.imag());\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; } // cross product\n    db operator * (const point &p){ return x * p.x + y * p.y; } // dot product\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n    point unit(){ db k = (*this).len(); return point(x / k, y / k); }\n};\n\npoint err = point(INF_d, INF_d);\ndb rad(point A, point B){ return atan2((A ^ B), (A * B)); }// the ang(in rad) of two vectors A and B\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){ // find the distance of cloest pair of points in p\n//please make sure that p is sorted by x coordinate | sort(p, p + n, cmpxy);\n//this is nlognlogn, if need nlogn, replace the sort with a merge sort.\n    if (r - l <= 5){ db cloest = INF_d;\n        for (int i = l; i < r; i++) for (int j = i + 1; j < r; j++) cloest = min(cloest, (p[i] - p[j]).len());\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1; db cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid, r));\n        vector<point> v; v.clear();\n        for (int i = l; i < r; i++) if (fabs(p[i].x - p[mid].x) <= cloest) v.pb(p[i]); sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++) for (int j = i + 1; j < SZ(v) && dcmp(v[j].y - v[i].y - cloest) < 0; j++)\n                cloest = min(cloest, (v[i] - v[j]).len());\n        return cloest;\n    }\n}\n\nstruct circle{\n    point o; double r;\n    circle(){}\n    circle(point a, double b): o(a), r(b){}\n    void read(){\n        o.read(), scanf(\"%lf\", &r);\n    }\n    int inside(point p){ // 1: inside, 2: on the circle, 0: outside\n        int sgn = dcmp((o - p).len() - r) < 0; if (sgn < 0) return 1; if (!sgn) return 2; return 0;\n    }\n};\n\nint check_CC(circle C1, circle C2){ // return the number of common tangents of two circles C1 and C2\n//4: xiang_li, 3: wai_qie, 2: xiang_jiao, 1: nei_qie, 0: nei_han\n    db d =(C1.o - C2.o).len();\n    if (dcmp(d - C1.r - C2.r) > 0) return 4;\n    if (!dcmp(d - C1.r - C2.r)) return 3;\n    if (!dcmp(d - fabs(C1.r - C2.r))) return 1;\n    if (dcmp(d - fabs(C1.r - C2.r)) > 0 && dcmp(d - C1.r - C2.r) < 0) return 2;\n    return 0;\n}\n\nvector<point> inter_CL(circle C, point A, point B){ // return the intersection of a circle and a line\n// the result give in the direction from A -> B\n    point p_proj = proj_SP(A, B, C.o);\n    db d = C.r * C.r - (C.o - p_proj).len2();\n    if (dcmp(d) < 0) return {};\n    point delta = (B - A).unit() * sqrt(max((db)0, d)); return {p_proj - delta, p_proj + delta};\n}\n\nvector<point> inter_CL(circle C, line L){ // the same as the former one, but argument is different\n    return inter_CL(C, L.p[0], L.p[1]);\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\ncircle cir[2];\n\nint main(){\n    cir[0].read();\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        x.read(), y.read();\n        vector<point> itp = inter_CL(cir[0], x, y);\n        if (dcmp(itp[0].y - itp[1].y) > 0) swap(itp[0], itp[1]);\n        printf(\"%.10f %.10f %.10f %.10f\\n\", itp[0].x, itp[0].y, itp[1].x, itp[1].y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{\n    L(const P &a, const P &b){\n        push_back(a), push_back(b);\n    }\n};\n\nstruct C {\n    P p; double r;\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ncrossPointsOfCircleAndLine(C &circle, L &l){\n    P p0 = circle.p;\n    double r = circle.r;\n    P p1 = l[0];\n    P p2 = l[1];\n    double x = real(p1-p0);\n    double y = imag(p1-p0);\n    double z = real(p2-p0);\n    double w = imag(p2-p0);\n    double a = y-w;\n    double b = -(x-z);\n    double c = y*z - x*w;\n\n    P cross1((a*c - b*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b), (b*c + a*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b));\n    P cross2((a*c + b*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b), (b*c - a*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b));\n\n    if(cross2 < cross1){\n        swap(cross1, cross2);\n    }\n    printf(\"%.10f %.10f \", cross1.real() + p0.real(), cross1.imag() + p0.imag());\n    printf(\"%.10f %.10f\\n\", cross2.real() + p0.real(), cross2.imag() + p0.imag());\n}\n\nint main(){\n    double cx, cy, r, x1, y1, x2, y2;\n    int q;\n    cin >> cx >> cy >> r >> q;\n    P p0(cx, cy);\n    C circle(p0, r);\n\n    for (int i=0;i<q;i++){\n        cin >> x1 >> y1 >> x2 >> y2 ;\n        P p1(x1, y1);\n        P p2(x2, y2);\n        L l(p1, p2);\n        crossPointsOfCircleAndLine(circle, l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n  \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\tps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n  \n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);      \n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }    \n  }   \n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n  \n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }    \n  }\n  \n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(a.x*b.x+a.y*b.y,a.x*b.y-a.y*b.x);\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n\treturn c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n\tres+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n//END CUT HERE\n\n//Projection\nsigned AOJ_CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned AOJ_CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned AOJ_CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned AOJ_CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned AOJ_CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//cross point\nsigned AOJ_CGL2C(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<getCrossPointSS(Segment(p0,p1),Segment(p2,p3))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=jp\n*/\n\n//distanceSS\nsigned AOJ_CGL2D(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    printf(\"%.12f\\n\",getDistanceSS(Segment(p0,p1),Segment(p2,p3)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=jp\n*/\n\n//area of Polygon\nsigned AOJ_CGL3A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.1f\\n\",area(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=jp\n*/\n\n\n//isConvex\nsigned AOJ_CGL3B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<isConvex(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=jp\n*/\n\n\n\n//contains\nsigned AOJ_CGL3C(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  int q;\n  cin>>q;\n  while(q--){\n    Point r;\n    cin>>r;\n    cout<<contains(p,r)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n*/\n\n\n//convex hull\nsigned AOJ_CGL4A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=convex_hull(p);\n  cout<<q.size()<<endl;\n  for(Point v:q) cout<<v.x<<\" \"<<v.y<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n*/\n\n//diameter of Polygon\nsigned AOJ_CGL4B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n*/\n\n//convexCut:\nsigned AOJ_CGL4C(){\n  int n;\n  cin>>n;\n  Polygon g(n);\n  for(int i=0;i<n;i++) cin>>g[i];\n  Polygon p=andrewScan(g);\n  int q;\n  cin>>q;\n  while(q--){\n    Line l;\n    cin>>l.p1>>l.p2;\n    printf(\"%.12f\\n\",area(convexCut(p,l)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=jp\n*/\n\n//closest pair:\nsigned AOJ_CGL5A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<fixed<<setprecision(12)<<closest_pair(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=jp\n*/\n\n//manhattanIntersection:\nsigned AOJ_CGL6A(){\n  int n;\n  cin>>n;\n  vector<Segment> ss(n);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  //for(int i=0;i<n;i++) cout<<ss[i].p1<<\":\"<<ss[i].p2<<endl;\n  cout<<manhattanIntersection(ss,1e9+10)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/06/18\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_6_A&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7A(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  cout<<intersectCC(c1,c2)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\n*/\n\n\n//getCrossPointCL\nsigned AOJ_CGL7D(){\n  Circle c;\n  int q;\n  cin>>c>>q;\n  while(q--){\n    Line l;\n    cin>>l;\n    auto pp=getCrossPointCL(c,l);\n    if(pp.size()==1u) pp.emplace_back(pp[0]);\n    if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n    cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7E(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto pp=getCrossPointCC(c1,c2);\n  if(pp.size()==1u) pp.emplace_back(pp[0]);\n  if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n  cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=jp\n*/\n\n//tangent to a Circle\nsigned AOJ_CGL7F(){\n  Point p;\n  Circle c;\n  cin>>p>>c;\n  auto pp=tangent(c,p);\n  for(auto p:pp) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F&lang=jp\n*/\n\n//Common Tangent\nsigned AOJ_CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\n//Intersection of a Circle and a Polygon\nsigned AOJ_CGL7H(){\n  int n;\n  double r;\n  cin>>n>>r;\n  Circle c(Point(0,0),r);\n  Polygon ps(n);\n  for(int i=0;i<n;i++) cin>>ps[i];\n  cout<<fixed<<setprecision(12)<<area(ps,c)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\n//area of 2 circles' intersection\nsigned AOJ_2572(){\n  double uw,uh,a,b,ab;\n  while(cin>>uw>>uh>>a>>b>>ab,uw!=0){\n    Circle c1(Point(0,0),sqrt(a/PI));\n    Circle c2(Point(0,0),sqrt(b/PI));\n    bool f=0;\n    if(c1.r<=c2.r) swap(c1,c2),f=1;\n    double l=max(0.0,c1.r-c2.r),r=c1.r+c2.r+EPS;\n    for(int k=0;k<100;k++){\n      double m=(l+r)/2;\n      c2.c.x=m;\n      //cout<<area(c1,c2)<<endl;\n      if(area(c1,c2)<=ab) r=m;\n      else l=m;\n    }\n    c2.c.x=l;\n    \n    double EPS3=1e-4;\n    assert(abs(area(c1,c2)-ab)<=EPS3);\n\n    l=0,r=PI/2;\n    for(int k=0;k<200;k++){\n      double m=(l+r)/2;\n      Circle t=c2;\n      t.c=translate(c2.c,m);\n      if(c1.r+max(c1.r,t.c.x+t.r)<=uw) r=m;\n      else l=m;\n    }\n    c2.c=translate(c2.c,r);\n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n    \n    Vector v(c1.r,c1.r);\n    c1.c=c1.c+v;\n    c2.c=c2.c+v;\n    \n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n\n    if(f) swap(c1,c2);\n    f=1;\n    f&=(c1.c.x-c1.r>=-EPS3);\n    f&=(c1.c.x+c1.r<=uw+EPS3);\n    f&=(c1.c.y-c1.r>=-EPS3);\n    f&=(c1.c.y+c1.r<=uh+EPS3);\n    f&=(c2.c.x-c2.r>=-EPS3);\n    f&=(c2.c.x+c2.r<=uw+EPS3);\n    f&=(c2.c.y-c2.r>=-EPS3);\n    f&=(c2.c.y+c2.r<=uh+EPS3);\n    if(f) cout<<c1.c<<\" \"<<c1.r<<\" \"<<c2.c<<\" \"<<c2.r<<endl;\n    else cout<<\"impossible\"<<endl;\n    //else cout<<c1.c<<\" \"<<c1.r<<\"/\"<<c2.c<<\" \"<<c2.r<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/12/31\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2572\n*/\n\n//Segment Arrangement\nsigned AOJ_2454(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  \n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> used(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {used[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!used[u]){\n\tused[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(used[v]&&used[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<fixed<<setprecision(12)<<ans-tmp<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/27\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2454\n*/\n\n\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  //AOJ_CGL4B();\n  //AOJ_CGL4C();\n  \n  //AOJ_CGL5A();\n\n  //AOJ_CGL6A();\n  \n  //AOJ_CGL7A();\n  AOJ_CGL7D();\n  //AOJ_CGL7E();\n  //AOJ_CGL7F();\n  //AOJ_CGL7G();\n  //AOJ_CGL7H();\n\n  //AOJ_2572();\n  //AOJ_2454();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-7; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\n// VP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// // cross point between circles Verify AOJ CGL_7_E\n// VP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n/*\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}*/\n\nVP pcl(C c, L l) {\n    P h=proj(l,c.c);\n    P e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n    return VP{h-e,h+e};\n}\nVP pcc(C a,C b){\n    P d=b.c-a.c;\n    P w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n    P e=w*P(0,1);\n    return pcl(a,{w-e,w+e}); \n}\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std; int DIGITS = 1919;\nlong double X, Y, R, X1, Y1, X2, Y2; int Q;\nstruct Point { long double px, py; }; struct Segment { Point p1, p2; };\nPoint Minus(Point a, Point b) { Point G; G.px = a.px - b.px; G.py = a.py - b.py; return G; }\nPoint Times(Point a, long double b) { Point J; J.px = a.px*b; J.py = a.py*b; return J; }\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint prj(Segment a, Point b) {\n\tPoint c = Minus(a.p2, a.p1); Point D = Times(c, dot(Minus(b, a.p1), c));\n\tD = Times(D, 1.0 / norm(c)); return Minus(D, Times(a.p1, -1));\n}\nint main() {\n\tcin >> X >> Y >> R >> Q; Point H; H.px = X; H.py = Y;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> X1 >> Y1 >> X2 >> Y2; Point A1, A2; A1.px = X1; A1.py = Y1; A2.px = X2; A2.py = Y2;\n\t\tSegment S; S.p1 = A1; S.p2 = A2; Point I = prj(S, H); Point K = Minus(A2, A1); K = Times(K, 1 / sqrt(norm(K)));\n\t\tdouble base = sqrt(R*R - norm(Minus(I, H))); K = Times(K, base);\n\t\tPoint L[2]; L[0] = Minus(I, K); L[1] = Minus(I, Times(K, -1));\n\t\tif (L[0].px > L[1].px) { swap(L[0], L[1]); }\n\t\telse if (L[0].px == L[1].px && L[0].py > L[1].py) { swap(L[0], L[1]); }\n\t\tcout << fixed << setprecision(DIGITS) << L[0].px << ' ' << fixed << setprecision(DIGITS) << L[0].py << ' ';\n\t\tcout << fixed << setprecision(DIGITS) << L[1].px << ' ' << fixed << setprecision(DIGITS) << L[1].py << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\nstruct point{\n    int x,y;\n};\n\nstruct line{\n    point s,t;\n};\nstruct bec{\n    int x,y;\n};\nstruct circle{\n    point p;\n    int r;\n};\n\n\n\nvoid solve(circle o, line l){\n    double d;\n    bec p1p,p1p2;\n    p1p.x=o.p.x-l.s.x; p1p.y=o.p.y-l.s.y;\n    p1p2.x=l.t.x-l.s.x; p1p2.y=l.t.y-l.s.y;\n    double c,dp,dp2,k,ansx,ansy;\n    dp=sqrt((double)p1p.x*(double)p1p.x+(double)p1p.y*(double)p1p.y);\n    dp2=sqrt((double)p1p2.x*(double)p1p2.x+(double)p1p2.y*(double)p1p2.y);\n    if(dp==0) d=0;\n    else{\n    c=((double)p1p.x*(double)p1p2.x+(double)p1p.y*(double)p1p2.y)/(dp*dp2);\n    k=dp*c;\n    ansx=l.s.x+k*(p1p2.x/dp2);\n    ansy=l.s.y+k*(p1p2.y/dp2);\n    d = sqrt((o.p.x-ansx)*(o.p.x-ansx)+(o.p.y-ansy)*(o.p.y-ansy));\n    }\n    \n    \n    double co = sqrt(1-(d/o.r)*(d/o.r));\n    double ansx1,ansx2,ansy1,ansy2;\n\n\n    ansx1 = ansx-(o.r*co)*(p1p2.x/dp2);\n    ansx2 = ansx+(o.r*co)*(p1p2.x/dp2);\n    ansy1 = ansy-(o.r*co)*(p1p2.y/dp2);\n    ansy2 = ansy+(o.r*co)*(p1p2.y/dp2);\n    if(ansx1<ansx2) printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n    else if(ansx1==ansx2){\n        if(ansy1<ansy2) printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n        else printf(\"%.8f %.8f %.8f %.8f\\n\",ansx2,ansy2,ansx1,ansy1);\n    }\n    else printf(\"%.8f %.8f %.8f %.8f\\n\",ansx2,ansy2,ansx1,ansy1);\n}\n\nint main(){\n    int cx,cy,x1,x2,y1,y2,n,r;\n    point p,s,t;\n    line l;\n    circle o;\n\n    cin>>cx>>cy>>r;\n    p.x=cx;\n    p.y=cy;\n    o.p=p; o.r=r;\n\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>x1>>y1>>x2>>y2;\n        s.x=x1; s.y=y1;\n        t.x=x2; t.y=y2;\n        l.s=s; l.t=t;\n        solve(o,l);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define loop(i, n) for (ll i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define mod 1000000007ll\n#define setbit bitset<8>\n#define flagcount __builtin_popcount\n#define flag(x) (1 << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1 << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define count2way(v, x) high2way(v, x) - low2way(v, x)\n#define lower(v, x) low2way(v, x) - v.begin()       //1番左が0、もし見つから無いならｎを出力\n#define higher(v, x) high2way(v, x) - v.begin() - 1 //1番左が0、もし見つからないならn-1を出力（注意）\n#define putout(a) cout << a << endl\n#define putout2(a, b) \\\n    putout(a);        \\\n    putout(b)\n#define putout3(a, b, c) \\\n    putout(a);           \\\n    putout(b);           \\\n    putout(c)\n#define putout4(a, b, c, d) \\\n    putout(a);              \\\n    putout(b);              \\\n    putout(c);              \\\n    putout(d)\n#define putout5(a, b, c, d, e) \\\n    putout(a);                 \\\n    putout(b);                 \\\n    putout(c);                 \\\n    putout(d);                 \\\n    putout(e)\n#define Gput(a, b) G[a].push_back(b)\n#define cin1(a) cin >> a\n#define cin2(a, b) cin >> a >> b\n#define cin3(a, b, c) cin >> a >> b >> c\n#define cin4(a, b, c, d) cin >> a >> b >> c >> d\n#define cin5(a, b, c, d, e) cin >> a >> b >> c >> d >> e\n#define Sum(v) accumulate(all(v), 0ll)\n#define gcd(x, y) __gcd(x, y)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return 0;\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nT modinv(T a, T m)\n{\n    T b = m, u = 1, v = 0;\n    while (b)\n    {\n        T t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//多次元配列の宣言法\n//vector<vector<ll>> field(h, vector<ll>(w));\ntemplate <class T>\ninline void chmax(T &a, T b)\n{\n    if (a < b)\n        a = b;\n}\ntemplate <class T>\ninline void chmin(T &a, T b)\n{\n    if (a > b)\n        a = b;\n}\n/*\nライブラリをここに置いてコメントを削除\n*/\n//円周率\nstatic const double pi = 3.141592653589793;\n//幾何の問題で入力が多い時に使用\n#define scan(x) scanf(\"%ld\", &x)\n\n//誤差チェッカー\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n//点を表わす構造体\nstruct Point\n{\npublic:\n    double x, y;\n    Point(double _x, double _y) : x(_x), y(_y) {}\n    /*\n    以下ベクトルに対する演算子の定義\n    +:ベクトルの足し算\n    -:ベクトルの引き算\n    *:スカラー倍\n    /:スカラーの逆数倍\n    */\n    Point operator+(const Point p) { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point p) { return Point(x - p.x, y - p.y); }\n    Point operator*(const double k) { return Point(x * k, y * k); }\n    Point operator/(const double k) { return Point(x / k, y / k); }\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n    //ベクトルの比較(x軸方向のベクトルから比較)\n    bool operator<(const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator>(const Point &p) const\n    {\n        return x != p.x ? x > p.x : y > p.y;\n    }\n    bool operator==(const Point &p) const\n    {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    bool operator!=(const Point &p) const\n    {\n        return (!equals(x, p.x)) || (!equals(y, p.y));\n    }\n};\n//ベクトルとして扱う場合\ntypedef Point Vector;\n//線分を表わす構造体\nstruct Segment\n{\n    Point p1, p2;\n    Segment(Point _p1, Point _p2) : p1(_p1), p2(_p2) {}\n};\n//直線として扱う場合\ntypedef Segment Line;\n//ベクトルのノルム\ndouble norm(Vector a)\n{\n    return a.x * a.x + a.y * a.y;\n}\n//ベクトルの大きさ\ndouble abs(Vector a)\n{\n    return sqrt(norm(a));\n}\n//ベクトルの内積\ndouble dot(Vector a, Vector b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n//ベクトルの外積\ndouble cross(Vector a, Vector b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n//内積≓0かどうかによるベクトルの直交判定(様々な引数で答えられるように複数用意)\nbool Orthogonal(Vector a, Vector b)\n{\n    return equals(dot(a, b), 0.0);\n}\nbool Orthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n    return Orthogonal(a1 - a2, b1 - b2);\n}\nbool Orthogonal(Segment s1, Segment s2)\n{\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n//外積≓0かどうかによるベクトルの平行判定(様々な引数で答えられるように複数用意)\nbool Parallel(Vector a, Vector b)\n{\n    return equals(cross(a, b), 0.0);\n}\nbool Parallel(Point a1, Point a2, Point b1, Point b2)\n{\n    return Parallel(a1 - a2, b1 - b2);\n}\nbool Parallel(Segment s1, Segment s2)\n{\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n//直線sに対して点ｐから垂線を引いたときの交点x(直線sに対する点pの射影)を求める\nPoint Project(Line s, Point p)\n{\n    Vector base = s.p2 - s.p1, hypo = p - s.p1;\n    double scalar = (dot(base, hypo) / norm(base));\n    return s.p1 + base * scalar;\n}\n//直線sに対して点pと線対称の位置にある点p'を求める\nPoint Reflect(Line s, Point p)\n{\n    return p + (Project(s, p) - p) * 2.0;\n}\n//点と点の距離\ndouble GetDist(Point a, Point b)\n{\n    return abs(a - b);\n}\n//直線と点の距離\ndouble GetDistLP(Line l, Point p)\n{\n    return abs(Project(l, p) - p);\n}\n//線分と点の距離\ndouble GetDistSP(Segment s, Point p)\n{\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n        return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n        return abs(p - s.p2);\n    return GetDistLP(s, p);\n}\n//Counter-Clockwise(AOJ:CGL_1_Cより)\nstatic const int COUNTER_CLOCKWISE = 1; //反時計回り\nstatic const int CLOCKWISE = -1;        //時計回り\nstatic const int ONLINE_BACK = 2;       //線分の後ろにある\nstatic const int ONLINE_FRONT = -2;     //線分の前にある\nstatic const int ON_SEGMENT = 0;        //線分上にある\n//線分p0p1と点p2の位置関係を求める\nint CCW(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0, b = p2 - p0; //a:p0->p1,b:p0->p2\n    if (cross(a, b) > EPS)\n        return COUNTER_CLOCKWISE; //外積が正なら反時計回り(sinθ>0)\n    if (cross(a, b) < -EPS)\n        return CLOCKWISE; //外積が負なら時計回り(sinθ<0)\n    if (dot(a, b) < -EPS)\n        return ONLINE_BACK; //外積が0かつ内積が負(cosθ<0)\n    if (a.norm() < b.norm())\n        return ONLINE_FRONT; //p2がp0p1に含まれないときp0p2=p0p1+p1p2となり|a|^2<|b|^2が成立\n    return ON_SEGMENT;       //最後にp0p2p1が残る\n}\n//2本の線分の交差判定(点と線分で2種類用意)\nbool Intersect(Point p1, Point p2, Point p3, Point p4)\n{\n    return (CCW(p1, p2, p3) * CCW(p1, p2, p4) <= 0 && CCW(p3, p4, p1) * CCW(p3, p4, p2) <= 0);\n}\nbool Intersect(Segment s1, Segment s2)\n{\n    return Intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//線分と線分の距離\ndouble GetDist(Segment s1, Segment s2)\n{\n    //線分が交差していた場合、距離は0.0\n    if (Intersect(s1, s2))\n        return 0.0;\n    return min(min(GetDistSP(s1, s2.p1), GetDistSP(s1, s2.p2)), min(GetDistSP(s2, s1.p1), GetDistSP(s2, s1.p2)));\n}\n//交差する2本の線分の交点\nPoint CrossPoint(Segment s1, Segment s2)\n{\n    if (!Intersect(s1, s2))\n        cout << \"2本の線分は交点を持たない\" << endl; //デバッグ用\n    Vector base = s2.p2 - s2.p1, hypo1 = s1.p1 - s2.p1, hypo2 = s1.p2 - s2.p1;\n    double d1 = fabs(cross(base, hypo1)) / abs(base);\n    double d2 = fabs(cross(base, hypo2)) / abs(base);\n    Point x = s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n    return x;\n}\n//座標cを中心とする半径rの円を表わす構造体\nstruct Circle\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point _c, double _r) : c(_c), r(_r) {}\n};\n//円と直線の交点の組(接点なら同じものを2つ)を求める(小さい順に入れる)\npair<Point, Point> CrossPoints(Circle c, Line l)\n{\n    if (GetDistLP(l, c.c) - c.r > EPS)\n        cout << \"円と直線は交点を持たない\" << endl;      //デバッグ用\n    Point mid = Project(l, c.c);                         //交点の中間\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);         //直線lの単位ベクトル\n    double halfdist = sqrt(c.r * c.r - norm(c.c - mid)); //三平方の定理で2交点の距離の半分を求める\n    Point s = mid + e * halfdist, t = mid - e * halfdist;\n    if (s > t)\n        swap(s, t);\n    return make_pair(s, t); //s<tの順\n}\n\n//多角形は点の列として扱う\ntypedef vector<Point> Polygon;\nint main()\n{\n    cout << fixed << setprecision(30);\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n    Point cc(cx, cy);\n    Circle C(cc, r);\n    ll q;\n    cin >> q;\n    loop(i, q)\n    {\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Point p1(x1, y1), p2(x2, y2);\n        Line L(p1, p2);\n        pair<Point, Point> cp = CrossPoints(C, L);\n        cout << cp.first.x << \" \" << cp.first.y << \" \" << cp.second.x << \" \" << cp.second.y << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; } // cross product\n    db operator * (const point &p){ return x * p.x + y * p.y; } // dot product\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n    point unit(){ db k = (*this).len(); return point(x / k, y / k); }\n};\n\npoint err = point(INF_d, INF_d);\ndb rad(point A, point B){ return atan2((A ^ B), (A * B)); }// the ang(in rad) of two vectors A and B\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){ // find the distance of cloest pair of points in p\n//please make sure that p is sorted by x coordinate | sort(p, p + n, cmpxy);\n//this is nlognlogn, if need nlogn, replace the sort with a merge sort.\n    if (r - l <= 5){ db cloest = INF_d;\n        for (int i = l; i < r; i++) for (int j = i + 1; j < r; j++) cloest = min(cloest, (p[i] - p[j]).len());\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1; db cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid, r));\n        vector<point> v; v.clear();\n        for (int i = l; i < r; i++) if (fabs(p[i].x - p[mid].x) <= cloest) v.pb(p[i]); sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++) for (int j = i + 1; j < SZ(v) && dcmp(v[j].y - v[i].y - cloest) < 0; j++)\n                cloest = min(cloest, (v[i] - v[j]).len());\n        return cloest;\n    }\n}\n\nstruct circle{\n    point o; double r;\n    circle(){}\n    circle(point a, double b): o(a), r(b){}\n    void read(){\n        o.read(), scanf(\"%lf\", &r);\n    }\n    int inside(point p){ // 1: inside, 2: on the circle, 0: outside\n        int sgn = dcmp((o - p).len() - r) < 0; if (sgn < 0) return 1; if (!sgn) return 2; return 0;\n    }\n};\n\nint check_CC(circle C1, circle C2){ // return the number of common tangents of two circles C1 and C2\n//4: xiang_li, 3: wai_qie, 2: xiang_jiao, 1: nei_qie, 0: nei_han\n    db d =(C1.o - C2.o).len();\n    if (dcmp(d - C1.r - C2.r) > 0) return 4;\n    if (!dcmp(d - C1.r - C2.r)) return 3;\n    if (!dcmp(d - fabs(C1.r - C2.r))) return 1;\n    if (dcmp(d - fabs(C1.r - C2.r)) > 0 && dcmp(d - C1.r - C2.r) < 0) return 2;\n    return 0;\n}\n\nvector<point> inter_CL(circle C, point A, point B){ // return the intersection of a circle and a line\n// the result give in the direction from A -> B\n    point p_proj = proj_SP(A, B, C.o);\n    db d = C.r * C.r - (C.o - p_proj).len2();\n    if (dcmp(d) < 0) return {};\n    point delta = (B - A).unit() * sqrt(max((db)0, d)); return {p_proj - delta, p_proj + delta};\n}\n\nvector<point> inter_CL(circle C, line L){ // the same as the former one, but argument is different\n    return inter_CL(C, L.p[0], L.p[1]);\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\ncircle cir[2];\n\nint main(){\n    cir[0].read();\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        x.read(), y.read();\n        vector<point> itp = inter_CL(cir[0], x, y);\n        sort(itp.begin(), itp.end(), cmpxy);\n        printf(\"%.10f %.10f %.10f %.10f\\n\", itp[0].x, itp[0].y, itp[1].x, itp[1].y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometry\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ??§ ???????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ??§ ????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b??§?????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c??§?????´??????\n    return 0;  // a -- c -- b??§?????´??????\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  { //OK\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  { //OK\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  { //OK\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n};\n\nvoid solve()\n{\n  Geometry::Circle c;\n  cin >> c.p >> c.r;\n  int N;\n  cin >> N;\n  while(N--) {\n    Geometry::Line l;\n    cin >> l;\n    auto pp = Geometry::Crosspoint(c, l);\n    cout << pp.first.x << \" \" << pp.first.y << \" \" << pp.second.x << \" \" << pp.second.y << endl;\n  }\n\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--Geometry Template (Plane)\n//-------------------------------------------------\n\nusing lf = double;\nconst lf EPS = 1e-9;\nconst lf PI = acos(-1);\n\n#define sgn(x) (((x)<-EPS)?-1:((x)>EPS)?1:0)\n#define EQ(x,y) (sgn((y)-(x))==0)\n\nstruct V {\n    lf x,y;\n    V(){}\n    V(lf x, lf y):x(x),y(y){}\n    V(const V &v):x(v.x),y(v.y){}\n    V& operator+=(const V &v){x+=v.x; y+=v.y; return *this;}\n    V& operator-=(const V &v){x-=v.x; y-=v.y; return *this;}\n    V& operator*=(lf k){x*=k; y*=k; return *this;}\n    V& operator/=(lf k){x/=k; y/=k; return *this;}\n    V operator+(const V &v){return V(*this)+=v;}\n    V operator-(const V &v){return V(*this)-=v;}\n    V operator*(lf k){return V(*this)*=k;}\n    V operator/(lf k){return V(*this)/=k;}\n    V operator-(){return V(-x,-y);}\n    lf sq(){return x*x+y*y;}\n    lf norm(){return sqrt(sq());}\n    V unit(){return V(*this)/=norm();}\n    lf arg(){return atan2(y,x);}\n    V rot(lf c, lf s){return V(x*c-y*s,x*s+y*c);}\n    V rot(lf a){return rot(sin(a),cos(a));}\n    V rot90(){return V(-y,x);}\n    bool operator<(const V &v){\n        if (sgn(x-v.x)) return sgn(x-v.x)<0;\n        return sgn(y-v.y)<0;\n    }\n    friend ostream& operator<<(ostream &os, const V &v){return os<<'('<<v.x<<\", \"<<v.y<<')';}\n};\n\nlf dot(const V &a, const V &b){return a.x*b.x+a.y*b.y;}\nlf det(const V &a, const V &b){return a.x*b.y-a.y*b.x;}\n\nint ccw(V a, V b, V c){\n    b-=a; c-=a;\n    if (sgn(det(b,c))>0) return 1;\n    else if(sgn(det(b,c))<0) return -1;\n    else if(sgn(dot(b,c))<0) return 2;\n    else if(sgn(b.norm()-c.norm())<0) return -2;\n    return 0;\n}\n\nstruct Line {\n    V p,q;\n    Line(){}\n    Line(const V &p, const V &q):p(p),q(q){}\n    Line(const Line &l):Line(l.p,l.q){}\n    V unit(){return (q-p).unit();}\n    lf arg(){return (q-p).arg();}\n    Line rot(lf c, lf s){return Line(p.rot(c,s),q.rot(c,s));}\n    Line rot(lf a){return Line(p.rot(a),q.rot(a));}\n    Line rot90(){return Line(p.rot90(),q.rot90());}\n};\n\nstruct Segment : Line {\n    Segment(){}\n    Segment(const V &p, const V &q):Line(p,q){}\n    Segment(const Segment &s):Line(s){}\n    lf sq(){return (Line::q-Line::p).sq();}\n    lf norm(){return (Line::q-Line::p).norm();}\n};\n\n// functions about lines\nbool parallel(V &a, V &b){return EQ(det(a,b),0.0);}\nbool parallel(Line &a, Line &b){return EQ(det(a.q-a.p,b.q-b.p),0.0);}\nbool orthogonal(V &a, V &b){return EQ(dot(a,b),0.0);}\nbool orthogonal(Line &a, Line &b){return EQ(dot(a.q-a.p,b.q-b.p),0.0);}\n\nbool samel(Line &a, Line &b){return parallel(a,b)&&EQ(det(a.q-a.p,b.p-a.p),0.0);}\nbool insec(Line &a, Line &b){return !parallel(a,b);}\nbool insec(Segment &a, Segment &b){\n    int c1 = ccw(a.p,a.q,b.p)*ccw(a.p,a.q,b.q);\n    int c2 = ccw(b.p,b.q,a.p)*ccw(b.p,b.q,a.q);\n    return (c1<=0 && c2<=0);\n}\nbool insec(Line &a, Segment &b){return ccw(a.p,a.q,b.p)*ccw(a.p,a.q,b.q)<=0;}\n\n// use only if lines have intersection\nV cpoint(Line &a, Line &b){\n    V r(a.q-a.p);\n    r *= det(b.p-a.p,b.q-b.p)/det(a.q-a.p,b.q-b.p);\n    return a.p+r;\n}\n\nlf distance(V &a, V &b){return (b-a).norm();}\nlf distance(Line &l, V &v){return abs(det((l.q-l.p).unit(),v-l.p));}\nlf distance(Line &a, Line &b){return (parallel(a,b))?distance(a,b.p):0.0;}\nlf distance(Segment &s, V &v){\n    if (sgn(dot(s.q-s.p,v-s.p))<0) return distance(s.p,v);\n    else if(sgn(dot(s.p-s.q,v-s.q))<0) return distance(s.q,v);\n    return distance((Line&)s,v);\n}\nlf distance(Segment &a, Segment &b){\n    if (insec(a,b)) return 0.0;\n    lf A=min(distance(a,b.p),distance(a,b.q));\n    lf B=min(distance(b,a.p),distance(b,a.q));\n    return min(A,B);\n}\nlf distance(Line &a, Segment &b){\n    if (insec(a,b)) return 0.0;\n    return min(distance(a,b.p),distance(a,b.q));\n}\n\nV subdiv(V &a, V &b, lf m, lf n){return (a*n+b*m)/(m+n);}\nV outside(V &a, V &b, lf m, lf n){return (-a*n+b*m)/(m-n);}\nV ppfoot(Line &l, V &v){\n    V u = (l.q-l.p).unit();\n    return l.p+u*dot(u,v-l.p);\n}\nV reflect(Line &l, V &v){\n    V f = ppfoot(l,v);\n    return f+(f-v);\n}\n\nLine vbsector(V &a, V &b){\n    V m = (a+b)/2;\n    return Line(m, m+(b-a).rot90());\n}\nLine absector(V &c, V &a, V &b){\n    lf m=(a-c).norm(), n=(b-c).norm();\n    return Line(c,subdiv(a,b,m,n));\n}\nLine perpend(V &c, V &a, V &b){return Line(c,c+(b-a).rot90());}\n\n//-------------------------------------------------\n//--Polygon (depends on Geometry Template)\n//-------------------------------------------------\n\n//anti-clockwise\nstruct Polygon {\n    vector<V> ps; int n;\n    Polygon():n(0){}\n    Polygon(int n):n(n),ps(n){}\n    void push(const V &v){ps.push_back(v), n++;}\n    void pop(){ps.pop_back(), n--;}\n    V& operator[](int k){return ps[k%n];}\n};\n\nlf area(Polygon &p){\n    lf ret=0.0;\n    for(int i=0; i<p.n; i++)\n        ret+=det(p[i],p[i+1])/2;\n    return ret;\n}\n\nV gravity(Polygon &p){\n    V ret(0,0); lf wsum=0.0;\n    for(int i=0; i<p.n; i++){\n        lf w = det(p[i],p[i+1]);\n        ret+=(p[i]+p[i+1])/3*w;\n        wsum+=w;\n    }\n    return ret/wsum;\n}\n\nbool convex(Polygon &p){\n    for(int i=0; i<p.n; i++)\n        if (sgn(det(p[i]-p[i+1],p[i+1]-p[i+2]))<0) return false;\n    return true;\n}\n\nPolygon convex_full(vector<V> &ps){\n    Polygon ret;\n    sort(ps.begin(), ps.end());\n    for(int i=0; i<ps.size(); i++){\n        while(ret.n>1 && sgn(det(ret[ret.n-1]-ret[ret.n-2],ps[i]-ret[ret.n-1]))<=0) ret.pop();\n        ret.push(ps[i]);\n    }\n    for(int i=ps.size()-2, t=ret.n; i>=0; i--){\n        while(ret.n>t && sgn(det(ret[ret.n-1]-ret[ret.n-2],ps[i]-ret[ret.n-1]))<=0) ret.pop();\n        ret.push(ps[i]);\n    }\n    ret.pop();\n    return ret;\n}\n\n// OUT=0, ON=1, IN=2\nint contain(Polygon &p, const V &v){\n    int ret=0;\n    for(int i=0; i<p.n; i++){\n        V a=p[i]-v, b=p[i+1]-v;\n        if (a.y>b.y) swap(a,b);\n        if (sgn(a.y)<0 && sgn(b.y)>=0 && sgn(det(a,b))<0) ret=2-ret;\n        if (EQ(det(a,b),0.0) && sgn(dot(a,b))<=0) return 1;\n    }\n    return ret;\n}\n\n//-------------------------------------------------\n//--Circle (depends on Geometry Template)\n//-------------------------------------------------\n\nstruct Circle {\n    V p; lf r;\n    Circle(){}\n    Circle(const V &v, lf r):p(v),r(r){}\n    Circle(const Circle &c):p(c.p),r(c.r){}\n    lf area(){return r*r*PI;}\n    lf area(lf t){return r*r*t/2;}\n};\n\n// functons about circles\nbool contain(Circle &c, V &v){return sgn(distance(v,c.p)-c.r)<=0;}\nbool contain(Circle &c, Segment &s){\n    return sgn(max(distance(s.p,c.p),distance(s.q,c.p))-c.r)<=0;\n}\nbool insec(Circle &c, Line &l){return sgn(distance(l,c.p)-c.r)<=0;}\nbool insec(Circle &c, Segment &s){\n    return sgn(distance(s,c.p)-c.r)<=0 && sgn(max(distance(s.p,c.p),distance(s.q,c.p))-c.r)>=0;\n}\n\nvector<V> cpoint(Circle &a, Circle &b){\n    vector<V> ret;\n    V ab(b.p-a.p);\n    lf d = ab.norm(), dd = ab.sq();\n    lf c = (a.r*a.r+dd-b.r*b.r)/(2.0*a.r*d);\n    if (sgn(abs(c)-1.0)>0) return ret;\n    if (EQ(abs(c),1.0)){\n        c = (c>0)?1:-1;\n        ret.push_back(a.p+ab.unit().rot(c,0)*a.r);\n    }else{\n        lf s = sqrt(1.0-c*c);\n        ret.push_back(a.p+ab.unit().rot(c,s)*a.r);\n        ret.push_back(a.p+ab.unit().rot(c,-s)*a.r);\n    }\n    return ret;\n}\n\nvector<V> cpoint(Circle &c, Line &l){\n    vector<V> ret;\n    lf d = distance(l,c.p);\n    if (sgn(d-c.r)>0) return ret;\n    V h = ppfoot(l,c.p);\n    if (EQ(d,c.r)){\n        ret.push_back(h);\n        ret.push_back(h);\n    }else{\n        V r = (l.q-l.p).unit()*sqrt(c.r*c.r-d*d);\n        ret.push_back(h+r);\n        ret.push_back(h-r);\n    }\n    return ret;\n}\n\nvector<V> tangent(Circle &c, V &v){\n    lf rr=(c.p-v).sq()-c.r*c.r;\n    if (sgn(rr)<0) return vector<V>();\n    Circle c2(v,sqrt(rr));\n    return cpoint(c,c2);\n}\n\nlf carea(Circle &a, Circle &b){\n    lf d = distance(a.p,b.p);\n    if (sgn(d+a.r-b.r)<=0) return a.area();\n    if (sgn(d+b.r-a.r)<=0) return b.area();\n    auto cps = cpoint(a,b);\n    if (cps.size()<2) return 0.0;\n    lf t1 = acos(dot((cps[1]-a.p).unit(),(cps[0]-a.p).unit()));\n    if (sgn(det(cps[1]-a.p,cps[0]-a.p))<0) t1=2*PI-t1;\n    lf t2 = acos(dot((cps[0]-b.p).unit(),(cps[1]-b.p).unit()));\n    if (sgn(det(cps[0]-b.p,cps[1]-b.p))<0) t2=2*PI-t2;\n    return a.area(t1)+b.area(t2)-d*(cps[1]-cps[0]).norm()/2;\n}\n\n//-------------------------------------------------\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout<<setp(12);\n    int x,y,r; cin>>x>>y>>r;\n    Circle cir(V(x,y),r);\n    int q; cin>>q;\n    while(q--){\n        int a,b,c,d; cin>>a>>b>>c>>d;\n        Line l(V(a,b), V(c,d));\n        auto cps = cpoint(cir,l);\n        sort(all(cps));\n        cout<<cps[0].x<<\" \"<<cps[0].y<<\" \";\n        cout<<cps[1].x<<\" \"<<cps[1].y<<\"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\n#define eps (1e-10)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nbool cmp_x(const Point& p,const Point& q){\n  if(p.x!=q.x) return p.x<q.x;\n  return p.y<q.y;\n}\nstruct Line{\n    Point p1,p2;\n    Line(){}\n    Line(Point p1, Point p2):p1(p1),p2(p2){}\n};\nstruct Circle{\n    double r;\n    Point p;\n    Circle(){}\n    Circle(Point p,double r):p(p),r(r){}\n};\nint ccw(Point a,Point b,Point c){\n    Point t1=b-a,t2=c-a;\n    if(t1.det(t2)> eps) return 1;//counter clockwise\n    if(t1.det(t2)< -eps) return -1;//clockwise\n    if(t1.dot(t2)< -eps) return 2;//c-a-b online\n    if(t1.norm()<t2.norm()) return -2;//a-b-c online\n    return 0;//a-c-b online\n}\nPoint project(Line l,Point p){\n    Point base=l.p2-l.p1;\n    double r=(p-l.p1).dot(base)/base.norm();\n    return l.p1+base*r;\n}\ndouble distance(Line l,Point p){\n    Point r=project(l,p);\n    return (p-r).abs();\n    /*\n    if(abs(ccw(l.p1,l.p2,r))==0) return (p-r).abs();//projection not online\n    else return min((p-l.p1).abs(),(p-l.p2).abs());\n    */\n}\nbool isIntersectCC(Circle c1,Circle c2){\n    return (c1.p-c2.p).abs()<=c1.r+c2.r+eps;\n}\nbool isIntersectCL(Circle c,Line l){\n    return distance(l,c.p)<=c.r+eps;\n}\npair<Point,Point> CrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=(c1.p-c2.p).abs();\n    double k=acos((d*d+c1.r*c1.r-c2.r*c2.r)/(c1.r*d*2));\n    return make_pair(c1.p+(c2.p-c1.p)*Point(cos(k),sin(k))*(c1.r/d),c1.p+(c2.p-c1.p)*Point(cos(-k),sin(-k))*(c1.r/d));\n}\npair<Point,Point> CrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n    Point p=project(l,c.p);\n    double q=sqrt(c.r*c.r-(p-c.p).norm());\n    Point e=(l.p2-l.p1)*(1.0/(l.p2-l.p1).abs());\n    return make_pair(p+e*q,p-e*q);\n}\nint main(){\n    double cx,cy,r;\n    double x1,y1,x2,y2;\n    int q;\n    cin>>cx>>cy>>r;\n    Circle c(Point(cx,cy),r);\n    cin>>q;\n    rep(i,q){\n        cin>>x1>>y1>>x2>>y2;\n        Line l(Point(x1,y1),Point(x2,y2));\n        pair<Point,Point> pp=CrossPointsCL(c,l);\n        if(!cmp_x(pp.first,pp.second)) swap(pp.first,pp.second);\n        cout<<fixed<<setprecision(12)<<pp.first.x<<\" \"<<pp.first.y<<\" \"<<pp.second.x<<\" \"<<pp.second.y<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimize(\"Ofast\")\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\n// Geometry {{{\nconst long double EPS = 1e-10;\nconst long double PI = acos(-1);\n\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\nstatic const int ICC_SEPARATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Real {\n    long double x;\n\n    Real(long double x = 0) : x(x) {}\n    Real(const Real& rhs) { x = rhs.x; }\n\n    Real operator+(const Real& rhs) const { return Real(x + rhs.x); }\n    Real& operator+=(const Real& rhs) { return x += rhs.x, *this; }\n    Real operator-(const Real& rhs) const { return Real(x - rhs.x); }\n    Real& operator-=(const Real& rhs) { return x -= rhs.x, *this; }\n    Real operator*(const Real& rhs) const { return Real(x * rhs.x); }\n    Real& operator*=(const Real& rhs) { return x *= rhs.x, *this; }\n    Real operator/(const Real& rhs) const { return Real(x / rhs.x); }\n    Real& operator/=(const Real& rhs) { return x /= rhs.x, *this; }\n    Real operator-() const { return Real(-x); }\n    Real& operator++() { return ++x, *this; }\n    Real& operator--() { return --x, *this; }\n    Real operator++(int) { Real tmp(x); return ++x, tmp; }\n    Real operator--(int) { Real tmp(x); return --x, tmp; }\n    bool operator==(const Real& rhs) const { return fabs(x - rhs.x) < EPS; }\n    bool operator!=(const Real& rhs) const { return !(*this == rhs); }\n    bool operator<(const Real& rhs) const { return (*this == rhs) ? false : x < rhs.x; }\n    bool operator>(const Real& rhs) const { return (*this == rhs) ? false : x > rhs.x; }\n    bool operator<=(const Real& rhs) const { return (*this == rhs) ? true : x < rhs.x; }\n    bool operator>=(const Real& rhs) const { return (*this == rhs) ? true : x > rhs.x; }\n\n    friend istream& operator>>(istream& is, Real& rhs) {\n        is >> rhs.x;\n        return is;\n    }\n    friend ostream& operator<<(ostream& os, const Real& rhs) {\n        os << rhs.x;\n        return os;\n    }\n\n    friend Real pow(const Real& n, const Real& p) { return pow(n.x, p.x); }\n    friend Real pow(Real n, intmax_t p) {\n        Real ret = 1;\n        for (; p > 0; p >>= 1) {\n            if (p & 1) ret *= n;\n            n *= n;\n        }\n        return ret;\n    }\n    friend Real abs(const Real& rhs) { return abs(rhs.x); }\n    friend Real sin(const Real& rhs) { return sin(rhs.x); }\n    friend Real cos(const Real& rhs) { return cos(rhs.x); }\n    friend Real tan(const Real& rhs) { return tan(rhs.x); }\n    friend Real asin(const Real& rhs) { return asin(rhs.x); }\n    friend Real acos(const Real& rhs) { return acos(rhs.x); }\n    friend Real atan(const Real& rhs) { return atan(rhs.x); }\n    friend Real atan2(const Real& lhs, const Real& rhs) { return atan2(lhs.x, rhs.x); }\n    friend Real sqrt(const Real& rhs) { return sqrt(rhs.x); }\n    friend Real ceil(const Real& rhs) { return ceil(rhs.x); }\n    friend Real floor(const Real& rhs) { return floor(rhs.x); }\n    friend Real round(const Real& rhs) { return round(rhs.x); }\n};\n\nusing real_t = Real;\n\nstruct Point {\n    real_t x, y;\n\n    Point(real_t x = 0, real_t y = 0) : x(x), y(y) {}\n\n    Point operator+(const Point& rhs) const { return Point(x + rhs.x, y + rhs.y); }\n    Point operator-(const Point& rhs) const { return Point(x - rhs.x, y - rhs.y); }\n    Point operator*(const real_t& rhs) const { return Point(x * rhs, y * rhs); }\n    Point operator/(const real_t& rhs) const { return Point(x / rhs, y / rhs); }\n    Point operator-() const { return Point(-x, -y); }\n    bool operator==(const Point& rhs) const { return x == rhs.x && y == rhs.y; }\n    bool operator!=(const Point& rhs) const { return !(*this == rhs); }\n    bool operator<(const Point& rhs) const { return (x == rhs.x) ? y < rhs.y : x < rhs.x; }\n    bool operator>(const Point& rhs) const { return (x == rhs.x) ? y > rhs.y : x > rhs.x; }\n    bool operator<=(const Point& rhs) const { return (*this == rhs) ? true : *this < rhs; }\n    bool operator>=(const Point& rhs) const { return (*this == rhs) ? true : *this > rhs; }\n\n    friend istream& operator>>(istream& is, Point& rhs) {\n        is >> rhs.x >> rhs.y;\n        return is;\n    }\n    friend ostream& operator<<(ostream& os, const Point& rhs) {\n        os << rhs.x << ' ' << rhs.y;\n        return os;\n    }\n};\n\nusing Vector = Point;\nusing Polygon = vector<Point>;\n\nreal_t norm(const Vector& a) { return a.x * a.x + a.y * a.y; }\nreal_t len(const Vector& a) { return sqrt(norm(a)); }\nreal_t dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; }\nreal_t cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; }\n\nstruct Segment {\n    Point p1, p2;\n\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\n    bool operator==(const Segment& rhs) const { return p1 == rhs.p1 && p2 == rhs.p2; }\n    bool operator!=(const Segment& rhs) const { return !(*this == rhs); }\n\n    friend istream& operator>>(istream& is, Segment& rhs) {\n        is >> rhs.p1 >> rhs.p2;\n        return is;\n    }\n    friend ostream& operator<<(ostream& os, const Segment& rhs) {\n        os << rhs.p1 << ' ' << rhs.p2;\n        return os;\n    }\n};\n\nusing Line = Segment;\n\nstruct Circle {\n    Point c;\n    real_t r;\n\n    Circle(Point c = Point(), real_t r = 0) : c(c), r(r) {}\n\n    bool operator==(const Circle& rhs) const { return c == rhs.c && r == rhs.r; }\n    bool operator!=(const Circle& rhs) const { return !(*this == rhs); }\n\n    friend istream& operator>>(istream& is, Circle& rhs) {\n        is >> rhs.c >> rhs.r;\n        return is;\n    }\n    friend ostream& operator<<(ostream& os, const Circle& rhs) {\n        os << rhs.c << rhs.r;\n        return os;\n    }\n};\n\nreal_t len(const Segment& s) { return len(s.p1 - s.p2); }\n\nbool isParallel(const Vector& a, const Vector& b) {\n    return cross(a, b) == 0.0;\n}\nbool isParallel(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(const Segment& s1, const Segment& s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isOrthogonal(const Vector& a, const Vector& b) {\n    return dot(a, b) == 0.0;\n}\nbool isOrthogonal(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(const Segment& s1, const Segment& s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(const Segment& s, const Point& p) {\n    const Vector base = s.p2 - s.p1;\n    const Vector hypo = p - s.p1;\n    const real_t r = dot(hypo, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(const Segment& s, const Point& p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\nint ccw(const Point& p0, const Point& p1, const Point& p2);\nbool intersectSS(const Point& p1, const Point& p2, const Point& p3, const Point& p4);\nbool intersectSS(const Segment& s1, const Segment& s2);\nbool intersectGS(const Polygon& g, const Segment& s);\nint intersectCC(Circle c1, Circle c2);\nbool intersectSC(const Segment& s, const Circle& c);\nreal_t getDistancePP(const Point& p1, const Point& p2);\nreal_t getDistanceLP(const Line& l, const Point& p);\nreal_t getDistanceSP(const Segment& s, const Point& p);\nreal_t getDistanceSS(const Segment& s1, const Segment& s2);\nPoint getCrossPointSS(const Segment& s1, const Segment& s2);\nPolygon getCrossPointCL(const Circle& c, const Line& l);\nreal_t area(const Polygon& g);\n\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > 0.0) return CCW_COUNTER_CLOCKWISE;\n    if (cross(a, b) < 0.0) return CCW_CLOCKWISE;\n    if (dot(a, b) < 0) return CCW_ONLINE_BACK;\n    if (norm(a) < norm(b)) return CCW_ONLINE_FRONT;\n    return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\nbool intersectSS(const Segment& s1, const Segment& s2) {\n    return intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersectGS(const Polygon& g, const Segment& s) {\n    const size_t N = g.size();\n    for (size_t i = 0; i < N; ++i) {\n        if (intersectSS(Segment(g[i], g[(i + 1) % N]), s)) return true;\n    }\n    return false;\n}\n\nint intersectCC(Circle c1, Circle c2) {\n    if (c1.r < c2.r) swap(c1, c2);\n    const real_t d = len(c1.c - c2.c);\n    const real_t r = c1.r + c2.r;\n    if (d == r) return ICC_CIRCUMSCRIBE;\n    if (d > r) return ICC_SEPARATE;\n    if (d + c2.r == c1.r) return ICC_INSCRIBE;\n    if (d + c2.r < c1.r) return ICC_CONTAIN;\n    return ICC_INTERSECT;\n}\n\nbool intersectSC(const Segment& s, const Circle& c) {\n    return getDistanceSP(s, c.c) <= c.r;\n}\n\nreal_t getDistancePP(const Point& p1, const Point& p2) {\n    return len(p2 - p1);\n}\n\nreal_t getDistanceLP(const Line& l, const Point& p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / len(l.p2 - l.p1));\n}\n\nreal_t getDistanceSP(const Segment& s, const Point& p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return getDistancePP(p, s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return getDistancePP(p, s.p2);\n    return getDistanceLP(s, p);\n}\n\nreal_t getDistanceSS(const Segment& s1, const Segment& s2) {\n    if (intersectSS(s1, s2)) return 0.0;\n    const real_t opt1 = getDistanceSP(s1, s2.p1);\n    const real_t opt2 = getDistanceSP(s1, s2.p2);\n    const real_t opt3 = getDistanceSP(s2, s1.p1);\n    const real_t opt4 = getDistanceSP(s2, s1.p2);\n    return min({opt1, opt2, opt3, opt4});\n}\n\nPoint getCrossPointSS(const Segment& s1, const Segment& s2) {\n    Vector base = s2.p2 - s2.p1;\n    const real_t d1 = abs(cross(base, s1.p1 - s2.p1));\n    const real_t d2 = abs(cross(base, s1.p2 - s2.p1));\n    const real_t t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nPolygon getCrossPointCL(const Circle& c, const Line& l) {\n    Polygon ps;\n    const Point pr = project(l, c.c);\n    const Vector e = (l.p2 - l.p1) / len(l.p2 - l.p1);\n    if (getDistanceLP(l, c.c) == c.r) {\n        ps.emplace_back(pr);\n        return ps;\n    }\n    const real_t base = sqrt(c.r * c.r - norm(pr - c.c));\n    ps.emplace_back(pr + e * base);\n    ps.emplace_back(pr - e * base);\n    return ps;\n}\n\nreal_t area(const Polygon& g) {\n    const size_t N = g.size();\n    real_t res = 0;\n    for (size_t i = 0; i < g.size(); ++i) {\n        res += cross(g[i], g[(i + 1) % N]) / 2.0;\n    }\n    return res;\n}\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n\n    var(Circle, c);\n    var(size_t, Q);\n\n    while (Q--) {\n        var(Line, l);\n        auto res = getCrossPointCL(c, l);\n        if (res.size() == 1) {\n            output(res[0], res[0]);\n        } else {\n            if (res[0] > res[1]) swap(res[0], res[1]);\n            output(res[0], res[1]);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\n\nclass Point {\npublic:\n\tld x, y;\n\tPoint() {\n\t\tx = y = 0.0;\n\t}\n\tPoint(ld x, ld y) :\n\t\t\tx(x), y(y) {\n\t}\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(ld a) {\n\t\treturn Point(x * a, y * a);\n\t}\n\tPoint operator /(ld a) {\n\t\treturn Point(x / a, y / a);\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c;\n\tld r;\n\tCircle(Point c = Point(), ld r = 0.0) :\n\t\t\tc(c), r(r) {\n\t}\n};\n\nld dot(Point p1, Point p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\n\nld norm(Point p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nld abs(Point p) {\n\treturn sqrt(norm(p));\n}\n\nPoint project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tld r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Segment l) {\n\tPoint pr = project(l, c.c);\n\tPoint e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tld base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr - e * base, pr + e * base);\n}\n\nint main() {\n\n\tint cx, cy, r;\n\tscanf(\"%d %d %d\", &cx, &cy, &r);\n\tPoint cp(cx, cy);\n\tCircle c(cp, r);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint p1x, p1y, p2x, p2y;\n\t\tscanf(\"%d %d %d %d\", &p1x, &p1y, &p2x, &p2y);\n\t\tPoint p1(p1x, p1y);\n\t\tPoint p2(p2x, p2y);\n\t\tSegment s(p1, p2);\n\t\tpair<Point, Point> pair = getCrossPoints(c, s);\n\n\t\tcout << fixed << setprecision(10) << pair.first.x << \" \" << pair.first.y << \" \" << pair.second.x << \" \" << pair.second.y << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator==(const Point &p)const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n};\n\n//1?¬?\ntypedef Point Vector;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point(1, 1)) :p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\n\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//??´?????????\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) { return isOrthogonal(a1 - a2, b1 - b2); }\nbool isOrthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isParallel(Point a1, Point a2, Point b1, Point b2) { return isParallel(a1 - a2, b1 - b2); }\nbool isParallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//?????????????????????(?????????????¶????)\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n//2??????????????¢\ndouble getDistance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n//????????¨??????????????¢\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return getDistanceLP(l, c.c) <= c.r; }\n//?????¨??????????????????\nbool intersect(Circle c1, Circle c2) { return getDistance(c1.c, c2.c) <= c1.r + c2.r; }\n\n//????????¨???????????????\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//?????¨??´????????????\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tassert(intersect(c1, c2));\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nint main() {\n\tCircle c;\n\tcin >> c.c.x >> c.c.y >> c.r;\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tLine l;\n\t\tscanf(\"%lf%lf%lf%lf\", &l.p1.x, &l.p1.y, &l.p2.x, &l.p2.y);\n\n\t\tpair<Point, Point> points = getCrossPoints(c, l);\n\t\tPoint a = points.first;\n\t\tPoint b = points.second;\n\t\tif (b < a)swap(a, b);\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a.x, a.y, b.x, b.y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include \"stdio.h\"\n#include <cstdlib>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <array>\n\nusing namespace std;\nusing NUM = double;\n\nstatic const NUM  EPS = 1e-10;\n\ntemplate<typename T>\nstruct Point {\n\tT x, y;\n\tPoint<T> operator+(const Point<T>& rhs)const {\n\t\tPoint<T> p;\n\t\tp.x = this->x + rhs.x;\n\t\tp.y = this->y + rhs.y;\n\t\treturn p;\n\t}\n\tPoint<T> operator-(const Point<T>& rhs)const {\n\t\tPoint<T> p;\n\t\tp.x = this->x - rhs.x;\n\t\tp.y = this->y - rhs.y;\n\t\treturn p;\n\t}\n\tPoint<T> operator*(const T rhs) const {\n\t\tPoint<T> p;\n\t\tp.x = this->x * rhs;\n\t\tp.y = this->y * rhs;\n\t\treturn p;\n\t}\n\tPoint<T> operator/(const T rhs) const {\n\t\tPoint<T> p;\n\t\tp.x = this->x / rhs;\n\t\tp.y = this->y / rhs;\n\t\treturn p;\n\t}\n\tPoint<T> operator-() const {\n\t\tPoint<T> p;\n\t\tp.x = this->x * -1.0;\n\t\tp.y = this->y * -1.0;\n\t\treturn p;\n\t}\n\tstatic bool compByCrd(const Point<T>& p1, const Point<T>& p2) {\n\t\tif (abs(p1.x - p2.x) < EPS) return p1.y < p2.y;\n\t\treturn p1.x < p2.x;\n\t}\n};\n\ntemplate<typename T>\nPoint<T> operator*(const T val, const Point<T>& p)\n{\n\treturn p*val;\n}\n\ntemplate<typename T>\nstruct Segment {\n\tPoint<T> p1, p2;\n};\n\ntemplate<typename T>\nstruct Circle {\n\tPoint<T> center;\n\tT radius;\n};\n\ntemplate<typename T>\nbool isZero(const T val)\n{\n\treturn fabs(val) < 1e-10;\n}\n\ntemplate<typename T>\nT innerProduct(const Point<T>& p0, const Point<T>& p1)\n{\n\tdouble x0 = p0.x;\n\tdouble y0 = p0.y;\n\tdouble x1 = p1.x;\n\tdouble y1 = p1.y;\n\treturn x0 * x1 + y0 * y1;\n}\n\ntemplate<typename T>\nT outerProduct(const Point<T>& p0, const Point<T>& p1)\n{\n\tdouble x0 = p0.x;\n\tdouble y0 = p0.y;\n\tdouble x1 = p1.x;\n\tdouble y1 = p1.y;\n\treturn x0 * y1 - y0 * x1;\n}\n\ntemplate<typename T>\nT norm(const Point<T>& p)\n{\n\tdouble x = p.x;\n\tdouble y = p.y;\n\treturn x*x + y*y;\n}\n\ntemplate<typename T>\nT absolute(const Point<T>& p)\n{\n\treturn sqrt(norm(p));\n}\n\ntemplate<typename T>\nPoint<T> unit(const Point<T>& p)\n{\n\treturn p / absolute(p);\n}\n\ntemplate<typename T>\nvoid readPoint(Point<T>& p)\n{\n\tcin >> p.x;\n\tcin >> p.y;\n}\n\ntemplate<typename T>\nvoid readSegment(Segment<T>& s)\n{\n\tcin >> s.p1.x;\n\tcin >> s.p1.y;\n\tcin >> s.p2.x;\n\tcin >> s.p2.y;\n}\n\ntemplate<typename T>\nvoid readCircle(Circle<T>& c)\n{\n\tcin >> c.center.x;\n\tcin >> c.center.y;\n\tcin >> c.radius;\n}\n\ntemplate<typename T>\nvoid outputComponentesOfPoint(const Point<T>& p)\n{\n\tcout << fixed;\n\tcout << setprecision(8) << p.x;\n\tcout << \" \";\n\tcout << setprecision(8) << p.y;\n\tcout << endl;\n}\n\ntemplate<typename T>\nT getDistanceFromPointToLine(const Point<T>& p, const Segment<T>& s) {\n\tconst Point<T> a = p - s.p1;\n\tconst Point<T> b = s.p2 - s.p1;\n\tconst T outer = outerProduct(a, b);\n\treturn abs( outer / absolute(b) );\n}\n\ntemplate<typename T>\nPoint<T> getIntersectionPointOfLineSegments(const Segment<T>& s1, const Segment<T>& s2)\n{\n\tconst T d1 = getDistanceFromPointToLine(s1.p1, s2);\n\tconst T d2 = getDistanceFromPointToLine(s1.p2, s2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\n\n\n//template<typename T>\n//T distance(const Point<T>& p1, const Point<T>& p2)\n//{\n//\treturn absolute(p2 - p1);\n//}\n//\n\n//template<typename T>\n//T getDistanceFromPointToSegment(const Point<T>& p, const Segment<T>& s) {\n//\tconst T zero = static_cast<T>(0);\n//\tconst Point<T> a = p - s.p1;\n//\tconst Point<T> b = s.p2 - s.p1;\n//\tconst Point<T> c = p - s.p2;\n//\tconst T innerAB = innerProduct(a, b);\n//\tconst T innerc_b = innerProduct(c, -b);\n//\n//\tif (innerAB < zero) {\n//\t\treturn distance(p, s.p1);\n//\t}\n//\telse if (innerc_b < zero) {\n//\t\treturn distance(p, s.p2);\n//\t}\n//\telse {\n//\t\treturn fabs(outerProduct(a, b) / absolute(b) );\n//\t}\n//}\n//\n\n//template<typename T>\n//double getParameterOfProjectedPointToSegment(const Point<T>& p, const Segment<T>& s)\n//{\n//\tconst Point<T> a = p - s.p1;\n//\tconst Point<T> b = s.p2 - s.p1;\n//\tconst T normB = norm(b);\n//\tconst T ab = innerProduct(a, b);\n//\treturn ab / normB;\n//}\n//\n//template<typename T>\n//int getPositionOnSegment(const Point<T>& p, const Segment<T>& s)\n//{\n//\tconst T position = getParameterOfProjectedPointToSegment(p, s);\n//\tif (position < 0.0) {\n//\t\treturn -1;\n//\t}\n//\telse if (1.0 < position) {\n//\t\treturn 1;\n//\t}\n//\telse {\n//\t\treturn 0;\n//\t}\n//}\n\n//static const int counter_clockwise = 2;\n//static const int clockwise = -2;\n//static const int online_back = -1;\n//static const int online_front = 1;\n//static const int onSegment = 0;\n//\n//template<typename T>\n//int getPointPositionToSegment(const Point<T>& p, const Segment<T>& s)\n//{\n//\tconst Point<NUM> a = s.p2 - s.p1;\n//\tconst Point<NUM> b = p - s.p1;\n//\tconst NUM outer = outerProduct(a, b);\n//\tif (outer > EPS) return counter_clockwise;\n//\tif (outer < -EPS) return clockwise;\n//\tif (innerProduct(a, b) < -EPS) return online_back;\n//\tif (norm(b) > norm(a) + EPS) return online_front;\n//\treturn onSegment;\n//}\n//\n//template<typename T>\n//bool intersects(const Segment<T>& s1, const Segment<T>& s2) {\n//\treturn getPointPositionToSegment(s2.p1, s1) * getPointPositionToSegment(s2.p2, s1) <= 0\n//\t\t&& getPointPositionToSegment(s1.p1, s2) * getPointPositionToSegment(s1.p2, s2) <= 0;\n//}\n\n//\n//template<typename T>\n//T getDistanceFromSegmentToSegment(const Segment<T>& s1, const Segment<T>& s2) {\n//\tif (intersects(s1, s2)) {\n//\t\treturn static_cast<T>(0.0);\n//\t}else{\n//\t\treturn min(\n//\t\t\tmin(getDistanceFromPointToSegment(s1.p1, s2), getDistanceFromPointToSegment(s1.p2, s2))\n//\t\t\t, min(getDistanceFromPointToSegment(s2.p1, s1), getDistanceFromPointToSegment(s2.p2, s1))\n//\t\t);\n//\t}\n//}\n\n//template<typename T>\n//void projectPointToSegment(const Point<T>& p, const Segment<T>& s, Point<T>& foot, T& param)\n//{\n//\tconst Point<T> a = p - s.p1;\n//\tconst Point<T> b = s.p2 - s.p1;\n//\tconst T normB = norm(b);\n//\tconst T ab = innerProduct(a, b);\n//\tparam = ab / normB;\n//\tfoot = s.p1 + (s.p2 - s.p1)*param;\n//}\n\ntemplate<typename T>\nPoint<T> projectPointToSegment(const Point<T>& p, const Segment<T>& s)\n{\n\tconst Point<T> a = p - s.p1;\n\tconst Point<T> b = s.p2 - s.p1;\n\treturn s.p1 + (s.p2 - s.p1)*(innerProduct(a, b) /norm(b));\n}\n\ntemplate<typename T>\narray<Point<T>, 2> getIntersectionOfCircleAndLine(const Circle<T>& c, const Segment<T>& s)\n{\n\tconst T h = getDistanceFromPointToLine(c.center, s);\n\t// supposing c,radius >= h\n\tconst T d = sqrt(c.radius*c.radius - h*h);\n\tconst Point<T> v = unit(s.p2 - s.p1);\n\tconst Point<T> foot = projectPointToSegment(c.center, s);\n\t\n\tarray<Point<T>, 2> ret;\n\tret.at(0) = foot + v*d;\n\tret.at(1) = foot - v*d;\n\treturn ret;\n}\n\nint main()\n{\n\tCircle<NUM> c;\n\treadCircle(c);\n\tint q; cin >> q;\n\tfor (int i = 0; i != q; ++i) {\n\t\tSegment<NUM> s;\n\t\treadSegment(s);\n\t\tarray<Point<NUM>, 2> points = getIntersectionOfCircleAndLine(c, s);\n\t\tsort(points.begin(), points.end(), Point<NUM>::compByCrd);\n\t\tcout << fixed;\n\t\tcout << setprecision(8) << points.at(0).x;\n\t\tcout << \" \";\n\t\tcout << setprecision(8) << points.at(0).y;\n\t\tcout << \" \";\n\t\tcout << setprecision(8) << points.at(1).x;\n\t\tcout << \" \";\n\t\tcout << setprecision(8) << points.at(1).y;\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\nint sign(double x) {\n    if (fabs(x) < EPS) {\n        return 0;\n    } else if (x > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nint dcmp(double x, double y) {\n    return sign(x - y);\n}\n\ndouble cosLaw(double a, double b, double c) {\n    return acos((a * a + b * b - c * c) / (2 * a * b));\n}\n\nstruct Vector;\ntypedef Vector Point;\nstruct Line;\nstruct Circle;\n\nstruct Vector {\n    double x;\n    double y;\n\n    explicit Vector(double x = 0, double y = 0);\n\n    Vector operator+(const Vector &rhs) const;\n    Vector operator-() const;\n    Vector operator-(const Vector &rhs) const;\n    Vector operator*(double d) const;\n    Vector operator/(double d) const;\n\n    bool operator==(const Vector &rhs) const;\n    bool operator!=(const Vector &rhs) const;\n    bool operator<(const Vector &rhs) const;\n    bool operator>(const Vector &rhs) const;\n    bool operator<=(const Vector &rhs) const;\n    bool operator>=(const Vector &rhs) const;\n\n    friend std::ostream &operator<<(std::ostream &os, const Vector &vector);\n\n    double dot(const Vector &rhs) const;\n    double cross(const Vector &rhs) const;\n    double length() const;\n    double angle() const;\n    double angle(const Vector &rhs) const;\n    Vector rotate(double rad) const;\n    Vector normal() const;\n    double getDistanceTo(const Point &rhs) const;\n};\n\nstruct Line {\n    Point a;\n    Point b;\n\n    Line(double x1 = 0, double y1 = 0, double x2 = 0, double y2 = 0);\n    Line(const Point &a = Point(), const Point &b = Point());\n\n    double getDistanceTo(const Point &rhs) const;\n    Point getIntersection(const Line &rhs) const;\n    Point getProjection(const Point &rhs) const;\n    Point getReflection(const Point &rhs) const;\n    bool contains(const Point &rhs) const;\n    bool intersects(const Line &rhs) const;\n};\n\nstruct Circle {\n    Point center;\n    double r;\n\n    enum class IntersectsLine {\n        NOT_CROSS,\n        TANGENT,\n        INTERSECT\n    };\n\n    enum class IntersectsCircle {\n        NOT_CROSS,\n        CIRCUMSCRIBED,\n        INTERSECT,\n        INSCRIBED,\n        INCLUDE\n    };\n\n    explicit Circle(double x = 0, double y = 0, double r = 0);\n    explicit Circle(const Point &c = Point(), double r = 0);\n    Circle(const Point &a, const Point &b, const Point &c);\n\n    double area() const;\n    double circumstance() const;\n    bool contains(const Point &rhs, bool onLine = true) const;\n    IntersectsLine intersects(const Line &rhs) const;\n    IntersectsCircle intersects(const Circle &rhs) const;\n    double getDistanceTo(const Circle &rhs) const;\n    Point point(double a) const;\n    std::vector<Point> getIntersections(const Circle &rhs) const;\n    std::vector<Point> getIntersections(const Line &rhs) const;\n    double getAreaOfOverlap(const Circle &rhs) const;\n};;\n\nVector::Vector(double x, double y) : x(x), y(y) {}\n\nVector Vector::operator+(const Vector &rhs) const {\n    return Vector(x + rhs.x, y + rhs.y);\n}\n\nVector Vector::operator-() const {\n    return Vector(-x, -y);\n}\n\nVector Vector::operator-(const Vector &rhs) const {\n    return *this + -rhs;\n}\n\nVector Vector::operator*(double d) const {\n    return Vector(x * d, y * d);\n}\n\nVector Vector::operator/(double d) const {\n    return Vector(x / d, y / d);\n}\n\n\nbool Vector::operator==(const Vector &rhs) const {\n    return dcmp(x, rhs.x) == 0 && dcmp(y, rhs.y) == 0;\n}\n\nbool Vector::operator!=(const Vector &rhs) const {\n    return !(rhs == *this);\n}\n\nbool Vector::operator<(const Vector &rhs) const {\n    if (dcmp(x, rhs.x) != 0) {\n        return dcmp(x, rhs.x) < 0;\n    } else {\n        return dcmp(y, rhs.y) < 0;\n    }\n}\n\nbool Vector::operator>(const Vector &rhs) const {\n    return rhs < *this;\n}\n\nbool Vector::operator<=(const Vector &rhs) const {\n    return !(rhs < *this);\n}\n\nbool Vector::operator>=(const Vector &rhs) const {\n    return !(*this < rhs);\n}\n\nstd::ostream &operator<<(std::ostream &os, const Vector &vector) {\n    os << \"(\" << vector.x << \", \" << vector.y << \")\";\n    return os;\n}\n\ndouble Vector::dot(const Vector &rhs) const {\n    return x * rhs.x + y * rhs.y;\n}\n\ndouble Vector::cross(const Vector &rhs) const {\n    return x * rhs.y - rhs.x * y;\n}\n\ndouble Vector::length() const {\n    return sqrt(dot(*this));\n}\n\ndouble Vector::angle() const {\n    return atan2(y, x);\n}\n\ndouble Vector::angle(const Vector &rhs) const {\n    return acos(dot(rhs) / length() / rhs.length());\n}\n\nVector Vector::rotate(double rad) const {\n    return Vector(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad));\n}\n\nVector Vector::normal() const {\n    double l = length();\n    return Vector(-y / l, x / l);\n}\n\ndouble Vector::getDistanceTo(const Point &rhs) const {\n    return sqrt(pow(x - rhs.x, 2) + pow(y - rhs.y, 2));\n}\n\nLine::Line(double x1, double y1, double x2, double y2) : a(x1, y1), b(x2, y2) {}\n\nLine::Line(const Point &a, const Point &b) : a(a), b(b) {}\n\ndouble Line::getDistanceTo(const Point &rhs) const {\n    const Vector &v1 = b - a;\n    const Vector &v2 = rhs - a;\n    return fabs(v1.cross(v2) / v1.length());\n}\n\nPoint Line::getIntersection(const Line &rhs) const {\n    if (!intersects(rhs)) {\n        return Point();\n    }\n    Vector u = a - rhs.a;\n    Vector v = b - a;\n    Vector w = rhs.b - rhs.a;\n    double t = w.cross(u) / v.cross(w);\n    return a + v * t;\n}\n\nPoint Line::getProjection(const Point &rhs) const {\n    const Vector &v = b - a;\n    return a + v * (v.dot(rhs - a) / v.dot(v));\n}\n\nPoint Line::getReflection(const Point &rhs) const {\n    // TODO get reflection\n    return Point();\n}\n\nbool Line::contains(const Point &rhs) const {\n    Point p1 = a;\n    Point p2 = b;\n    if (p1 == rhs) {\n        p1 = p1 + (p2 - p1) * 2;\n    } else if (p2 == rhs) {\n        p2 = p2 + (p1 - p2) * 2;\n    }\n    return sign((p2 - rhs).cross(p1 - rhs)) == 0;\n}\n\nbool Line::intersects(const Line &rhs) const {\n    return dcmp((b - a).angle(), (rhs.b - rhs.a).angle()) != 0;\n}\n\nCircle::Circle(double x, double y, double r) : center(x, y), r(r) {}\n\nCircle::Circle(const Point &c, double r) : center(c), r(r) {}\n\nCircle::Circle(const Point &a, const Point &b, const Point &c) {\n    double a1 = b.x - a.x;\n    double b1 = b.y - a.y;\n    double c1 = (a1 * a1 + b1 * b1) / 2;\n    double a2 = c.x - a.x;\n    double b2 = c.y - a.y;\n    double c2 = (a2 * a2 + b2 * b2) / 2;\n    double d = a1 * b2 - a2 * b1;\n    center = Point(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);\n    r = center.getDistanceTo(a);\n}\n\nbool Circle::contains(const Point &rhs, bool onLine) const {\n    double dis = center.getDistanceTo(rhs);\n    if (onLine) {\n        return dcmp(dis, r) <= 0;\n    } else {\n        return dcmp(dis, r) < 0;\n    }\n}\n\ndouble Circle::getDistanceTo(const Circle &rhs) const {\n    return center.getDistanceTo(rhs.center);\n}\n\nPoint Circle::point(double a) const {\n    return Point(center.x + cos(a) * r, center.y + sin(a) * r);\n}\n\nstd::vector<Point> Circle::getIntersections(const Circle &rhs) const {\n    std::vector<Point> res;\n    double d = getDistanceTo(rhs);\n    if (sign(d) == 0) {\n        return res;\n    } else if (dcmp(r + rhs.r, d) < 0) {\n        return res;\n    } else if (dcmp(fabs(r - rhs.r), d) > 0) {\n        return res;\n    }\n\n    double a = (rhs.center - center).angle();\n    double da = acos((r * r + d * d - rhs.r * rhs.r) / (2 * r * d));\n    Point p1 = point(a - da);\n    Point p2 = point(a + da);\n    res.push_back(p1);\n    if (p1 != p2) {\n        res.push_back(p2);\n    }\n    return res;\n}\n\nstd::vector<Point> Circle::getIntersections(const Line &rhs) const {\n    std::vector<Point> res;\n    IntersectsLine pos = intersects(rhs);\n    switch (pos) {\n        case IntersectsLine::INTERSECT: {\n            Point u = rhs.getProjection(center);\n            Vector v = (rhs.b - rhs.a);\n            v = v / v.length();\n            double d = sqrt(pow(r, 2) - pow(u.getDistanceTo(center), 2));\n            v = v * d;\n            res.push_back(u + v);\n            res.push_back(u - v);\n            break;\n        }\n        case IntersectsLine::TANGENT: {\n            res.push_back(rhs.getProjection(center));\n            break;\n        }\n        case IntersectsLine::NOT_CROSS: {\n            break;\n        }\n    }\n    return res;\n}\n\ndouble Circle::getAreaOfOverlap(const Circle &rhs) const {\n    double d = getDistanceTo(rhs);\n    if (dcmp(r + rhs.r, d) <= 0) {\n        return 0;\n    } else if (dcmp(fabs(r - rhs.r), d) >= 0) {\n        double radius = std::min(r, rhs.r);\n        return PI * radius * radius;\n    }\n    double angle1 = cosLaw(r, d, rhs.r);\n    double angle2 = cosLaw(rhs.r, d, r);\n    double s1 = area() * angle1 * 2 / (2 * PI);\n    double s2 = rhs.area() * angle2 * 2 / (2 * PI);\n    double s3 = 2 * 0.5 * r * d * sin(angle1);\n    return s1 + s2 - s3;\n}\n\ndouble Circle::area() const {\n    return PI * r * r;\n}\n\ndouble Circle::circumstance() const {\n    return 2 * PI * r;\n}\n\nCircle::IntersectsLine Circle::intersects(const Line &rhs) const {\n    double d = rhs.getDistanceTo(center);\n    int res = dcmp(d, r);\n    if (res == 0) {\n        return IntersectsLine::TANGENT;\n    } else if (res > 0) {\n        return IntersectsLine::NOT_CROSS;\n    } else {\n        return IntersectsLine::INTERSECT;\n    }\n}\n\nint main() {\n//    freopen(\"data.in\", \"r\", stdin);\n\n    int q;\n    int x, y, r;\n    while (~scanf(\"%d%d%d\", &x, &y, &r)) {\n        Circle circle(x, y, r);\n        scanf(\"%d\", &q);\n        while (q--) {\n            int x1, y1;\n            int x2, y2;\n            scanf(\"%d%d\", &x1, &y1);\n            scanf(\"%d%d\", &x2, &y2);\n            vector<Point> vector = circle.getIntersections(Line(x1, y1, x2, y2));\n            if (vector.size() == 1) {\n                vector.push_back(vector.back());\n            }\n            if (vector.front().x > vector.back().x || (vector.front().x == vector.back().x && vector.front().y > vector.back().y)) {\n                swap(vector[0], vector[1]);\n            }\n            printf(\"%.10lf %.10lf \", vector.front().x, vector.front().y);\n            printf(\"%.10lf %.10lf\\n\", vector.back().x, vector.back().y);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef struct node\n{\n\tdouble x, y;\n}NODE;\ninline NODE Vector(NODE A, NODE B);  //向量AB\ndouble cross(NODE A, NODE B, NODE P);\ndouble dis2(NODE a, NODE b);\ndouble disLine(NODE A, NODE B, NODE P);\ndouble dot(NODE A, NODE B, NODE P);\nNODE prxy(NODE A, NODE B, NODE O);\nint main()\n{\n\tNODE A, B, O;\n\tdouble r;\n\tint q;\n\tcin >> O.x >> O.y>>r;\n\tcin >> q;\n\twhile (q--)\n\t{\n\t\tcin >> A.x >> A.y >> B.x >> B.y;\n\t\tNODE pr = prxy(A, B, O);\n\t\tdouble base = sqrt(r*r - disLine(A, B, O)*disLine(A, B, O));\n\t\tNODE AB = Vector(A, B);\n\t\tNODE e = { AB.x / sqrt(dis2(A, B)), AB.y / sqrt(dis2(A, B)) };\n\t\tNODE Base = { e.x*base, e.y*base };\n\t\tNODE x1 = { Base.x + pr.x, Base.y + pr.y };\n\t\tNODE x2 = { pr.x - Base.x, pr.y - Base.y };\n\t\tif (x1.x<x2.x)\n\t\t\t//cout << x1.x << ' ' << x1.y << ' ' << x2.x << ' ' << x2.y << endl;\n\t\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\",x1.x,x1.y,x2.x,x2.y);\n\t\telse if (x1.x>x2.x)\n\t\t\t//cout << x2.x << ' ' << x2.y << ' ' << x1.x << ' ' << x1.y << endl;\n\t\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", x2.x, x2.y, x1.x, x1.y);\n\t\telse if (x1.x == x2.x)\n\t\t{\n\t\t\tif (x1.y < x2.y)\n\t\t\t\t//cout << x1.x << ' ' << x1.y << ' ' << x2.x << ' ' << x2.y << endl;\n\t\t\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", x1.x, x1.y, x2.x, x2.y);\n\t\t\telse\n\t\t\t\t//cout << x2.x << ' ' << x2.y << ' ' << x1.x << ' ' << x1.y << endl;\n\t\t\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", x2.x, x2.y, x1.x, x1.y);\n\t\t}\n\t}\n\treturn 0;\n}\n\nNODE prxy(NODE A,NODE B,NODE O)\n{\n\tNODE AO = Vector(A, O);\n\tNODE AB = Vector(A, B);\n\tdouble l = dot(A, B, O) / sqrt(dis2(A, B));\n\tNODE e = { AB.x / sqrt(dis2(A, B)), AB.y / sqrt(dis2(A, B)) };\n\tNODE Apr = { e.x*l, e.y*l };\n\treturn{ A.x + Apr.x, A.y + Apr.y };\n}\ndouble disLine(NODE A, NODE B, NODE P)\n{\n\treturn fabs(cross(A,B,P))/sqrt(dis2(A,B));\n}\ndouble dot(NODE A, NODE B, NODE P)\n{\n\tNODE AB = Vector(A, B);\n\tNODE AP = Vector(A, P);\n\treturn AB.x*AP.x + AB.y*AP.y;\n}\ndouble dis2(NODE a, NODE b)\n{\n\treturn (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y);\n}\ndouble cross(NODE A, NODE B, NODE P)\n{\n\tNODE AB = Vector(A, B);\n\tNODE AP = Vector(A, P);\n\treturn AB.x*AP.y - AB.y*AP.x;\n}\ninline NODE Vector(NODE A, NODE B)\n{\n\treturn{ B.x - A.x, B.y - A.y };\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n\n// Circle // verified: AOJ 1183 \nenum RCC{OUT=2,ON_OUT=1,ISC=0,ON_IN=-1,IN=-2};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\n\n// cross point between circle and line \n// verified: AOJ CGL_7_D\nP cir(C c,R t){return c.c+polar(c.r,t);}\nVP cross(C c, L l){\n\tP h=proj(l,c.c),e=polar(sq(norm(c.r)-norm(h-c.c)),arg(l.t-l.s));\n\treturn VP{h-e,h+e};\n}\n\nint main(void){\n\tint q;\n\tC c;\n\tcin >> c.c >> c.r;\n\t\t\n\tcin >> q;\n\tcout.precision(20);\n\trep(i,q){\n\t\tP a,b;\n\t\tcin >> a >> b;\n\t\tL l={a,b};\n\t\tVP res=cross(c,l);\n\t\tif(sgn(real(res[0])-real(res[1])>0) swap(res[0],res[1]);\n\t\tif(sgn(real(res[0])-real(res[1]))==0 and sgn(imag(res[0])-imag(res[1]))>0) swap(res[0],res[1]);\n\t\tcout << fixed << res[0] << \" \" << res[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*****************************\n*\tGeometry Template          *\n*\tdouble !!!                 *\n*\tTODO: test everything!!!   *\n*****************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double INF = 1e17;\nconst double EPS = 1e-9;\nconst double PI = 2.0 * asin(1);\n\ninline int sign(const double x) {\n\tif (abs(x) < EPS) {\n\t\treturn 0;\n\t}\n\tif (x < 0.0) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\ninline bool is_in(double a, double b, double x) {\n\tif (a > b) {\n\t\tswap(a, b);\n\t}\n\treturn (a - EPS <= x && x <= b + EPS);\n}\n\nstruct point {\n\tdouble x, y;\n\tpoint() {}\n\tpoint(double _x, double _y) : x(_x), y(_y) {}\n};\n\nbool operator < (const point &P, const point &Q) {\n\tif (abs(P.y - Q.y) > EPS) {\n\t\treturn P.y < Q.y;\n\t}\n\tif (abs(P.x - Q.x) > EPS) {\n\t\treturn P.x < Q.x;\n\t}\n\treturn false;\n}\n\nstruct compare_x {\n\tbool operator () (const point &P, const point &Q) {\n\t\tif (abs(P.x - Q.x) > EPS) {\n\t\t\treturn P.x < Q.x;\n\t\t}\n\t\treturn P.y < Q.y;\n\t}\n};\n\nstruct compare_y {\n\tbool operator () (const point &P, const point &Q) {\n\t\tif (abs(P.y - Q.y) > EPS) {\n\t\t\treturn P.y < Q.y;\n\t\t}\n\t\treturn P.x < Q.x;\n\t}\n};\n\ninline void read(point &P) {\n\tcin >> P.x >> P.y;\n}\n\npoint operator + (const point &P, const point &Q) {\n\treturn point(P.x + Q.x, P.y + Q.y);\n}\n\npoint operator - (const point &P, const point &Q) {\n\treturn point(P.x - Q.x, P.y - Q.y);\n}\n\npoint operator * (const point &P, const double k) {\n\treturn point(P.x * k, P.y * k);\n}\n\npoint operator / (const point &P, const double k) {\n\tassert(fabs(k) > EPS);\n\treturn point(P.x / k, P.y / k);\n}\n\ninline int half_plane(const point &P) {\n\tif (abs(P.y) > EPS) {\n\t\tif (P.y > 0) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn -1;\n\t}\n\tif (P.x > 0) {\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\ninline double dot(const point &P, const point &Q) {\n\treturn P.x * Q.x + P.y * Q.y;\n}\n\ninline double cross(const point &P, const point &Q) {\n\treturn P.x * Q.y - P.y * Q.x;\n}\n\ninline double norm2(const point &P) {\n\treturn dot(P, P);\n}\n\ninline double norm(const point &P) {\n\treturn sqrt(dot(P, P));\n}\n\ninline double dist2(const point &P, const point &Q) {\n\treturn norm2(P - Q);\n}\n\n/// returns distance between P and Q\ninline double dist(const point &P, const point &Q) {\n\treturn sqrt(dot(P - Q, P - Q));\n}\n\n/// returns true if P belongs in segment AB\ninline bool is_in(point A, point B, point P) {\n\tif (abs(cross(B - A, P - A)) > EPS) {\n\t\treturn false;\n\t}\n\treturn (is_in(A.x, B.x, P.x) && is_in(A.y, B.y, P.y));\n}\n\n/// projects point P in line P1, P2\ninline point project(const point &P, const point &P1, const point &P2) {\n\treturn P1 + (P2 - P1) * (dot(P2 - P1, P - P1) / norm2(P2 - P1));\n}\n\ninline point reflect(const point &P, const point &P1, const point &P2) {\n\treturn project(P, P1, P2) * 2.0 - P;\n}\n\n/// distance from point P to the straigh line that passes through A and B\ninline double point_to_line(const point &P, const point &A, const point &B) {\n\t// return abs(cross(B - A, C - A) / norm(B - A));\n\treturn dist(P, project(P, A, B));\n}\n\n/// distance from point P to segment AB\ninline double point_to_segment(const point &P, const point &A, const point &B) {\n\tpoint PP = project(P, A, B);\n\tif (is_in(A, B, PP)) {\n\t\treturn dist(P, PP);\n\t}\n\treturn min(dist(P, A), dist(P, B));\n}\n\n/// line to line intersection\n/// A, B difine the first line\n/// C, D define the second line\ninline point intersect(const point &A, const point &B, const point &C, const point &D) {\n\treturn A + (B - A) * (cross(C - A, C - D) / cross(B - A, C - D));\n}\n\n/// distance between segmente AB and CD\ninline double segment_to_segment(const point &A, const point &B, const point &C, const point &D) {\n\tpoint I = intersect(A, B, C, D);\n\tif (is_in(A, B, I) && is_in(C, D, I)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(point_to_segment(A, C, D), point_to_segment(B, C, D)),\n\t\t\t\t\t\t min(point_to_segment(C, A, B), point_to_segment(D, A, B)));\n}\n\n/// rotate point P angle radians\ninline point rotate_point(const point &P, double angle) {\n\treturn point(P.x * cos(angle) - P.y * sin(angle), P.y * cos(angle) + P.x * sin(angle));\n}\n\n/// center of a circle that passes through points A, B, C\ninline point circle_center(const point &A, const point &B, const point &C) {\n\tassert(abs(cross(B - A, C - A)) > EPS); // no colinear\n\treturn intersect((A + B) / 2.0, (A + B) / 2.0 + rotate_point(B - A, PI),\n\t\t\t\t\t\t\t\t\t (B + C) / 2.0, (B + C) / 2.0 + rotate_point(C - B, PI));\n}\n\n/// tangent to a circle with center in C and radius r, passes through P --> tested OK\ninline pair <point, point> point_circle_tangent(const point &P, const point &C, const double r) {\n\tdouble d = dist(P, C);\n\tdouble l = sqrt(d * d - r * r);\n\tdouble a = asin(r / d);\n\treturn make_pair(P + rotate_point((C - P) * (l / d), a), P + rotate_point((C - P) * (l / d), -a));\n}\n\n/// common tangents to a pair of circles\ninline vector <pair <point, point> > common_tangents(const point &C1, const double r1, const point C2, const double r2) {\n\t/// TODO\n}\n\n/// line to circle intersection\ninline vector <point> line_circle_intersect(const point &A, const point &B, const point &C, const double r) {\n\tpoint PC = project(C, A, B);\n\tdouble d = dist(C, PC);\n\tif (d > r + EPS) {\n\t\treturn vector <point> ();\n\t}\n\tif (abs(d - r) <= EPS) {\n\t\treturn vector <point> (1, PC);\n\t}\n\tdouble l = sqrt(r * r - d * d);\n\tvector <point> res(2);\n\tdouble dAB = dist(A, B);\n\tres[0] = PC + (B - A) * (l / dAB);\n\tres[1] = PC - (B - A) * (l / dAB);\n\treturn res;\n}\n\n/// signed polygon area O(n)\ninline double signed_area(const vector <point> &polygon) {\n\tdouble res = 0.0;\n\tint n = polygon.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i + 1 == n) ? 0 : i + 1;\n\t\tres += cross(polygon[i], polygon[j]);\n\t}\n\treturn 0.5 * res;\n}\n\n/// polygon area O(n)\ninline double abs_area(const vector <point> &polygon) {\n\treturn abs(signed_area(polygon));\n}\n\n/// closest pair of points O(n * log(n))\ninline double closest_pair_of_points(vector <point> pts) {\n\tsort(pts.begin(), pts.end(), compare_x());\n\tmultiset <point> candidates;\n\tint n = pts.size();\n\tdouble res = INF;\n\tfor (int i = 0, last = 0; i < n; i++) {\n\t\twhile (last < i && pts[i].x - pts[last].x >= res + EPS) {\n\t\t\tcandidates.erase(candidates.find(pts[last]));\n\t\t\tlast++;\n\t\t}\n\t\tset <point> :: iterator lo = candidates.lower_bound(point(-INF, pts[i].y - res - EPS));\n\t\tset <point> :: iterator hi = candidates.upper_bound(point(INF, pts[i].y + res + EPS));\n\t\twhile (lo != hi) {\n\t\t\tres = min(res, dist(pts[i], *lo));\n\t\t\tlo++;\n\t\t}\n\t\tcandidates.insert(pts[i]);\n\t}\n\treturn res;\n}\n\ninline vector <point> minkowsky_sum(vector <point> &VA, const vector <point> &VB) {\n\t/// TODO\n}\n\n/// further pair of points\ninline double convex_diameter(const vector <point> &polygon) {\n\t/// TODO\n}\n\ninline vector <point> normalize_polygon(vector <point> pts) {\n\t/// TODO\n}\n\ninline vector <point> convex_hull(vector <point> pts) {\n\t/// TODO\n}\n\ninline bool point_inside_polygon(const point &P, const vector <point> &polygon) {\n\t/// TODO\n}\n\ninline bool point_inside_convex(const point &P, const vector <point> &polygon) {\n\t/// TODO\n}\n\nstruct line {\n\tdouble a, b, c;\n};\n\ninline vector <point> half_planes_intersection(const vector <line> &half_planes) {\n\t/// TODO\n}\n\n/// randomized algorithm -> expected time O(n)\ninline pair <point, double> min_enclosing_circle(vector <point> pts) {\n\t///\n}\n\ninline point centroid(const vector <point> &polygon) {\n\t/// TODO\n}\n\n/// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\n/// test ok\nvoid testPolygonArea() {\n    int n;\n    cin >> n;\n    vector <point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        read(polygon[i]);\n    }\n    cout.precision(1);\n    cout << fixed << abs_area(polygon) << \"\\n\";\n}\n\n/// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\n/// test ???\nvoid test_line_circle_intersect() {\n\tpoint C;\n\tdouble r;\n\tcin >> C.x >> C.y >> r;\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tpoint A, B;\n\t\tcin >> A.x >> A.y >> B.x >> B.y;\n\t\tvector <point> answer = line_circle_intersect(A, B, C, r);\n\t\tassert(answer.size() != 0);\n\t\tif (answer.size() == 1) {\n\t\t\tanswer.push_back(answer.back());\n\t\t}\n\t\tif (answer[1].x < answer[0].x || (answer[1].x == answer[0].x && answer[1].y < answer[0].y)) {\n\t\t\tswap(answer[0], answer[1]);\n\t\t}\n\t\tcout << fixed << answer[0].x << \" \" << fixed << answer[0].y << \" \" << fixed << answer[1].x << \" \" << fixed << answer[1].y << \"\\n\";\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n\n\t// testPolygonArea();\n\ttest_line_circle_intersect();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define PII pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define MP make_pair\n\nclass Point;\nclass Segment;\nclass circle;\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double X = 0, double Y = 0)\n\t{\n\t\tx = X;\n\t\ty = Y;\n\t}\n\tPoint operator +(const Point &p)const { return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p)const { return Point(x - p.x, y - p.y); };\n\tPoint operator *(const double a)const { return Point(x*a, y*a); };\n\tPoint operator /(const double a)const { return Point(x / a, y / a); };\n\tdouble norm()const { return x*x + y*y; };\n\tdouble length()const { return sqrt(norm()); };\n\tdouble dot(const Point &p)const { return x*p.x + y*p.y; };\n\tdouble cross(const Point &p)const { return x*p.y - y*p.x; };\n\tPoint normalize()const\n\t{\n\t\tPoint ans(x, y);\n\t\treturn ans = ans / ans.length();\n\t}\n\tbool operator ==(const Point &p)const\n\t{\n\t\treturn fabs(x - p.x)<EPS &&fabs(y - p.y)<EPS;\n\t}\n\tfriend ostream& operator <<(ostream& os, const Point &p);\n\tint CCW(Point p1, Point p2)\n\t{\n\t\tPoint p0(x, y);\n\t\tPoint V1 = p1 - p0;\n\t\tPoint V2 = p2 - p0;\n\t\tif (V1.cross(V2) > 0.0)return -1;\n\t\telse if (V1.cross(V2) < 0.0)return 1;\n\t\telse if (V1.dot(V2) < 0.0)return -2;\n\t\telse if (V1.norm() < V2.norm())return 2;\n\t\treturn 0;\n\t}\n};\ntypedef Point Vector;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point C = Point(), double R = 0)\n\t{\n\t\tc = C;\n\t\tr = R;\n\t}\n};\n\nostream& operator <<(ostream& os, const Point &p)\n{\n\treturn os << \"(\" << p.x << \",\" << p.y << \")\";\n}\n\nclass Segment\n{\npublic:\n\tPoint p1, p2;\n\tSegment(double x1, double y1, double x2, double y2)\n\t{\n\t\tp1.x = x1;\n\t\tp1.y = y1;\n\t\tp2.x = x2;\n\t\tp2.y = y2;\n\t}\n\tdouble GetLength()\n\t{\n\t\tPoint temp = p2 - p1;\n\t\treturn temp.length();\n\t}\n\tdouble GetDistanceSeg(double X, double Y)\n\t{\n\t\tPoint p(X, Y);\n\t\tPoint a = p2 - p1;\n\t\tPoint b = p - p1;\n\t\tPoint c = p1 - p2;\n\t\tPoint d = p - p2;\n\t\tif (a.dot(b) < 0.0)return b.length();\n\t\tif (c.dot(d) < 0.0)return d.length();\n\t\treturn GetDistanceLine(X, Y);\n\t}\n\tdouble GetDistanceLine(double X, double Y)\n\t{\n\t\tPoint t(X, Y);\n\t\tPoint a = p2 - p1;\n\t\tPoint b = t - p1;\n\t\treturn abs(a.cross(b) / a.length());\n\t}\n\tbool IsIntersect(Segment &s)\n\t{\n\t\tint s1, s2;\n\t\ts1 = p1.CCW(p2, s.p1)*p1.CCW(p2, s.p2);\n\t\ts2 = s.p1.CCW(s.p2, p1)*s.p1.CCW(s.p2, p2);\n\t\treturn s1 <= 0 && s2 <= 0;\n\t}\n\tbool IsIntersect(Circle &Cir)\n\t{\n\t\treturn GetDistanceLine(Cir.c.x, Cir.c.y) - Cir.r <= EPS;\n\t}\n\tbool IsOrthogonal(const Segment &s)\n\t{\n\t\tVector t1 = p2 - p1;\n\t\tVector t2 = s.p2 - s.p1;\n\t\treturn equals(0.0, t1.dot(t2));\n\t}\n\tbool IsParallel(const Segment &s)\n\t{\n\t\tVector t1 = p2 - p1;\n\t\tVector t2 = s.p2 - s.p1;\n\t\treturn equals(0.0, t1.cross(t2));\n\t}\n\tPoint GetProjection(double X, double Y)const\n\t{\n\t\tVector V = p2 - p1;\n\t\tPoint P(X, Y);\n\t\tPoint ret = V*(V.dot(P - p1) / V.norm());\n\t\treturn ret + p1;\n\t}\n\tPoint GetProjection(Point p)const\n\t{\n\t\tVector V = p2 - p1;\n\t\tPoint ret = V*(V.dot(p - p1) / V.norm());\n\t\treturn ret + p1;\n\t}\n\tPoint GetReflect(double X, double Y)\n\t{\n\t\tPoint t(X, Y);\n\t\tPoint Pro = GetProjection(X, Y);\n\t\tVector dV = Pro - t;\n\t\treturn t + dV*2.0;\n\t}\n\tPoint GetCrossPoint(Segment &s)\n\t{\n\t\tPoint P2 = p2 - p1;\n\t\tPoint P3 = s.p1 - p1;\n\t\tPoint P4 = s.p2 - p1;\n\t\tdouble d1 = abs(P2.cross(P3));\n\t\tdouble d2 = abs(P2.cross(P4));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint ans = (P4 - P3)*t + P3 + p1;\n\t\treturn ans;\n\t}\n\tpair<Point, Point> GetCrossPoint(Circle &Cir)\n\t{\n\t\ttry { if (!IsIntersect(Cir)) { throw \"error\"; } }\n\t\tcatch (string str) { cout << str << endl; }\n\t\tVector pr = GetProjection(Cir.c);\n\t\tVector p = (p2 - p1).normalize();\n\t\tdouble l = sqrt(Cir.r*Cir.r - (pr - Cir.c).norm());\n\t\treturn make_pair(p*l + pr, p*(-l) + pr);\n\t}\n};\ntypedef Segment Line;\n\n\nint main()\n{\n\tdouble x, y, r;\n\tcin >> x >> y >> r;\n\tCircle Cir(Point(x, y), r);\n\tint q;\n\tcin >> q;\n\tREP(i, q)\n\t{\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1>> y1>> x2>> y2;\n\t\tSegment s(x1, y1, x2, y2);\n\t\tpair<Point, Point> ans = s.GetCrossPoint(Cir);\n\t\tPoint p1 = ans.first;\n\t\tPoint p2 = ans.second;\n\t\tif (p1.x < p2.x)\n\t\t{\n\t\t\tcout << fixed << setprecision(10) << p1.x << \" \";\n\t\t\tcout << fixed << setprecision(10) << p1.y << \" \";\n\t\t\tcout << fixed << setprecision(10) << p2.x << \" \";\n\t\t\tcout << fixed << setprecision(10) << p2.y << endl;\n\t\t}\t\t\n\t\telse if (equals(p1.x, p2.x))\n\t\t{\n\t\t\tif (p1.y < p2.y)\n\t\t\t{\n\t\t\t\tcout << fixed << setprecision(10) << p1.x << \" \";\n\t\t\t\tcout << fixed << setprecision(10) << p1.y << \" \";\n\t\t\t\tcout << fixed << setprecision(10) << p2.x << \" \";\n\t\t\t\tcout << fixed << setprecision(10) << p2.y << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << fixed << setprecision(10) << p2.x << \" \";\n\t\t\t\tcout << fixed << setprecision(10) << p2.y << \" \";\n\t\t\t\tcout << fixed << setprecision(10) << p1.x << \" \";\n\t\t\t\tcout << fixed << setprecision(10) << p1.y << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << fixed << setprecision(10) << p2.x << \" \";\n\t\t\tcout << fixed << setprecision(10) << p2.y << \" \";\n\t\t\tcout << fixed << setprecision(10) << p1.x << \" \";\n\t\t\tcout << fixed << setprecision(10) << p1.y << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\nstruct Point\n{\n    double x, y;\n    Point() {}\n    Point(double _x,double _y):x(_x),y(_y) {}\n    Point operator +(Point a)\n    {\n        return Point(x+a.x,y+a.y);\n    }\n    Point operator -(Point a)\n    {\n        return Point(x-a.x,y-a.y);\n    }\n    Point operator *(double d)\n    {\n        return Point(x*d,y*d);\n    }\n    Point operator /(double d)\n    {\n        return Point(x/d,y/d);\n    }\n\n\n};\ndouble dot(Point a,Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\ndouble norm(Point a)\n{\n    return a.x*a.x+a.y*a.y;\n}\ndouble abs(Point a)\n{\n    return sqrt(norm(a));\n}\n\nint n;\ndouble r;\nPoint p0,p1,p2,p3,p4;\n\nPoint projection(Point p1,Point p2,Point p)\n{\n    Point a=p2-p1;\n    Point b=p-p1;\n    return p1+a*dot(a,b)/norm(a);\n\n\n}\nvoid solve(Point p1,Point p2,Point p)\n{\n    Point p2p1=p2-p1;\n    Point q=projection(p1,p2,p);\n    double m=sqrt(r*r-norm(q-p0));\n    Point e=p2p1/abs(p2p1);\n    Point q1=q-e*m;\n    Point q2=q+e*m;\n    if(q1.x==q2.x)\n    {\n        if(q1.y<q2.y)        printf(\"%.6lf %.6lf %.6lf %.6lf\\n\",q1.x,q1.y,q2.x,q2.y);\n        else  printf(\"%.6lf %.6lf %.6lf %.6lf\\n\",q2.x,q2.y,q1.x,q1.y);\n    }\n    else if(q1.x<q2.x) printf(\"%.6lf %.6lf %.6lf %.6lf\\n\",q1.x,q1.y,q2.x,q2.y);\n    else printf(\"%.6lf %.6lf %.6lf %.6lf\\n\",q2.x,q2.y,q1.x,q1.y);\n}\n\n\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%lf%lf%lf\",&p0.x,&p0.y,&r);\n    scanf(\"%d\",&n);\n    while(n--)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p1.x,&p1.y,&p2.x,&p2.y);\n        solve(p1,p2,p0);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\tcout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tif (equals(pr.abs(), r)) {\n\t\tVector ans = center + pr;\n\t\treturn make_pair(ans, ans);\n\t} else {\n\t\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * r;\n\t\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * r;\n\t\tif (ans1.x < ans2.x) {\n\t\t\treturn make_pair(ans1, ans2);\n\t\t} else {\n\t\t\treturn make_pair(ans2, ans1);\n\t\t}\n\t}\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n\nconst double kEpsilon = 1e-10;\ninline bool equals(double a, double b)\n{\n    return fabs(a - b) < kEpsilon;\n}\n\nclass Point\n{\n  public:\n    double x, y;\n\n    Point() = default;\n    Point(double x, double y) : x(x), y(y)\n    {\n    }\n\n    Point operator+(const Point &p)\n    {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator-(const Point &p)\n    {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator*(const double k)\n    {\n        return Point(x * k, y * k);\n    }\n    Point operator/(const double k)\n    {\n        return Point(x / k, y / k);\n    }\n\n    double SquaredNorm()\n    {\n        return x * x + y * y;\n    }\n    double abs()\n    {\n        return sqrt(this->SquaredNorm());\n    }\n\n    bool operator<(const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator==(const Point &p) const\n    {\n        return fabs(x - p.x) < kEpsilon && fabs(y - p.y) < kEpsilon;\n    }\n\n    double dot(const Point &p) const\n    {\n        return x * p.x + y * p.y;\n    }\n    double cross(const Point &p) const\n    {\n        return x * p.y - y * p.x;\n    }\n};\n\ndouble dot(const Point &p1, const Point &p2)\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\ndouble cross(const Point &p1, const Point &p2)\n{\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nusing Vector = Point;\n\nstruct Segment\n{\n    Point p1, p2;\n\n    Segment() = default;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2)\n    {\n    }\n};\nusing Line = Segment;\n\nclass Circle\n{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r)\n    {\n    }\n};\n\nPoint projection(Point &p1, Point &p2, Point &p)\n{\n    auto q = p2 - p1;\n    auto a = q.dot(p - p1) / q.SquaredNorm();\n    return p1 + q * a;\n}\n\nPoint projection(Line &l, Point &p)\n{\n    auto p1 = l.p1;\n    auto p2 = l.p2;\n    return projection(p1, p2, p);\n}\n\nstd::array<Point, 2> crossPointsCircleLine(Circle &c, Line &l)\n{\n\n    Vector q = l.p2 - l.p1;\n    if (l.p2 < l.p1)\n        q = q * (-1.);\n\n    Vector e = q / q.abs();\n    Point pr = projection(l, c.c);\n    double h = (c.c - pr).abs();\n    double length = sqrt(c.r * c.r - h * h);\n\n    std::array<Point, 2> cross = {pr - e * length, pr + e * length};\n\n    return cross;\n}\n\nint main()\n{\n    int q;\n    Circle c;\n    Line l;\n\n    std::cin >> c.c.x >> c.c.y >> c.r;\n    std::cin >> q;\n\n    for (size_t i = 0; i < q; ++i)\n    {\n        std::cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n        auto cross = crossPointsCircleLine(c, l);\n        printf(\"%.9f %.9f %.9f %.9f\\n\", cross[0].x, cross[0].y, cross[1].x, cross[1].y);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lb long double\n#define eps 1e-10\nusing namespace std;\nint n;\nstruct Po{lb x,y;}q1,q2;\nstruct circ{Po x;lb r;}p;\nPo operator - (Po x,Po y){return (Po){x.x-y.x,x.y-y.y};}\nPo operator +(Po x,Po y){return (Po){x.x+y.x,x.y+y.y};}\nlb operator *(Po x,Po y){return x.x*y.y-x.y*y.x;}\nlb operator ^(Po x,Po y){return x.x*y.x+x.y*y.y;}\nPo operator *(Po x,lb y){return (Po){x.x*y,x.y*y};}\nPo operator /(Po x,lb y){return (Po){x.x/y,x.y/y};}\nvoid get(Po &x){scanf(\"%Lf %Lf\",&x.x,&x.y);}\nlb dis2(Po x){return x.x*x.x+x.y*x.y;}\nlb dis(Po x){return sqrt(dis2(x));}\nint main(){\n\tget(p.x);scanf(\"%Lf\",&p.r);\n\tscanf(\"%d\",&n);\n\twhile (n--){\n\t\tget(q1);get(q2);\n\t\tlb x=((q2-q1)^(p.x-q1))/dis(q2-q1);\n\t\tPo xian=(q2-q1)/(dis(q2-q1));\n\t\tPo zh=q1+xian*x;\n\t\tlb de=sqrt(p.r*p.r-dis2(p.x-zh));\n\t\tPo an1=q1+xian*(x-de),an2=q1+xian*(x+de);\n\t\tif (an1.x>an2.x+eps||(fabs(an1.x-an2.x)<eps&&an1.y>an2.y+eps))swap(an1,an2);\n\t\tprintf(\"%.10Lf %.10Lf %.10Lf %.10Lf\\n\",an1.x,an1.y,an2.x,an2.y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator+(Point p){\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator*(double d){\n        return Point(x * d, y * d);\n    }\n};\ntypedef Point Vector;\ndouble dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\ndouble cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\nstruct Line{\n    Point p1;\n    Point p2;\n    Line(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c, double r): c(c), r(r) {}\n};\n\nPoint cross_point1(Circle c, Line l){\n    Vector b = l.p2 - l.p1;\n    Vector h = c.c - l.p1;\n    double d = fabs(cross(b, h)) / sqrt(dot(b, b));\n    Point x =  l.p1 + b * (dot(h, b) / dot(b, b));\n    return x + b * (sqrt(c.r * c.r - d * d) / sqrt(dot(b, b)));\n}\n\nPoint cross_point2(Circle c, Line l){\n    Vector b = l.p2 - l.p1;\n    Vector h = c.c - l.p1;\n    double d = fabs(cross(b, h)) / sqrt(dot(b, b));\n    Point x =  l.p1 + b * (dot(h, b) / dot(b, b));\n    return x - b * (sqrt(c.r * c.r - d * d) / sqrt(dot(b, b)));\n}\nvoid disp(Point a, Point b){\n    Point f = a;\n    Point s = b;\n    if (f.x > s.x || (f.x == s.x && f.y > s.y)) swap(f, s);\n    cout << fixed << setprecision(10);\n    cout << f.x << \" \" << f.y << \" \" << s.x << \" \" << s.y << endl;\n}\n\nint main(){\n    int cx, cy, r;\n    cin >> cx >> cy >> r;\n    Circle c(Point(cx, cy), r);\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line l(Point(x1, y1), Point(x2, y2));\n        disp(cross_point1(c, l), cross_point2(c, l));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{\n    L(const P &a, const P &b){\n        push_back(a), push_back(b);\n    }\n};\n\nstruct C {\n    P p; double r;\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nvoid crossPointsOfCircleAndLine(C &circle, L &l){\n    P p0 = circle.p;\n    double r = circle.r;\n    P p1 = l[0];\n    P p2 = l[1];\n    double x = real(p1-p0);\n    double y = imag(p1-p0);\n    double z = real(p2-p0);\n    double w = imag(p2-p0);\n    double a = y-w;\n    double b = -(x-z);\n    double c = y*z - x*w;\n\n    P cross1((a*c - b*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b), (b*c + a*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b));\n    P cross2((a*c + b*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b), (b*c - a*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b));\n\n    if(cross2 < cross1){\n        swap(cross1, cross2);\n    }\n    printf(\"%.10f %.10f \", cross1.real() + p0.real(), cross1.imag() + p0.imag());\n    printf(\"%.10f %.10f\\n\", cross2.real() + p0.real(), cross2.imag() + p0.imag());\n}\n\nint main(){\n    double cx, cy, r, x1, y1, x2, y2;\n    int q;\n    cin >> cx >> cy >> r >> q;\n    P p0(cx, cy);\n    C circle(p0, r);\n\n    for (int i=0;i<q;i++){\n        cin >> x1 >> y1 >> x2 >> y2 ;\n        P p1(x1, y1);\n        P p2(x2, y2);\n        L l(p1, p2);\n        crossPointsOfCircleAndLine(circle, l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\ntypedef double D;\nconst D PI = acos(-1.0);\nconst D EPS = 1e-10;\nstruct P {\n  D x, y;\n  P(D x=0, D y=0) : x(x), y(y) {}\n\n  P& operator+=(const P& o) { x += o.x; y += o.y; return *this; }\n  P& operator-=(const P& o) { x -= o.x; y -= o.y; return *this; }\n  P& operator*=(const P& o) { return *this = {x*o.x - y*o.y, x*o.y + y*o.x}; }\n  P& operator*=(const D& r) { x *= r; y *= r; return *this; }\n  P& operator/=(const D& r) { x /= r; y /= r; return *this; }\n  P operator-() const { return {-x, -y}; }\n\n  D norm() const { return x*x + y*y; }\n  D abs() const { return sqrt(norm()); }\n  D arg() const { return atan2(y, x); }\n  bool isZero() const { return std::abs(x) < EPS && std::abs(y) < EPS; }\n  /** 象限 */\n  int orth() const { return y >= 0 ? (x >= 0 ? 1 : 2) : (x < 0 ? 3 : 4); }\n  static P polar(const D& rho, const D& theta = 0) { return {rho * cos(theta), rho * sin(theta)}; }\n};\nstd::ostream &operator<<(std::ostream &os, P const &p) { return os << \"(\" << p.x << \", \" << p.y << \")\"; }\nstd::istream &operator>>(std::istream &is, P &p) { D a, b; is >> a >> b; p = P(a, b); return is; }\nP operator+(const P& p, const P& q) { return P(p) += q; }\nP operator-(const P& p, const P& q) { return P(p) -= q; }\nP operator*(const P& p, const P& q) { return P(p) *= q; }\nP operator*(const P& p, const D& r) { return P(p) *= r; }\nP operator/(const P& p, const D& r) { return P(p) /= r; }\nP operator*(const D& r, const P& p) { return P(p) *= r; }\nP operator/(const D& r, const P& p) { return P(p) /= r; }\nD crs(const P& a, const P& b){ return a.x*b.y - a.y*b.x; }\nD dot(const P& a, const P& b){ return a.x*b.x + a.y*b.y; }\nint signum(D x) {return x > EPS ? +1 : x < -EPS ? -1 : 0;}\nbool operator<(const P& a, const P& b) {\n  if (a.x != b.x) return a.x < b.x;\n  return a.y < b.y;\n}\n\n/** ベクトルpをベクトルbに射影したベクトル */\nP proj(const P& p, const P& b) {\n  P t = b * dot(p, b);\n  return t / b.norm();\n}\n/** 点pから直線abに引いた垂線の足となる点 */\nP footOfLP(const P& a, const P& b, const P& p) {\n  return a + proj(p-a, b-a);\n}\n\ndouble distLP(const P& a, const P& b, const P& c) {\n  return abs(crs(b-a, c-a)) / (b-a).abs();\n}\n\nint ccw(const P& a, P b, P c) {\n  // return signum(crs(b - a, c - a));\n  b -= a; c -= a;\n  if (crs(b, c) > 0)       return +1;       // counter clockwise\n  if (crs(b, c) < 0)       return -1;       // clockwise\n  if (dot(b, c) < 0)       return +2;       // c--a--b on line\n  if (b.norm() < c.norm()) return -2;       // a--b--c on line\n  return 0;\n}\nP intersectionLL(const P& a1, const P& a2, const P& b1, const P& b2){\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * crs(b, b1-a1) / crs(b, a);\n}\n// 凸多角形をある直線で切断し、左側を残す。\n// 凸多角形は半時計回りに与えられていること\nvector<P> convexCut(const vector<P>& ps, const P& p1, const P& p2) {\n  vector<P> ret;\n  int N = ps.size();\n  REP(i,N){\n      P a = ps[i];\n      P b = ps[(i+1)%N];\n      if( ccw(p1, p2, a) != -1 ) ret.push_back(a);\n      if( ccw(p1, p2, a) * ccw(p1, p2, b) == -1 )\n          ret.push_back( intersectionLL(a,b,p1,p2) );\n  }\n  return ret;\n}\n double area(const vector<P> &v) {\n  double ret = 0.0;\n  REP(i, v.size()) ret += crs(v[i], v[(i+1) % v.size()]);\n  return abs(ret / 2.0);\n}\n\nstruct C : public P {\n  D r;\n  C() {}\n  C(const P &p, D r):P(p),r(r){}\n};\n\n// 直線abと円cの交点をvectorで返す\nvector<P> intersectionLC(const P& a, const P& b, const C& c){\n  double dist = distLP(a,b,c);\n  vector<P> ret;\n  if( abs(dist - c.r) < EPS ) {\n    ret.push_back( footOfLP(a,b,c) );\n  } else if( dist < c.r ) {\n    P m = footOfLP(a,b,c);\n    P u = (b-a) / (b-a).abs();\n    double t = sqrt( c.r * c.r - dist * dist );\n    ret.push_back( m + t * u );\n    ret.push_back( m - t * u );\n  }\n  return ret;\n}\n\nint main2() {\n  P p1;\n  double r1;\n  cin >> p1 >> r1;\n  C c1 = C(p1, r1);\n  int N; cin >> N;\n  REP(i, N) {\n    P a, b; cin >> a >> b;\n    vector<P> ps = intersectionLC(a, b, c1);\n\n    if (ps.size() == 1) {\n      printf(\"%.10f %.10f %.10f %.10f\\n\", ps[0].x, ps[0].y, ps[0].x, ps[0].y);\n    } else if (ps.size() == 2) {\n      if (ps[1] < ps[0]) swap(ps[0], ps[1]);\n      printf(\"%.10f %.10f %.10f %.10f\\n\", ps[0].x, ps[0].y, ps[1].x, ps[1].y);\n    }\n  }\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define BiSearchRangeNum(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y);\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\n  public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\nclass Circle {\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\nstruct Segment {\n  Point p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n  return a.x * a.x + a.y * a.y;\n};\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n};\n\n// 内積\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n};\n\n// 外積\ndouble cross(Vector a, Vector b) {\n  return a.x * b.y - a.y * b.x;\n};\n\n// 直交判定\nbool isOrthogonal(Vector a, Vector b) {\n  return equals(dot(a, b), 0.0);\n};\n\n// 並行判定\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a, b), 0.0);\n};\n\n// 射影\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n};\n\n// 反射\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n};\n\n// 点と点の距離\ndouble getDistance(Point a, Point b) {\n  return abs(a - b);\n};\n\n// 点と直線の距離\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n};\n\n// 点と線分の距離\ndouble getDistanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n};\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// 二つのベクトルの位置関係\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n};\n\n// 線分の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n};\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n};\n\n// 円と直線の交差判定\nbool intersect(Circle c, Line l) {\n  return getDistanceLP(l, c.c) <= c.r;\n};\n\n// 線分と線分の距離\ndouble getDistance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n};\n\n// 線分と線分の交点(必ず交点があり、それがどちらかの端点出ない)\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 -s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1/ (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n};\n\n// 円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r * c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n};\n\nint main() {\n  double cx, cy, r;\n  cin >> cx >> cy >> r;\n  Point center = Point(cx, cy);\n  Circle c = Circle(center, r);\n  int q;\n  cin >> q;\n  Point p1, p2;\n  Line l;\n  rep(i, 0, q) {\n    cin >> p1.x >> p1.y >> p2.x >> p2.y;\n    l.p1 = p1;\n    l.p2 = p2;\n    pair<Point, Point> crossPs = getCrossPoints(c, l);\n    if (crossPs.first.x == crossPs.second.x) {\n      if (crossPs.first.y <= crossPs.second.y) {\n        printf(\"%.10f %.10f %.10f %.10f\\n\", crossPs.first.x, crossPs.first.y, crossPs.second.x, crossPs.second.y);\n      } else {\n        printf(\"%.10f %.10f %.10f %.10f\\n\", crossPs.second.x, crossPs.second.y, crossPs.first.x, crossPs.first.y);\n      }\n    } else if (crossPs.first.x <= crossPs.second.x) {\n      printf(\"%.10f %.10f %.10f %.10f\\n\", crossPs.first.x, crossPs.first.y, crossPs.second.x, crossPs.second.y);\n    } else {\n      printf(\"%.10f %.10f %.10f %.10f\\n\", crossPs.second.x, crossPs.second.y, crossPs.first.x, crossPs.first.y);\n    }\n  }\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    }\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(const Point &p, const double r): p(p), r(r) {}\n};\n\ndouble get_distance(const Line &l, const Point &p) {\n    return abs(cross_prod(l.second-l.first, p-l.first))/abs(l.second-l.first);\n}\n\ntemplate <class LineType>\npair<pair<double, double>, double> get_stdform(const LineType &l) {\n    double dx=real(l.second)-real(l.first);\n    double dy=imag(l.second)-imag(l.first);\n    double k=-dx*imag(l.first)+dy*real(l.first);\n\n    return make_pair(make_pair(-dy, dx), k);\n}\n\ntemplate <class LineType>\npair<Point, Point> get_ipoints(const Circle &c, const LineType &l) {\n    double a=imag(l.first)-imag(l.second);\n    double b=real(l.second)-real(l.first);\n    double k=-b*imag(l.first)-a*real(l.first);\n\n    double d=a*real(c.p)+b*imag(c.p)+k;\n    double r=c.r;\n\n    double R=a*a+b*b;\n    double D=sqrt(R*r*r-d*d);\n    Point p1=c.p+polar(1/sqrt(R), atan2(b, a))*Point(-d, D);\n    Point p2=c.p+polar(1/sqrt(R), atan2(b, a))*Point(-d, -D);\n\n    if (p2 < p1)\n        swap(p1, p2);\n\n    return make_pair(p1, p2);\n}\n\nint main() {\n    double x, y, r;\n    scanf(\"%lf %lf %lf\", &x, &y, &r);\n    Circle c(Point(x, y), r);\n\n    size_t q;\n    scanf(\"%zu\", &q);\n\n    for (size_t i=0; i<q; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        Point p1(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p2(x, y);\n\n        Line l(p1, p2);\n        pair<Point, Point> ps=get_ipoints(c, l);\n        printf(\"%.9f %.9f \", real(ps.first), imag(ps.first));\n        printf(\"%.9f %.9f\\n\", real(ps.second), imag(ps.second));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ld> PT;\ntypedef vector<PT> Poly;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst ld EPS = 1e-12;\n\nconst int ON = 0, LEFT = 1, RIGHT = -1, BACK = -2, FRONT = 2, IN = 3, OUT = -3;\n\ninline bool Geq(ld a, ld b){ return a - b > -EPS; }\ninline bool Grt(ld a, ld b){ return a - b > EPS; }\ninline bool Leq(ld a, ld b){ return a - b < EPS; }\ninline bool Lss(ld a, ld b){ return a - b < -EPS; }\ninline bool Equ(ld a, ld b){ return abs(a-b) < EPS; }\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val; is >> val; p.real(val); is >> val; p.imag(val); return is;\n}\nbool byX(const PT &a, const PT &b){\n\tif (Equ(a.X, b.X)) return Lss(a.Y, b.Y);\n\treturn Lss(a.X, b.X);\n}\nbool byY(const PT &a, const PT &b){\n\tif (Equ(a.Y, b.Y)) return Lss(a.X, b.X);\n\treturn Lss(a.Y, b.Y);\n}\nstruct cmpXY{ bool operator ()(const PT &a, const PT &b){ return byX(a, b); } };\nstruct cmpYX{ bool operator ()(const PT &a, const PT &b){ return byY(a, b); } };\n\nld dot(PT a, PT b){ return real(conj(a)*b); }\nld cross(PT a, PT b){ return imag(conj(a)*b); }\nld sqlen(PT a){ return dot(a, a); }\nld len(PT a){ return sqrt(sqlen(a)); }\nPT unit(PT a){ return a/len(a); }\n\n//projection of c on ab\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\n//reflection of c toward ab\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\n//rotate b with center=a theta radian\nPT rotate(PT a, PT b, ld theta){\n\treturn (b-a)*polar<ld>(1, theta) + a;\n}\n\n//relative position of c toward ab\nint relpos(PT a, PT b, PT c){\n\tb -= a; c -= a; c /= b;\n\tif (Grt(c.imag(), 0)) return LEFT;\n\tif (Lss(c.imag(), 0)) return RIGHT;\n\tif (Lss(c.real(), 0)) return BACK;\n\tif (Grt(c.real(), 1)) return FRONT;\n\treturn ON;\n}\n\n//sign of cross product of ab and ac\nint side(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn Grt(cr, 0) ? 1 : (Lss(cr, 0) ? -1 : 0);\n}\n\n//if two line segments intersect\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = side(c, d, a), bs = side(c, d, b), cs = side(a, b, c), ds = side(a, b, d);\n\tif (as && as == bs || cs && cs == ds) return false;\n\telse if (as || bs || cs || ds) return true;\n\tfor (int j = 0; j < 2; j++, swap(a, c), swap(b, d)){\n\t\tld mx = min(a.X, b.X), Mx = max(a.X, b.X), my = min(a.Y, b.Y), My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++, swap(c, d))\n\t\t\tif (Geq(c.X, mx) && Leq(c.X, Mx) && Geq(c.Y, my) && Leq(c.Y, My))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n//intersection of two non-parallel lines\nPT intersection(PT a, PT b, PT c, PT d){\n\tld c1 = cross(b-a, c-a), c2 = cross(b-a, d-a);\n\treturn (c1*d - c2*c)/(c1-c2);\n}\n\n//distance of a point from a line\nld distLP(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn abs(cross(b, c))/len(b);\n}\n\n//distance of a point from a line segment\nld distLSP(PT a, PT b, PT c){\n\tint rpos = relpos(a, b, proj(a, b, c));\n\tif (rpos == BACK) return len(c-a);\n\tif (rpos == FRONT) return len(c-b);\n\tb -= a, c -= a;\n\treturn abs(cross(b, c)/len(b));\n}\n\n//distance between two line segments\nld distLS(PT a, PT b, PT c, PT d){\n\tif (intersect(a, b, c, d)) return 0;\n\treturn min(min(distLSP(a, b, c), distLSP(a, b, d)), min(distLSP(c, d, a), distLSP(c, d, b)));\n}\n\nld signedArea(Poly &po){\n\tint n = po.size();\n\tld res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += cross(po[i], po[(i+1)%n]);\n\treturn res/2;\n}\n\nld area(Poly &poly){\n\treturn abs(signedArea(poly));\n}\n\n//angles less than or equal to 180\nbool isConvex(Poly &po){\n\tint n = po.size();\n\tbool neg = false, pos = false;\n\tfor (int i = 0; i < n; i++){\n\t\tint rpos = relpos(po[i], po[(i+1)%n], po[(i+2)%n]);\n\t\tif (rpos == LEFT) pos = true;\n\t\tif (rpos == RIGHT) neg = true;\n\t}\t\n\treturn (neg&pos) == false;\n}\n\nint crossingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint cn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q) && (side(a, b, p) == 1 || side(a, b, q) == 1))\n\t\t\tcn++;\n\t}\n\treturn cn;\n}\n\nint windingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint wn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q)){\n\t\t\tint ps = side(a, b, p), qs = side(a, b, q);\n\t\t\tif (qs >= 0) wn++;\n\t\t\tif (ps >= 0) wn--;\n\t\t}\n\t}\n\treturn wn;\n}\n\n//returns IN, ON or OUT\nint pointInPoly(Poly &po, PT a){\n\tint n = po.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (relpos(po[i], po[(i+1)%n], a) == ON)\n\t\t\treturn ON;\t\n\treturn (crossingN(po, a)%2 ? IN : OUT);\n\t//return (windingN(po, a) ? IN : OUT);\n}\n\nPoly getHull(Poly &po, bool lower){\n\tsort(po.begin(), po.end(), cmpXY());\n\tPoly res;\n\tint n = res.size();\n\tfor (auto p : po){\n\t\twhile (n >= 2 && side(res[n-2], res[n-1], p) == (lower ? RIGHT : LEFT))\n\t\t\tres.pop_back(), n--;\n\t\tres.pb(p), n++;\n\t}\n\treturn res;\n}\n\nPoly convexHull(Poly &po){\n\tint n = po.size();\n\tPoly lower = getHull(po, true),\n\t\t upper = getHull(po, false);\n\tPoly res = lower;\n\tfor (int i = (int)upper.size()-2; i; i--)\n\t\tres.pb(upper[i]);\n\treturn res;\n}\n\n//Given some points (at least two)\npair <PT, PT> nearestPair(Poly &po){\n\tint n = po.size();\n\tsort(po.begin(), po.end(), cmpXY());\n\tmultiset <PT, cmpYX> s;\n\tld rad = len(po[1]-po[0]);\n\tpair <PT, PT> res = {po[0], po[1]};\n\tint l = 0, r = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (l < r && Geq(po[i].X - po[l].X, rad))\n\t\t\ts.erase(po[l++]);\n\t\twhile (r < i && Leq(po[r].X, po[i].X))\n\t\t\ts.insert(po[r++]);\n\t\tfor (auto it = s.lower_bound(PT(po[i].X, po[i].Y-rad)); it != s.end(); it++){\n\t\t\tif (Grt(it->Y, po[i].Y+rad))\n\t\t\t\tbreak;\n\t\t\tld cur = len(po[i] - (*it));\n\t\t\tif (Lss(cur, rad)){\n\t\t\t\trad = cur;\n\t\t\t\tres = {*it, po[i]};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n//Given Convex Polygon having at least one point\npair <PT, PT> farthestPair(Poly &po){\n\tint n = po.size();\n\tpair <PT, PT> res = {po[0], po[0]};\n\tint j = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (Grt(len(po[(j+1)%n] - po[i]), len(po[j] - po[i])))\n\t\t\tj = (j+1)%n;\n\t\tif (Grt(len(po[j]-po[i]), len(res.S-res.F)))\n\t\t\tres = {po[i], po[j]};\n\t}\n\treturn res;\n}\n\nld diameter(Poly &po){\n\tauto p = farthestPair(po);\n\treturn len(p.S-p.F);\n}\n\nld radius(Poly &po){\n\tauto p = nearestPair(po);\n\treturn len(p.S-p.F);\n}\n\n//Cuts polygon with line ab and returns the left cut polygon\nPoly convexCut(Poly &po, PT a, PT b){\n\tint n = po.size();\n\tPoly res;\n\tfor (int i = 0; i < n; i++){\n\t\tif (side(a, b, po[i]) >= 0) \n\t\t\tres.pb(po[i]);\n\t\tif (abs(side(a, b, po[i]) - side(a, b, po[(i+1)%n])) == 2)\n\t\t\tres.pb(intersection(a, b, po[i], po[(i+1)%n]));\n\t}\n\treturn res;\n}\n\n//Sweep Line Example\nvoid SweepLine(){\n\tvector <PT> adds, rems;\n\tvector <LS> query;\n\tfor (int i = in(); i; i--){\n\t\tPT p, q;\n\t\tcin >> p >> q;\n\t\tif (Equ(p.Y, q.Y)){\n\t\t\tif (Lss(q.X, p.X))\n\t\t\t\tswap(p, q);\n\t\t\tadds.pb(p);\n\t\t\trems.pb(q);\n\t\t}\n\t\telse{\n\t\t\tif (Lss(q.Y, p.Y))\n\t\t\t\tswap(p, q);\n\t\t\tquery.pb({p, q});\n\t\t}\n\t}\n\tsort(adds.begin(), adds.end(), [](PT a, PT b){ return byX(a, b); });\n\tsort(rems.begin(), rems.end(), [](PT a, PT b){ return byX(a, b); });\n\tsort(query.begin(), query.end(), [](LS a, LS b){ return byX(a.F, b.F); });\n\tmultiset <ld> ys;\n\tint iadd = 0, irem = 0;\n\tint ans = 0;\n\tfor (auto p : query){\n\t\twhile (iadd < adds.size() && Leq(adds[iadd].X, p.F.X))\n\t\t\tys.insert(adds[iadd++].Y);\n\t\twhile (irem < rems.size() && Lss(rems[irem].X, p.F.X) && ys.find(rems[irem].Y) != ys.end())\n\t\t\tys.erase(ys.find(rems[irem++].Y));\n\t\tint cur = distance(ys.lower_bound(p.F.Y), ys.upper_bound(p.S.Y));\n\t\tans += cur;\n\t}\n\tcout << ans << endl;\n}\n\ntypedef struct Circle{\n\tPT C;\n\tld R;\n} CL;\n\n//number of common tangent lines between c1 and c2\nint tangentCnt(CL c1, CL c2){\n\tld d = len(c1.C-c2.C);\n\tif (Grt(d, c1.R+c2.R)) return 4;\n\tif (Equ(d, c1.R+c2.R)) return 3;\n\tif (Lss(d, c1.R+c2.R) && Grt(d, abs(c1.R-c2.R))) return 2;\n\tif (Equ(d, abs(c1.R-c2.R))) return 1;\n\treturn 0;\n}\n\n//if circle c and line a-b intersect\nbool intersect(PT a, PT b, CL c){\n\treturn Leq(distLP(a, b, c.C), c.R);\n}\n\n//intersection of intersecting line and circle\nLS intersection(PT a, PT b, CL c){\n\tld dis = distLP(a, b, c.C);\n\tld d = sqrt(c.R*c.R - dis*dis);\n\tPT p = proj(a, b, c.C);\n\treturn {p + d*unit(b-a), p + d*unit(a-b)};\n}\n\nint main(){\t\n\tcout << setprecision(10) << fixed;\n\tCL c;\n\tPT a, b;\n\tcin >> c.C >> c.R;\n\tint q = in();\n\twhile (q--){\n\t\tcin >> a >> b;\n\t\tif (intersect(a, b, c)){\n\t\t\tLS pp = intersection(a, b, c);\n\t\t\tif (byX(pp.S, pp.F))\n\t\t\t\tswap(pp.F, pp.S);\n\t\t\tcout << pp.F.X << ' ' << pp.F.Y << ' ' << pp.S.X << ' ' << pp.S.Y << '\\n';\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nstruct pnt{\n  double x,y;\n  bool operator>(const pnt &key)const{\n      if(this->x==key.x)return this->y>key.y;\n      return this->x>key.x;\n  }\n  pnt operator+(pnt key){\n      pnt res;res.x=x+key.x,res.y=y+key.y;\n      return res;\n  } \n  pnt operator-(pnt key){\n      pnt res;res.x=x-key.x,res.y=y-key.y;\n      return res;\n  }  \n  pnt operator*(double key){\n      pnt res;res.x=x*key,res.y=y*key;\n      return res;\n  }\n  pnt operator/(double key){\n      pnt res;res.x=x/key,res.y=y/key;\n      return res;\n  }\n  double abs(){\n      return sqrt(x*x+y*y);\n  }\n};\ndouble dot(pnt a,pnt b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble dis(pnt a,pnt b){\n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\npnt shaei(pnt a,pnt b,pnt c){\n    pnt base=b-a;\n    return a+base*dot(c-a,base)/base.abs()/base.abs();\n}\npair<pnt,pnt> koten(pnt a,pnt b,pnt c,double r){\n    pnt sha=shaei(a,b,c);\n    double di=dis(c,sha);\n    double len=sqrt(r*r-di*di);\n    pnt e=(a-b)/dis(a,b);\n    return make_pair(sha+e*len,sha+e*len*-1);\n}\nvoid inn(pnt & a){\n    cin>>a.x>>a.y;\n}\nint main(){\n    pnt cir;double rad;\n    inn(cir); cin>>rad;\n    ll q;cin>>q;\n    while(q--){\n\tpnt a,b;inn(a);inn(b);\n\tpair<pnt,pnt> res=koten(a,b,cir,rad);\n\tif(res.first>res.second)swap(res.first,res.second);\n\tcout<<fixed<<setprecision(9)<<res.first.x<<\" \";\n\tcout<<fixed<<setprecision(9)<<res.first.y<<\" \";\n\tcout<<fixed<<setprecision(9)<<res.second.x<<\" \";\n\tcout<<fixed<<setprecision(9)<<res.second.y<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\n    public:\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x * x + y * y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment {\n    Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nbool isParallel(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross((s1.p2 - s1.p1), (s2.p2 - s2.p1)), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot((s1.p2 - s1.p1), (s2.p2 - s2.p1)), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    Point projection = project(s, p);\n    Vector toReflection = (projection - p) * 2.0;\n    return p + toReflection; \n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n\n    // 反時計\n    if (cross(v1, v2) > 0.0) return 1;\n    // 時計\n    if (cross(v1, v2) < 0.0) return -1;\n\n    // p1, p2 が逆方向\n    if (dot(v1, v2) < 0.0) return 2;\n\n    // p1, p2 が同方向\n    if (v1.abs() < v2.abs()) return -2;\n    return 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return (ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0\n            && ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0) return (p - s.p1).abs();\n    if (dot(s.p1 - s.p2, p - s.p2) < 0) return (p - s.p2).abs();\n\n    return getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) {\n        return 0.0;\n    }\n\n    return min(\n        min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n        min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n    );\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n\n    Vector hypo = s1.p2 - s1.p1;\n    return s1.p1 + hypo * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCircleSegmentCrossPoint(Circle c, Segment s) {\n    Point projection = project(s, c.c);\n    double dist = sqrt(c.r * c.r - (c.c - projection).norm());\n    Vector base = s.p2 - s.p1;\n    base = base / base.abs();\n    Point a = projection + (base * dist);\n    return make_pair(projection + (base * dist), projection - (base * dist));\n}\n\nvoid printPoints(Point p1, Point p2) {\n    cout << p1.x << \" \" << p1.y << \" \" << p2.x << \" \" << p2.y << endl;\n}\n\nint main() {\n    cout << fixed << setprecision(11);\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n    Point c = {cx, cy};\n    Circle circle = {c, r};\n\n    int q;\n    cin >> q;\n    double x1, y1, x2, y2;\n    for (int i = 0; i < q; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Point p1 = {x1, y1};\n        Point p2 = {x2, y2};\n        Segment s = {p1, p2};\n\n        pair<Point, Point> crossPoints = getCircleSegmentCrossPoint(circle, s);\n        Point first = crossPoints.first;\n        Point second = crossPoints.second;\n        if (first.x < second.x) {\n            printPoints(first, second);\n        } else if (first.x > second.x) {\n            printPoints(second, first);\n        } else {\n            if (first.y <= second.y) {\n                printPoints(first, second);\n            } else {\n                printPoints(second, first);\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator+(Point p){\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator*(double d){\n        return Point(x * d, y * d);\n    }\n};\ntypedef Point Vector;\ndouble dot(Vector v1, Vector v2){\n    return v1.x * v1.x + v2.y * v2.y;\n}\ndouble cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\nstruct Line{\n    Point p1;\n    Point p2;\n    Line(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c, double r): c(c), r(r) {}\n};\n\nPoint cross_point1(Circle c, Line l){\n    Vector b = l.p2 - l.p1;\n    Vector h = c.c - l.p1;\n    double d = abs(cross(b, h)) / sqrt(dot(b, b));\n    double a = sqrt((dot(h, h) - d * d) / dot(b, b));\n    Point x =  l.p1 + b * a;\n    return x + b * (sqrt(c.r * c.r - d * d) / sqrt(dot(b, b)));\n}\n\nPoint cross_point2(Circle c, Line l){\n    Vector b = l.p2 - l.p1;\n    Vector h = c.c - l.p1;\n    double d = abs(cross(b, h)) / sqrt(dot(b, b));\n    double a = sqrt((dot(h, h) - d * d) / dot(b, b));\n    Point x =  l.p1 + b * a;\n    return x - b * (sqrt(c.r * c.r - d * d) / sqrt(dot(b, b)));\n}\nvoid disp(Point a, Point b){\n    Point f = a;\n    Point s = b;\n    if (f.x > s.x || (f.x == s.x && f.y > s.y)) swap(f, s);\n    cout << fixed << setprecision(10);\n    cout << f.x << \" \" << f.y << \" \" << s.x << \" \" << s.y << endl;\n}\n\nint main(){\n    int cx, cy, r;\n    cin >> cx >> cy >> r;\n    Circle c(Point(cx, cy), r);\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line l(Point(x1, y1), Point(x2, y2));\n        disp(cross_point1(c, l), cross_point2(c, l));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n \nint main()\n{\n    double cx = 0, cy = 0, r = 0;\n    int q = 0;\n    double x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n \n    cin >> cx >> cy >> r >> q;\n \n    for (int i = 0; i < q; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n \n        double a = 0, b = 0, s = 0, t = 0, u = 0,\n            v1 = 0, v2 = 0, w1 = 0, w2 = 0;\n \n        if (x1 == x2) {\n            v1 = x1;\n            v2 = x2;\n            w1 = cy - sqrt(r * r - (x1 - cx) * (x1 - cx));\n            w2 = cy + sqrt(r * r - (x1 - cx) * (x1 - cx));\n        }\n        else {\n            a = (y2 - y1) / (x2 - x1);\n            b = (x2 * y1 - x1 * y2) / (x2 - x1);\n \n            s = a * a + 1;\n            t = a * b - a * cy - cx;\n            u = cx * cx + (b - cy) * (b - cy) - r * r;\n \n            v1 = (-t - sqrt(t * t - s * u)) / s;\n            v2 = (-t + sqrt(t * t - s * u)) / s;\n            w1 = a * v1 + b;\n            w2 = a * v2 + b;\n        }\n \n        cout << setiosflags(ios::fixed | ios::showpoint) << setprecision(8)\n             << v1 << \" \" << w1 << \" \" << v2 << \" \" << w2 << endl;\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\tcout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tdouble base = sqrt(r * r - pr.norm());\n\t/*\n\tif (equals(pr.abs(), r)) {\n\t\tVector ans = center + pr;\n\t\treturn make_pair(ans, ans);\n\t} else {*/\n\t\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * base;\n\t\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * base;\n\t\tif (ans1.x < ans2.x) {\n\t\t\treturn make_pair(ans1, ans2);\n\t\t} else {\n\t\t\treturn make_pair(ans2, ans1);\n\t\t}\n\t//}\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\tdouble cx,cy,r,x1,x2,y1,y2,slope,cross_x,cross_y,h,k,div_x,div_y;\n\tint q;\n\tbool X_FLG,Y_FLG;\n\n\tscanf(\"%lf %lf %lf\",&cx,&cy,&r);\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf\",&x1,&y1,&x2,&y2);\n\n\t\tX_FLG = false,Y_FLG = false;\n\n\t\tif(y1 == y2){\n\t\t\tX_FLG = true;\n\t\t}else if(x1 == x2){\n\t\t\tY_FLG = true;\n\t\t}else{\n\t\t\tslope = (y2-y1)/(x2-x1);\n\t\t}\n\n\t\tif(X_FLG){\n\t\t\tcross_x = cx;\n\t\t\tcross_y = y1;\n\t\t}else if(Y_FLG){\n\t\t\tcross_x = x1;\n\t\t\tcross_y = cy;\n\t\t}else{\n\t\t\tcross_x = (cy*(x2-x1)*(y2-y1)+cx*(x2-x1)*(x2-x1)-y1*(y2-y1)*(x2-x1)+x1*(y2-y1)*(y2-y1))/((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1));\n\t\t\tcross_y = ((x1-x2)*cross_x+cy*(y2-y1)+cx*(x2-x1))/(y2-y1);\n\t\t}\n\n\t\th = sqrt((cx - cross_x)*(cx-cross_x)+(cy-cross_y)*(cy-cross_y));\n\t\tk = sqrt(r*r-h*h);\n\n\t\tif(X_FLG){\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",cross_x - k,y1,cross_x+k,y1);\n\t\t}else if(Y_FLG){\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",x1,cross_y-k,x1,cross_y+k);\n\t\t}else{\n\t\t\tdiv_x = k*(x2-x1)/(sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)));\n\t\t\tdiv_y = k*(y2-y1)/(sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)));\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",cross_x-div_x,cross_y-div_y,cross_x + div_x,cross_y+div_y);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAX = 1e2 + 5;\nconst int L = 2;\nconst LL MOD = 10000;\nconst int dir[MAX][MAX] = {{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,1},{1,-1}};\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tPoint o;\n\tdouble r;\n\tscanf(\"%lf%lf%lf\", &o.x, &o.y, &r);\n\tint T;\n\tsfi(T);\n\twhile(T--)\n\t{\n\t\tLine l;\n\t\tscanf(\"%lf%lf%lf%lf\", &l.a.x, &l.a.y, &l.b.x, &l.b.y);\n\t\tPoint ret[3];\n\t\tint num;\n\t\tcircle_cross_line(l.a, l.b, o, r, ret, num);\n\t\tif(num == 1)\n\t\t\tret[1].x = ret[0].x, ret[1].y = ret[0].y;\n\t\tif(ret[0].x > ret[1].x || (!cmp(ret[0].x - ret[1].x) && ret[0].y > ret[1].y))\n\t\t\tswap(ret[0], ret[1]);\n\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", ret[0].x, ret[0].y, ret[1].x, ret[1].y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\n\ntemplate<class T> using V = vector<T>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2(D _x = D(), D _y = D()) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"P(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L(P _s = P(), P _t = P()) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nostream& operator<<(ostream& os, const L &l) {\n    return os << \"L(\" << l.s << \", \" << l.t << \")\";\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / v.norm());\n}\n\nbool insSL(const L &s, const L &l) {\n    int a = ccw(l, s.s), b = ccw(l, s.t);\n    return (a%2 == 0 || b%2 == 0 || a != b);\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P q = project(s, p);\n    if (ccw(s, q) == 0) return (p - q).abs();\n    else return min((s.s - p).abs(), (s.t - p).abs());\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C(P _p = P(), D _r = D()) : p(_p), r(_r) {}\n};\n\n//need Intersect/distLP\nint crossCL(const C &c, const L &l, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v+di, v-di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n// Tri((0, 0), a, b)とC(P(0, 0), r)の共有面積\nD insArea2TC(const P &a, const P &b, const D &r) {\n    if (a == b) return 0;\n    auto single = [&](P x, P y, bool tri) {\n        if (tri) return cross(x, y);\n        else return r * r * ((y * P(x.x, -x.y)).arg());\n    };\n    bool ins_a = sgn(a.abs(), r) != 1, ins_b = sgn(b.abs(), r) != 1;\n    if (ins_a && ins_b) return single(a, b, true);\n//    if (sgn(max(a.abs(), b.abs()), r) != 1) return cross(a, b);\n//    auto sec_s = [&](P x, P y) { return r * r * ((y * P(x.x, -x.y)).arg()); };\n//    if (u == 0) { return sec_s(a, b); }\n    D r2 = distSP(L(a, b), P(0, 0));    \n    if (sgn(r, r2) != 1) return single(a, b, false);\n    L l;\n    assert(crossCL(C(P(0, 0), r), L(a, b), l) == 2);\n    if (ins_a) l.t = l.s;\n    else if (ins_b) l.s = l.t;\n    return single(a, l.s, ins_a) + single(l.s, l.t, true) + single(l.t, b, ins_b); //insArea2TC(a, (a+b)/2, r) + insArea2TC((a+b)/2, b, r);\n//    assert(ccw(a, b, l.s) == 0);\n//    assert(ccw(a, b, l.t) == 0);\n//    return sec_s(a, l.t) + cross(l.t, l.s) + sec_s(l.s, b);\n//    return insArea2TC(a, (a+b)/2, r) + insArea2TC((a+b)/2, b, r);\n}\n\n// p, cの共有面積\nD insAreaPolC(const Pol &po, const C &c) {\n    D sm = 0;\n    P a, b = po.back();\n    for (auto p: po) {\n        a = b; b = p;\n        sm += insArea2TC(a, b, c.r);\n    }\n    return sm / 2;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    \n    int n; D r;\n    cin >> n >> r;\n    C c = C(P(0, 0), r);\n    Pol po(n);\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        po[i] = P(x, y);\n    }\n    cout << insAreaPolC(po, c) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nclass Point\n{\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator+(Point p)\n  {\n    return Point(x + p.x, y + p.y);\n  }\n  Point operator-(Point p)\n  {\n    return Point(x - p.x, y - p.y);\n  }\n  Point operator*(double a)\n  {\n    return Point(a * x, a * y);\n  }\n  Point operator/(double a)\n  {\n    return Point(x / a, y / a);\n  }\n\n  double abs()\n  {\n    return sqrt(norm());\n  }\n  double norm()\n  {\n    return x * x + y * y;\n  }\n\n  bool operator<(const Point &p) const\n  {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator==(const Point &p) const\n  {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n\n  void print()\n  {\n    printf(\"%.10f %.10f\\n\", x, y);\n  }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b)\n{\n  return a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b)\n{\n  return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment\n{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0) : c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint projection(Line l, Point p)\n{\n  return l.p1 + (l.p2 - l.p1) * (dot(p - l.p1, l.p2 - l.p1) / (l.p2 - l.p1).norm());\n}\n\nPoint reflection(Line l, Point p)\n{\n  Point x = projection(l, p);\n  return p + (x - p) * 2;\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0, b = p2 - p0;\n  if (cross(a, b) > EPS)\n  {\n    return COUNTER_CLOCKWISE;\n  }\n  if (cross(a, b) < -EPS)\n  {\n    return CLOCKWISE;\n  }\n  if (dot(a, b) < -EPS)\n  {\n    return ONLINE_BACK;\n  }\n  if (a.norm() < b.norm())\n  {\n    return ONLINE_FRONT;\n  }\n  return ON_SEGMENT;\n}\n\nbool is_parallel(Line l1, Line l2)\n{\n  Vector a = l1.p2 - l1.p1, b = l2.p2 - l2.p1;\n  return equals(cross(a, b), 0);\n}\n\nbool is_orthogonal(Line l1, Line l2)\n{\n  Vector a = l1.p2 - l1.p1, b = l2.p2 - l2.p1;\n  return equals(dot(a, b), 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n  Point p0 = s1.p1, p1 = s1.p2, p2 = s2.p1, p3 = s2.p2;\n  return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0) && (ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nPoint intersection(Segment s1, Segment s2)\n{\n  Point p0 = s1.p1, p1 = s1.p2, p2 = s2.p1, p3 = s2.p2;\n  double a0 = fabs(cross(p2 - p0, p3 - p0)), a1 = fabs(cross(p2 - p1, p3 - p1));\n  return (p0 * a1 + p1 * a0) / (a0 + a1);\n}\n\ndouble line_distance(Line l, Point p)\n{\n  Point p0 = l.p1, p1 = l.p2;\n  return fabs(cross(p1 - p0, p - p0)) / (p1 - p0).abs();\n}\n\ndouble distance(Segment s, Point p)\n{\n  Point p0 = s.p1, p1 = s.p2;\n  if (dot(p1 - p0, p - p0) < -EPS)\n  {\n    return (p0 - p).abs();\n  }\n  if (dot(p0 - p1, p - p1) < -EPS)\n  {\n    return (p1 - p).abs();\n  }\n  return fabs(cross(p1 - p0, p - p0)) / (p1 - p0).abs();\n}\n\ndouble distance(Segment s1, Segment s2)\n{\n  if (intersect(s1, s2))\n  {\n    return 0;\n  }\n  double res = distance(s1, s2.p1);\n  res = min(res, distance(s1, s2.p2));\n  res = min(res, distance(s2, s1.p1));\n  res = min(res, distance(s2, s1.p2));\n  return res;\n}\n\npair<Point, Point> intersection(Circle s, Line l)\n{\n  Point x = projection(l, s.c);\n  double d = line_distance(l, s.c);\n  if (equals(d, s.r))\n  {\n    return make_pair(x, x);\n  }\n  Point p0 = l.p1, p1 = l.p2;\n  Vector u = p1 - p0;\n  Vector v = u * (sqrt(s.r * s.r - d * d)) / u.abs();\n  Point a0 = x + v, a1 = x - v;\n  if (a1 < a0)\n  {\n    swap(a0, a1);\n  }\n  return make_pair(a0, a1);\n}\n\nint main()\n{\n  double cx, cy, r;\n  cin >> cx >> cy >> r;\n  Circle s = {Point{cx, cy}, r};\n  int q;\n  cin >> q;\n  rep(i, q)\n  {\n    double x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n    Line l = {Point{x0, y0}, Point{x1, y1}};\n    Point a0, a1;\n    tie(a0, a1) = intersection(s, l);\n    printf(\"%.10f %.10f %.10f %.10f\\n\", a0.x, a0.y, a1.x, a1.y);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <regex>\n#include <cstdio>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\nusing ll = long long int;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b)  for(int i = (a); i < (b) ; i++)\n#define pb push_back\n#define SORT(v,n) sort(v, v+n)\n#define ALL(x) (x).begin(),(x).end()\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define elif else if\n#define int ll\n//const int INF = 100100100;\nconst int INF = (1LL << 32);\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint dx[8] = { 1, 0, -1, 0, 1, -1, -1, 1 };\nint dy[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator<(const Point & p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator==(const Point & p) const {\n\t\treturn fabs(x - p.x) < EPS and fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x* b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x* b.y - a.y * b.x;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n//直交判定\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//平行判定\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//線分sに対する点pの射影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\n//線分ｓに対する点ｐの反射\nPoint refrect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n//2点間の距離\ndouble getDistance(Point a, Point b) {\n\tPoint res = a - b;\n\treturn res.abs();\n}\n//点と直線の距離\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / Vector(l.p2 - l.p1).abs());\n}\n\n//線分ｓと点ｐの距離\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) {\n\t\tPoint r = p - s.p1;\n\t\treturn r.abs();\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) {\n\t\tPoint r = p - s.p2;\n\t\treturn r.abs();\n\t}\n\treturn getDistanceLP(s, p);\n}\n\n//counter clock wise\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//線分と線分の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//線分と線分の距離\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(\n\t\tmin(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n\t);\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//円ｃと線分ｌの交差判定\nbool intersect(Circle c, Line l) {\n\treturn getDistanceSP(l, c.c) <= c.r;\n}\n\n//円ｃと線分ｌの交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / Vector(l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - Vector(pr - c.c).norm());\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tint q; \n\tcin >> q;\n\trep(i, q) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tLine l = Line(Point(x1, y1), Point(x2, y2));\n\t\tauto r = getCrossPoints(c, l);\n\t\tcout << fixed << setprecision(10);\n\t\tif (r.first.x > r.second.x) {\n\t\t\tcout << r.second.x << ' ' << r.second.y << ' ';\n\t\t\tcout << r.first.x << ' ' << r.first.y << endl;\n\t\t}elif(r.first.x < r.second.x) {\n\t\t\tcout << r.first.x << ' ' << r.first.y << ' ';\n\t\t\tcout << r.second.x << ' ' << r.second.y << endl;\n\t\t}elif(r.first.y < r.second.y) {\n\t\t\tcout << r.first.x << ' ' << r.first.y << \" \";\n\t\t\tcout << r.second.x << ' ' << r.second.y << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << r.second.x << ' ' << r.second.y << \" \";\n\t\t\tcout << r.first.x << ' ' << r.first.y << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cmath>\n#define int long long\n#define mod 1000000007\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\nusing namespace std;\nint get() { int r; cin >> r; return r; }\nsigned main() {\n\tdouble x0, y0, r; int q;\n\tcin >> x0 >> y0 >> r >> q;\n\tfor1(i, q) {\n\t\tdouble x1, x2, y1, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tdouble p = ((y2 - y1) * (x0 - x1) - (x2 - x1) * (y0 - y1)) / ((x2 - x1) * (x1 - x2) + (y2 - y1) * (y1 - y2));\n\t\tp = -p;\n\t\tdouble x4 = x0 + p * (y1 - y2), y4 = y0 - p * (x1 - x2);\n\t\tdouble k = sqrt(r * r - (x0 - x4) * (x0 - x4) - (y0 - y4) * (y0 - y4)) / sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t\tif (x1 < x2) { swap(x1, x2); swap(y1, y2); }\n\t\telse if (x1 == x2 && y1 < y2) { swap(x1, x2); swap(y1, y2); }\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", x4 - k * (x1 - x2), y4 - k * (y1 - y2), x4 + k * (x1 - x2), y4 + k * (y1 - y2));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        t=convex_hull(t);\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=min(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>EPS)return 1;//intersect\n            if(in_triangle(p,t))return 2;//c in t\n            else if(r-d<-EPS)return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n    //p must be convex and ccw\n    LS diameter(Poly &p){\n        int n=p.size();\n        int is=0,js=0;\n        REP(i,n)if(p[i].Y>p[is].Y)is=i;\n        REP(i,n)if(p[i].Y<p[js].Y)js=i;\n        LS res={p[is],p[js]};\n        {\n            int i=is;\n            int j=js;\n            do{\n                int ni=(i+1)%n;\n                int nj=(j+1)%n;\n                if(cross(p[ni]-p[i],p[nj]-p[j])<EPS)i=ni;\n                else j=nj;\n                if(abs(res.fi-res.se)<abs(p[i]-p[j]))\n                    res=LS(p[i],p[j]);\n            }while(i!=is||j!=js);   \n        }\n        return res;\n    }\n    Poly cross_C_L(C c,L v){\n        DCc(p,r,c);\n        DCl(a,b,v);\n        a-=p;\n        b-=p;\n        P u=a-b;\n        u=P(-u.Y,u.X);\n        P x=cross_L_L({a,b},{P(0,0),u});\n        D d=abs(x);\n        Poly res;\n        if(d-r>EPS)return res;\n        D y=sqrt(r*r-d*d);\n        res.pb(p+x+(b-a)*y/abs(b-a));\n        if(d-r>-EPS)return res;\n        res.pb(p+x+(a-b)*y/abs(b-a));\n        return res;\n    }\n}\n\n\nusing namespace geo;\n\nint main(){\n    cout<<setprecision(10);\n    cout<<fixed;\n    double x,y,r;\n    cin>>x>>y>>r;\n    C c(P(x,y),r);\n    int q;\n    cin>>q;\n    while(q--){\n        double a,b,u,v;\n        cin>>a>>b>>u>>v;\n        auto res=cross_C_L(c,L(P(a,b),P(u,v)));\n        if(res.size()==1){\n            res.pb(res[0]);\n        }\n        sort(ALL(res),comp);\n        cout<<res[0].X<<\" \"<<res[0].Y<<\" \"<<res[1].X<<\" \"<<res[1].Y<<endl;\n    }\n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\ndouble xmax, xmin, ymax, ymin;\nstruct vec{\n  double x, y;\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n  //double ppdist(vec p){ return sqrt( (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y) ); }\n  //double ppdist2(vec p){ return (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y); }\n};\nstruct line{\n  vec a, b;\n  vec getvec(){ return b - a; }\n  double size(){ return getvec().norm(); }\n  vec proj(vec p){ return a + (b - a).sca((p - a).dot(b - a) / (b - a).dot(b - a)); }\n  vec vref(vec p){ return proj(p).sca(2.0) - p; }\n  int ccw(vec p){\n    vec q = p - a, ba = b - a;\n    if(ba.cross(q) > 0)return 1; //ccw\n    if(ba.cross(q) < 0)return -1; //cw\n    if(ba.dot(q) < 0)return -2; //back\n    if(ba.dot(ba) < q.dot(q))return 2; //front\n    return 0; //on\n  }\n  bool paral(line l){ return abs(l.getvec().cross(getvec())) < eps; }\n  bool orth(line l){ return abs(l.getvec().dot(getvec())) < eps; }\n  bool intersec(line l){\n    bool res0 = (ccw(l.a) * ccw(l.b) == 4); //syukutai\n    bool res1 = (getvec().cross(l.a - a) * getvec().cross(l.b - a)) <= eps;\n    bool res2 = (l.getvec().cross(a - l.a) * l.getvec().cross(b - l.a)) <= eps;\n    return !res0 && res1 && res2;\n  }\n  vec crosspoint(line l){\n    return a + getvec().sca((l.a - a).cross(l.getvec()) / getvec().cross(l.getvec()));\n  }\n  double pldist(vec p){\n    double res = min((a - p).norm2(), (b - p).norm2());\n    vec h = proj(p);\n    if((a - h).dot(b - h) < 0)res = min(res, (h - p).norm2());\n    return sqrt(res);\n  }\n  double lldist(line l){\n    if(intersec(l))return 0.0;\n    return min(min(pldist(l.a), pldist(l.b)), min(l.pldist(a), l.pldist(b)));\n  }\n};\nstruct polygon{\n  vector<vec> p;  //ccw\n  double area(){\n    double res = 0.0;\n    for(int i = 0;i < p.size();++i)res += p[i].cross(p[(i + 1) % p.size()]);\n    return res / 2.0;\n  }\n  bool isconv(){\n    for(int i = 0;i < p.size();++i)\n    if((p[(i + 1) % p.size()] - p[i]).cross(p[(i + 2) % p.size()] - p[i]) < -eps)return false;\n    return true;\n  }\n  int isin(vec a){\n    line l = (line){a, a + (vec){xmax - xmin, 0.0}};\n    int cnt = 0, n = p.size();\n    for(int i = 0;i < n;++i){\n      line tmp = (line){p[i], p[(i + 1) % n]};\n      if(tmp.ccw(a) == 0)return 1; //on line\n      if(l.intersec(tmp)){\n        ++cnt;\n        if(l.ccw(p[i]) == 0 && l.ccw(p[(i + 1) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        if(l.paral(tmp)){\n          ++cnt;\n          if(l.ccw(p[(i + 2) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        }\n      }\n    }\n    return (cnt & 1) * 2;  //2:in 0:out\n  }\n};\n\nstruct circle{\n  vec o;\n  double r;\n  int intersec(circle c){\n    double d = (o - c.o).norm(), rp = r + c.r, rm = abs(r - c.r);\n    if(abs(rp - d) < eps)return 3;\n    if(rp < d + eps)return 4;\n    if(abs(rm - d) < eps)return 1;\n    if(rm < d + eps)return 2;\n    return 0;\n  }\n  pair<vec, vec> clpoint(line l){\n    pair<vec, vec> res;\n    vec h = l.proj(o);\n    double dist = (l.a - h).norm(), diff = sqrt(r * r - (o - h).norm2());\n    res.first = l.a + (l.b - l.a).sca((dist + diff) / l.size());\n    res.second = l.a + (l.b - l.a).sca((dist - diff) / l.size());\n    if(res.first.x + eps > res.second.x)swap(res.first, res.second);\n    return res;\n  }\n};\n\nsigned main(void){\n  int i, j, k, q;\n  circle c;\n  cin >> c.o.x >> c.o.y >> c.r >> q;\n  for(;q--;){\n    line l;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n    pair<vec, vec> res = c.clpoint(l);\n    printf(\"%.15lf %.15lf %.15lf %.15lf\\n\", res.X.x, res.X.y, res.Y.x, res.Y.y);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nbool operator < (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() < r.imag() : l.real() < r.real();\n}\n\nbool operator > (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() > r.imag() : l.real() > r.real();\n}\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this);\n  Circle(){}\n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto h = projection(l, c);\n  auto e = (l[1]-l[0]) / abs(l[1]-l[0]);\n  auto base = sqrt(c.r*c.r-abs(h-c)*abs(h-c));\n  return {h+e*base, h-e*base};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  Circle c; cin >> c.p >> c.r;\n  int n; cin >> n;\n  rep(i, n) {\n    P a, b; cin >> a >> b;\n    auto cp = crosspoint(c, Line(a, b));\n//    if(cp.first > cp.second) { swap(cp.first, cp.second); }\n    printf(\"%.10f %.10f %.10f %.10f\\n\", cp.first.real(), cp.first.imag(), cp.second.real(), cp.second.imag());\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nclass Point {\npublic:\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y) {}\n    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n    Point operator * (double a) {return Point(a*x,a*y);}\n    Point operator / (double a) {return Point(x/a,y/a);}\n\n    double abs() {return sqrt(norm());}\n    double norm() {return x*x+y*y;}\n\n    bool operator<(const Point &p) const {\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    bool operator==(const Point &p) const {\n        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n    }\n};\n\nstruct Segment {Point p1,p2;};\ntypedef Point Vector;\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0): c(c),r(r) {}\n};\n\ndouble dot(Vector a,Vector b) {\n    return  a.x*b.x+a.y*b.y;\n}\n\ndouble cross (Vector a,Vector b) {\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble getDistance(Point a,Point b) {\n    return (a-b).abs();\n}\n\ndouble getDistanceLP(Line l,Point p) {\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s,Point p) {\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2) {\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nPoint project(Segment s,Point p) {\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l) {\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\nint main(void) {\n    Circle c;\n    cin>>c.c.x>>c.c.y;\n    int q;\n    cin>>q;\n    while(q) {\n        Line l;\n        cin>>l.p1.x>>l.p1.y>>l.p2.x>>l.p2.y;\n        pair<Point,Point> ans=getCrossPoints(c,l);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",ans.first.x,ans.first.y,ans.second.x,ans.second.y);\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n) ; i++)\nconstexpr auto INF = 2147483647;\nstatic const double EPS = pow(10,-10);\ntypedef long long ll;\nstatic int COUNTER_CLOCKWISE = 1;\nstatic int CLOCKWISE = -1;\nstatic int ONLINE_BACK = 2;\nstatic int ONLINE_FRONT = -2;\nstatic int ON_SEGMENT = 0;\n\nclass Vector2{\n  public:\n  double x, y;\n  Vector2(){}\n  Vector2(double x, double y): x(x), y(y) {}\n\n  Vector2 operator + (Vector2 v) {\n    return Vector2(x + v.x , y + v.y);\n  }\n  Vector2 operator - (Vector2 v) {\n    return Vector2(x - v.x , y - v.y);\n  }\n\n  Vector2 operator * (double d){\n    return Vector2(d*x, d*y);\n  }\n\n  double norm(){\n    return pow(x,2) + pow(y,2);\n  }\n\n  double abs(){\n    return sqrt(norm());\n  }\n\n};\n\nclass Circle{\n  public:\n  Vector2 center;\n  double r;\n  Circle(){};\n  Circle(Vector2 center_, double r):center(center),r(r){};\n};\n\ndouble dot(Vector2 a, Vector2 b){\n  return a.x * b.x + a.y * b.y; \n}\n\ndouble cross(Vector2 a, Vector2 b){\n  return a.x * b.y - a.y*b.x;\n}\n\nVector2 projection(Vector2 a, Vector2 b, Vector2 p){\n  Vector2 base = b - a;\n  Vector2 hypo = p - a;\n  double norm_base = pow(base.x,2) + pow(base.y,2);\n\n  Vector2 x;\n  x = a + base*(dot(hypo,base) / norm_base);\n  return x;\n}\n\nVector2 refrection(Vector2 a, Vector2 b, Vector2 p){\n  Vector2 v, p_projection;\n  p_projection = projection(a,b,p); \n  v = p_projection + (p_projection - p);\n  return v;\n}\n\nint ccw(Vector2 a, Vector2 b, Vector2 p){\n  Vector2 hypo = p - a;\n  Vector2 base = b - a;\n  if(cross(base,hypo) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(base,hypo) < -EPS) return CLOCKWISE;\n  if(dot(base,hypo) < -EPS) return ONLINE_BACK;\n  if(hypo.norm() > base.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Vector2 a,Vector2 b,Vector2 p,Vector2 q){\n  int t1, t2;\n  t1 =ccw(a,b,p)*ccw(a,b,q);\n  t2 =ccw(p,q,a)*ccw(p,q,b);\n  if(t1 <= 0 && t2 <= 0) return true;\n  else return false;\n}\n\nVector2 crossPoint(Vector2 a,Vector2 b,Vector2 p,Vector2 q){\n  Vector2 base, hypo_1, hypo_2, v;\n  base = b-a;\n  hypo_1 = p-a;\n  hypo_2 = q-a;\n  double d1 = abs(cross(base, hypo_1)); \n  double d2 = abs(cross(base, hypo_2));\n  double ratio = d1/(d1+d2);\n  v = p + (hypo_2 - hypo_1)*ratio;\n  return v;\n}\n\ndouble distance(Vector2 a,Vector2 b,Vector2 p){\n  if(dot(b-a, p-b) > 0) return (p-b).abs();\n  if(dot(b-a, p-a) < 0) return (p-a).abs();\n  return (p - projection(a,b,p)).abs();\n}\n\ndouble distance(Vector2 a,Vector2 b,Vector2 p,Vector2 q){\n  if(intersect(a,b,p,q)) return 0;\n  vector<double> d_arr(4) ;\n  d_arr[0] = distance(a,b,p);\n  d_arr[1] = distance(a,b,q);\n  d_arr[2] = distance(p,q,a);\n  d_arr[3] = distance(p,q,b);\n  return min(min(d_arr[0],d_arr[1]),\n             min(d_arr[2],d_arr[3]));\n}\n\npair<Vector2,Vector2> crossPoint(Circle circle, Vector2 a, Vector2 b){\n  Vector2 base = b-a ;\n  Vector2 pro = projection(a,b,circle.center);\n  double ratio = sqrt(pow(circle.r,2) -(pro-circle.center).norm())\n                 / base.abs();\n  Vector2 v_1, v_2, tmp;\n  v_1 = pro - base*ratio;\n  v_2 = pro + base*ratio;\n  if((v_1.x == v_2.x && v_1.y > v_2.y) || v_1.x > v_2.x) swap(v_1,v_2);\n  return make_pair(v_1,v_2);\n}       \n\n\n\n\nint main(){\n  Vector2 a,b;\n  pair<Vector2,Vector2> ans;\n  Circle c;\n  cin >> c.center.x >> c.center.y >> c.r;\n  int queri;\n  cin >> queri;\n  rep(i,queri){\n    cin >> a.x >> a.y >> b.x >> b.y;\n    ans = crossPoint(c, a, b);\n    cout << fixed << setprecision(8);\n    cout << ans.first.x << \" \" << ans.first.y << \" \";\n    cout << ans.second.x << \" \" << ans.second.y;\n    cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\n\nclass Point {\npublic:\n\tld x, y;\n\tPoint() {\n\t\tx = y = 0.0;\n\t}\n\tPoint(ld x, ld y) :\n\t\t\tx(x), y(y) {\n\t}\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(ld a) {\n\t\treturn Point(x * a, y * a);\n\t}\n\tPoint operator /(ld a) {\n\t\treturn Point(x / a, y / a);\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c;\n\tld r;\n\tCircle(Point c = Point(), ld r = 0.0) :\n\t\t\tc(c), r(r) {\n\t}\n};\n\nld dot(Point p1, Point p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\n\nld norm(Point p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nld abs(Point p) {\n\treturn sqrt(norm(p));\n}\n\nPoint project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tld r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Segment l) {\n\tPoint pr = project(l, c.c);\n\tPoint e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tld base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n\n\tint cx, cy, r;\n\tscanf(\"%d %d %d\", &cx, &cy, &r);\n\tPoint cp(cx, cy);\n\tCircle c(cp, r);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint p1x, p1y, p2x, p2y;\n\t\tscanf(\"%d %d %d %d\", &p1x, &p1y, &p2x, &p2y);\n\t\tPoint p1(p1x, p1y);\n\t\tPoint p2(p2x, p2y);\n\t\tSegment s(p1, p2);\n\t\tpair<Point, Point> pair = getCrossPoints(c, s);\n\n\t\tcout << fixed << setprecision(8) << pair.second.x << \" \" << pair.second.y << \" \" << pair.first.x << \" \" << pair.first.y << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = (1LL<<30);\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nstruct Point{\n  double x, y;\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b){\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nPoint project(Segment s, Point p){\n  Vector a = s.p2 - s.p1;\n  Vector b = p - s.p1;\n  return s.p1 + a * (dot(a, b)/a.norm());\n}\n\nPoint reflect(Segment s, Point p){\n  return p + (project(s, p) - p)*2;\n}\n\nstatic const int Counter_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return Counter_CLOCKWISE;\n  else if(cross(a, b) < -EPS) return CLOCKWISE;\n  else if(dot(a, b) < -EPS) return ONLINE_BACK;\n  else if(a.norm() < b.norm()) return ONLINE_FRONT;\n  else return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\ndouble getDistance(Point a, Point b){\n  Point tmp = a-b;\n  return tmp.abs();\n}\n\ndouble getDistanceLP(Line l, Point p){\n  Vector a = l.p2 - l.p1;\n  Vector b = p - l.p1;\n  return abs(cross(a, b) / a.abs());\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  Vector a = s.p2 - s.p1;\n  Vector b = p - s.p1;\n  double n = dot(a, b) / a.norm();\n  if(0.0 <= n && n <= 1.0) return getDistanceLP(s, p);\n  else return min(getDistance(s.p1, p), getDistance(s.p2, p));\n}\n\ndouble getDistanceSS(Segment s1, Segment s2){\n  if(intersect(s1.p1, s1.p2, s2.p1, s2.p2)) return 0.0;\n  double res = INF;\n  chmin(res, getDistanceSP(s1, s2.p1));\n  chmin(res, getDistanceSP(s1, s2.p2));\n  chmin(res, getDistanceSP(s2, s1.p1));\n  chmin(res, getDistanceSP(s2, s1.p2));\n  return res;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n  double d1 = getDistanceLP(s1, s2.p1);\n  double d2 = getDistanceLP(s1, s2.p2);\n  double t = d1/(d1+d2);\n  return s2.p1 + (s2.p2 - s2.p1)*t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l){\n  assert(getDistanceLP(l, c.c) <= c.r);\n  Point pr = project(l, c.c);\n  Vector a = l.p2 - l.p1;\n  Vector e = a / a.abs();\n  Vector vcpr = pr - c.c;\n  double d = sqrt(c.r*c.r - vcpr.norm());\n  return make_pair(pr+e*d, pr-e*d);\n}\n\nint main(){\n  double cx, cy, r;\n  cin >> cx >> cy >> r;\n  Circle c = Circle(Point(cx, cy), r);\n\n  int q;\n  cin >> q;\n\n  rep(i, q){\n    double x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    Point p1 = Point(x1, y1);\n    Point p2 = Point(x2, y2);\n    Line l = {p1, p2};\n    pair<Point, Point> tmp = getCrossPoints(c, l);\n    vector<Point> ans(2);\n    ans[0] = tmp.first;\n    ans[1] = tmp.second;\n    sort(all(ans));\n    cout << fixed << setprecision(10);\n    cout << ans[0].x << \" \" << ans[0].y << \" \";\n    cout << ans[1].x << \" \" << ans[1].y << endl;\n  }\n\n  return 0;\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <iostream>\n#define X real()\n#define Y imag()\n#define EPS 1e-10\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nP projection(P a, P b){\n  return dot(a,b)/abs(b)/abs(b)*b;\n}\n\ndouble p_to_l_dist(P p, L l){\n  return abs(cross(l.second-l.first,p-l.first))/abs(l.first-l.second);\n}\n\nvector<P> sort_comp(vector<P> a){\n  int l = a.size();\n  vector< pair<double, double> > t(l);\n  for(int i = 0; i < l; ++i){\n    t[i].first = a[i].X;\n    t[i].second = a[i].Y;\n  }\n  sort(t.begin(),t.end());\n  for(int i = 0; i < l; ++i){\n    a[i] = P(t[i].first,t[i].second);\n  }\n  return a;\n}\n\nvector<P> cpcl(C c, L l){\n  double d = p_to_l_dist(c.first,l), r = c.second;\n  P m = l.first + projection(c.first-l.first,l.second-l.first);\n  P x = sqrt(r*r-d*d)/abs(l.second-l.first)*(l.second-l.first);\n  vector<P> cp(2,m);\n  cp[0] -= x;\n  cp[1] += x;\n  return cp;\n}\n\nint main(){\n  double x1, y1, x2, y2, r;\n  cin >> x1 >> y1 >> r;\n  C c = C(P(x1,y1),r);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i){\n    cin >> x1 >> y1 >> x2 >> y2;\n    L l;\n    l.first = P(x1,y1);\n    l.second = P(x2,y2);\n    vector<P> cp = sort_comp(cpcl(c,l));\n    printf(\"%.10lf %.10lf %.10lf %.10lf\\n\", cp[0].X, cp[0].Y, cp[1].X, cp[1].Y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rep1(i,n) for(int i = 1; i <= n; ++i)\n#define F first\n#define S second\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\nusing ll = long long;\nusing pi = pair<int,int>;\nusing ld = long double;\nconst ld EPS = 1e-10;\nstruct Vec2 {\n  ld x;\n  ld y;\n\n  Vec2() : x(0.0),y(0.0){} \n  Vec2(ld _x,ld _y) :x(_x),y(_y){}  \n  \n  Vec2 operator+(const Vec2& other) const { return { x + other.x , y + other.y }; }\n  Vec2 operator-(const Vec2& other) const { return { x - other.x , y - other.y }; }\n  bool operator==(const Vec2& other) const { return (abs(x - other.x) < EPS && abs(y - other.y) < EPS ); } \n  bool operator<(const Vec2& other) const { if(abs(x - other.x) < EPS) return y < other.y; else return x < other.x; }\n \n  ld dot(const Vec2& other) const { return x * other.x + y * other.y; }\n  ld cross(const Vec2& other) const { return x * other.y - y * other.x; }\n  ld length() const { return sqrt(x * x + y * y); }\n  \n  void Show() { printf(\"%.8Lf %.8Lf\\n\", x, y); }\n};\n\nstruct Line {\n  Vec2 s; // 始点\n  Vec2 t; // 終点\n  \n  Line() : s({0, 0}), t({0, 0}) {}\n  Line(Vec2 s, Vec2 t) : s(s), t(t) {}\n\n  Vec2 V() { return t - s; }\n  ld dot(const Line &other) const { return (t - s).dot(other.t - other.s); }\n  ld cross(const Line &other) const { return (t - s).cross(other.t - other.s); }\n  ld length() const { return (t - s).length(); }\n\n  ld alpha() { // 直線の傾き\n    if(abs((t - s).x) < EPS) { cout << \"pararell Y axis!!!\" << \"\\n\"; return 0; }\n    else return (t - s).y / (t - s).x;\n  }\n  ld beta() { // 直線の切片\n    if(abs((t - s).x) < EPS) { cout << \"pararell Y axis!!!\" << \"\\n\"; return 0; }\n    else return s.y - (t - s).y / (t - s).x * s.x;\n  }\n};\n// A とB のなす角θ cosθ, sinθ を返す\nld Cos(const Line &A, const Line &B) {\n  if(A.length() < EPS || B.length() < EPS) return 0;\n  return A.dot(B) / (A.length()*B.length());\n}\nld Sin(const Line &A, const Line &B) {\n  if(A.length() < EPS || B.length() < EPS) return 0;\n  return A.cross(B) / (A.length()*B.length());\n}\n// 線分ABをB方向に長さlに延長する\nLine ExpandB(const Line &AB, const ld &l) {\n  Line v(Vec2(0,0), Vec2(1,0));\n  Vec2 d(l * Cos(v, AB), l * Sin(v, AB));\n  return Line(AB.s, AB.s + d);\n}\n// 線分ABを両方向に長さlに延長する\nLine ExpandAB(Line &AB, ld &l) {\n  Line v(Vec2(0,0), Vec2(1,0));\n  Vec2 d(l * Cos(v, AB), l * Sin(v, AB));\n  return Line(AB.t - d, AB.s + d);\n}\n// 線分ABをx:y に内分する点を返す\nVec2 InDiv(Line &AB, ld x, ld y) {\n  ld l = AB.length() * x / (x + y);\n  return ExpandB(AB, l).t;\n}\n// 直線ABと点Cの距離\nld DistLinePoint(const Line &AB, const Vec2 &C) {\n  Line AC(AB.s, C);\n  return AC.length() * abs(Sin(AB, AC));\n}\n// 直線AB上に点Cを射影した点\nVec2 Proj(const Line &AB, const Vec2 &C) {\n  Line AC(AB.s, C);\n  ld l = AC.length() * Cos(AB, AC);\n  Line res = ExpandB(AB, l);\n  return res.t;\n}\n// 線分AB上に点Cがあるか\nbool IsInLine(const Line &AB, const Vec2 &C) {\n  Line CA(C, AB.s), CB(C, AB.t);\n  return abs(Sin(CA, CB)) < EPS && CA.dot(CB) < EPS;\n}\n// 線分の交差判定\nbool CrossCheck(const Line &AB, const Line &CD) {\n  //  if(a == c || a == d || b == c || b == d) return true; // 端点が等しい場合はtrue\n  Line AC(AB.s, CD.s), AD(AB.s, CD.t);\n  Line BC(AB.t, CD.s), BD(AB.t, CD.t);\n  Line CA(CD.s, AB.s), CB(CD.s, AB.t);\n  Line DA(CD.t, AB.s), DB(CD.t, AB.t);\n  ld s = AB.cross(AC) * AB.cross(AD);\n  ld t = CD.cross(CA) * CD.cross(CB);\n\n  if(abs(Sin(AB, CD)) < EPS) { // 平行のとき\n    if(abs(Sin(AB, AC)) < EPS) { // 同一直線上にあるか？\n      return (CA.dot(CB) < EPS || DA.dot(DB) < EPS || AC.dot(AD) < EPS || BC.dot(BD) < EPS);\n    }\n    else return false;\n  }\n  else return s < EPS && t < EPS;\n}\n// 直線の交点\nVec2 CrossPoint(Line &AB, Line &CD) {\n  if( abs(Sin(AB, CD)) < EPS) {\n    cout << \"Pararell\" << \"\\n\";\n    return Vec2(0,0);\n  }\n  if(abs(AB.V().x) < EPS) { // ABがy軸に平行\n    return Vec2(AB.s.x, CD.alpha() * AB.s.x + CD.beta());\n  }\n  else if( abs(CD.V().x) < EPS) { // CDがy軸に平行\n    return Vec2(CD.s.x, AB.alpha() * CD.s.x + AB.beta());\n  }\n  else {\n    ld resX = (CD.beta() - AB.beta()) / (AB.alpha() - CD.alpha());\n    ld resY = AB.alpha() * resX + AB.beta();\n    return Vec2(resX, resY);\n  }\n}\n// 点Cを通りABに平行な直線を返す\nLine OrthogonalLine(Line &AB, Vec2 &C) {\n  Vec2 t(C.x + AB.V().y, C.y - AB.V().x);\n  return Line(C, t);\n}\n\nstruct Circle {\n  Vec2 p;\n  ld r;\n\n  Circle() : p({0,0}), r(0) {}\n  Circle(Vec2 p, ld r) : p(p), r(r) {}\n  \n  void Show() { printf(\"%.8Lf %.8Lf %.8Lf\\n\", p.x, p.y, r); }\n};\n\n// 三角形の外接円\nCircle CircumscribedCircle(Vec2 &A, Vec2 &B, Vec2 &C) {\n  Line AB(A, B), BC(B, C);\n  Vec2 ABx = InDiv(AB, 1, 1);\n  Vec2 BCx = InDiv(BC, 1, 1);  \n  Line ABn = OrthogonalLine(AB, ABx);\n  Line BCn = OrthogonalLine(BC, BCx);\n  Vec2 Cen = CrossPoint(ABn, BCn);\n  return Circle(Cen, (Cen - A).length());\n}\n// \nvector<Vec2> CrossPointCircleLine(Circle &C, Line &AB){\n  vector<Vec2> res;\n  if(IsInLine(AB, C.p)) {\n    Line OX(C.p, AB.s);\n    Vec2 X = ExpandB(OX, C.r).t;\n    Line OY(C.p, AB.t);\n    Vec2 Y = ExpandB(OY, C.r).t;\n    res.push_back(X);\n    res.push_back(Y);\n    return res;\n  }\n  Vec2 P = Proj(AB, C.p);\n  Line OP(C.p, P);\n  Line OPn = OrthogonalLine(OP, P);\n  ld l = sqrt(C.r*C.r - OP.length()*OP.length());\n\n  if(C.r < OP.length()) return res;\n  Vec2 X = ExpandB(OPn, l).t;\n  Vec2 Y = ExpandB(OPn, -l).t;\n  // if(X == Y) res.push_back(X);\n  // else { \n    res.push_back(X);\n    res.push_back(Y);    \n    //  }\n  return res;\n}\nint main()\n{\n  Circle C;\n  cin >> C.p.x >> C.p.y >> C.r;\n  int q; cin >> q;\n  while(q-- > 0) {\n    Vec2 A,B;\n    cin >> A.x >> A.y;\n    cin >> B.x >> B.y;\n    Line AB(A, B);\n    ld inf = 4000;\n    Line ABE = ExpandAB(AB, inf);\n    vector<Vec2> res = CrossPointCircleLine(C, ABE);\n    sort(res.begin(), res.end());\n    rep(i,res.size()) printf(\"%.8Lf %.8Lf \", res[i].x, res[i].y);\n    cout << \"\\n\";\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct point{\n    double  x,y;\n    point(){};\n    point(double x,double y):x(x),y(y){}\n    point operator + (point p){\n        return point(x+p.x,y+p.y);\n    }\n    point operator - (point p){\n        return point(x-p.x,y-p.y);\n    }\n    point operator * (double k){\n        return point(x*k,y*k);\n    }\n    point operator / (double k){\n        return point(x/k,y/k);\n    }\n};\n\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(point a,point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(point p)\n{\n    return p.x*p.x+p.y*p.y;\n}\ndouble ABS(point p)\n{\n    return sqrt(norm(p));\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/norm(base);\n    return a+(base*r);\n}\n\npair<point,point>getcrosspoints(point a,int r,point b,point c)\n{\n    point pr=project(b,c,a);\n    point e=(b-c)/ABS(b-c);\n    double base=sqrt(r*r*1.0-norm(pr-a));\n    e=e*base;\n    return make_pair(pr+e,pr-e);\n}\n\nint main()\n{\n    point a;\n    int temp;\n    cin>>a.x>>a.y>>temp;\n    int q;\n    cin>>q;\n    point c,d;\n    for(int i=0;i<q;i++){\n        cin>>c.x>>c.y>>d.x>>d.y;\n        pair<point,point>res=getcrosspoints(a,temp,c,d);\n        if(res.first.x>res.second.x){\n            swap(res.first,res.second);\n        }\n        printf(\"%.8f %.8f %.8f %.8f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´?????????????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶????????????????????¬\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°????????????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//?????¨??´???????????????2??????\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//????´???°2D///////////A???)///////////\ntypedef complex<double> comp;\ntypedef vector<comp> cvec;\n//????´???????\ndouble dot(comp a,comp b){return real(b*conj(a));}\n//????´???????\ndouble cross(comp a,comp b){return imag(b*conj(a));}\ndouble Area(cvec &a){\n  double b=0;int n=a.size();\n  for(int i=0;i<n;i++)\n    b+=cross(a[i],a[(i+1==n?0:i+1)]);\n  return abs(b/2.0);\n}\n////how to use(exp)/////////////////////\n//  double a,b; cvec t; cin>>n;       //\n// while(n--){                        //\n//    cin>>a>>b;                      //\n//    t.push_back(comp(a,b));         //\n//  }printf(\"%.11f\\n\",Area(t));       //\n////////////////////////////////////////\nseg scan(){\n  seg a;\n  scanf(\"%lf%lf%lf%lf\",&a.p1.x,&a.p1.y,&a.p2.x,&a.p2.y);\n  return a;\n}\n\nint main(){\n  Circle o;\n  cin>>o.c.x>>o.c.y>>o.r;\n  int n;\n  cin>>n;\n  while(n--){\n    seg a;\n    a=scan();\n    seg p=getCrossPoint(o,a);\n    if(p.p1.x>p.p2.x){\n      Point t;\n      t=p.p1;\n      p.p1=p.p2;\n      p.p2=t;\n    }\n    else if(p.p1.y>p.p2.y){\n      Point t;\n      t=p.p1;\n      p.p1=p.p2;\n      p.p2=t;\n    }\n    printf(\"%.6f %.6f %.6f %.6f\\n\",p.p1.x,p.p1.y,p.p2.x,p.p2.y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define EPS  (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\n// 点类\nclass Point {\npublic :\n\tdouble x, y;\n\tPoint() {};\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n// 线段类\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() {};\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {};\n};\n// 圆类\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle() {};\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n// 定义向量\ntypedef Point Vector;\n// 定义直线\ntypedef Segment Line;\n// 定义多边形\ntypedef vector<Point> Polygon;\n\n/***************************点、向量****************************/\n\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\n\n// 向量的内积\ndouble dot(Point a, Point b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 向量的外积\ndouble cross(Point a, Point b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 向量a，b是否正交 <==> 内积为0\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn equals(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n// 向量a，b是否平行 <==> 外积为0\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn equals(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n// 点p在线段s上的投影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r ;\n}\n\n//以线段s为对称轴与点p成线对称的点\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n// 点a到点b的距离\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n// 线段l和点p的距离\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1) );\n}\n\n// 线段s与点p的距离\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t\treturn abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t\treturn abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n\n\n/*************************线段********************************/\n// 线段s1，s2是否正交 <==> 内积为0\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// 线段s1，s2是否平行 <==> 外积为0\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// 逆时针方向ccw（Counter-Clockwise）\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// 判断线段p1p2和线段p3p4是否相交\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n//判断线段s1和s2是否相交\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 线段s1和线段s2的距离\ndouble getDistance(Segment s1, Segment s2) {\n\t// 相交\n\tif (intersect(s1, s2))\n\t\treturn 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 线段s1与线段s2的交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/***************************圆****************************/\n\n// 圆c和直线l的交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n// 圆c1和圆c2的交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n/***************************多边形****************************/\n// 点的内包\n/*\n\tIN 2\n\tON 1\n\tOUT 0\n*/\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS)\n\t\t\tx = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n// 凸包\nPolygon andrewScan(Polygon s) {\n\tPolygon u, l;\n\tint len = s.size();\n\tif (len < 3) return s;\n\t// 以x，y为基准升序排序\n\tsort(s.begin(), s.end());\n\t// 将x值最小的两个点添加到u\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\n\t// 将x值最大的两个点添加到l\n\tl.push_back(s[len - 1]);\n\tl.push_back(s[len - 2]);\n\n\t// 构建凸包上部\n\tfor (int i = 2; i < len; i++) {\n\t\tfor (int j = u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], s[i]) != CLOCKWISE; j--)\n\t\t\tu.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\n\t// 构建凸包下部\n\tfor (int i = len - 3; i >= 0; i--) {\n\t\tfor (int j = l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], s[i]) != CLOCKWISE; j--)\n\t\t\tl.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\n\t// 按顺时针方向生成凸包的点的序列\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--)\n\t\tl.push_back(u[i]);\n\n\treturn l;\n}\n\n\nint main() {\n\tCircle c;\n\tLine l;\n\tint n;\n\tscanf(\"%lf %lf %lf\", &c.c.x, &c.c.y, &c.r);\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%lf %lf %lf %lf\", &l.p1.x, &l.p1.y,\n\t\t\t&l.p2.x, &l.p2.y);\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\t\tif (ans.first < ans.second)\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\", ans.first.x, ans.first.y,\n\t\t\t\tans.second.x, ans.second.y);\n\t\telse\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\", ans.second.x, ans.second.y,\n\t\t\t\tans.first.x, ans.first.y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct F {\n\tlong long a, b;\n\tF() {}\n\tF(long long _a, long long _b) : a(_a), b(_b) {}\n\tF operator + (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a + a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator - (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a - a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator * (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator / (const F &f) {\n\t\tlong long x = a * f.b, y = b * f.a;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n};\nconst double pi = acos(-1);\nconst double eps = 1e-8;\ninline int sign(double a) {\n\treturn a < -eps ? -1 : a > eps;\n}\ninline int cmp(double a, double b) {\n\treturn sign(a - b);\n}\ndouble add(double a, double b) {\n\tif (abs(a + b) < eps * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\ntypedef double data;\nstruct P {\n\tdata x, y;\n\tP() {}\n\tP(data x, data y) : x(x), y(y) {}\n\tP operator + (const P &p) { return P(x + p.x, y + p.y); }\n\tP operator - (const P &p) { return P(x - p.x, y - p.y); }\n\tP operator * (data d) { return P(x * d, y * d); }\n\tP operator / (data d) { return P(x / d, y / d); }\n\tdata dot(const P &p) { return x * p.x + y * p.y; }\n\tdata det(const P &p) { return x * p.y - y * p.x; }\n\tdouble disto(const P &p) { return (*this - p).abs(); }\n\tdouble alpha() { return atan2(y, x); }\n\tdouble abs() { return sqrt(abs2()); }\n\tdata abs2() { return x * x + y * y; }\n\tP rot90() { P(-y, x); }\n\tP unit() { return *this / abs(); }\n\tbool operator < (P p) const {\n\t\tint c = cmp(x, p.x);\n\t\tif (c) return c == -1;\n\t\treturn cmp(y, p.y) == -1;\n\t}\n\tfriend istream& operator>>(istream &in, P &p) {\n\t\tin >> p.x >> p.y;\n\t\treturn in;\n\t}\n\tfriend ostream& operator<<(ostream& out, P &p) {\n\t\tout << p.x << ' ' << p.y;\n\t\treturn out;\n\t}\n};\nP projection(P p1, P p2, P q) {\n\tP dir = p2 - p1;\n\treturn p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\nP reflection(P p1, P p2, P q) {\n\treturn projection(p1, p2, q) * 2 - q;\n}\nbool is_midddle(data a, data m, data b) {\n\treturn sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\nbool is_midddle(P a, P m, P b) {\n\treturn is_midddle(a.x, m.x, b.x) && is_midddle(a.y, m.y, b.y);\n}\nbool on_seg(P p1, P p2, P q) {\n\treturn sign((p1 - q).det(p2 - q)) == 0 && (p1 - q).dot(p2 - q) <= 0;\n\t// return (p1 - q).det(p2 - q) == 0 && is_middle(p1, q, p2);\n}\nbool intersect(data l1, data r1, data l2, data r2) {\n\tif (l1 > r1) swap(l1, r1);\n\tif (l2 > r2) swap(l2, r2);\n\treturn cmp(r1, l2) != -1 && cmp(r2, l1) != -1;\n}\nbool intersect(P p1, P p2, P q1, P q2) {\n\treturn intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y)\n\t       && sign((p2 - p1).det(q1 - p1)) * sign((p2 - p1).det(q2 - p1)) <= 0\n\t       && sign((q2 - q1).det(p1 - q1)) * sign((q2 - q1).det(q2 - q1)) <= 0;\n}\nP seg_intersection(P p1, P p2, P q1, P q2) {\n\tdata a1 = (q2 - q1).det(p1 - q1), a2 = -(q2 - p1).det(p2 - q1);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\nP line_intersection(P p1, P p2, P q1, P q2) {\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\ndata nearest(P p1, P p2, P q) {\n\tP h = projection(p1, p2, q);\n\tif (is_midddle(p1, h, p2)) return q.disto(h);\n\treturn min(p1.disto(q), p2.disto(q));\n}\ndata seg_dist(P p1, P p2, P q1, P q2) {\n\tif (intersect(p1, p2, q1, q2)) return 0;\n\treturn min(min(nearest(p1, p2, q1), nearest(p1, p2, q2)), min(nearest(q1, q2, p1), nearest(q1, q2, p2)));\n}\ndata area(vector<P> &ps) {\n\tdata res = 0;\n\tint n = ps.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tres += ps[i].det(ps[(i + 1) % n]);\n\t}\n\treturn abs(res / 2);\n}\nbool is_convex(vector<P> &ps) {\n\tint n = ps.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tdata a1 = (ps[(i + 1) % n] - ps[i]).det(ps[(i + 2) % n] - ps[(i + 1) % n]);\n\t\tdata a2 = (ps[(i + 2) % n] - ps[(i + 1) % n]).det(ps[(i + 3) % n] - ps[(i + 2) % n]);\n\t\tif (a1 * a2 < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint contain(vector<P> &ps, P p) {\n\tint n = ps.size(), res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tP u = ps[i], v = ps[(i + 1) % n];\n\t\tif (on_seg(u, v, p)) return 1;\n\t\tif (cmp(u.y, v.y) <= 0) swap(u, v);\n\t\tif (cmp(p.y, u.y) > 0 || cmp(p.y, v.y) <= 0) continue;\n\t\tres ^= (u - p).det(v - p) > 0;\n\t}\n\treturn res * 2;\n\t//2:inside 1:on_seg 0:outside\n}\nvector<P> convex_hull(vector<P> &ps) {\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<P> qs(n << 1);\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\nvector<P> convex_hull_nonstrict(vector<P> &ps) {\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<P> qs(n << 1);\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) < 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) < 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\ndata convex_diameter(vector<P> &ps) {\n\tint n = ps.size();\n\tif (n <= 1) return 0;\n\tint is = 0, js = 0;\n\tfor (int k = 1; k < n; k++) {\n\t\tis = ps[k] < ps[is] ? k : is;\n\t\tjs = ps[js] < ps[k] ? k : js;\n\t}\n\tint i = is, j = js;\n\tdouble res = ps[i].disto(ps[j]);\n\tdo {\n\t\tif ((ps[(i + 1) % n] - ps[i]).det(ps[(j + 1) % n] - ps[j]) >= 0) {\n\t\t\t(++j) %= n;\n\t\t} else {\n\t\t\t(++i) %= n;\n\t\t}\n\t\tres = max(res, ps[i].disto(ps[j]));\n\t} while (i != is || j != js);\n\treturn res;\n}\nvector<P> convex_cut(vector<P> &ps, P q1, P q2) {\n\tvector<P> qs;\n\tint n = ps.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP p1 = ps[i], p2 = ps[(i + 1) % n];\n\t\tint d1 = sign((q2 - q1).det(p1 - q1)), d2 = sign((q2 - q1).det(p2 - q1));\n\t\tif (d1 >= 0) qs.push_back(p1); // left-half\n\t\tif (d1 * d2 < 0) qs.push_back(line_intersection(p1, p2, q1, q2));\n\t}\n\treturn qs;\n}\ndata closest_pair(vector<P> &ps, int l, int r) {\n\t// ps should be sorted before this\n\tif (r - l <= 5) {\n\t\tdouble res = 1e100;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tfor (int j = l; j < i; j++) {\n\t\t\t\tres = min(res, ps[i].disto(ps[j]));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tint m = (l + r) >> 1;\n\tdouble res = min(closest_pair(ps, l, m), closest_pair(ps, m, r));\n\tvector<P> qs;\n\tfor (int i = l; i < r; i++) {\n\t\tif (abs(ps[i].x - ps[m].x) <= res) {\n\t\t\tqs.push_back(ps[i]);\n\t\t}\n\t}\n\tsort(qs.begin(), qs.end(), [](const P & a, const P & b) { return a.y < b.y; });\n\tfor (int i = 1, sz = qs.size(); i < sz; i++) {\n\t\tfor (int j = i - 1; j >= 0 && qs[j].y >= qs[i].y - res; j--) {\n\t\t\tres = min(res, qs[i].disto(qs[j]));\n\t\t}\n\t}\n\treturn res;\n}\nP circum_center(P p0, P p1, P p2) {\n\tdouble a1 = p1.x - p0.x, b1 = p1.y - p0.y, c1 = (a1 * a1 + b1 * b1) / 2;\n\tdouble a2 = p2.x - p0.x, b2 = p2.y - p0.y, c2 = (a2 * a2 + b2 * b2) / 2;\n\tdouble d = a1 * b2 - a2 * b1;\n\treturn P(p0.x + (c1 * b2 - c2 * b1) / d, p0.y + (a1 * c2 - a2 * c1) / d);\n}\nint circle_intersect(P o1, data r1, P o2, data r2) {\n\tdata d = (o1 - o2).abs2();\n\tif(cmp(d, (r1 + r2) * (r1 + r2)) == 1) return 4;\n\tif(cmp(d, (r1 + r2) * (r1 + r2)) == 0) return 3;\n\tif(cmp(d, abs(r1 - r2) * abs(r1 - r2)) == 1) return 2;\n\tif(cmp(d, abs(r1 - r2) * abs(r1 - r2)) == 0) return 1;\n\treturn 0;\n}\nvector<P> circle_intersection(P o, data r, P p1, P p2) {\n\tdata x = (p1 - o).dot(p2 - p1), y = (p2 - p1).abs2(), d = x * x - y * ((p1 - o).abs2() - r * r);\n\tif(sign(d) < 0) return {};\n\td = max(d, 0.0);\n\tP m = p1 - (p2 - p1) * (x / y), dr = (p2 - p1) * (sqrt(d) / y);\n\treturn {m - dr, m + dr};\n}\n\nint main() {\n#ifdef LOCAL_DEFINE\n\tfreopen(\"data.in\", \"rt\", stdin);\n\t//freopen(\"data.out\", \"w\", stdout);\n\tauto _start = chrono::high_resolution_clock::now();\n#endif\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tP c; double r;\n\tcin >> c >> r;\n\tint q;\n\tcin >> q;\n\twhile(q--) {\n\t\tP p1, p2;\n\t\tcin >> p1 >> p2;\n\t\tvector<P> ans = circle_intersection(c, r, p1, p2);\n\t\tsort(ans.begin(), ans.end());\n\t\tfor(P &p : ans) {\n\t\t\tcout << p << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n\n#ifdef LOCAL_DEFINE\n\tauto _end = chrono::high_resolution_clock::now();\n\tcerr << \"elapsed time: \" << chrono::duration<double, milli>(_end - _start).count() << \" ms\\n\";\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nstruct Circle;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l);\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point,Point> getCrossPoints(Circle c, Line l);\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l){\n    return getDistanceLP(l, c.c) < c.r+EPS; // ?\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1-s2.p1));\n    double d2 = abs(cross(base, s1.p2-s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point,Point> getCrossPoints(Circle c, Line l){\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\n\nint main(){\n    double x, y, r;\n    cin >> x >> y >> r;\n    Circle C(Point(x,y), r);\n\n    int q;\n    cin >> q;\n\n    while(q-- > 0){\n        double a, b, c, d;\n        cin >> a >> b >> c >> d;\n        pair<Point, Point> p = getCrossPoints(C, Line(Point(a,b), Point(c,d)));\n        if(p.second < p.first)  swap(p.first, p.second);\n        cout << fixed << setprecision(12) << p.first.x << \" \" << p.first.y << \" \" << p.second.x << \" \" << p.second.y << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment\n\n// dot(a,b) = |a||b|cos x\nlong double dot(CP a, CP b) { return (a * conj(b)).X; }\n// cross(a,b) : area of parallelogram\nlong double cross(CP a, CP b) { return (a * conj(b)).Y; }\nlong double corner(CP a, CP b) {\n  //[0,pi]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\nCP projection(CP p, CP s, CP t) {\n  CP base = t - s;\n  long double r = dot(p - s, base) / norm(base);\n  return s + base * r;\n}\nCP reflection(CP p, CP s, CP t) {\n  CP tmp = (projection(p, s, t) - p);\n  tmp *= 2;\n  return p + tmp;\n}\n\nCP intersection(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP a, CP b, CP p) {\n  // if not use end point, dot(a - p, b - p) < 0\n  return abs(cross(a - p, b - p)) <= 1e-10 &&\n         dot(a - p, b - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersection(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong double distLP(CP a, CP b, CP p) {\n  return abs(cross(b - a, p - a) / abs(b - a));\n}\n\n// segmentver.\nlong double distSP(CP a, CP b, CP p) {\n  if(dot(b - a, p - a) < 0) return abs(p - a);\n  if(dot(a - b, p - b) < 0) return abs(p - b);\n  return distLP(a, b, p);\n}\n\n// segment and segment\nlong double distSS(CP a, CP b, CP c, CP d) {\n  long double res = 1e18;\n  if(iscross(a, b, c, d)) return 0.0L;\n  res = min(res, distSP(a, b, c));\n  res = min(res, distSP(a, b, d));\n  res = min(res, distSP(c, d, a));\n  res = min(res, distSP(c, d, b));\n  return res;\n}\n\nstruct convex_hull {\n  vector<CP> ch;\n  int psize;\n  convex_hull() {}\n  convex_hull(vector<CP> &ps) { calculation(ps); }\n  void calculation(vector<CP> &ps) {\n    auto lmd = [&](const CP &l, const CP &r) {\n      if(l.X != r.X) return l.X < r.X;\n      return l.Y < r.Y;\n    };\n    psize = ps.size();\n    sort(ps.begin(), ps.end(), lmd);\n    int k = 0;\n    ch.resize(psize * 2);\n    for(int i = 0; i < psize; ++i) {\n      while(k > 1 && cross(ch[k - 1] - ch[k - 2],\n                           ps[i] - ch[k - 1]) <= 0)\n        --k;\n      ch[k++] = ps[i];\n    }\n    for(int i = psize - 2, t = k; i >= 0; --i) {\n      while(k > t && cross(ch[k - 1] - ch[k - 2],\n                           ps[i] - ch[k - 1]) <= 0)\n        --k;\n      ch[k++] = ps[i];\n    }\n    ch.resize(k - 1);\n    psize = ch.size();\n  }\n};\n\nstruct Circle {\n  CP o;\n  long double r;\n  Circle(long double _x = 0.0L, long double _y = 0.0L,\n         long double _r = 0.0L)\n      : o(CP(_x, _y)), r(_r) {}\n};\n\nvoid intersectionCL(Circle ci, CP s, CP t, CP &res1,\n                    CP &res2) {\n  res1 = res2 = projection(ci.o, s, t);\n  long double r = sqrtl(ci.r * ci.r - norm(res1 - ci.o));\n  t -= s;\n  t *= r / abs(t);\n  res1 += t;\n  res2 -= t;\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nlong long n, id = 0, a, b, c, d;\nCircle ci;\nCP s, t, res1, res2;\n\nint main() {\n  cout << fixed << setprecision(10);\n  cin >> a >> b >> c;\n  ci = Circle(a, b, c);\n  cin >> n;\n  for(int i = 0; i < n; ++i) {\n    cin >> a >> b >> c >> d;\n    s = CP(a, b);\n    t = CP(c, d);\n    intersectionCL(ci, s, t, res1, res2);\n    cout << res1.X << \" \" << res1.Y << \" \" << res2.X << \" \"\n         << res2.Y << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nP pin(){\n\tdouble x,y;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.c < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL circles_point(C a,C b){\n    double d = abs(a.c-b.c);\n    double s = (a.r+a.r+d) / 2;\n    double S = sqrt(s*(s-a.r)*(s-b.r)*(s-d));\n    double h = 2 * S / d;\n    P v = (b.c-b.c) / (abs(b.c-a.c)); \n    double m = sqrt(a.r*a.r - h*h);\n    P aa=a.c + m*v+h*v*P(0,1);\n\tP bb=a.c + m*v-h*v*P(0,1);\n\tif(bb<aa)\n\t\tswap(aa,bb);\n\treturn L(aa,bb);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint contain(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nint main(){\n\tdouble a,b,d;\n\tcin>>a>>b>>d;\n\tC c(P(a,b),d);\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tP p[2];\n\t\tPIN(p,2);\n\t\tL l(p[0],p[1]);\n\t\tL out=crosspointCL(c,l);\n\t\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int N = 200000 + 10;\nconst double EPS = 1e-7;\nconst double INF = 1e12;\nint sgn(double x) {\n    if (x < -EPS) return -1;\n    if (x > +EPS) return +1;\n    return 0;\n}\nstruct Vec {\n    double x,y;\n    Vec() {}\n    Vec(double x, double y) { \n        this->x = x, this->y = y; \n    }\n    void read() { \n        scanf(\"%lf %lf\", &x, &y); \n    }\n    void prt() {\n        printf(\"%.8f %.8f \", x, y); \n    }\n    double len() { \n        return sqrt(x * x + y * y); \n    }\n    double len2() { \n        return x * x + y * y; \n    }\n    bool operator <(const Vec& o)const {\n        if(x == o.x)\n            return y < o.y;\n        return x < o.x;\n    }\n    Vec operator +(const Vec& o)const { \n        return Vec(x + o.x, y + o.y); \n    }\n    Vec operator -(const Vec& o)const { \n        return Vec(x - o.x, y - o.y); \n    }\n    Vec operator *(const double& k)const { \n        return Vec(k * x, k * y); \n    }\n    double operator *(const Vec& o)const {\n        return x * o.x + y * o.y; \n    }\n    double operator ^(const Vec& o)const {\n        return x * o.y - y * o.x; \n    }\n    Vec rotate(double ang){ \n        return Vec(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang)); \n    }\n    Vec change(double l) { \n        if(len() < EPS) return *this; \n        return (*this) * (l/len()); \n    }\n};\nbool cmpang(Vec A, Vec B) {\n    if ((A ^ B) == 0) {\n        return A < B;\n    }\n    return (A ^ B) > 0;\n}\n\nstruct Line {\n    Vec A1, A2;\n    Line() {}\n    Line(Vec A1, Vec A2) {\n        this->A1 = A1, this->A2 = A2;\n    }\n    double len() {\n        return (A2-A1).len();\n    }\n    double Len2() {\n        return (A2-A1).len2();\n    }\n    double getAng() const {\n        return atan2(A2.y-A1.y, A2.x-A1.x);\n    }\n    void prt() {\n        printf(\"(%.5f %.5f) - (%.5f %.5f) %.7f\\n\", A1.x,A1.y,A2.x,A2.y,(*this).getAng());\n    }\n    bool operator <(const Line& o)const {\n        Line l = o;\n        double A = (*this).getAng();\n        double B = l.getAng();\n        if (abs(A-B) < EPS)\n            return ((A2-A1)^(l.A1-A1)) > EPS;\n        return A < B;\n    }   \n};\n// P to L\ndouble disToLine(Vec P, Line L) {\n    return abs((P-L.A1)^(L.A2-L.A1)) / L.len();\n}\nVec projection(Vec P, Line L) {\n    double shadowLen = (P - L.A1) * (L.A2 - L.A1) / (L.A2 - L.A1).len();\n    return L.A1 + (L.A2-L.A1).change(shadowLen);\n}\nVec rejection(Vec P, Line L) {\n    return projection(P,L) * 2 - P;\n}\nbool onseg(Vec P, Line L) {\n    if(disToLine(P, L) > EPS) return 0;\n    return (P-L.A1) * (P-L.A2) <= 0;\n}\nVec Lineintersect(Line L1, Line L2) {\n    // 0 ~ (L2.A1 - L1.A1) ^ (L2.A2 - L1.A1);\n    // 1 ~ (L2.A1 - L1.A2) ^ (L2.A2 - L1.A2);\n    double F0 = (L2.A1 - L1.A1) ^ (L2.A2 - L1.A1);\n    double F1 = (L2.A1 - L1.A2) ^ (L2.A2 - L1.A2);\n    if (abs(F1 - F0) < EPS) return Vec(INF, INF);\n    return L1.A1 + (L1.A2 - L1.A1) * (- F0 / (F1 - F0));\n}\nVec Segintersect(Line L1, Line L2) {\n    Vec P = Lineintersect(L1, L2);\n    if (P.x == INF) return P;\n    if (onseg(P, L1) && onseg(P, L2)) return P;\n    return Vec(INF, INF);\n}\nbool disToSeg(Vec P, Line L) {\n    double ans = min((P-L.A1).len(), (P-L.A2).len());\n    ans = min(ans, (P - projection(P,L)).len());\n    return ans;\n}\n\n// \nvector<Vec> shiftConvexHull(vector<Vec> A) {\n    double my = INF, mx = INF; int st = -1;\n    for (int i = 0; i < A.size(); i ++) {\n        if (A[i].y < my || (A[i].y == my && A[i].x < mx) ) {\n            my = A[i].y; mx = A[i].x; st = i;\n        }\n    }\n    vector<Vec> ans;\n    for (int i = 0; i < A.size(); i ++) {\n        ans.push_back(A[(i+st)%A.size()]);\n    }\n    return ans;\n}\n\nvector<Vec> convexHull(vector<Vec> v) {\n    sort(v.begin(), v.end());\n    vector<Vec> ans; ans.resize(2*v.size());\n    int top = 0, n = v.size();\n    if(n <= 1) return v;\n\n    for(int i = 0; i < n; ans[top++] = v[i++]) {\n        while (top > 1 && ((ans[top-1] - ans[top-2]) ^ (v[i] - ans[top-1])) < EPS) -- top;\n    }\n    for(int i = n-2, t = top; i >= 0; ans[top++] = v[i--]) {\n        while (top > t && ((ans[top-1] - ans[top-2]) ^ (v[i] - ans[top-1])) < EPS) -- top;\n    } \n    while(ans.size() >= top) ans.pop_back();\n    return ans;\n}\ndouble PolyArea(vector<Vec> v) {\n    double ans = 0;\n    int n = v.size();\n    for(int i = 0; i < v.size(); i ++) {\n        ans = ans + (v[i] ^ v[(i+1)%n]);\n    }\n    return abs(ans) / 2;\n}\nvector<Vec> convexCut(vector<Vec> v, Vec P1, Vec P2) {\n    vector<Vec> ans;\n    for(int i=0;i<v.size();i++) {\n        int d1 = sgn((P2-P1)^(v[i]-P1));\n        int d2 = sgn((P2-P1)^(v[(i+1)%v.size()]-P1));\n        if (d1 >= 0) ans.push_back(v[i]);\n        if (d1 * d2 < 0) ans.push_back(Lineintersect(Line(P1,P2), Line(v[i],v[(i+1)%v.size()])));\n    }\n    return ans;\n}\ndouble cloestPair(vector<Vec> v) {\n    if (v.size() <= 1) return INF;\n\n    sort(v.begin(), v.end());\n    vector<Vec> vL, vR;\n    int mid = v.size() / 2;\n    for (int i = 0; i < v.size(); i ++) {\n        if (i < mid)\n            vL.push_back(v[i]);\n        else\n            vR.push_back(v[i]);\n    }\n    double d = min(cloestPair(vL), cloestPair(vR));\n    \n    vector<Vec> strip;\n    for (int i = 0; i < v.size(); i ++) {\n        if (abs(v[mid].x - v[i].x) <= d + EPS) \n            strip.push_back(v[i]);\n    }\n\n    for (int i = 0; i < strip.size(); i ++) swap(strip[i].x, strip[i].y);\n    sort(strip.begin(), strip.end());\n    for (int i = 0; i < strip.size(); i ++) swap(strip[i].x, strip[i].y);\n\n    for (int i = 0; i < strip.size(); i ++) {\n        for (int j = i + 1; j < strip.size(); j ++) {\n            if (strip[j].y - strip[i].y > d + EPS) break;\n            d = min(d, (strip[j]-strip[i]).len());\n        }\n    }\n    return d;\n}\nbool onRight(Line L1, Line L2, Line L3) {\n    Vec P = Lineintersect(L2, L3);\n    return ((L1.A2 - L1.A1) ^ (P - L1.A1)) < 0;\n}\nvector<Vec> halfPlaneIntersection(vector<Line> L) {\n    sort(L.begin(), L.end());\n\n    int head = 0, tail = 0, cnt = 0; //[head, tail)\n    Line que[L.size()+1];\n    for (int i = 0; i < (int)L.size() - 1; i ++) {\n        if (abs(L[i].getAng() - L[i+1].getAng()) < EPS) continue;\n        L[cnt ++] = L[i];\n    }\n\n    L[cnt ++] = L[(int)L.size() - 1];\n\n    for (int i = 0; i < cnt; i ++) {\n        while (tail - head > 1 && onRight(L[i], que[tail-1], que[tail-2])) -- tail;\n        while (tail - head > 1 && onRight(L[i], que[head], que[head+1])) ++ head;\n        que[tail++] = L[i];\n    }\n    while (tail - head > 1 && onRight(que[tail-1], que[head], que[head+1])) ++ head;\n    while (tail - head > 1 && onRight(que[head], que[tail-1], que[tail-2])) -- tail;\n    \n    vector<Vec> ans;\n    for (int i = head; i < tail - 1; i ++) {\n        ans.push_back(Lineintersect(que[i], que[i+1]));\n    }\n    ans.push_back(Lineintersect(que[tail - 1], que[head]));\n    \n    return ans;\n}\nvector<Vec> Minkowski(vector<Vec> a, vector<Vec> b) {\n    vector<Line> L;\n    for (int i = 0; i < a.size(); i ++) {\n        L.push_back(Line(a[i], a[(i+1)%(int)a.size()]));\n    }\n    for (int i = 0; i < b.size(); i ++) {\n        L.push_back(Line(b[i], b[(i+1)%(int)b.size()]));\n    }\n    sort(L.begin(), L.end());\n    vector<Vec> ans;\n\n    Vec now = Vec(0, 0); \n    ans.push_back(now);\n    for (int i = 0; i < L.size(); i ++) {\n        ans.push_back(now + L[i].A2 - L[i].A1);\n        now = now + L[i].A2 - L[i].A1;\n    }\n\n    Vec LD = Vec(INF,INF);\n    for (int i = 0; i < ans.size(); i ++) {\n        LD = min(LD, ans[i]);\n    }\n    for (int i = 0; i < ans.size(); i ++) {\n        ans[i] = ans[i] + (a[0] + b[0] - LD);        \n    }\n    return ans;\n}\n/*\nCircle:\n*/\n\nstruct Circle {\n    Vec O; double r;\n    void read() {\n        O.read(); scanf(\"%lf\", &r);\n    }\n};\nvector<Vec> isCL(Circle C, Line L) {\n    vector<Vec> ans;\n    double dis = disToLine(C.O, L);\n    if (dis > C.r + EPS) return ans;\n    Vec P = projection(C.O, L);\n\n    //printf(\"%.8f %.8f\\n\", P.x, P.y);\n    Vec v = (L.A1 - L.A2).change(sqrt(C.r * C.r - dis * dis));\n    ans.push_back(P + v);\n    ans.push_back(P - v);\n    sort(ans.begin(), ans.end());\n    for (auto p: ans)\n        p.prt();\n    printf(\"\\n\");\n    return ans;\n}\nvector<Vec> isCC(Circle C1, Circle C2) {\n    vector<Vec> ans;\n    double d = (C1.O - C2.O).len();\n\n    if (C1.r + C2.r < d - EPS) return ans;\n    if (abs(C1.r - C2.r) > d + EPS) return ans;\n\n    double cos1 = (C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d);\n    Vec v1 = (C2.O - C1.O).change(C1.r * cos1);\n    Vec v2 = v1.rotate(acos(-1)/2).change(C1.r * sqrt(1 - cos1*cos1));\n    ans.push_back(C1.O + v1 + v2);\n    ans.push_back(C1.O + v1 - v2);\n    return ans;\n} \nvector<Vec> tanCP(Circle C, Vec P) {\n    double x = (C.O - P).len();\n    double d = x * x - C.r * C.r;\n    vector<Vec> ans;\n    if (d < -EPS) return ans;\n    if (d < 0) d = 0;\n    Vec q1 = (P - C.O) * ( (C.r * C.r) / (x * x) );\n    Vec q2 = q1.rotate(acos(-1) / 2).change(C.r / x * (sqrt(x * x - C.r * C.r)));\n    ans.push_back(C.O + q1 + q2);\n    ans.push_back(C.O + q1 - q2);\n    return ans;\n}\n\nvector<Line> tanCC(Circle C1, Circle C2) {\n\n}\ndouble AreaCC(Circle C1, Circle C2) {\n    double d = (C1.O - C2.O).len();\n    if (C1.r + C2.r > d + EPS) {\n        return C1.r * C1.r * acos(-1) + C2.r * C2.r * acos(-1);\n    }\n    if (abs(C1.r - C2.r) < d - EPS) {\n        return max(C1.r, C2.r) * max(C1.r, C2.r) * acos(-1);\n    }\n    double ans = C1.r * C1.r * acos(-1) + C2.r * C2.r * acos(-1);\n    double cos1 = (C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d);\n    double the1 = 2 * acos(cos1);\n\n    double cos2 = (C2.r * C2.r + d * d - C1.r * C1.r) / (2 * C2.r * d);\n    double the2 = 2 * acos(cos2);\n\n    ans = ans - ( (2 * acos(-1) - the1) * C1.r * C1.r - sin(the1) * C1.r * C1.r / 2 );\n    ans = ans - ( (2 * acos(-1) - the2) * C2.r * C2.r - sin(the2) * C2.r * C2.r / 2 );\n    return ans;\n}   \ndouble AreaCT(Circle C1, Vec P1, Vec P2) {\n\n}\n\nint main(){\n    Circle C;\n    C.read();\n    int q; scanf(\"%d\", &q);\n    while (q --) {\n        Vec A, B;\n        A.read(); \n        B.read();\n        isCL(C,Line(A,B));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\ntypedef db T;\nconst db eps = 1e-8;\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n    T x,y;\n    P(){} P(T x,T y):x(x),y(y){}\n    void read(){scanf(\"%lf%lf\",&x,&y);}\n    P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n    P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n    T operator * (const P&b) const {return x*b.x+y*b.y;}\n    P operator * (const T&k) const {return P(x*k,y*k);}\n    T operator ^ (const P&b) const {return x*b.y-y*b.x;}\n    bool operator < (const P&b) const {return sgn(x-b.x)?x<b.x:y<b.y;}\n};\nT norm(P x){return x*x;}\nT abs(P x){return sqrt(x*x);}\nstruct L{\n    P s,t;\n    void read(){s.read();t.read();}\n};\nstruct C{\n    P o;T r;\n    void read(){o.read();scanf(\"%lf\",&r);}\n};\nint relation(C A,C B){\n    T dis = abs(A.o - B.o);\n    if(sgn(dis - (A.r + B.r)) == 1) return 4;\n    if(sgn(dis - (A.r + B.r)) == 0) return 3;\n    if(sgn(dis - fabs(A.r - B.r)) == 1) return 2;\n    if(sgn(dis - fabs(A.r - B.r)) == 0) return 1;\n    return 0;\n}\nvector<P> insCL(C c,L a){\n    db x = (a.s-c.o)*(a.t-a.s) , y = norm(a.t-a.s);\n    db d = x * x - y * (norm(a.s-c.o) - c.r*c.r);\n    vector<P> res;\n    if(sgn(d) < 0) return res;\n    d = max(d,0.);\n    P mid = a.s - (a.t - a.s) * (x / y);\n    P del = (a.t - a.s) * (sqrt(d) / y);\n    return {mid - del,mid + del};\n}\n\nint main(){\n    C o;o.read();\n    int Q;scanf(\"%d\",&Q);\n    rep(i,0,Q){\n        L a;a.read();\n        vector<P> ans = insCL(o,a);\n        sort(all(ans));\n        for(auto p : ans) printf(\"%.10f %.10f \",p.x,p.y);\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    double abs(){ return sqrt(norm()); }\n    double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ndouble getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = 2;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = -2;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n//两个线段的交点\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/* 圆与直线的交点\n * 交点为一个的时候返回两个相同的点\n * 没有交点则退出\n */\n\nbool intersect(Circle c,Line l){\n    return sign(getDistanceLP(l,c.c)-c.r)<=0;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));         //没有交点\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\nint main(){\n    double r;\n    Point p1,p2,p;\n    scanf(\"%lf%lf%lf\",&p.x,&p.y,&r);\n    Circle c(p,r);\n    int n;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%lf%lf%lf%lf\",&p1.x,&p1.y,&p2.x,&p2.y);\n        pair<Point,Point> ans=getCrossPoints(c,Line{p1,p2});\n        if(ans.first.x>ans.second.x) swap(ans.first,ans.second);\n        else if(ans.first.x==ans.second.x&&ans.first.y>ans.second.y) swap(ans.first,ans.second);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",ans.first.x,ans.first.y,ans.second.x,ans.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 100010;\nconst double eps = 1e-10;\nclock_t START, END;\n\nint X, Y, E;\n\n//basic defitition\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n};\ntypedef Point Vector;\nVector operator + (Vector A, Vector B) { return Vector(A.x + B.x, A.y + B.y); }\nVector operator - (Point A, Point B) { return Vector(A.x - B.x, A.y - B.y); }\nVector operator * (Vector A, double p) { return Vector(A.x * p, A.y * p); }\nVector operator / (Vector A, double p) { return Vector(A.x / p, A.y / p); }\nbool operator < (const Point& a, const Point& b) { return a.x < b.x || (a.x == b.x && a.y < b.y); }\nint dcmp(double x) { if (fabs(x) < eps)return 0; else return x < 0 ? -1 : 1; }\nbool operator == (const Point& a, const Point& b) { return dcmp(a.x - b.x) == 0 && dcmp(a.y - b.y) == 0; }\nstruct Line {\n\tPoint p;\n\tVector v;\n\tLine(Point p, Vector v) :p(p), v(v) {}\n\tPoint point(double t) { return p + v * t; }\n\t//Line move(double d) { return Line(p + Normal(v) * d, v); }\n};\n// basic operator\ndouble Dot(Vector A, Vector B) { return A.x * B.x + A.y * B.y; }\ndouble Length(Vector A) { return sqrt(Dot(A, A)); }\ndouble Angle(Vector A, Vector B) { return acos(Dot(A, B) / Length(A) / Length(B)); }\ndouble Cross(Vector A, Vector B) { return A.x * B.y - A.y * B.x; }\ndouble Area2(Point A, Point B, Point C) { return Cross(B - A, C - A); }\nVector Rotate(Vector A, double rad) { return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad)); }\nVector Normal(Vector A) { double L = Length(A); return Vector(-A.y / L, A.x / L); } //A is not zero vector\n//point and line\nPoint GetLineIntersection(Point P, Vector v, Point Q, Vector w) {\n\tVector u = P - Q;\n\tdouble t = Cross(w, u) / Cross(v, w);\n\treturn P + v * t;\n}//two lines only have one intersection and Cross(v,w) is not zero\ndouble DistanceToLine(Point P, Point A, Point B) {\n\tVector v1 = B - A, v2 = P - A;\n\treturn fabs(Cross(v1, v2)) / Length(v1);\n}\ndouble DistanceToSegment(Point P, Point A, Point B) {\n\tif (A == B) return Length(P - A);\n\tVector v1 = B - A, v2 = P - A, v3 = P - B;\n\tif (dcmp(Dot(v1, v2)) < 0) return Length(v2);\n\telse if (dcmp(Dot(v1, v3)) > 0) return Length(v3);\n\telse return fabs(Cross(v1, v2)) / Length(v1);\n}\nPoint GetLineProjection(Point P, Point A, Point B) {\n\tVector v = B - A;\n\treturn A = v * (Dot(v, P - A) / Dot(v, v));\n}\nbool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) {\n\tdouble c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n\treturn dcmp(c1) * dcmp(c2) < 0 && dcmp(c3) * dcmp(c4) < 0;\n}\nbool OnSegment(Point p, Point a1, Point a2) {\n\treturn dcmp(Cross(a1 - p, a2 - p)) == 0 && dcmp(Dot(a1 - p, a2 - p)) <= 0;\n}\n//polygon\ndouble ConvexPolygonArea(Point* p, int n) {\n\tdouble area = 0;\n\tfor (int i = 1; i < n - 1; i++)\n\t\tarea = Cross(p[i] - p[0], p[i + 1] - p[0]);\n\treturn area / 2;\n}\n//circle\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c, double r) :c(c), r(r) {}\n\tPoint point(double a) { return Point(c.x + cos(a) * r, c.y + sin(a) * r); }\n};\nint getLineCircleIntersection(Line L, Circle C, double& t1, double& t2, vector<Point>& sol) {\n\tdouble a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;\n\tdouble e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r;\n\tdouble delta = f * f - 4 * e * g;\n\tif (dcmp(delta) < 0)\n\t\treturn 0;\n\tif (dcmp(delta) == 0) {\n\t\tt1 = t2 = -f / (2 * e);\n\t\tsol.push_back(L.point(t1));\n\t\treturn 1;\n\t}\n\tt1 = (-f - sqrt(delta)) / (2 * e);\n\tsol.push_back(L.point(t1));\n\tt2 = (-f + sqrt(delta)) / (2 * e);\n\tsol.push_back(L.point(t2));\n\treturn 2;\n}\n\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint q;\n\tPoint A, B, O, E, F;\n\tvector<Point> sol;\n\tdouble r, t1, t2;\n\tscanf(\"%lf%lf%lf\", &O.x, &O.y, &r);\n\tCircle C(O, r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%lf%lf%lf%lf\", &A.x, &A.y, &B.x, &B.y);\n\t\tif (getLineCircleIntersection(Line(A, B - A), C, t1, t2, sol) == 1)\n\t\t\tE = F = A + (B - A) * t1;\n\t\telse {\n\t\t\tE = A + (B - A) * t1;\n\t\t\tF = A + (B - A) * t2;\n\t\t\tif (E.x > F.x || E.x == F.x && E.y > F.y) {\n\t\t\t\tswap(E.x, F.x);\n\t\t\t\tswap(E.y, F.y);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", E.x, E.y, F.x, F.y);\n\t}\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nclass Vec{\npublic:\n  double x, y;\n  Vec(double x = 0, double y = 0):x(x),y(y){}\n\n  Vec &read(){\n    cin >> x >> y;\n    return *this;\n  }\n\n  void print(){\n    printf(\"%.10lf %.10lf\\n\", x, y);\n  }\n\n  bool operator<(const Vec &other){\n    if(x < other.x)return true;\n    if(x == other.x && y < other.y)return true;\n    return false;\n  }\n  \n  Vec operator+(const Vec &other)\n  {\n    Vec result = *this;\n    result.x += other.x;\n    result.y += other.y;\n    return result;\n  }\n\n  Vec operator-(const Vec &other)\n  {\n    Vec result = *this;\n    result.x -= other.x;\n    result.y -= other.y;\n    return result;\n  }\n\n  Vec operator*(const double &k)\n  {\n    Vec result = *this;\n    result.x *= k;\n    result.y *= k;\n    return result;\n  }\n\n  Vec operator/(const double &k)\n  {\n    Vec result = *this;\n    result.x /= k;\n    result.y /= k;\n    return result;\n  } \n  \n  double cross(const Vec &other)\n  {\n    return x*other.y - y*other.x;\n  }\n\n  double dot(const Vec &other){\n    return x*other.x + y*other.y;\n  }\n  \n  bool operator==(const Vec &other) const\n  {\n    return abs(x - other.x) < EPS && abs(y - other.y) < EPS;\n  }\n\n  double norm()\n  {\n    return sqrt(x*x+y*y);\n  }\n\n  double norm2()\n  {\n    return x*x+y*y;\n  }\n\n  Vec standard(){\n    Vec result = *this;\n    return result/result.norm();\n  }\n};\n\n//cw:1, ccw:-1, other:0\nInt CCW(Vec a, Vec b, Vec c){\n  b = b - a;\n  c = c - a;\n  if(b.cross(c) > EPS)return -1;\n  if(b.cross(c) < -EPS)return 1;\n  return 0;\n}\n\ndouble dist(Vec a, Vec b){\n  return (a-b).norm();\n}\n\nclass Line{\npublic:\n  Vec a, b;\n  Vec vect;\n  Line(Vec a = Vec(), Vec b = Vec()):a(a),b(b),vect(b-a){}\n\n  //projection\n  Vec proj(Vec p){\n    p = p - a;\n    return a + vect * vect.dot(p) / vect.norm2();\n  }\n\n  //reflection\n  Vec reflect(Vec p){\n    return proj(p) * 2 - p;\n  }\n\n  bool onSegment(Vec p){\n    return abs((p-a).cross(b-a)) < EPS && (p-a).dot(p-b) < EPS;\n  }\n\n  //other -> LineSegment(not inclusive), this -> Line\n  bool _intersect(Line other){\n    return CCW(a, b, other.a) * CCW(a, b, other.b) < 0;\n  }\n\n  //other, this: both are LineSegment(inclusive)\n  bool intersect(Line other){\n    return onSegment(other.a) || onSegment(other.b) || other.onSegment(a) || other.onSegment(b) || _intersect(other) && other._intersect(*this);\n  }\n\n  //low accuracy\n  Vec crossPoint(Line &other){\n    double ratio = (a - other.a).cross(vect) / other.vect.cross(vect);\n    return other.a + other.vect * ratio;\n  }\n\n  double dist(Vec p){\n    Vec pp = proj(p);\n    if(onSegment(pp))return ::dist(p, pp);\n    else return min(::dist(p, a), ::dist(p, b));\n  }\n  \n  double dist(Line &other){\n    if(intersect(other))return 0;\n    return min(min(dist(other.a), dist(other.b)), min(other.dist(a), other.dist(b)));\n  }\n};\n\n\n\nint main(){\n  Vec c, p1, p2;\n  double r;\n  c.read();cin >> r;\n  Int q;\n  cin >> q;\n  while(q--){\n    p1.read();\n    p2.read();\n    Line l(p1, p2);\n    Vec h = l.proj(c);\n    double v = sqrt(r * r - (h-c).norm2());\n    Vec ans1 = h + l.vect.standard() * v;\n    Vec ans2 = h - l.vect.standard() * v;\n    if(!(ans1.x < ans2.x || ans1.x == ans2.x && ans1.y < ans2.y))swap(ans1, ans2);\n    printf(\"%.10lf %.10lf %.10lf %.10lf\\n\", ans1.x, ans1.y, ans2.x, ans2.y);\n  }\n  \n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(v) v.begin(), v.end()\ntypedef long long ll;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n// cout<<fixed<<setprecision(15)\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\n//点またはベクトル\nclass Point{\n  public:\n  double x,y;\n  \n  Point(double x=0, double y=0): x(x),y(y) {}\n  \n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){return Point(x-p.x,y-p.y);}\n  Point operator*(double a){return Point(a*x,a*y);}\n  Point operator/(double a){return Point(x/a,y/a);}\n  \n  bool operator<(const Point &p) const{\n    return x != p.x ? x<p.x : y<p.y;\n  }\n  \n  bool operator==(const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\ntypedef Point Vector;\n//ベクトルの二乗和と絶対値\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\ndouble abs(Point p){return sqrt(norm(p));}\n//線分または直線\nstruct Segment{Point p1,p2;};\ntypedef Segment Line;\n//円\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(), double r=0.0): c(c), r(r) {}\n};\n//多角形\ntypedef vector<Point> Polygon;\n//内積\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\n//外積\ndouble cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\n//直交判定\nbool isOrthgonal(Vector a,Vector b){return equals(dot(a,b), 0.0);}\n//平行判定\nbool isParallel(Vector a,Vector b){return equals(cross(a,b), 0.0);}\n//射影\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n//反射\nPoint reflect(Segment s,Point p){return p+(project(s,p)-p)*2.0;}\n//反時計周りCounter-Clockwise\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS) return CLOCKWISE;\n  if(dot(a,b)<-EPS) return ONLINE_BACK;\n  if(norm(a)<norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//線分の交差判定\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2){return intersect(s1.p1,s1.p2,s2.p1,s2.p2);}\n//点と点の距離\ndouble getDisPP(Point a,Point b){return abs(a-b);}\n//直線と点の距離\ndouble getDisLP(Line l,Point p){return abs(cross(l.p2-l.p1,p-l.p1))/abs(l.p2-l.p1);}\n//線分と点の距離\ndouble getDisSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n  return getDisLP(s,p);\n}\n//線分と線分の距離\ndouble getDisSS(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDisSP(s1,s2.p1),getDisSP(s1,s2.p2)),\n             min(getDisSP(s2,s1.p1),getDisSP(s2,s1.p2)));\n}\n//線分と線分の交点\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base =s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//円と直線の交点\npair<Point,Point> getCrossPoint(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\nint main(){\n  double cx,cy,r;\n  cin>>cx>>cy>>r;\n  Circle c;\n  c.c.x=cx,c.c.y=cy,c.r=r;\n  \n  int q;\n  cin>>q;\n  \n  rep(i,q){\n    double x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    Line l;\n    Point p1,p2;\n    p1.x=x1,p1.y=y1,p2.x=x2,p2.y=y2;\n    l.p1=p1,l.p2=p2;\n    pair<Point,Point> p;\n    Point p3,p4;\n    p=getCrossPoint(c,l);\n    p3=p.first,p4=p.second;\n    if(p3.x<p4.x) cout<<fixed<<setprecision(7)<<p3.x<<\" \"<<p3.y<<\" \"<<p4.x<<\" \"<<p4.y<<endl;\n    else if(p3.x==p4.x && p3.y<p4.y) cout<<fixed<<setprecision(7)<<p3.x<<\" \"<<p3.y<<\" \"<<p4.x<<\" \"<<p4.y<<endl;\n    else cout<<fixed<<setprecision(7)<<p4.x<<\" \"<<p4.y<<\" \"<<p3.x<<\" \"<<p3.y<<endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double              lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\npt operator / ( const pt& A, const lf& B ) {\n  return { x(A)/B, y(A)/B };\n}\n\ninline lf dot( pt A, pt B ) {\n  return x(A)*x(B) + y(A)*y(B);\n}\n\ninline lf cross( pt A, pt B ) {\n  return x(A)*y(B) - y(A)*x(B);\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline bool samePt ( pt A, pt B ) {\n  return same ( x(A), x(B) ) && same ( y(A), y(B) );\n}\n\nlf distToLine (pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  c = A + u*( B-A );\n  return dist( p , c );\n}\n\nbool circleLineIntersection( pt c, lf r, pt A, pt B, pt &p1, pt &p2 ) {\n  pt t;\n  lf u = distToLine( c, A, B, t );\n  if( u > r+EPS ) {\n    return false;\n  }\n  pt v = (B-A)/abs(B-A);\n  lf d = sqrt(r*r - u*u);\n  p1 = t + d*v;\n  p2 = t - d*v;\n  return true;\n}\n\nint q;\npt c, p1, p2;\nlf r;\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision(8);\n  cin >> c >> r >> q;\n  for( int i = 0; i < q; ++i ) {\n    pt A,B; cin >> A >> B;\n    if( circleLineIntersection( c, r, A, B, p1, p2 ) ) {\n      if( same( p1.x, p2.x ) ) {\n        if( p1.y > p2.y+EPS ) {\n          swap( p1,p2 );\n        }\n      }\n      if( p1.x > p2.x+EPS ) {\n        swap( p1,p2 );\n      }\n      cout << p1 << \" \" << p2 << '\\n';\n    }\n    else {\n      assert( false );\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\nusing Point = complex< double >;\n\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() {}\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(double A, double B, double C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() {}\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() {}\n\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\ndouble cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ndouble distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\ndouble distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point hp = projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return {hp - v, hp + v};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nbool merge_if_able(Segment &s1, Segment s2) {\n  if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid merge_segments(vector< Segment > &segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon convex_cut(Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble area2(const Polygon &p) {\n  double A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble convex_diameter(Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\ndouble closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n\n  function< double(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return 1e18;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n\nint main() {\n  Circle c;\n  cin >> c.p >> c.r;\n  int Q;\n  cin >> Q;\n  while(Q--) {\n    Line l;\n    cin >> l;\n    auto p = crosspoint(c, l);\n    auto q = minmax(p.first, p.second);\n    cout << fixed << setprecision(10) << real(q.first) << \" \" << imag(q.first) << \" \" << real(q.second) << \" \" << imag(q.second) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<iomanip>\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point{\n\tpublic:\n\t\tdouble x, y;\n\n\t\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\t\tPoint operator + (Point p){ return Point(x + p.x, y + p.y);}\n\t\tPoint operator - (Point p){ return Point(x - p.x, y - p.y);}\n\t\tPoint operator * (double a){ return Point(a * x, a * y);}\n\t\tPoint operator / (double a){ return Point(x / a, y / a);}\n\n\t\tdouble abs(){ return sqrt(norm());}\n\t\tdouble norm(){ return x * x + y * y;}\n\n\t\tbool operator < (const Point &p) const{\n\t\t\treturn x != p.x ? x < p.x : y < p.y;\n\t\t}\n\n\t\tbool operator == (const Point &p) const{\n\t\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\ndouble getDistance(Point a, Point b){\n\treturn (a - b).abs();\n}\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\ndouble getDistanceSP(Segment s, Point p){\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2){\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\nint main(void){\n\tCircle c;\n\tint q;\n\tLine l;\n\tPoint p_1, p_2;\n\tcin >> c.c.x >> c.c.y >> c.r;\n\tcin >> q;\n\tfor(int i = 1; i <= q; i++){\n\t\tcin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n\t\tp_1 = getCrossPoints(c, l).first;\n\t\tp_2 = getCrossPoints(c, l).second;\n\t\tif(abs(p_1.x - p_2.x) < EPS){\n\t\t\tif(p_1.y < p_2.y) cout << fixed << setprecision(6) << p_1.x << \" \" << p_1.y << \" \" << p_2.x << \" \" << p_2.y << endl;\n\t\t\telse cout << fixed << setprecision(6) << p_2.x << \" \" << p_2.y << \" \" << p_1.x << \" \" << p_1.y << endl;\n\t\t}else{\n\t\t\tif(p_1.x < p_2.x) cout << fixed << setprecision(6) << p_1.x << \" \" << p_1.y << \" \" << p_2.x << \" \" << p_2.y << endl;\n\t\t\telse cout << fixed << setprecision(6) << p_2.x << \" \" << p_2.y << \" \" << p_1.x << \" \" << p_1.y << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define equals(a, b) (fabs((a) - (b)) < EPS )\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Point Vector;\ntypedef Segment Line;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/abs(base);\n  return s.p1+base*t;\n}\n\nPoint p;\ndouble r;\nSegment s;\n\nPoint rotate( Point a, double si,double co){\n  return Point(a.x*co-a.y*si,a.x*si+a.y*co);\n}\n\nvector<Point> solve(){\n  vector<Point> res;\n  Point q=project(s,p);\n  double d=sqrt(r*r-abs(p-q)*abs(p-q));\n  Vector base=s.p1-s.p2;\n  res.push_back(q+base*(d/abs(base)));\n  res.push_back(q-base*(d/abs(base)));\n  return res;\n}\n\nint main(){\n  cin>>p.x>>p.y>>r;\n  int tc;\n  cin>>tc;\n  for(int i=0;i<tc;i++){\n    cin>>s.p1.x>>s.p1.y>>s.p2.x>>s.p2.y;\n    vector<Point> t=solve();\n    printf(\"%.8f %.8f %.8f %.8f\\n\",t[0].x,t[0].y,t[1].x,t[1].y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nclass Vector\n{\npublic:\n  double x;\n  double y;\n\n  Vector(){}\n  Vector( double x, double y ) : x(x), y(y) {}\n\n  Vector operator + ( const Vector v ) { return Vector( x + v.x, y + v.y ); }\n  Vector operator - ( const Vector v ) { return Vector( x - v.x, y - v.y ); }\n  Vector operator * ( const double k ) { return Vector( x * k, y * k ); }\n  Vector operator / ( const double k ) { return Vector( x / k, y / k ); }\n  bool operator < ( const Vector &v ) const { return x * x + y * y < v.x * v.x + v.y * v.y; }\n\n  double abs() { return sqrt( norm() ); }\n  double norm() { return x * x + y * y; }\n\n  static double dot( Vector v1, Vector v2 ) { return v1.x * v2.x + v1.y * v2.y; }\n  static double cross( Vector v1, Vector v2 ) { return v1.x * v2.y - v1.y * v2.x; }\n\n  void print() { cout << fixed << setprecision(10) << x << \" \" << y << endl; }\n  static Vector projection( Vector ps, Vector pt, Vector p );\n};\n\nVector Vector::projection( Vector ps, Vector pt, Vector p )\n{\n  Vector a = pt - ps;\n  Vector b = p - ps;\n\n  return ps + a * dot( a, b ) / a.norm();\n}\n\nclass Circle\n{\npublic:\n  Vector cp;\n  double r;\n  Circle(){}\n  Circle( Vector cp, double r ) : cp(cp), r(r) {}\n};\n  \nclass CPCircleLine\n{\npublic:\n  Circle c;\n  CPCircleLine(){}\n  CPCircleLine( Circle c ) : c(c) {}\n  int solve( Vector p0, Vector p1 );\n  void print( Vector p0, Vector p1 );\n};\n\nint CPCircleLine::solve( Vector p0, Vector p1 )\n{\n  Vector pr = Vector::projection( p0, p1, c.cp );\n  Vector a = pr - c.cp;\n  double t = sqrt( c.r * c.r - a.norm() );\n  Vector p10 = p1 - p0;\n  Vector e = p10 / p10.abs();\n  print( pr + e * t, pr - e * t );\n  \n  return 0;\n}\n\nvoid CPCircleLine::print( Vector p0, Vector p1 )\n{\n  if ( p0.x < p1.x )\n    cout << fixed << setprecision(10) << p0.x << \" \" << p0.y << \" \" << p1.x << \" \" << p1.y << endl;\n  else if ( p0.x > p1.x )\n    cout << fixed << setprecision(10) << p1.x << \" \" << p1.y << \" \" << p0.x << \" \" << p0.y << endl;\n  else if ( p0.y < p1.y )\n    cout << fixed << setprecision(10) << p0.x << \" \" << p0.y << \" \" << p1.x << \" \" << p1.y << endl;\n  else\n    cout << fixed << setprecision(10) << p1.x << \" \" << p1.y << \" \" << p0.x << \" \" << p0.y << endl;\n}\n\nint main()\n{\n  double cx, cy, r;\n  cin >> cx >> cy >> r;\n  \n  CPCircleLine cpcl( Circle( Vector(cx, cy), r ));\n  \n  int q;\n  cin >> q;\n\n  for ( auto i = 0; i < q; ++i )\n    {\n      double x0, y0, x1, y1;\n      cin >> x0 >> y0 >> x1 >> y1;\n      \n      cpcl.solve( Vector(x0, y0), Vector(x1, y1) );\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\nconst double PI=acos(-1);\nconst double EPS=1e-10;\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nP inP(){\n  double x,y;\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\nvoid printL(const L &l){\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag()\n      << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nint main(){\n\n  C c = inC();\n\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; i++){\n    L l = inL();\n    printL(crosspointCL(c,l));\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); i++)\n#define pb push_back\n#define all(X) X.begin(), X.end()\n\n#define X real()\n#define Y imag()\n#define x(p) real(p)\n#define y(p) imag(p)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1)%P.size()]\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n\t\t\tcross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n// enum { OUT, ON, IN };\n// int contains(const G& pol, const P& p){\n// \tif(pol.size() < 2) return OUT;\n// \tif(intersectSP({pol[0], pol[1]}, p)) return ON;\n// \tbool f = cross(pol[1]-pol[0], p - pol[0]) > 0;\n// \tfor(int i = 1; i < pol.size(); i++) {\n// \t\tauto& now = curr(pol, i);\n// \t\tauto& nxt = next(pol, i);\n// \t\tif(intersectSP({nxt, now}, p)) return ON;\n// \t\tif(f^(cross(nxt-now, p-now)>0)) return OUT;\n// \t}\n// \treturn IN;\n// }\n//??????????§???¢?????????????????????(polygon??????????¨???????)\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\nbool contains(const polygon& a, const polygon& b) {\n\trep(i, a.size()) if(contains(b, a[i]) == OUT) return false;\n\treturn true;\n}\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT, HIT, A_IN_B, B_IN_A};\nint isHit(const polygon& a, const polygon& b){\n\tif(contains(a, b)) return A_IN_B;\n\tif(contains(b, a)) return B_IN_A;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n\n//point???theta???????????¢\npoint spinP(const point& p, double theta, double ext = 1.0) {\n\treturn p*P(cos(theta),sin(theta))*ext;\n}\n\npoint makeP(double r, double arg) {return P(r*cos(arg), r*sin(arg));}\n\n//?????¨????????????????±???????\nvector<P> crossPoint(const C& a, const C& b){\n\tdouble d = abs(b.p-a.p);\n\tdouble arg = atan2(y(b.p-a.p), x(b.p-a.p));\n\tdouble arg2 = acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r));\n\tif(abs(arg2)<EPS) return {a.r*makeP(1.0, arg)+a.p};\n\tif(abs(a.r-b.r)<d && d < a.r+b.r) return {a.r*makeP(1.0, arg+arg2)+a.p, a.r*makeP(1.0, arg-arg2)+a.p};\n\treturn {};\n}\n\n//????????±?????\\???\nvector<L> comonTang(C c1, C c2) {\n\tvector<L> ret;\n\tif(c1.r > c2.r) swap(c1, c2);\n\tP sub = c1.p;\n\tc1.p -= sub;\n\tc2.p -= sub;\n\tdouble theta = atan2(c2.p.Y, c2.p.X);\n\n\tc2.p = spinP(c2.p, -theta);\n\tint signX = 0;\n\tif(c2.p.X > 0) signX = 1;\n\tif(c2.p.X < 0) signX = -1;\n\n\tdouble x = abs(c2.p.X), r1 = c1.r, r2 = c2.r;\n\tif(abs(x*x -(r2 - r1) * (r2 - r1))<EPS) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t}\n\telse if(x*x > (r2 - r1) * (r2 - r1)) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t\tret.pb({spinP({0, -r1}, -theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), -r1}, -theta2)});\n\t}\n\tif(abs(r1+r2-x)<EPS) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t}\n\telse if(x > r1+r2) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t\tret.pb({spinP({0, -r1}, -theta3), spinP({len, -r1}, theta3)});\n\t}\n\n\tfor(auto& l : ret) {\n\t\tif(signX == -1) l[1] = {-l[1].X, l[1].Y};\n\t\tl[0] = spinP(l[0], theta);\n\t\tl[1] = spinP(l[1], theta);\n\t\tl[0] += sub;\n\t\tl[1] += sub;\n\t}\n\treturn ret;\n}\n\ndouble getArea(const polygon& pol) {\n\tint n = pol.size();\n\tdouble s = 0.0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint now = i, nxt = (i + 1) % n;\n\t\ts += (pol[now].X - pol[nxt].X) * (pol[now].Y + pol[nxt].Y);\n\t}\n\treturn abs(s/2.0);\n}\n\n//?????? - convex hull\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n  \tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n  \t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  \tfor (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n  \t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  \tch.resize(k-1);\n  \treturn ch;\n}\n//???????¨??????????polygon????????????????????????\t\t\tCGL_3_B\nbool isHull(const G& g) {\n\tint n = g.size();\n\tif(n < 3) return false;\n\trep(i, n) if(ccw(prev(g, i), curr(g, i), next(g, i)) == -1) return false;\n\treturn true;\n}\nbool contains(const P& p, const C& c) {\n\treturn abs(p-c.p) < c.r+EPS;\n}\nint posRel(const L&s, const C&c){\n\tif(abs(distanceSP(s,c.p)-c.r)<EPS)\treturn 1;\t//??\\?????????\n\tif(distanceSP(s,c.p) > c.r+EPS) \treturn 0;\t//????????£????????????\n\tif(contains(s[0], c) && contains(s[1], c))\treturn 2;\t//????????????\n\tif(contains(s[0], c)||contains(s[1], c))\treturn 3;\t//?????´???????????????\n\treturn 4;\t//????????????\n}\nvector<P> crossPoint(C c, L l) {\n\tint hit = posRel(l, c);\n\tif(hit == 0) return {};\n\t\n\tdouble R = c.r;\n\tP sub = c.p;\n\tdouble theta;\n\n\tl[0] -= sub;\n\tl[1] -= sub;\n\n\ttheta = atan2(imag(l[1]-l[0]), real(l[1]-l[0]));\n\n\tl[0] = spinP(l[0], -theta);\n\tl[1] = spinP(l[1], -theta);\n\n\tassert(abs(imag(l[0]-l[1])) < EPS);\n\n\tvector<P> ret;\n\tif(abs(abs(l[0].Y) - R) < EPS) ret.pb({0.0, l[0].Y});\n\telse {\n\t\tdouble y = l[0].Y;\n\t\tdouble x = sqrt(R*R-y*y);\n\t\tret.pb({x, y});\n\t\tret.pb({-x, y});\n\t}\n\n\trep(i, ret.size()) {\n\t\tret[i] = spinP(ret[i], theta);\n\t\tret[i] += sub;\n\t}\n\trep(i, ret.size()) {\n\t\tif(abs(ret[i].X) < EPS) ret[i] = {0.0, ret[i].Y};\n\t}\n\treturn ret;\n}\n\nint main() {\n\tdouble x, y, r;\n\tcin >> x >> y >> r;\n\tC c({x, y}, r);\n\tint q;\n\tcin >> q;\n\trep(i, q) {\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tL l({x1, y1}, {x2, y2});\n\t\tvector<P> a = crossPoint(c, l);\n\t\tif(a.size() == 1) a.pb(a[0]);\n\t\tsort(all(a));\n\t\tprintf(\"%.15lf %.15lf %.15lf %.15lf\\n\", a[0].X, a[0].Y, a[1].X, a[1].Y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\nstruct point{\n    int x,y;\n};\n\nstruct line{\n    point s,t;\n};\nstruct bec{\n    int x,y;\n};\nstruct circle{\n    point p;\n    int r;\n};\n\n\n\nvoid solve(circle o, line l){\n    double d;\n    bec p1p,p1p2;\n    p1p.x=o.p.x-l.s.x; p1p.y=o.p.y-l.s.y;\n    p1p2.x=l.t.x-l.s.x; p1p2.y=l.t.y-l.s.y;\n    double c,dp,dp2,k,ansx,ansy;\n    dp=sqrt((double)p1p.x*(double)p1p.x+(double)p1p.y*(double)p1p.y);\n    if(dp==0) d=0;\n\n    dp2=sqrt((double)p1p2.x*(double)p1p2.x+(double)p1p2.y*(double)p1p2.y);\n    c=((double)p1p.x*(double)p1p2.x+(double)p1p.y*(double)p1p2.y)/(dp*dp2);\n    k=dp*c;\n    ansx=l.s.x+k*(p1p2.x/dp2);\n    ansy=l.s.y+k*(p1p2.y/dp2);\n    d = sqrt((o.p.x-ansx)*(o.p.x-ansx)+(o.p.y-ansy)*(o.p.y-ansy));\n    \n    \n    double co = sqrt(1-(d/o.r)*(d/o.r));\n    double ansx1,ansx2,ansy1,ansy2;\n\n\n    ansx1 = ansx-(o.r*co)*(p1p2.x/dp2);\n    ansx2 = ansx+(o.r*co)*(p1p2.x/dp2);\n    ansy1 = ansy-(o.r*co)*(p1p2.y/dp2);\n    ansy2 = ansy+(o.r*co)*(p1p2.y/dp2);\n    if(ansx1<ansx2) printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n    else if(ansx1==ansx2){\n        if(ansy1<ansy2) printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n        else printf(\"%.8f %.8f %.8f %.8f\\n\",ansx2,ansy2,ansx1,ansy1);\n    }\n    else printf(\"%.8f %.8f %.8f %.8f\\n\",ansx2,ansy2,ansx1,ansy1);\n}\n\nint main(){\n    int cx,cy,x1,x2,y1,y2,n,r;\n    point p,s,t;\n    line l;\n    circle o;\n\n    cin>>cx>>cy>>r;\n    p.x=cx;\n    p.y=cy;\n    o.p=p; o.r=r;\n\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>x1>>y1>>x2>>y2;\n        s.x=x1; s.y=y1;\n        t.x=x2; t.y=y2;\n        l.s=s; l.t=t;\n        solve(o,l);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\n//bool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n\n    Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n\n    Point operator*(double a) { return Point(a * x, a * y); }\n\n    Point operator/(double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n\n    double norm() { return x * x + y * y; }\n\n    bool operator<(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\n\ndouble norm(Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nPolygon f(Polygon g) {\n    Polygon u, l;\n    if (g.size() < 3) return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size() - 1]);\n    l.push_back(g[g.size() - 2]);\n\n    // upper\n    for (int i = 2; i < g.size(); i++) {\n        for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], g[i]) == COUNTER_CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for (int i = g.size() - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], g[i]) == COUNTER_CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\n\ndouble abs(Point a) {\n    return sqrt(norm(a));\n}\n\n\ndouble getDistance(Point a, Point b) {\n    return abs(a - b);\n}\n\n\ndouble convexDiameter(Polygon g) {\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; i++) {\n        if (g[i].y > g[is].y) is = i;\n        if (g[i].y < g[js].y) js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do {\n        if (cross(g[(i + 1) % n] - g[i], g[(j + 1) % n] - g[j]) >= 0.0) j = (j + 1) % n;\n        else i = (i + 1) % n;\n        if (getDistance(g[i], g[j]) > d) {\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    } while (i != is || j != js);\n\n    return d;\n}\n\nstruct Segment {\n    Point p1, p2;\n\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\nPolygon andrewScan(Polygon g) {\n    Polygon u, l;\n    if (g.size() < 3) return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size() - 1]);\n    l.push_back(g[g.size() - 2]);\n\n    // upper\n    for (int i = 2; i < g.size(); i++) {\n        for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], g[i]) != CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for (int i = g.size() - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], g[i]) != CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\n\ndouble area(Polygon g) {\n    if (g.size() < 3) return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for (int i = 0; i < n; i++) s += cross(g[i] - o, g[(i + 1) % n] - o);\n    return abs(s) / 2.0;\n}\n\nconst double INF = 1e10;\n\ntypedef pair<double, double> p;\np v[100000];\n\nbool comp_y(p a, p b) {\n    return a.second < b.second;\n}\n\ndouble closest_pair(p *a, int n) {\n    if (n <= 1) return INF;\n\n    int m = n / 2;\n    double x = a[m].first;\n    double d = min(closest_pair(a, m), closest_pair(a + m, n - m)); // x軸で区切られた範囲内での頂点対のみ考慮\n    inplace_merge(a, a + m, a + n, comp_y); // ソート済みの[a, a+m)と[a+m, a+n)をy座標基準でマージ\n\n    vector<p> b; // 直線 x = a[m].firstから距離d未満の点を入れる\n    for (int i = 0; i < n; i++) {\n        if (fabs(a[i].first - x) >= d) continue; // そもそもx座標の差がd以上の点は論外\n\n        // bに入っている頂点を末尾から、y座標の差がd以上になるまで見ていく\n        // y座標降順で見ていき、d以上離れた時点で打ち切り\n        for (int j = 0; j < b.size(); j++) {\n            double dx = a[i].first - b[b.size() - 1 - j].first;\n            double dy = a[i].second - b[b.size() - 1 - j].second;\n            if (dy >= d) break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\n\nstruct STsum {\nprivate:\n    int n;\n    vector<int> dat;\npublic:\n    STsum(int siz) {\n        n = 1;\n        while (n < siz) n *= 2;\n        dat.resize(2 * n - 1, 0);\n    }\n\n    void update(int x, int val) {\n        x += (n - 1);\n        dat[x] += val;\n        while (x > 0) {\n            x = (x - 1) / 2;\n            dat[x] = dat[2 * x + 1] + dat[2 * x + 2];\n        }\n    }\n\n    // focus on k-th node, who controls [l, r)\n    int query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        if (r <= a || b <= l) return 0;\n        if (a <= l && r <= b) return dat[k];\n\n        int lx = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int rx = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return lx + rx;\n    }\n};\n\nstruct Circle {\n    Point c;\n    double r;\n\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n    double x, y, r;\n    cin >> x >> y >> r;\n    Circle C(Point(x, y), r);\n\n    int q;\n    cin >> q;\n\n    while (q-- > 0) {\n        double a, b, c, d;\n        cin >> a >> b >> c >> d;\n        pair<Point, Point> p = getCrossPoints(C, Line(Point(a, b), Point(c, d)));\n        if (p.second < p.first) swap(p.first, p.second);\n        cout << fixed << setprecision(12) << p.first.x << \" \" << p.first.y << \" \" << p.second.x << \" \" << p.second.y\n             << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(v) v.begin(), v.end()\n#define Graph vector< vector<int> >\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1000000007;\n\nconst double EPS = 1e-10;\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point{\n    double x, y;\n    Point(){}\n    Point(double x0, double y0){\n        x = x0; y = y0;\n    }\n\n    Point operator +(const Point &p){\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator -(const Point &p){\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator *(const double &a){\n        return Point(a * x, a * y);\n    }\n    Point operator /(const double &a){\n        return Point(x / a, y / a);\n    }\n\n    bool operator == (const Point &p){\n        return equals(x, p.x) && equals(y, p.y);\n    }\n\n    bool operator < (const Point &p){\n        return x != p.x ? x < p.x : y < p.y ;\n    }\n\n};\n\ndouble norm(Point p){\n    return p.x * p.x + p.y * p.y;\n}\n\ndouble v_abs(Point p){\n    return sqrt(norm(p));\n}\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c0, double r0){\n        c.x = c0.x;\n        c.y = c0.y;\n        r = r0;\n    }\n    Circle(double x0, double y0, double r0){\n        c.x = x0;\n        c.y = y0;\n        r = r0;\n    }\n};\n\nint main(){\n    Circle C;\n    cin >> C.c.x >> C.c.y >> C.r;\n    int Q;\n    cin >> Q;\n    rep(i, Q){\n        Point p1, p2;\n        cin >> p1.x >> p1.y;\n        cin >> p2.x >> p2.y;\n        Vector a = p2 - p1, b = C.c - p1;\n        double s = dot(a, b)/norm(a);\n        double t = abs(cross(a, b))/v_abs(a);\n        double u = sqrt(C.r * C.r - t * t) / v_abs(a);\n        Point m = p1 + a * s;\n        vector<Point> P;\n        P.push_back(m - a * u);\n        P.push_back(m + a * u);\n        sort(all(P));\n        \n        printf(\"%.10lf %.10lf \", P[0].x, P[0].y);\n        printf(\"%.10lf %.10lf\\n\", P[1].x, P[1].y);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Point Vector;\ntypedef Segment Line;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\n \nPoint p;\ndouble r;\nSegment s;\n \nPoint rotate( Point a, double si,double co){\n  return Point(a.x*co-a.y*si,a.x*si+a.y*co);\n}\n \nvector<Point> solve(){\n  vector<Point> res;\n  Point q=project(s,p);\n  double d=sqrt(r*r-abs(p-q)*abs(p-q));\n  Vector base=s.p1-s.p2;\n  res.push_back(q+base*(d/abs(base)));\n  res.push_back(q-base*(d/abs(base)));\n  return res;\n}\n \nint main(){\n  cin>>p.x>>p.y>>r;\n  int tc;\n  cin>>tc;\n  for(int i=0;i<tc;i++){\n    cin>>s.p1.x>>s.p1.y>>s.p2.x>>s.p2.y;\n    vector<Point> t=solve();\nsort(t.begin(),t.end());\n    printf(\"%.8f %.8f %.8f %.8f\\n\",t[0].x,t[0].y,t[1].x,t[1].y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nstatic constexpr int CONTAIN = 0;\nstatic constexpr int INSCRIBE = 1;\nstatic constexpr int INTERSECT = 2;\nstatic constexpr int CIRCUMSCRIBED = 3;\nstatic constexpr int SEPARATE = 4;\n\nint intersect(Circle c1, Circle c2){\n    if(c1.r < c2.r) swap(c1, c2);\n    real d = abs(c1.c-c2.c);\n    real r = c1.r + c2.r;\n    if(fabs(d-r) < EPS) return CIRCUMSCRIBED;\n    if(d > r) return SEPARATE;\n    if(fabs(d+c2.r-c1.r) < EPS) return INSCRIBE;\n    if(d+c2.r < c1.r) return CONTAIN;\n    return INTERSECT;\n}\n\nreal distance(Line l, Point c){\n    return abs(cross(l.b-l.a, c-l.a)/abs(l.b-l.a));\n}\n\n\nreal distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\nreal distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\nPoint project(Line l, Point p){\n    Point Q = l.b-l.a;\n    return l.a + Q*(dot(p-l.a, Q) / dot(Q, Q));\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPolygon crossPoint(Circle c, Line l){\n    Point p = project(l, c.c), q = (l.b-l.a)/abs(l.b-l.a);\n    if(abs(distance(l, c.c)-c.r) < EPS){\n        return {p};\n    }\n    double k = sqrt(c.r*c.r-dot(p-c.c, p-c.c));\n    return {p+q*k, p-q*k};\n}\n\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nbool isconvex(Polygon v){\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        if(ccw(v[(i+n-1)%n], v[i], v[(i+1)%n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint contains(Polygon v, Point p){\n    int n = v.size();\n    bool x = false;\n    static constexpr int IN = 2;\n    static constexpr int ON = 1;\n    static constexpr int OUT = 0;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?IN:OUT);\n}\n\nreal diameter(Polygon v){\n    int n = v.size();\n    if(n == 2) return abs(v[0]-v[1]);\n    int i = 0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if(v[i] < v[k]) i = k;\n        if(!(v[j] < v[k])) j = k;\n    }\n    real ret = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        ret = max(ret, abs(v[i]-v[j]));\n        if(cross(v[(i+1)%n]-v[i], v[(j+1)%n]-v[j]) < 0.0) i = (i+1)%n;\n        else j = (j+1)%n;\n    }\n    return ret;\n}\n\nPolygon convexCut(Polygon v, Line l){\n    Polygon q;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i], b = v[(i+1)%n];\n        if(ccw(l.a, l.b, a) != -1) q.push_back(a);\n        if(ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0){\n            q.push_back(crossPoint(Line(a, b), l));\n        }\n    }\n    return q;\n}\n\nreal closest_pair(Polygon &v, int l = 0, int r = -1){\n    if(!(~r)){\n        r = v.size();\n        sort(v.begin(),v.end());\n    }\n    if(r - l < 2) {\n        return abs(v.front()-v.back());\n    }\n    int mid = (l+r)/2;\n    real p = v[mid].x;\n    real d = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, sorty);\n    Polygon u;\n    for (int i = l; i < r; ++i) {\n        if(fabs(v[i].x-p) >= d) continue;\n        for (int j = 0; j < u.size(); ++j) {\n            real dy = v[i].y-next(u.rbegin(), j)->y;\n            if(dy >= d) break;\n            d = min(d, abs(v[i]-*next(u.rbegin(), j)));\n        }\n        u.emplace_back(v[i]);\n    }\n    return d;\n}\n\nint main() {\n    Point a; real b;\n    cin >> a >> b;\n    Circle c(a, b);\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        Point A, B;\n        cin >> A >> B;\n        Line l(A, B);\n        auto ret = crossPoint(c, l);\n        sort(ret.begin(),ret.end());\n        printf(\"%.10f %.10f %.10f %.10f\\n\", ret.front().x, ret.front().y, ret.back().x, ret.back().y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // ????????\\???\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // ????????????????????????\nld dot(Point a, Point b) { return real(conj(a) * b); } // ??????\nld cross(Point a, Point b) { return imag(conj(a) * b); } // ??????\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t // ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n/* ???????????? */\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// ????????´????????????\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// ?????????????????????\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* ?????¢ */\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tCircle c; c.p = input_point(); cin >> c.r;\n\tint q; cin >> q;\n\tfor (int i = 0; i < q;i++) {\n\t\tcout << fixed << setprecision(10);\n\t\tLine l(input_point(), input_point());\n\t\tauto ps = is_lc(c, l);\n\t\tsort(ps.begin(), ps.end());\n\t\tfor (int i = 0; i < 2;i++) {\n\t\t\tcout << ps[i].real() << \" \" << ps[i].imag();\n\t\t\tif (i == 0) cout << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X)\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nnamespace Geometry{\n  #define EPS (1e-10)\n  #define equals(a,b) (fabs((a)-(b)) < EPS)\n\n  class Point{\n  public:\n    double x,y;\n\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n\n    bool operator < (const Point &p) const{\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n      return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS);\n    }\n\n    friend ostream& operator << (ostream &os,Point &p){\n      return os << p.x << \" \" << p.y;\n    }\n\n    friend istream& operator >> (istream &is,Point &p){\n      return is >> p.x >> p.y;\n    }\n  };\n  typedef Point Vector;\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &p){\n      return os << p.p1.x << \" \" << p.p1.y << \" \" << p.p2.x << \" \" << p.p2.y;\n    }\n\n    friend istream& operator >> (istream &is,Segment &p){\n      return is >> p.p1.x >> p.p1.y >> p.p2.x >> p.p2.y;\n    }\n  };\n  typedef Segment Line;\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){\n      return os << c.c.x << c.c.y << c.r;\n    }\n\n    friend istream& operator >> (istream &is,Circle &c){\n      return is >> c.c.x >> c.c.y >> c.r;\n    }\n  };\n\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){\n    return  a.x * a.x + a.y * a.y;\n  }\n\n  double abs(Vector a){\n    return sqrt(norm(a));\n  }\n\n  double dot(Vector a,Vector b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  double cross(Vector a,Vector b){\n    return a.x * b.y - a.y * b.x;\n  }\n\n  bool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n  }\n\n  bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1 - a1,b1 - b2);\n  }\n\n  bool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0);\n  }\n\n  bool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n  }\n\n  bool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1 - a2 , b1 - b2);\n  }\n\n  bool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n  }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base / norm(base));\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n\n  int ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n\n  bool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n  }\n\n  double getDistance(Vector a,Vector b){\n    return abs(a - b);\n  }\n\n  double getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1));\n  }\n\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n              min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    // cassert(intersect(c,l));\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){\n    return atan2(p.y,p.x);\n  }\n\n  Vector polar(double a,double r){\n    return Point(cos(r) * a, sin(r) * a);\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    // assert(intersect(c1,c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n\n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y < b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  Polygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0;i--){\n      for(int n = l.size();n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--)l.push_back(u[i]);\n    return l;\n  }\n\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  Circle c;\n  Line a;\n  cin >> c;\n  cin >> n;\n  while(n--){\n    cin >> a;\n    pair<Point,Point> ans = getCrossPoints(c,a);\n    if(ans.first.x < ans.second.x)fprints(8,ans.first,ans.second);\n    else if(ans.first.x == ans.second.y){\n      if(ans.first.y < ans.second.y)fprints(8,ans.first,ans.second);\n      else fprints(8,ans.second,ans.first);\n    }else{\n      fprints(8,ans.second,ans.first);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i = (a); i < (b); ++i)\n#define per(i, a, b) for(int i = (b) - 1; i >= (a); --i)\n#define sz(a) (int)a.size()\n#define de(c) cout << #c << \" = \" << c << endl\n#define dd(c) cout << #c << \" = \" << c << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef db T;\nconst db eps = 1e-9 , pi = acosl(-1.);\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n  T x,y; P(){} P(T x,T y):x(x),y(y){}\n  P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n  P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n  T operator * (const P&b) const {return x*b.x+y*b.y;}\n  T operator / (const P&b) const {return x*b.y-y*b.x;}\n  P operator * (const T&k) const {return P(x*k,y*k);}\n  P operator / (const T&k) const {return P(x/k,y/k);}\n\tbool operator < (const P&b) const {return sgn(x-b.x)?x<b.x:y<b.y;}\n\tbool operator == (const P&b) const{return !sgn(x-b.x)&&!sgn(y-b.y);}\n\tP rot90(){return P(-y,x);}\n};\nT norm(P a){return a*a;}\nT abs(P a) {return sqrtl(norm(a));}\nP proj(P p,P a,P b){return (b-a)*((p-a)*(b-a)/norm(b-a))+a;}\nP reflect(P p,P a,P b){return proj(p,a,b)*2-p;}\nT cross(P o,P a,P b){return (a-o)/(b-o);}\nint crossOp(P o,P a,P b){return sgn(cross(o,a,b));}\nbool onPS(P p,P s,P t){return sgn((t-s)/(p-s))==0&&sgn((p-s)*(p-t))<=0;}\nstruct L{ P s,t;L(){} L(P s,P t):s(s),t(t){}};\nP insLL(L a,L b){ // line x line\n\tP s = a.s - b.s , v = a.t - a.s , w = b.t - b.s;\n\tdb k1 = s / w , k2 = w / v;\n\tif(sgn(k2) == 0) return abs(b.s - a.s) < abs(b.t - a.s) ? b.s : b.t;\n\treturn a.s + v * (k1 / k2);\n}\nbool isSS(L a,L b){ // seg x seg , replace x->y to accelerate\n\tT c1=(a.t-a.s)/(b.s-a.s),c2=(a.t-a.s)/(b.t-a.s);\n\tT c3=(b.t-b.s)/(a.s-b.s),c4=(b.t-b.s)/(a.t-b.s);\n\treturn sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n\t\tsgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n\t\tsgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n\t\tsgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n\t\tsgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\ndb disPL(P p,L a){return fabs((a.t-a.s)/(p-a.s)) / abs(a.t-a.s);}\ndb disPS(P p,L a){ // p x seg dis\n\tif(sgn((a.t-a.s)*(p-a.s)) == -1) return abs(p-a.s);\n\tif(sgn((a.s-a.t)*(p-a.t)) == -1) return abs(p-a.t);\n\treturn disPL(p,a);\n}\ndb disSS(L a,L b){ // seg x seg dis\n\tif(isSS(a,b)) return 0;\n\treturn min(min(disPS(a.s,b),disPS(a.t,b)),min(disPS(b.s,a),disPS(b.t,a)));\n}\ntypedef vector<P> polygon;\npolygon convex(polygon A){ // counter-clockwise , < : <=180 , <= : <180\n  int n=sz(A),m=0;\n  polygon B;B.resize(n<<1);\n  sort(all(A));\n  rep(i,0,n){\n    while(m > 1 && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  int k = m;\n  per(i,0,n-1){\n    while(m > k && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  B.resize(m);\n  if(sz(B) > 1) B.pop_back();\n  return B;\n}\nT area(polygon A) { // multiple 2 with integer type\n\tT res=0;\n\trep(i,0,sz(A)) res+=A[i]/(A[(i+1)%sz(A)]);\n\treturn fabs(res) / 2;\n}\nbool isconvex(polygon A){ // counter-clockwise\n\tbool ok=1;int n=sz(A);\n\trep(i,0,2) A.pb(A[i]);\n\trep(i,0,n) ok&=((A[i+1]-A[i])/(A[i+2]-A[i]))>=0;\n\treturn ok;\n}\nint inPpolygon(P p,polygon A){ // -1 : on , 0 : out , 1 : in\n\tint res=0;\n\trep(i,0,sz(A)){\n\t\tP u=A[i],v=A[(i+1)%sz(A)];\n\t\tif(onPS(p,u,v)) return -1;\n\t\tT cross = sgn((v-u)/(p-u)) , d1 = sgn(u.y-p.y) , d2 = sgn(v.y-p.y);\n\t\tif(cross > 0 && d1 <= 0 && d2 > 0) ++res;\n\t\tif(cross < 0 && d2 <= 0 && d1 > 0) --res;\n\t}\n\treturn res != 0;\n}\nT diameter(polygon A) { // longest distance\n  int n=sz(A);if(n <= 1) return 0;\n  int l=0,r=0;rep(i,1,n) (A[i]<A[l])&&(l=i),(A[r]<A[i])&&(r=i);\n  db res=abs(A[l]-A[r]);int i=l,j=r;\n  do (++((A[(i+1)%n]-A[i])/(A[(j+1)%n]-A[j])>=0?j:i))%=n,\n    res=max(res,abs(A[i]-A[j]));\n  while(i!=l||j!=r);\n  return res;\n}\npolygon convexCut(polygon A,P s,P t){ // counter-clockwise , left hand of st\n\tint n=sz(A);\n\tpolygon B;\n\trep(i,0,n){\n\t\tP u=A[i],v=A[(i+1)%n];\n\t\tint d1 = sgn((t-s)/(u-s)) , d2 = sgn((t-s)/(v-s));\n\t\tif(d1 >= 0) B.pb(u);\n\t\tif(d1 * d2 < 0) B.pb(insLL(L(u,v),L(s,t)));\n\t}\n\treturn B;\n}\nnamespace NearestPoints{\n  T solve(int l,int r,vector<P>&p){\n    if(l == r) return 1e100;\n    int m=(l+r)>>1;\n    T Xm = p[m].x , lim = min(solve(l,m,p) , solve(m+1,r,p));\n    inplace_merge(p.begin()+l,p.begin()+m+1,p.begin()+r+1,[&](P a,P b){return a.y<b.y;});\n    vector<P> V;\n    rep(i,l,r+1) if(fabs(p[i].x - Xm) <= lim) V.pb(p[i]);\n    rep(i,0,sz(V)) rep(j,i+1,sz(V)){\n      if(fabs(V[j].y - V[i].y) >= lim) break;\n      T dis = abs(V[i]-V[j]);\n      lim = min(lim,dis);\n    }\n    return lim;\n  }\n  T solve(vector<P> A){\n    sort(all(A),[&](P a,P b){return a.x<b.x;});\n    return solve(0,sz(A)-1,A);\n  }\n}\nstruct C{\n\tP o;T r;C(){} C(P o,T r):o(o),r(r){}\n\tbool operator == (const C&b) const {return o==b.o&&sgn(r-b.r)==0;}\n};\nint relCC(C A,C B){\n\tT dis = abs(A.o - B.o);\n\tif(sgn(dis - (A.r + B.r)) == 1) return 4;\n\tif(sgn(dis - (A.r + B.r)) == 0) return 3;\n\tif(sgn(dis - fabs(A.r - B.r)) == 1) return 2;\n\tif(sgn(dis - fabs(A.r - B.r)) == 0) return 1;\n\treturn 0;\n}\nvector<P> insCL(C c,L a){\n\tdb x = (a.s-c.o)*(a.t-a.s) , y = norm(a.t-a.s);\n\tdb d = x * x - y * (norm(a.s-c.o) - c.r*c.r);\n\tvector<P> res;\n\tif(sgn(d) < 0) return res;\n\td = max(d,0.);\n\tP mid = a.s - (a.t - a.s) * (x / y);\n\tP del = (a.t - a.s) * (sqrt(d) / y);\n\treturn {mid - del,mid + del}; // dir : a.s -> a.t\n}\n\nC o;\nP p;\ndb r;\n\nint main() {\n\tstd::ios::sync_with_stdio(0);\n\tstd::cin.tie(0);\n\t//\tfreopen(\"a.in\", \"r\", stdin);\n\t//\tfreopen(\"a.out\", \"w\", stdout);\n\tcout << setiosflags(ios::fixed);\n\tcout << setprecision(10);\n\tcin >> p.x >> p.y >> r;\n\to = C(p, r);\n\tint q;\n\tcin >> q;\n\twhile(q--) {\n\t\tP a, b;\n\t\tcin >> a.x >> a.y >> b.x >> b.y;\n\t\tvector<P> r = insCL(o, L(a, b));\n\t\tif(b.x < a.x || (b.x == a.x && b.y < a.y)) swap(r[0], r[1]);\n\t\tcout << r[0].x << \" \" << r[0].y << \" \" << r[1].x << \" \" << r[1].y << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-10; //??´??°???????????????\n\nbool operator<(const P &a, const P &b){\n  return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n}\n\nbool operator==(const P &a, const P &b){\n  const double eps = P_eps;\n  return abs(a.real() - b.real()) <= eps && abs(a.imag() - b.imag()) <= eps;\n}\n\nP rotate(P p, double theta){\n  return p * P(cos(theta), sin(theta));\n}\n\n//??????\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//??????\ndouble cross(P a, P b) {\n  return (a * conj(b)).imag();\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > P_eps) return 1; //COUNTER_CLOCKWISE\n  if(cross(b-a,c-a) < P_eps) return -1; //CLOCKWISE\n  if(dot(b-a,c-a) < P_eps) return -2; //c -> a -> b\n  if(dot(a-b,c-b) < P_eps) return 2; //a -> b -> c\n  return 0; //a -> c -> b\n}\n\n/* ??????ab??¨???c????????¢ */\ndouble distanceSP(P a, P b, P c) {\n  if ( dot(b-a, c-a) < P_eps ) return abs(c-a);\n  if ( dot(a-b, c-b) < P_eps ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ??´???ab??¨???c????????¢ */\ndouble distanceLP(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ????????????????????? */\ndouble isContainedCP(P c, double r, P p){\n  return abs(c-p) < r - P_eps; //?????¨??????????????????\n  //return abs(c-p) < r + P_eps; //?????¨????????????\n}\n\n/* ??´??????????????? */\nbool isIntersectedLL(P a1, P a2, P b1, P b2){\n  return abs(cross(a1-a2, b1-b2)) > P_eps;\n}\n\n/* ?????????????????? */\nbool isIntersectedSS(P a1, P a2, P b1, P b2){\n  \n  //??????a ??¨ ??´???b\n  P_type a = ccw(b1,b2,a1);\n  P_type b = ccw(b1,b2,a2);\n  \n  //??????b ??¨ ??´???a\n  P_type c = ccw(a1,a2,b1);\n  P_type d = ccw(a1,a2,b2);\n  \n  return a*b < P_eps && c*d < P_eps; // T?????????????????? -P_eps\n}\n\n/* ??????????????? */\nbool isIntersectedCC(P c1, double r1, P c2, double r2){\n  double dist = abs(c1 - c2);\n  \n  return abs(r1 - r2) < dist + P_eps && dist - P_eps < r1 + r2; //?????\\?????\\?????????\n  //return abs(r1 - r2) < dist - P_eps && dist + P_eps < r1 + r2; //?????\\?????\\?????????\n}\n\n/* ?????´??????????????? */\nbool isIntersectedCL(P c, double r, P a1, P a2){\n  return distanceLP(a1, a2, c) < r + P_eps; //??\\????????´????????????????????´??? - P_eps\n}\n\n/* ????????????????????? */\nbool isIntersectedCS(P c, double r, P a1, P a2){\n  return isContainedCP(c,r,a1) &&\n    isContainedCP(c,r,a2) &&\n    distanceLP(a1, a2, c) < r + P_eps; //??\\????????´????????????????????´??? - P_eps\n}\n\n/* ??´???/???????????? */\nP getCrosspointLL(P a1, P a2, P b1, P b2) {\n  //assert(isIntersectedLL(a1, a2, b1, b2));\n  //assert(isIntersectedSS(a1, a2, b1, b2));\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nP getCrosspointSS(P a1, P a2, P b1, P b2){\n  return getCrosspointLL(a1, a2, b1, b2);\n}\n\n/* ????????? */\npair<P,P> getCrosspointCC(P c1, double r1, P c2, double r2){\n  //assert(isIntersectedCC(c1, r1, c2, r2));\n  \n  double dist = abs(c1 - c2);\n  double a = acos((r1*r1 + dist * dist - r2 * r2) / (2 * r1 * dist));\n  return {c1 + polar(r1, arg(c2 - c1) + a), c1 + polar(r1, arg(c2 - c1) - a)};\n}\n\n/* ??????????????? */\npair<P,P> getCrosspointCS(P c, double r, P a1, P a2){\n  //assert(isIntersectedCS(c1, r1, c2, r2));\n  \n  P base1 = a2 - a1;\n  P proj = a1 + base1 * dot(c - a1, base1) / norm(base1); //?°???±\n  P e = (a2 - a1) / abs(a2 - a1);\n  P base2 = sqrt(r*r - norm(proj - c));\n  return {proj + e*base2, proj - e*base2};\n}\n\n\nint main(){\n  int cx,cy,r,q;\n\n  scanf(\"%d%d%d%d\",&cx,&cy,&r,&q);\n\n  for(int i=0;i<q;i++){\n    int x1,y1,x2,y2;\n\n    scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\n    auto crosspoints = getCrosspointCS(P(cx,cy),r,P(x1,y1),P(x2,y2));\n\n    if(crosspoints.second < crosspoints.first){\n      swap(crosspoints.first, crosspoints.second);\n    }\n\n    printf(\"%.10lf %.10lf %.10lf %.10lf\\n\",\n           crosspoints.first.real(),\n           crosspoints.first.imag(),\n           crosspoints.second.real(),\n           crosspoints.second.imag());    \n  }\n    \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn(s1.p1 + (s1.p2 - s1.p1) * t);\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn(make_pair(pr - e * base, pr + e * base));\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tCircle circle;\n\tcin >> circle.c.x >> circle.c.y >> circle.r;\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tLine line;\n\t\tcin >> line.p1.x >> line.p1.y >> line.p2.x >> line.p2.y;\n\t\tpair<Point, Point> pp = getCrossPoints(circle, line);\n\t\tif (pp.first < pp.second)\n\t\t{\n\t\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", pp.first.x, pp.first.y, pp.second.x, pp.second.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", pp.second.x, pp.second.y, pp.first.x, pp.first.y);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<float.h>\n#include<cstdio>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) fabs((a)-(b))<DBL_EPSILON*fmax(1,fmax(fabs(a),fabs(b)))\n//点のクラス\nclass Point{\n    public:\n        double x,y;\n        Point(double x=0,double y=0):x(x),y(y){}\n\n        Point operator + (Point p){return Point(x+p.x,y+p.y);}\n        Point operator - (Point p){return Point(x-p.x,y-p.y);}\n        Point operator * (double a){return Point(a*x,a*y);}\n        Point operator / (double a){return Point(x/a,y/a);}\n\n        double norm(Point p){return p.x*p.x+p.y*p.y;}\n        double abs(Point p){return sqrt(norm(p));}    \n        bool operator < (const Point &p)const{\n            return x!=p.x?x<p.x:y<p.y;\n        }\n        bool operator == (const Point &p)const{\n            return equals(x,p.x)&&equals(y,p.y);\n        }\n};\ntypedef Point Vector;\nstruct Segment{ Point p1,p2; };\ntypedef Segment Line;\ndouble norm(Vector v){return v.x*v.x+v.y*v.y;} \ndouble abs(Vector v){return sqrt(norm(v));}    \n//円\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n//多角形\ntypedef vector<Point> Polygon;\n//内積\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\n//外戚\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n//直交\nbool isOrthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){ return isOrthogonal(a1-a2,b1-b2); }\nbool isOrthogonal(Segment s1,Segment s2){ return equals(dot(s1.p1-s1.p2,s2.p1-s2.p2),0.0); }\n//平行\nbool isParallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\nbool isParallel(Point a1,Point a2,Point b1,Point b2){ return isParallel(a1-a2,b1-b2); }\nbool isParallel(Segment s1,Segment s2){ return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); }\n//射影\nPoint project(Segment s,Point p){ //射影　p377\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n//反射　p379\nPoint reflect(Segment s,Point p){return p+(project(s,p)-p)*2.0;}\n//ベクトルa,bの位置関係\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return 1;//p0,p1,p2が反時計回り\n    if(cross(a,b)<-EPS) return -1;//p0,p1,p2が時計回り\n    if(dot(a,b)<-EPS) return 2;//p1,p0,p2の順で一直線\n    if(norm(a)<norm(b)) return -2;//p0,p1,p2の順で一直線\n    return 0; //p0,p2,p1の順で一直線\n}\n//交差判定　p389\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);//p1,p2,p3,p4の順で一直線になるのを除く\n}\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//交点の座標　p392\nPoint getCrossPoint(Segment s1,Segment s2){ \n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n//距離p380\ndouble getDistance(Point a,Point b){ return abs(a-b);} //点aと点b\ndouble getDistanceLP(Line l,Point p){//直線lと点p\n\treturn abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\ndouble getDistanceSP(Segment s,Point p){//線分sと点p\n\tif(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n\tif(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\treturn getDistanceLP(s,p);\n}\ndouble getDistance(Segment s1,Segment s2){ //線分s1と線分s2\n\tif(intersect(s1,s2))return 0.0;\n\treturn min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t\t\t  min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//円　交点\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    //asert(intersect(c,l));   交点を持つことの確認\n\tVector pr =project(l,c.c);\n\tVector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\nint main(){\n    int q;\n    Point p1,p2;\n    Circle c;\n    cin>>c.c.x>>c.c.y>>c.r;\n    cin>>q;\n    pair<Point,Point> pp;\n    Line l;\n    for(int i=0;i<q;i++){\n        cin>>p1.x>>p1.y>>p2.x>>p2.y;\n        l.p1=p1; l.p2=p2;\n        pp=getCrossPoints(c,l);                                 \n        if(pp.first.x>pp.second.x)swap(pp.first,pp.second);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",pp.first.x,pp.first.y,pp.second.x,pp.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntemplate<class T>\nstruct Vec2\n{\n\tVec2(){}\n\tVec2(T _x, T _y) : x(_x), y(_y) {}\n\n\tVec2 operator+(const Vec2& rhs) const { return Vec2(x + rhs.x, y + rhs.y); }\n\tVec2 operator-(const Vec2& rhs) const { return Vec2(x - rhs.x, y - rhs.y); }\n\tVec2 operator*(T s) const { return Vec2(x*s, y*s); }\n\tT dot(const Vec2& rhs) const { return x*rhs.x + y*rhs.y; }\n\tT cross(const Vec2& rhs) const { return x*rhs.y - y*rhs.x; }\n\tdouble length() const { return sqrt(1.0*x*x + 1.0*y*y); }\n\tbool operator<(const Vec2& rhs) const\n\t{\n\t\tif (x != rhs.x) return x < rhs.x;\n\t\treturn y < rhs.y;\n\t}\n\n\tT x;\n\tT y;\n};\n\nint main()\n{\n\ttypedef Vec2<double> Vec2;\n\n\tint cx, cy, r, q;\n\tcin >> cx >> cy >> r >> q;\n\tVec2 C(cx, cy);\n\tfor (int i = 0; i < q; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tVec2 A(x1, y1), B(x2, y2);\n\t\tA = A - C;\n\t\tB = B - C;\n\t\tVec2 D = B - A;\n\t\tVec2 DU = D * (1.0 / D.length());\n\t\tVec2 H = A - DU*(A.dot(DU));\n\t\tdouble h = H.length();\n\n\n\t\tdouble l = sqrt(r*r - h*h);\n\t\tdouble pa = (A - H).dot(DU), pb = (B - H).dot(DU);\n\t\tVec2 int1 = (H - DU*l) + C;\n\t\tVec2 int2 = (H + DU*l) + C;\n\t\tif (int2 < int1) {\n\t\t\tswap(int1, int2);\n\t\t}\n\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\", int1.x, int1.y, int2.x, int2.y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// ????????????\n// verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//2??????????????????\n// Verify AOJ 1183\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{w-e,w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tP ba=b.c-a.c;\n\tR d=arg(ba);\n\tR i=acos((a.r+b.r)/abs(ba));\n\tR o=acos((a.r-b.r)/abs(ba));\n\tint r=rcc(a,b);\n\n\tif(r==OUT){\t\t//??±????????\\???\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ??±????????\\???\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\n\tif(r&ONS) res.push_back(tangent(a,d)); //??\\????????±???????????\\???\n\treturn res;\n}\n\n\nint main(void){\n\tint q;\n\tC c;\n\tcin >> c.c >> c.r;\n\t\t\n\tcin >> q;\n\tcout.precision(20);\n\trep(i,q){\n\t\tP a,b;\n\t\tcin >> a >> b;\n\t\tL l={a,b};\n\t\tVP res=pcl(c,l);\n\t\tif(real(res[0])>real(res[1])) swap(res[0],res[1]);\n\t\tif(real(res[0])==real(res[1])&&imag(res[0])==imag(res[1])) swap(res[0],res[1]);\n\t\tcout << fixed << res[0] << \" \" << res[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef complex<double> Point;\nusing Circle = struct{Point c; double r;};\ntypedef vector<Point> Polygon;\ntypedef Point Vector;\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\nconstexpr double EPS = (1e-9L);\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\ndouble dot(const Point& p1, const Point& p2) { return (conj(p1) * p2).real(); }\ndouble cross(const Point& p1, const Point& p2) { return (conj(p1) * p2).imag(); }\nconstexpr bool eq(double a) { return abs(a) < EPS; }\nPoint project(Segment s, Point p) {\n\tVector base = s.fi - s.se;\n\tdouble r = dot(p - s.fi, base) / norm(base);\n\treturn s.fi + base * r;\n}\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (cross(a, b) > EPS) return 1;\n\tif (cross(a, b) < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.fi, s1.se, s2.fi, s2.se);\n}\ndouble getDistance(Point &a, Point &b) { return abs(a - b); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.se - l.fi, p - l.fi) / abs(l.se - l.fi));\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.se - s.fi, p - s.fi) < 0.0) return abs(p - s.fi);\n\tif(dot(s.fi - s.se, p - s.se) < 0.0) return abs(p - s.se);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.fi), getDistanceSP(s1, s2.se)),\n\t\t\t\tmin(getDistanceSP(s2, s1.fi), getDistanceSP(s2, s1.se)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.se - s2.fi;\n\tdouble d1 = abs(cross(base, s1.fi - s2.fi));\n\tdouble d2 = abs(cross(base, s1.se - s2.fi));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.fi + (s1.se - s1.fi) * t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.se - l.fi) / abs(l.se - l.fi);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn mp(pr + e * base, pr - e * base);\n}\nint main() {\n\tcout << setprecision(10) << fixed;\n\tdouble x, y, r; cin >> x >>  y >> r;\n\tCircle ci{Point(x, y), r};\n\tint q; cin >> q;\n\tdouble x1, y1, x2, y2;\n\tpair<Point, Point> ppp;\n\trep(i, 0, q) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tppp = getCrossPoints(ci, Line(Point(x1, y1), Point(x2, y2)));\n\t\tif(ppp.se.real() < ppp.fi.real() || (ppp.se.real() == ppp.fi.real() && ppp.se.imag() < ppp.fi.imag()))\n\t\t\tswap(ppp.fi, ppp.se);\n\t\tcout << ppp.fi.real() << \" \" << ppp.fi.imag() << \" \" << ppp.se.real() << \" \" << ppp.se.imag() << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (Point p) { return Point(x * p.x, y * p.y); }\n\tPoint operator * (double p) { return Point(x * p, y * p); }\n\tPoint operator / (Point p) { return Point(x / p.x, y / p.y); }\n\tPoint operator / (double p) { return Point(x / p, y / p); }\n\tvoid insert(double a, double b) { x = a; y = b; }\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\nstruct Segment {\n\tVector p1, p2;\n\tSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0):\n\t\tp1(x1, y1), p2(x2, y2) {}\n\tSegment(Point a1, Point a2) : p1(a1), p2(a2) {}\n\tvoid insert(Vector a1, Vector a2) { p1 = a1; p2 = a2; }\n};\ntypedef Segment Line;\ninline double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ninline double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\ninline bool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\ninline bool isOrthogonal(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\ninline bool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\ninline bool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\ninline bool isParallel(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\ninline bool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point &p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point &p1, Point &p2, Point &p3, Point &p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Point &a, Point &b) { return (a - b).abs(); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn mp(pr + e * base, pr - e * base);\n}\nint main() {\n\tcout << setprecision(10) << fixed;\n\tdouble x, y, r; cin >> x >>  y >> r;\n\tCircle ci(Point(x, y), r);\n\tint q; cin >> q;\n\tdouble x1, y1, x2, y2;\n\tpair<Point, Point> ppp;\n\trep(i, 0, q) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tppp = getCrossPoints(ci, Line(x1, y1, x2, y2));\n\t\tif(ppp.fi < ppp.se) {\n\t\t\tcout << ppp.fi.x << \" \" << ppp.fi.y << \" \" << ppp.se.x << \" \" << ppp.se.y << \"\\n\";\n\t\t} else {\n\t\t\tcout << ppp.se.x << \" \" << ppp.se.y << \" \" << ppp.fi.x << \" \" << ppp.fi.y << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<float.h>\n#include<cstdio>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) fabs((a)-(b))<DBL_EPSILON*fmax(1,fmax(fabs(a),fabs(b)))\n//点のクラス\nclass Point{\n    public:\n        double x,y;\n        Point(double x=0,double y=0):x(x),y(y){}\n\n        Point operator + (Point p){return Point(x+p.x,y+p.y);}\n        Point operator - (Point p){return Point(x-p.x,y-p.y);}\n        Point operator * (double a){return Point(a*x,a*y);}\n        Point operator / (double a){return Point(x/a,y/a);}\n\n        double norm(Point p){return p.x*p.x+p.y*p.y;}\n        double abs(Point p){return sqrt(norm(p));}    \n        bool operator < (const Point &p)const{\n            return x!=p.x?x<p.x:y<p.y;\n        }\n        bool operator == (const Point &p)const{\n            return equals(x,p.x)&&equals(y,p.y);\n        }\n};\ntypedef Point Vector;\nstruct Segment{ Point p1,p2; };\ntypedef Segment Line;\ndouble norm(Vector v){return v.x*v.x+v.y*v.y;} \ndouble abs(Vector v){return sqrt(norm(v));}    \n//円\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n//多角形\ntypedef vector<Point> Polygon;\n//内積\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\n//外戚\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n//直交\nbool isOrthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){ return isOrthogonal(a1-a2,b1-b2); }\nbool isOrthogonal(Segment s1,Segment s2){ return equals(dot(s1.p1-s1.p2,s2.p1-s2.p2),0.0); }\n//平行\nbool isParallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\nbool isParallel(Point a1,Point a2,Point b1,Point b2){ return isParallel(a1-a2,b1-b2); }\nbool isParallel(Segment s1,Segment s2){ return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); }\n//射影\nPoint project(Segment s,Point p){ //射影　p377\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n//反射　p379\nPoint reflect(Segment s,Point p){return p+(project(s,p)-p)*2.0;}\n//ベクトルa,bの位置関係\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return 1;//p0,p1,p2が反時計回り\n    if(cross(a,b)<-EPS) return -1;//p0,p1,p2が時計回り\n    if(dot(a,b)<-EPS) return 2;//p1,p0,p2の順で一直線\n    if(norm(a)<norm(b)) return -2;//p0,p1,p2の順で一直線\n    return 0; //p0,p2,p1の順で一直線\n}\n//交差判定　p389\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);//p1,p2,p3,p4の順で一直線になるのを除く\n}\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//交点の座標　p392\nPoint getCrossPoint(Segment s1,Segment s2){ \n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n//距離p380\ndouble getDistance(Point a,Point b){ return abs(a-b);} //点aと点b\ndouble getDistanceLP(Line l,Point p){//直線lと点p\n\treturn abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\ndouble getDistanceSP(Segment s,Point p){//線分sと点p\n\tif(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n\tif(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\treturn getDistanceLP(s,p);\n}\ndouble getDistance(Segment s1,Segment s2){ //線分s1と線分s2\n\tif(intersect(s1,s2))return 0.0;\n\treturn min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t\t\t  min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//円　交点\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    //asert(intersect(c,l));   交点を持つことの確認\n\tVector pr =project(l,c.c);\n\tVector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\nint main(){\n    int q;\n    Point p1,p2;\n    Circle c;\n    cin>>c.c.x>>c.c.y>>c.r;\n    cin>>q;\n    pair<Point,Point> pp;\n    Line l;\n    for(int i=0;i<q;i++){\n        cin>>p1.x>>p1.y>>p2.x>>p2.y;\n        l.p1=p1; l.p2=p2;\n        pp=getCrossPoints(c,l);                                 \n        if(pp.first.x>pp.second.x)\n           swap(pp.first,pp.second);\n        else if(pp.first.x==pp.second.x&&pp.first.y>pp.second.y)\n            swap(pp.first,pp.second);\n\n        printf(\"%.10f %.10f %.10f %.10f\\n\",pp.first.x,pp.first.y,pp.second.x,pp.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double,double> pdd;\nconst double eps = 1e-7;\n\nbool eq(double a,double b)\n{\n    return abs(a-b)<eps;\n}\n\nvector<double> solve(double a,double b,double c)\n{\n    vector<double> ans;\n    double d = b*b - 4*a*c;\n\n    if(eq(d,0))\n    {\n        ans.push_back(-b/2/a);\n        ans.push_back(-b/2/a);\n    }else if(d>eps)\n    {\n        d = sqrt(d);\n        ans.push_back((-b+d)/(2*a));\n        ans.push_back((-b-d)/(2*a));\n    }\n    return ans;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int x,y,r;\n    cin>>x>>y>>r;\n\n    int q;\n    cin>>q;\n\n    cout<<fixed<<setprecision(10);\n    while(q--)\n    {\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n\n        double a,b,b1,c,k;\n        vector<double> ans;\n        vector<pdd> rs;\n        if(eq(x1,x2))\n        {\n            a = 1;\n            b = -2*y;\n            c = y*y - r*r + (x1-x)*(x1-x);\n            ans = solve(a,b,c);\n            for(int i=0;i<ans.size();i++)\n            {\n                rs.push_back(pdd(x1,ans[i]));\n            }\n        }else\n        {\n            k = (y2-y1)/(x2-x1);\n            b1 = y1 - k*x1;\n            a = 1 + k*k;\n            c = x*x + (b1-y)*(b1-y) - r*r;\n            b = 2*k*(b1-y)-2*x;\n            ans  = solve(a,b,c);\n\n            for(int i=0;i<ans.size();i++)\n            {\n                rs.push_back(pdd(ans[i],k*ans[i]+b1));\n            }\n\n        }\n\n        sort(rs.begin(),rs.end());\n        for(int i=0;i<rs.size();i++)\n        {\n            cout<<rs[i].first<<\" \"<<rs[i].second<<\" \";\n        }\n        cout<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<utility>\n#include<assert.h>\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n    \n    Point operator + (Point p) {return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) {return Point(x - p.x, y - p.y); }\n    Point operator * (double a) {return Point(a * x, a * y); }\n    Point operator / (double a) {return Point(x / a, y / a); }\n    \n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n    \n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; \n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a) {\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n    \n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n//    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n    int n;\n    Circle c;\n    Line l;\n    cin >> c.c.x >> c.c.y >> c.r >> n;\n    \n    for ( int i = 0; i < n; i++ ) {\n        cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n        pair<Point, Point> P = getCrossPoints(c, l);\n        Point p1, p2;\n        p1 = (P.first < P.second) ? P.first : P.second;\n        p2 = (P.first < P.second) ? P.second : P.first;\n        cout << fixed << setprecision(8) << p1.x << \" \"\n             << fixed << setprecision(8) << p1.y << \" \"\n             << fixed << setprecision(8) << p2.x << \" \"\n             << fixed << setprecision(8) << p2.y << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\n\ndouble eps = 1e-8;\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}  \n  double norm() {return sqrt(x*x + y*y);}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);};\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);};\ndouble operator * (const Point &p, const Point q) {return p.x * q.x + p.y * q.y;};\nbool operator == (const Point &p, const Point &q) {return (abs(p.x - q.x) < eps && abs(p.y - q.y) < eps);};\nbool operator != (const Point &p, const Point &q) {return !(p == q);};\n\nstruct Line {\n  double a, b, c;\n  Line(double a, double b, double c) : a(a), b(b), c(c) {}\n  Line(Point p, Point q) {\n    a = q.y - p.y;\n    b = p.x - q.x;\n    c = q.x * p.y - p.x * q.y;\n  }\n};\n\nstruct Circle {\n  double r;\n  Point p;\n  Circle(Point p = Point(0.0, 0.0), double r = 0.0) : p(p), r(r) {}\n};\n\nvector<Point> circle_line_cross(Line l, Circle c) {\n  vector<Point> vp;\n  Point h;\n  h.x = c.p.x - l.a * (l.a*c.p.x + l.b*c.p.y + l.c) / (l.a*l.a + l.b*l.b);\n  h.y = c.p.y - l.b * (l.a*c.p.x + l.b*c.p.y + l.c) / (l.a*l.a + l.b*l.b);\n\n  double d = l.a*c.p.x + l.b*c.p.y + l.c;\n  double q = c.r*c.r - d*d / (l.a*l.a + l.b*l.b);\n  Point p1, p2;\n  p1.x = h.x + sqrt(q) * l.b / sqrt(l.a*l.a + l.b*l.b);\n  p1.y = h.y - sqrt(q) * l.a / sqrt(l.a*l.a + l.b*l.b);\n  p2.x = h.x - sqrt(q) * l.b / sqrt(l.a*l.a + l.b*l.b);\n  p2.y = h.y + sqrt(q) * l.a / sqrt(l.a*l.a + l.b*l.b);\n  if(abs(l.b) < eps) {\n    if(l.a > 0) {\n      vp.push_back(p1);\n      vp.push_back(p2);\n    } else {\n      vp.push_back(p2);\n      vp.push_back(p1);\n    }\n  } else if(l.b > eps) {\n    vp.push_back(p2);\n    vp.push_back(p1);\n  } else {\n    vp.push_back(p1);\n    vp.push_back(p2);\n  }\n  return vp;\n} \n\nint main(){\n  double cx, cy, r;\n  cin >> cx >> cy >> r;\n  Circle c(Point(cx,cy),r);\n  int q;\n  cin >> q;\n  rep(i,q) {\n    double x1, x2, y1, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    Line l(Point(x1,y1),Point(x2,y2));\n    vector<Point> ans = circle_line_cross(l,c);\n    printf(\"%.9lf %.9lf %.9lf %.9lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-9;\nstruct dot{\n\tdouble x,y;\n\tdouble len(){return sqrt(x*x+y*y);}\n\tdot(double a=0.0,double b=0.0){x=a,y=b;}\n\tdot operator +(const dot&b)const {return dot(x+b.x,y+b.y);}\n\tdot operator -(const dot&b)const {return dot(x-b.x,y-b.y);}\n\tdot operator *(const double&z)const {return dot(x*z,y*z);}\n\tbool operator <(const dot&b)const {return (y<b.y)||(y==b.y&&x<b.x);}\n\tbool operator ==(const dot&b)const {return fabs(x-b.x)<eps&&fabs(y-b.y)<eps;}\t\n\tbool operator !=(const dot&b)const {return fabs(x-b.x)>=eps||fabs(y-b.y)>=eps;}\n\tvoid read(){scanf(\"%lf%lf\",&x,&y);} \n};\nstruct line{\n\tdot x1,x2;\n\tvoid read(){x1.read();x2.read();};\n\tline(dot a=dot(0.0,0.0),dot b=dot(0.0,0.0)){x1=a,x2=b;} \n\tdot getdot(){return x2-x1;}\n};\ndouble chaji(dot x,dot y){\n\treturn x.x*y.y-x.y*y.x;\n}\ndouble neiji(dot x,dot y){\n\treturn x.x*y.x+x.y*y.y;\n}\ndouble cos(dot x,dot y){\n\tif (!x.len()||!y.len())return 0;\n\treturn neiji(x,y)/x.len()/y.len();\n}\ndot Projection(dot x,line y){//求x关于直线y的投影点（垂足） \n\ty.x2=y.x2-y.x1;\n\tx=x-y.x1;\n\tdouble len=cos(x,y.x2)*x.len()/y.x2.len();\n\ty.x2=y.x2*len;\n\treturn y.x2+y.x1;\n}\ndot Reflection(dot x,line y){//求x关于直线y的对称点 \n\tdot z=Projection(x,y);\n\treturn z*2-x;\n}\nint Counter_Clockwise(dot x,line y){//求两个向量的五种关系 \n\tx=x-y.x1;y.x2=y.x2-y.x1;\n\tif (chaji(y.x2,x)!=0){\n\t\tif (chaji(y.x2,x)>0)return 1;\n\t\treturn 2;\n\t} \n\tif (fabs(cos(x,y.x2)+1)<eps)return 3;\n\tif (x.len()>y.x2.len())return 4;\n\treturn 5;\n} \nint Parallel_Orthogonal(line x,line y){//求两个直线是垂直还是平行还是其他 \n\tdot a=x.getdot(),b=y.getdot();\n\tif (chaji(a,b)==0)return 2;\n\tif (neiji(a,b)==0)return 1;\n\treturn 0;\n}\nint Intersection(line x,line y){//求两条线段是否相交 \n\tint Minx1=min(x.x1.x,x.x2.x),Maxx1=max(x.x1.x,x.x2.x);\n\tint Minx2=min(y.x1.x,y.x2.x),Maxx2=max(y.x1.x,y.x2.x);\n\tint Miny1=min(x.x1.y,x.x2.y),Maxy1=max(x.x1.y,x.x2.y);\n\tint Miny2=min(y.x1.y,y.x2.y),Maxy2=max(y.x1.y,y.x2.y);\n\tif (Minx1>Maxx2||Minx2>Maxx1)return 0;\n\tif (Miny1>Maxy2||Miny2>Maxy1)return 0;\n\tif (chaji(x.getdot(),y.x1-x.x1)*chaji(x.getdot(),y.x2-x.x1)>0)return 0;\n\tif (chaji(y.getdot(),x.x1-y.x1)*chaji(y.getdot(),x.x2-y.x1)>0)return 0;\n\treturn 1;\n}\nint Intersection2(line x,line y){//求线段和直线是否相交 \n\tif (chaji(y.getdot(),x.x1-y.x1)*chaji(y.getdot(),x.x2-y.x1)>0)return 0;\n\treturn 1;\n}\ndot CrossPoint(line x,line y){//求两条线段的交点 \n\tif (fabs(cos(x.getdot(),y.getdot())-1)<eps||fabs(cos(x.getdot(),y.getdot())+1)<eps){\n\t\tif (x.x1<x.x2)swap(x.x1,x.x2);\n\t\tif (y.x1<y.x2)swap(y.x1,y.x2);\n\t\tif (x.x2<y.x2)return y.x2;\n\t\telse return x.x2;\n\t}\n\telse {\n\t\tif (x.x2.x-x.x1.x==0){\n\t\t\tdouble k2=(y.x2.y-y.x1.y)/(y.x2.x-y.x1.x),b2=y.x2.y-y.x2.x*k2;\n\t\t\treturn dot(x.x2.x,x.x2.x*k2+b2);\n\t\t}\n\t\tif (y.x2.x-y.x1.x==0){\n\t\t\tdouble k1=(x.x2.y-x.x1.y)/(x.x2.x-x.x1.x),b1=x.x2.y-x.x2.x*k1;\n\t\t\treturn dot(y.x2.x,y.x2.x*k1+b1);\t\t\t\n\t\t}\n\t\tdouble k1=(x.x2.y-x.x1.y)/(x.x2.x-x.x1.x),b1=x.x2.y-x.x2.x*k1;\n\t\tdouble k2=(y.x2.y-y.x1.y)/(y.x2.x-y.x1.x),b2=y.x2.y-y.x2.x*k2;\n\t\tdot ans;\n\t\tans.x=(b2-b1)/(k1-k2);ans.y=ans.x*k1+b1;\n\t\treturn ans;\n\t}\n} \ndouble Dis(dot x,dot y){//点到点的距离 \n\treturn sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));\n}\ndouble dist(line x,dot y){//点到线段的距离 \n\tdot P=Projection(y,x);\n\tdouble k=neiji(x.getdot(),P-x.x1)/neiji(x.getdot(),x.getdot());\n\tif (k<=0)return Dis(x.x1,y);\n\tif (k>=1)return Dis(x.x2,y);\n\treturn Dis(y,P);\n}\ndouble Distance(line x,line y){//线段之间距离 \n\treturn min(min(dist(x,y.x1),dist(x,y.x2)),min(dist(y,x.x1),dist(y,x.x2)));\n}\nstruct polygon{\n\tvector<dot > A;\n\tdouble S(){//多边形面积\n\t\tdouble ans=0;\n\t\tfor (int i=0;i+1<A.size();i++)ans+=chaji(A[i],A[i+1])/2;\n\t\tif (A.size()>1)ans+=chaji(A[A.size()-1],A[0])/2;\n\t\treturn ans;\t\t\n\t}\n\tdouble C(){//多边形周长 \n\t\tdouble ans=0;\n\t\tfor (int i=0;i+1<A.size();i++)ans+=Dis(A[i],A[i+1]);\n\t\tif (A.size()>1)ans+=Dis(A[A.size()-1],A[0]);\n\t\treturn ans;\n\t}\n\tvoid read(){\n\t\tint n;scanf(\"%d\",&n);A.resize(n);\n\t\tfor (int i=0;i<n;i++)A[i].read();\n\t}\n\tint Is_Convex(){//是否是凸多边形 \n\t\tfor (int i=0;i<A.size();i++)\n\t\t\tif (chaji(A[(i+1)%A.size()]-A[i],A[(i+2)%A.size()]-A[(i+1)%A.size()])<0)\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n}G;\nint PolygonPointContainment(polygon G,dot x){//射线和多边形的关系\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (Counter_Clockwise(x,line(G.A[i],G.A[(i+1)%G.A.size()]))==5)return 1;\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (x==G.A[i])return 1;\n\tdouble k=sqrt(2)+1,b=x.y-x.x*k;\n\tdot x2=dot(-1000000000,-1000000000*k+b);line R=line(x,x2);\n\tint ans=0;\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (Intersection(R,line(G.A[i],G.A[(i+1)%G.A.size()])))ans++;\n\tif (ans&1)return 2;\n\treturn 0;\t\n}\nint isclock(dot x,dot y,dot z){//是否顺时针 \n\treturn chaji(z-x,y-x)<0;\n}\npolygon Convex_Hull(polygon G){//求凸包 \n\tpolygon ans1,ans2;\n\tsort(G.A.begin(),G.A.end());\n\tans1.A.push_back(G.A[0]);ans1.A.push_back(G.A[1]);\n\tfor (int i=2;i<G.A.size();i++){\n\t\twhile (ans1.A.size()>=2&&isclock(ans1.A[ans1.A.size()-2],ans1.A[ans1.A.size()-1],G.A[i]))\n\t\t\tans1.A.pop_back();\n\t\tans1.A.push_back(G.A[i]);\t\n\t}\n\tans2.A.push_back(G.A[G.A.size()-1]);ans2.A.push_back(G.A[G.A.size()-2]);\n\tfor (int i=G.A.size()-3;i>=0;i--){\n\t\twhile (ans2.A.size()>=2&&isclock(ans2.A[ans2.A.size()-2],ans2.A[ans2.A.size()-1],G.A[i]))\n\t\t\tans2.A.pop_back();\n\t\tans2.A.push_back(G.A[i]);\t\t\n\t}\n\tfor (int i=1;i<ans2.A.size()-1;i++)ans1.A.push_back(ans2.A[i]);\n\treturn ans1;\n}\ndouble DiameterofaConvexPolygon(polygon G){//求直径 \n\tint l=0,r=1,flag=1;\n\tdouble ans=Dis(G.A[0],G.A[1]);\n\twhile (l!=0||flag){\n\t\tflag=0;\n\t\twhile (Dis(G.A[l],G.A[r])<=Dis(G.A[l],G.A[(r+1)%G.A.size()])){\n\t\t\tr=(r+1)%G.A.size();\n\t\t\tans=max(ans,Dis(G.A[l],G.A[r]));\n\t\t}\n\t\tl=(l+1)%G.A.size();\n\t\tans=max(ans,Dis(G.A[l],G.A[r]));\n\t}\n\treturn ans;\n}\ndouble Convex_Cut(polygon G,line x){//求多边形在线的左边的部分 \n\tpolygon ans;line y=x;\n\tfor (int i=0;i<G.A.size();i++){\n\t\tif (chaji(y.x2-y.x1,G.A[i]-y.x1)>=0)ans.A.push_back(G.A[i]);\n\t\tif (Intersection2(line(G.A[i],G.A[(i+1)%G.A.size()]),y))\n\t\t\tans.A.push_back(CrossPoint(line(G.A[i],G.A[(i+1)%G.A.size()]),y));\t\n\t}\n\treturn ans.S();\n}\nint cmp2(int x,int y){\n\treturn G.A[x]<G.A[y];\n}\ndouble ClosestPair(int l,int r){//求平面最近点对 \n    double d=1e20;vector<int > ans;\n    if (l==r)return d;\n    if (l+1==r)return Dis(G.A[l],G.A[r]);\n    int mid=(l+r)/2; \n    double d1=ClosestPair(l,mid),d2=ClosestPair(mid+1,r);\n    d=min(d1,d2);\n    for (int i=l;i<=r;i++)\n        if (fabs(G.A[mid].x-G.A[i].x)<=d)ans.push_back(i);\n    sort(ans.begin(),ans.end(),cmp2);\n    for (int i=0;i<ans.size();i++)\n        for (int j=i+1;j<ans.size()&&G.A[ans[j]].y-G.A[ans[i]].y<d;j++)\n\t\t\td=min(d,Dis(G.A[ans[i]],G.A[ans[j]]));\n    return d;\n}\nint cmp(dot x,dot y){\n\treturn x.x<y.x||(x.x==y.x&&x.y<y.y);\n}\nstruct cricle{\n\tdot x;\n\tint r;\n\tvoid read(){\n\t\tx.read();\n\t\tscanf(\"%d\",&r);\n\t}\n};\nint IntersectionofCircles(cricle x,cricle y){//求两个圆的公切线个数 \n\tif (x.r+y.r<Dis(x.x,y.x))return 4;\n\tif (x.r+y.r==Dis(x.x,y.x))return 3;\n\tif (fabs(x.r-y.r)<Dis(x.x,y.x))return 2;\n\tif (fabs(x.r-y.r)==Dis(x.x,y.x))return 1;\n\treturn 0;\n}\nline CrossPointsofaCirceandaLine(cricle x,line y){\n\tdot K=Projection(x.x,y);\n\tdouble p=sqrt(x.r*x.r-Dis(x.x,K)*Dis(x.x,K));\n\tline ans;y.x1=y.x1-K;y.x2=y.x2-K;\n\tans.x1=(y.getdot())*(p/(y.getdot()).len())+K;\n\tans.x2=(y.getdot())*(-p/(y.getdot()).len())+K;\n\treturn ans;\n}\nint main(){\n\tcricle x;line y;\n\tx.read();int T;\n\tscanf(\"%d\",&T);\n\twhile (T--){\n\t\ty.read();\n\t\tline z=CrossPointsofaCirceandaLine(x,y);\n\t\tif (z.x1.x>z.x2.x||(z.x1.x==z.x2.x&&z.x1.y>z.x2.y))swap(z.x1,z.x2);\n\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",z.x1.x,z.x1.y,z.x2.x,z.x2.y);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nint CommonTangent(Circle c1, Circle c2) {\n  if (c1.r < c2.r) swap(c1, c2);\n  double d = Distance(c1.p, c2.p);\n  if (c1.r + c2.r < d) return 4;\n  if (eq(c1.r + c2.r, d)) return 3;\n  if (c1.r - c2.r < d) return 2;\n  if (eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// ↓ｺﾚ\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nint main() {\n  Circle c;\n  cin >> c.p >> c.r;\n\n  int q;\n  cin >> q;\n  while (q--) {\n    Line l;\n    cin >> l;\n    PointPoint ans = Crosspoint(c, l);\n    cout << fixed << setprecision(10) << ans.first << \" \" << ans.second << endl;\n  }\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (const auto &i : pos[0]) {\n    for (const auto &j : pos[1]) {\n      if (Distance(i, j) < d) {\n        d = Distance(i, j);\n        res = PointPoint(i, j);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  PointPoint res = ClosestPairUtil(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Points p(n);\n//   for (auto &i : p) cin >> i;\n//   sort(p.begin(), p.end());\n//   PointPoint pp = ClosestPair(p);\n//   cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n//   // cerr << pp.first << \" \" << pp.second << endl;\n// }\n\n// CommonTangent(C, C)\n// https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/7/CGL_7_A\n// int main() {\n//   Circle c1, c2;\n//   cin >> c1.p >> c1.r;\n//   cin >> c2.p >> c2.r;\n//   cout << CommonTangent(c1, c2) << endl;\n// } // !!!!!!!!!!!!!!!!!!!!!! AC !!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nclass Point{\n    public:\n    double x,y;\n    Point(double x=0,double y=0):x(x),y(y){}\n    Point operator+(const Point &p){\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator-(const Point &p){\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator*(const double &a){\n        return Point(a*x,a*y);\n    }\n    Point operator/(const double &a){\n        return Point(x/a,y/a);\n    }\n    double abs(){\n        return sqrt(norm());\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n    bool operator<(const Point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator==(const Point &p){\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\ntypedef Point Vector;\nstruct Segment{\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0):c(c),r(r){}\n};\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;   \n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2;\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1))/(l.p2-l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0){\n        return (p-s.p1).abs();\n    }\n    if(dot(s.p1-s.p2,p-s.p2)<0){\n        return (p-s.p2).abs();\n    }\n    return getDistanceLP(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return 1;\n    if(cross(a,b)<-EPS) return -1;\n    if(dot(a,b)<-EPS) return 2;\n    if(a.norm()<b.norm()) return -2;\n    return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n        ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n        min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nbool intersect(Circle c,Line l){\n    double x=getDistanceLP(l,c.c);\n    return (x<=c.r);    \n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\nint main(){\n    double cx,cy,r,a,b,c,d;\n    cin>>cx>>cy>>r;\n    int q;\n    cin>>q;\n    Point c1,p1,p2;\n    c1=Point(cx,cy);\n    Circle cc(c1,r);\n    for(int i=0;i<q;i++){\n        cin>>a>>b>>c>>d;\n        p1=Point(a,b);\n        p2=Point(c,d);\n        Line l(p1,p2);\n        auto points=getCrossPoints(cc,l);\n        if(points.first<points.second){\n            printf(\"%.6lf %.6lf %.6lf %.6lf\\n\",\n                points.first.x,points.first.y,\n                points.second.x,points.second.y);\n        }\n        else{\n            printf(\"%.6lf %.6lf %.6lf %.6lf\\n\",\n                points.second.x,points.second.y,\n                points.first.x,points.first.y);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(const Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?distance(c.o,h)<c.r-EPS?2:1\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn intersect(c,s)?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?c.r-max(d1,d2)\n\t\t:intersect(s,h)?distance(c.o,h)-c.r\n\t\t:min(distance(c.o,s.p1),distance(c.o,s.p2))-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h,0))ret.emplace_back(a.o+u*a.r,a.o+u*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){}\nmain(){\n\tCircle c;\n\tcin>>c.o>>c.r;\n\tint n;cin>>n;\n\tfor(;n--;)\n\t{\n\t\tLine e;cin>>e.p1>>e.p2;\n\t\tpair<Point,Point>p=crosspoint(c,e);\n\t\tcout<<p.first<<\" \"<<p.second<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ld = long double;\nusing point = std::complex<ld>;\nusing polygon = std::vector<point>;\n\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = std::acos(-1.0);\n\nbool comp(point a, point b) {\n    return std::real(a) < std::real(b) || (std::real(a) <= std::real(b) && std::imag(a) < std::imag(b));\n}\n\nstd::vector<point> unique(std::vector<point> ps) {\n    std::sort(std::begin(ps), std::end(ps), comp);\n    std::vector<point> res;\n    for(auto& p : ps) {\n        if(res.empty() || abs(res.back() - p) > eps) {\n            res.push_back(p);\n        }\n    }\n    return res;\n}\n\nld dot(point const& a, point const& b) {\n    return std::real(std::conj(a) * b);\n}\nld cross(point const& a, point const& b) {\n    return std::imag(std::conj(a) * b);\n}\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps) return 1;            // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps) return -1;          // a -> b -> c : clockwise\n    if(dot(b, c) < 0) return 2;                // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\nstruct segment {\n    segment() : a(0, 0), b(0, 0) {}\n    segment(point a, point b) : a(a), b(b) {}\n    point a, b;\n};\n\nstruct line {\n    line() : a(0, 0), b(0, 0) {}\n    line(point a, point b) : a(a), b(b) {}\n    line(segment s) : a(s.a), b(s.b) {}\n    point a, b;\n};\n\nstruct circle {\n    circle() : p(point(0, 0)), r(0) {}\n    circle(point p_, long double r_) : p(p_), r(r_) {}\n    point p;\n    long double r;\n};\n\nbool isis_ll(line l, line m) {\n    return cross(l.b - l.a, m.b - m.a) < eps;\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\npoint is_ss(segment s1, segment s2) {\n    assert(isis_ss(s1, s2));\n    point sv = s1.b - s1.a, tv = s2.b - s2.a;\n    if(cross(sv, tv) == 0) {\n        if(std::abs(s1.a - s2.a) < eps || std::abs(s1.a - s2.b) < eps) {\n            return s1.a;\n        } else {\n            return s1.b;\n        }\n    } else {\n        return is_ll(line(s1), line(s2));\n    }\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\nstd::vector<point> is_cl(circle const& c, line const& l) {\n    const ld d = dist_lp(l, c.p);\n    std::vector<point> res;\n    if(d > c.r) return res;\n    auto p = proj(l, c.p);\n    if(std::fabs(d - c.r) < eps) {\n        res.push_back(p);\n        return res;\n    }\n    const ld len = std::sqrt(c.r * c.r - d * d);\n    auto vec = (l.b - l.a) / std::abs(l.b - l.a);\n    res.push_back(p + vec * len);\n    res.push_back(p + vec * len * point(-1, 0));\n    if(comp(res[1], res[0])) swap(res[0], res[1]);\n    return res;\n}\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    ld d = std::abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    ld rs = std::sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\nld area(polygon const& p) {\n    const int N = p.size();\n    ld res = 0;\n    for(int i = 0; i < N; ++i) {\n        res += cross(p[i], p[(i + 1) % N]);\n    }\n    return res / 2;\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    const int n = poly.size();\n    ld sum = 0;\n    for(int i = 0; i < n; ++i) {\n        point p1 = poly[i], p2 = poly[(i + 1) % n];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return std::abs(sum) < pi / 2 ? 2 : 1; // @todo: should check < 0.5 ?\n}\n\n// left side\npolygon convex_cut(polygon const& p, line l) {\n    const int N = p.size();\n    polygon res;\n    for(int i = 0; i < N; ++i) {\n        auto a = p[i], b = p[(i + 1) % N];\n        if(ccw(l.a, l.b, a) != -1) {\n            res.push_back(a);\n        }\n        if(ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) {\n            if(cross(a - b, l.a - l.b) == 0) continue; // cut line が辺に覆いかぶさる\n            res.push_back(is_ll(line(a, b), l));\n        }\n    }\n    return res;\n}\n\npolygon convex_hull(std::vector<point> ps) {\n    std::sort(ps.begin(), ps.end(), comp);\n    const int n = ps.size();\n    int k = 0;\n    polygon qs(2 * n);\n    for(int i = 0; i < n; ++i) {\n        while(k > 1 && ccw(qs[k - 2], qs[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    for(int i = n - 2, t = k; i >= 0; --i) {\n        while(k > t && ccw(qs[k - 2], qs[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    qs.resize(k - 1);\n    return qs;\n}\n\nbool compare_y(point const& a, point const& b) {\n    return std::imag(a) < std::imag(b);\n}\n\nld closest_pair_impl(point* a, int n) {\n    if (n <= 1) return 1e20;\n    int m = n / 2;\n    ld x = std::real(a[m]);\n    ld d = std::min(closest_pair_impl(a, m), closest_pair_impl(a + m, n - m));\n    std::inplace_merge(a, a + m, a + n, compare_y);\n    std::vector<point> b;\n    for (int i = 0; i < n; i++) {\n        if (std::abs(std::real(a[i]) - x) >= d) continue;\n        for (int j = 0; j < (int)b.size(); j++) {\n            ld dx = std::real(a[i]) - std::real(b[b.size() - j - 1]);\n            ld dy = std::imag(a[i]) - std::imag(b[b.size() - j - 1]);\n            if (dy >= d) break;\n            d = std::min(d, sqrtl(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\nld closest_pair(std::vector<point> ps) {\n    std::sort(std::begin(ps), std::end(ps), comp);\n    return closest_pair_impl(ps.data(), ps.size());\n}\n\nusing namespace std;\n\nint main() {\n    ld cx, cy, r;\n    cin >> cx >> cy >> r;\n    circle c(point(cx, cy), r);\n    int q; cin >> q;\n    while(q--) {\n        ld x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        line l(point(x1, y1), point(x2, y2));\n        auto ans = is_cl(c, l);\n        if(ans.size() == 1u) ans.push_back(ans.back());\n        cout << fixed << setprecision(10);\n        cout << real(ans[0]) << ' ' << imag(ans[0]) << ' ' << real(ans[1]) << ' ' << imag(ans[1]) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define eps (1e-10)\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point &p){return point(x+p.x,y+p.y);}\n    point operator - (point &p){return point(x-p.x,y-p.y);}\n    point operator * (double k){return point(x*k,y*k);}\n    point operator / (double k){return point(x/k,y/k);}\n\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n\n    bool operator < (const point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator == (const point &p){\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n//内积\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n//外积\ndouble cross(point a,point b){\n    return a.x*b.y-a.y*b.x;\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/base.norm();\n    base=base*r;\n    return a+base;\n}\n\npair<point,point>getcrosspoints(point xin,int r,point a,point b)\n{\n    point pr=project(a,b,xin);\n    point e=(b-a)/(b-a).abs();\n    double base=sqrt(r*r-(pr-xin).norm());\n    e=e*base;\n    return make_pair(pr+e,pr-e);\n}\n\nint main()\n{\n    point xin;\n    int r;\n    cin>>xin.x>>xin.y>>r;\n    int q;\n    cin>>q;\n    point a,b;\n    for(int i=0;i<q;i++){\n        cin>>a.x>>a.y>>b.x>>b.y;\n        pair<point,point>res=getcrosspoints(xin,r,a,b);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n幾何\nhttps://gist.github.com/zeptometer/3719669\n複素数平面による幾何ライブラリ←もっと短くなる可能生アリ\nhttp://osrehun.hatenadiary.jp/entry/2016/12/31/145827\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing DD=double;\n\n\n#define EPS 1e-10\n#define eq(a,b) (abs( (a) - (b) )<EPS)\nconst DD PI=acosl(-1.0);\nconstexpr DD INF=1LL<<62;\n\n//点\nusing P=complex<DD>;\n//ベクトル\nusing V=P;\n//線分\nstruct Segment{\n    P a,b;\n    Segment()=default;\n    Segment(P a,P b) :a(a),b(b){}\n    Segment(DD ax,DD ay,DD bx,DD by):a(ax,ay),b(bx,by){}\n\n};\n//直線\nusing Line=Segment;\n//円\nstruct Circle{\n    P p;\n    DD r;\n    Circle()=default;\n    Circle(P p,DD r):p(p),r(r){}\n};\nusing Polygon=vector<P>;\n\n//++++++++++++++++基本計算++++++++++++++//\ninline DD torad(const DD &deg){return deg*PI/180;}\ninline DD todeg(const DD &rad){return rad*180/PI;}\n//内積\ninline DD dot(const V &a,const V &b){\n    return real(a*conj(b));\n}\n//外積\ninline DD cross(const V &a,const V &b){\n    return imag(conj(a)*b);\n}\n//ベクトルvを反時計回りにr度回転\ninline V rotate(const V &v,const DD r){\n    return v*V(cos(r),sin(r));\n}\ninline bool xy(const P &a,const P &b){\n    if(real(a)+EPS<=real(b)) return true;\n    if(eq(real(a),real(b)) && imag(a)+EPS<imag(b)) return true;\n    return false;\n}\ninline bool yx(const P &a,const P &b){\n    if(imag(a)+EPS<imag(b)) return true;\n    if(eq(imag(a),imag(b)) && real(a)+EPS<real(b)) return true;\n    return false;\n}\n\n//++++++++++++++++平行や直交+++++++++++++++//\ninline bool isOrthogonal(const V &a,const V &b){\n    return eq(dot(a,b),0.0);\n}\ninline bool isOrthogonal(const Segment &a,const Segment &b){\n    return eq(dot(a.a-a.b,b.a-b.b),0);\n}\ninline bool isParallel(const V &a,const V &b){\n    return eq(cross(a,b),0.0);\n}\ninline bool isParallel(const Segment &a,const Segment &b){\n    return eq(cross(a.a-a.b,b.a-b.b),0);\n}\n//線分a-bに対してcがどの位置にあるか\n//ccwの簡略版 反時計回り:1 時計回り:-1 直線上:0\ninline int ccw(const P &a,const P &b,const P &c){\n    DD cr=cross(b-a,c-a);\n    if(cr>EPS) return 1;\n    if(cr<-EPS) return -1;\n    return 0;\n}\n\n//線分a-bに対してcがどの位置にあるか\n//反時計回り:1　時計回り:-1 直線上(a,b,c:-2 a,c,b:0 c,a,b:2) \ninline int ccwH(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS) return 1;\n    if(cross(b,c)<-EPS) return -1;\n    if(dot(b,c)<-EPS) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\n\n\n//+++++++++++++++射影+++++++++++++++++++++//\ninline P project(const P &p,const Segment &s){\n    V base=s.b-s.a;\n    DD r=dot(p-s.a,base)/norm(base);\n    return s.a+base*r;\n}\ninline P reflect(const P &p,const Segment &s){\n    return p+(project(p,s)-p)*2.0;\n}\n/*++++++++++点との距離++++++++++++++++++*/\n//点と直線の距離\ninline DD dis(const P &p,const Line &l){return abs(cross(l.b-l.a,p-l.a))/abs(l.b-l.a);}\n//点と線分の距離\ninline DD disPS(const P &p,const Segment &s){\n    if( dot(s.b-s.a,p-s.a)<0.0 ) return abs(p-s.a);\n    if( dot(s.a-s.b,p-s.b)<0.0 ) return abs(p-s.b);\n    return dis(p,s); //点と直線の距離\n}\n\n\n//+++++++++++++++線分と直線+++++++++++++++++//\n\n//線分a-b,c-dは交差するか?\ninline bool intersect(const P &a,const P &b,const P &c,const P &d){\n    return(ccwH(a,b,c)*ccwH(a,b,d)<=0 && ccwH(c,d,a)*ccwH(c,d,b)<=0);\n}\n//線分s,tは交差するか？\ninline bool intersect(const Segment &s,const Segment &t){\n    return intersect(s.a,s.b,t.a,t.b);\n}\n//線分と線分の交点\n//これをやる前にintersectで判定\ninline P crossPoint(const Segment &s,const Segment &t){\n    V base=t.b-t.a;\n    DD d1=abs(cross(base,s.a-t.a));\n    DD d2=abs(cross(base,s.b-t.a));\n    DD r=d1/(d1+d2);\n    return s.a+(s.b-s.a)*r;\n}\n//線分と線分の距離\ninline DD dis(const Segment &s,const Segment t){\n    if(intersect(s,t)) return 0.0;\n    return min(min(disPS(t.a,s),disPS(t.b,s)),min(disPS(s.a,t),disPS(s.b,t)) );\n}\n\n//+++++++++++円++++++++++++++++//\n\n//円cと直線lの交点\n//abs(l,c.p)<c.r+EPSが必要\npair<P,P> crossPoint(const Line &l,const Circle &c){\n    P pr=project(c.p,l);\n    V e=(l.b-l.a)/(abs(l.b-l.a));\n    DD base=sqrt(c.r*c.r-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n//線分sと円cの交点\nvector<P> crossPointSC(const Segment &s,const Circle &c){\n    vector<P> ret;\n    if(dis(c.p,s)>=c.r+EPS) return ret;\n    auto p=crossPoint(s,c);\n    if(dot(p.first-s.a,s.b-s.a)>0 && dot(p.first-s.b,s.a-s.b)>0) ret.push_back(p.first);\n    if(dot(p.second-s.a,s.b-s.a)>0 && dot(p.second-s.b,s.a-s.b)>0) ret.push_back(p.second);\n    if(xy(s.a,s.b)) sort(ret.begin(),ret.end(),xy);\n    else sort(ret.rbegin(),ret.rend(),xy);\n    return ret;\n}\n\n//共通接線の数\n//離れている:4 外接:3 交わる:2 内接:1 内包:0\ninline int intersect(const Circle &a,const Circle &b){\n    DD d=abs(a.p-b.p);\n    if(d>a.r+b.r+EPS) return 4;\n    if(eq(d,a.r+b.r)) return 3;\n    if(eq(d,abs(a.r-b.r))) return 1;\n    if(d<abs(a.r-b.r)-EPS) return 0;\n    return 2;\n}\n\n//円c1と円c2の交点\n//これを使う前に交点があるかどうかを判定する\nvector<P> crossPoint(const Circle &a,const Circle &b){\n    vector<P> ret;\n    if(abs(a.p-b.p)<a.r+b.r+EPS) return ret;\n    DD d=abs(a.p-b.p);\n    DD s=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n    DD t=arg(b.p-a.p);\n    if(eq(s,0)) ret.emplace_back(a.p+polar(a.r,t+s));\n    else ret.emplace_back(a.p+polar(a.r,t+s)),ret.emplace_back(a.p+polar(a.r,t-s));\n    return ret;\n}\n\n//pがcの外にあるかの判定が必要\nvector<P> TanLine(const P &p,const Circle &c){\n    vector<P> ret;\n    DD d=abs(p-c.p);\n    if(d<=c.r-EPS) return ret;\n    if(eq(d,c.r)){\n        ret.push_back(p);\n        return ret;\n    } \n    return crossPoint(c,Circle(p,sqrt(d*d-c.r*c.r)));\n}\n//https://ei1333.github.io/luzhiled/snippets/geometry/template.html\n//↑すごい。丸写し\n//円c1,c2の共通接線\n//接点をつないで線にしている(１個だけ追加するときに注意)\nvector<Line> TanLine(Circle a,Circle b){\n    vector<Line> ret;\n    if(a.r<b.r) swap(a,b);\n    DD g=abs(a.p-b.p);\n    if(eq(g,0)) return ret;\n    V u=(b.p-a.p)/g;\n    V v=rotate(u,PI*0.5);\n    for(DD s:{-1,1}){\n        DD h=(a.r+s*b.r)/g;\n        if(eq(1-h*h,0)){\n            ret.emplace_back(a.p+u*a.r,a.p+(u+v)*a.r);\n        }else if(1-h*h>0){\n            V uu=u*h,vv=v*sqrt(1-h*h);\n            ret.emplace_back(a.p+(uu+vv)*a.r,b.p-(uu+vv)*b.r*s);\n            ret.emplace_back(a.p+(uu-vv)*a.r,b.p-(uu-vv)*b.r*s);\n        }\n    }\n    return ret;\n}\n\n/*+++++++++++++++++++三角形+++++++++++++++++*/\n//外心\n//isParallel()を使って判定を忘れずに\nP circumcenter(const P &a,const P &b,const P &c){\n    P ab=(a+b)/2.0,bc=(b+c)/2.0;\n    Segment s(ab,ab+polar(1.0,arg(b-a)+PI*0.5));\n    Segment t(bc,bc+polar(1.0,arg(c-b)+PI*0.5));\n    return crossPoint(s,t);\n}\n\n/*+++++++++++++++++++多角形+++++++++++++++++++*/\n//IN:2 ON:1 OUT:0\n//点がどの位置にあるか\nint contains(const P &p,const Polygon &g){\n    int n=(int)g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        V a=g[i]-p,b=g[(i+1)%n]-p;\n        if(eq(cross(a,b),0) && dot(a,b)<EPS) return 1;\n        if(imag(a)>imag(b)) swap(a,b);\n        if(imag(a)<EPS && EPS<imag(b) && cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n//凸性判定\nbool isConvex(const Polygon &g){\n    int n=(int)g.size();\n    int flag=0;\n    int t;\n    for(int i=0;i<n;i++){\n        V a(g[(i+1)%n]-g[i]),b(g[(i+2)%n]-g[i]);\n        if(cross(a,b)>EPS) t=1;\n        else if(cross(a,b)<-EPS) t=-1;\n        else continue;\n        if(flag==-t) return false;\n        flag=t;\n    }\n    return true;\n}\n\n//凸包　アンドリューのアルゴリズム\n//https://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp←螺旋本より早そう\n//j=1:返上の点を含まない　j=-1:含む\n//反時計回りの多角形を返す\n//sはソートされる\nPolygon ConvexHull(Polygon &s,const int j){\n    int sz=(int)s.size();\n    if(sz<3) return s;\n    sort(s.begin(),s.end(),yx);\n\n    int n=0;\n    Polygon res(2*sz);\n    for(int i=0;i<sz;i++){\n        while(n>=2 && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    int t=n+1;\n    for(int i=sz-2;i>=0;i--){\n        while(n>=t && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    res.resize(n-1);\n    return res;\n}\n\n//符号付き面積\n//反時計回りの図形なら正\n//https://imagingsolution.net/math/calc_n_point_area/\nDD Area(const Polygon &g){\n    DD ret=0.0;\n    int n=(int)g.size();\n    for(int i=0;i<n;i++){\n        ret+=cross(g[i],g[(i+1)%n]);\n    }\n    return ret/2.0L;\n}\n\n//反時計回り\n//理解が浅い←大体分かった（本当か？）\nDD Diameter(Polygon g){\n    g=ConvexHull(g,1);\n    int gz=g.size();\n    int m=0,M=0;\n    for(int i=1;i<gz;i++){\n        if(imag(g[i])<imag(g[m])) m=i;\n        if(imag(g[i])>imag(g[M])) M=i;\n    }\n    DD ret=0;\n    int sm=m,sM=M;\n    while(m!=sM || M!=sm){\n        ret=max(ret,norm(g[m]-g[M]));\n        if(cross(g[(m+1)%gz]-g[m],g[(M+1)%gz]-g[M])<0) m=(m+1)%gz;\n        else M=(M+1)%gz;\n    }\n    return sqrt(ret);\n}\n\n//凸多角形gをlで切断\n//l.p1-l.p2の左側\n//gは反時計回り→反時計回りで返す\n//時計回り→時計回り\nPolygon ConvexCut(const Polygon &g,const Line &l){\n    Polygon ret;\n    int gz=(int)g.size();\n    for(int i=0;i<gz;i++){\n        P now=g[i],next=g[(i+1)%gz];\n        if(ccw(l.a,l.b,now)>=0) ret.push_back(now);\n        if(ccw(l.a,l.b,now)*ccw(l.a,l.b,next)<0){\n            ret.push_back(crossPoint(Line(now,next),l));\n        }\n    }\n    return ret;\n}\n\ninline DD calc(const P &a,const P &b,const DD &r,const bool triangle){\n    if(triangle) return cross(a,b);\n    else return r*r*arg(b-a);\n}\n\nDD calcArea(const DD &r,const P &a,const P &b){\n    if(eq(abs(a-b),0)) return 0;\n    bool ina=abs(a)<r+EPS;\n    bool inb=abs(b)<r+EPS;\n    if(ina && inb) return cross(a,b);\n    auto cr=crossPointSC(Segment(a,b),Circle((0,0),r));\n    if(cr.empty()) return calc(a,b,r,false);\n    auto s=cr[0],t=cr.back();\n    return calc(s,t,r,true)+calc(a,s,r,ina)+calc(t,b,r,inb);\n}\n\n//円と多角形の共通部分の面積\n//http://drken1215.hatenablog.com/entry/2020/02/02/091000\nDD Area(const Circle &c,const Polygon &g){\n    DD ret=0.0;\n    int gz=g.size();\n    if(gz<3) return ret;\n    for(int i=0;i<gz;i++){\n        P a=g[i]-c.p,b=g[(i+1)%gz]-c.p;\n        ret+=calcArea(c.r,g[i]-c.p,g[(i+1)%gz]-c.p);\n    }\n    return ret/2.0;\n}\n\n//++++なんか凄いの+++++++++++++++\n\n//最近点対\nDD RecClosetPair(Polygon::iterator it,const int n){\n    if(n<=1) return INF;\n    int m=n/2;\n    DD x=real(it[m]);\n    DD d=min(RecClosetPair(it,m),RecClosetPair(it+m,n-m));\n    inplace_merge(it,it+m,it+n,yx);\n    Polygon v;\n    for(int i=0;i<n;i++){\n        if(abs(real(it[i])-x)>=d) continue;\n        for(int j=0;j<v.size();j++){\n            DD dy=imag(it[i])-imag(v[v.size()-1-j]);\n            if(dy>=d) break;\n            DD dx=real(it[i])-real(v[v.size()-1-j]);\n            d=min(d,sqrt(dx*dx+dy*dy));\n        }\n        v.push_back(it[i]);\n    }\n    return d;\n}\n\nDD ClosetPair(Polygon g){\n    sort(g.begin(),g.end(),xy);\n    return RecClosetPair(g.begin(),g.size());\n}\n\n\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n\n    DD cx,cy,r;\n    cin>>cx>>cy>>r;\n    Circle c(P(cx,cy),r);\n    int Q;\n    cin>>Q;\n    while(Q--){\n        int x[2],y[2];\n        vector<P> p;\n        for(int i=0;i<2;i++) cin>>x[i]>>y[i],p.emplace_back(x[i],y[i]);\n        auto ans=crossPoint(Line(p[1],p[0]),c);\n        if(!xy(ans.first,ans.second)) swap(ans.first,ans.second);\n        printf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans.first.real(),ans.first.imag(),ans.second.real(),ans.second.imag());\n    }\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n\nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n\ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n\nP Vector(L a){\n  return a.second-a.first;\n}\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n\ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n\n\nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n\nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n\nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n\nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n\nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n\nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n\nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n\nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n\ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n\ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n\ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n\nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\n\n \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvecP cutConvex(vecP &t,L l){\n  P a=l.first, b=l.second;\n  int N=t.size();\n  vecP res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C==-D&&abs(C)==1)res.push_back(getCrossLL( l ,L(c,d) ));\n  }\n  return res;\n}\n\nP getVector(const vecP &t, int id){\n  int n=t.size();\n  return t[ (id+1)%n ] - t[id%n];\n}\n\ndouble convex_diameter(vecP &t) {\n  int n = t.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(t[i]) > imag(t[is])) is = i;\n    if (imag(t[i]) < imag(t[js])) js = i;\n  }\n  double maxd = norm(t[is]-t[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    \n    if (cross( getVector(t,i), getVector(t,j)) >= 0) j = (j+1) % n;\n    \n    else i = (i+1) % n;\n    if (norm(t[i]-t[j]) > maxd) {\n      maxd = norm(t[i]-t[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nbool compare_y(const P &a,const P &b){\n  return a.imag() < b.imag();\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return 1e30;\n  int m = n / 2;\n  double x = a[m].real();\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if( abs(a[i].real() - x) >= d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dx = real(a[i] - b[b.size() - j - 1]);\n      double dy = imag(a[i] - b[b.size() - j - 1]);\n      if(dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nP _pool[200005];\ndouble minDist(vecP &t){\n  int n=t.size();\n  for(int i=0;i<n;i++)_pool[i]=t[i];\n  sort( _pool, _pool+n);\n  return closest_pair(_pool, n);\n}\n\nint getStateCC(C a,C b){\n  double ar=a.second, br=b.second;\n  double dist=abs(a.first-b.first);\n  if(dist>ar+br+eps)return 4;\n  if(dist>ar+br-eps)return 3;\n  if(dist>abs(ar-br)+eps)return 2;\n  if(dist>abs(ar-br)-eps)return 1;\n  return 0;\n}\n\nP getCrossCC(C a,C b){\n  P p1=a.first, p2=a.second;\n  double r1=a.second, r2=b.second;\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,Sqrt(1.0-cA*cA));\n}\n\nS getTangentCP(C a,P p){\n  P base=a.first-p;\n  double ar=a.second;\n  double w=Sqrt(norm(base)-ar*ar);\n  P s=p+base*P(w,ar)/norm(base)*w;\n  P t=p+base*P(w,-ar)/norm(base)*w;\n  return S(s,t);\n}\n\nS getInTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double w=ar+br;\n  double h=Sqrt(norm(base)-w*w);\n  P k=base*P(w,h*flg)/norm(base);\n  return S(ap+k*ar,bp-k*br);\n}\n  \nS getOutTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double h=br-ar;\n  \n  double w=Sqrt(norm(base)-h*h);\n  P k=base*P(w,h*flg)/norm(base)*P(0,flg);\n  return S(ap+k*ar,bp+k*br);\n}\n  \nvector<S> getTangent(C a,C b){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  vector<S> res;\n  double dist=abs(ap-bp);\n    \n  if(dist>ar+br+eps)\n    res.push_back(getInTangent(a,b,1));\n  \n  if(dist>ar+br-eps)\n    res.push_back(getInTangent(a,b,-1));\n  \n  if(dist>abs(ar-br)+eps)\n    res.push_back(getOutTangent(a,b,1));\n  \n  if(dist>abs(ar-br)-eps)\n    res.push_back(getOutTangent(a,b,-1));\n  \n  return res;\n}\n\n\nvecP getCrossCL(C cir,L l){\n  P a=l.first, b=l.second;\n  double cr=cir.second;\n  P cp=cir.first;\n  \n  vecP res;\n  P base=b-a,  target=project(a,b,cp);\n  \n  double length=abs(base), h=abs(cp-target);\n  base/=length;\n  \n  if(cr+eps<h)return res;\n  double w=Sqrt(cr*cr-h*h);\n  double L=getTime( normal(b-a) ,target-a)-w,  R=L+w*2.0;\n  \n  res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  res.push_back(a+base*R);\n\n  return res;\n}\n\nvecP getCrossCS(C cir,S s){\n  vecP tmp=getCrossCL(cir,s);\n  vecP res;\n  for(int i=0;i<(int)tmp.size();i++)\n    if( ccw(s.first,s.second, tmp[i] ) == 0)\n      res.push_back(tmp[i]);\n  return res;\n}\n\ndouble getArea(C c,P a,P b){\n  P cp=c.first;\n  double cr=c.second;\n  \n  P va=cp-a,  vb=cp-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=distSP( S(a,b) ,cp), res=0;\n  \n  if( eq(0, f ) )return 0;\n  if(A<cr+eps&&B<cr+eps)return f*0.5;\n  if(d>cr-eps)return cr*cr*PI*getArg(va,vb)/PI2;\n   \n  vecP u=getCrossCS(c, S(a,b) );\n  \n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getCrossArea(vecP t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\n\ndouble calcArea(const vecP &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++){\n    res+= cross( t[ (i+1)%n ],t[i] );\n  }\n  return abs(res)*0.5;\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\nvoid pr(P p,string str){\n  printf(\"%.10f %.10f\",p.real(),p.imag());\n  cout<<str;\n}\n\n\nint main(){\n\n  C a,b;\n  a.first=input();\n  cin>>a.second;\n\n  int n;\n  cin>>n;\n  while(n--){\n    P s=input();\n    P t=input();\n    vecP ans = getCrossCL( a, L(s,t));\n    if(ans.size()==1)ans.push_back(ans[0]);\n    sort(ans.begin(),ans.end());\n    pr(ans[0],\" \");\n    pr(ans[1],\"\\n\"); \n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reprrev(i,a,b) for(int i=b-1;i>=a;i--) // [a, b)\n#define reprev(i,n) reprrev(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n/* attention\n    long longのシフト演算には気をつけよう\n    タイポした時のデバッグが死ぬほどきつくなるので変数名は最低3字くらい使った方がいいかも\n    sizeは(int)とキャストしよう\n    cin.tie(0);\n    ios::sync_with_stdio(false);<- これら、printfとかと併用しない方が良さそう\n\n*/\n\nconst ll mod = 1e9+7;\n\nvoid chmod(ll &M){\n    if(M >= mod) M %= mod;\n    else if(M < 0){\n        M += (abs(M)/mod + 1)*mod;\n        M %= mod;\n    }\n}\n\nll modpow(ll x, ll n){\n    if(n==0) return 1;\n    ll res=modpow(x, n/2);\n\n    if(n%2==0) return res*res%mod;\n    else return res*res%mod*x%mod;\n}\n\nint getl(int i, int N) { return i==0? N-1:i-1; };\nint getr(int i, int N) { return i==N-1? 0:i+1; };\n\n\n// 線分 ab の偏角 返り値は[-π, π]\ndouble argument(const pair<double, double> &a, const pair<double, double> &b){\n    double ax=a.first, ay=a.second, bx=b.first, by=b.second;\n    return atan2(by-ay, bx-ax);\n}\n\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n\n\nlong double const EPS = (1e-10);\nbool equal(long double const a, long double const b) { return fabs(a-b) < EPS; }\n\nstruct Point {\n    long double x, y;\n    Point(long double _x=0, long double _y=0) : x(_x), y(_y) {}\n\n    Point operator + (Point const & p) const { return Point{x + p.x, y + p.y}; }\n    Point & operator += (Point const & p) { x += p.x; y += p.y; return *this; }\n    Point operator - (Point const & p) const { return Point{x - p.x, y - p.y}; }\n    Point & operator -= (Point const & p) { x -= p.x; y -= p.y; return *this; }\n    Point operator * (long double a) const { return Point{a*x, a*y}; }\n    Point & operator *= (long double a) { x *= a; y *= a; return *this; }\n    Point operator / (long double a) const { return Point{x/a, y/a}; }\n\n    long double norm() { return x*x + y*y; }\n    long double abs() { return sqrt(norm()); }\n    \n    bool operator < (Point const & p) const { return x != p.x ? x < p.x : y < p.y; }\n    bool operator == (Point const & p) const { return equal(x, p.x) && equal(y, p.y); }\n\n    void print() { cout << fixed << setprecision(15) << x << ' ' << y << \"\\n\"; }\n};\nusing Vector = Point;\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point _p1, Point _p2)\n        : p1(_p1), p2(_p2) {}\n};\nusing Line = Segment;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point _c, double _r)\n        : c(_c), r(_r) {}\n};\nusing Polygon = vector<Point>;\n\n// 内積 外積 外積は大きさを返す\n// https://mathtrain.jp/gaiseki\nlong double dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\nlong double cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n// ベクトルの直交判定　平行判定\nbool isOrthogonal(Vector const & a, Vector const & b) { return equal(dot(a, b), 0.0); }\nbool isOrthogonal(Point const & a1, Point const & a2, Point const & b1, Point const & b2) { return isOrthogonal(a1-a2, b1-b2); }\nbool isOrthogonal(Segment const & s1, Segment const & s2) { return isOrthogonal(s1.p1 - s1.p2, s2.p1 - s2.p2); }\nbool isParallel(Vector const & a, Vector const & b) { return equal(cross(a, b), 0); }\nbool isParallel(Point const & a1, Point const & a2, Point const & b1, Point const & b2) { return isParallel(a1-a2, b1-b2); }\nbool isParallel(Segment const & s1, Segment const & s2) { return isParallel(s1.p1-s1.p2, s2.p1-s2.p2); }\n\n// 線分 s に対する点 p の射影\nPoint project(Segment const & s, Point const & p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n// 線分 s を対称軸とした点 p の線対称点\nPoint reflect(Segment const & s, Point const & p) { return p + (project(s, p) - p) * 2.0; }\n\n// 線分p0-p1 に対して線分 p0-p2 が反時計回りなのか直線上なのか線分上なのか...\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2-p0-p1\nstatic const int ONLINE_FRONT = -2; // p0-p1-p2\nstatic const int ON_SEGMENT = 0;    // p0-p2-p1\nint ccw(Point const & p0, Point const & p1, Point const & p2){\n    Vector a = p1 - p0, b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// 線分 p1-p2 と線分 p3-p4 の交差判定（交点を持てば true）\nbool intersect(Point const & p1, Point const & p2, Point const & p3, Point const & p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment const & s1, Segment const & s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点と直線の距離\nlong double getDistanceLP(Line const & l, Point const & p) {\n    return abs(cross(l.p2-l.p1, p-l.p1) / (l.p2-l.p1).abs());\n}\n\n// 点と線分の距離\nlong double getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2-s.p1, p-s.p1) < 0.0) return (p-s.p1).abs();\n    if (dot(s.p1-s.p2, p-s.p2) < 0.0) return (p-s.p2).abs();\n    return getDistanceLP(s, p);\n}\n\n// 線分と線分の距離\nlong double getDistance(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 線分と線分の交点　交点がある時\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    long double d1 = abs(cross(base, s1.p1 - s2.p1));\n    long double d2 = abs(cross(base, s1.p2 - s2.p1));\n    long double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\n//　円 c と直線 l の交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    assert(getDistanceLP(l, c.c) < c.r + EPS);\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    long double base = sqrt(c.r*c.r - (pr-c.c).norm());\n    return make_pair(pr + e*base, pr - e*base);\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int cx, cy; cin >> cx >> cy;\n    int r; cin >> r;\n    Circle ci(Point(cx, cy), r);\n    int q; cin >> q;\n    while(q--) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n        Line l(Point(a, b), Point(c, d));\n        auto pa = getCrossPoints(ci, l);\n        if (pa.second < pa.first) swap(pa.first, pa.second);\n        cout << fixed << setprecision(15) << pa.first.x << \" \" << pa.first.y << \" \" << pa.second.x << \" \" << pa.second.y << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// 円と直線の交点\n//\n// verified:\n//   AOJ Course CGL_7_D Circles - Cross Points of a Circle and a Line\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=jp\n//\n\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n/* Point */\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n/* Circle */\nstruct Circle : Point {\n    DD r;\n    Circle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n    friend ostream& operator << (ostream &s, const Circle &c) {return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')';}\n};\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n    vector<Point> res;\n    DD d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < EPS) return vector<Point>();\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n    vector<Point> res;\n    DD d = abs(e - f);\n    if (d < EPS) return vector<Point>();\n    if (d > e.r + f.r + EPS) return vector<Point>();\n    if (d < abs(e.r - f.r) - EPS) return vector<Point>();\n    DD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n    if (e.r - abs(rcos) < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (f - e) / d;\n    Point p1 = e + dir * Point(rcos, rsin);\n    Point p2 = e + dir * Point(rcos, -rsin);\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, l);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\nbool cmp(const Point &a, const Point &b) { return make_pair(a.x, a.y) < make_pair(b.x, b.y); }\nint main() {\n    Circle c; cin >> c.x >> c.y >> c.r;\n    int Q; cin >> Q;\n    for (int _ = 0; _ < Q; ++_) {\n        Point x, y;\n        cin >> x.x >> x.y >> y.x >> y.y;\n        Line l(x, y);\n        vector<Point> cp = crosspoint(c, l);\n        if (cp.size() == 1) cp.push_back(cp[0]);\n        sort(cp.begin(), cp.end(), cmp);\n        cout << fixed << setprecision(10)\n            << cp[0].x << \" \" << cp[0].y << \" \" << cp[1].x << \" \" << cp[1].y << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nusing ld = long double;\nusing Point = std::complex<ld>;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    std::cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 1; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return -1; // a,b,c : clockwise\n    if (dot(b, c) < 0)\n        return 2; // c,a,b : on a line\n    if (norm(b) < norm(c))\n        return -2; // a,b,c : on a line\n    return 0;      // a,c,b : on a line\n}\n\nclass Line\n{\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Line l, Line m)\n{\n    return dot((l.a - l.b), (m.a - m.b));\n}\n\nclass Circle\n{\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// l:line, m:line が交点を持つか\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// l:line, s:segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// s:segment, t:segment\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// p が l:line 上に存在するか\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p)\n{\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// p から l に下ろした足との交点\nPoint proj(Line l, Point p)\n{\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// l:line, t:line の交点\nPoint is_ll(Line l, Line m)\n{\n    Point lv = l.b - l.a, mv = m.b - m.a;\n    assert(cross(lv, mv) != 0);\n    return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\n\n// p, l:line の距離\nld dist_lp(Line l, Point p)\n{\n    return abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n    if (isis_ss(s, t))\n        return 0;\n    return std::min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n// a, b の垂直二等分線. a -> b を90度反時計回り回転\nLine bisector(Point a, Point b)\n{\n    Point mid = (a + b) * Point(0.5, 0);\n    return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\n\n// 直線 l, m のなす角を求める\nld degree_ll(Line l, Line m)\n{\n    ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n    if (cos_shita < -1.0)\n        cos_shita = -1.0;\n    if (cos_shita > 1.0)\n        cos_shita = 1.0;\n    ld shita = acos(cos_shita);\n    // shita = sita * 180.0 / PI;\n    return shita;\n}\n\n// c1, c2 の交点\nstd::vector<Point> is_cc(Circle c1, Circle c2)\n{\n    std::vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps)\n        dfr = 0.0;\n    else if (dfr < 0.0)\n        return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.emplace_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0)\n        res.emplace_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nstd::vector<Point> is_lc(Circle c, Line l)\n{\n    std::vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps)\n    {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.emplace_back(proj(l, c.p) + len * nor);\n        res.emplace_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nstd::vector<Point> is_sc(Circle c, Line l)\n{\n    std::vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p))\n            res.emplace_back(p);\n    return res;\n}\n\n// p から c への接線\nstd::vector<Line> tangent_cp(Circle c, Point p)\n{\n    std::vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (std::isnan(l))\n    {\n        return ret;\n    }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.emplace_back(Line(p, p + v1));\n    if (l < eps)\n        return ret;\n    ret.emplace_back(Line(p, p + v2));\n    return ret;\n}\n\n// c1, c2 の共通接線\nstd::vector<Line> tangent_cc(Circle c1, Circle c2)\n{\n    std::vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps)\n    {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps)\n    {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        std::vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else\n    {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.emplace_back(Line(q1, q1 + v));\n        ret.emplace_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\nusing Polygon = std::vector<Point>;\n\nld area(const Polygon &p)\n{\n    ld res = 0;\n    int n = p.size();\n    for (int i = 0; i < n; i++)\n    {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\n// 0 => out\n// 1 => on\n// 2 => in\nint is_in_polygon(const Polygon &poly, Point p)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p))\n            return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(std::vector<Point> ps)\n{\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n// 凸包カット\nPolygon convex_cut(const Polygon &ps, Line l)\n{\n    int n = ps.size();\n    Polygon Q;\n    for (int i = 0; i < n; i++)\n    {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1)\n            Q.emplace_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.emplace_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(std::vector<Point> &ps, Point p)\n{\n    for (Point q : ps)\n        if (abs(q - p) < eps)\n            return;\n    ps.emplace_back(p);\n}\n\n// Voronoi 図: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3668810\n// polygon を ps でボロノイ分割する時の ps[index] に割り当てられる多角形\nPolygon voronoi(const Polygon &polygon, const std::vector<Point> &ps, int index)\n{\n    Polygon p = polygon;\n    int n = ps.size();\n    for (int j = 0; j < n; j++)\n    {\n        if (index == j)\n            continue;\n        Line l = bisector(ps[index], ps[j]);\n        p = convex_cut(p, l);\n    }\n    return p;\n}\n\nvoid solve_cgl_1_a()\n{\n    auto p1 = input_point(), p2 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        auto ret = proj(Line(p1, p2), p);\n        cout << fixed << setprecision(10) << ret.real() << \" \" << ret.imag() << endl;\n    }\n}\n\nvoid solve_cgl_1_b()\n{\n    auto p1 = input_point(), p2 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        auto ret = proj(Line(p1, p2), p);\n        cout << fixed << setprecision(10) << 2 * ret.real() - p.real() << \" \" << 2 * ret.imag() - p.imag() << endl;\n    }\n}\n\nvoid solve_cgl_1_c()\n{\n    auto p0 = input_point(), p1 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p2 = input_point();\n        int ret = ccw(p0, p1, p2);\n        if (ret == 1)\n            cout << \"COUNTER_CLOCKWISE\" << endl;\n        else if (ret == -1)\n            cout << \"CLOCKWISE\" << endl;\n        else if (ret == 2)\n            cout << \"ONLINE_BACK\" << endl;\n        else if (ret == -2)\n            cout << \"ONLINE_FRONT\" << endl;\n        else\n            cout << \"ON_SEGMENT\" << endl;\n    }\n}\n\nvoid solve_cgl_2_a()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line l(p0, p1), m(p2, p3);\n        if (!isis_ll(l, m))\n        {\n            cout << 2 << endl;\n        }\n        else if (eq(dot(l.b - l.a, m.b - m.a), 0))\n        {\n            cout << 1 << endl;\n        }\n        else\n        {\n            cout << 0 << endl;\n        }\n    }\n}\n\nvoid solve_cgl_2_b()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        cout << (isis_ss(s1, s2) ? 1 : 0) << endl;\n    }\n}\n\nvoid solve_cgl_2_c()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        auto ret = is_ll(s1, s2);\n        cout << fixed << setprecision(10) << ret.real() << \" \" << ret.imag() << endl;\n    }\n}\n\nvoid solve_cgl_2_d()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        cout << fixed << setprecision(10) << dist_ss(s1, s2) << endl;\n    }\n}\n\nvoid solve_cgl_3_a()\n{\n    Polygon p;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(input_point());\n    }\n    cout << fixed << setprecision(10) << area(p) << endl;\n}\n\nvoid solve_cgl_3_b()\n{\n    Polygon p;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(input_point());\n    }\n    auto cv = convex_hull(p);\n    cout << (eq(area(p), area(cv)) ? 1 : 0) << endl;\n}\n\nvoid solve_cgl_3_c()\n{\n    Polygon ps;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        int ret = is_in_polygon(ps, p);\n        cout << ret << endl;\n    }\n}\n\nvoid solve_cgl_4_a()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    auto ret = convex_hull(ps);\n    cout << ret.size() << endl;\n    for (auto p : ret)\n    {\n        cout << (int)p.real() << \" \" << (int)p.imag() << endl;\n    }\n}\n\n// cgl_4_b: 凸多角形の直径\n\nvoid solve_cgl_4_c()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point();\n        auto l = Line(p0, p1);\n        auto ret = convex_cut(ps, l);\n        cout << fixed << setprecision(10) << area(ret) << endl;\n    }\n}\n\n// cgl_5_a: 最近点対\n\n// cgl_6_a: 線分交差\n\nvoid solve_cgl_7_a()\n{\n    auto p0 = input_point();\n    ld r0, r1;\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ls = tangent_cc(c0, c1);\n    cout << ls.size() << endl;\n}\n\nvoid solve_cgl_7_d()\n{\n    auto p = input_point();\n    ld r;\n    cin >> r;\n    Circle c(p, r);\n    int q;\n    cin >> q;\n    cout << fixed << setprecision(10);\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point();\n        Line l(p0, p1);\n        auto ret = is_lc(c, l);\n        assert(ret.size() <= 2);\n        sort(ret.begin(), ret.end());\n        cout << ret[0].real() << \" \" << ret[0].imag();\n        if (ret.size() == 2)\n        {\n            cout << \" \" << ret[1].real() << \" \" << ret[1].imag();\n        }\n        cout << endl;\n    }\n}\n\nvoid solve_cgl_7_e()\n{\n    auto p0 = input_point();\n    ld r0, r1;\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ret = is_cc(c0, c1);\n    if ((int)ret.size() == 1)\n        ret.push_back(ret[0]);\n    sort(ret.begin(), ret.end());\n    cout << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n}\n\nvoid solve_cgl_7_f()\n{\n    auto p = input_point();\n    auto p0 = input_point();\n    ld r0;\n    cin >> r0;\n    Circle c(p0, r0);\n    auto ls = tangent_cp(c, p);\n    vector<Point> ret;\n    for (auto l : ls)\n    {\n        auto ps = is_lc(c, l);\n        assert((int)ps.size() == 1);\n        ret.push_back(ps[0]);\n    }\n    sort(ret.begin(), ret.end());\n    cout << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n}\n\nvoid solve_cgl_7_g()\n{\n    ld r0, r1;\n    auto p0 = input_point();\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ls = tangent_cc(c0, c1);\n    vector<Point> ret;\n    for (auto l : ls)\n    {\n        auto ps = is_sc(c0, l);\n        assert((int)ps.size() == 1);\n        ret.push_back(ps[0]);\n    }\n    sort(ret.begin(), ret.end());\n    for (auto p : ret)\n    {\n        cout << fixed << setprecision(10) << p.real() << \" \" << p.imag() << endl;\n    }\n}\n\n// cgl_7_h: 円と多角形の共通部分(は?)\n// 参考実装: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2114290\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    solve_cgl_7_d();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-7)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\tcout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tdouble base = sqrt(r * r - pr.norm());\n\n\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * base;\n\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * base;\n\tif (equals(ans1.x, ans2.x)) {\n\t\tif (ans1.y < ans2.y) {\n\t\t\treturn make_pair(ans1, ans2);\n\t\t} else {\n\t\t\treturn make_pair(ans2, ans1);\n\t\t}\n\t}else if (ans1.x < ans2.x) {\n\t\treturn make_pair(ans1, ans2);\n\t} else {\n\t\treturn make_pair(ans2, ans1);\n\t}\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nint CommonTangent(Circle c1, Circle c2) {\n  if (c1.r < c2.r) swap(c1, c2);\n  double d = Distance(c1.p, c2.p);\n  if (c1.r + c2.r < d) return 4;\n  if (eq(c1.r + c2.r, d)) return 3;\n  if (c1.r - c2.r < d) return 2;\n  if (eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// ↓ｺﾚ\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nint main() {\n  Circle c;\n  cin >> c.p >> c.r;\n\n  int q;\n  cin >> q;\n  while (q--) {\n    Line l;\n    cin >> l;\n    PointPoint ans = Crosspoint(c, l);\n    if (ans.second < ans.first) swap(ans.first, ans.second);\n    cout << fixed << setprecision(10) << ans.first << \" \" << ans.second << endl;\n  }\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (const auto &i : pos[0]) {\n    for (const auto &j : pos[1]) {\n      if (Distance(i, j) < d) {\n        d = Distance(i, j);\n        res = PointPoint(i, j);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  PointPoint res = ClosestPairUtil(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Points p(n);\n//   for (auto &i : p) cin >> i;\n//   sort(p.begin(), p.end());\n//   PointPoint pp = ClosestPair(p);\n//   cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n//   // cerr << pp.first << \" \" << pp.second << endl;\n// }\n\n// CommonTangent(C, C)\n// https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/7/CGL_7_A\n// int main() {\n//   Circle c1, c2;\n//   cin >> c1.p >> c1.r;\n//   cin >> c2.p >> c2.r;\n//   cout << CommonTangent(c1, c2) << endl;\n// } // !!!!!!!!!!!!!!!!!!!!!! AC !!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma region Geometry\nconst double EPS=1e-8,PI=acos(-1);\ninline bool EQ(double a,double b){return fabs(b-a)<EPS;}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) const {return Point{x+p.x,y+p.y};}\n    Point operator-(Point p) const {return Point{x-p.x,y-p.y};}\n    Point operator*(double t) const {return Point{x*t,y*t};}\n    Point operator*(Point p) const {return Point{x*p.x-y*p.y,x*p.y+y*p.x};}\n    Point operator/(double t) const {return Point{x/t,y/t};}\n    bool operator<(const Point &p) const {\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator==(const Point &p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n    friend istream &operator>>(istream &is,Point &p){\n        is >> p.x >> p.y;\n        return is;\n    }\n    friend ostream &operator<<(ostream &os,Point p){\n        os << fixed << setprecision(10) << p.x << ' ' << p.y;\n        return os;\n    }\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point a,Point b):a(a),b(b){}\n    friend istream &operator>>(istream &is,Line &l){\n        is >> l.a >> l.b;\n        return is;\n    }\n    friend ostream &operator<<(ostream &os,Line l){\n        os << l.a << \" to \" << l.b;\n        return os;\n    }\n};\n\nstruct Segment:Line{\n    Segment(){}\n    Segment(Point a,Point b):Line(a,b){}\n};\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c,double r):c(c),r(r){}\n    friend istream &operator>> (istream &is,Circle &c){\n        is >> c.c >> c.r;\n        return is;\n    }\n    friend ostream &operator<<(ostream &os,Circle &c){\n        os << c.c << ' ' << c.r;\n        return os;\n    }\n};\n\ntypedef vector<Point> Polygon;\nistream &operator>>(istream &is,Polygon &p){\n    for (int i=0;i<p.size();++i) is >> p[i];\n    return is;\n}\n\ndouble dot(const Point &a,const Point &b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(const Point &a,const Point &b){\n    return a.x*b.y-a.y*b.x;\n}\ndouble norm(const Point &a){\n    return a.x*a.x+a.y*a.y;\n}\ndouble abs(const Point &a){\n    return sqrt(norm(a));\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A\nPoint proj(const Line &l,const Point &p){\n    double t=dot(p-l.a,l.b-l.a)/norm(l.b-l.a);\n    return l.a+(l.b-l.a)*t;\n}\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B\nPoint refl(const Line &l,const Point &p){\n    return p+(proj(l,p)-p)*2.0;\n}\n\nPoint rotate(const Point &p,double theta){\n    return Point(cos(theta)*p.x-sin(theta)*p.y,sin(theta)*p.x+cos(theta)*p.y);\n}\ndouble arg(const Point &p){\n    return atan2(p.y,p.x);\n}\ndouble get_angle(const Point &a,const Point &b,const Point &c){\n    const Point v=b-a,w=c-b;\n    double alpha=arg(v),beta=arg(w);\n    if (alpha>beta) swap(alpha,beta);\n    double theta=beta-alpha;\n    return min(theta,2*PI-theta);\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\nint ccw(const Point &a,Point b,Point c){\n    b=b-a,c=c-a;\n    if (cross(b,c)>EPS) return COUNTER_CLOCKWISE;\n    if (cross(b,c)<-EPS) return CLOCKWISE;\n    if (dot(b,c)<-EPS) return ONLINE_BACK;\n    if (norm(b)<norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\nbool orthogonal(const Point &a,const Point &b){\n    return EQ(dot(a,b),0.0);\n}\nbool orthogonal(const Point &a,const Point &b,const Point &c,const Point &d){\n    return orthogonal(b-a,d-c);\n}\nbool orthogonal(const Line &l,const Line &m){\n    return EQ(dot(l.b-l.a,m.b-m.a),0.0);\n}\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\nbool parallel(const Point &a,const Point &b){\n    return EQ(cross(a,b),0.0);\n}\nbool parallel(const Point &a,const Point &b,const Point &c,const Point &d){\n    return parallel(b-a,d-c);\n}\nbool parallel(const Line &l,const Line &m){\n    return EQ(cross(l.b-l.a,m.b-m.a),0.0);\n}\n\nbool intersect(const Line &l,const Point &p){\n    return abs(ccw(l.a,l.b,p))!=1;\n}\nbool intersect(const Line &l,const Line &m){\n    return abs(cross(l.b-l.a,m.b-m.a)>EPS||abs(cross(l.b-l.a,m.b-m.a))<EPS);\n}\nbool intersect(const Line &l,const Segment &s){\n    return cross(l.b-l.a,s.a-l.a)*cross(l.b-l.a,s.b-l.a)<EPS;\n}\nbool intersect(const Segment &s,const Point &p){\n    return ccw(s.a,s.b,p)==0;\n}\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B\nbool intersect(const Segment &s,const Segment &t){\n    return ccw(s.a,s.b,t.a)*ccw(s.a,s.b,t.b)<=0&&ccw(t.a,t.b,s.a)*ccw(t.a,t.b,s.b)<=0;\n}\nbool intersect(const Circle &c,const Line &l){\n    return (norm(proj(l,c.c)-c.c)-c.r*c.r)<=EPS;\n}\nint intersect(const Circle &c,const Segment &s){\n    if (norm(proj(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n    double d1=abs(c.c-s.a),d2=abs(c.c-s.b);\n    if (d1<c.r+EPS&&d2<c.r+EPS) return 0;\n    if (d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS) return 1;\n    const Point h=proj(s,c.c);\n    if (dot(s.a-h,s.b-h)<0) return 2;\n    return 0;\n}\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A\nint intersect(Circle c,Circle d){\n    if (c.r<d.r) swap(c,d);\n    double dist=abs(c.c-d.c);\n    if (c.r+d.r<dist) return 4;\n    if (EQ(c.r+d.r,dist)) return 3;\n    if (c.r-d.r<dist) return 2;\n    if (EQ(c.r-d.r,dist)) return 1;\n    return 0;\n}\n\ndouble distance(const Point &a,const Point &b){\n    return abs(b-a);\n}\ndouble distance(const Line &l,const Point &p){\n    return abs(p-proj(l,p));\n}\ndouble distance(const Line &l,const Line &m){\n    return intersect(l,m)?0:distance(l,m.a);\n}\ndouble distance(const Segment &s,const Point &p){\n    Point h=proj(s,p);\n    return intersect(s,h)?abs(h-p):min(abs(s.a-p),abs(s.b-p));\n}\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D\ndouble distance(const Segment &s,const Segment &t){\n    if (intersect(s,t)) return 0;\n    return min({distance(s,t.a),distance(s,t.b),distance(t,s.a),distance(t,s.b)});\n}\ndouble distance(const Line &l,const Segment &s){\n    return intersect(l,s)?0:min(distance(l,s.a),distance(l,s.b));\n}\n\nPoint crosspoint(const Line &l,const Line &m){\n    double d1=cross(l.b-l.a,m.b-m.a),d2=cross(l.b-l.a,l.b-m.a);\n    if (EQ(abs(d1),0.0)&&EQ(abs(d2),0.0)) return m.a;\n    return m.a+(m.b-m.a)*d2/d1;\n}\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C\nPoint crosspoint(const Segment &s,const Segment &t){\n    assert(intersect(s,t));\n    return crosspoint(Line(s),Line(t));\n}\nvector<Point> crosspoint(const Circle &c,const Line &l){\n    Point pr=proj(l,c.c);\n    Point e=(l.b-l.a)/abs(l.b-l.a);\n    if (EQ(distance(l,c.c),c.r)) return {pr};\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return {pr-e*base,pr+e*base};\n}\nvector<Point> crosspoint(const Circle &c,const Segment &s){\n    Line l=Line(s);\n    assert(intersect(c,l));\n    auto res=crosspoint(c,l);\n    if (intersect(c,l)==2) return res;\n    if (dot(l.a-res[0],l.b-res[0])<0) res.emplace_back(res[0]);\n    else res.pop_back();\n    return res;\n}\nvector<Point> crosspoint(const Circle &c,const Circle &d){\n    double dist=abs(c.c-d.c);\n    double a=acos((c.r*c.r+dist*dist-d.r*d.r)/(2*c.r*dist));\n    double t=arg(d.c-c.c);\n    Point p1=c.c+Point(cos(t+a),sin(t+a))*c.r,p2=c.c+Point(cos(t-a),sin(t-a))*c.r;\n    return {p1,p2};\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_C\nCircle circumcenter(Point a,Point b,const Point &c){\n    a=(a-c)*0.5;\n    b=(b-c)*0.5;\n    Point center=c+crosspoint(Line(a,a*Point{1,1}),Line{b,b*Point{1,1}});\n    return Circle{center,abs(c-center)};\n}\nvector<Point> center_given_radius(const Point &a,const Point &b,const double &r){\n    Point m=(b-a)*0.5;\n    double d1=abs(m);\n    vector<Point> res;\n    if (EQ(d1,0.0)||d1>r) return res;\n    double d2=sqrt(r*r-d1*d1);\n    Point n=m*Point{0.0,1.0}*d2/d1;\n    res.emplace_back(a+m+n);\n    if (d2>EPS) res.emplace_back(a+m-n);\n    return res;\n}\n\nbool convex(const Polygon &p){\n    int n=p.size();\n    for (int i=0;i<n;++i){\n        if (ccw(p[(i+n-1)%n],p[i],p[(i+1)%n])==-1){\n            return false;\n        }\n    }\n    return true;\n}\n\nPolygon convex_hull(Polygon p){\n    int n=p.size(),k=0;\n    if (n<=2) return p;\n    sort(p.begin(),p.end());\n    Polygon ch(2*n);\n    for (int i=0;i<n;ch[k++]=p[i++]){\n        while(k>=2&&cross(ch[k-1]-ch[k-2],p[i]-ch[k-1])<EPS) --k;\n    }\n    for (int i=n-2,t=k+1;i>=0;ch[k++]=p[i--]){\n        while(k>=t&&cross(ch[k-1]-ch[k-2],p[i]-ch[k-1])<EPS) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\n#pragma endregion\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Circle c; cin >> c;\n    int q; cin >> q;\n    for (;q--;){\n        Line l; cin >> l;\n        vector<Point> ans=crosspoint(c,l);\n        sort(ans.begin(),ans.end());\n        if (ans.size()==1) ans.emplace_back(ans[0]);\n        for (int i=0;i<2;++i) cout << ans[i] << (i==1?'\\n':' ');\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  cgl_7_d.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Oct 23 00:28:22 2017\n//\n#include <cmath>\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define EPS 1e-10\n#define equals(x, y) (fabs(x - y) < EPS)\n\nstruct vector_t {\n  double x;\n  double y;\n\n  vector_t(double a, double b) : x(a), y(b)\n  {\n  }\n\n  double norm2()\n  {\n    return x * x + y * y;\n  }\n\n  double norm()\n  {\n    return sqrt(norm2());\n  }\n\n  double dot(vector_t a)\n  {\n    return x * a.x + y * a.y;\n  }\n\n  double cross(vector_t a)\n  {\n    return x * a.y - y * a.x;\n  }\n\n  vector_t operator*(double a)\n  {\n    return vector_t(a * x, a * y);\n  }\n\n  vector_t operator/(double a)\n  {\n    return vector_t(x / a, y / a);\n  }\n};\n\nstruct point_t {\n  double x;\n  double y;\n\n  point_t operator+(const point_t a)\n  {\n    return point_t({x + a.x, y + a.y});\n  }\n\n  void println()\n  {\n    cout << fixed << setprecision(10) << x << \" \" << y << endl;\n  }\n\n  void print()\n  {\n    cout << fixed << setprecision(10) << x << \" \" << y;\n  }\n\n  point_t operator+(const vector_t vec)\n  {\n    return point_t({x + vec.x, y + vec.y});\n  }\n\n  point_t operator-(const vector_t vec)\n  {\n    return point_t({x - vec.x, y - vec.y});\n  }\n\n  vector_t operator-(const point_t p)\n  {\n    return vector_t({x - p.x, y - p.y});\n  }\n\n  point_t project(point_t p1, point_t p2)\n  {\n    vector_t vec1(x - p1.x, y - p1.y);\n    vector_t vec2(p2.x - x, p2.y - y);\n    return point_t({x, y}) + vec1 * (vec1.dot(vec2) / vec1.norm2());\n  }\n\n  point_t reflect(point_t p1, point_t p2)\n  {\n    point_t proj = project(p1, p2);\n    return p2 + (proj - p2) * 2.0;\n  }\n};\n\nenum pos_t {\n  CCLOCKWISE = -1,\n  CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = -2,\n  ON_SEGMENT = 0,\n};\n\npos_t ccw(point_t p0, point_t p1, point_t p2)\n{\n  if ((p1 - p0).cross(p2 - p0) > EPS) {\n    return CCLOCKWISE;\n  } else if ((p1 - p0).cross(p2 - p0) < -EPS) {\n    return CLOCKWISE;\n  } else if ((p1 - p0).dot(p2 - p0) < -EPS) {\n    return ONLINE_BACK;\n  } else {\n    if ((p1 - p0).norm2() < (p2 - p0).norm2()) {\n      return ONLINE_FRONT;\n    } else {\n      return ON_SEGMENT;\n    }\n  }\n}\n\nbool intersection(point_t p0, point_t p1, point_t p2, point_t p3)\n{\n  return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0) && (ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nstruct segment_t {\n  point_t a;\n  point_t b;\n\n  double distance(point_t p0)\n  {\n    if ((b - a).dot(p0 - a) < 0.0) {\n      return (p0 - a).norm();\n    } else if ((a - b).dot(p0 - b) < 0.0) {\n      return (p0 - b).norm();\n    } else {\n      return fabs((b - a).cross(p0 - a) / (b - a).norm());\n    }\n  }\n};\n\nstruct circle_t {\n  point_t p;\n  double r;\n\n  vector<point_t> cross_points(point_t p0, point_t p1)\n  {\n    vector_t v = p1 - p0;\n    vector_t e = v / v.norm();\n    point_t pproject = p0.project(p1, p);\n    double ratio = sqrt(r * r - (pproject - p).norm2());\n    return {pproject + e * ratio, pproject - e * ratio};\n  }\n};\n\nint32_t main()\n{\n  double cx, cy, r;\n  cin >> cx >> cy >> r;\n  circle_t c({{cx, cy}, r});\n\n  uint32_t q;\n  cin >> q;\n  for (uint32_t i = 0; i < q; i++) {\n    double x, y;\n    cin >> x >> y;\n    point_t p0({x, y});\n    cin >> x >> y;\n    point_t p1({x, y});\n    vector<point_t> points = c.cross_points(p1, p0);\n    points[0].print();\n    cout << \" \";\n    points[1].println();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\n\nclass Point {\npublic:\n\tld x, y;\n\tPoint() {\n\t\tx = y = 0.0;\n\t}\n\tPoint(ld x, ld y) :\n\t\t\tx(x), y(y) {\n\t}\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(ld a) {\n\t\treturn Point(x * a, y * a);\n\t}\n\tPoint operator /(ld a) {\n\t\treturn Point(x / a, y / a);\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c;\n\tld r;\n\tCircle(Point c = Point(), ld r = 0.0) :\n\t\t\tc(c), r(r) {\n\t}\n};\n\nld dot(Point p1, Point p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\n\nld norm(Point p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nld abs(Point p) {\n\treturn sqrt(norm(p));\n}\n\nPoint project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tld r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Segment l) {\n\tPoint pr = project(l, c.c);\n\tPoint e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tld base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n\n\tint cx, cy, r;\n\tscanf(\"%d %d %d\", &cx, &cy, &r);\n\tPoint cp(cx, cy);\n\tCircle c(cp, r);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint p1x, p1y, p2x, p2y;\n\t\tscanf(\"%d %d %d %d\", &p1x, &p1y, &p2x, &p2y);\n\t\tPoint p1(p1x, p1y);\n\t\tPoint p2(p2x, p2y);\n\t\tSegment s(p1, p2);\n\t\tpair<Point, Point> pair = getCrossPoints(c, s);\n\n\t\tbool firstFirst = true;\n\n\t\tif (pair.first.x > pair.second.x) {\n\t\t\tfirstFirst = false;\n\t\t} else if (pair.first.x == pair.second.x) {\n\t\t\tif (pair.first.y > pair.second.y) {\n\t\t\t\tfirstFirst = false;\n\t\t\t}\n\t\t}\n\n\t\tif (firstFirst) {\n\t\t\tcout << fixed << setprecision(8) << pair.first.x << \" \" << pair.first.y << \" \" << pair.second.x << \" \" << pair.second.y << endl;\n\t\t} else {\n\t\t\tcout << fixed << setprecision(8) << pair.second.x << \" \" << pair.second.y << \" \" << pair.first.x << \" \" << pair.first.y << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\n/*????????????(??§?¨?)????????????*/\nclass Vector\n{\npublic:\n\tdouble x,y;\n\tVector(double x=0,double y=0):x(x),y(y){}\n\t\n\tVector operator + (Vector p){return Vector(x+p.x,y+p.y);}\n\tVector operator - (Vector p){return Vector(x-p.x,y-p.y);}\n\tVector operator * (double a){return Vector(x*a,y*a);}\n\tVector operator / (double a){return Vector(x/a,y/a);}\n\t\n\tdouble abs(){return sqrt(norm());}\n\tdouble norm(){return x*x+y*y;}\n\t\n\tbool operator <  (const Vector &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator == (const Vector &p)const{return fabs(x-p.x)<EPS && fabs(y-p.y<EPS);}\n};\n\n/*??´???????????????*/\nclass Line\n{\npublic:\n\tVector p,q;\n\tLine(Vector p=Vector(),Vector q=Vector()):p(p),q(q){}\n};\n\n/*???????????????*/\nclass Circle\n{\npublic:\n\tVector c;\n\tdouble r;\n\tCircle(Vector c=Vector(),double r=0.0):c(c),r(r){}\n};\n\n/*???????????????????¬????????????§??????*/\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-b.x*a.y;}\n\n/*??´??????????°???±*/\nVector project(Line l,Vector p)\n{\n\tVector base=l.q-l.p;\n\tdouble r=dot(p-l.p,base)/base.norm();\n\treturn l.p+base*r;\n}\n\n/*????????¨??????????????¢????????????*/\nint ccw(Vector p0,Vector p1,Vector p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;//???????¨???????\n\tif(cross(a,b)<-EPS)return -1;//????¨???????\n\tif(dot(a,b)<-EPS)return 2;//p0?????????\n\tif(a.norm()<b.norm())return -2;//p1????\\\\\n\treturn 0;//?????????\n}\n\n/*?????????????????????*/\nbool intersect(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n\treturn (ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n}\n\n/*??´?????¨??´????????????*/\nVector LLcross(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n\tdouble d1=cross(p3-p2,p0-p2);\n\tdouble d2=cross(p3-p2,p1-p3);\n\treturn p0+(p1-p0)*(d1/(d1+d2));\n}\n\n/*?????¨??´????????????*/\npair<Vector,Vector> CLcross(Circle c,Line l)\n{\n\tVector pr=project(l,c.c);\n\tVector e=(l.q-l.p)/(l.q-l.p).abs();\n\tdouble base=sqrt(c.r*c.r-(pr-c.c).norm());\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\n/*?????¨????????????*/\npair<Vector,Vector> CCcross(Circle c,Circle d)\n{\n\t\n}\n////////////////////////////////////////////////\nint main()\n{\n\tCircle c;\n\tcin>>c.c.x>>c.c.y>>c.r;\n\tint n;cin>>n;\n\tLine l;\n\tREP(i,n)\n\t{\n\t\tcin>>l.p.x>>l.p.y>>l.q.x>>l.q.y;\n\t\tVector a=CLcross(c,l).first;\n\t\tVector b=CLcross(c,l).second;\n\t\tif(a<b)cout<<a.x<<\" \"<<a.y<<\" \"<<b.x<<\" \"<<b.y<<endl;\n\t\telse cout<<b.x<<\" \"<<b.y<<\" \"<<a.x<<\" \"<<a.y<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; } // cross product\n    db operator * (const point &p){ return x * p.x + y * p.y; } // dot product\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n    point unit(){ db k = (*this).len(); return point(x / k, y / k); }\n};\n\npoint err = point(INF_d, INF_d);\ndb rad(point A, point B){ return atan2((A ^ B), (A * B)); }// the ang(in rad) of two vectors A and B\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){ // find the distance of cloest pair of points in p\n//please make sure that p is sorted by x coordinate | sort(p, p + n, cmpxy);\n//this is nlognlogn, if need nlogn, replace the sort with a merge sort.\n    if (r - l <= 5){ db cloest = INF_d;\n        for (int i = l; i < r; i++) for (int j = i + 1; j < r; j++) cloest = min(cloest, (p[i] - p[j]).len());\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1; db cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid, r));\n        vector<point> v; v.clear();\n        for (int i = l; i < r; i++) if (fabs(p[i].x - p[mid].x) <= cloest) v.pb(p[i]); sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++) for (int j = i + 1; j < SZ(v) && dcmp(v[j].y - v[i].y - cloest) < 0; j++)\n                cloest = min(cloest, (v[i] - v[j]).len());\n        return cloest;\n    }\n}\n\nstruct circle{\n    point o; double r;\n    circle(){}\n    circle(point a, double b): o(a), r(b){}\n    void read(){\n        o.read(), scanf(\"%lf\", &r);\n    }\n    int inside(point p){ // 1: inside, 2: on the circle, 0: outside\n        int sgn = dcmp((o - p).len() - r) < 0; if (sgn < 0) return 1; if (!sgn) return 2; return 0;\n    }\n};\n\nint check_CC(circle C1, circle C2){ // return the number of common tangents of two circles C1 and C2\n//4: xiang_li, 3: wai_qie, 2: xiang_jiao, 1: nei_qie, 0: nei_han\n    db d =(C1.o - C2.o).len();\n    if (dcmp(d - C1.r - C2.r) > 0) return 4;\n    if (!dcmp(d - C1.r - C2.r)) return 3;\n    if (!dcmp(d - fabs(C1.r - C2.r))) return 1;\n    if (dcmp(d - fabs(C1.r - C2.r)) > 0 && dcmp(d - C1.r - C2.r) < 0) return 2;\n    return 0;\n}\n\nvector<point> inter_CL(circle C, point A, point B){ // return the intersection of a circle and a line\n// the result give in the direction from A -> B\n    point p_proj = proj_SP(A, B, C.o);\n    db d = C.r * C.r - (C.o - p_proj).len2();\n    if (dcmp(d) < 0) return {};\n    point delta = (B - A).unit() * sqrt(max((db)0, d)); return {p_proj - delta, p_proj + delta};\n}\n\nvector<point> inter_CL(circle C, line L){ // the same as the former one, but argument is different\n    return inter_CL(C, L.p[0], L.p[1]);\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\ncircle cir[2];\n\nint main(){\n    cir[0].read();\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        x.read(), y.read();\n        vector<point> itp = inter_CL(cir[0], x, y);\n        sort(itp.begin(), itp.end(), cmpxy);\n        printf(\"%.10f %.10f %.10f %.10f\\n\", itp[0].x, itp[0].y, itp[1].x, itp[1].y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\ndouble getDistanceLP(Line, Point);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q;\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\n\t\tif (ans.first.x < ans.second.x) {\n\t\t\tans.first.show();\n\t\t\tcout << \" \";\n\t\t\tans.second.show();\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tif (equals(ans.first.x - ans.second.x, 0.0)) {\n\t\t\t\tif (ans.first.y < ans.second.y) {\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans.second.show();\n\t\t\t\tcout << \" \";\n\t\t\t\tans.first.show();\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\n//END CUT HERE\n\n//Projection\nsigned AOJ_CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned AOJ_CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned AOJ_CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned AOJ_CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned AOJ_CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//cross point\nsigned AOJ_CGL2C(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<getCrossPointSS(Segment(p0,p1),Segment(p2,p3))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=jp\n*/\n\n//distanceSS\nsigned AOJ_CGL2D(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    printf(\"%.12f\\n\",getDistanceSS(Segment(p0,p1),Segment(p2,p3)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=jp\n*/\n\n//area of Polygon\nsigned AOJ_CGL3A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.1f\\n\",area(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=jp\n*/\n\n\n//isConvex\nsigned AOJ_CGL3B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<isConvex(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=jp\n*/\n\n\n\n//contains\nsigned AOJ_CGL3C(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  int q;\n  cin>>q;\n  while(q--){\n    Point r;\n    cin>>r;\n    cout<<contains(p,r)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n*/\n\n\n//convex hull\nsigned AOJ_CGL4A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=convex_hull(p);\n  cout<<q.size()<<endl;\n  for(Point v:q) cout<<v.x<<\" \"<<v.y<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n*/\n\n//diameter of Polygon\nsigned AOJ_CGL4B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n*/\n\n//convexCut:\nsigned AOJ_CGL4C(){\n  int n;\n  cin>>n;\n  Polygon g(n);\n  for(int i=0;i<n;i++) cin>>g[i];\n  Polygon p=andrewScan(g);\n  int q;\n  cin>>q;\n  while(q--){\n    Line l;\n    cin>>l.p1>>l.p2;\n    printf(\"%.12f\\n\",area(convexCut(p,l)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=jp\n*/\n\n\n//intersectCC\nsigned AOJ_CGL7A(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  cout<<intersectCC(c1,c2)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\n*/\n\n\n//getCrossPointCL\nsigned AOJ_CGL7D(){\n  Circle c;\n  int q;\n  cin>>c>>q;\n  while(q--){\n    Line l;\n    cin>>l;\n    auto pp=getCrossPointCL(c,l);\n    if(pp[0]<pp[1]) swap(pp[0],pp[1]);\n    cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=jp\n*/\n\n//Common Tangent\nsigned AOJ_CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  //AOJ_CGL4B();\n  //AOJ_CGL4C();\n\n  \n  //AOJ_CGL7A();\n  AOJ_CGL7D();\n  //AOJ_CGL7E();\n  //AOJ_CGL7G();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < (EPS))\n#define SQR(n) ((n) * (n))\n\n#define COUNTER_CLOCKWISE (1)\n#define CLOCKWISE (-1)\n#define ONLINE_BACK (2)\n#define ONLINE_FRONT (-2)\n#define ON_SEGMENT (0)\n\nstruct Point \n{\n  double x, y;\n  \n  Point() {}\n  \n  Point(double x, double y) : x(x), y(y) {}\n  \n  void input() { scanf(\"%lf %lf\", &x, &y); }\n  void output() { printf(\"%.10f %.10f\", x, y); }\n  void outputspace() { output(); putchar(' '); }\n  void outputln() { output(); putchar('\\n'); }\n  \n  double abs() { return (sqrt(norm())); }\n  double norm() { return (x * x + y * y); }\n  \n  Point operator + (Point d) { return (Point(x + d.x, y + d.y)); }\n  Point operator - (Point d) { return (Point(x - d.x, y - d.y)); }\n  Point operator - () { return (Point(-x, -y)); }\n  Point operator * (double a) { return (Point(x * a, y * a)); }\n  Point operator / (double a) { return (Point(x / a, y / a)); }\n  \n  bool operator < (Point d) {\n    if(x < d.x) return (true);\n    if(x > d.x) return (false);\n    return (y < d.y);\n  }\n  bool operator > (Point d) {\n    if(x > d.x) return (true);\n    if(x < d.x) return (false);\n    return (y > d.y);\n  }\n\n};\n\nstruct Segment\n{\n  Point p1, p2;\n  \n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\n  void input() { p1.input(); p2.input(); }\n  \n};\n\nstruct Circle\n{\n  Point c;\n  double r;\n  Circle() {}\n  Circle(Point c, double r) : c(c), r(r) {}\n  \n  void inputcr() { c.input(); scanf(\"%lf\", &r); }\n  \n};\n\ntypedef pair < Point, Point > TwoPoint;\ntypedef Point Vector;\ntypedef vector < Point > Polygon;\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b)\n{\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n  return (a.x * b.y - a.y * b.x);\n}\n\nPoint project(Line l, Point p)\n{\n  Vector base = l.p2 - l.p1;\n  return (l.p1 + base * (dot(p - l.p1, base) / base.norm()));\n}\n\nPoint reflect(Line l, Point p)\n{\n  return (-p + project(l, p) * 2.0);\n}\n\n\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0, b = p2 - p0;\n  \n  if(cross(a, b) > EPS) return (COUNTER_CLOCKWISE);\n  if(cross(a, b) < -EPS) return (CLOCKWISE);\n  if(dot(a, b) < -EPS) return (ONLINE_BACK);\n  if(a.norm() < b.norm()) return (ONLINE_FRONT);\n  \n  return (ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n  return (intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\n\ndouble getDistanceLP(Line l, Point p)\n{\n  return (abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return ((p - s.p1).abs());\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return ((p - s.p2).abs());\n  return (getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n  double ans;\n\n  if(intersect(s1, s2)) {\n    ans = 0.0;\n  } else {\n    ans = min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n    ans = min(ans, min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)));\n  }\n\n  return (ans);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  double d1 = getDistanceLP(s2, s1.p1);\n  double d2 = getDistanceLP(s2, s1.p2);\n  \n  return (s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2)));\n}\n\nbool intersect(Circle c, Line l)\n{\n  return (getDistanceLP(l, c.c) - c.r > EPS);\n}\n\nTwoPoint getCrossPoints(Circle c, Line l)\n{\n  Vector pr, e;\n  double base;\n  if(intersect(c, l)) abort();\n  \n  pr = project(l, c.c);\n  base = sqrt(SQR(c.r) - (pr - c.c).norm());\n  e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  \n  return (make_pair(pr + (e * base), pr - (e * base)));\n}\n\nmain()\n{\n  int n;\n  Circle c;\n  \n  c.inputcr(); cin >> n;\n  for(int i = 0; i < n; i++) {\n    Line l;\n    TwoPoint tp;\n    \n    l.input();\n    tp = getCrossPoints(c, l);\n\n    if(tp.first > tp.second) swap(tp.first, tp.second);\n    tp.first.outputspace(); tp.second.outputln();\n  }\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define chmax(a, b) a = (a >= b ? a : b)\n#define chmin(a, b) a = (a <= b ? a : b)\n#define sz(v) (int)v.size()\n#define inf (int)(1e9+7)\n#define ceil(a, b) a / b + !!(a % b)\nll pow(ll a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\n\nusing P = complex<double>;\nstruct S { P p1, p2; };\ndouble dot(P a, P b) { return real(conj(a) * b); }\ndouble cross(P a, P b) { return imag(conj(a) * b); }\nconst double eps = 1e-8;\n\ndouble norm(P a) { return real(a) * real(a) + imag(a) * imag(a); }\ndouble abs(P a) { return sqrt(norm(a)); }\n\nP projection(P p, P p1, P p2) {\n    double t = dot(p - p1, p2 - p1) / abs(p2 - p1);\n    return p1 + t / abs(p2 - p1) * (p2 - p1);\n}\nint main() {\n    double x, y, r;\n    cin >> x >> y >> r;\n    P p = P(x, y);\n    \n    int query;\n    cin >> query;\n    \n    while (query--) {\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        P p1 = P(x1, y1), p2 = P(x2, y2);\n        \n        double d = abs(cross(p - p2, p1 - p2)) / abs(p1 - p2);\n        \n        double sca = sqrt(r * r - d * d);\n        \n        P r = projection(p, p1, p2);\n        \n        P p3 = r + sca * (p2 - p1) / abs(p2 - p1);\n        P p4 = r - sca * (p2 - p1) / abs(p2 - p1);\n        if (real(p3) > real(p4)) swap(p3, p4);\n        // cout << real(p3) << \" \" << imag(p3) << \" \" << real(p4) << \" \" << imag(p4) << endl;\n        if (real(p3) >= real(p4) && imag(p3) > imag(p4)) swap(p3, p4);\n        \n        cout << fixed << setprecision(10);\n        cout << real(p3) << \" \" << imag(p3) << \" \" << real(p4) << \" \" << imag(p4) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{\n    L(const P &a, const P &b){\n        push_back(a), push_back(b);\n    }\n};\n\nstruct C {\n    P p; double r;\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ncrossPointsOfCircleAndLine(C &circle, L &l){\n    P p0 = circle.p;\n    double r = circle.r;\n    P p1 = l[0];\n    P p2 = l[1];\n    double x = real(p1-p0);\n    double y = imag(p1-p0);\n    double z = real(p2-p0);\n    double w = imag(p2-p0);\n    double a = y-w;\n    double b = -(x-z);\n    double c = y*z - x*w;\n\n    P cross1((a*c - b*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b), (b*c + a*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b));\n    P cross2((a*c + b*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b), (b*c - a*sqrt((a*a+b*b)*r*r - c*c))/(a*a + b*b));\n\n    if(cross2 < cross1){\n        swap(cross1, cross2);\n    }\n    printf(\"%.10f %.10f \", cross1.real() + p0.real(), cross1.imag() + p0.imag());\n    printf(\"%.10f %.10f\\n\", cross2.real() + p0.real(), cross2.imag() + p0.imag());\n}\n\nint main(){\n    double cx, cy, r, x1, y1, x2, y2;\n    int q;\n    cin >> cx >> cy >> r >> q;\n    P p0(cx, cy);\n    C circle(p0, r);\n\n    for (int i=0;i<q;i++){\n        cin >> x1 >> y1 >> x2 >> y2 ;\n        P p1(x1, y1);\n        P p2(x2, y2);\n        L l(p1, p2);\n        crossPointsOfCircleAndLine(circle, l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; } // cross product\n    db operator * (const point &p){ return x * p.x + y * p.y; } // dot product\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n    point unit(){ db k = (*this).len(); return point(x / k, y / k); }\n};\n\npoint err = point(INF_d, INF_d);\ndb rad(point A, point B){ return atan2((A ^ B), (A * B)); }// the ang(in rad) of two vectors A and B\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){ // find the distance of cloest pair of points in p\n//please make sure that p is sorted by x coordinate | sort(p, p + n, cmpxy);\n//this is nlognlogn, if need nlogn, replace the sort with a merge sort.\n    if (r - l <= 5){ db cloest = INF_d;\n        for (int i = l; i < r; i++) for (int j = i + 1; j < r; j++) cloest = min(cloest, (p[i] - p[j]).len());\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1; db cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid, r));\n        vector<point> v; v.clear();\n        for (int i = l; i < r; i++) if (fabs(p[i].x - p[mid].x) <= cloest) v.pb(p[i]); sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++) for (int j = i + 1; j < SZ(v) && dcmp(v[j].y - v[i].y - cloest) < 0; j++)\n                cloest = min(cloest, (v[i] - v[j]).len());\n        return cloest;\n    }\n}\n\nstruct circle{\n    point o; double r;\n    circle(){}\n    circle(point a, double b): o(a), r(b){}\n    void read(){\n        o.read(), scanf(\"%lf\", &r);\n    }\n    int inside(point p){ // 1: inside, 2: on the circle, 0: outside\n        int sgn = dcmp((o - p).len() - r) < 0; if (sgn < 0) return 1; if (!sgn) return 2; return 0;\n    }\n};\n\nint check_CC(circle C1, circle C2){ // return the number of common tangents of two circles C1 and C2\n//4: xiang_li, 3: wai_qie, 2: xiang_jiao, 1: nei_qie, 0: nei_han\n    db d =(C1.o - C2.o).len();\n    if (dcmp(d - C1.r - C2.r) > 0) return 4;\n    if (!dcmp(d - C1.r - C2.r)) return 3;\n    if (!dcmp(d - fabs(C1.r - C2.r))) return 1;\n    if (dcmp(d - fabs(C1.r - C2.r)) > 0 && dcmp(d - C1.r - C2.r) < 0) return 2;\n    return 0;\n}\n\nvector<point> inter_CL(circle C, point A, point B){ // return the intersection of a circle and a line\n// the result give in the direction from A -> B\n    point p_proj = proj_SP(A, B, C.o);\n    db d = C.r * C.r - (C.o - p_proj).len2();\n    if (dcmp(d) < 0) return {};\n    point delta = (B - A).unit() * sqrt(max((db)0, d)); return {p_proj - delta, p_proj + delta};\n}\n\nvector<point> inter_CL(circle C, line L){ // the same as the former one, but argument is different\n    return inter_CL(C, L.p[0], L.p[1]);\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\ncircle cir[2];\n\nint main(){\n    cir[0].read();\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        x.read(), y.read();\n        vector<point> itp = inter_CL(cir[0], x, y);\n        sort(itp.begin(), itp.end(), cmpxy);\n        printf(\"%.10f %.10f %.10f %.10f\\n\", itp[0].x, itp[0].y, itp[1].x, itp[1].y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#define EPS (1e-10)\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT=0;\nclass Point{\npublic:\n    double x,y;\n    Point(double x=0, double y=0):x(x),y(y){}\n    Point operator +(const Point &p){\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point &p){\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(double k){\n        return Point(k*x,k*y);\n    }\n    Point operator /(double k){\n        return Point(x/k,y/k);\n    }\n\n    double norm(){\n        return x*x+y*y;\n    }\n    double abs(){\n        return sqrt(norm());\n    }\n};\ntypedef Point Vector;\nstruct segment{\n    Point p1,p2;\n};\ntypedef segment Line;\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle (double x=0, double y=0,double r=0):c(x,y),r(r){}\n};\ndouble dot(const Vector &v1,const Vector &v2){\n    return v1.x*v2.x+v1.y*v2.y;\n}\ndouble cross(const Vector &v1,const Vector &v2){\n    return v1.x*v2.y-v1.y*v2.x;\n}\nbool isParallel(const Vector &v1,const Vector &v2){\n    if(fabs(cross(v1,v2)-0.0)<EPS)return true;\n    return false;\n}\nbool isOrthogonal(const Vector &v1,const Vector &v2){\n    if(fabs(dot(v1,v2)-0.0)<EPS)return true;\n    return false;\n}\nPoint projection( Point &p, Point &p1, Point &p2){\n    Vector a=p-p1;\n    Vector b=p2-p1;\n    double r=dot(a,b);\n    double pro_abs=r/b.norm();\n    Vector res=b*pro_abs;\n    return Point(res.x+p1.x,res.y+p1.y);\n}\nPoint reflection(Point &p, Point &p1, Point &p2){\n    Point pro=projection(p,p1,p2);\n    Vector v=pro-p;\n    v=v*2;\n    return Point(v.x+p.x,v.y+p.y);\n}\nint ccw(Point &p, Point &p1, Point &p2){\n    Vector a=p-p1;\n    Vector b=p2-p1;\n    if(cross(a,b)>0)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<0)return CLOCKWISE;\n    if(dot(a,b)<0)return ONLINE_BACK;\n    if(a.norm()>b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool intersect(segment &s1,segment &s2){\n    if(ccw(s1.p1,s2.p1,s2.p2)*ccw(s1.p2,s2.p1,s2.p2)<=0 && ccw(s2.p1,s1.p1,s1.p2)*ccw(s2.p2,s1.p1,s1.p2)<=0)\n        return true;\n    return false;\n}\ndouble getDistanceSP(Point &p,segment &s){\n    if(dot(p-s.p1,s.p2-s.p1)<0)return (p-s.p1).abs();\n    if(dot(p-s.p2,s.p1-s.p2)<0)return (p-s.p2).abs();\n    return fabs(cross(p-s.p1,s.p2-s.p1)/(s.p2-s.p1).abs());\n}\ndouble Distance(segment &s1,segment &s2){\n    if(intersect(s1,s2))return 0;\n    return min(min(getDistanceSP(s1.p1,s2),getDistanceSP(s1.p2,s2)),min(getDistanceSP(s2.p1,s1),getDistanceSP(s2.p2,s1)));\n}\nPoint CrossPoint(segment &s1,segment &s2){\n    Vector base =s2.p2-s2.p1;\n    double d1=fabs(cross(base,s1.p1-s2.p1));\n    double d2=fabs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return (s1.p2-s1.p1)*t+s1.p1;\n}\npair<Point,Point> getCrossPoints(Circle &c,Line &l){\n    Vector e = (l.p2-l.p1)/(l.p2-l.p1).abs();\n    Point p=projection(c.c,l.p1,l.p2);\n    double len=sqrt(c.r*c.r-(p-c.c).norm());\n    return make_pair(p-e*len,p+e*len);\n }\nint main()\n{\n    int q,cx,cy,cr,p0x,p1x,p0y,p1y;\n    cin>>cx>>cy>>cr;\n    Circle c(cx,cy,cr);\n    Line l1;\n    cin>>q;\n    while(q-->0){\n        cin>>p0x>>p0y>>p1x>>p1y;\n        l1.p1=Point(p0x,p0y);\n        l1.p2=Point(p1x,p1y);\n        pair<Point,Point>res=getCrossPoints(c,l1);\n        if(res.first.x<=res.second.x){\n            if(fabs(res.first.x-res.second.x)<EPS && res.first.y>res.second.y){\n                printf(\"%.8f %.8f %.8f %.8f\\n\",res.second.x,res.second.y,res.first.x,res.first.y);\n                continue;\n            }\n            printf(\"%.8f %.8f %.8f %.8f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n        }\n        else\n            printf(\"%.8f %.8f %.8f %.8f\\n\",res.second.x,res.second.y,res.first.x,res.first.y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nnamespace Random_Number{\n\tunsigned int seed = 19260817;\n\tvoid srnd(unsigned int x){ seed = x; }\n\tunsigned int rnd(){\n\t\treturn seed ^= seed << 19, seed ^= seed >> 7, seed ^= seed << 1;\n\t}\n}\nusing namespace Random_Number;\nnamespace Geometry{\n\tconst int COUNTER_CLOCKWISE = 1, CLOCKWISE = 2, ONLINE_BACK = 3, ONLINE_FRONT = 4, ON_SEGMENT = 5;\n\tconst double eps = 1e-9, pi = 3.14159265358979323846;\n\tbool equal(double a, double b){ return fabs(a - b) < eps; }\n\tstruct point{\n\t\tdouble x, y;\n\t\tpoint(){}\n\t\tpoint(double _x, double _y){ x = _x, y = _y; }\n\t\tpoint operator * (const double &la) const { return point(x * la, y * la); }\n\t\tpoint operator / (const double &la) const { return point(x / la, y / la); }\n\t\tpoint operator + (const point &rhs) const { return point(x + rhs.x, y + rhs.y); }\n\t\tpoint operator - (const point &rhs) const { return point(x - rhs.x, y - rhs.y); }\n\t\tbool operator < (const point &rhs) const { return x < rhs.x || (x == rhs.x && y < rhs.y); }\n\t\tbool operator > (const point &rhs) const { return x > rhs.x || (x == rhs.x && y > rhs.y); }\n\t\tbool operator == (const point &rhs) const { return equal(x, rhs.x) && equal(y, rhs.y); }\n\t\tdouble len2() const { return x * x + y * y; }\n\t\tdouble len() const { return sqrt(len2()); }\n\t\tpoint unit() const { return *this / len(); }\n\t\tpoint unit2() const { return *this / len2(); }\n\t\tfriend double distance(const point &a, const point &b){ return (a - b).len(); }\n\t\tfriend double distance2(const point &a, const point &b){ return (a - b).len2(); }\n\t\tfriend double dot(const point &a, const point &b){ return a.x * b.x + a.y * b.y; }\n\t\tfriend double cross(const point &a, const point &b){ return a.x * b.y - a.y * b.x; }\n\t\tvoid read(){ scanf(\"%lf%lf\", &x, &y); }\n\t\tvoid print(char ch = '\\n') const { printf(\"%.10lf %.10lf\", x, y), putchar(ch); }\n\t\tpoint rotation(double th) const { return point(x * cos(th) - y * sin(th), y * cos(th) + x * sin(th)); }\n\t\tfriend double angle(const point &a, const point &b){ return atan2(cross(a, b), dot(a, b)); }\n\t};\n\tstruct line{\n\t\tpoint a, b;\n\t\tline(){}\n\t\tline(point _a, point _b){ a = _a, b = _b; }\n\t\tvoid read(){ a.read(), b.read(); }\n\t\tvoid print(char ch1 = ' ', char ch2 = '\\n') const { a.print(ch1), b.print(ch2); }\n\t\tpoint projection(const point &p) const { return a + (b - a).unit2() * dot(p - a, b - a); }\n\t\tpoint reflection(const point &p) const { return projection(p) * 2 - p; }\n\t\tint direction(const point &p) const {\n\t\t\tdouble t = cross(b - a, p - a);\n\t\t\tif (t >= eps) return 1;\n\t\t\tif (t <= -eps) return 2;\n\t\t\tdouble l1 = dot(p - a, b - a), l2 = dot(b - a, b - a);\n\t\t\tif (l1 <= -eps) return 3;\n\t\t\tif (l1 > l2) return 4;\n\t\t\treturn 5;\n\t\t}\n\t\tfriend bool parallel(const line &a, const line &b){ return equal(cross(a.b - a.a, b.b - b.a), 0); }\n\t\tfriend bool orthogonal(const line &a, const line &b){ return equal(dot(a.b - a.a, b.b - b.a), 0); }\n\t\tfriend std :: vector<point> line_cross_point(const line &a, const line &b){\n\t\t\tif (parallel(a, b)) return {};\n\t\t\tpoint u = a.a - b.a, v = a.b - a.a, w = b.b - b.a;\n\t\t\treturn {a.a + v * (cross(w, u) / cross(v, w))};\n\t\t}\n\t\tfriend bool segment_intersection(const line &a, const line &b){\n\t\t\tif (std :: min(a.a.x, a.b.x) >= std :: max(b.a.x, b.b.x) + eps) return 0;\n\t\t\tif (std :: min(b.a.x, b.b.x) >= std :: max(a.a.x, a.b.x) + eps) return 0;\n\t\t\tif (std :: min(a.a.y, a.b.y) >= std :: max(b.a.y, b.b.y) + eps) return 0;\n\t\t\tif (std :: min(b.a.y, b.b.y) >= std :: max(a.a.y, a.b.y) + eps) return 0;\n\t\t\tdouble t1, t2;\n\t\t\tt1 = cross(b.a - a.a, a.b - a.a), t2 = cross(b.b - a.a, a.b - a.a);\n\t\t\tif ((t1 >= eps && t2 >= eps) || (t1 <= -eps && t2 <= -eps)) return 0;\n\t\t\tt1 = cross(a.a - b.a, b.b - b.a), t2 = cross(a.b - b.a, b.b - b.a);\n\t\t\tif ((t1 >= eps && t2 >= eps) || (t1 <= -eps && t2 <= -eps)) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tfriend double distance_ps(const point &p, const line &l){\n\t\t\tdouble l1 = dot(p - l.a, l.b - l.a), l2 = dot(l.b - l.a, l.b - l.a);\n\t\t\tif (l1 > l2) return distance(p, l.b);\n\t\t\tif (l1 < 0) return distance(p, l.a);\n\t\t\treturn fabs(cross(l.b - l.a, p - l.a)) / distance(l.a, l.b);\n\t\t}\n\t\tfriend double distance_ss(const line &a, const line &b){\n\t\t\tif (segment_intersection(a, b)) return 0;\n\t\t\treturn std :: min(std :: min(distance_ps(a.a, b), distance_ps(a.b, b)), \n\t\t\tstd :: min(distance_ps(b.a, a), distance_ps(b.b, a)));\n\t\t}\n\t};\n\tstruct polygon{\n\t\tstd :: vector<point> g;\n\t\tpolygon(){}\n\t\tpolygon(int n){ g.resize(n); }\n\t\tpolygon(const std :: vector<point> &_g){ g = _g; }\n\t\tvoid read(){\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n), g.resize(n);\n\t\t\tfor (register int i = 0; i < n; ++i) g[i].read();\n\t\t}\n\t\tvoid print(){\n\t\t\tprintf(\"%d\\n\", g.size());\n\t\t\tfor (register int i = 0; i < g.size(); ++i) g[i].print();\n\t\t}\n\t\tvoid clear(){ g.clear(); }\n\t\tvoid resize(int n){ g.resize(n); }\n\t\tint size() const { return g.size(); }\n\t\tvoid push_back(point x){ return g.push_back(x); }\n\t\tvoid pop_back(){ g.pop_back(); }\n\t\tpoint& operator [] (int x){ return g[x]; }\n\t\tconst point& operator [] (int x) const { return g[x]; }\n\t\tdouble directed_area() const {\n\t\t\tint n = g.size();\n\t\t\tdouble s = 0;\n\t\t\tfor (register int i = 0; i < n; ++i) s += cross(g[i], g[(i + 1) % n]);\n\t\t\treturn s / 2;\n\t\t}\n\t\tbool is_convex() const {\n\t\t\tint n = g.size();\n\t\t\tfor (register int i = 0; i < n; ++i)\n\t\t\t\tif (cross(g[(i + 1) % n] - g[i], g[(i - 1 + n) % n] - g[i]) <= -eps) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tint point_containment(const point &a) const {\n\t\t\tdouble k = sqrt(1.0 * rnd() / rnd());\n\t\t\tline l = line(a, point(a.x + 1e9, a.y + 1e9 * k));\n\t\t\tint n = g.size(), s = 0;\n\t\t\tfor (register int i = 0; i < n - 1; ++i)\n\t\t\t\tif (line(g[i], g[i + 1]).direction(a) == 5) return 1;\n\t\t\tif (line(g[n - 1], g[0]).direction(a) == 5) return 1;\n\t\t\tfor (register int i = 0; i < n - 1; ++i)\n\t\t\t\tif (segment_intersection(l, line(g[i], g[i + 1]))) ++s;\n\t\t\tif (segment_intersection(l, line(g[n - 1], g[0]))) ++s;\n\t\t\tif (s & 1) return 2; else return 0;\n\t\t}\n\t\tvoid convex_hull(std :: vector<point> f){\n\t\t\tg.clear();\n\t\t\tint n = f.size();\n\t\t\tstd :: sort(f.begin(), f.end());\n\t\t\tstd :: vector<point> p;\n\t\t\tp.push_back(f[0]);\n\t\t\tfor (register int i = 1; i < n; ++i){\n\t\t\t\twhile (p.size() > 1 && cross(f[i] - p.back(), *(++p.rbegin()) - p.back()) <= -eps)\n\t\t\t\t\tp.pop_back();\n\t\t\t\tp.push_back(f[i]);\n\t\t\t}\n\t\t\tfor (register int i = 0; i < p.size() - 1; ++i) g.push_back(p[i]);\n\t\t\tstd :: reverse(f.begin(), f.end());\n\t\t\tp.clear(), p.push_back(f[0]);\n\t\t\tfor (register int i = 1; i < n; ++i){\n\t\t\t\twhile (p.size() > 1 && cross(f[i] - p.back(), *(++p.rbegin()) - p.back()) <= -eps)\n\t\t\t\t\tp.pop_back();\n\t\t\t\tp.push_back(f[i]);\n\t\t\t}\n\t\t\tfor (register int i = 0; i < p.size() - 1; ++i) g.push_back(p[i]);\n\t\t\tf = g, n = f.size(), g.clear();\n\t\t\tint t = 0;\n\t\t\tfor (register int i = 1; i < n; ++i)\n\t\t\t\tif (f[i].y < f[t].y || (f[i].y == f[t].y && f[i].x < f[t].x)) t = i;\n\t\t\tfor (register int i = t; i < n; ++i) g.push_back(f[i]);\n\t\t\tfor (register int i = 0; i < t; ++i) g.push_back(f[i]);\n\t\t}\n\t\tdouble convex_diamater() const {\n\t\t\tint n = g.size();\n\t\t\tdouble ans = 0;\n\t\t\tfor (register int i = 0, j = 0; i < n; ++i){\n\t\t\t\twhile (cross(g[i] - g[j], g[(i + 1) % n] - g[j])\n\t\t\t\t  < cross(g[i] - g[(j + 1) % n], g[(i + 1) % n] - g[(j + 1) % n]) + eps)\n\t\t\t\t\tj = (j + 1) % n;\n\t\t\t\tans = std :: max(ans, distance(g[j], g[i]));\n\t\t\t\tans = std :: max(ans, distance(g[j], g[(i + 1) % n]));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tpolygon convex_cut(const line &l) const {\n\t\t\tpolygon res;\n\t\t\tint n = g.size();\n\t\t\tfor (register int i = 0; i < g.size(); ++i){\n\t\t\t\tpoint u = g[i], v = g[(i + 1) % n];\n\t\t\t\tif (cross(l.b - l.a, u - l.a) > -eps){\n\t\t\t\t\tres.push_back(u);\n\t\t\t\t\tif (cross(l.b - l.a, v - l.a) <= -eps) res.push_back(line_cross_point(line(u, v), l)[0]);\n\t\t\t\t}\n\t\t\t\telse if (cross(l.b - l.a, v - l.a) >= eps) res.push_back(line_cross_point(line(u, v), l)[0]);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\tstruct circle{\n\t\tpoint o;\n\t\tdouble r;\n\t\tcircle(){}\n\t\tcircle(point _o, double _r){ o = _o, r = _r; }\n\t\tvoid read(){ o.read(), scanf(\"%lf\", &r); }\n\t\tvoid print(char ch = '\\n') const { printf(\"%.10lf %.10lf %.10lf\", o.x, o.y, r), putchar(ch); }\n\t\tint circle_intersection(const circle &c) const {\n\t\t\tdouble d = distance(o, c.o);\n\t\t\tif (d >= r + c.r + eps) return 4;\n\t\t\tif (equal(d, r + c.r)) return 3;\n\t\t\tif (d >= fabs(r - c.r) + eps) return 2;\n\t\t\tif (equal(d, fabs(r - c.r))) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\tstd :: vector<point> directed_line_cross_point(const line &l) const {\n\t\t\tpoint p = line(l.a, l.b).projection(o), v = (l.b - l.a).unit();\n\t\t\tdouble d = distance(p, o);\n\t\t\tif (d >= r + eps) return {};\n\t\t\tdouble t = sqrt(r * r - (p - o).len2());\n\t\t\tif (equal(t, 0)) return {p};\n\t\t\telse return {p - v * t, p + v * t};\n\t\t}\n\t\tstd :: vector<point> circle_cross_point(const circle &c) const {\n\t\t\tdouble d = distance(o, c.o);\n\t\t\tif (d <= fabs(r - c.r) - eps || d >= r + c.r + eps) return {};\n\t\t\tdouble x = (r * r - c.r * c.r + d * d) / (d * 2), h = sqrt(r * r - x * x);\n\t\t\tpoint p = (c.o - o).unit() * x, v = (c.o - o).unit().rotation(pi / 2) * h;\n\t\t\tif (v == point(0, 0)) return {p}; else return {p - v, p + v};\n\t\t}\n\t\tstd :: vector<point> tangent(const point &p) const {\n\t\t\tdouble d = distance(o, p);\n\t\t\tif (d <= r - eps) return {};\n\t\t\tif (equal(d, r)) return {p};\n\t\t\treturn circle_cross_point(circle(p, sqrt(d * d - r * r)));\n\t\t}\n\t\tstd :: vector<point> common_tangent_out(const circle &c) const {\n\t\t\tif (equal(r, c.r)){\n\t\t\t\tpoint p = (c.o - o).unit().rotation(pi / 2) * r;\n\t\t\t\treturn {o - p, o + p};\n\t\t\t}\n\t\t\tpoint p = (o * c.r - c.o * r) / (c.r - r);\n\t\t\treturn tangent(p);\n\t\t}\n\t\tstd :: vector<point> common_intangent_in(const circle &c) const {\n\t\t\tpoint p = (o * c.r + c.o * r) / (r + c.r);\n\t\t\treturn tangent(p);\n\t\t}\n\t\tdouble directed_triangle_intersection(const point &a, const point &b) const {\n\t\t\tbool ta = a.x * a.x + a.y * a.y < r * r + eps, tb = b.x * b.x + b.y * b.y < r * r + eps;\n\t\t\tstd :: vector<point> t = circle(point(0, 0), r).directed_line_cross_point(line(b, a));\n\t\t\tif (ta == 1 && tb == 1) return cross(a, b) / 2;\n\t\t\tif (ta == 1 && tb == 0) return angle(t.front(), b) * r * r / 2 + cross(a, t.front()) / 2;\n\t\t\tif (ta == 0 && tb == 1) return angle(a, t.back()) * r * r / 2 + cross(t.back(), b) / 2;\n\t\t\tdouble s = angle(a, b) * r * r / 2;\n\t\t\tif (distance_ps(point(0, 0), line(a, b)) > r - eps) return s;\n\t\t\treturn s + angle(t.front(), t.back()) * r * r / 2 - cross(t.front(), t.back()) / 2;\n\t\t}\n\t\tdouble directed_polygon_intersection(const polygon &g) const {\n\t\t\tint n = g.size();\n\t\t\tdouble s = 0;\n\t\t\tfor (register int i = 0; i < n; ++i)\n\t\t\t\ts += directed_triangle_intersection(g[i] - o, g[(i + 1) % n] - o);\n\t\t\treturn s;\n\t\t}\n\t};\n}\nusing namespace Geometry;\npoint p, t;\nline l, m;\npolygon g;\ncircle c, d;\nstd :: vector<point> v, res;\nint n, q;\ndouble r;\nvoid CGL_1_A(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--) p.read(), l.projection(p).print();\n}\nvoid CGL_1_B(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--) p.read(), l.reflection(p).print();\n}\nvoid CGL_1_C(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--){\n\t\tp.read();\n\t\tint t = l.direction(p);\n\t\tif (t == COUNTER_CLOCKWISE) puts(\"COUNTER_CLOCKWISE\");\n\t\tif (t == CLOCKWISE) puts(\"CLOCKWISE\");\n\t\tif (t == ONLINE_BACK) puts(\"ONLINE_BACK\");\n\t\tif (t == ONLINE_FRONT) puts(\"ONLINE_FRONT\");\n\t\tif (t == ON_SEGMENT) puts(\"ON_SEGMENT\");\n\t}\n}\nvoid CGL_2_A(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tif (parallel(l, m)) puts(\"2\");\n\t\telse if (orthogonal(l, m)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n}\nvoid CGL_2_B(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tif (segment_intersection(l, m)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n}\nvoid CGL_2_C(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tline_cross_point(l, m)[0].print();\n\t}\n}\nvoid CGL_2_D(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tprintf(\"%.10lf\\n\", distance_ss(l, m));\n\t}\n}\nvoid CGL_3_A(){\n\tg.read(), printf(\"%.1lf\\n\", g.directed_area());\n}\nvoid CGL_3_B(){\n\tg.read(), printf(\"%d\\n\", g.is_convex());\n}\nvoid CGL_3_C(){\n\tg.read();\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tp.read();\n\t\tprintf(\"%d\\n\", g.point_containment(p));\n\t}\n}\nvoid CGL_4_A(){\n\tscanf(\"%d\", &n), v.resize(n);\n\tfor (register int i = 0; i < n; ++i) v[i].read();\n\tg.convex_hull(v);\n\tprintf(\"%d\\n\", g.size());\n\tfor (register int i = 0; i < g.size(); ++i) printf(\"%d %d\\n\", int(g[i].x), int(g[i].y));\n}\nvoid CGL_4_B(){\n\tg.read(), printf(\"%.10lf\\n\", g.convex_diamater());\n}\nvoid CGL_4_C(){\n\tg.read();\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read();\n\t\tprintf(\"%.10lf\\n\", g.convex_cut(l).directed_area());\n\t}\n}\nvoid CGL_7_A(){\n\tc.read(), d.read(), printf(\"%d\\n\", c.circle_intersection(d));\n}\nvoid CGL_7_B(){\n\tc.read();\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read();\n\t\tres = c.directed_line_cross_point(l);\n\t\tstd :: sort(res.begin(), res.end());\n\t\tif (res.size() == 1) res.push_back(res[0]);\n\t\tres[0].print(' '), res[1].print();\n\t}\n}\nvoid CGL_7_H(){\n\tint n;\n\tdouble r;\n\tscanf(\"%d%lf\", &n, &r);\n\tpolygon g(n);\n\tfor (register int i = 0; i < n; ++i) g[i].read();\n\tprintf(\"%.10lf\\n\", fabs(circle(point(0, 0), r).directed_polygon_intersection(g)));\n}\nint main(){\n\tCGL_7_B();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x <<\" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<class T, class... Ts> void err(const T& arg,const Ts&... args) { cout << arg << \" \"; err(args...); }\nconst int N = 100 + 5;\ntypedef double db;\nconst db eps = 1e-8;\nint sgn(db x){\n    if(fabs(x) < eps) return 0;\n    if(x < 0) return -1;\n    return 1;\n}\nstruct Point{\n    db x, y;\n    Point(){}\n    Point(db x, db y):x(x), y(y){}\n    void input(){\n        //如果为longdouble则需要改为Lf\n        scanf(\"%lf%lf\",&x, &y);\n    }\n    Point operator - (const Point &b)const{\n        return Point(x - b.x, y - b.y);\n    }\n    db operator * (const Point &b)const{\n        return x * b.x + y * b.y;\n    }\n    Point operator + (const Point &b)const{\n        return Point(x + b.x, y + b.y);\n    }\n    bool operator < (Point b)const{\n        return sgn(x-b.x) == 0 ? sgn(y - b.y) < 0 : x < b.x;\n    }\n    //叉积\n    db operator ^ (const Point &b)const{\n        return x * b.y - y * b.x;\n    }\n    db len(){\n        return hypot(x, y);\n    }\n    Point trunc(db r){\n        db l = len();\n        if(!sgn(l)) return *this;\n        r /= l;\n        return Point(x*r, y*r);\n    }\n    //返回两点距离 \n    db distance(Point p){\n        return hypot(x - p.x, y - p.y);\n    }\n    Point operator * (const db &k) const {\n        return Point(x * k,  y * k);\n    }\n    Point operator /(const db &k)const {\n        return Point(x / k, y / k);\n    }\n    db len2(){\n        return x * x + y * y;\n    }\n};\nstruct Line{\n    Point s, e;\n    Line(){}\n    Line(Point s, Point e):s(s),e(e){}\n    void input(){\n        s.input();\n        e.input();\n    }\n    Point lineprog(Point p){\n        return s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) );\n    }\n    db length(){\n        return s.distance(e);\n    }\n    db dispointtoline(Point p){\n        return fabs((p-s) ^ (e-s)) / length();\n    }\n};\nstruct circle{\n    Point p;\n    db r;\n    circle(){}\n    circle(Point p, db r):p(p), r(r){}\n    void input(){\n        p.input();\n        // 注意类型\n        scanf(\"%lf\", &r);\n    }\n    int relationline(Line v){\n        db dst = v.dispointtoline(p);\n        if(sgn(dst - r) < 0) return 2;\n        else if(sgn(dst - r) == 0) return 1;\n        return 0;\n    }\n    int pointcrossline(Line v, Point &p1, Point &p2){\n        if(!(*this).relationline(v)) return 0;\n        Point a = v.lineprog(p);\n        db d = v.dispointtoline(p);\n        d = sqrt(r * r - d * d);\n        if(sgn(d) == 0){\n            p1 = a;\n            p2 = a;\n            return 1;\n        }\n        p1 = a + (v.e - v.s).trunc(d);\n        p2 = a - (v.e - v.s).trunc(d);\n        return 2;\n    }\n};\n\nint main(){\n    circle c;\n    c.input();\n    int n;scanf(\"%d\", &n);\n    while(n--){\n        Line l;\n        l.input();\n        Point p1, p2;\n        c.pointcrossline(l, p1, p2);\n        if(p2 < p1) swap(p1, p2);\n        printf(\"%.8f %.8f %.8f %.8f\\n\", p1.x, p1.y, p2.x, p2.y);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nsigned main(){\n  Circle c;\n  int q;\n  cin>>c>>q;\n  while(q--){\n    Line l;\n    cin>>l;\n    auto pp=getCrossPoints(c,l);\n    if(pp.second<pp.first) swap(pp.first,pp.second);\n    cout<<pp.first<<\" \"<<pp.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\nconst double EPS = 1e-10;\nconst int COUNTER_CLOCKWISE = 1, CLOCKWISE = -1, ONLINE_BACK = 2, ONLINE_FRONT = -2, ON_SEGMENT = 0;\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point rhs) {\n\t\treturn Point(x + rhs.x, y + rhs.y);\n\t}\n\tPoint operator - (Point rhs) {\n\t\treturn Point(x - rhs.x, y - rhs.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k * x, k * y);\n\t}\n\tbool operator < (const Point& rhs) const {\n\t\treturn x != rhs.x ? x < rhs.x : y < rhs.y;\n\t}\n\tbool operator == (const Point& rhs) const {\n\t\treturn equals(x, rhs.x) && equals(y, rhs.y);\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0);\n}\nbool isOrthogonal(Segment a, Segment b) {\n\treturn isOrthogonal(Vector(a.p2.x - a.p1.x, a.p2.y - a.p1.y), Vector(b.p2.x - b.p1.x, b.p2.y - b.p1.y));\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0);\n}\nbool isParallel(Segment a, Segment b) {\n\treturn isParallel(Vector(a.p2.x - a.p1.x, a.p2.y - a.p1.y), Vector(b.p2.x - b.p1.x, b.p2.y - b.p1.y));\n}\nPoint project(Point p, Segment s) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + (base * r);\n}\nPoint reflect(Point p, Segment s) {\n\treturn p + (project(p, s) - p) * 2;\n}\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\telse if (cross(a, b) < -EPS) return CLOCKWISE;\n\telse if (dot(a, b) < -EPS) return ONLINE_BACK;\n\telse if (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn (ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 && ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0); \n}\ndouble getDistance(Point a, Point b) {\n\treturn (b - a).abs();\n}\ndouble getDistancePL(Point p, Line l) {\n\treturn fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\ndouble getDistancePS(Point p, Segment s) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0) return (p - s.p1).abs();\n\telse if (dot(s.p1 - s.p2, p - s.p2) < 0) return (p - s.p2).abs();\n\telse return getDistancePL(p, s);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0;\n\treturn min(min(getDistancePS(s2.p1, s1), getDistancePS(s2.p2, s1)), min(getDistancePS(s1.p1, s2), getDistancePS(s1.p2, s2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = fabs(cross(base, s1.p1 - s2.p1)), d2 = fabs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\npair<Point, Point> getCrossPoints(Line l, Circle c) {\n\tPoint pr = project(c.c, l);\n\tVector e = (l.p2 - l.p1) * (1 / (l.p2 - l.p1).abs());\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\tif (e.x > EPS || (fabs(e.x) < EPS && e.y > EPS)) return make_pair(pr - e * base, pr + e * base);\n\telse return make_pair(pr + e * base, pr - e * base);\n}\nint main() {\n    int x, y, r, q;\n    scanf(\"%d%d%d%d\", &x, &y, &r, &q);\n    Circle c = Circle(Point(x, y), r);\n    while (q--) {\n    \tPoint p0, p1;\n    \tscanf(\"%d%d\", &x, &y);\n    \tp0 = Point(x, y);\n    \tscanf(\"%d%d\", &x, &y);\n    \tp1 = Point(x, y);\n    \tpair<Point, Point> ans = getCrossPoints(Line(p0, p1), c);\n    \tprintf(\"%.08lf %.08lf %.08lf %.08lf\\n\", ans.first.x, ans.first.y, ans.second.x, ans.second.y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nbool operator < (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() < r.imag() : l.real() < r.real();\n}\n\nbool operator > (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() > r.imag() : l.real() > r.real();\n}\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this);\n  Circle(){}\n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto h = projection(l, c);\n  auto e = (l[1]-l[0]) / abs(l[1]-l[0]);\n  auto base = sqrt(c.r*c.r-abs(h-c)*abs(h-c));\n  return {h+e*base, h-e*base};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  Circle c; cin >> c.p >> c.r;\n  int n; cin >> n;\n  rep(i, n) {\n    P a, b; cin >> a >> b;\n    auto cp = crosspoint(c, Line(a, b));\n    if(cp.first > cp.second) { swap(cp.first, cp.second); }\n    printf(\"%.10f %.10f %.10f %.10f\\n\", cp.first.real(), cp.first.imag(), cp.second.real(), cp.second.imag());\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-8; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\nVP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// cross point between circles Verify AOJ CGL_7_E\nVP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n/*\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}*/\n\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#define f first\n#define s second\n#define mp make_pair\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return (s1.p1+(s1.p2-s1.p1)*t);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nint main()\n{\n  Point A,B;\n  int q,a,b;\n  Circle C;\n\n  cin>>C.c.x>>C.c.y>>C.r;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>A.x>>A.y>>B.x>>B.y;\n    pair<Point,Point> PP=getCrossPoints(C,Line(A,B));\n    if(PP.f.x<PP.s.x)\n      printf(\"%.10f %.10f %.10f %.10f\\n\",PP.f.x,PP.f.y,PP.s.x,PP.s.y);\n    else if(PP.f.x>PP.s.x)\n      printf(\"%.10f %.10f %.10f %.10f\\n\",PP.s.x,PP.s.y,PP.f.x,PP.f.y);\n    else {\n      if(PP.f.y<PP.f.y)\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\",PP.f.x,PP.f.y,PP.s.x,PP.s.y);\n      else \n\tprintf(\"%.10f %.10f %.10f %.10f\\n\",PP.s.x,PP.s.y,PP.f.x,PP.f.y);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (Point p) { return Point(x * p.x, y * p.y); }\n\tPoint operator * (double p) { return Point(x * p, y * p); }\n\tPoint operator / (Point p) { return Point(x / p.x, y / p.y); }\n\tPoint operator / (double p) { return Point(x / p, y / p); }\n\tvoid insert(double a, double b) { x = a; y = b; }\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\nstruct Segment {\n\tVector p1, p2;\n\tSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0):\n\t\tp1(x1, y1), p2(x2, y2) {}\n\tSegment(Point a1, Point a2) : p1(a1), p2(a2) {}\n\tvoid insert(Vector a1, Vector a2) { p1 = a1; p2 = a2; }\n};\ntypedef Segment Line;\ninline double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ninline double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\ninline bool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\ninline bool isOrthogonal(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\ninline bool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\ninline bool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\ninline bool isParallel(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\ninline bool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point &p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point &p1, Point &p2, Point &p3, Point &p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Point &a, Point &b) { return (a - b).abs(); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn mp(pr + e * base, pr - e * base);\n}\nint main() {\n\tcout << setprecision(10) << fixed;\n\tdouble x, y, r; cin >> x >>  y >> r;\n\tCircle ci(Point(x, y), r);\n\tint q; cin >> q;\n\tdouble x1, y1, x2, y2;\n\tpair<Point, Point> ppp;\n\trep(i, 0, q) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tppp = getCrossPoints(ci, Line(x1, y1, x2, y2));\n\t\tif(ppp.se < ppp.fi) swap(ppp.fi, ppp.se);\n\t\tcout << ppp.fi.x << \" \" << ppp.fi.y << \" \" << ppp.se.x << \" \" << ppp.se.y << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\ndouble getDistanceLP(Line, Point);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q;\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\n\t\tif (ans.first.x < ans.second.x) {\n\t\t\tans.first.show();\n\t\t\tcout << \" \";\n\t\t\tans.second.show();\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tif (equals(ans.first.x - ans.second.x, 0.0)) {\n\t\t\t\tif (ans.first.y < ans.second.y) {\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\n\n\nnamespace Geometory {\n    const double EPS = 1e-10;\n\n    inline bool equals(double a, double b) {\n        return fabs(a - b) < EPS;\n    }\n\n    struct Point {\n        double x, y;\n\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n        Point operator+(const Point &p) {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator-(const Point &p) {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator*(const double k) {\n            return Point(x * k, y * k);\n        }\n\n        Point operator/(const double k) {\n            return Point(x / k, y / k);\n        }\n\n        double norm() const {\n            return x * x + y * y;\n        }\n\n        double abs() const {\n            return sqrt(norm());\n        }\n\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n\n        bool operator<(const Point &p) const {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator==(const Point &p) const {\n            return equals(x, p.x) && equals(y, p.y);\n//            return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n        }\n\n\n    };\n\n    using Vector = Point;\n\n    struct Segment {\n        Point p1, p2;\n\n        Segment() {}\n\n        Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\n        Segment(double x1, double y1, double x2, double y2) : p1(x1, y1), p2(x2, y2) {}\n    };\n\n    using Line = Segment;\n\n\n    double norm(Vector p) {\n        return p.x * p.x + p.y * p.y;\n    }\n\n    double abs(Vector a) {\n        return sqrt(norm(a));\n    }\n\n    double dot(Vector a, Vector b) {\n        return a.dot(b);\n    }\n\n    double cross(Vector a, Vector b) {\n        return a.cross(b);\n    }\n\n    //直行判定\n    bool is_orthogonal(Vector a, Vector b) {\n        return equals(dot(a, b), 0.0);\n    }\n\n    bool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n        return is_orthogonal(a1 - a2, b1 - b2);\n    }\n\n    bool is_orthogonal(Segment s1, Segment s2) {\n        return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n    }\n\n    //平行判定\n    bool is_parallel(Vector a, Vector b) {\n        return equals(cross(a, b), 0.0);\n    }\n\n    bool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n        return is_parallel(a1 - a2, b1 - b2);\n    }\n\n    bool is_parallel(Segment s1, Segment s2) {\n        return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n    }\n\n    //反時計回り\n    static const int CCW = 1; // Counter Clockwise\n    static const int CW = -1; // Clockwise\n    static const int OB = 2; // Online Back\n    static const int OF = -2; // Online Front\n    static const int OS = 0; // On Segment\n\n    // p0を中心としたとき、p2は{反時計回り、時計回り、p2->p0->p1で同一直線上、p0->p1->p2で直線上、p2がp0p1線分上} (後ろの3つの説明は雑)\n    int ccw(Point p0, Point p1, Point p2) {\n        Vector a = p1 - p0;\n        Vector b = p2 - p0;\n        if (cross(a, b) > EPS) return CCW;\n        if (cross(a, b) < -EPS) return CW;\n        if (dot(a, b) < -EPS) return OB;\n        if (a.norm() < b.norm()) return OF;\n\n        return OS;\n    }\n\n    //交差判定\n    bool is_intersect(Point p1, Point p2, Point p3, Point p4) {\n        return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n               ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n    }\n\n    //交差判定\n    bool is_intersect(Segment s1, Segment s2) {\n        return is_intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n    }\n\n    //射影を求める\n    //pからsに垂直に線を引いたときの座標を返す\n    Point project(Segment s, Point p) {\n        Vector base = s.p2 - s.p1;\n        double r = dot(p - s.p1, base) / norm(base);\n        return s.p1 + base * r;\n    }\n\n    // 反射\n    // pを線分sを対称軸として線対称の位置にある点を求める。\n    Point reflect(Segment s, Point p) {\n//        return p + (project(s, p) - p) * 2;\n        return project(s, p) * 2 - p;\n    }\n\n\n    //距離シリーズ\n    //2点間の距離\n    double get_distance(Point a, Point b) {\n        return abs(a - b);\n    }\n\n    // 直線lと点pの距離\n    double get_distanceLP(Line l, Point p) {\n        return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n    }\n\n    // 線分sと点pの距離\n    double get_distanceSP(Segment s, Point p) {\n        if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n        if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n        return get_distanceLP(s, p);\n    }\n\n    //線分と線分の距離\n    double get_distance(Segment s1, Segment s2) {\n        if (is_intersect(s1, s2)) return 0.0;\n        return min({get_distanceSP(s1, s2.p1),\n                    get_distanceSP(s1, s2.p2),\n                    get_distanceSP(s2, s1.p1),\n                    get_distanceSP(s2, s1.p2),\n                   });\n    }\n\n    // 線分と線分の交点\n    Point get_cross_point(Segment s1, Segment s2) {\n        Vector base = s2.p2 - s2.p1;\n        double d1 = abs(cross(base, s1.p1 - s2.p1));\n        double d2 = abs(cross(base, s1.p2 - s2.p1));\n\n        double t = d1 / (d1 + d2);\n        return s1.p1 + (s1.p2 - s1.p1) * t;\n    }\n\n    struct Circle {\n        Point c;\n        double r;\n\n        Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n    };\n\n    //円と線分の交差判定\n    bool is_intersect(Circle c, Line l) {\n        double d = get_distanceLP(l, c.c);\n        return d - c.r < EPS;\n    }\n\n    //円と線分の交点\n    pair<Point, Point> get_cross_points(Circle c, Line l) {\n//        assert(is_intersect(c, l));\n        if (!is_intersect(c, l)) exit(-1);\n        Vector pr = project(l, c.c);\n        Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n        double base = sqrt(c.r * c.r - norm(pr - c.c));\n        return make_pair(pr + e * base, pr - e * base);\n    }\n\n\n    using Polygon = vector<Point>;\n\n    std::ostream &operator<<(std::ostream &os, const Point &p) {\n//        os << \"(\" << p.x << \", \" << p.y << \")\";\n        os << \"\" << p.x << \" \" << p.y << \"\";\n        return os;\n    }\n\n};\n\nusing namespace Geometory;\n\n\nclass Solve {\npublic:\n    void solve() {\n        Circle c;\n        cin >> c.c.x >> c.c.y >> c.r;\n\n        Int q;\n        cin >> q;\n        while (q--) {\n            Line l;\n            cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n\n            pair<Point, Point> ans = get_cross_points(c, l);\n            if (ans.first.x > ans.second.x) {\n                swap(ans.first, ans.second);\n            } else if (equals(ans.first.x, ans.second.x) && ans.first.y > ans.second.y) {\n                swap(ans.first, ans.second);\n            }\n\n            cout << ans.first << \" \" << ans.second << endl;\n        }\n\n\n    }\n\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\nstruct circle { point p; double r; };\nstruct line { point p, q; };\n\nconst double eps = 1e-9;\n\ndouble sign(double x) { return x < -eps ? -1 : x > eps; }\n\ndouble dot(point a, point b) { return real(conj(a) * b); }\n\n// circle-line intersection\nvector<point> intersect(line L, circle C)\n{\n\tpoint u = L.p - L.q, v = L.p - C.p;\n\tdouble a = dot(u, u), b = dot(u, v), c = dot(v, v) - C.r*C.r;\n\tdouble det = b*b - a*c;\n\tif (sign(det) < 0) return {};              // no solution\n\tif (sign(det) == 0) return {L.p - b/a*u}; // touch\n\treturn {L.p + (-b + sqrt(det))/a*u,\n\t\t\tL.p + (-b - sqrt(det))/a*u};\n}\n\npoint read(){\n\tdouble x, y; cin >> x >> y;\n\treturn point(x, y);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tpoint c = read(); \n\tdouble r; cin >> r;\n\tcircle cir = {c, r};\n\n\tint n; cin >> n;\n\n\tfor (int i = 0; i < n; ++i){\n\t\tpoint p = read(), q = read();\n\t\tline l = {p, q};\n\t\tauto ans = intersect(l, cir);\n\t\tif (ans.size() == 1) ans.push_back(ans[0]);\n\t\tfor (auto pp : ans)\n\t\t\tcout << pp.real() << \" \" << pp.imag() << \" \";\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  cgl_7_d.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Oct 23 00:28:22 2017\n//\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define EPS 1e-10\n#define equals(x, y) (fabs(x - y) < EPS)\n\nstruct vector_t {\n  double x;\n  double y;\n\n  vector_t(double a, double b) : x(a), y(b)\n  {\n  }\n\n  double norm2()\n  {\n    return x * x + y * y;\n  }\n\n  double norm()\n  {\n    return sqrt(norm2());\n  }\n\n  double dot(vector_t a)\n  {\n    return x * a.x + y * a.y;\n  }\n\n  double cross(vector_t a)\n  {\n    return x * a.y - y * a.x;\n  }\n\n  vector_t operator*(double a)\n  {\n    return vector_t(a * x, a * y);\n  }\n\n  vector_t operator/(double a)\n  {\n    return vector_t(x / a, y / a);\n  }\n};\n\nstruct point_t {\n  double x;\n  double y;\n\n  point_t operator+(const point_t a)\n  {\n    return point_t({x + a.x, y + a.y});\n  }\n\n  void println()\n  {\n    cout << fixed << setprecision(10) << x << \" \" << y << endl;\n  }\n\n  void print()\n  {\n    cout << fixed << setprecision(10) << x << \" \" << y;\n  }\n\n  point_t operator+(const vector_t vec)\n  {\n    return point_t({x + vec.x, y + vec.y});\n  }\n\n  point_t operator-(const vector_t vec)\n  {\n    return point_t({x - vec.x, y - vec.y});\n  }\n\n  vector_t operator-(const point_t p)\n  {\n    return vector_t({x - p.x, y - p.y});\n  }\n\n  bool operator<(const point_t p)\n  {\n    return x == p.x ? y < p.y : x < p.x;\n  }\n\n  point_t project(point_t p1, point_t p2)\n  {\n    vector_t vec1(x - p1.x, y - p1.y);\n    vector_t vec2(p2.x - x, p2.y - y);\n    return point_t({x, y}) + vec1 * (vec1.dot(vec2) / vec1.norm2());\n  }\n\n  point_t reflect(point_t p1, point_t p2)\n  {\n    point_t proj = project(p1, p2);\n    return p2 + (proj - p2) * 2.0;\n  }\n};\n\nenum pos_t {\n  CCLOCKWISE = -1,\n  CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = -2,\n  ON_SEGMENT = 0,\n};\n\npos_t ccw(point_t p0, point_t p1, point_t p2)\n{\n  if ((p1 - p0).cross(p2 - p0) > EPS) {\n    return CCLOCKWISE;\n  } else if ((p1 - p0).cross(p2 - p0) < -EPS) {\n    return CLOCKWISE;\n  } else if ((p1 - p0).dot(p2 - p0) < -EPS) {\n    return ONLINE_BACK;\n  } else {\n    if ((p1 - p0).norm2() < (p2 - p0).norm2()) {\n      return ONLINE_FRONT;\n    } else {\n      return ON_SEGMENT;\n    }\n  }\n}\n\nbool intersection(point_t p0, point_t p1, point_t p2, point_t p3)\n{\n  return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0) && (ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nstruct segment_t {\n  point_t a;\n  point_t b;\n\n  double distance(point_t p0)\n  {\n    if ((b - a).dot(p0 - a) < 0.0) {\n      return (p0 - a).norm();\n    } else if ((a - b).dot(p0 - b) < 0.0) {\n      return (p0 - b).norm();\n    } else {\n      return fabs((b - a).cross(p0 - a) / (b - a).norm());\n    }\n  }\n};\n\nstruct circle_t {\n  point_t p;\n  double r;\n\n  vector<point_t> cross_points(point_t p0, point_t p1)\n  {\n    vector_t v = p1 - p0;\n    vector_t e = v / v.norm();\n    point_t pproject = p0.project(p1, p);\n    double ratio = sqrt(r * r - (pproject - p).norm2());\n    return {pproject + e * ratio, pproject - e * ratio};\n  }\n};\n\nint32_t main()\n{\n  double cx, cy, r;\n  cin >> cx >> cy >> r;\n  circle_t c({{cx, cy}, r});\n\n  uint32_t q;\n  cin >> q;\n  for (uint32_t i = 0; i < q; i++) {\n    double x, y;\n    cin >> x >> y;\n    point_t p0({x, y});\n    cin >> x >> y;\n    point_t p1({x, y});\n    vector<point_t> points = c.cross_points(p1, p0);\n    sort(points.begin(), points.end());\n    points[0].print();\n    cout << \" \";\n    points[1].println();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// ????????????\n// verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//2??????????????????\n// Verify AOJ 1183\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{w-e,w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tP ba=b.c-a.c;\n\tR d=arg(ba);\n\tR i=acos((a.r+b.r)/abs(ba));\n\tR o=acos((a.r-b.r)/abs(ba));\n\tint r=rcc(a,b);\n\n\tif(r==OUT){\t\t//??±????????\\???\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ??±????????\\???\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\n\tif(r&ONS) res.push_back(tangent(a,d)); //??\\????????±???????????\\???\n\treturn res;\n}\n\n\nint main(void){\n\tint q;\n\tC c;\n\tcin >> c.c >> c.r;\n\t\t\n\tcin >> q;\n\tcout.precision(20);\n\trep(i,q){\n\t\tP a,b;\n\t\tcin >> a >> b;\n\t\tL l={a,b};\n\t\tVP res=pcl(c,l);\n\t\tif(real(res[0])>real(res[1])) swap(res[0],res[1]);\n\t\tif(real(res[0])==real(res[1])&&imag(res[0])>imag(res[1])) swap(res[0],res[1]);\n\t\tcout << fixed << res[0] << \" \" << res[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\ndouble getDistanceLP(Line, Point);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q;\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\n\t\tif (ans.first.x < ans.second.x) {\n\t\t\tans.first.show();\n\t\t\tcout << \" \";\n\t\t\tans.second.show();\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tif (equals(ans.first.x - ans.second.x, 0.0)) {\n\t\t\t\tif (ans.first.y < ans.second.y) {\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}else{\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing T = double;\nconst T EPS = 1e-10;\nT torad(int deg) {return (T)(deg) * M_PI / 180;}\nT todeg(T ang) {return ang * 180 / M_PI;}\n\n/* Point */\nusing P = complex<T>;\n#define x real()\n#define y imag()\ntemplate <typename T> inline bool eq(T p, T q) { return abs(p - q) < EPS; }\ninline int sgn(T x) { return (T(0) < x) - (x < T(0)); }\ninline T dot(P v, P w) { return (conj(v) * w).x; }\ninline T cross(P v, P w) { return (conj(v) * w).y; }\ninline bool isOrth(P v, P w) { return dot(v, w) == 0; }\ninline bool isPara(P v, P w) { return cross(v, w) == 0; }\ninline P unit(P v) { return v / abs(v); }\ninline P translate(P p, P v) { return p + v; }\ninline P scale(P p, P c, T k) { return c + (p - c) * k; }\ninline P rot(P p, T a) { return p * polar(1.0, a); }\ninline P rot90(P p) { return {-p.y, p.x}; }\ninline T orient(P a, P b, P c) { return cross(b - a, c - a); }\nistream& operator>>(istream& is, P& p) { T xx, yy; is >> xx >> yy; p = P(xx, yy); return is; }\nbool cmpX(const P& a, const P& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool cmpY(const P& a, const P& b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nnamespace std {\n    bool operator < (const P& a, const P& b) { return cmpX(a, b); }\n}\n\nP linearTransform(P p, P q, P fp, P fq, P r) {\n    return fp + (r - p) * (fq - fp) / (q - p);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return +1;      // counter clockwise\n    if (cross(b, c) < 0) return -1;      // clockwise\n    if (dot(b, c) < 0) return +2;        // c--a--b on line\n    if (norm(b) < norm(c)) return -2;    // a--b--c on line or a==b\n    return 0;                            // a--c--b on line or a==c or b==c\n}\n\nT angle(P v, P w) {\n    T cosTheta = dot(v, w) / abs(v) / abs(w);\n    return acos(max(-1.0, min(1.0, cosTheta)));\n}\nT orientedAngle(P a, P b, P c) {\n    if (orient(a, b, c) >= 0) return angle(b - a, c - a);\n    return 2 * M_PI - angle(b - a, c - a);\n}\nbool inAngle(P a, P b, P c, P p) {\n    assert(abs(orient(a, b, c)) != 0);\n    if (orient(a, b, c) < 0) swap(b, c);\n    return orient(a, b, p) >= 0 && orient(a, c, p) <= 0;\n}\n\n// polar sort\nbool half(P p) {\n    assert(p.x != 0 || p.y != 0);\n    return p.y > 0 || (p.y == 0 && p.x < 0);\n}\nvoid polarSort(vector<P>& v, P o = P(0.0, 0.0)) {\n    sort(v.begin(), v.end(), [&](P v, P w) {\n        return make_tuple(half(v - o), 0, norm(v - o)) <\n            make_tuple(half(w - o), cross(v - o, w - o), norm(w - o));\n    });\n}\n\n/* Line */\nstruct L : array<P, 2> {\n    P v; T c;\n    L(P a = P(0.0, 0.0), P b = P(0.0, 0.0)) : array<P, 2>({a, b}), v(b - a), c(cross(v, a)) {}\n    T side(P p) { return cross(v, p) - c; }\n    P proj(P p) { return p - rot90(v) * side(p) / norm(v); }\n    P refl(P p) { return p - rot90(v) * T(2) * side(p) / norm(v); }\n    friend istream& operator>>(istream& is, L& l) { P p, q; is >> p >> q; l = L(p, q); return is; }\n    friend ostream& operator<<(ostream& os, const L& l) { return os << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct C : P {\n    T r;\n    C(P p = P(0.0, 0.0), T r = 0.0) : P(p), r(r) {}\n    friend istream& operator>>(istream& is, C& c) { P p; T r; is >> p >> r; c = C(p, r); return is; }\n    friend ostream& operator<<(ostream& os, const C& c) { return os << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\nP circumCenter(P a, P b, P c) {\n    b -= a, c -= a;\n    assert(cross(b, c) != 0);\n    return a + rot90(b * norm(c) - c * norm(b)) / cross(b, c) / T(2);\n}\n\nvector<P> tangentPoints(C c, P p) {\n    if (eq(abs(p - c), c.r)) return vector<P>{p};\n    vector<P> res;\n    T t = acos(c.r / abs(p - c));\n    P q = (p - c) / abs(p - c) * c.r;\n    res.push_back(c + q * polar(1.0, t));\n    res.push_back(c + q * polar(1.0, -t));\n    sort(res.begin(), res.end(), cmpX);\n    return res;\n}\n\nvector<L> tangentLines(C c1, C c2, bool inner) {\n    if (inner) c2.r = -c2.r;\n    vector<L> res;\n    P d = c2 - c1;\n    T dr = c1.r - c2.r, d2 = norm(d), h2 = d2 - dr * dr;\n    if (d2 == 0 || h2 < 0) { assert(h2 != 0); return res; }\n    for (T sign : {-1, 1}) {\n        P v = (d * dr + rot90(d) * sqrt(h2) * sign) / d2;\n        res.emplace_back(c1 + v * c1.r, c2 + v * c2.r);\n    }\n    return res;\n}\n\n// intersect\nbool isInterPL(P p, L l) { return (ccw(l[0], l[1], p) != 1); }\nbool isInterPS(P p, L s) { return (ccw(s[0], s[1], p) == 0); }\nbool isInterLL(L l, L m) { return (!isPara(l.v, m.v)); }\nbool isInterLS(L l, L s) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], l);\n    return (ccw(l[0], l[1], s[0]) * ccw(l[0], l[1], s[1]) <= 0);\n}\nbool isInterSS(L s, L t) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], t);\n    if (eq(t[0], t[1])) return isInterPL(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nint isInterCC(C a, C b) {\n    T d = abs(b - a);\n    if (a == b && a.r == b.r) return 0;         // ∞ cp (A = B)\n    if (a.r + d - b.r < -EPS) return +1;        // 0 cp (A in B)\n    if (b.r + d - a.r < -EPS) return -1;        // 0 cp (B in A)\n    if (abs(a.r + d - b.r) < EPS) return +2;    // 1 cp (A in B)\n    if (abs(b.r + d - a.r) < EPS) return -2;    // 1 cp (B in A)\n    if (abs(a.r + b.r - d) < EPS) return 3;     // 1 cp (outside)\n    if (a.r + b.r - d < -EPS) return 4;         // 0 cp (outside)\n    return 5;                                   // 2 cp\n}\n \n// distance\nT distancePL(P p, L l) { return (abs(p - l.proj(p))); }\nT distancePS(P p, L s) {\n    P h = s.proj(p);\n    if (isInterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nT distanceLL(L l, L m) {\n    if (isInterLL(l, m)) return T(0);\n    return distancePL(m[0], l);\n}\nT distanceLS(L l, L s) {\n    if (isInterLS(l, s)) return 0;\n    return min(distancePL(s[0], l), distancePL(s[1], l));\n}\nT distanceSS(L s, L t) {\n    if (isInterSS(s, t)) return 0;\n    return min({distancePS(s[0], t), distancePS(s[1], t), distancePS(t[0], s), distancePS(t[1], s)});\n}\n\n// crosspoint\nvector<P> crosspointLL(L l, L m) {\n    if (!isInterLL(l, m)) return vector<P>();\n    vector<P> res;\n    T d = cross(m[1] - m[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLS(L l, L s) {\n    if (!isInterLS(l, s)) return vector<P>();\n    vector<P> res;\n    T d = cross(s[1] - s[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(s[1] - s[0], s[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLC(L l, C c, bool dupl = false) {\n    if (abs(c - l.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, l), h2 = c.r * c.r - d * d;\n    assert(h2 >= 0);\n    P p = l.proj(c), h = l.v * sqrt(h2) / abs(l.v);\n    res.push_back(p - h);\n    if (dupl || abs(h) > 0) res.push_back(p + h);\n    if (res.size() == 2 && !(res[0] < res[1])) swap(res[0], res[1]);\n    return res;\n}\nvector<P> crosspointSS(L s, L t) {\n    if (!isInterSS(s, t)) return vector<P>();\n    vector<P> res;\n    if (unit(s.v) != unit(t.v)) {\n        T d = cross(t[1] - t[0], s[1] - s[0]);\n        res.push_back(s[0] + (s[1] - s[0]) * cross(t[1] - t[0], t[1] - s[0]) / d);\n    } else {\n        if (ccw(s[0], s[1], t[0]) == 0) res.push_back(t[0]);\n        if (ccw(s[0], s[1], t[1]) == 0) res.push_back(t[1]);\n        if (ccw(t[0], t[1], s[0]) == 0) res.push_back(s[0]);\n        if (ccw(t[0], t[1], s[1]) == 0) res.push_back(s[1]);\n    }\n    return res;\n}\nvector<P> crosspointSC(L s, C c, bool dupl = false) {\n    if (abs(c - s.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, s), h2 = c.r * c.r - d * d;\n    assert(h2 >= 0);\n    P p = s.proj(c), h = s.v * sqrt(h2) / abs(s.v);\n    if (ccw(s[0], s[1], p - h) == 0) res.push_back(p - h);\n    if (dupl || (abs(h) > 0 && isInterPS(p + h, s))) res.push_back(p + h);\n    if (res.size() == 2 && !(res[0] < res[1])) swap(res[0], res[1]);\n    return res;\n}\nvector<P> crosspointCC(C c1, C c2, bool dupl = false) {\n    P d = c2 - c1; T d2 = norm(d);\n    if (d2 == 0) { assert(c1.r != c2.r); return vector<P>(); }\n    vector<P> res;\n    T pd = (d2 + c1.r * c1.r - c2.r * c2.r) / 2;\n    T h2 = c1.r * c1.r - pd * pd / d2;\n    if (h2 >= 0) {\n        P p = c1 + d * pd / d2, h = rot90(d) * sqrt(h2 / d2);\n        res.push_back(p - h);\n        if (dupl || abs(h) > 0) res.push_back(p + h);\n        if (res.size() == 2 && !(res[0] < res[1])) swap(res[0], res[1]);\n    }\n    return res;\n}\n\n/* Polygon */\n// p[0] has minimum y and p is counterclockwise\nvector<P> makeStandard(vector<P> p) {\n    int n = p.size(), j = -1;\n    for (int i = 0; i < n; ++i) {\n        if (j == -1 || p[i].y < p[j].y) j = i;\n    }\n    vector<P> res;\n    if (p[(j - 1 + n) % n].x <= p[j].x && p[j].x <= p[(j + 1) % n].x) {\n        for (int i = 0; i < n; ++i) {\n            res.push_back(p[(i + j) % n]);\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            res.push_back(p[(i - j + n) % n]);\n        }\n    }\n    return res;\n}\nbool isConvex(vector<P> p) {\n    p = makeStandard(p);\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        P a = p[i], b = p[(i + 1) % n], c = p[(i + 2) % n];\n        if (orient(a, b, c) < 0) return false;\n        if (b.y != p[0].y && b.y < min(a.y, c.y)) return false;\n        if (b.y != p[0].y && a.y == b.y && b.y == c.y && a.x <= b.x && b.x <= c.x) return false;\n    }\n    return true;\n}\nT areaTriangle(P a, P b, P c) {\n    return abs(cross(b - a, c - a)) / T(2);\n}\nT area(vector<P> p) {\n    T res = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return abs(res) / T(2);\n}\nP centroid(vector<P> p) {\n    P c; T sumA = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        T a = cross(p[i], p[(i + 1) % n]);\n        sumA += abs(a);\n        c += (p[i] + p[(i + 1) % n]) * a;\n    }\n    return T(1) / T(3) / sumA * c;\n}\n// If A is strictly inside P, return 1.\n// If A is on the boundary, return 2.\n// Else return 0.\nint inConvexCcw(vector<P> p, P a) {\n    int n = p.size();\n    P g = (p[0] + p[n / 2]) / T(2);\n    if (g == a) return 1;\n    P ga = a - g;\n    int l = 0, r = n;\n    while (r - l > 1) {\n        int m = (l + r) / 2;\n        P gl = p[l] - g, gm = p[m] - g;\n        if (cross(gl, gm) > EPS) {\n            if (cross(gl, ga) > -EPS && cross(gm, ga) < EPS) r = m;\n            else l = m;\n        } else {\n            if (cross(gl, ga) < EPS && cross(gm, ga) > -EPS) l = m;\n            else r = m;\n        }\n    }\n    r %= n;\n    int c = ccw(a, p[l], p[r]);\n    return (c == 2 || c == -2 || c == 0) ? 2 : c == -1 ? 0 : 1;\n}\nbool above(P a, P p) { return p.y >= a.y; }\nbool crossesRay(P a, P p, P q) {\n    return (above(a, q) - above(a, p)) * orient(a, p, q) > 0;\n}\n// If A is strictly inside P, return 1.\n// If A is on the boundary, return 2.\n// Else return 0.\nint inPolygon(vector<P> p, P a) {\n    int numCrossing = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        if (ccw(p[i], p[(i + 1) % n], a) == 0) return 2;\n        numCrossing += crossesRay(a, p[i], p[(i + 1) % n]);\n    }\n    return numCrossing & 1;\n}\nvector<P> convexHull(vector<P> p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(), p.end(), cmpX);\n    vector<P> res(2 * n);\n    for (int i = 0; i < n; res[k++] = p[i++])\n        while (k >= 2 && ccw(res[k - 2], res[k - 1], p[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; res[k++] = p[i--])\n        while (k >= t && ccw(res[k - 2], res[k - 1], p[i]) <= 0) --k;\n    res.resize(k - 1);\n    return res;\n}\nvector<P> convexHullCollinearOK(vector<P> p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(), p.end(), cmpX);\n    vector<P> res(2 * n);\n    for (int i = 0; i < n; res[k++] = p[i++])\n        while (k >= 2 && ccw(res[k - 2], res[k - 1], p[i]) == -1) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; res[k++] = p[i--])\n        while (k >= t && ccw(res[k - 2], res[k - 1], p[i]) == -1) --k;\n    res.resize(k - 1);\n    return res;\n}\nvector<P> convexCut(vector<P> p, L l) {\n    vector<P> res;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        int ccwc = ccw(l[0], l[1], p[i]);\n        if (ccwc != -1) res.push_back(p[i]);\n        int ccwn = ccw(l[0], l[1], p[(i + 1) % n]);\n        if (ccwc * ccwn == -1) res.push_back(crosspointLL(l, L(p[i], p[(i + 1) % n]))[0]);\n    }\n    return res;\n}\npair<int, int> convexDiameter(const vector<P>& p) {\n    int i = min_element(p.begin(), p.end()) - p.begin();\n    int j = max_element(p.begin(), p.end()) - p.begin();\n    int maxI, maxJ;\n    T maxD = 0;\n    for (int k = 0, n = p.size(); k < 2 * n; ++k) {\n        if (maxD < norm(p[i] - p[j]) - EPS) {\n            maxD = norm(p[i] - p[j]);\n            maxI = i;\n            maxJ = j;\n        }\n        if (cross(p[i] - p[(i + 1) % n], p[(j + 1) % n] - p[j]) < EPS) j = (j + 1) % n;\n        else i = (i + 1) % n;\n    }\n    return make_pair(maxI, maxJ);\n}\nT closest_pair(vector<P>& a, int l = 0, int r = -1) {\n    if (r < 0) {\n        r = a.size();\n        sort(a.begin(), a.end());\n    }\n    if (r - l <= 1) return abs(a[0] - a[1]);\n    int m = (l + r) >> 1;\n    T amx = a[m].x, d = min(closest_pair(a, l, m), closest_pair(a, m, r));\n    inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r, cmpY);\n    vector<P> b;\n    for (int i = l; i < r; ++i) {\n        if (abs(a[i].x - amx) > d - EPS) continue;\n        for (int j = 0, n = b.size(); j < n; ++j) {\n            if (a[i].y - b[n - j - 1].y > d - EPS) break;\n            d = min(d, abs(a[i] - b[n - j - 1]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    C c;\n    cin >> c;\n    int q;\n    cin >> q;\n    REP (i, q) {\n        L l;\n        cin >> l;\n        auto cp = crosspointLC(l, c, true);\n        cout << cp[0].x << \" \" << cp[0].y << \" \" << cp[1].x << \" \" << cp[1].y << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-8;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\n\nnamespace geometry {\n// Point : 複素数型を位置ベクトルとして扱う\n// 実軸(real)をx軸、挙軸(imag)をy軸として見る\nusing Point = complex<double>;\n\ninline bool equal(const double &a, const double &b) {\n    return fabs(a - b) < EPS;\n}\n\n// 単位ベクトル(unit vector)を求める\nPoint unitVector(const Point &a) { return a / abs(a); }\n\n// 法線ベクトル(normal vector)を求める\n// 90度回転した単位ベクトルをかける\n// -90度がよければPoint(0, -1)をかける\nPoint normalVector(const Point &a) { return a * Point(0, 1); }\n\n// 内積(dot product) : a・b = |a||b|cosΘ\ndouble dot(const Point &a, const Point &b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積(cross product) : a×b = |a||b|sinΘ\ndouble cross(const Point &a, const Point &b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点pを反時計回りにtheta度回転\nPoint rotate(const Point &p, const double &theta) {\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(),\n                 sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\n// ラジアン->度\ndouble radianToDegree(const double &radian) { return radian * 180.0 / PI; }\n\n// 度->ラジアン\ndouble degreeToRadian(const double &degree) { return degree * PI / 180.0; }\n\n// 点の回転方向\n// 点a, b, cの位置関係について(aが基準点)\nint ccw(const Point &a, Point b, Point c) {\n    b -= a, c -= a;\n    // 点a, b, c が\n    // 反時計回りの時、\n    if(cross(b, c) > EPS) {\n        return 1;\n    }\n    // 時計回りの時、\n    if(cross(b, c) < -EPS) {\n        return -1;\n    }\n    // c, a, bがこの順番で同一直線上にある時、\n    if(dot(b, c) < 0) {\n        return 2;\n    }\n    // a, b, cがこの順番で同一直線上にある場合、\n    if(norm(b) < norm(c)) {\n        return -2;\n    }\n    // cが線分ab上にある場合、\n    return 0;\n}\n\n// Line : 直線を表す構造体\n// b - a で直線・線分を表せる\nstruct Line {\n    Point a, b;\n    Line() = default;\n    Line(Point a, Point b) : a(a), b(b) {}\n    // Ax+By=C\n    Line(double A, double B, double C) {\n        if(equal(A, 0)) {\n            a = Point(0, C / B), b = Point(1, C / B);\n        } else if(equal(B, 0)) {\n            b = Point(C / A, 0), b = Point(C / A, 1);\n        } else {\n            a = Point(0, C / B), b = Point(C / A, 0);\n        }\n    }\n};\n\n// Segment : 線分を表す構造体\n// Lineと同じ\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\n// Circle : 円を表す構造体\n// pが中心の位置ベクトル、rは半径\nstruct Circle {\n    Point p;\n    double r;\n\n    Circle() = default;\n\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(const Line &a, const Line &b) {\n    return equal(dot(a.b - a.a, b.b - b.a), 0);\n}\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(const Line &a, const Line &b) {\n    return equal(cross(a.b - a.a, b.b - b.a), 0);\n}\n\n// 点cが直線ab上にあるか\nbool isPointOnLine(const Point &a, const Point &b, const Point &c) {\n    return isParallel(Line(a, b), Line(a, c));\n}\n\n// 点cが\"線分\"ab上にあるか\nbool isPointOnSegment(const Point &a, const Point &b, const Point &c) {\n    // |a-c| + |c-b| <= |a-b| なら線分上\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n// 直線lと点pの距離を求める\ndouble distanceBetweenLineAndPoint(const Line &l, const Point &p) {\n    return abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);\n}\n\n// 線分lと点pの距離を求める\n// 定義：点pから「線分lのどこか」への最短距離\ndouble distanceBetweenSegmentAndPoint(const Segment &l, const Point &p) {\n    if(dot(l.b - l.a, p - l.a) < EPS) {\n        return abs(p - l.a);\n    }\n    if(dot(l.a - l.b, p - l.b) < EPS) {\n        return abs(p - l.b);\n    }\n    return abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);\n}\n\n// 直線s, tの交点の計算\nPoint crossPoint(const Line &s, const Line &t) {\n    double d1 = cross(s.b - s.a, t.b - t.a);\n    double d2 = cross(s.b - s.a, s.b - t.a);\n    if(equal(abs(d1), 0) && equal(abs(d2), 0)) {\n        return t.a;\n    }\n    return t.a + (t.b - t.a) * (d2 / d1);\n}\n\n// 線分s, tの交点の計算\nPoint crossPoint(const Segment &s, const Segment &t) {\n    return crossPoint(Line(s), Line(t));\n}\n\n// 線分sと線分tが交差しているかどうか\nbool isIntersect(const Segment &s, const Segment &t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 線分sとtの距離\ndouble distanceBetweenSegments(const Segment &s, const Segment &t) {\n    if(isIntersect(s, t)) {\n        return (double)(0);\n    }\n    double ans = distanceBetweenSegmentAndPoint(s, t.a);\n    chmin(ans, distanceBetweenSegmentAndPoint(s, t.b));\n    chmin(ans, distanceBetweenSegmentAndPoint(t, s.a));\n    chmin(ans, distanceBetweenSegmentAndPoint(t, s.b));\n    return ans;\n}\n\n// 射影(projection)\n// 直線(線分)lに点pから引いた垂線の足を求める\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\n// 反射(reflection)\n// 直線lを対称軸として点pと線対称の位置にある点を求める\nPoint reflection(const Line &l, const Point &p) {\n    return p + (projection(l, p) - p) * 2.0;\n}\n\n// 2つの円の交差判定\n// 返り値は共通接線の数\nint isIntersect(const Circle &c1, const Circle &c2) {\n    double d = abs(c1.p - c2.p);\n    // 2つの円が離れている場合\n    if(d > c1.r + c2.r + EPS) {\n        return 4;\n    }\n    // 外接している場合\n    if(equal(d, c1.r + c2.r)) {\n        return 3;\n    }\n    // 内接している場合\n    if(equal(d, abs(c1.r - c2.r))) {\n        return 1;\n    }\n    // 内包している場合\n    if(d < abs(c1.r - c2.r) - EPS) {\n        return 0;\n    }\n    return 2;\n}\n\n// 2つの円の交点\nvector<Point> crossPoint(const Circle &c1, const Circle &c2) {\n    vector<Point> res;\n    int mode = isIntersect(c1, c2);\n    // 2つの中心の距離\n    double d = abs(c1.p - c2.p);\n    // 2円が離れている場合\n    if(mode == 4) {\n        return res;\n    }\n    // 1つの円がもう1つの円に内包されている場合\n    if(mode == 0) {\n        return res;\n    }\n    // 2円が外接する場合\n    if(mode == 3) {\n        double t = c1.r / (c1.r + c2.r);\n        res.emplace_back(c1.p + (c2.p - c1.p) * t);\n        return res;\n    }\n    // 内接している場合\n    if(mode == 1) {\n        if(c2.r < c1.r - EPS) {\n            res.emplace_back(c1.p + (c2.p - c1.p) * (c1.r / d));\n        } else {\n            res.emplace_back(c2.p + (c1.p - c2.p) * (c2.r / d));\n        }\n        return res;\n    }\n    // 2円が重なる場合\n    double rc1 = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * d);\n    double rs1 = sqrt(c1.r * c1.r - rc1 * rc1);\n    if(c1.r - abs(rc1) < EPS) {\n        rs1 = 0;\n    }\n    Point e12 = (c2.p - c1.p) / abs(c2.p - c1.p);\n    res.emplace_back(c1.p + rc1 * e12 + rs1 * e12 * Point(0, 1));\n    res.emplace_back(c1.p + rc1 * e12 + rs1 * e12 * Point(0, -1));\n    return res;\n}\n\n// 円cと直線lの交点\nvector<Point> crossPoint(const Circle &c, const Line &l) {\n    vector<Point> res;\n    double d = distanceBetweenLineAndPoint(l, c.p);\n    // 交点を持たない\n    if(d > c.r + EPS) {\n        return res;\n    }\n    // 接する\n    Point h = projection(l, c.p);\n    if(equal(d, c.r)) {\n        res.emplace_back(h);\n        return res;\n    }\n    Point e = unitVector(l.b - l.a);\n    double ph = sqrt(c.r * c.r - d * d);\n    res.emplace_back(h - e * ph);\n    res.emplace_back(h + e * ph);\n    return res;\n}\n\n// 点pが円cの内部(円周上も含む)に入っているかどうか\nbool isInCircle(const Circle &c, const Point &p) {\n    double d = abs(c.p - p);\n    return (equal(d, c.r) || d < c.r - EPS);\n}\n\n// ----------- ↓多角形 -------------\n\n// 多角形の面積を求める\ndouble PolygonArea(const vector<Point> &p) {\n    double res = 0;\n    int n = p.size();\n    for(int i = 0; i < n - 1; i++) {\n        res += cross(p[i], p[i + 1]);\n    }\n    res += cross(p[n - 1], p[0]);\n    return res * 0.5;\n}\n\n// 凸多角形かどうか\nbool isConvex(const vector<Point> &p) {\n    int n = p.size();\n    int now, pre, nxt;\n    for(int i = 0; i < n; i++) {\n        pre = (i - 1 + n) % n;\n        nxt = (i + 1) % n;\n        now = i;\n        if(ccw(p[pre], p[now], p[nxt]) == -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// 凸包 O(NlogN)\nvector<Point> ConvexHull(vector<Point> &p) {\n    int n = (int)p.size(), k = 0;\n    sort(ALL(p), [](const Point &a, const Point &b) {\n        return (real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b));\n    });\n    vector<Point> ch(2 * n);\n    // 一直線上の3点を含める -> (< -EPS)\n    // 含め無い -> (< EPS)\n    for(int i = 0; i < n; ch[k++] = p[i++]) { // lower\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0)\n            --k;\n    }\n    for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) { // upper\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0)\n            --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\n} // namespace geometry\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n    geometry::Circle c(geometry::Point(cx, cy), r);\n    int q;\n    cin >> q;\n    while(q--) {\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        geometry::Line l(geometry::Point(x1, y1), geometry::Point(x2, y2));\n        auto ans = geometry::crossPoint(c, l);\n        int n = ans.size();\n        // cout << n << endl;\n        sort(ALL(ans), [](const geometry::Point &a, const geometry::Point &b) {\n            return (real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b));\n        });\n        for(int i = 0; i < 2; i++) {\n            cout << real(ans[i % n]) << ' ' << imag(ans[i % n]) << ' ';\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tint d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nint main()\n{\n\tint q;\n\tld x, y, r, x1, x2, y1, y2;\n\tcout << fixed << setprecision(9);\n\tcin >> x >> y >> r;\n\tCircle c = { (Point) { x, y }, r };\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tLine l = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tauto res = is_lc(c, l);\n\t\tcout << res[0].real() << ' ' << res[0].imag() << ' ' << res[1].real() << ' ' << res[1].imag() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJ-CGL-7-D\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a) for(int i = 0; i < (a); i++)\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n\nstruct Point {\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\nbool intersect(Segment s1, Segment s2);\n\ndouble getDistance(Segment s1, Segment s2) {\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    // assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n    // assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n// IN : 2, ON : 1, OUT : 0\nint contains(Polygon g, Point p) {\n    int n = g.size();\n    bool x = false;\n    for( int i = 0; i < n; i++ ) {\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if ( abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if ( a.y > b.y ) swap(a, b);\n        if ( a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;\n    }\n    return ( x ? 2 : 0 );\n}\n\nsigned main(){\n    double cx, cy, r;\n    int q;\n    cin >> cx >> cy >> r;\n    Circle c = Circle(Point(cx, cy), r);\n    cin >> q;\n    double x1, y1, x2, y2;\n    REP(i,q){\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line l = Line(Point(x1, y1), Point(x2, y2));\n        pair<Point, Point> p = getCrossPoints(c, l);\n        if(p.first.x > p.second.x || (p.first.x == p.second.x && p.first.y > p.second.y)){\n            swap(p.first, p.second);\n        }\n        printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", p.first.x, p.first.y, p.second.x, p.second.y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X)\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nnamespace Geometry{\n  #define EPS (1e-10)\n  #define equals(a,b) (fabs((a)-(b)) < EPS)\n\n  class Point{\n  public:\n    double x,y;\n\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n\n    bool operator < (const Point &p) const{\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n      return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS);\n    }\n\n    friend ostream& operator << (ostream &os,Point &p){\n      return os << p.x << \" \" << p.y;\n    }\n\n    friend istream& operator >> (istream &is,Point &p){\n      return is >> p.x >> p.y;\n    }\n  };\n  typedef Point Vector;\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &p){\n      return os << p.p1.x << \" \" << p.p1.y << \" \" << p.p2.x << \" \" << p.p2.y;\n    }\n\n    friend istream& operator >> (istream &is,Segment &p){\n      return is >> p.p1.x >> p.p1.y >> p.p2.x >> p.p2.y;\n    }\n  };\n  typedef Segment Line;\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){\n      return os << c.c.x << c.c.y << c.r;\n    }\n\n    friend istream& operator >> (istream &is,Circle &c){\n      return is >> c.c.x >> c.c.y >> c.r;\n    }\n  };\n\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){\n    return  a.x * a.x + a.y * a.y;\n  }\n\n  double abs(Vector a){\n    return sqrt(norm(a));\n  }\n\n  double dot(Vector a,Vector b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  double cross(Vector a,Vector b){\n    return a.x * b.y - a.y * b.x;\n  }\n\n  bool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n  }\n\n  bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1 - a1,b1 - b2);\n  }\n\n  bool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0);\n  }\n\n  bool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n  }\n\n  bool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1 - a2 , b1 - b2);\n  }\n\n  bool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n  }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base / norm(base));\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n\n  int ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n\n  bool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n  }\n\n  double getDistance(Vector a,Vector b){\n    return abs(a - b);\n  }\n\n  double getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1));\n  }\n\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n              min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    // cassert(intersect(c,l));\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){\n    return atan2(p.y,p.x);\n  }\n\n  Vector polar(double a,double r){\n    return Point(cos(r) * a, sin(r) * a);\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    // assert(intersect(c1,c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n\n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y < b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  Polygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0;i--){\n      for(int n = l.size();n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--)l.push_back(u[i]);\n    return l;\n  }\n\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  Circle c;\n  Line a;\n  cin >> c;\n  cin >> n;\n  while(n--){\n    cin >> a;\n    pair<Point,Point> ans = getCrossPoints(c,a);\n    if(ans.first.x == ans.second.x){\n      if(ans.first.y < ans.second.y)fprints(8,ans.first,ans.second);\n      else fprints(8,ans.second,ans.first);\n    }else if(ans.first.x < ans.second.x){\n      fprints(8,ans.first,ans.second);\n    }\n    else{\n      fprints(8,ans.second,ans.first);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 李青坪 on 2018/12/5.\n//\n\n#include <cmath>\n#include <cstdio>\n//#include <assert.h>\n#include <algorithm>\n\n#define EPSLON 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPSLON)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK -2\n#define ONLINE_FRONT 2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// 点\nclass Point {\npublic:\n    double x;\n    double y;\n\n    Point() {}\n\n    Point(double x, double y) : x(x), y(y) {}\n\n    Point operator+(Point a) {\n        return Point(x + a.x, y + a.y);\n    }\n\n    Point operator-(Point a) {\n        return Point(x - a.x, y - a.y);\n    }\n\n    Point operator*(double a) {\n        return Point(x * a, y * a);\n    }\n\n    Point operator/(double a) {\n        return Point(x / a, y / a);\n    }\n\n    double norm() {\n        return x * x + y * y;\n    }\n\n    double absVector() {\n        return sqrt(norm());\n    }\n\n    bool operator==(Point a) const {\n        return equals(x, a.x) && equals(y, a.y);\n    }\n};\n\ntypedef Point Vector;\n\n// 线段\nclass Segment {\npublic:\n    Point a, b;\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n};\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Segment s, Point p) {\n    Vector v1 = s.b - s.a;\n    Vector v2 = p - s.a;\n    if (cross(v1, v2) > 0) return COUNTER_CLOCKWISE;\n    if (cross(v1, v2) < 0) return CLOCKWISE;\n    if (dot(v1, v2) < 0) return ONLINE_BACK;\n    if (v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersection(Segment s1, Segment s2) {\n    return (ccw(s1, s2.a) * ccw(s1, s2.b) <= 0 && ccw(s2, s1.a) * ccw(s2, s1.b) <= 0);\n}\n\nPoint projection(Segment s, Point point) {\n    Vector base = s.b - s.a;\n    double t = dot(point - s.a, base) / base.absVector();\n    double r = t / base.absVector();\n    Point y = base * r;\n    Point x = s.a + y;\n    return x;\n}\n\npair<Point, Point> getCrossPoints(Circle circle, Line line) {\n    Point pro = projection(line, circle.c);\n    Vector pr = pro - circle.c;\n//    assert(pr.absVector() <= circle.r);\n    Vector e = (line.b - line.a) / (line.b - line.a).absVector();\n    double base = sqrt(circle.r * circle.r - pr.norm());\n    return make_pair(pro - e * base, pro + e * base);\n}\n\nint n;\n\n\nint main() {\n    Circle circle;\n    double x, y, r;\n    scanf(\"%lf %lf %lf\", &x, &y, &r);\n    circle.c.x = x;\n    circle.c.y = y;\n    circle.r = r;\n    scanf(\"%d\", &n);\n    Point point[2];\n    double x1, y1, x2, y2;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n        point[0].x = x1;\n        point[0].y = y1;\n        point[1].x = x2;\n        point[1].y = y2;\n        Line l;\n        l.a = point[0];\n        l.b = point[1];\n        pair<Point, Point> re = getCrossPoints(circle, l);\n        if (re.first.x == re.second.x && re.first.y == re.second.y) {\n            printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", re.first.x, re.first.y, re.second.x, re.second.y);\n        } else if (re.first.x < re.second.x) {\n            printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", re.first.x, re.first.y, re.second.x, re.second.y);\n        } else {\n            if (re.first.x == re.second.x) {\n                if (re.first.y < re.second.y) {\n                    printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", re.first.x, re.first.y, re.second.x, re.second.y);\n                } else {\n                    printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", re.second.x, re.second.y, re.first.x, re.first.y);\n                }\n            } else {\n                printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", re.second.x, re.second.y, re.first.x, re.first.y);\n            }\n        }\n    }\n}\n/*\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\n */\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <cmath>\n#include <iomanip>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\n\ntemplate <class T>\nstruct real_constant;\n\ntemplate <>\nstruct real_constant<double> {\n  using value_type = double;\n  static constexpr value_type infinity() { return 1e9; }\n  static constexpr value_type epsilon() { return 1e-9; }\n  static constexpr value_type pi() { return std::acos(-1.0); }\n};\n\ntemplate <>\nstruct real_constant<long double> {\n  using value_type = long double;\n  static constexpr value_type infinity() { return 1e18; }\n  static constexpr value_type epsilon() { return 1e-10; }\n  static constexpr value_type pi() { return std::acos(-1.0L); }\n};\n\ntemplate <>\nstruct real_constant<int> {\n  using value_type = int;\n  static constexpr value_type infinity() { return 1e9; }\n  static constexpr value_type epsilon() { return 1; }\n};\n\ntemplate <>\nstruct real_constant<long long> {\n  using value_type = long long;\n  static constexpr value_type infinity() { return 1e18; }\n  static constexpr value_type epsilon() { return 1; }\n};\n\ntemplate <class T, class U>\nconstexpr bool leq(T x, U y) {\n  return x - y < real_constant<T>::epsilon();\n}\ntemplate <class T, class U>\nconstexpr bool geq(T x, U y) {\n  return y - x < real_constant<T>::epsilon();\n}\ntemplate <class T, class U>\nconstexpr bool equal(T x, U y) {\n  return leq(x, y) && geq(x, y);\n}\n\n\ntemplate <class T>\nstruct vector_type {\n  using value_type = T;\n  value_type x, y;\n  constexpr vector_type(): x(0), y(0) { }\n  constexpr vector_type(value_type x_, value_type y_): x(x_), y(y_) { }\n  constexpr vector_type &operator += (const vector_type &rhs) { x += rhs.x; y += rhs.y; return *this; }\n  constexpr vector_type operator + (const vector_type &rhs) const { return vector_type(*this) += rhs; }\n  constexpr vector_type &operator -= (const vector_type &rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n  constexpr vector_type operator - (const vector_type &rhs) const { return vector_type(*this) -= rhs; }\n  constexpr vector_type operator - () const { return vector_type(-x, -y); }\n  constexpr vector_type &operator *= (value_type rhs) { x *= rhs; y *= rhs; return *this; }\n  constexpr vector_type &operator /= (value_type rhs) { x /= rhs; y /= rhs; return *this; }\n  constexpr bool operator == (const vector_type &rhs) const { return equal(x, rhs.x) && equal(y, rhs.y); }\n  constexpr bool operator != (const vector_type &rhs) const { return !equal(x, rhs.x) || !equal(y, rhs.y); }\n};\n\ntemplate <class T, class U>\nconstexpr vector_type<T> operator * (vector_type<T> v, U rhs) { return v *= rhs; }\ntemplate <class T, class U>\nconstexpr vector_type<T> operator * (U rhs, vector_type<T> v) { return v *= rhs; }\ntemplate <class T, class U>\nconstexpr vector_type<T> operator / (vector_type<T> v, U rhs) { return v /= rhs; }\n\ntemplate <class T>\nstd::istream& operator >> (std::istream& is, vector_type<T> &v) { return is >> v.x >> v.y; }\ntemplate <class T>\nstd::ostream& operator << (std::ostream& os, const vector_type<T> &v) { return os << v.x << ' ' <<  v.y; }\n\ntemplate <class T>\nconstexpr T norm(const vector_type<T> &v) { return v.x * v.x + v.y * v.y; }\ntemplate <class T>\nconstexpr T abs(const vector_type<T> &v) { return std::sqrt(norm(v)); }\ntemplate <class T>\nconstexpr T argr(const vector_type<T> &v) { return std::atan2(v.y, v.x); }\ntemplate <class T>\nconstexpr T argd(const vector_type<T> &v) { return argr(v) * 180 / real_constant<T>::pi(); }\ntemplate <class T>\nconstexpr T dist(const vector_type<T> &v, const vector_type<T> &u) { return abs(v - u); }\ntemplate <class T>\nconstexpr T dot(const vector_type<T> &v, const vector_type<T> &u) { return v.x * u.x + v.y * u.y; }\ntemplate <class T>\nconstexpr T cross(const vector_type<T> &v, const vector_type<T> &u) { return v.x * u.y - v.y * u.x; }\n\ntemplate <class T>\nconstexpr unsigned orthan(const vector_type<T> &v) {\n  if (v.x > 0 && v.y >= 0) return 0;\n  if (v.x <= 0 && v.y > 0) return 1;\n  if (v.x < 0 && v.y <= 0) return 2;\n  if (v.x >= 0 && v.y < 0) return 3;\n  return 0;\n}\ntemplate <class T>\nconstexpr bool cmp_x(const vector_type<T> &v, const vector_type<T> &u) {\n  if (equal(v.x, u.x)) return v.y < u.y;\n  return v.x < u.x;\n}\ntemplate <class T>\nconstexpr bool cmp_y(const vector_type<T> &v, const vector_type<T> &u) {\n  if (equal(v.y, u.y)) return v.x < u.x;\n  return v.y < u.y;\n}\ntemplate <class T>\nconstexpr bool cmp_arg(const vector_type<T> &v, const vector_type<T> &u) {\n  if (orthan(v) != orthan(u)) return orthan(v) < orthan(u);\n  if (!equal(cross(v, u), 0)) return cross(v, u) > 0;\n  return norm(v) < norm(u);\n}\n\ntemplate <class T>\nstruct line_type {\n  using value_type = T;\n  value_type a, b, c;\n  constexpr line_type(): a(0), b(0), c(0) { }\n  constexpr line_type(value_type a_, value_type c_): a(a_), b(-1), c(c_) { }\n  constexpr line_type(value_type a_, value_type b_, value_type c_): a(a_), b(b_), c(c_) { }\n  constexpr value_type valx(value_type y) const { return (b * y + c) / (-a); }\n  constexpr value_type valy(value_type x) const { return (a * x + c) / (-b); }\n  constexpr bool operator == (const value_type &l) const { return equal(a * l.b, b * l.a) && equal(a * l.c, c * l.a); }\n  constexpr bool operator != (const value_type &l) const { return !equal(a * l.b, b * l.a) || !equal(a * l.c, c * l.a); }\n};\n\ntemplate <class T>\nconstexpr bool parallel(const line_type<T> &l, const line_type<T> &m) { return equal(l.a * m.b, l.b * m.a); };\ntemplate <class T>\nconstexpr bool vertical(const line_type<T> &l, const line_type<T> &m) { return equal(l.a * m.a + l.b * m.b, 0); };\ntemplate <class T>\nconstexpr bool is_on(const line_type<T> &l, const vector_type<T> &v) { return equal(l.a * v.x + l.b * v.y + l.c, 0);}\ntemplate <class T>\nconstexpr vector_type<T> intersection(const line_type<T> &l, const line_type<T> &m) {\n  auto x = (l.b * m.c - l.c * m.b) / (l.a * m.b - l.b * m.a);\n  auto y = (l.c * m.a - l.a * m.c) / (l.a * m.b - l.b * m.a);\n  return vector_type<T>(x, y);\n}\ntemplate <class T>\nconstexpr vector_type<T> direction(const line_type<T> &l) { return vector_type<T>(-l.b, l.a); }\ntemplate <class T>\nconstexpr vector_type<T> perpend(const line_type<T> &l, const vector_type<T> &v) {\n  auto u = vector_type<T>(l.a, l.b);\n  auto d = -l.c / norm(u);\n  auto e = dot(v, u) / norm(u);\n  return (d - e) * u;\n}\ntemplate <class T>\nconstexpr vector_type<T> project(const line_type<T> &l, const vector_type<T> &v) {\n  return v + perpend(l, v);\n}\ntemplate <class T>\nconstexpr vector_type<T> relfect(const line_type<T> &l, const vector_type<T> &v) {\n  return v + perpend(l, v) * 2;\n}\ntemplate <class T>\nconstexpr T dist(const line_type<T> &l, const vector_type<T> &v) { \n  return std::abs(l.a * v.x + l.b * v.y + l.c) / abs(vector_type<T>(l.a, l.b)); \n}\n\ntemplate <class T>\nstruct segment_type {\n  using value_type = T;\n  vector_type<value_type> st, en;\n  constexpr segment_type(): st(0, 0), en(0, 0) { }\n  constexpr segment_type(const vector_type<value_type> &l, const vector_type<value_type> &r): st(l), en(r) { }\n  constexpr segment_type(value_type x1, value_type y1, value_type x2, value_type y2): st(x1, y1), en(x2, y2) { } \n  constexpr bool operator == (const segment_type &s) const { \n    return (st == s.st && en == s.en) || (st == s.en && en == s.st);\n  }\n  constexpr bool operator != (const segment_type &s) const { \n    return !(st == s.st && en == s.en) && !(st == s.en && en == s.st);\n  }\n};\n\ntemplate <class T>\nconstexpr vector_type<T> direction(const segment_type<T> &l) { return l.en - l.st;; }\ntemplate <class T>\nconstexpr line_type<T> to_line(const segment_type<T> &s) {\n  auto v = direction(s);\n  auto c = v.y * s.st.x - v.x * s.st.y;\n  return line_type<T>(-v.y, v.x, c);\n}\ntemplate <class T>\nconstexpr line_type<T> bisect(const segment_type<T> &s) {\n  auto v = direction(s), u = (s.st + s.en) / 2;\n  return line_type<T>(v.x, v.y, -v.x * u.x - v.y * u.y);\n}\ntemplate <class T>\nconstexpr bool intersects(const segment_type<T> &s, const segment_type<T> &t) {\n  auto v = direction(s), u = direction(t);\n  auto d = cross(v, t.st - s.st) * cross(v, t.en - s.st);\n  auto e = cross(u, s.st - t.st) * cross(u, s.en - t.st);\n  return leq(d, 0) && leq(e, 0);\n}\n\ntemplate <class T>\nstruct circle_type {\n  using value_type = T;\n  vector_type<value_type> cn;\n  value_type rd;\n  circle_type(): cn(0, 0), rd(0) { }\n  circle_type(const vector_type<value_type> &cn_, value_type rd_): cn(cn_), rd(rd_) { }\n  circle_type(value_type x_, value_type y_, value_type rd_): cn(x_, y_), rd(rd_) { }\n};\n\ntemplate <class T>\nconstexpr bool is_on(const circle_type<T> &c, const vector_type<T> &v) {\n  return equal(c.rd * c.rd, norm(v - c.cn));\n}\ntemplate <class T>\nconstexpr bool is_inside(const circle_type<T> &c, const vector_type<T> &v) {\n  return geq(c.rd * c.rd, norm(v - c.cn));\n}\ntemplate <class T>\nstd::vector<vector_type<T>> intersection(const circle_type<T> &c, const circle_type<T> &d) {\n  auto v = d.cn - c.cn;\n  auto l = abs(v);\n  if (equal(l, 0)) return {};\n  if (equal(l + c.rd + d.rd, std::max({ l, c.rd, d.rd }) * 2)) return { c.cn + v * (c.rd / l) };\n  if (l + c.rd + d.rd < std::max({ l, c.rd, d.rd }) * 2) return {};\n  auto x = -(d.rd * d.rd - l * l - c.rd * c.rd) / (l * 2);\n  auto y = std::sqrt(c.rd * c.rd - x * x);\n  auto mid = c.cn + v * (x / l);\n  vector_type<T> vec(-v.y, v.x);\n  return { mid + vec * (y / l), mid - vec * (y / l) };\n}\ntemplate <class T>\nstd::vector<vector_type<T>> intersection(const circle_type<T> &c, const line_type<T> &l) {\n  auto v = project(l, c.cn);\n  if (is_on(c, v)) return { v };\n  if (!is_inside(c, v)) return {};\n  auto u = direction(l);\n  auto d = std::sqrt(c.rd * c.rd - norm(v - c.cn)) / abs(u);\n  return { v + u * d, v - u * d };\n}\n\nint main() {\n  circle_type<double> c;\n  std::cin >> c.cn >> c.rd;\n  int Q;\n  std::cin >> Q;\n  std::cout << std::fixed << std::setprecision(8);\n  while (Q--) {\n    segment_type<double> seg;\n    std::cin >> seg.st >> seg.en;\n    auto ans = intersection(c, to_line(seg));\n    std::sort(ans.begin(), ans.end(), cmp_x<double>);\n    if (ans.size() == 1) {\n      std::cout << ans[0] << ' ' << ans[0] << '\\n';\n    }\n    else {\n      std::cout << ans[0] << ' ' << ans[1] << '\\n';\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct point{\n    double  x,y;\n    point(){};\n    point(double x,double y):x(x),y(y){}\n    point operator + (point p){\n        return point(x+p.x,y+p.y);\n    }\n    point operator - (point p){\n        return point(x-p.x,y-p.y);\n    }\n    point operator * (double k){\n        return point(x*k,y*k);\n    }\n    point operator / (double k){\n        return point(x/k,y/k);\n    }\n};\n\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(point a,point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(point p)\n{\n    return p.x*p.x+p.y*p.y;\n}\ndouble ABS(point p)\n{\n    return sqrt(norm(p));\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/norm(base);\n    return a+(base*r);\n}\n\npair<point,point>getcrosspoints(point a,int r,point b,point c)\n{\n    point pr=project(b,c,a);\n    point e=(b-c)/ABS(b-c);\n    double base=sqrt(r*r*1.0-norm(pr-a));\n    e=e*base;\n    return make_pair(pr+e,pr-e);\n}\n\nint main()\n{\n    point a;\n    int temp;\n    cin>>a.x>>a.y>>temp;\n    int q;\n    cin>>q;\n    point c,d;\n    for(int i=0;i<q;i++){\n        cin>>c.x>>c.y>>d.x>>d.y;\n        pair<point,point>res=getcrosspoints(a,temp,c,d);\n        if(res.first.x>res.second.x){\n            swap(res.first,res.second);\n        }else if(res.first.x==res.second.x){\n            if(res.first.y>res.second.y){\n                swap(res.first,res.second);\n            }\n        }\n        printf(\"%.8f %.8f %.8f %.8f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <array>\n#include <algorithm>\n#include <cassert>\n\nusing Number = double;\n\nconst Number EPS = 1e-10;\nconst Number INF = 1e10;\nconst Number PI = acos(-1.0);\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\n// change between degree and radian\ninline Number to_radian(const Number degree) { return degree * PI / 180.0; }\ninline Number to_degree(const Number radian) { return radian * 180.0 / PI; }\n\n\n/**\n * Point in two dimensional\n */\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    // Arithmetic operator between points\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(const Point &rhs) const { // cross product between points\n        return Point(this->x * rhs.x - this->y * rhs.y,\n                     this->x * rhs.x + this->y * rhs.x);\n    }\n\n    // Unary operator and compound assignment operator\n    Point operator-() const {\n        return Point(-this->x, -this->y);\n    }\n    Point& operator+=(const Point &rhs) {\n        return *this = *this + rhs;\n    }\n    Point& operator-=(const Point &rhs) {\n        return *this = *this - rhs;\n    }\n\n    // Arithmetic operator between point and number\n    Point operator*(Number rhs) const {\n        return Point(this->x * rhs, this->y * rhs);\n    }\n    Point operator/(Number rhs) const {\n        return Point(this->x / rhs, this->y / rhs);\n    }\n\n    // Comparison operation\n    bool operator==(const Point &rhs) const {\n        return sign(this->x - rhs.x) == 0 && sign(this->y - rhs.y) == 0;\n    }\n    bool operator<(const Point &rhs) const {\n        return (this->x < rhs.x) || (this->x == rhs.x && this->y < rhs.y);\n    }\n\n    // Other operator\n    Number abs(void) const {\n        return sqrt(this->x * this->x + this->y * this->y);\n    }\n    Number abs2(void) const {\n        return this->x * this->x + this->y * this->y;\n    }\n    Number arg(void) const {\n        return atan2(this->y, this->x);\n    }\n    Number dot(const Point &rhs) {\n        return this->x * rhs.x + this->y * rhs.y;\n    }\n    Point rotate90(void) const {\n        return Point(-this->y, this->x);\n    }\n    Point rotate(double angle) const {\n        return Point(cos(angle) * this->x - sin(angle) * this->y,\n                     sin(angle) * this->x + cos(angle) * this->y);\n    }\n\n};\ninline Number dot(const Point &p1, const Point &p2) {\n    return p1.x * p2.x + p1.y * p2.y;\n}\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n// Output of a point\nstd::ostream& operator<<(std::ostream &os, const Point &p) {\n    return os <<  p.x << ' ' << p.y;\n}\n// Input of a point\nstd::istream& operator>>(std::istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\n\n// Counter-Clockwise predicate (a, b, c)\nenum CCW {\n    COUNTER_CLOCKWISE = 1,      // counter clockwise\n    CLOCKWISE         = -1,     // clockwise\n    ONLINE_FRONT      = 2,      // a--c--b on line\n    ONLINE_BACK       = -2,      // c--a--b on line\n    ON_SEGMENT        = 0,     // a--b--c on line\n};\nCCW ccw(const Point &a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (abs_cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (abs_cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0)       return ONLINE_BACK;\n    if (b.abs2() < c.abs2())   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n/**\n * Line in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0] >> l[1];\n}\ninline CCW ccw(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p);\n}\n\n\n/**\n * Segment in two dimensional\n */\nclass Segment : public Line {\npublic:\n    Segment() {}\n    Segment(const Point &p1, const Point &p2) : Line(p1, p2) {}\n};\n\n\n/**\n * Circle in two dimensional\n */\nclass Circle : public Point {\npublic:\n    Number r;\n    Circle() {}\n    Circle(const Point &p, Number r = 0.0) : Point(p), r(r) {}\n};\n// Input of a circle\nstd::istream& operator>>(std::istream &is, Circle &c) {\n    return is >> c.x >> c.y >> c.r;\n}\n\n\n\n/**\n * Intersection testing\n */\nPoint Projection(const Line &l, const Point &p) {\n    Point dir = l[1] - l[0];\n    Number t = dot(p - l[0], dir) / dir.abs2();\n    return l[0] + dir * t;\n}\ninline Point Reflection(const Line &l, const Point &p) {\n    return Projection(l, p) * 2.0 - p;\n}\n\ninline bool IsOrthogonal(const Line &l1, const Line &l2) {\n    return equal(dot(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\ninline bool IsIntersect(const Line &l, const Point &p) {\n    return abs(ccw(l[0], l[1], p)) != 1;\n}\ninline bool IsIntersect(const Segment &s, const Point &p) {\n    return ccw(s[0], s[1], p) == 0;\n}\ninline bool IsIntersect(const Line &l1, const Line l2) {\n    return !IsParallel(l1, l2) || IsParallel(l1, Line(l1[0], l2[0]));\n}\ninline bool IsIntersect(const Line &l, const Segment &s) {\n    return abs_cross(l[1] - l[0], s[0] - l[0]) *\n        abs_cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\ninline bool IsIntersect(const Segment &s1, const Segment &s2) {\n    return ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n        ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\ninline bool IsIntersect(const Circle &c, const Point &p) { // p is in interior or boundary\n    return (c - p).abs() <= c.r + EPS;\n}\ninline bool IsIntersect(const Circle &c, const Line &l) {\n    return IsIntersect(c, Projection(l, c));\n}\ninline bool IsIntersect(const Circle &c1, const Circle &c2) {\n    return (c1 - c2).abs() <= c1.r + c2.r && abs(c1.r - c2.r) <= (c1 - c2).abs();\n}\n\n\n/**\n * Distance and Intersection point\n */\ninline Number Distance(const Point &p1, const Point &p2) {\n    return (p1 - p2).abs();\n}\ninline Number Distance(const Line &l, const Point &p) {\n    return (p - Projection(l, p)).abs();\n}\ninline Number Distance(const Segment &s, const Point &p) {\n    if (sign(dot(s[1] - s[0], p - s[0])) == -1) return (p - s[0]).abs();\n    if (sign(dot(s[0] - s[1], p - s[1])) == -1) return (p - s[1]).abs();\n    return (p - Projection(s, p)).abs();\n}\ninline Number Distance(const Line &l1, const Line &l2) {\n    return IsIntersect(l1, l2) ? 0 : Distance(l1, l2[0]);\n}\ninline Number Distance(const Line &l, const Segment &s) {\n    if (IsIntersect(l, s)) return 0.0;\n    return std::min(Distance(l, s[0]), Distance(l, s[1]));\n}\ninline Number Distance(const Segment &s1, const Segment &s2) {\n    if (IsIntersect(s1, s2)) return 0.0;\n    return std::min({Distance(s1, s2[0]), Distance(s1, s2[1]),\n                Distance(s2, s1[0]), Distance(s2, s1[1])});\n}\n\nPoint CrossPoint(const Line &s1, const Line &s2) {\n    Point base = s2[1] - s2[0];\n    Number d1 = abs(abs_cross(base, s1[0] - s2[0]));\n    Number d2 = abs(abs_cross(base, s1[1] - s2[0]));\n    Number t = d1 / (d1 + d2);\n    return s1[0] + (s1[1] - s1[0]) * t;\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c1, const Circle &c2) {\n    Number d = Distance(c1, c2);\n    Number rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2.0 * d);\n    Number rs = sqrt(c1.r * c1.r - rc * rc);\n    Point diff = (c2 - c1) / d;\n    return std::make_pair(c1 + diff * Point(rc, rs), c1 + diff * Point(rc, -rs));\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c, const Line &l) {\n    assert(true);\n    Point mid = Projection(l, c);\n    Point e = (l[1] - l[0]) / (l[1] - l[0]).abs();\n    Number len = sqrt(c.r * c.r - (mid - c).abs2());\n    return std::make_pair(mid - e * len, mid + e * len);\n}\n\n\nint main()\n{\n    std::cout << std::fixed << std::setprecision(15);\n\n    Circle c;\n    Line l;\n    int q;\n\n    std::cin >> c >> q;\n\n    while (q--) {\n        std::cin >> l;\n        auto ans = CrossPoint(c, l);\n        std::cout << ans.first << ' ' << ans.second << '\\n';\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// geo\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n    Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n    Point operator*(double a) { return Point(x * a, y * a); }\n    Point operator/(double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator<(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nclass vector<Point> Polygon;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\n\ndouble abs(Vector a) { return sqrt(norm(a)); }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\n\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\n\nenum Position {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ON_SEGMENT = 0,\n    ONLINE_FRONT = -2\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    enum Position p;\n    if (cross(a, b) > EPS)\n        p = COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -EPS)\n        p = CLOCKWISE;\n    else if (dot(a, b) < -EPS)\n        p = ONLINE_BACK;\n    else if (a.norm() < b.norm())\n        p = ONLINE_FRONT;\n    else\n        p = ON_SEGMENT;\n    return p;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Point a, Point b) {\n    Vector v = a - b;\n    return v.abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    double c = cross(l.p2 - l.p1, p - l.p1);\n    Vector v = l.p2 - l.p1;\n    return abs(c) / v.abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nbool hasCrossPoint(Circle c, Line l) {\n    if (getDistanceLP(l, c.c) <= c.r) return true;\n    return false;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return MP(pr + e * base, pr - e * base);\n}\n\nint main(void) {\n    Circle c;\n    cin >> c.c.x >> c.c.y >> c.r;\n    int n;\n    cin >> n;\n    Line l[n];\n    REP(i, n) cin >> l[i].p1.x >> l[i].p1.y >> l[i].p2.x >> l[i].p2.y;\n    REP(i, n) {\n        pair<Point, Point> p = getCrossPoints(c, l[i]);\n        if (p.first < p.second) {\n            cout << fixed << setprecision(10) << p.first.x << \" \" << p.first.y\n                 << \" \" << p.second.x << \" \" << p.second.y << endl;\n        } else {\n            cout << fixed << setprecision(10) << p.second.x << \" \" << p.second.y\n                 << \" \" << p.first.x << \" \" << p.first.y << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\nstruct point{\n    int x,y;\n};\n\nstruct line{\n    point s,t;\n};\nstruct bec{\n    int x,y;\n};\nstruct circle{\n    point p;\n    int r;\n};\npoint kouten;\n\ndouble suichoku(point p, line l){\n    bec p1p,p1p2;\n    p1p.x=p.x-l.s.x; p1p.y=p.y-l.s.y;\n    p1p2.x=l.t.x-l.s.x; p1p2.y=l.t.y-l.s.y;\n    double c,dp,dp2,k,ansx,ansy;\n    dp=sqrt((double)p1p.x*(double)p1p.x+(double)p1p.y*(double)p1p.y);\n\n    if(dp==0){\n        kouten.x=p.x;\n        kouten.y=p.y;\n        return 0;\n    }\n\n    dp2=sqrt((double)p1p2.x*(double)p1p2.x+(double)p1p2.y*(double)p1p2.y);\n    c=((double)p1p.x*(double)p1p2.x+(double)p1p.y*(double)p1p2.y)/(dp*dp2);\n    k=dp*c;\n    ansx=l.s.x+k*(p1p2.x/dp2);\n    ansy=l.s.y+k*(p1p2.y/dp2);\n    kouten.x=ansx; kouten.y=ansy;\n\n    return sqrt((p.x-ansx)*(p.x-ansx)+(p.y-ansy)*(p.y-ansy));\n    \n}\nvoid solve(circle o, line l){\n    bec p;\n    double d=suichoku(o.p,l);\n    double co = sqrt(1-(d/o.r)*(d/o.r));\n    double ansx1,ansx2,ansy1,ansy2;\n\n    p.x=l.t.x-l.s.x;\n    p.y=l.t.y-l.s.y;\n\n    double dp = sqrt((double)p.x*(double)p.x+(double)p.y*(double)p.y);\n    ansx1 = kouten.x-(o.r*co)*(p.x/dp);\n    ansx2 = kouten.x+(o.r*co)*(p.x/dp);\n    ansy1 = kouten.y-(o.r*co)*(p.y/dp);\n    ansy2 = kouten.y+(o.r*co)*(p.y/dp);\n\n    if(ansx1<ansx2) printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n    else if(ansx1==ansx2){\n        if(ansy1<ansy2) printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n        else printf(\"%.8f %.8f %.8f %.8f\\n\",ansx2,ansy2,ansx1,ansy1);\n    }\n    else printf(\"%.8f %.8f %.8f %.8f\\n\",ansx2,ansy2,ansx1,ansy1);\n}\n\nint main(){\n    int cx,cy,x1,x2,y1,y2,n,r;\n    point p,s,t;\n    line l;\n    circle o;\n\n    cin>>cx>>cy>>r;\n    p.x=cx;\n    p.y=cy;\n    o.p=p; o.r=r;\n\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>x1>>y1>>x2>>y2;\n        s.x=x1; s.y=y1;\n        t.x=x2; t.y=y2;\n        l.s=s; l.t=t;\n        solve(o,l);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(::abs(x), ::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n\n//robust less\nbool rless(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    if (sgn(cross(l.vec(), m.vec())) == 0) {\n        r = l.s;\n        if (ccw(l.s, l.t, m.s) % 2 == 0) return -1;\n        return 0;\n    }\n    D t = cross(l.vec(), l.t - m.s) / cross(l.vec(), m.vec());\n    r = m.s + m.vec() * t;\n    return 1;\n}\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / (v.x*v.x + v.y*v.y));\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u - c.r);\n    if (si == 1) return 0;\n    P v = (l.t-l.s) / l.abs() * P(0, -1); //lに直行する単位ベクトル\n    v *= u;\n    if (ccw(l.s, l.t, c.p) < 0) v *= -1;\n    //vは円の中心からlへと向かう方向のベクトル\n    if (si == 0) {\n        r.s = r.t = c.p + v;\n        return 1;\n    }\n    r.s = c.p+v+P::polar(sqrt(c.r*c.r - u*u), l.arg());\n    r.t = c.p+v-P::polar(sqrt(c.r*c.r - u*u), l.arg());\n    return 2;\n}\n\n//共通内接線\nint internal_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(c.r + d.r, di) == 1) return 0;\n    D th = acos((c.r+d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p - P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p - P::polar(d.r, ar+th);\n    if (sgn(di, c.r + d.r) == 0) return 1;\n    return 2;\n}\n\n//共通外接線\nint external_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(abs(c.r - d.r), di) == 1) return 0;\n    assert(sgn(di)); // prohibit same circles\n    D th = acos((c.r-d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p + P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p + P::polar(d.r, ar+th);\n    if (sgn(di, abs(c.r - d.r)) == 0) return 1;\n    return 2;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    D x, y, r;\n    cin >> x >> y >> r;\n    C c = C(P(x, y), r);\n    \n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        P p1, p2;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        L l;\n        crossLC(L(p1, p2), c, l);\n        if (!rless(l.s, l.t)) swap(l.s, l.t);\n        cout << l.s.x << \" \" << l.s.y << \" \" << l.t.x << \" \" << l.t.y << endl;\n    }\n    \n/*    C c1, c2;\n    D x, y, r;\n    cin >> x >> y >> r; c1 = C(P(x, y), r);\n    cin >> x >> y >> r; c2 = C(P(x, y), r);\n\n    L l1, l2;\n    int z;\n    V<P> res;\n    z = internal_tangent(c2, c1, l1, l2);\n    if (z >= 1) res.push_back(l1.t);\n    if (z >= 2) res.push_back(l2.t);\n    z = external_tangent(c2, c1, l1, l2);\n    if (z >= 1) res.push_back(l1.t);\n    if (z >= 2) res.push_back(l2.t);\n\n    sort(begin(res), end(res), rless);\n    for (auto p: res) {\n        cout << p.x << \" \" << p.y << endl;\n    }*/\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´?????????????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶????????????????????¬\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°????????????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//?????¨??´???????????????2??????\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//????´???°2D///////////A???)///////////\ntypedef complex<double> comp;\ntypedef vector<comp> cvec;\n//????´???????\ndouble dot(comp a,comp b){return real(b*conj(a));}\n//????´???????\ndouble cross(comp a,comp b){return imag(b*conj(a));}\ndouble Area(cvec &a){\n  double b=0;int n=a.size();\n  for(int i=0;i<n;i++)\n    b+=cross(a[i],a[(i+1==n?0:i+1)]);\n  return abs(b/2.0);\n}\n////how to use(exp)/////////////////////\n//  double a,b; cvec t; cin>>n;       //\n// while(n--){                        //\n//    cin>>a>>b;                      //\n//    t.push_back(comp(a,b));         //\n//  }printf(\"%.11f\\n\",Area(t));       //\n////////////////////////////////////////\nseg scan(){\n  seg a;\n  scanf(\"%lf%lf%lf%lf\",&a.p1.x,&a.p1.y,&a.p2.x,&a.p2.y);\n  return a;\n}\n\nint main(){\n  Circle o;\n  cin>>o.c.x>>o.c.y>>o.r;\n  int n;\n  cin>>n;\n  while(n--){\n    seg a;\n    a=scan();\n    seg p=getCrossPoint(o,a);\n    if(p.p1.x>p.p2.x){\n      Point t;\n      t=p.p1;\n      p.p1=p.p2;\n      p.p2=t;\n    }\n    else if(p.p1.y>p.p2.y){\n      Point t;\n      t=p.p1;\n      p.p1=p.p2;\n      p.p2=t;\n    }\n    printf(\"%.9f %.9f %.9f %.9f\\n\",p.p1.x,p.p1.y,p.p2.x,p.p2.y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-7)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\tcout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tdouble base = sqrt(r * r - pr.norm());\n\n\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * base;\n\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * base;\n\t/*\n\tif (equals(ans1.x, ans2.x)) {\n\t\tif (ans1.y < ans2.y) {\n\t\t\treturn make_pair(ans1, ans2);\n\t\t} else {\n\t\t\treturn make_pair(ans2, ans1);\n\t\t}\n\t}else if (ans1.x < ans2.x) {\n\t\treturn make_pair(ans1, ans2);\n\t} else {\n\t\treturn make_pair(ans2, ans1);\n\t}\n\t*/\n\treturn make_pair(ans1, ans2);\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(x * a, y * a); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\nclass Circle {\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x; \n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n    return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\ndouble getDistanceSP(Segment s, Point p) {\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n    return getDistanceLP(s, p);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = fabs(cross(s1.p1 - s2.p1, base));\n    double d2 = fabs(cross(s1.p2 - s2.p1, base));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt((c.r * c.r) - (pr - c.c).norm());\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint main()\n{\n    int q;\n    double x1, x2, x3, y1, y2, y3, r;\n    Line l;\n    cin >> x1 >> y1 >> r;\n    Circle c = Circle(Point(x1, y1), r);\n    cin >> q;\n    for (int i = 0; i != q; ++i)\n    {\n        cin >> x2 >> y2 >> x3 >> y3;\n        l.p1 = Point(x2, y2);\n        l.p2 = Point(x3, y3);\n        pair<Point, Point> res = getCrossPoints(c, l);\n        cout << fixed << setprecision(10);\n        if (res.first < res.second)\n        {\n            cout << res.first.x << \" \" << res.first.y << \" \" << res.second.x << \" \" << res.second.y << endl;\n        }\n        else\n        {\n            cout << res.second.x << \" \" << res.second.y << \" \" << res.first.x << \" \" << res.first.y << endl;\n        }\n        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace Geo2D{\n\ttypedef long long int ll;\n\tconst double eps = 1e-8;\n\tconst double pi = acos(-1);\n\tconst double inf = 1e100;\n\t/* Be careful for the criteria for == two doubles */\n\t/* Relative or Absolute? */\n\tstruct Double{\n\t\tdouble x;\n\t\tDouble(double x=0):x(x){}\n\t\tDouble(const Double& rhs){x=rhs.x;}\n\t\tDouble operator+(const Double& rhs)const{return Double(x+rhs.x);}\n\t\tDouble& operator+=(const Double& rhs){return x+=rhs.x,*this;}\n\t\tDouble operator-(const Double& rhs)const{return Double(x-rhs.x);}\n\t\tDouble& operator-=(const Double& rhs){return x-=rhs.x,*this;}\n\t\tDouble operator*(const Double& rhs)const{return Double(x*rhs.x);}\n\t\tDouble& operator*=(const Double& rhs){return x*=rhs.x,*this;}\n\t\tDouble operator/(const Double& rhs)const{return Double(x/rhs.x);}\n\t\tDouble& operator/=(const Double& rhs){return x/=rhs.x,*this;}\n\t\tDouble operator-()const{return Double(-x);}\n\t\tDouble operator^(const Double& rhs)const{return pow(x,rhs.x);}\n\t\tDouble operator^(const int& rhs)const{\n\t\t\tdouble res = 1, base = x;\n\t\t\tint b = rhs;\n\t\t\twhile(b){\n\t\t\t\tif(b&1)\tres = res * base;\n\t\t\t\tb >>= 1;\n\t\t\t\tbase *= base;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tDouble& operator++(){return ++x,*this;}\n\t\tDouble& operator--(){return --x,*this;}\n\t\tDouble operator++(int){Double res(x);return x++,res;}\n\t\tDouble operator--(int){Double res(x);return x--,res;}\n\t\tbool operator==(const Double& rhs)const{return x+eps>=rhs.x&&x<=rhs.x+eps;}\n\t\tbool operator!=(const Double& rhs)const{return !(*this==rhs);}\n\t\tbool operator<(const Double& rhs)const{return (*this==rhs)?false:x<rhs.x;}\n\t\tbool operator>(const Double& rhs)const{return (*this==rhs)?false:x>rhs.x;}\n\t\tbool operator<=(const Double& rhs)const{return (*this==rhs)?true:x<rhs.x;}\n\t\tbool operator>=(const Double& rhs)const{return (*this==rhs)?true:x>rhs.x;}\n\t\tfriend ostream & operator << (ostream& os, const Double& rhs){\n\t\t\tos << rhs.x;\n\t\t\treturn os;\n\t\t}\n\t\tfriend istream & operator >> (istream& is, Double& rhs){\n\t\t\tis >> rhs.x;\n\t\t\treturn is;\n\t\t}\n\t\tfriend Double abs(const Double& rhs){return abs(rhs.x);}\n\t\tfriend Double sin(const Double& rhs){return sin(rhs.x);}\n\t\tfriend Double cos(const Double& rhs){return cos(rhs.x);}\n\t\tfriend Double tan(const Double& rhs){return tan(rhs.x);}\n\t\tfriend Double asin(const Double& rhs){return asin(rhs.x);}\n\t\tfriend Double acos(const Double& rhs){return acos(rhs.x);}\n\t\tfriend Double atan(const Double& rhs){return atan(rhs.x);}\n\t\tfriend Double atan2(const Double& lhs,const Double& rhs){return atan2(lhs.x,rhs.x);}\n\t\tfriend Double sqrt(const Double& rhs){return sqrt(rhs.x);}\n\t\tfriend ll ceil(const Double& rhs){return ceil(rhs.x);}\n\t\tfriend ll round(const Double& rhs){return round(rhs.x);}\n\t\tfriend ll floor(const Double& rhs){return floor(rhs.x);}\n\t\tfriend int sign(const Double& rhs){return (rhs<0)?(-1):(rhs>0);}\n\t};\n\ttypedef Double T;\n\t/* To change a point, do P = P.member_function() */\n\tstruct Point{\n\t\tT x,y;\n\t\tPoint(T x=0,T y=0):x(x),y(y){}\n\t\tbool operator<(const Point& rhs)const{return x==rhs.x?y<rhs.y:x<rhs.x;}\n\t\tbool operator==(const Point& rhs)const{return x==rhs.x&&y==rhs.y;}\n\t\tPoint operator-()const{return Point(-x,-y);}\n\t\tPoint operator+(const Point& rhs)const{return Point(x+rhs.x,y+rhs.y);}\n\t\tPoint operator-(const Point& rhs)const{return Point(x-rhs.x,y-rhs.y);}\n\t\tT operator*(const Point& rhs)const{return x*rhs.x+y*rhs.y;}\n\t\tPoint operator*(const T& rhs)const{return Point(x*rhs,y*rhs);}\n\t\tPoint operator/(const T& rhs)const{return Point(x/rhs,y/rhs);}\n\t\tT operator^(const Point& rhs)const{return x*rhs.y-y*rhs.x;}\n\t\tDouble len()const{return sqrt(x*x+y*y);}\n\t\tT len2()const{return x*x+y*y;}\n\t\tDouble dist(const Point& rhs)const{Point delta = *this - rhs;return delta.len();}\n\t\tT dist2(const Point& rhs)const{Point delta = *this - rhs;return delta.len2();}\n\t\tPoint norm()const{Double l = len();return *this/l;}\n\t\tPoint resize(Double l)const{return norm()*l;}\n\t\tPoint rotpos()const{return Point(-y,x);}\n\t\tPoint rotneg()const{return Point(y,-x);}\n\t\tPoint rot(const Double& ang)const{return Point(x*cos(ang)-y*sin(ang),y*cos(ang)+x*sin(ang));}\n\t\t/* friend function */\n\t\t/* the angle of ABC <= 180 */\n\t\tfriend Double angle(const Point& A,const Point& B,const Point& C){\n\t\t\treturn abs(atan2(abs((A-B)^(C-B)),(A-B)*(C-B)));\n\t\t}\n\t\tfriend ostream & operator << (ostream& os, const Point& rhs){\n\t\t\tos << rhs.x << ' ' << rhs.y;\n\t\t\treturn os;\n\t\t}\n\t\tfriend istream & operator >> (istream& is, Point& rhs){\n\t\t\tis >> rhs.x >> rhs.y;\n\t\t\treturn is;\n\t\t}\n\t};\n\t/* ccw, call hull for Pp,Pq beforehand */\n\tvector<Point> Minkowski(vector<Point>& Pp,vector<Point>& Pq){\n\t\tint n=Pp.size(),m=Pq.size();\n\t\tvector<Point> Pr;\n\t\tPr.emplace_back(Pp[0]+Pq[0]);\n\t\tPp.emplace_back(Pp[0]);Pq.emplace_back(Pq[0]);\n\t\tfor(int i=0,j=0;i!=n||j!=m;){\n\t\t\tPoint nxt;\n\t\t\tif((j==m)||(i!=n&&((Pp[i+1]-Pp[i])^(Pq[j+1]-Pq[j]))>=0)){\n\t\t\t\tnxt=Pr.back()+Pp[i+1]-Pp[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnxt=Pr.back()+Pq[j+1]-Pq[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\twhile(Pr.size()>=2&&((Pr.back()-nxt)^(Pr[Pr.size()-2]-nxt))==0)\n\t\t\t\tPr.pop_back();\n\t\t\tPr.emplace_back(nxt);\n\t\t}\n\t\tPp.pop_back();Pq.pop_back();Pr.pop_back();\n\t\treturn Pr;\n\t}\n\tbool inConvex(vector<Point>& c,const Point& p){\n\t\tint L=1,R=c.size()-1;\n\t\tif(((p-c[0])^(c[L]-c[0]))>0)\treturn false;\n\t\tif(((p-c[0])^(c[R]-c[0]))<0)\treturn false;\n\t\twhile(L<R){\n\t\t\tint mid=(L+R+1)>>1;\n\t\t\tif(((p-c[0])^(c[mid]-c[0]))<=0)\tL=mid;\n\t\t\telse\tR=mid-1;\n\t\t}\n\t\tif(L==c.size()-1)\tL--;\n\t\treturn ((p-c[L])^(c[L+1]-c[L]))<=0;\n\t}\n\t/* (-pi,pi] */\n\tDouble norm(Double ang){\n\t\tang = ang-round(ang/pi/2)*pi*2;\n\t\tif(ang<=-pi)\tang+=2*pi;\n\t\tif(ang>pi)\tang-=2*pi;\n\t\treturn ang;\n\t}\n\tstruct Line{\n\t\tPoint s,e;\n\t\tLine(Point s=Point(),Point e=Point()):s(s),e(e){}\n\t\tLine(Point p,Double ang):s(p){\n\t\t\tang=norm(ang);\n\t\t\tif(ang==pi/2)\te=s+Point(0,1);\n\t\t\telse if(ang==-pi/2)\te=s-Point(0,1);\n\t\t\telse\te=s+Point(1,tan(ang));\n\t\t}\n\t\t/* ax+by+c==0 */\n\t\tLine(Double a,Double b,Double c){\n\t\t\tif(a==0){\n\t\t\t\ts=Point(0,-c/b);\n\t\t\t\te=Point(1,-c/b);\n\t\t\t}\n\t\t\telse if(b==0){\n\t\t\t\ts=Point(-c/a,0);\n\t\t\t\te=Point(-c/a,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts=Point(0,-c/b);\n\t\t\t\te=Point(-c/a,0);\n\t\t\t}\n\t\t}\n\t\tbool operator==(const Line& rhs)const{return s==rhs.s&&e==rhs.e;}\n\t\tDouble len()const{return s.dist(e);}\n\t\tT len2()const{return s.dist2(e);}\n\t\tDouble angle()const{return atan2(e.y-s.y,e.x-s.x);}\n\t\tPoint projection(const Point& p)const{\n\t\t\treturn s+((e-s)*((e-s)*(p-s)))/(e-s).len2();\n\t\t}\n\t\tPoint symmetry(const Point& p)const{\n\t\t\treturn projection(p)*2-p;\n\t\t}\n\t\t/* -1: at left, 0: on line, 1: at right */\n\t\tint where(const Point& p)const{\n\t\t\tauto x = (p-s)^(e-s);\n\t\t\tif(x==0)\treturn 0;\n\t\t\telse if(x>0)\treturn 1;\n\t\t\telse return -1;\n\t\t}\n\t\t/* 0: parallel, 1: same, 2: orthogonal, 3: intersect */\n\t\tint relation(const Line& l)const{\n\t\t\tif(parallel(l))\treturn where(l.s)==0;\n\t\t\telse if(orthogonal(l))\treturn 2;\n\t\t\telse return 3;\n\t\t}\n\t\tbool onseg(const Point& p)const{return ((p-s)^(e-s))==0&&((p-s)*(p-e))<=0;}\n\t\tbool parallel(const Line& l)const{return ((e-s)^(l.e-l.s))==0;}\n\t\tbool orthogonal(const Line& l)const{return ((e-s)*(l.e-l.s))==0;}\n\t\t/* 0: no intersection, 1: not normal, 2: normal */\n\t\t/* *this is line, l is seg */\n\t\tint linecrossseg(const Line& l)const{\n\t\t\tint d0 = sign((e-s)^(l.s-s));\n\t\t\tint d1 = sign((e-s)^(l.e-s));\n\t\t\tif((d0^d1)==-2)\treturn 2;\n\t\t\treturn d0==0||d1==0;\n\t\t}\n\t\t/* 0: no intersection, 1: not normal, 2: normal */\n\t\tint segcrossseg(const Line& l)const{\n\t\t\tint d0 = sign((e-s)^(l.s-s));\n\t\t\tint d1 = sign((e-s)^(l.e-s));\n\t\t\tint d2 = sign((l.e-l.s)^(s-l.s));\n\t\t\tint d3 = sign((l.e-l.s)^(e-l.s));\n\t\t\tif((d0^d1)==-2&&(d2^d3)==-2)\treturn 2;\n\t\t\treturn (d0==0&&onseg(l.s))||(d1==0&&onseg(l.e))||(d2==0&&l.onseg(s))||(d3==0&&l.onseg(e));\n\t\t}\n\t\tDouble distasline(const Point& p)const{return abs(((p-s)^(e-s))/len());}\n\t\tDouble distasseg(const Point& p)const{\n\t\t\tif(((p-s)*(e-s))<0||((p-e)*(s-e))<0)\n\t\t\t\treturn min(s.dist(p),e.dist(p));\n\t\t\treturn distasline(p);\n\t\t}\n\t\t/* both are segs */\n\t\tDouble distsegseg(const Line& l)const{\n\t\t\tif(segcrossseg(l)!=0)\treturn 0;\n\t\t\treturn min(min(distasseg(l.s),distasseg(l.e)),min(l.distasseg(s),l.distasseg(e)));\n\t\t}\n\t\t/* *this is line */\n\t\tDouble distlineseg(const Line& l)const{\n\t\t\tif(linecrossseg(l)==0)\n\t\t\t\treturn min(distasline(l.s),distasline(l.e));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfriend ostream & operator << (ostream& os, const Line& rhs){\n\t\t\tos << rhs.s << ' ' << rhs.e;\n\t\t\treturn os;\n\t\t}\n\t\tfriend istream & operator >> (istream& is, Line& rhs){\n\t\t\tis >> rhs.s >> rhs.e;\n\t\t\treturn is;\n\t\t}\n\t\tfriend Point intersectLL(const Line& l,const Line& r){\n\t\t\tDouble s1=(r.e-r.s)^(l.s-r.s), s2=-((r.e-r.s)^(l.e-r.s));\n\t\t\treturn (l.s*s2+l.e*s1)/(s1+s2);\n\t\t}\n\t};\n\tstruct Circle{\n\t\tPoint p;\n\t\tDouble r;\n\t\tCircle(Point p=Point(),Double r=0):p(p),r(r){}\n\t\tCircle(Double x,Double y,Double r):p(Point(x,y)),r(r){}\n\t\tbool operator==(const Circle& rhs)const{return p==rhs.p&&r==rhs.r;}\n\t\tbool operator<(const Circle& rhs)const{return p<rhs.p||(p==rhs.p&&r<rhs.r);}\n\t\tDouble area()const{return r*r*pi;}\n\t\tDouble circum()const{return r*pi*2;}\n\t\t/* -1: in, 0: on, 1: out */\n\t\tint relation(const Point& rhs)const{\n\t\t\tDouble d=p.dist(rhs);\n\t\t\tif(d<r)\treturn -1;\n\t\t\tif(d==r)\treturn 0;\n\t\t\telse return 1;\n\t\t}\n\t\t/* -1: somewhere inside, 0: intersect once, 1: totally outside */\n\t\tint relationseg(const Line& rhs)const{\n\t\t\tDouble d=rhs.distasseg(p);\n\t\t\tif(d<r)\treturn -1;\n\t\t\tif(d==r)\treturn 0;\n\t\t\telse return 1;\n\t\t}\n\t\t/* -1: somewhere inside, 0: tangent, 1: totally outside */\n\t\tint relationline(const Line& rhs)const{\n\t\t\tDouble d=rhs.distasline(p);\n\t\t\tif(d<r)\treturn -1;\n\t\t\tif(d==r)\treturn 0;\n\t\t\telse return 1;\n\t\t}\n\t\t/* -3: equal\n\t\t   -2: contain\n\t\t   -1: in tangent\n\t\t    0: intersect\n\t\t    1: ex tangent\n\t\t    2: separate */\n\t\tint relation(const Circle& rhs)const{\n\t\t\tif(*this==rhs)\treturn -3;\n\t\t\tDouble d=p.dist(rhs.p), l=abs(r-rhs.r);\n\t\t\tif(d>r+rhs.r)\treturn 2;\n\t\t\tif(d==r+rhs.r)\treturn 1;\n\t\t\tif(d>l)\treturn 0;\n\t\t\tif(d==l)\treturn -1;\n\t\t\treturn -2;\n\t\t}\n\t\tfriend ostream & operator << (ostream& os, const Circle& rhs){\n\t\t\tos << rhs.p << ' ' << rhs.r;\n\t\t\treturn os;\n\t\t}\n\t\tfriend istream & operator >> (istream& is, Circle& rhs){\n\t\t\tis >> rhs.p >> rhs.r;\n\t\t\treturn is;\n\t\t}\n\t\tfriend vector<Point> intersectCL(const Circle& C,const Line& L){\n\t\t\tint rel=C.relationline(L);\n\t\t\tPoint proj=L.projection(C.p);\n\t\t\tif(rel==1)\treturn {};\n\t\t\telse if(rel==0)\treturn {proj};\n\t\t\telse{\n\t\t\t\tDouble d=L.distasline(C.p);\n\t\t\t\td=sqrt(C.r*C.r-d*d);\n\t\t\t\tvector<Point> res;\n\t\t\t\tres.emplace_back(proj+(L.e-L.s).resize(d));\n\t\t\t\tres.emplace_back(proj-(L.e-L.s).resize(d));\n\t\t\t\tif(res[1]<res[0])\n\t\t\t\t\tswap(res[0],res[1]);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t};\n\n\t/* Triangle Centers */\n\tPoint incenter(const Point& A,const Point& B,const Point& C){\n\t\tauto a=(B-C).len(),b=(A-C).len(),c=(A-B).len();\n\t\treturn (A*a+B*b+C*c)/(a+b+c);\n\t}\n\tPoint circenter(const Point& A,const Point& B,const Point& C){\n\t\tLine u((A+B)/2,(A+B)/2+(B-A).rotpos());\n\t\tLine v((A+C)/2,(A+C)/2+(C-A).rotpos());\n\t\treturn intersectLL(u,v);\n\t}\n\tPoint masscenter(const Point& A,const Point& B,const Point& C){\n\t\treturn (A+B+C)/3;\n\t}\n\tPoint orthocenter(const Point& A,const Point& B,const Point& C){\n\t\treturn masscenter(A,B,C)*3-circenter(A,B,C)*2;\n\t}\n\n\t/* not necessary convex */\n\tstruct Polygon:vector<Point>{\n\t\tbool isconvex()const{\n\t\t\tbool flagl=false,flagr=false;\n\t\t\tfor(int i=0;i<size();i++){\n\t\t\t\tint j=(i+1)%size(),k=(j+1)%size();\n\t\t\t\tauto z=(at(i)-at(j))^(at(k)-at(j));\n\t\t\t\tif(z<0)\tflagl=true;\n\t\t\t\tif(z>0)\tflagr=true;\n\t\t\t\tif(flagl&&flagr)\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t/* negative then clockwise, ccw if positive */\n\t\tT area2()const{\n\t\t\tT res=0;\n\t\t\tfor(int i=0;i<size();i++)\n\t\t\t\tres+=(at(i)^at((i+1)%size()));\n\t\t\treturn res;\n\t\t}\n\t\tDouble area()const{return abs(area2())/2;}\n\t\tDouble circum()const{\n\t\t\tDouble res=0;\n\t\t\tfor(int i=0;i<size();i++)\n\t\t\t\tres+=at(i).dist(at((i+1)%size()));\n\t\t\treturn res;\n\t\t}\n\t\t/* 3: as vertex, 2: onseg, 1: interior, 0: exterior */\n\t\tint relation(const Point& p)const{\n\t\t\tint n=size();\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tif(p==at(i))\n\t\t\t\t\treturn 3;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint s=at(i),e=at((i+1)%n);\n\t\t\t\tif(Line(s,e).onseg(p))\treturn 2;\n\t\t\t\tif(s.y-e.y>0)\ts=at((i+1)%n),e=at(i);\n\t\t\t\tif(p.y>=e.y||p.y<s.y)\tcontinue;\n\t\t\t\tif(Line(s,e).where(p)==-1)\tcnt++;\n\t\t\t}\n\t\t\treturn cnt&1;\n\t\t}\n\t};\n\tstruct Convex:Polygon{\n\t\t/* P should contain at least two \"different\" points */\n\t\t/* ccw, first point is defined by sort */\n\t\tConvex(vector<Point> P={},bool border=false){\n\t\t\tif(P.size()<=1){\n\t\t\t\tclear();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsort(P.begin(),P.end());\n\t\t\templace_back(P[0]),emplace_back(P[1]);\n\t\t\tfor(int i=2;i<P.size();i++){\n\t\t\t\tif(border)\n\t\t\t\t\twhile(size()>=2&&((back()-at(size()-2))^(P[i]-at(size()-2)))<0)\n\t\t\t\t\t\tpop_back();\n\t\t\t\telse\n\t\t\t\t\twhile(size()>=2&&((back()-at(size()-2))^(P[i]-at(size()-2)))<=0)\n\t\t\t\t\t\tpop_back();\n\t\t\t\templace_back(P[i]);\n\t\t\t}\n\t\t\tfor(int i=P.size()-2,t=size();i>=0;i--){\n\t\t\t\tif(border)\n\t\t\t\t\twhile(size()>t&&((back()-at(size()-2))^(P[i]-at(size()-2)))<0)\n\t\t\t\t\t\tpop_back();\n\t\t\t\telse\n\t\t\t\t\twhile(size()>t&&((back()-at(size()-2))^(P[i]-at(size()-2)))<=0)\n\t\t\t\t\t\tpop_back();\n\t\t\t\templace_back(P[i]);\n\t\t\t}\n\t\t\tpop_back();\n\t\t\tif(size()<=1||(size()==2&&at(0)==at(1)))\tclear();\n\t\t}\n\t\tDouble diameter()const{\n\t\t\tif(size()<=1)\treturn 0;\n\t\t\tif(size()==2)\treturn at(0).dist(at(1));\n\t\t\tint n=size(),q=1;\n\t\t\tDouble res=0;\n\t\t\tconst vector<Point> &v=*this;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint j=(i+1)%n;\n\t\t\t\twhile(((v[j]-v[i])^(v[q]-v[i]))<((v[j]-v[i])^(v[(q+1)%n]-v[i])))\n\t\t\t\t\tq=(q+1)%n;\n\t\t\t\tres=max(res,max(v[i].dist(v[q]),v[j].dist(v[(q+1)%n])));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t/* get the left hand side of the convex polygon */\n\t\tConvex cut(const Line& l)const{\n\t\t\tConvex res;\n\t\t\tfor(int i=0,n=size();i<n;i++){\n\t\t\t\tint p=l.where(at(i)),q=l.where(at((i+1)%n));\n\t\t\t\tif(p<=0)\tres.emplace_back(at(i));\n\t\t\t\tif(p*q<0)\tres.emplace_back(intersectLL(l,Line(at(i),at((i+1)%n))));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n}\n/* End of Geo2D */\n\nusing namespace Geo2D;\n\n/* LightOJ 1203: angle\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint T;\n\tcin>>T;\n\tfor(int t=1;t<=T;t++){\n\t\tdouble ans = inf;\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<Point> res(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>res[i].x>>res[i].y;\n\t\tres = hull(res);\n\t\tif(res.empty())\tans = 0;\n\t\telse{\n\t\t\tfor(int i=0;i<res.size();i++){\n\t\t\t\tint j =(i+1)%res.size(),k=(j+1)%res.size();\n\t\t\t\tans = min(ans,angle(res[i],res[j],res[k]));\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<setprecision(10);\n\t\tcout<<\"Case \"<<t<<\": \"<<ans/pi*180<<endl;\n\t}\n}\n*/\n\n/* LibreOJ 2459\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector<Point> Pp(n), Pq(m);\n    for (int i = 0; i < n; i++) cin >> Pp[i].x >> Pp[i].y;\n    for (int i = 0; i < m; i++) {\n        cin >> Pq[i].x >> Pq[i].y;\n        Pq[i].x = -Pq[i].x;\n        Pq[i].y = -Pq[i].y;\n    }\n    Pp = hull(Pp), Pq = hull(Pq);\n    vector<Point> Pr = Minkowski(Pp, Pq);\n    while (q--) {\n        Point P;\n        cin >> P.x >> P.y;\n        cout << inConvex(Pr, P) << '\\n';\n    }\n}\n*/\n\n\n\n/* Aizu CGL 1 A */\n/* Aizu CGL 1 B */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tPoint s,e;\n\tcin>>s.x>>s.y>>e.x>>e.y;\n\tLine L(s,e);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tPoint p;\n\t\tcin>>p.x>>p.y;\n\t\t// p = L.projection(p);\n\t\tp = L.symmetry(p);\n\t\tcout<<fixed<<setprecision(15)<<p.x<<' '<<p.y<<'\\n';\n\t}\n}\n*/\n\n/* Aizu CGL 1 C */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tLine L;\n\tcin>>L;\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tPoint p2;\n\t\tcin>>p2;\n\t\tint w = L.where(p2);\n\t\tif(w==-1)\n\t\t\tcout<<\"COUNTER_CLOCKWISE\\n\";\n\t\telse if(w==1)\n\t\t\tcout<<\"CLOCKWISE\\n\";\n\t\telse{\n\t\t\tif(L.onseg(p2))\n\t\t\t\tcout<<\"ON_SEGMENT\\n\";\n\t\t\telse if((L.e-L.s)*(p2-L.s) > 0)\n\t\t\t\tcout<<\"ONLINE_FRONT\\n\";\n\t\t\telse\n\t\t\t\tcout<<\"ONLINE_BACK\\n\";\n\t\t}\n\t}\n}\n*/\n\n/* Aizu CGL 2 A */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tLine L1,L2;\n\t\tcin>>L1>>L2;\n\t\tint r = L1.relation(L2);\n\t\tif(r==3)\n\t\t\tcout<<0<<'\\n';\n\t\telse if(r==2)\n\t\t\tcout<<1<<'\\n';\n\t\telse\n\t\t\tcout<<2<<'\\n';\n\t}\n}\n*/\n\n/* Aizu CGL 2 B */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tLine L1,L2;\n\t\tcin>>L1>>L2;\n\t\tint r = L1.segcrossseg(L2);\n\t\tif(r==0)\n\t\t\tcout<<0<<'\\n';\n\t\telse\n\t\t\tcout<<1<<'\\n';\n\t}\n}\n*/\n\n/* Aizu CGL 2 C */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tLine L1,L2;\n\t\tcin>>L1>>L2;\n\t\tauto P = intersectLL(L1,L2);\n\t\tcout<<fixed<<setprecision(15)<<P<<'\\n';\n\t}\n}\n*/\n\n/* Aizu CGL 2 D */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tLine L1,L2;\n\t\tcin>>L1>>L2;\n\t\tcout<<fixed<<setprecision(15)<<L1.distsegseg(L2)<<'\\n';\n\t}\n}\n*/\n\n/* Aizu CGL 3 A */\n/* Aizu CGL 3 B */\n/* Aizu CGL 3 C */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tPolygon Poly;\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tPoint nxt;\n\t\tcin>>nxt;\n\t\tPoly.emplace_back(nxt);\n\t}\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tPoint P;\n\t\tcin>>P;\n\t\tint x=Poly.relation(P);\n\t\tif(x>=2)\tcout<<1<<'\\n';\n\t\telse if(x==1)\tcout<<2<<'\\n';\n\t\telse\tcout<<0<<'\\n';\n\t}\n\t// cout<<Poly.isconvex()<<endl;\n\t// cout<<fixed<<setprecision(1)<<Poly.area()<<endl;\n}\n*/\n\n/* Aizu CGL 4 A */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tvector<Point> P(n);\n\tfor(int i=0;i<n;i++)\n\t\tcin>>P[i];\n\tConvex C(P,true);\n\tint m=0;\n\tfor(int i=0;i<C.size();i++)\n\t\tif(C[i].y<C[m].y||(C[i].y==C[m].y&&C[i].x<C[m].x))\n\t\t\tm=i;\n\trotate(C.begin(),C.begin()+m,C.end());\n\tcout<<C.size()<<'\\n';\n\tfor(auto it:C)\n\t\tcout<<it<<'\\n';\n}\n*/\n\n/* Aizu CGL 4 B */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tvector<Point> P(n);\n\tfor(int i=0;i<n;i++)\n\t\tcin>>P[i];\n\tConvex C(P);\n\tcout<<fixed<<setprecision(15)<<C.diameter()<<'\\n';\n}\n*/\n\n/* Aizu CGL 4 C */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tvector<Point> P(n);\n\tfor(int i=0;i<n;i++)\n\t\tcin>>P[i];\n\tConvex C(P);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tLine L;\n\t\tcin>>L;\n\t\tauto c=C.cut(L);\n\t\tcout<<fixed<<setprecision(15)<<c.area()<<'\\n';\n\t}\n}\n*/\n\n/* Aizu CGL 7 A */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tCircle c1,c2;\n\tcin>>c1>>c2;\n\tcout<<c1.relation(c2)+2<<'\\n';\n}\n*/\n\n/* Aizu CGL 7 D */\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tCircle c;\n\tcin>>c;\n\tint q;\n\tcin>>q;\n\tcout<<fixed<<setprecision(15);\n\twhile(q--){\n\t\tLine l;\n\t\tcin>>l;\n\t\tauto res = intersectCL(c,l);;\n\t\tif(res.size()==0)\tassert(false);\n\t\telse if(res.size()==1){\n\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\tcout<<res[0]<<' ';\n\t\t}\n\t\telse\n\t\t\tcout<<res[0]<<' '<<res[1];\n\t\tcout<<'\\n';\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'000LL;\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(begin(cccc), end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? begin(cccc)+llll : end(cccc);\\\n    auto jjjj = llll <= rrrr ? begin(cccc)+rrrr : end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n    for(auto first = begin(v), it = first; it != end(v); ++it) {\n        if(it != first)\n            out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    cout << x;\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \" << value << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\nstruct Vector {\n    f64 x, y;\n\n    Vector() : Vector(0,0) {}\n    Vector(f64 xx, f64 yy) : x(xx), y(yy) {}\n\n    const Vector operator-() const {\n        return Vector(-x,-y);\n    }\n    Vector& operator+=(const Vector& rhs) {\n        x += rhs.x;\n        y += rhs.y;\n        return *this;\n    }\n    Vector& operator-=(const Vector& rhs) {\n        x -= rhs.x;\n        y -= rhs.y;\n        return *this;\n    }\n    Vector& operator*=(f64 rhs) {\n        x *= rhs;\n        y *= rhs;\n        return *this;\n    }\n    Vector& operator/=(f64 rhs) {\n        x /= rhs;\n        y /= rhs;\n        return *this;\n    }\n\n    f64 norm() const { return x*x + y*y; }\n    f64 abs() const { return sqrt(norm()); }\n\n    Vector unit() const { return Vector(*this) /= this->abs(); }\n};\n\nconst Vector operator+(const Vector& lhs, const Vector& rhs) { return Vector(lhs) += rhs; }\nconst Vector operator-(const Vector& lhs, const Vector& rhs) { return Vector(lhs) -= rhs; }\nconst Vector operator*(const Vector& lhs, f64 rhs) { return Vector(lhs) *= rhs; }\nconst Vector operator*(f64 lhs, const Vector& rhs) { return Vector(rhs) *= lhs; }\nconst Vector operator/(const Vector& lhs, f64 rhs) { return Vector(lhs) /= rhs; }\n\nbool operator==(const Vector& lhs, const Vector& rhs) {\n    return feq(lhs.x,rhs.x) && feq(lhs.y,rhs.y);\n}\n\nostream& operator<<(ostream& out, const Vector& v) {\n    return out << \"Vector(\" << v.x << \",\" << v.y << \")\";\n}\n\nstruct Segment {\n    Vector p1, p2;\n\n    Segment(const Vector& pp1, const Vector& pp2) : p1(pp1), p2(pp2) {}\n    Segment(f64 x1, f64 y1, f64 x2, f64 y2) : p1(Vector(x1,y1)), p2(Vector(x2,y2)) {}\n\n    Vector vec() const { return p2 - p1; }\n\n    f64 norm() const { return vec().norm(); }\n    f64 abs() const { return vec().abs(); }\n};\n\nostream& operator<<(ostream& out, const Segment& seg) {\n    out << \"Segment(\";\n    out << \"(\" << seg.p1.x << \",\" << seg.p1.y << \")\";\n    out << \",\";\n    out << \"(\" << seg.p2.x << \",\" << seg.p2.y << \")\";\n    out << \")\";\n    return out;\n}\n\nstruct Line {\n    Vector p1, p2;\n\n    Line(const Vector& pp1, const Vector& pp2) : p1(pp1), p2(pp2) {}\n    Line(f64 x1, f64 y1, f64 x2, f64 y2) : p1(Vector(x1,y1)), p2(Vector(x2,y2)) {}\n    Line(const Segment& seg) : p1(seg.p1), p2(seg.p2) {}\n\n    Vector vec() const { return p2 - p1; }\n};\n\nostream& operator<<(ostream& out, const Line& line) {\n    out << \"Line(\";\n    out << \"(\" << line.p1.x << \",\" << line.p1.y << \")\";\n    out << \",\";\n    out << \"(\" << line.p2.x << \",\" << line.p2.y << \")\";\n    out << \")\";\n    return out;\n}\n\nf64 geo_dot(const Vector& lhs, const Vector& rhs) {\n    return lhs.x*rhs.x + lhs.y*rhs.y;\n}\n\nf64 geo_cross(const Vector& lhs, const Vector& rhs) {\n    return lhs.x*rhs.y - lhs.y*rhs.x;\n}\n\nVector geo_project(const Line& line, const Vector& p) {\n    Vector v = line.vec();\n    f64 r = geo_dot(p-line.p1, v) / v.norm();\n    return line.p1 + r*v;\n}\n\nenum ABC {\n    ABC_CCW        =  1,\n    ABC_CW         = -1,\n    ABC_ON_BACK    =  2,\n    ABC_ON_FRONT   = -2,\n    ABC_ON_SEGMENT =  0,\n};\n\nABC geo_abc(const Vector& a, const Vector& b, const Vector& c) {\n    Vector x = b - a;\n    Vector y = c - a;\n    f64 cross = geo_cross(x,y);\n    if(cross > 0) return ABC_CCW;\n    if(cross < 0) return ABC_CW;\n    f64 dot = geo_dot(x,y);\n    if(dot < 0) return ABC_ON_BACK;\n    if(x.norm() < y.norm()) return ABC_ON_FRONT;\n    return ABC_ON_SEGMENT;\n}\n\nbool geo_intersect(const Segment& x, const Segment& y) {\n    return geo_abc(x.p1,x.p2,y.p1) * geo_abc(x.p1,x.p2,y.p2) <= 0 &&\n           geo_abc(y.p1,y.p2,x.p1) * geo_abc(y.p1,y.p2,x.p2) <= 0;\n}\n\nf64 geo_distance(const Line& line, const Vector& p) {\n    Vector v = line.vec();\n    return fabs(geo_cross(v,p-line.p1)) / v.abs();\n}\n\nf64 geo_distance(const Segment& seg, const Vector& p) {\n    if(geo_dot( seg.vec(), p-seg.p1) < 0) return (p-seg.p1).abs();\n    if(geo_dot(-seg.vec(), p-seg.p2) < 0) return (p-seg.p2).abs();\n    return geo_distance(Line(seg), p);\n}\n\nf64 geo_distance(const Segment& seg1, const Segment& seg2) {\n    if(geo_intersect(seg1,seg2)) return 0;\n    return min({\n        geo_distance(seg1, seg2.p1),\n        geo_distance(seg1, seg2.p2),\n        geo_distance(seg2, seg1.p1),\n        geo_distance(seg2, seg1.p2),\n    });\n}\n\nVector geo_crosspoint(const Segment& x, const Segment& y) {\n    Line ly = Line(y);\n    f64 d1 = geo_distance(ly, x.p1);\n    f64 d2 = geo_distance(ly, x.p2);\n    return x.p1 + (d1/(d1+d2))*x.vec();\n}\n\nvoid RD(Vector& v) {\n    RD(v.x);\n    RD(v.y);\n}\n\n//--------------------------------------------------------------------\n\nstruct Circle {\n    Vector c;\n    f64 r;\n\n    Circle(const Vector& cc, f64 rr) : c(cc), r(rr) {}\n};\n\nbool geo_intersect(const Circle& cir, const Line& line) {\n    return geo_distance(line, cir.c) <= cir.r;\n}\n\n// 接する場合も同じ座標2つを返す\nvector<Vector> geo_crosspoints(const Circle& cir, const Line& line) {\n    if(!geo_intersect(cir,line)) return {};\n    Vector p = geo_project(line, cir.c);\n    Vector e = line.vec().unit();\n    f64 t = sqrt(cir.r*cir.r - (p-cir.c).norm());\n    return { p+t*e, p-t*e };\n}\n\nvoid solve() {\n    Vector c; RD(c);\n    f64 r; RD(r);\n    Circle cir(c,r);\n\n    i64 Q; RD(Q);\n    REP(_, Q) {\n        Vector p1; RD(p1);\n        Vector p2; RD(p2);\n        Line line(p1,p2);\n\n        vector<Vector> ans = geo_crosspoints(cir, line);\n        ALL(sort, ans, ON(less<>(), [](const Vector& p) { return make_pair(p.x,p.y); }));\n\n        PRINTLN(ans[0].x, ans[0].y, ans[1].x, ans[1].y);\n    }\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Cross Point of a Circle and a Line\n#include <iostream>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\n\nstatic const double ESP = 1e-10;\n\nbool equals(double a, double b) { return fabs(a - b) < ESP; }\n\nclass Point {\npublic:\n    double x, y;\n\n    explicit Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(a / x, a / y); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < ESP && fabs(y - p.y) < ESP;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    explicit Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector v1, Vector v2) {\n    return equals(cross(v1, v2), 0.0);\n}\n\nbool isOrthogonal(Vector v1, Vector v2) {\n    return equals(dot(v1, v2), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    return s.p1 + (base * (dot(base, p - s.p1) / base.norm()));\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2;\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > ESP) return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -ESP) return CLOCKWISE;\n    else if (dot(a, b) < -ESP) return ONLINE_BACK;\n    else if (a.norm() < b.norm()) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) {\n        return getDistancePP(s.p1, p);\n    } else if(dot(s.p1 - s.p2, p - s.p2) < 0) {\n        return getDistancePP(s.p2, p);\n    } else {\n        return getDistanceLP(s, p);\n    }\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if(intersect(s1, s2)) return 0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s1.p2 - s1.p1;\n    double d1 = fabs(cross(base, s2.p1 - s1.p1));\n    double d2 = fabs(cross(base, s2.p2 - s1.p1));\n    return s2.p1 + (s2.p2 - s2.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l) {\n    Vector base = l.p2 - l.p1;\n    double d = getDistanceLP(l, c.c);\n    Point m = project(l, c.c);\n    double t = sqrt(pow(c.r, 2.0) - pow(d, 2.0)) / base.abs();\n    return make_pair(m + base * t, m - base * t);\n}\n\nint main() {\n    int q;\n    double cx, cy, r, x0, y0, x1, y1;\n    cin >> cx >> cy >> r >> q;\n    Circle c = Circle(Point(cx, cy), r);\n    for(int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1;\n        Line l = Line(Point(x0, y0), Point(x1, y1));\n        pair<Point, Point> p = getCrossPoint(c, l);\n        if(p.first.x > p.second.x) swap(p.first, p.second);\n        else if (fabs(p.first.x - p.second.x) < ESP && p.first.y > p.second.y) swap(p.first, p.second);\n        printf(\"%.8f %.8f %.8f %.8f\\n\", p.first.x, p.first.y, p.second.x, p.second.y);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstdio>\n#include <algorithm>\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\n\n//点を表す構造体\nclass Point{\npublic:\n  double x, y;\n\n  Point(double x=0, double y=0){\n    this->x = x;\n    this->y = y;\n  }\n\n  Point operator+(const Point &seg2){\n    return Point(x+seg2.x, y+seg2.y);\n  }\n\n  Point operator-(const Point &seg2){\n    return Point(x-seg2.x, y-seg2.y);\n  }\n\n  Point operator*(const double k){\n    return Point(x*k, y*k);\n  }\n\n  Point operator/(const double k){\n    return Point(x/k, y/k);\n  }\n\n  Point &operator=(const Point &p){\n    x = p.x;\n    y = p.y;\n    return *this;\n  }\n\n  bool operator < (const Point &p) const{\n    return x != p.x? x<p.x : y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return equals(x, p.x) && equals(y, p.y);\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n\n  double abs(){\n    return sqrt(norm());\n  }\n\n  static double dot(Point a, Point b){\n    return a.x*b.x + a.y*b.y;\n  }\n\n  static double cross(Point a, Point b){\n    return a.x*b.y - a.y*b.x;\n  }\n\n  static bool isOrthogonal(Point a, Point b){\n    return equals(dot(a, b), 0.0);\n  }\n\n  static bool isParallel(Point a, Point b){\n    return equals(cross(a, b), 0.0);\n  }\n\n  static void swap(Point* a, Point* b){\n    Point temp = *b;\n    *b = *a;\n    *a = temp;\n  }\n};\n\n/*\n//ベクトルを点の別表記でも表せるようにしておく\n//いらない説濃厚(Pointのtypedefで済ませそう)\nclass Vector : public Point{\npublic:\n  Vector() : Point() {}\n\n  Vector(double x, double y) : Point(x, y) {}\n\n  Vector(Point p) : Point(){\n    x = p.x;\n    y = p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n\n  double abs(){\n    return sqrt(norm());\n  }\n\n  static double dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n  }\n\n  static double cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n  }\n\n  static bool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n  }\n\n  static bool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n  }\n};\n*/\n\ntypedef Point Vector;//Vectorをtypedefしておく\n\n//線分(ベクトルを用いて)を表す構造体。両端の点が定義されている点に注意\nclass Segment{\npublic:\n  Point p1, p2;\n\n  Segment(Point p1, Point p2){\n    this->p1 = p1;\n    this->p2 = p2;\n    x = p2.x-p1.x;\n    y = p2.y-p1.y;\n  }\n\n  static bool isOrthogonal(Segment a, Segment b){\n    return equals(dot(a, b), 0.0);\n  }\n\n  static bool isParallel(Segment a, Segment b){\n    return equals(cross(a, b), 0.0);\n  }\n\nprivate:\n  int x, y;\n  static double dot(Segment a, Segment b){\n    return a.x*b.x + a.y*b.y;\n  }\n\n  static double cross(Segment a, Segment b){\n    return a.x*b.y - a.y*b.x;\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\nclass Polygon{\npublic:\n  Point* ver;\n  int size;\n  Polygon(int size){\n    this->size = size;\n    ver = new Point[size];\n  }\n  ~Polygon(){\n    delete[] ver;\n  }\n\n  double area(){\n    double ans=0.0;\n\n    Vector a, b;\n    for(int i=0; i<size; i++){\n      a=ver[i%size]; b=ver[(i+1)%size];\n      ans += Vector::cross(a, b)/2;\n    }\n\n    return ans;\n  }\n\n  /*\n    ・含まれる時:2\n    ・辺上に点が存在する時:1\n    ・それ以外の場合:0\n    を返す\n  */\n  int contain(Point p){\n    bool flag = false;\n\n    int ans;\n    for(int i=0; i<size; i++){\n      Vector a = ver[i%size]-p, b = ver[(i+1)%size]-p;\n      //外積=0かつ内積<0の時辺上に点があると判定できる\n      if(fabs(Vector::cross(a, b))<EPS && Vector::dot(a, b)<EPS){\n        ans = 1;\n        return ans;\n      }\n      if(a.y > b.y)Vector::swap(&a, &b);\n      //端点をうまく処理するために以下の条件分岐ではEPSの使い方に注意\n      if(a.y < EPS && b.y > EPS && Vector::cross(a, b)>EPS) flag = !flag;\n    }\n\n    ans = flag ? 2 : 0;\n    return ans;\n  }\n};\n\nclass Tryangle : public Polygon{\npublic:\n  Tryangle(Point p1, Point p2, Point p3) : Polygon(3){\n    ver[0] = p1;\n    ver[1] = p2;\n    ver[3] = p3;\n  }\n  double area(){\n    Vector a = ver[1]-ver[0], b = ver[2]-ver[0];\n    return fabs(Vector::cross(a, b))/2.0;\n  }\n};\n\nstring ccw_str(Point p0, Point p1, Point p2){\n  //enum res {COUNTER_CLOCKWISE=0, CLOCKWISE, ONLINE_BACK, ONLINE_FRONT, ON_SEGMENT};\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(Vector::cross(a, b) > EPS) return \"COUNTER_CLOCKWISE\";\n  if(Vector::cross(a, b) < -EPS) return \"CLOCKWISE\";\n  if(Vector::dot(a, b) < -EPS) return \"ONLINE_BACK\";\n  if(a.norm() < b.norm()) return \"ONLINE_FRONT\";\n  return \"ON_SEGMENT\";\n}\n\nint ccw_int(Point p0, Point p1, Point p2){\n  enum res {COUNTER_CLOCKWISE=-1, CLOCKWISE=1, ONLINE_BACK=2, ONLINE_FRONT=-2, ON_SEGMENT=0};\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(Vector::cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(Vector::cross(a, b) < -EPS) return CLOCKWISE;\n  if(Vector::dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPoint project(Segment s, Point p){\n  Vector base = s.p2-s.p1;\n  double r = Vector::dot(p - s.p1, base) / base.norm();\n  return s.p1 + base*r;\n}\n\nPoint reflect(Segment s, Point p){\n  Point pro = project(s, p);\n  return p + (pro-p)*2.0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n  return ccw_int(p1, p2, p3)*ccw_int(p1, p2, p4)<=0 && ccw_int(p3, p4, p1)*ccw_int(p3, p4, p2)<=0;\n}\n\nbool intersect(Segment s1, Segment s2){\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4){\n  Vector base = p2-p1;\n  double d1 = fabs(Vector::cross(base, p4-p1))/fabs(base.abs());\n  double d2 = fabs(Vector::cross(base, p3-p1))/fabs(base.abs());\n  double t = d1/(d1+d2);\n  Point x = p4 + (p3-p4)*t;\n  return x;\n}\n\ndouble getDistance(Point p1, Point p2){\n  Vector base=p2-p1;\n  return base.abs();\n}\n\ndouble getDistance(Point p, Segment s){\n  double dot1, dot2;\n  Vector base = s.p2-s.p1;\n  dot1 = Vector::dot(base, p-s.p1);\n  dot2 = Vector::dot(base*(-1.0), p-s.p2);\n\n  double ans;\n  if(dot1<-EPS) ans = getDistance(s.p1, p);\n  else if(dot2<-EPS) ans = getDistance(s.p2, p);\n  else ans = fabs(Vector::cross(p-s.p1, base))/base.abs();\n\n  return ans;\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  double ans;\n  if(intersect(s1, s2)) ans = 0.0;\n  else {\n    ans = min(min(getDistance(s1.p1, s2), getDistance(s1.p2, s2)),\n                  min(getDistance(s2.p1, s1), getDistance(s2.p2, s1)));\n  }\n  return ans;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l){\n  Point pr = project(l, c.c);\n  Vector e = (l.p1-l.p2)/(l.p1-l.p2).abs();\n  double base = sqrt(c.r*c.r - (pr-c.c).norm());\n  return make_pair(pr+e*base, pr-e*base);\n}\n\nint main(){\n  double cx, cy, cr;\n  cin >> cx >> cy >> cr;\n  Circle c(Point(cx, cy), cr);\n\n  int q; cin >> q;\n\n  double x1, y1, x2, y2;\n  pair<Point, Point> ans;\n  for(int i=0; i<q; i++){\n    cin >> x1 >> y1 >> x2 >> y2;\n    Line l(Point(x1, y1), Point(x2, y2));\n    ans = getCrossPoints(c, l);\n    printf(\"%.10lf %.10lf %.10lf %.10lf\\n\", ans.first.x, ans.first.y,\n                                              ans.second.x, ans.second.y);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#define f first\n#define s second\n#define mp make_pair\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return (s1.p1+(s1.p2-s1.p1)*t);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nint main()\n{\n  Point A,B;\n  int q,a,b;\n  Circle C;\n\n  cin>>C.c.x>>C.c.y>>C.r;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>A.x>>A.y>>B.x>>B.y;\n    pair<Point,Point> PP=getCrossPoints(C,Line(A,B));\n    if((PP.s.x-PP.f.x)>eps)\n      printf(\"%.10f %.10f %.10f %.10f\\n\",PP.f.x,PP.f.y,PP.s.x,PP.s.y);\n    else if((PP.s.x-PP.f.x)<-eps)\n      printf(\"%.10f %.10f %.10f %.10f\\n\",PP.s.x,PP.s.y,PP.f.x,PP.f.y);\n    else {\n      if((PP.s.y-PP.f.y)>eps)\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\",PP.f.x,PP.f.y,PP.s.x,PP.s.y);\n      else \n\tprintf(\"%.10f %.10f %.10f %.10f\\n\",PP.s.x,PP.s.y,PP.f.x,PP.f.y);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <utility>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals( A, B ) (fabs((A) - (B)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n    Point( double x = 0, double y = 0 ): x(x), y(y) {}\n    \n    Point operator + ( Point p ) { return Point( x + p.x, y + p.y ); }\n    Point operator - ( Point p ) { return Point( x - p.x, y - p.y ); }\n    Point operator * ( double a ) { return Point( a * x, a * y ); }\n    Point operator / ( double a ) { return Point( x / a, y / a ); }\n\n    double abs() { return sqrt( norm() ); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn ( x != p.x ) ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn equals( x, p.x ) && equals( y, p.y ); \n    }\n\n    double dot( Point a ) { return x * a.x + y * a.y; }\n    double cross( Point a ) { return x * a.y - y * a.x; }\n    double distance( Point a ) {\n\treturn (*this - a).abs();\n    }\n};\n\ntypedef Point Vector;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Line {\npublic:\n    Point p1, p2;\n    Line( Point p1 = Point(), Point p2 = Point() ): p1(p1), p2(p2){}\n    // ?????´????????????( cos = 0 )\n    bool isOrthogonal( Line a ) {\n\treturn equals( 0.0, (p1 - p2).dot( a.p1 - a.p2 ) );\n    }\n    // ??????????????????( sin = 0 )\n    bool isParallel( Line a ) {\n\treturn equals( 0.0, (p1 - p2).cross( a.p1 - a.p2 ) );\n    }\n\n    Point projection( Point p ) {\n\tVector v12 = p2 - p1;\n\tdouble r = v12.dot( p - p1 ) / v12.norm();\n\treturn p1 + v12 * r;\n    }\n\n    Point reflection( Point p ) {\n\treturn p + ( projection( p ) - p ) * 2.0;\n    }\n\n    double distance( Point p ) {\n\tVector v12 = this->p2 -this->p1;\n\tVector v10 = p - this->p1;\n\t\n\treturn abs( v12.cross( v10 ) / v12.abs() );\n    }\n\n    double distanceSP( Point p ) {\n\tif ( (p - this->p1).dot( this->p2 - this->p1 ) < 0.0 ) {\n\t    return this->p1.distance( p );\n\t} else if ( (p - this->p2).dot( this->p1 - this->p2 ) < 0.0 ) {\n\t    return this->p2.distance( p );\n\t}\n\telse {\n\t    return distance( p );\n\t}\n    }\n\n    int ccw( Point p ) {\n\tVector a = p2 - p1;\n\tVector b = p - p1;\n\tif ( a.cross( b ) > EPS ) return COUNTER_CLOCKWISE;\n\telse if ( a.cross( b ) < -EPS ) return CLOCKWISE;\n\telse if ( a.dot( b ) < -EPS ) return ONLINE_BACK;\n\telse if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\telse return ON_SEGMENT;\n    }\n\n    bool intersect( Line l ) {\n\treturn ( ( ccw( l.p1 ) * ccw( l.p2 ) <= 0 && l.ccw( p1 ) * l.ccw( p2 ) <= 0 ) );\n    }\n\n    Point crossPoint( Line l ) {\n\tVector base = p2 - p1;\n\tVector v1 = l.p1 - p1;\n\tVector v2 = l.p2 - p1;\n\tdouble d1 = base.cross( v1 );\n\tdouble d2 = base.cross( v2 );\t\n\tdouble t = d1 / ( d1 + d2 );\n\n\treturn l.p1 + ( l.p2 - l.p1 ) * t;\n    }\n};\n\ntypedef Line Segment;\n\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n\n    Circle( Point c = Point(), double r = 0 ): c(c), r(r) {}\n\n    pair<Point, Point> crossPoints( Line l ) {\n\tPoint proj = l.projection( c ); // ?????????????????´???????°???±\n\tdouble base = sqrt( r * r - ( c - proj ).norm() );\n\tVector e = ( l.p2 - l.p1 ) / ( l.p2 - l.p1 ).abs();\n\tif ( l.p2 < l.p1 ) e = e * -1; // x?????£????????????????????????\n\treturn make_pair( proj - e * base, proj + e * base );\n    }\n\n};\n\nint main()\n{\n    Circle c;\n    int q;\n\n    scanf(\"%lf %lf %lf\", &c.c.x, &c.c.y, &c.r);\n    scanf(\"%d\", &q);\n\n    for ( int i = 0; i < q; i++ ) {\n\tPoint p1, p2;\n\tscanf(\"%lf %lf\", &p1.x, &p1.y);\n\tscanf(\"%lf %lf\", &p2.x, &p2.y);\n\tLine l = Line( p1, p2 );\n\tpair<Point, Point> pp = c.crossPoints( l );\n\n\tprintf(\"%.10lf %.10lf \", pp.first.x, pp.first.y);\n\tprintf(\"%.10lf %.10lf\\n\", pp.second.x, pp.second.y);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\nconst double PI=acos(-1);\nconst double EPS=1e-10;\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nP inP(){\n  double x,y;\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\nvoid printL(const L &l){\n  \tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\", l[0].real(), l[0].imag(), l[1].real(), l[1].imag());\n}\n\nint main(){\n\n  C c = inC();\n\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; i++){\n    L l = inL();\n    printL(crosspointCL(c,l));\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nclass Vec2d {\nprivate:\n    double m_dx;\n    double m_dy;\npublic:\n    Vec2d(double m_dx, double m_dy) {\n        this->m_dx = m_dx;\n        this->m_dy = m_dy;\n    }\n    double length() {\n        return sqrt(pow(m_dx, 2) + pow(m_dy, 2));\n    }\n    void normalize() {\n        double size = this->length();\n        m_dx = m_dx / size;\n        m_dy = m_dy / size;\n    }\n    Vec2d operator +(const Vec2d& zVec) {\n        double dX = this->m_dx + zVec.m_dx;\n        double dY = this->m_dy + zVec.m_dy;\n        return Vec2d(dX, dY);\n    }\n    Vec2d operator -(const Vec2d& zVec) {\n        double dX = this->m_dx - zVec.m_dx;\n        double dY = this->m_dy - zVec.m_dy;\n        return Vec2d(dX, dY);\n    }\n    //dot product\n    double operator *(const Vec2d& zVec) {\n        return this->m_dx * zVec.m_dx + this->m_dy * zVec.m_dy;\n    }\n    //scalar multiplication\n    Vec2d operator *(const double mul) {\n        double dX = m_dx * mul;\n        double dY = m_dy * mul;\n        return Vec2d(dX, dY);\n    }\n    double getX() {\n        return m_dx;\n    }\n    double getY() {\n        return m_dy;\n    }\n};\n\nint main()\n{\n    double dCx, dCy, dCr;\n    cin >> dCx >> dCy >> dCr;\n    Vec2d zCircle(dCx, dCy);\n    int nSize;\n    cin >> nSize;\n    double dX1, dY1, dX2, dY2, dRoot, dDiscriminant, dI1x, dI1y, dI2x, dI2y;\n    for (int i = 0; i < nSize; i++) {\n        cin >> dX1 >> dY1 >> dX2 >> dY2;\n        Vec2d zP(dX1, dY1);\n        Vec2d zD = (Vec2d(dX2, dY2) - zP);\n        zD.normalize();\n        dRoot = -(zD*(zP - zCircle));\n        //Problem constraint: The circle and line have at least one cross point\n        dDiscriminant = sqrt(pow(dRoot, 2) - (zP - zCircle)*(zP - zCircle) + dCr*dCr);\n        Vec2d zIntersect1 = zP + zD*(dRoot - dDiscriminant);\n        Vec2d zIntersect2 = zP + zD*(dRoot + dDiscriminant);\n        dI1x = zIntersect1.getX();\n        dI1y = zIntersect1.getY();\n        dI2x = zIntersect2.getX();\n        dI2y = zIntersect2.getY();\n        cout << fixed << setprecision(6);\n        if (dI1x < dI2x || (dI1x == dI2x && dI1y <= dI2y)) {\n            cout << dI1x << \" \" << dI1y << \" \" << dI2x << \" \" << dI2y << \"\\n\";\n        }\n        else {\n            cout << dI2x << \" \" << dI2y << \" \" << dI1x << \" \" << dI1y << \"\\n\";\n        }    \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\nconst db eps = 1e-12, pi = acos(-1);\nint sign(db x) {return x < -eps ? -1 : x > eps;}\nint cmp(db x, db y) {return sign(x - y);}\nint intersect(db l1, db r1, db l2, db r2) {\n    if (l1 > r1) swap(l1, r1); if (l2 > r2) swap(l2, r2); return cmp(r1, l2) != -1 && cmp(r2, l1) != -1;\n}\nint inmid(db k1, db k2, db k3) {return sign(k1 - k3) * sign(k2 - k3) <= 0;}//k3 in [k1,k2]?1:0\nstruct Point {\n    db x, y;\n    Point operator + (const Point & a)const {return Point{a.x + x, a.y + y};}\n    Point operator - (const Point & a)const {return Point{x - a.x, y - a.y};}\n    Point operator * (db a) const {return Point{x * a, y * a};}\n    Point operator / (db a) const {return Point{x / a, y / a};}\n    bool operator < (const Point p) const {int a = cmp(x, p.x); if (a) return a == -1; return cmp(y, p.y) == -1;}\n    bool operator == (const Point & a) const {return cmp(x, a.x) == 0 && cmp(y, a.y) == 0;}\n    db abs() {return sqrt(x * x + y * y);}\n    db abs2() {return x * x + y * y;}\n    db dis(Point p) {return ((*this) - p).abs();}\n    db dis2(Point p) {return ((*this) - p).abs2();}\n    int getP() const {return sign(y) == 1 || (sign(y) == 0 && sign(x) == -1);}\n    void input() {scanf(\"%lf%lf\", &x, &y);}\n};\ndb cross(Point p1, Point p2) {return p1.x * p2.y - p1.y * p2.x;}\ndb cross(Point p0, Point p1, Point p2) {return cross(p1 - p0, p2 - p0);}\ndb dot(Point p1, Point p2) {return p1.x * p2.x + p1.y * p2.y;}\nint inmid(Point k1, Point k2, Point k3) {return inmid(k1.x, k2.x, k3.x) && inmid(k1.y, k2.y, k3.y);}\nbool compareangle(Point p1, Point p2) {//Polar Angle Sort\n    return p1.getP() < p2.getP() || (p1.getP() == p2.getP() && sign(cross(p1, p2)) > 0);\n}\nint clockwise(Point p1, Point p2, Point p3) { // p1 p2 p3 anticlockwise:1 clockwise:-1 others:0\n    return sign(cross(p1, p2, p3));\n}\nstruct Line {\n    Point s, e;\n    void input() {scanf(\"%lf%lf%lf%lf\", &s.x, &s.y, &e.x, &e.y);}\n    Point vec() {return e - s;}\n    db length() {return sqrt(dot(s - e, s - e));}\n    db length2() {return dot(s - e, s - e);}\n};\nint onS(Line l, Point p) {// On Seg?\n    return inmid(l.s, l.e, p) && sign(cross(l.s - p, l.e - l.s)) == 0;\n}\nbool checkLL(Line l1, Line l2) {\n    return cmp(cross(l1.s, l2.s, l2.e), cross(l1.e, l2.s, l2.e)) != 0;\n}\nbool checkLS(Line l1, Line l2) {//Intersection of Line l1 and Seg l2?\n    return sign(cross(l2.s, l1.s, l1.e)) * sign(cross(l2.e, l1.s, l1.e)) <= 0;\n}\nint checkSS(Line l1, Line l2) {//Intersection of Two Seg?1:0\n    return intersect(l1.s.x, l1.e.x, l2.s.x, l2.e.x) && intersect(l1.s.y, l1.e.y, l2.s.y, l2.e.y) && checkLS(l1, l2) && checkLS(l2, l1);\n}\nPoint project(Line l, Point p) {\n    return l.s + l.vec() * dot(p - l.s, l.vec()) / l.length2();\n}\nPoint reflect(Line l, Point p) {//Mirror Point\n    return project(l, p) * 2 - p;\n}\nPoint getLL(Line l1, Line l2) {//Intersection Point of Line l1,l2\n    db w1 = cross(l2.s, l1.s, l2.e), w2 = cross(l2.s, l2.e, l1.e); return (l1.s * w2 + l1.e * w1) / (w1 + w2);\n}\ndb disSP(Line l, Point p) {\n    Point p2 = project(l, p);\n    if (inmid(l.s, l.e, p2)) return p.dis(p2); else return min(p.dis(l.s), p.dis(l.e));\n}\ndb disSS(Line l1, Line l2) {\n    if (checkSS(l1, l2)) return 0;\n    return min(min(disSP(l1, l2.s), disSP(l1, l2.e)), min(disSP(l2, l1.s), disSP(l2, l1.e)));\n}\ndb area(vector<Point> A) {//Anticlockwise\n    db ans = 0;\n    for (int i = 0; i < A.size(); i++) ans += cross(A[i], A[(i + 1) % A.size()]);\n    return ans / 2;\n}\nint contain(vector<Point>A, Point p) {//2:in 1:on 0:out\n    int ans = 0; A.push_back(A[0]);\n    for (int i = 1; i < A.size(); i++) {\n        Line l = {A[i - 1], A[i]};\n        if (onS(l, p)) return 1; if (cmp(l.s.y, l.e.y) > 0) swap(l.s, l.e);\n        if (cmp(l.s.y, p.y) >= 0 || cmp(l.e.y, p.y) < 0) continue;\n        if (sign(cross(l.e, l.s, p)) < 0)ans ^= 1;\n    }\n    return ans << 1;\n}\nbool checkconvex(vector<Point>A) { //anticlock\n    int n = A.size(); A.push_back(A[0]); A.push_back(A[1]);\n    for (int i = 0; i < n; i++) if (sign(cross(A[i], A[i + 1], A[i + 2])) == -1) return 0;\n    return 1;\n}\nvector<Point> ConvexHull(vector<Point>A, int flag = 1) { // flag=0 不严格 flag=1 严格\n    int n = A.size(); vector<Point>ans(n * 2);\n    sort(A.begin(), A.end()); int now = 0; if (n <= 1)return A;\n    for (int i = 0; i < n; ans[now++] = A[i++])\n        while (now > 1 && sign(cross(ans[now - 2], ans[now - 1], A[i])) < flag)--now;\n    for (int i = n - 2, pre = now; i >= 0; ans[now++] = A[i--])\n        while (now > pre && sign(cross(ans[now - 2], ans[now - 1], A[i])) < flag)--now;\n    ans.resize(now - 1); return ans;\n}\ndb convexDiameter(vector<Point>A) {\n    int n = A.size(); if (n <= 1)return 0;\n    int is = 0, js = 0; for (int k = 1; k <= n; ++k)is = A[k] < A[is] ? k : is, js = A[js] < A[k] ? k : js;\n    int i = is, j = js; db ret = A[i].dis(A[j]); do {\n        if (sign(cross(A[(i + 1) % n] - A[i], A[(j + 1) % n] - A[j])) >= 0)(++j) %= n;\n        else (++i) %= n;\n        ret = max(ret, A[i].dis(A[j]));\n    } while (i != is || j != js);\n    return ret;\n}\nvector<Point> convexcut(vector<Point>A, Line l) { // 保留 k1,k2,p 逆时针的所有点,判断n是否为0\n    int n = A.size(); A.push_back(A[0]); vector<Point>ans;\n    for (int i = 0; i < n; i++) {\n        int w1 = clockwise(l.s, l.e, A[i]), w2 = clockwise(l.s, l.e, A[i + 1]);\n        if (w1 >= 0) ans.push_back(A[i]);\n        if (w1 * w2 < 0) ans.push_back(getLL(l, Line{A[i], A[i + 1]}));\n    }\n    return ans;\n}\nstruct Circle {\n    Point o; db r;\n    void input() {o.input(); scanf(\"%lf\", &r);}\n};\nint checkCC(Circle c1, Circle c2) {// 返回两个圆的公切线数量\n    db d = c1.o.dis(c2.o); if (cmp(d, c1.r + c2.r) == 1)return 4;\n    if (cmp(d, c1.r + c2.r) == 0)return 3; if (cmp(d, abs(c1.r - c2.r)) == 1)return 2;\n    if (cmp(d, abs(c1.r - c2.r)) == 0)return 1; return 0;\n}\nvector<Point> getCL(Circle c, Line l) {// 沿着 s->e 方向给出 , 相切给出两个\n    Point p = project(l, c.o); db d = c.r * c.r - p.dis2(c.o);\n    if (sign(d) == -1)return{};\n    Point del = l.vec() / l.length() * sqrt(max(db(0.0), d)); return {p - del, p + del};\n}\nint main() {\n    Circle c;c.input();\n    int Q;cin>>Q;while(Q--){\n        Line l;l.input();\n        vector<Point> ANS=getCL(c,l);\n        sort(ANS.begin(),ANS.end());\n        printf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ANS[0].x,ANS[0].y,ANS[1].x,ANS[1].y);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\npair<Point,Point>getCrossPoints(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\nint main(){\n    Circle c;\n    getCircle(c);\n\n    int q;\n    scanf(\"%d\",&q);\n\n    while(q--){\n\n        Line l;\n        getLine(l);\n        pair<Point,Point>x=getCrossPoints(c,l);\n        if(!cmpx(x.first,x.second))swap(x.first,x.second);\n        printf(\"%.20lf %.20lf %.20lf %.20lf\\n\",x.first.real(),x.first.imag(),x.second.real(),x.second.imag());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    }\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(const Point &p, const double r): p(p), r(r) {}\n};\n\ndouble get_distance(const Line &l, const Point &p) {\n    return abs(cross_prod(l.second-l.first, p-l.first))/abs(l.second-l.first);\n}\n\ntemplate <class LineType>\npair<pair<double, double>, double> get_stdform(const LineType &l) {\n    double dx=real(l.second)-real(l.first);\n    double dy=imag(l.second)-imag(l.first);\n    double k=-dx*imag(l.first)+dy*real(l.first);\n\n    return make_pair(make_pair(-dy, dx), k);\n}\n\ntemplate <class LineType>\npair<Point, Point> get_ipoints(const Circle &c, const LineType &l) {\n    double a=imag(l.first)-imag(l.second);\n    double b=real(l.second)-real(l.first);\n    double k=-b*imag(l.first)-a*real(l.first);\n\n    double d=a*real(c.p)+b*imag(c.p)+k;\n    double r=c.r;\n\n    double R=a*a+b*b;\n    double D=sqrt(R*r*r-d*d);\n    Point p1=c.p+polar(1/sqrt(R), atan2(b, a))*Point(-d, D);\n    Point p2=c.p+polar(1/sqrt(R), atan2(b, a))*Point(-d, -D);\n\n    return make_pair(p1, p2);\n}\n\nint main() {\n    double x, y, r;\n    scanf(\"%lf %lf %lf\", &x, &y, &r);\n    Circle c(Point(x, y), r);\n\n    size_t q;\n    scanf(\"%zu\", &q);\n\n    for (size_t i=0; i<q; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        Point p1(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p2(x, y);\n\n        Line l(p1, p2);\n        pair<Point, Point> ps=get_ipoints(c, l);\n        printf(\"%.9f %.9f \", real(ps.first), imag(ps.first));\n        printf(\"%.9f %.9f\\n\", real(ps.second), imag(ps.second));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\n#define eps (1e-10)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nbool cmp_x(const Point& p,const Point& q){\n  if(p.x!=q.x) return p.x<q.x;\n  return p.y<q.y;\n}\nstruct Line{\n    Point p1,p2;\n    Line(){}\n    Line(Point p1, Point p2):p1(p1),p2(p2){}\n};\nstruct Circle{\n    double r;\n    Point p;\n    Circle(){}\n    Circle(Point p,double r):p(p),r(r){}\n};\nint ccw(Point a,Point b,Point c){\n    Point t1=b-a,t2=c-a;\n    if(t1.det(t2)> eps) return 1;//counter clockwise\n    if(t1.det(t2)< -eps) return -1;//clockwise\n    if(t1.dot(t2)< -eps) return 2;//c-a-b online\n    if(t1.norm()<t2.norm()) return -2;//a-b-c online\n    return 0;//a-c-b online\n}\nPoint project(Line l,Point p){\n    Point base=l.p2-l.p1;\n    double r=(p-l.p1).dot(base)/base.norm();\n    return l.p1+base*r;\n}\ndouble distance(Line l,Point p){\n    Point r=project(l,p);\n    if(abs(ccw(l.p1,l.p2,r))==0) return (p-r).abs();//projection not online\n    else return min((p-l.p1).abs(),(p-l.p2).abs());\n}\nbool isIntersectCC(Circle c1,Circle c2){\n    return (c1.p-c2.p).abs()<=c1.r+c2.r+eps;\n}\nbool isIntersectCL(Circle c,Line l){\n    return distance(l,c.p)<=c.r+eps;\n}\npair<Point,Point> CrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=(c1.p-c2.p).abs();\n    double k=acos((d*d+c1.r*c1.r-c2.r*c2.r)/(c1.r*d*2));\n    return make_pair(c1.p+(c2.p-c1.p)*Point(cos(k),sin(k))*(c1.r/d),c1.p+(c2.p-c1.p)*Point(cos(-k),sin(-k))*(c1.r/d));\n}\npair<Point,Point> CrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n    Point p=project(l,c.p);\n    double q=sqrt(c.r*c.r-(p-c.p).norm());\n    Point e=(l.p2-l.p1)*(1.0/(l.p2-l.p1).abs());\n    return make_pair(p+e*q,p-e*q);\n}\nint main(){\n    double cx,cy,r;\n    double x1,y1,x2,y2;\n    int q;\n    cin>>cx>>cy>>r;\n    Circle c(Point(cx,cy),r);\n    cin>>q;\n    rep(i,q){\n        cin>>x1>>y1>>x2>>y2;\n        Line l(Point(x1,y1),Point(x2,y2));\n        pair<Point,Point> pp=CrossPointsCL(c,l);\n        if(!cmp_x(pp.first,pp.second)) swap(pp.first,pp.second);\n        cout<<fixed<<setprecision(12)<<pp.first.x<<\" \"<<pp.first.y<<\" \"<<pp.second.x<<\" \"<<pp.second.y<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ???\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\n// ????§???¢\ntypedef vector<Point> Polygon;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// ???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\nint main()\n{\n  Circle c;\n  cin >> c.c.x >> c.c.y >> c.r;\n  int q; cin >> q;\n  while(q--) {\n    Segment s;\n    cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n    auto ps = getCrossPoints(c, s);\n    Point p, q;\n    tie(p, q) = minmax(ps.first, ps.second);\n    printf(\"%.10f %.10f %.10f %.10f\\n\", p.x, p.y, q.x, q.y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type {{{\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int,int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvll = vector<vector<ll>>;\n// }}}\n// macro {{{\n// }}}\n// debug {{{\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    for (int i=0; i<(((int)(v).size())); ++i) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n// }}}\n// chmax, chmin {{{\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// }}}\n// constants {{{\nconst ll MOD = 1e9+7;\nconst ld EPS = 1e-9;\n// }}}\nusing Real = double;\nconst Real PI = acos(-1);\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\nReal radian_to_degree(Real r) {\n    return r * 180.0 / PI;\n}\nReal degree_to_radian(Real d) {\n    return d * PI / 180.0;\n}\nPoint rotate(const Point &p, Real theta) {\n    return p * polar((Real)1.0, theta);\n}\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n         B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\nconst int COUNTER_CLOCKWISE = 1,\n          CLOCKWISE = -1,\n          ONLINE_BACK = 2,\n          ONLINE_FRONT = -2,\n          ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n                 distance(s2, s1.a), distance(s2, s1.b) });\n}\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n         B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\nstruct Circle {\n    Point p;\n    Real r;\n    Circle() {}\n    Circle(const Point& p, Real r) : p(p), r(r) {}\n};\nint intersected(Circle c1, Circle c2) {\n    if (c1.r < c2.r) swap(c1, c2);\n    Real d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d) return 4;\n    if (eq(c1.r + c2.r, d)) return 3;\n    if (c1.r - c2.r < d) return 2;\n    if (eq(c1.r - c2.r, d)) return 1;\n    return 0;\n}\npair<Point,Point> crosspoint(const Circle& c, const Line& l) {\n    Real h = distance(l, c.p);\n    Point p = projection(l, c.p);\n    if (eq(h, c.r)) return { p, p };\n    Point u = l.a - l.b; u /= abs(u);\n    Real d = sqrt(c.r * c.r - h * h);\n    return { p + u * d, p - u * d };\n}\npair<Point,Point> crosspoint(const Circle& c1, const Circle& c2) {\n    Real d = abs(c2.p - c1.p), t = arg(c2.p - c1.p);\n    Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    return { c1.p + polar(c1.r, t + a),\n             c1.p + polar(c1.r, t - a) };\n}\nint main()\n{\n    cout << fixed << setprecision(10);\n    double x, y, r;\n    cin >> x >> y >> r;\n    Circle c(Point(x, y), r);\n    int q; cin >> q;\n    while (q--) {\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Point p1, p2;\n        tie(p1, p2) = crosspoint(c, Line(Point(x1, y1), Point(x2, y2)));\n        if (p2 < p1) swap(p1, p2);\n        cout << p1.real() << \" \" << p1.imag() << \" \" <<\n                p2.real() << \" \" << p2.imag() << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <istream>\n\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nnamespace asl\n{\n    \n    template <typename numeric_type>\n    class point\n    {\n    public:\n        numeric_type x, y;\n\n        point(numeric_type x = 0, numeric_type y = 0) : x(x), y(y) {}\n\n        bool operator<(const point<numeric_type> &ri) const\n        {\n            if (x != ri.x)\n                return x < ri.x;\n            return y < ri.y;\n        }\n\n        point<numeric_type> &operator+=(const point<numeric_type> &ri)\n        {\n            x += ri.x;\n            y += ri.y;\n            return *this;\n        }\n\n        point<numeric_type> &operator-=(const point<numeric_type> &ri)\n        {\n            x -= ri.x;\n            y -= ri.y;\n            return *this;\n        }\n\n        point<numeric_type> &operator*=(const point<numeric_type> &ri)\n        {\n            auto _x = x * ri.x - y * ri.y;\n            auto _y = x * ri.y + y * ri.x;\n            x = _x;\n            y = _y;\n            return *this;\n        }\n\n        friend point<numeric_type> operator+(const point<numeric_type> &a, const point<numeric_type> &b)\n        {\n            return point<numeric_type>(a) += b;\n        }\n\n        friend point<numeric_type> operator-(const point<numeric_type> &a, const point<numeric_type> &b)\n        {\n            return point<numeric_type>(a) -= b;\n        }\n\n        friend point<numeric_type> operator*(const point<numeric_type> &a, const point<numeric_type> &b)\n        {\n            return point<numeric_type>(a) *= b;\n        }\n\n    };\n\n    template <typename numeric_type>\n    std::ostream &operator<<(std::ostream &out, const point<numeric_type> &p)\n    {\n        return out << p.x << \" \" << p.y;\n    }\n\n    template <typename numeric_type>\n    std::istream &operator>>(std::istream &is, point<numeric_type> &p)\n    {\n        return is >> p.x >> p.y;\n    }\n\n    template <typename numeric_type>\n    numeric_type dot(point<numeric_type> a, point<numeric_type> b)\n    {\n        return a.x * b.x + a.y * b.y;\n    }\n\n    template <const int eps_exp = 9>\n    int sign(double v)\n    {\n        const double eps = std::pow(10, -eps_exp);\n\n        if (v < -eps)\n            return -1;\n        else if (v > eps)\n            return +1;\n        else\n            return 0;\n    }\n\n#include <stdint.h>\n\n    template <typename T>\n    std::ostream &operator<<(std::ostream &out, const std::vector<T> &vec)\n    {\n        bool start = true;\n\n        for (auto x : vec)\n        {\n            if (start)\n            {\n                start = false;\n            }\n            else\n            {\n                out << \" \";\n            }\n\n            out << x;\n        }\n        return out;\n    }\n\n} \n\n#include <experimental/optional>\n\nnamespace asl\n{\n    template <typename numeric_type>\n    class line\n    {\n    public:\n        point<numeric_type> p, q;\n\n    };\n\n    template <typename numeric_type>\n    std::istream &operator>>(std::istream &is, line<numeric_type> &l)\n    {\n        return is >> l.p >> l.q;\n    }\n\n    template <typename numeric_type>\n    class circle\n    {\n    public:\n        point<numeric_type> p;\n        numeric_type r;\n    };\n\n    template <typename numeric_type>\n    std::istream &operator>>(std::istream &is, circle<numeric_type> &c)\n    {\n        return is >> c.p >> c.r;\n    }\n\n    template <typename numeric_type>\n    std::vector<point<numeric_type>> intersect_circle_line(const circle<numeric_type> &circ, const line<numeric_type> &l)\n    {\n        auto u = l.p - l.q, v = l.p - circ.p;\n        auto a = dot(u, u), b = dot(u, v), c = dot(v, v) - circ.r * circ.r;\n        auto det = b * b - a * c;\n        if (sign(det) < 0)\n            return {};\n        if (sign(det) == 0)\n            return {l.p - b / a * u};\n        return {l.p + (-b + sqrt(det)) / a * u,\n                l.p + (-b - sqrt(det)) / a * u};\n    }\n\n} \n\n#include <random>\n\n#define endl '\\n'\n\nusing namespace asl;\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(12);\n    cout << fixed;\n\n    circle<double> c;\n    cin >> c;\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        line<double> l;\n        cin >> l;\n\n        auto res = intersect_circle_line(c, l);\n        sort(res.begin(), res.end());\n\n        if (res.size() == 1)\n            res.push_back(res[0]);\n\n        cout << res << endl;\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (lt(a,b) || equal(a,b))\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\nPoint operator * (const Point &a,const Point &b){ return Point(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); }\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Line{\n  Point s,t;\n  Line(){}\n  Line(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Line &l,const Point &p){\n  Vector b = l.t-l.s;\n  double t = dot(p-l.s,b)/norm(b);\n  return l.s+b*t;\n}\n\ndouble distanceLP(const Line &l,const Point &p){\n  return abs(p-projection(l,p));\n}\n\nstruct Circle{\n  Point p;\n  double r;\n  Circle(){}\n  Circle(Point p,double r) : p(p),r(r) {}\n};\n\nvector<Point> crosspointCL(const Circle &c,const Line &l){\n  vector<Point> res;\n  double d = distanceLP(l,c.p);\n  if(le(d,c.r)){\n    Point p = projection(l,c.p);\n    Vector v = (l.t - l.s) / abs(l.t - l.s);\n    d = sqrt(c.r*c.r-d*d);\n    res.push_back(p - v*d);\n    res.push_back(p + v*d);\n  }\n  return res;\n}\n\nint main(){\n  Circle c;\n  int Q;\n  cin >> c.p >> c.r >> Q;\n  while(Q--){\n    Line l;\n    cin >> l.s >> l.t;\n    vector<Point> cp = crosspointCL(c,l);\n    sort(cp.begin(),cp.end());\n    printf(\"%.10f %.10f %.10f %.10f\\n\",cp[0].x,cp[0].y,cp[1].x,cp[1].y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <array>\n#include <algorithm>\n#include <cassert>\n \nusing Number = double;\n \nconst Number EPS = 1e-10;\nconst Number INF = 1e10;\nconst Number PI = acos(-1.0);\n \ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n \n// change between degree and radian\ninline Number to_radian(const Number degree) { return degree * PI / 180.0; }\ninline Number to_degree(const Number radian) { return radian * 180.0 / PI; }\n \n \n/**\n * Point in two dimensional\n */\nclass Point {\npublic:\n    Number x, y;\n \n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n \n    // Arithmetic operator between points\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(const Point &rhs) const { // cross product between points\n        return Point(this->x * rhs.x - this->y * rhs.y,\n                     this->x * rhs.x + this->y * rhs.x);\n    }\n \n    // Unary operator and compound assignment operator\n    Point operator-() const {\n        return Point(-this->x, -this->y);\n    }\n    Point& operator+=(const Point &rhs) {\n        return *this = *this + rhs;\n    }\n    Point& operator-=(const Point &rhs) {\n        return *this = *this - rhs;\n    }\n \n    // Arithmetic operator between point and number\n    Point operator*(Number rhs) const {\n        return Point(this->x * rhs, this->y * rhs);\n    }\n    Point operator/(Number rhs) const {\n        return Point(this->x / rhs, this->y / rhs);\n    }\n \n    // Comparison operation\n    bool operator==(const Point &rhs) const {\n        return sign(this->x - rhs.x) == 0 && sign(this->y - rhs.y) == 0;\n    }\n    bool operator<(const Point &rhs) const {\n        return (this->x < rhs.x) || (this->x == rhs.x && this->y < rhs.y);\n    }\n \n    // Other operator\n    Number abs(void) const {\n        return sqrt(this->x * this->x + this->y * this->y);\n    }\n    Number abs2(void) const {\n        return this->x * this->x + this->y * this->y;\n    }\n    Number arg(void) const {\n        return atan2(this->y, this->x);\n    }\n    Number dot(const Point &rhs) {\n        return this->x * rhs.x + this->y * rhs.y;\n    }\n    Point rotate90(void) const {\n        return Point(-this->y, this->x);\n    }\n    Point rotate(double angle) const {\n        return Point(cos(angle) * this->x - sin(angle) * this->y,\n                     sin(angle) * this->x + cos(angle) * this->y);\n    }\n \n};\ninline Number dot(const Point &p1, const Point &p2) {\n    return p1.x * p2.x + p1.y * p2.y;\n}\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n// Output of a point\nstd::ostream& operator<<(std::ostream &os, const Point &p) {\n    return os <<  p.x << ' ' << p.y;\n}\n// Input of a point\nstd::istream& operator>>(std::istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\n \n// Counter-Clockwise predicate (a, b, c)\nenum CCW {\n    COUNTER_CLOCKWISE = 1,      // counter clockwise\n    CLOCKWISE         = -1,     // clockwise\n    ONLINE_FRONT      = 2,      // a--c--b on line\n    ONLINE_BACK       = -2,      // c--a--b on line\n    ON_SEGMENT        = 0,     // a--b--c on line\n};\nCCW ccw(const Point &a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (abs_cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (abs_cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0)       return ONLINE_BACK;\n    if (b.abs2() < c.abs2())   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n \n \n/**\n * Line in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0] >> l[1];\n}\ninline CCW ccw(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p);\n}\n \n \n/**\n * Segment in two dimensional\n */\nclass Segment : public Line {\npublic:\n    Segment() {}\n    Segment(const Point &p1, const Point &p2) : Line(p1, p2) {}\n};\n \n \n/**\n * Circle in two dimensional\n */\nclass Circle : public Point {\npublic:\n    Number r;\n    Circle() {}\n    Circle(const Point &p, Number r = 0.0) : Point(p), r(r) {}\n};\n// Input of a circle\nstd::istream& operator>>(std::istream &is, Circle &c) {\n    return is >> c.x >> c.y >> c.r;\n}\n \n \n \n/**\n * Intersection testing\n */\nPoint Projection(const Line &l, const Point &p) {\n    Point dir = l[1] - l[0];\n    Number t = dot(p - l[0], dir) / dir.abs2();\n    return l[0] + dir * t;\n}\ninline Point Reflection(const Line &l, const Point &p) {\n    return Projection(l, p) * 2.0 - p;\n}\n \ninline bool IsOrthogonal(const Line &l1, const Line &l2) {\n    return equal(dot(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n \ninline bool IsIntersect(const Line &l, const Point &p) {\n    return abs(ccw(l[0], l[1], p)) != 1;\n}\ninline bool IsIntersect(const Segment &s, const Point &p) {\n    return ccw(s[0], s[1], p) == 0;\n}\ninline bool IsIntersect(const Line &l1, const Line l2) {\n    return !IsParallel(l1, l2) || IsParallel(l1, Line(l1[0], l2[0]));\n}\ninline bool IsIntersect(const Line &l, const Segment &s) {\n    return abs_cross(l[1] - l[0], s[0] - l[0]) *\n        abs_cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\ninline bool IsIntersect(const Segment &s1, const Segment &s2) {\n    return ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n        ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\ninline bool IsIntersect(const Circle &c, const Point &p) { // p is in interior or boundary\n    return (c - p).abs() <= c.r + EPS;\n}\ninline bool IsIntersect(const Circle &c, const Line &l) {\n    return IsIntersect(c, Projection(l, c));\n}\ninline bool IsIntersect(const Circle &c1, const Circle &c2) {\n    return (c1 - c2).abs() <= c1.r + c2.r && abs(c1.r - c2.r) <= (c1 - c2).abs();\n}\n \n \n/**\n * Distance and Intersection point\n */\ninline Number Distance(const Point &p1, const Point &p2) {\n    return (p1 - p2).abs();\n}\ninline Number Distance(const Line &l, const Point &p) {\n    return (p - Projection(l, p)).abs();\n}\ninline Number Distance(const Segment &s, const Point &p) {\n    if (sign(dot(s[1] - s[0], p - s[0])) == -1) return (p - s[0]).abs();\n    if (sign(dot(s[0] - s[1], p - s[1])) == -1) return (p - s[1]).abs();\n    return (p - Projection(s, p)).abs();\n}\ninline Number Distance(const Line &l1, const Line &l2) {\n    return IsIntersect(l1, l2) ? 0 : Distance(l1, l2[0]);\n}\ninline Number Distance(const Line &l, const Segment &s) {\n    if (IsIntersect(l, s)) return 0.0;\n    return std::min(Distance(l, s[0]), Distance(l, s[1]));\n}\ninline Number Distance(const Segment &s1, const Segment &s2) {\n    if (IsIntersect(s1, s2)) return 0.0;\n    return std::min({Distance(s1, s2[0]), Distance(s1, s2[1]),\n                Distance(s2, s1[0]), Distance(s2, s1[1])});\n}\n \nPoint CrossPoint(const Line &s1, const Line &s2) {\n    Point base = s2[1] - s2[0];\n    Number d1 = abs(abs_cross(base, s1[0] - s2[0]));\n    Number d2 = abs(abs_cross(base, s1[1] - s2[0]));\n    Number t = d1 / (d1 + d2);\n    return s1[0] + (s1[1] - s1[0]) * t;\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c1, const Circle &c2) {\n    Number d = Distance(c1, c2);\n    Number rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2.0 * d);\n    Number rs = sqrt(c1.r * c1.r - rc * rc);\n    Point diff = (c2 - c1) / d;\n    return std::make_pair(c1 + diff * Point(rc, rs), c1 + diff * Point(rc, -rs));\n}\nstd::pair<Point, Point> CrossPoint(const Circle &c, const Line &l) {\n    assert(IsIntersect(c, l));\n    Point mid = Projection(l, c);\n    Point e = (l[1] - l[0]) / (l[1] - l[0]).abs();\n    Number len = sqrt(c.r * c.r - (mid - c).abs2());\n    return std::make_pair(mid + e * len, mid - e * len);\n}\n \n \nint main()\n{\n    std::cout << std::fixed << std::setprecision(15);\n \n    Circle c;\n    Line l;\n    int q;\n \n    std::cin >> c >> q;\n \n    while (q--) {\n        std::cin >> l;\n        auto ans = CrossPoint(c, l);\n        if (ans.second < ans.first)\n            std::swap(ans.first, ans.second);\n        std::cout << ans.first << ' ' << ans.second << '\\n';\n    }\n \n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nVP crosspointLC(Point a1, Point a2, Point c, double r) {\n  VP ps;\n  Point ft = proj(a1, a2, c);\n  if(!GE(r*r,norm(ft-c))) assert(false);\n  assert(r*r >= norm(ft-c));\n  Point dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  ps.push_back(ft - dir);\n  return ps;\n}\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nint main(void){\n    double cx,cy,r;\n    int q;\n    cin>>cx>>cy>>r>>q;\n    rep(i,q){\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        VP ps = crosspointLC(Point(x1,y1),Point(x2,y2),Point(cx,cy),r);\n        sort(all(ps));\n        printf(\"%.9f %.9f \" ,ps[0].X,ps[0].Y);\n        printf(\"%.9f %.9f\\n\",ps[1].X,ps[1].Y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\ntypedef Segment Line;                               //??´???\ntypedef struct Circle{Point c; double r;}Circle;    //???\n\n//????????????a????????????\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n\n//????????????a?????§??????\ndouble absolute(Vector a){\n    return sqrt(norm(a));\n}\n\n//????????????a,b?????????\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\n//??????s(p1p2)???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\n//?????¨??????l?????????????±???????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / absolute(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint main(){\n    \n    int cx, cy;\n    double r;\n    int q;\n    int x1, y1, x2, y2;\n    \n    cin >> cx >> cy >> r >> q;\n    \n    Circle c = {Point(cx, cy), r};\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        \n        Line l = {Point(x1, y1), Point(x2, y2)};\n        \n        pair<Point, Point> ans = getCrossPoints(c, l);\n        bool swap_flag = (ans.first.x == ans.second.x) ? ans.first.y > ans.second.y : (ans.first.x > ans.second.x);\n        if(swap_flag) swap(ans.first, ans.second);\n        \n        printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", ans.first.x, ans.first.y, ans.second.x, ans.second.y);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nVP crosspointLC(Point a1, Point a2, Point c, double r) {\n  VP ps;\n  Point ft = proj(a1, a2, c);\n  assert(r*r >= norm(ft-c));\n  Point dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  ps.push_back(ft - dir);\n  return ps;\n}\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nint main(void){\n    double cx,cy,r;\n    int q;\n    cin>>cx>>cy>>r>>q;\n    rep(i,q){\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        VP ps = crosspointLC(Point(x1,y1),Point(x2,y2),Point(cx,cy),r);\n        sort(all(ps));\n        printf(\"%.9f %.9f \" ,ps[0].X,ps[0].Y);\n        printf(\"%.9f %.9f\\n\",ps[1].X,ps[1].Y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-10, pi = acos((double)-1);\n#define equals(a, b) (fabs((a) - (b)) < eps)\nstruct Point\n{\n    double x, y;\n    Point(const double &a = 0, const double &b = 0) : x(a), y(b) {}\n    void input()\n    {\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    Point operator+(const Point &t)\n    {\n        return Point(x + t.x, y + t.y);\n    }\n    Point operator-(const Point &t)\n    {\n        return Point(x - t.x, y - t.y);\n    }\n    Point operator*(const double &k)\n    {\n        return Point(k * x, k * y);\n    }\n    Point operator/(const double &k)\n    {\n        return Point(x / k, y / k);\n    }\n    Point turn(double T) // 逆时针旋转T弧度\n    {\n        return Point(x * cos(T) - y * sin(T),\n        x * sin(T) + y * cos(T));\n    }\n    Point Normal() // 求单位法向量\n    {\n        return Point(-(y / length()), x / length());\n    }\n    double operator*(const Point &t) // 内积\n    {\n        return (x * t.x + y * t.y);\n    }\n    double operator^(const Point &t) // 叉积\n    {\n        return (x * t.y - y * t.x);\n    }\n    bool operator==(const Point &t) // 判断是否相等\n    {\n        return equals((x - t.x), 0.0) && equals((y - t.y), 0.0);\n    }\n    double norm()\n    {\n        return x * x + y * y;\n    }\n    double length() // 向量长度\n    {\n        return sqrt(norm());\n    }\n};\ntypedef Point Vector;\nstruct Segment\n{\n    Point p1, p2;\n    Vector base()\n    {\n        return Vector(p2 - p1);\n    }\n};\ntypedef Segment Line;\nstruct Circle\n{\n    Point c; double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n    void input()\n    {\n        c.input(); scanf(\"%lf\", &r);\n    }\n};\ntypedef vector<Point> Polygon;\ndouble Dist(Point a, Point b) // 两点距离\n{\n    return (a - b).length();\n}\ndouble Angle(Vector a, Vector b) // 求两向量夹角\n{\n    return acos(a * b / (a.length() * b.length()));\n}\nbool isOrthogonal(Vector a, Vector b) // 两向量是否正交\n{\n    return equals((a * b), 0.0);\n}\nbool isParallel(Vector a, Vector b) // 两向量是否平行\n{\n    return equals((a ^ b), 0.0);\n}\nbool istouch(Point a, Vector v, Point c, double r) // 直线a->v是否与圆c相交（不相切）\n{\n    Point b = a + v;\n    return (fabs((a - c) ^ (b - c)) / Dist(a, b) < r);\n}\nbool isOnShot(Point a, Vector v, Point b) // b是否在射线a->v上\n{\n    return isParallel((b - a), v) && ((b - a) * v >= eps);\n}\nbool isOnSeg(Point a, Point b, Point c) // c是否在线段ab上\n{\n    return isParallel((c - a), (c - b)) && ((c - a) * (c - b) < eps);\n}\nPoint getCrossPoint(Segment s1, Segment s2) // 求两线段的交点\n{\n    double d1 = fabs((s2.base() ^ (s1.p1 - s2.p1)));\n    double d2 = fabs((s2.base() ^ (s1.p2 - s2.p1)));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + s1.base() * t;\n}\nPoint Projection(Line s, Point p) // 点p在直线s上的投影\n{\n    double r = ((p - s.p1) * s.base()) / s.base().norm();\n    return s.p1 + s.base() * r;\n}\nPoint Reflection(Line s, Point p) // 点p关于直线s的对称点\n{\n    return p + (Projection(s, p) - p) * 2.0;\n}\ndouble DistLP(Line s, Point p) // 点p到直线s的距离\n{\n    return fabs(s.base() ^ (p - s.p1)) / s.base().length();\n}\ndouble DistSP(Segment s, Point p) // 点p到线段s的距离\n{\n    if((s.base() * (p - s.p1)) < 0.0) return (p - s.p1).length();\n    if(((s.p1 - s.p2) * (p - s.p2)) < 0.0)  return (p - s.p2).length();\n    return DistLP(s, p);\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) // 点p2在线段p0p1的逆时针/顺时针方向或者在线段p0p1前/后/上\n{\n    Vector v1 = p1 - p0, v2 = p2 - p0;\n    if((v1 ^ v2) > eps) return COUNTER_CLOCKWISE;\n    if((v1 ^ v2) < -eps) return CLOCKWISE;\n    if((v1 * v2) < -eps) return ONLINE_BACK;\n    if(v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool Intersect(Point p1, Point p2, Point p3, Point p4) // 线段p1p2和线段p3p4是否相交\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n    ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool Intersect(Segment s1, Segment s2) // 线段s1和线段s2是否相交\n{\n    return Intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool Intersect(Circle c, Line l) // 圆c与直线l是否相交\n{\n    return (DistLP(l, c.c) < c.r) || equals(DistLP(l, c.c), c.r);\n}\ndouble DistSS(Segment s1, Segment s2) // 线段s1与线段s2的距离\n{\n    if(Intersect(s1, s2)) return 0.0;\n    return min(min(DistSP(s1, s2.p1), DistSP(s1, s2.p2)),\n    min(DistSP(s2, s1.p1), DistSP(s2, s1.p2)));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n    Point pr = Projection(l, c.c);\n    Vector e = l.base() / l.base().length();\n    double base = sqrt(c.r * c.r - (pr - c.c).norm());\n    return make_pair(pr + e * base, pr - e * base);\n}\ninline int read()\n{\n    int w = 1, s = 0; char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') w = -1; ch = getchar(); }\n    while(isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();\n    return w * s;\n}\nint main()\n{\n    Circle c; c.input();\n    int q = read();\n    while(q--)\n    {\n        Line l;\n        l.p1.input(), l.p2.input();\n        pair<Point, Point> tp;\n        if(Intersect(c, l)) tp = getCrossPoints(c, l);\n        if(tp.first.x < tp.second.x || (equals(tp.first.x, tp.second.x) && tp.first.y < tp.second.y))\n            printf(\"%.10lf %.10lf %.10lf %.10lf\\n\", tp.first.x, tp.first.y, tp.second.x, tp.second.y);\n        else\n            printf(\"%.10lf %.10lf %.10lf %.10lf\\n\", tp.second.x, tp.second.y, tp.first.x, tp.first.y);\n    }\n//    system(\"pause\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tld d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nint main()\n{\n\tint q;\n\tld x, y, r, x1, x2, y1, y2;\n\tcout << fixed << setprecision(9);\n\tcin >> x >> y >> r;\n\tCircle c = { (Point) { x, y }, r };\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tLine l = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tauto res = is_lc(c, l);\n\t\tsort(res.begin(), res.end(), [](const Point& l, const Point& r) { return l.real() < r.real() ? false : l.real() == l.real() && l.imag() <= r.imag() ? false : false; });\n\t\tcout << res[0].real() << ' ' << res[0].imag() << ' ' << res[1].real() << ' ' << res[1].imag() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<set>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\nenum\n{\n\tBOTTOM,\n\tLEFT,\n\tRIGHT,\n\tTOP\n};\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\n\tP unit()const\n\t{\n\t\treturn P(x / length(), y / length());\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tdouble cx, cy, cr;\n\tcin >> cx >> cy >> cr;\n\tP c(cx, cy);\n\n\tint q;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tP p1(x1, y1), p2(x2, y2);\n\n\t\tP p1c = c - p1, p12 = (p2 - p1).unit();\n\t\tP pp = p1 + p12*(p1c.x*p12.x + p1c.y*p12.y);\n\n\t\tdouble h = (c - pp).length();\n\n\t\tif (h == cr)\n\t\t{\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\", pp.x, pp.y, pp.x, pp.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tP cp1 = pp + p12*sqrt(cr*cr - h*h), cp2 = pp - p12*sqrt(cr*cr - h*h);\n\t\t\tif (cp1 > cp2)\n\t\t\t{\n\t\t\t\tswap(cp1, cp2);\n\t\t\t}\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\", cp1.x, cp1.y, cp2.x, cp2.y);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\n// VP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// // cross point between circles Verify AOJ CGL_7_E\n// VP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n/*\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}*/\n\nVP pcl(C c, L l) {\n    P h=proj(l,c.c);\n    P e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n    return VP{h-e,h+e};\n}\nVP pcc(C a,C b){\n    P d=b.c-a.c;\n    P w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n    P e=w*P(0,1);\n    return pcl(a,{w-e,w+e}); \n}\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n    int q;\n    C c;\n    {\n\t\tR x,y,r;\n\t\tcin >> x >> y >> r;\n\t\tc=C({P(x,y),R(r)});\n\t}\n         \n    cin >> q;\n    cout.precision(20);\n    rep(i,q){\n        L l;\n        {\n\t\t\tR x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n        VP res=pcl(c,l);\n        if(real(res[0])>real(res[1])) swap(res[0],res[1]);\n        if(real(res[0])==real(res[1])&&imag(res[0])>imag(res[1])) swap(res[0],res[1]);\n        cout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n    }\n    return 0;\n}\n\n\n/*int main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef long long ll;\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\n// 点\nstruct Point {\n    double x,y;\n    Point(){}\n    Point(double x, double y) : x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x, y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x, y-p.y);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){sqrt(norm());}\n    bool operator == (const Point &p) const {return equals(x,p.x)&&equals(y,p.y);}\n    bool operator < (const Point &p) const {\n        return x!=p.x?x<p.x:y<p.y;\n        //grid-point only\n        //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n    }\n};\n\ntypedef Point P;\ntypedef vector<Point> Polygon;\n\ndouble norm(P a){return a.x*a.x+a.y*a.y;}\ndouble abs(P a){return sqrt(norm(a));}\n\n// 線分\nstruct Segment {\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\n\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c, double r):c(c),r(r){}\n};\n\n// 法線ベクトル\nPoint normal(Point p){return Point(-p.y,p.x);}\n\n// 内積\ndouble dot(Point a, Point b) {return a.x*b.x + a.y*b.y;}\n\n// 外積\ndouble cross(Point a, Point b) {return a.x*b.y-a.y*b.x;}\n// 2直線の直行判定\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return equals(dot(a1-a2, b1-b2), 0.0);\n}\n// 2直線の平行判定\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return equals(cross(a1-a2, b1-b2), 0.0);\n}\n// 点cが直線ab上にあるかないか\nbool is_point_on_INF_line(Point a, Point b, Point c) {\n    return equals(cross(b-a,c-a), 0.0);\n}\n// 点cが線分ab上にあるかないか\nbool is_point_on_LIMITED_line(Point a, Point b, Point c) {\n    return (Point(a-c).abs()+Point(c-b).abs() < Point(a-b).abs() + EPS);\n}\n// 直線と点の距離\ndouble distance_l_p(Point a, Point b, Point c) {return abs(cross(b-a, c-a)) / (b-a).abs();}\n\n// 直線と点の距離\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\n// 線分と点の距離\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(Point a, Point b, Point c) {\n    if (dot(b-a, c-a) < EPS) return (c-a).abs();\n    if (dot(a-b, c-b) < EPS) return (c-b).abs();\n    return abs(cross(b-a, c-a)) / (b-a).abs();\n}\n\nPoint project(Segment s, Point p) {\n    Point base = s.p2-s.p1;\n    double r = dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\n// 点が線分のどちら側にあるかを計算\nint ccw(Point p0,Point p1,Point p2) {\n    P a = p1-p0;\n    P b = p2-p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0&&ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool intersectSS(Segment s1, Segment s2) {\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n// 多角形と線分の交差判定\nbool intersectPS(Polygon p,Segment l){\n    int n=p.size();\n    for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n    return 0;\n}\n\n// 円と円の交差判定\nint intersectCC(Circle c1,Circle c2){\n    if(c1.r<c2.r) swap(c1,c2);\n    double d=abs(c1.c-c2.c);\n    double r=c1.r+c2.r;\n    if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n    if(d>r) return ICC_SEPERATE;\n    if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n    if(d+c2.r<c1.r) return ICC_CONTAIN;\n    return ICC_INTERSECT;\n}\n\n// 線分と円の交差判定\nbool intersectSC(Segment s,Circle c){\n    return getDistanceSP(s,c.c)<=c.r;\n}\n\n// \nint intersectCS(Circle c,Segment s){\n    if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n    double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n    if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n    if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n    Point h=project(s,c.c);\n    if(dot(s.p1-h,s.p2-h)<0) return 2;\n    return 0;\n}\n\n\n\n\n// 線分と線分の距離\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(intersectSS(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\n// 前提として交差していることが必要\nP getCrossPointSS(P a1, P a2, P b1, P b2) {\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1/(d1+d2);\n    return a1+(a2-a1)*t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\n// 前提として平行でないことが必要\nPoint getCrossPointLL(Line l1,Line l2){\n    double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n    double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n    if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n    return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\ndouble arg(Point p){\n    return atan2(p.y,p.x);\n}\n\nPoint polar(double a,double r) {\n    return Point(cos(r)*a,sin(r)*a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n    Polygon ps;\n    Point pr=project(l,c.c);\n    Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    if(equals(getDistanceLP(l,c.c),c.r)){\n        ps.emplace_back(pr);\n        return ps;\n    }\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    ps.emplace_back(pr+e*base);\n    ps.emplace_back(pr-e*base);\n    return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n    Line l(s);\n    Polygon res=getCrossPointCL(c,l);\n    if(intersectCS(c,s)==2) return res;\n    if(res.size()>1u){\n        if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n        res.pop_back();\n    }\n    return res;\n}\n\nint main() {\n    double x0,y0,r; cin>>x0>>y0>>r;\n    Circle c(Point(x0,y0),r);\n    int q; cin>>q;\n    cout<<fixed<<setprecision(10);\n    rep(i,q) {\n        double x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2;\n        Line l(P(x1,y1),P(x2,y2));\n        Polygon ans = getCrossPointCL(c,l);\n        if (ans.size()==1) {\n            rep(i,2) cout<<ans[0].x<<\" \"<<ans[0].y<<\" \";\n            cout<<endl;\n            continue;\n        }\n        \n        if (ans[0].x > ans[1].x) swap(ans[0],ans[1]);\n        else if (ans[0].x==ans[1].x && ans[0].y>ans[1].y) swap(ans[0],ans[1]);\n        rep(i,ans.size()) {\n            cout<<ans[i].x<<\" \"<<ans[i].y<<\" \";\n        }\n        cout<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) x.begin(),x.end()\nconst long double PI = acos(-1.0L);\nconst long long MOD = 1000000007LL;\n// const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nusing DD = double; // 精度が足りないときはlong double\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//点\nstruct Point {\n    DD x, y;\n    Point (DD x = 0, DD y = 0): x(x), y(y) {}\n\n    Point& operator+=(const Point &p) { x += p.x; y += p.y; return *this;}\n    Point operator+(const Point &p) const { return Point(*this) += p;}\n    Point& operator-=(const Point &p) { x -= p.x; y -= p.y; return *this;}\n    Point operator-(const Point &p) const { return Point(*this) -= p;}\n    Point& operator*=(DD a) { x *= a; y *= a; return *this;}\n    Point operator*(DD a) const { return Point(*this) *= a;}\n    Point& operator/=(DD a) { x /= a; y /= a; return *this;}\n    Point operator/(DD a) const { return Point(*this) /= a;}\n    bool operator== (const Point &p) const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;}\n    friend istream& operator >>(istream& is, Point& p) { is >> p.x >> p.y; return is;}\n    friend ostream& operator <<(ostream& os, const Point& p) { os<<p.x<<\" \"<<p.y; return os;}\n};\ntypedef Point Vector; //ベクトル\n\ninline DD norm(const Vector &a) { return a.x * a.x + a.y * a.y;}\ninline DD abs(const Vector &a) { return sqrt(norm(a));}\ninline DD dot(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y;}\ninline DD cross(const Vector &a, const Vector &b) { return a.x * b.y - a.y * b.x;}\n\n//線分\nstruct Segment {\n    Point p1,p2;\n    Segment(Point p1 = Point(), Point p2 = Point()): p1(p1),p2(p2) {}\n};\ntypedef Segment Line; //直線\n\nstruct Circle {\n    Point c;\n    DD r;\n    Circle(Point c = Point(), DD r = 0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon; //多角形\n\n//射影\nPoint project(const Segment &s, const Point &p) {\n    Vector base = s.p2 - s.p1;\n    DD r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\ninline Point reflect(const Segment &s, const Point &p) {return p + (project(s,p) - p) * (DD)2;} //線対称\n\nint ccw(const Point &p0, const Point &p1, const Point &p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a,b) > EPS) return 1; //p0,p1から見てp2は左側(反時計回り)\n    if (cross(a,b) < -EPS) return -1; //p0,p1から見てp2は右側(時計回り)\n    if (dot(a,b) < -EPS) return 2; //p2-p0-p1の順に一直線上\n    if (norm(a) < norm(b)) return -2; //p0-p1-p2の順に一直線上\n    return 0; //p0-p2-p1の順に一直線上\n}\n//線分p1,p2とp3,p4の交差判定\ninline bool intersect(const Point &p1, const Point &p2, const Point &p3, const Point &p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);}\ninline bool intersect(const Segment &s1, const Segment &s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2);}\ninline DD getDistance(const Point &a, const Point &b) { return abs(a - b);}\ninline DD getDistanceLP(const Line &l, const Point &p) { return abs(cross(l.p2 - l.p1,p - l.p1) / abs(l.p2 - l.p1));}\nDD getDistanceSP(const Segment &s, const Point &p) {\n    if (dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\nDD getDistance(const Segment &s1, const Segment &s2) {\n    if (intersect(s1, s2)) return (DD)0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n//線分と線分の交点\nPoint getCrossPoint(const Segment &s1, const Segment &s2) {\n    Vector base = s2.p2 - s2.p1;\n    DD d1 = abs(cross(base, s1.p1 - s2.p1));\n    DD d2 = abs(cross(base, s1.p2 - s2.p1));\n    DD t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//円と直線の交差判定\ninline bool intersect(const Circle &c, const Line &l) { return getDistanceLP(l, c.c) - c.r < EPS;}\n\n//円と線分の交点\npair<Point, Point> getCrossPoints(const Circle &c, const Line &l) {\n    assert(intersect(c,l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    DD base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint ort(const Point &a) { //象限\n    if (norm(a) < EPS) return 0;\n    if (a.y > 0) return a.x > 0 ? 1 : 2;\n    return a.x > 0 ? 4 : 3;\n}\n\nbool xsort(const Point &a, const Point &b) {\n    if (equals(a.x, b.x)) return a.y < b.y;\n    return a.x < b.x;\n}\n\nbool ysort(const Point &a, const Point &b) {\n    if (equals(a.y, b.y)) return a.x < b.x;\n    return a.y < b.y;\n}\n\nbool argsortcross(const Point &a, const Point &b) {\n    int ao = ort(a), bo = ort(b);\n    if (ao != bo) return ao < bo;\n    return cross(a,b) > 0;\n}\n\nbool argsortatan2(const Point &a, const Point &b) {\n    return atan2(a.y, a.x) < atan2(b.y, b.x);\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    Circle C; cin >> C.c >> C.r;\n    int Q; cin >> Q;\n    while (Q--) {\n        Segment s; cin >> s.p1 >> s.p2;\n        vector<Point> p(2);\n        tie(p[0],p[1]) = getCrossPoints(C,s);\n        sort(all(p),xsort);\n        cout << fixed << setprecision(10) << p[0] << \" \" << p[1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nnamespace geom {\n  constexpr double eps = 1e-8;\n\n  /* point */\n  struct Point {\n    double x, y;\n    Point() : x(0.0), y(0.0) {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(this->x + p.x, this->y + p.y); }\n    Point operator-(const Point& p) const { return Point(this->x - p.x, this->y - p.y); }\n    Point operator*(double d) const { return Point(x * d, y * d); }\n    Point operator/(double d) const { return Point(x / d, y / d); }\n    Point operator-() const { return Point(-this->x, -this->y); }\n    Point& operator+=(const Point& p) { return *this = *this + p; }\n    Point& operator-=(const Point& p) { return *this = *this - p; }\n    Point& operator*=(double d) { return *this = *this * d; }\n    Point& operator/=(double d) { return *this = *this / d; }\n    friend Point operator*(double d, const Point& p) { return Point(p.x * d, p.y * d); }\n    bool operator==(const Point& p) const { return x == p.x && y == p.y; }\n    bool operator!=(const Point& p) const { return !(*this == p); }\n    bool operator<(const Point& p) const { return x == p.x ? y < p.y : x < p.x; }\n    bool operator<=(const Point& p) const { return *this == p || *this < p; }\n    bool operator>(const Point& p) const { return !(*this <= p); }\n    bool operator>=(const Point& p) const { return !(*this < p); }\n    double length() const { return std::sqrt(x * x + y * y); }\n    double length2() const { return x * x + y * y; }\n    Point unit() const { return *this / length(); }\n    Point normal() const { return Point(-y, x); }\n    double distance(const Point& p) const { return sqrt(pow(x - p.x, 2.0) + pow(y - p.y, 2.0)); }\n    friend std::ostream& operator<<(std::ostream& o, const Point& p) {\n      o << '(' << p.x << ',' << p.y << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Point& p) {\n      i >> p.x >> p.y;\n      return i;\n    }\n  };\n  \n  /* vector */\n  using Vector = Point;\n  double cross_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n  }\n  double inner_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n  }\n  enum struct ccw_t {\n    COUNTER_CLOCKWISE,\n    CLOCKWISE,\n    ONLINE_BACK,\n    ONLINE_FRONT,\n    ON_SEGMENT\n  };\n  ccw_t ccw(const Point& p0, const Point& p1, const Point& p2) {\n    Vector v1 = p1 - p0, v2 = p2 - p0;\n    if (cross_product(v1, v2) > eps) return ccw_t::COUNTER_CLOCKWISE;\n    if (cross_product(v1, v2) < -eps) return ccw_t::CLOCKWISE;\n    if (inner_product(v1, v2) < -eps) return ccw_t::ONLINE_BACK;\n    if (v1.length2() < v2.length2()) return ccw_t::ONLINE_FRONT;\n    return ccw_t::ON_SEGMENT;\n  }\n\n  /* line */\n  struct Line {\n    Point p1, p2;\n    Line() {}\n    Line(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}\n    Line(double x1, double y1, double x2, double y2) : p1(Point(x1, y1)), p2(Point(x2, y2)) {}\n    Vector to_vector() const { return p2 - p1; }\n    Point projection(const Point& p) const {\n      Vector v12(p2 - p1);\n      double det = v12.length2();\n      double a = v12.y * p1.x - v12.x * p1.y, b = v12.y * p.y + v12.x * p.x;\n      double x = v12.y * a + v12.x * b, y = v12.y * b - v12.x * a;\n      return Point(x / det, y / det);\n    }\n    Point reflection(const Point& p) const {\n      Point proj = projection(p);\n      return proj + proj - p;\n    }\n    double distance(const Point& p) const {\n      return projection(p).distance(p);\n    }\n    bool is_parallel(const Line& l) const {\n      return abs(cross_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    bool is_orthogonal(const Line& l) const {\n      return abs(inner_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    Point intersection(const Line& l) const {\n      Point p0(this->p1), p1(this->p2), p2(l.p1), p3(l.p2);\n      Vector v01(p1 - p0), v23(p3 - p2);\n      double det = cross_product(v01, v23);\n      double a = v01.y * p0.x - v01.x * p0.y, b = v23.y * p2.x - v23.x * p2.y;\n      double x = v01.x * b - v23.x * a;\n      double y = v01.y * b - v23.y * a;\n      return Point(x / det, y / det);\n    }\n    friend std::ostream& operator<<(std::ostream& o, const Line& l) {\n      o << '(' << l.p1 << ',' << l.p2 << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Line& l) {\n      i >> l.p1 >> l.p2;\n      return i;\n    }\n  };\n\n  /* segment */\n  using Segment = Line;\n  bool is_intersect_segments(const Segment& s1, const Segment& s2) {\n    Vector v2 = s2.to_vector(), p1(s1.p1 - s2.p1), p2(s1.p2 - s2.p1);\n    if (cross_product(v2, p1) * cross_product(v2, p2) > eps) return false;\n    Vector v1 = s1.to_vector(), p3(s2.p1 - s1.p1), p4(s2.p2 - s1.p1);\n    if (cross_product(v1, p3) * cross_product(v1, p4) > eps) return false;\n    if (inner_product(s2.p1 - s1.p1, s2.p2 - s1.p1) < eps) return true;\n    if (inner_product(s2.p1 - s1.p2, s2.p2 - s1.p2) < eps) return true;\n    if (inner_product(s1.p1 - s2.p1, s1.p2 - s2.p1) < eps) return true;\n    if (inner_product(s1.p1 - s2.p2, s1.p2 - s2.p2) < eps) return true;\n    return false;\n  }\n  bool is_intersect_segment_line(const Segment s, const Line& l) {\n    if (l.is_parallel(s)) return false;\n    Vector vst = l.to_vector();\n    Point ps = l.p1;\n    return cross_product(vst, s.p1 - ps) * cross_product(vst, s.p2 - ps) < eps;\n  }\n  double segment_distance(const Segment& s, const Point& p) {\n    Point proj = s.projection(p);\n    if (ccw(s.p1, proj, s.p2) == ccw_t::ONLINE_FRONT) return p.distance(proj);\n    return min(p.distance(s.p1), p.distance(s.p2));\n  }\n  double segment_distance(const Segment& s1, const Segment& s2) {\n    if (is_intersect_segments(s1, s2)) return 0.0;\n    return min({\n      segment_distance(s1, s2.p1), segment_distance(s1, s2.p2),\n      segment_distance(s2, s1.p1), segment_distance(s2, s1.p2)\n      });\n  }\n\n  /* polygon */\n  using Polygon = std::vector<Point>;\n  double area(const Polygon& poly) {\n    if (poly.size() <= 2) return 0;\n    Point b(DBL_MAX, DBL_MAX);\n    for (const Point& p : poly) {\n      b.x = min(b.x, p.x); b.y = min(b.y, p.y);\n    }\n    b.x -= 1.0; b.y -= 1.0;\n    int n = (int)poly.size();\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n      area += cross_product(poly[i] - b, poly[(i + 1) % n] - b) * 0.5;\n    }\n    return area;\n  }\n  bool is_convex(const Polygon& poly) {\n    if (poly.size() <= 2) return false;\n    int n = (int)poly.size();\n    for (int i = 0; i < n; i++) {\n      if (ccw(poly[i], poly[(i + 1) % n], poly[(i + 2) % n]) == ccw_t::CLOCKWISE) {\n        return false;\n      }\n    }\n    return true;\n  }\n  enum struct poly_t {\n    EXTERNAL = 0,\n    ON_SEGMENT = 1,\n    INTERNAL = 2\n  };\n  poly_t is_inside(const Point& p, const Polygon& poly) {\n    int n = (int)poly.size();\n    double rad = 0.0;\n    for (int i = 0; i < n; i++) {\n      const Point& p1 = poly[i];\n      const Point& p2 = poly[(i + 1) % n];\n      double d1 = p.distance(p1), d2 = p.distance(p2);\n      if (segment_distance(Segment(p1, p2), p) < eps) return poly_t::ON_SEGMENT;\n      Vector v1(p1 - p), v2(p2 - p);\n      double r = atan2(cross_product(v1, v2), inner_product(v1, v2));\n      rad += r;\n    }\n    return rad < eps ? poly_t::EXTERNAL : poly_t::INTERNAL;\n  }\n\n  /* convex hull */\n  using Hull = Polygon;\n  Hull convex_hull(std::vector<Point> points, bool strict = true) {\n    double e = strict ? eps : -eps;\n    std::sort(points.begin(), points.end());\n    int n = (int)points.size(), k = 0;\n    Hull hull(2 * n);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    hull.resize(k - 1);\n    return hull;\n  }\n  double convex_diameter(const Hull& hull) {\n    int n = (int)hull.size();\n    if (n == 2) return hull.front().distance(hull.back());\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n      if (hull[k] < hull[i]) i = k;\n      if (hull[j] < hull[k]) j = k;\n    }\n    double d = 0.0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n      d = max(d, hull[i].distance(hull[j]));\n      if (cross_product(hull[(i + 1) % n] - hull[i], hull[(j + 1) % n] - hull[j]) < 0.0) {\n        i = (i + 1) % n;\n      }\n      else {\n        j = (j + 1) % n;\n      }\n    }\n    return d;\n  }\n  std::pair<Hull, Hull> convex_cut(const Hull& hull, const Line& l) {\n    int n = (int)hull.size(), i = -1, j = -1;\n    Point pi, pj;\n    for (int k = 0; k < n; k++) {\n      Segment s(hull[k], hull[(k + 1) % n]);\n      if (is_intersect_segment_line(s, l)) {\n        if (cross_product(l.to_vector(), s.to_vector()) < 0) {\n          i = k;\n          pi = l.intersection(s);\n        }\n        else {\n          j = k;\n          pj = l.intersection(s);\n        }\n      }\n    }\n    if (i < 0) {\n      // no cut: 左か右か判定\n      if (cross_product(l.to_vector(), hull.front() - l.p1) > 0) {\n        // left\n        return std::make_pair(hull, Hull());\n      }\n      else {\n        return std::make_pair(Hull(), hull);\n      }\n    }\n    Hull left({ pi, pj }), right({ pj, pi });\n    for (int k = (j + 1) % n, e = (i + 1) % n; k != e; k = (k + 1) % n) {\n      if(left.back().distance(hull[k]) > eps) left.push_back(hull[k]);\n    }\n    for (int k = (i + 1) % n, e = (j + 1) % n; k != e; k = (k + 1) % n) {\n      if(right.back().distance(hull[k]) > eps) right.push_back(hull[k]);\n    }\n    if (left.front().distance(left.back()) < eps) left.pop_back();\n    if (right.front().distance(right.back()) < eps) right.pop_back();\n    return std::make_pair(left, right);\n  }\n\n  /* closest pair : 逐次構成法 */\n  double closest_pair_incremental(std::vector<Point> ps) {\n    using ll = long long;\n    using Grid = std::unordered_map<ll, std::vector<Point>>;\n    // for random\n    uint64_t x = 88172645463325252LL;\n    auto rnd = [&x](int mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return unsigned(x % mod); };\n    // shuffle\n    int n = (int)ps.size();\n    for (int i = n - 1; i >= 1; i--) {\n      int j = (int)rnd(i);\n      std::swap(ps[i], ps[j]);\n    }\n    // set bounding box\n    double x_min = DBL_MAX, x_max = DBL_MIN;\n    double y_min = DBL_MAX, y_max = DBL_MIN;\n    for (const Point& p : ps) {\n      x_min = min(x_min, p.x); x_max = max(x_max, p.x);\n      y_min = min(y_min, p.y); y_max = max(y_max, p.y);\n    }\n    x_min -= eps; x_max += eps; y_min -= eps; y_max += eps;\n    // grid generator\n    double delta = ps[0].distance(ps[1]);\n    auto generate_grid = [&](int sz, double delta) {\n      ll h = (int)ceil((y_max - y_min) / delta);\n      ll w = (int)ceil((x_max - x_min) / delta);\n      Grid grid;\n      for (int i = 0; i < sz; i++) {\n        double x = ps[i].x, y = ps[i].y;\n        ll ix = (ll)floor((x - x_min) / delta);\n        ll iy = (ll)floor((y - y_min) / delta);\n        grid[iy * w + ix].push_back(ps[i]);\n      }\n      return std::make_tuple(h, w, std::move(grid)); \n    };\n    // 幅 delta のグリッド構築\n    ll h, w;\n    Grid grid;\n    tie(h, w, grid) = generate_grid(2, delta);\n    for (int k = 2; k < n; k++) {\n      // d_i = d(p_i, S_i) を計算\n      double x = ps[k].x, y = ps[k].y;\n      ll ix = (ll)floor((x - x_min) / delta);\n      ll iy = (ll)floor((y - y_min) / delta);\n      // 近傍のみ調べればいい\n      double ndelta = delta;\n      for (ll i = max(iy - 1, 0LL); i <= min(iy + 1, h - 1); i++) {\n        for (ll j = max(ix - 1, 0LL); j <= min(ix + 1, w - 1); j++) {\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p : grid[i * w + j]) {\n            ndelta = std::min(ndelta, ps[k].distance(p));\n          }\n        }\n      }\n      if (ndelta < delta) {\n        // update grid\n        delta = ndelta;\n        tie(h, w, grid) = generate_grid(k + 1, delta);\n      }\n      else {\n        // insert point\n        grid[iy * w + ix].push_back(ps[k]);\n      }\n    }\n    return delta;\n  }\n\n  /* closest pair : 篩法 */\n  double closest_pair_sieve(const std::vector<Point>& ps) {\n    using ll = long long;\n    using Grid = std::unordered_map<ll, std::vector<Point>>;\n    // init grid\n    Grid grid;\n    for (const Point& p : ps) grid[0].push_back(p);\n    // for random\n    uint64_t x = 88172645463325252LL;\n    auto rnd = [&x](int mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return unsigned(x % mod); };\n    // set bounding box\n    double x_min = DBL_MAX, x_max = DBL_MIN;\n    double y_min = DBL_MAX, y_max = DBL_MIN;\n    for (const Point& p : ps) {\n      x_min = min(x_min, p.x); x_max = max(x_max, p.x); \n      y_min = min(y_min, p.y); y_max = max(y_max, p.y);\n    }\n    x_min -= eps; x_max += eps; y_min -= eps; y_max += eps;\n    // grid updator\n    auto update_grid = [&](const Grid& grid, double delta, bool erase_mode = true) {\n      int erased = 0;\n      ll h = (ll)ceil((y_max - y_min) / delta);\n      ll w = (ll)ceil((x_max - x_min) / delta);\n      Grid ngrid;\n      for (auto it = grid.begin(); it != grid.end(); ++it) {\n        for (const Point& p : it->second) {\n          ll ix = (ll)floor((p.x - x_min) / delta);\n          ll iy = (ll)floor((p.y - y_min) / delta);\n          ngrid[iy * w + ix].push_back(p);\n        }\n      }\n      if (erase_mode) {\n        // 孤立点の除去\n        auto it = ngrid.begin();\n        while (it != ngrid.end()) {\n          if (it->second.size() >= 2) { ++it; continue; }\n          ll pos = it->first, iy = pos / w, ix = pos % w;\n          // 8 近傍に点がなければ、削除する\n          bool found = [&]() {\n            for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n              for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n                if (i == iy && j == ix) continue;\n                if (ngrid.count(i * w + j)) {\n                  return true;\n                }\n              }\n            }\n            return false;\n          } ();\n          if (!found) {\n            it = ngrid.erase(ngrid.find(pos));\n            erased++;\n          }\n          else ++it;\n        }\n      }\n      return make_tuple(erased, h, w, std::move(ngrid));\n    };\n    // elimination phase\n    int n = (int)ps.size(), erased;\n    ll h = 1, w = 1;\n    double delta = DBL_MAX;\n    while (n) {\n      // ランダムに点を選ぶ\n      auto it = std::next(grid.begin(), rnd((int)grid.size()));\n      ll pos = it->first;\n      auto& cands = it->second;\n      int i = rnd((int)cands.size());\n      Point selected = cands[i];\n      // 一旦消す\n      cands.erase(cands.begin() + i);\n      // pos 周辺を探索\n      ll iy = pos / w, ix = pos % w;\n      for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n        for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p : grid[i * w + j]) {\n            delta = min(delta, selected.distance(p));\n          }\n        }\n      }\n      // 元に戻す\n      cands.push_back(selected);\n      // 幅 delta / 8 で grid を作成\n      delta /= 8;\n      tie(erased, h, w, grid) = update_grid(grid, delta);\n      n -= erased;\n    }\n    delta *= 8;\n    // 最終的な delta で最近点対探索\n    // reset grid\n    for (const Point& p : ps) grid[0].push_back(p);\n    tie(erased, h, w, grid) = update_grid(grid, delta, false);\n    // find closest points\n    delta = DBL_MAX;\n    for (auto it = grid.begin(); it != grid.end(); ++it) {\n      ll pos = it->first;\n      auto& cands = it->second;\n      // 自身の近傍\n      for (int i = 0; i < (int)cands.size() - 1; i++) {\n        for (int j = i + 1; j < cands.size(); j++) {\n          delta = min(delta, cands[i].distance(cands[j]));\n        }\n      }\n      // 周辺を探索\n      ll iy = pos / w, ix = pos % w;\n      for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n        for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n          if (i == iy && j == ix) continue;\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p1 : cands) {\n            for (const auto& p2 : grid[i * w + j]) {\n              delta = min(delta, p1.distance(p2));\n            }\n          }\n        }\n      }\n    }\n    return delta;\n  }\n\n  /* closest pair: 分割統治法 */\n  double closest_pair_impl(std::vector<Point>& ps, int l, int r) {\n    static const auto cmp_y = [](const Point& a, const Point& b) { return a.y < b.y; };\n    int n = r - l, m = (l + r) >> 1;\n    if (n <= 1) return DBL_MAX;\n    double x = ps[m].x;\n    double d = min(closest_pair_impl(ps, l, m), closest_pair_impl(ps, m, r));\n    std::inplace_merge(ps.begin() + l, ps.begin() + m, ps.begin() + r, cmp_y);\n    std::vector<Point> b;\n    for (int i = 0; i < n; i++) {\n      if (abs(ps[i + l].x - x) >= d) continue;\n      for (int j = (int)b.size() - 1; j >= 0; j--) {\n        double dx = ps[i + l].x - b[j].x, dy = ps[i + l].y - b[j].y;\n        if (dy >= d) break;\n        d = min(d, sqrt(dx * dx + dy * dy));\n      }\n      b.push_back(ps[i + l]);\n    }\n    return d;\n  }\n  double closest_pair(std::vector<Point> ps) {\n    std::sort(ps.begin(), ps.end());\n    return closest_pair_impl(ps, 0, (int)ps.size());\n  }\n\n  /* circle */\n  struct Circle {\n    double x, y, r;\n    Circle() {}\n    Circle(double x, double y, double r) : x(x), y(y), r(r) {}\n    friend std::ostream& operator<<(std::ostream& o, const Circle& c) {\n      o << '(' << c.x << ',' << c.y << ',' << c.r << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Circle& c) {\n      i >> c.x >> c.y >> c.r;\n      return i;\n    }\n    int tangent_lines(const Circle& c) const {\n      double d = center().distance(c.center());\n      if (abs(r + c.r - d) < eps) return 3;\n      if (abs(abs(r - c.r) - d) < eps) return 1;\n      if (r + c.r < d) return 4;\n      if (d < abs(r - c.r)) return 0;\n      return 2;\n    }\n    Point center() const { return Point(x, y); }\n    bool is_intersect(const Line& l) const { return l.distance(center()) < r; }\n    std::pair<Point, Point> intersection(const Line& l) const {\n      Point P = l.projection(center());\n      double d = P.distance(center());\n      double h = sqrt(max(0.0, r * r - d * d));\n      Vector e = l.to_vector().unit();\n      Point Q = P + e * h, R = P - e * h;\n      if (Q > R) std::swap(Q, R);\n      return std::make_pair(Q, R);\n    }\n  };\n  Circle inscribed_circle(const Point& A, const Point& B, const Point& C) {\n    Vector AB(B - A), BC(C - B), CA(A - C);\n    Vector u = (B - A).unit() + (C - A).unit();\n    Vector v = (B - A).unit() + (B - C).unit();\n    Vector w = B - A;\n    double c = cross_product(u, v);\n    double s = (v.y * w.x - v.x * w.y) / c;\n    double t = (u.x * w.y - u.y * w.x) / c;\n    Point O = A + s * u;\n    double S = abs(cross_product(AB, -CA) * 0.5);\n    double r = 2.0 * S / (AB.length() + BC.length() + CA.length());\n    return Circle(O.x, O.y, r);\n  }\n  Circle circumscribed_circle(const Point& A, const Point& B, const Point& C) {\n    Point P = (A + B) * 0.5, Q = (B + C) * 0.5;\n    Point O = Line(P, P + (B - A).normal()).intersection(Line(Q, Q + (C - B).normal()));\n    return Circle(O.x, O.y, O.distance(A));\n  }\n}\n\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  using namespace geom;\n\n  Circle C;\n  cin >> C;\n  int q;\n  cin >> q;\n\n  cout << fixed << setprecision(15);\n\n  rep(_, q) {\n    Line l;\n    cin >> l;\n    auto isc = C.intersection(l);\n    cout << isc.first.x << ' ' << isc.first.y << ' ' << isc.second.x << ' ' << isc.second.y << '\\n';\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \")\";\n\treturn os;\n}\n\ndouble dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }\ndouble atan(Point p) { return atan2(p.y, p.x); }\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\ndouble distancePP(Point p, Point o) { return sqrt(norm(o - p)); }\n\nint ccw(Point a, Point b, Point c) {\n\tb = b-a;\n\tc = c-a;\n\n\tif(cross(b, c) > 0.0) return +1;\t//conter clockwise\n\tif(cross(b, c) < 0.0) return -1;\t//clockwise\n\tif(dot(b, c) < 0.0) return +2;\t//a on Seg(b,c)\n\tif(norm(b) < norm(c)) return -2;\t//b on Seg(a,c)\n\treturn 0;\t//c on Seg(a,b)\n}\n\nstruct Line {\n\tPoint a, b;\n\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nostream& operator << (ostream& os, const Line& l) {\n\tos << \"(\" << l.a.x << \", \" << l.a.y << \")-(\" << l.b.x << \",\" << l.b.y << \")\";\n\treturn os;\n}\n\nstruct Seg {\n\tPoint a,b;\n\n\tSeg() : a(Point(0, 0)), b(Point(0, 0)) {}\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n};\n\nostream& operator << (ostream& os, const Seg& s) {\n\tos << \"(\" << s.a.x << \", \" << s.a.y << \")-(\" << s.b.x << \",\" << s.b.y << \")\";\n\treturn os;\n}\n\nbool isOrthogonal(Line l1, Line l2) { return equals(dot((l1.b - l1.a), (l2.b - l2.a)), 0.0); }\n\nbool isParallel(Line l1, Line l2) { return equals(cross((l1.b - l1.a), (l2.b - l2.a)), 0.0); }\n\nbool sameLine(Line l1, Line l2) { return abs(cross(l1.b - l1.a, l2.b - l1.a)) < EPS; }\n\nbool isIntersectLL(Line l1, Line l2) { return !isParallel(l1, l2) || sameLine(l1, l2); }\n\nbool isIntersectLS(Line l, Seg s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < 0;\n}\n\nbool isIntersectSS(Seg s1, Seg s2) { \n\treturn ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 \n\t\t&& ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\ndouble distanceLP(Line l, Point p) {\n\treturn abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);\n}\n\ndouble distanceLS(Line l, Seg s) {\n\tif (isIntersectLS(l, s)) return 0.0;\n\treturn min(distanceLP(l, s.a), distanceLP(l, s.b));\n}\n\ndouble distanceSP(Seg s, Point p) {\n\tif (dot(s.b - s.a, p - s.a) < 0.0) return abs(p - s.a);\n\tif (dot(s.a - s.b, p - s.b) < 0.0) return abs(p - s.b);\n\treturn distanceLP(Line(s.a, s.b) , p);\n}\n\ndouble distanceSS(Seg s1, Seg s2) {\n\tif (isIntersectSS(s1, s2)) return 0.0;\n\treturn min( min(distanceSP(s1, s2.a), distanceSP(s1, s2.b)), min(distanceSP(s2, s1.a), distanceSP(s2, s1.b)) );\n}\n\n// if isIntersectLL(l1, l2)\nPoint crossPointLL(Line l1, Line l2) {\n\tPoint base = l2.b - l2.a;\n\tdouble d = abs(cross(base, l1.a - l2.a));\n\tdouble d2 = abs(cross(base, l1.b - l2.a));\n\tdouble t = d / (d + d2);\n\treturn l1.a + (l1.b - l1.a) * t;\n}\n\n// if isIntersectLS(l, s)\nPoint crossPointLS(Line l, Seg s) { return crossPointLL(l, Line(s.a, s.b)); }\n\n// if isIntersectSS(s1, s2)\nPoint crossPointSS(Seg s1, Seg s2) { return crossPointLL(Line(s1.a, s1.b), Line(s2.a, s2.b)); }\n\nPoint project(Line l, Point p) {\n\tPoint base = l.b - l.a;\n\tdouble t = dot(base, p-l.a) / dot(base, base);\n\treturn l.a + base * t;\n}\n\nPoint reflect(Line l, Point p) {\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\n\tCircle() : p(Point(0,0)), r(0) {}\n\n\tCircle(Point o, double r) : p(o), r(r) {}\n\n\tCircle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n};\n\nbool inCircle(Circle c, Point p) {\n\tPoint a = p - c.p;\n\treturn dot(a, a) <= c.r * c.r + EPS;\n}\n\nbool isIntersectCL(Circle c, Line l) {\n\treturn distanceLP(l, c.p) <= c.r + EPS;\n}\n\n// 1:?????§??\\?????????0:???????????????-1:?????§??\\?????????2:?????????-2:??????\nint isIntersectCC(Circle c1, Circle c2) {\n\tdouble d = dot(c2.p - c1.p, c2.p - c1.p);\n\tdouble len = (c1.r + c2.r) * (c1.r + c2.r);\n\n\tif(equals(d, len)) return 1;\n\tif(d > len) return 0;\n\n\tdouble R = fabs(c2.r - c1.r) * fabs(c2.r - c1.r);\n\tif(equals(d, R)) return -1;\n\tif(d > R) return 2;\n\treturn -2;\n}\n\n// isIntersectCL\nvector<Point> crossPointCL(Circle c, Line l) {\n\tPoint p = project(l, c.p);\n\tPoint base = (l.b - l.a) / abs(l.b - l.a);\n\tdouble t = sqrt(c.r * c.r - norm(p - c.p) );\n\tvector<Point> ret(2);\n\tret[0] = p + base * t;\n\tret[1] = p - base * t;\n\treturn ret;\n}\n\nvector<Point> crossPointCC(Circle c1, Circle c2) {\n\tvector<Point> ret;\n\tint ch = isIntersectCC(c1, c2);\n\n\tif(ch == 0 || ch == -2) return ret;\n\n\tPoint base = c2.p - c1.p;\n\tdouble len = dot(base, base);\n\tdouble t = (c1.r*c1.r - c2.r*c2.r + len) / (2.0 * len);\n\n\tif(ch == 2) {\n\t\tPoint n(-base.y, base.x);\n\t\tn = n / (abs(n));\n\t\tdouble h = sqrt(c1.r * c1.r - t * t * len);\n\n\t\tret.push_back(c1.p + (base*t) + (n*h));\n\t\tret.push_back(c1.p + (base*t) - (n*h));\n\t} else {\n\t\tret.push_back(c1.p + (base*t));\n\t}\n\n\treturn ret;\n}\n\nint main() {\n\tCircle c1;\n\tcin >> c1.p.x >> c1.p.y >> c1.r;\n\n\tint q;\n\tcin >> q;\n\n\tLine l;\n\trep(i, q) {\n\t\tcin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n\n\t\tvector<Point> ret = crossPointCL(c1, l);\n\t\tsort(ret.begin(), ret.end());\n\n\t\tcout << fixed;\n\t\tcout.precision(20);\n\t\tcout << ret[0].x << \" \" << ret[0].y << \" \" << ret[1].x << \" \" << ret[1].y << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tdouble cx = 0, cy = 0, r = 0;\n\tint q = 0;\n\tint x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n\n\tcin >> cx >> cy >> r >> q;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\tdouble a = 0, b = 0, s = 0, t = 0, u = 0,\n\t\t\tv1 = 0, v2 = 0, w1 = 0, w2 = 0;\n\n\t\tif (x1 == x2) {\n\t\t\tv1 = x1;\n\t\t\tv2 = x2;\n\t\t\tw1 = cy - sqrt(r * r - (x1 - cx) * (x1 - cx));\n\t\t\tw2 = cy + sqrt(r * r - (x1 - cx) * (x1 - cx));\n\t\t}\n\t\telse {\n\t\t\ta = (y2 - y1) / (x2 - x1);\n\t\t\tb = (x2 * y1 - x1 * y2) / (x2 - x1);\n\n\t\t\ts = a * a + 1;\n\t\t\tt = a * b - a * cy - cx;\n\t\t\tu = cx * cx + (b - cy) * (b - cy) - r * r;\n\n\t\t\tv1 = (-t - sqrt(t * t - s * u)) / s;\n\t\t\tv2 = (-t + sqrt(t * t - s * u)) / s;\n\t\t\tw1 = a * v1 + b;\n\t\t\tw2 = a * v2 + b;\n\t\t}\n\n\t\tcout << setiosflags(ios::fixed | ios::showpoint) << setprecision(8)\n\t\t\t << v1 << \" \" << w1 << \" \" << v2 << \" \" << w2 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\ntypedef Segment Line;                               //??´???\ntypedef struct Circle{Point c; double r;}Circle;    //???\ntypedef vector<Point> Polygon;                      //????§???¢\n//????????????a????????????\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n//????????????a?????§??????\ndouble absolute(Vector a){\n    return sqrt(norm(a));\n}\n\n//????????????a,b?????????\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n//????????????a,b?????????\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\n//????????????a??¨b?????´?????????\n//a??¨b?????´????????´??????????????????0?????????\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a,b), 0.0);\n}\n\n//????????????a??¨b???????????????\n//a??¨b?????´????????´??????????????????0?????????\nbool isParallel(Vector a , Vector b){\n    return equals(cross(a,b), 0.0);\n}\n\n//??????s(p1p2)???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\n//??????s(p1p2)???????§°?????¨?????????p???????±????\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\n//???a,???b???????????¢\ndouble getDistance(Point a, Point b){\n    return absolute(a - b);\n}\n\n//??´???s??¨???p????????¢\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / absolute(l.p2 - l.p1));\n}\n\n//??????s(p1p2)??¨???p????????¢d????±???????\n//??\\???????????????????????§??´?????????\n//??????????????????p2-p1??¨???????????????p-p1??????????§???????90???????????§????????´???????????????-90?????????????°?????????´?????????d??????p??¨???p1??¨????????¢\n//??????????????????p1-p2??¨???????????????p-p2??????????§???????90???????????§????????´???????????????-90?????????????°?????????´?????????d??????p??¨???p2??¨????????¢\n//??????????????\\???????????????????????´??????d??????p??¨??´???p1p2????????¢\ndouble getDistanceSP(Segment s, Point p){\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absolute(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absolute(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\n\n//??????p0, p1, p2???????????????????????????p0p1???????????????p2??????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//??????S1(p1p2)??¨??????s2(p2p3)????????????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return  ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n            &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p1);\n}\n\n//??????s1??¨??????s2????????¢\n//??\\????????????????????¢????????§????????????????????????\n//????????????s1??¨??????s2????§????s2.p1????????¢\n//????????????s1??¨??????s2?????????s2.p2????????¢\n//????????????s2??¨??????s1????§????s1.p1????????¢\n//????????????s2??¨??????s1?????????s1.p2????????¢\ndouble getDistance(Segment s1, Segment s2){\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(\n               min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n               );\n}\n\n//??????s1??¨??????s2?????????????±???????\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//?????¨??????l?????????????±???????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / absolute(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????????±???????\nVector polar(double a, double r){\n    //??????a,?§????r???point????±???????\n    return Point(cos(r) * a, sin(r) * a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    Vector v = c2.c - c1.c;\n    double d = absolute(v);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d) );\n    double t = atan2(v.y, v.x);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\n\n\nint main(){\n    \n    int cx, cy;\n    double r;\n    int q;\n    int x1, y1, x2, y2;\n    \n    cin >> cx >> cy >> r >> q;\n    \n    Circle c = {Point(cx, cy), r};\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        \n        Line l = {Point(x1, y1), Point(x2, y2)};\n        \n        pair<Point, Point> ans = getCrossPoints(c, l);\n        bool swap_flag = (ans.first.x == ans.second.x) ? ans.first.y > ans.second.y : (ans.first.x > ans.second.x);\n        if(swap_flag) swap(ans.first, ans.second);\n        \n        printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", ans.first.x, ans.first.y, ans.second.x, ans.second.y);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // ????????\\???\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // ????????????????????????\nld dot(Point a, Point b) { return real(conj(a) * b); } // ??????\nld cross(Point a, Point b) { return imag(conj(a) * b); } // ??????\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t // ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n/* ???????????? */\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// ????????´????????????\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// ?????????????????????\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* ?????¢ */\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tCircle c; c.p = input_point(); cin >> c.r;\n\tint q; cin >> q;\n\tfor (int i = 0; i < q;i++) {\n\t\tcout << fixed << setprecision(10);\n\t\tLine l(input_point(), input_point());\n\t\tauto ps = is_sc(c, l);\n\t\tsort(ps.begin(), ps.end());\n\t\tif ((int)ps.size() == 1) {\n\t\t\tcout << ps[0].real() << \" \" << ps[0].imag() << \" \" << ps[0].real() << \" \" << ps[0].imag() << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ps[0].real() << \" \" << ps[0].imag() << \" \" << ps[1].real() << \" \" << ps[1].imag() << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define eps (1e-10)\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point &p){return point(x+p.x,y+p.y);}\n    point operator - (point &p){return point(x-p.x,y-p.y);}\n    point operator * (double k){return point(x*k,y*k);}\n    point operator / (double k){return point(x/k,y/k);}\n\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n\n    bool operator < (const point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator == (const point &p){\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n//内积\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n//外积\ndouble cross(point a,point b){\n    return a.x*b.y-a.y*b.x;\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/base.norm();\n    base=base*r;\n    return a+base;\n}\n\npair<point,point>getcrosspoints(point xin,int r,point a,point b)\n{\n    point pr=project(a,b,xin);\n    point temp=b-a;\n    point e=temp/temp.abs();\n    double base=sqrt(r*r-(pr-xin).norm());\n    e=e*base;\n    return make_pair(pr-e,pr+e);\n}\n\nint main()\n{\n    point xin;\n    int r;\n    cin>>xin.x>>xin.y>>r;\n    int q;\n    cin>>q;\n    point a,b;\n    for(int i=0;i<q;i++){\n        cin>>a.x>>a.y>>b.x>>b.y;\n        pair<point,point>res=getcrosspoints(xin,r,a,b);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#include <random>\n#include <bitset>\n\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, double> pld;\ntypedef pair<double, double> pdd;\ntypedef pair<double, ll> pdl;\ntypedef pair<int, char> pic;\ntypedef vector<ll> vl;\ntypedef vector<int> vi;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> llgreaterq;\ntypedef priority_queue<pll, vector<pll>, greater<pll>> pllgreaterq;\ntypedef priority_queue<pair<ll, pll>, vector<pair<ll, pll>>, greater<pair<ll, pll>>> plpllgreaterq;\ntypedef priority_queue<vi, vector<vi>, greater<vi>> vigreaterq;\ntypedef priority_queue<vl, vector<vl>, greater<vl >> vlgreaterq;\n#define bit(x,v) ((ll)x << v)\n#define rep(x,v) for(ll x=0;x<v;x++)\n#define rep2(x,f,v) for(ll x=f;x<v;x++)\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (std::abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define all(a) a.begin(),a.end()\n#define all0(a) memset(a,0,sizeof(a))\nconst ll INF = 1000000007;\nconst int MAX = 2000010;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[200010];\nint lank[200010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nint same(int x, int y) {\n\treturn parent(x) == parent(y);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (lank[px] < lank[py]) {\n\t\tpr[py] = px;\n\t\tlank[px] += lank[py] + 1;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t\tlank[py] += lank[px] + 1;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll* a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int, char>* a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF, ' ');\n\tR[n2] = make_pair(INF, ' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char>* a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll* a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int, char>* a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char>* a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\n\nll n;\nint ci = 0;\nll P[1000010];\nstruct Node {\n\tint key;\n\tint priority;\n\tNode* parent, * left, * right;\n\tNode(int key, int priority);\n\tNode() {}\n};\nNode NIL;\nNode::Node(int key, int priority) : key(key), priority(priority) {\n\tleft = &NIL;\n\tright = &NIL;\n}\nNode* root = new Node();\nvoid cenrec(Node* k) {\n\tif (k->key == NIL.key) return;\n\tcenrec(k->left);\n\tcout << \" \" << k->key;\n\tcenrec(k->right);\n}\nvoid fastrec(Node* k)\n{\n\tif (k->key == NIL.key) return;\n\tcout << \" \" << k->key;\n\tfastrec(k->left);\n\tfastrec(k->right);\n}\nvoid insert(Node* v) {\n\tNode* y = &NIL;\n\tNode* x = root;\n\twhile (x->key != NIL.key)\n\t{\n\t\ty = x;\n\t\tif (v->key < x->key) {\n\t\t\tx = x->left;\n\t\t}\n\t\telse {\n\t\t\tx = x->right;\n\t\t}\n\t}\n\tv->parent = y;\n\tif (y->key == NIL.key) {\n\t\troot = v;\n\t}\n\telse if (v->key < y->key) {\n\t\ty->left = v;\n\t}\n\telse {\n\t\ty->right = v;\n\t}\n\n}\n\nNode* find(Node* k, ll v)\n{\n\tif (k->key == NIL.key) return &NIL;\n\tif (k->key == v) return k;\n\tif (v < k->key) return find(k->left, v);\n\treturn find(k->right, v);\n}\nvoid delp12(Node* x) {\n\tif (x->key == NIL.key)  return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key == NIL.key\n\t\t&& r->key == NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = &NIL;\n\t\t}\n\t\telse pr->right = &NIL;\n\t}\n\telse if (l->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = l;\n\t\t}\n\t\telse pr->right = l;\n\t\tl->parent = pr;\n\t}\n\telse if (r->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = r;\n\t\t}\n\t\telse pr->right = r;\n\t\tr->parent = pr;\n\t}\n}\nNode* get_next(Node* k) {\n\tif (k->key == NIL.key) return &NIL;\n\tNode* res = get_next(k->left);\n\tif (res->key != NIL.key) return res;\n\treturn k;\n}\nvoid del(Node* x) {\n\n\tif (x->key == NIL.key) return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key != NIL.key && r->key != NIL.key) {\n\t\tNode* nex = get_next(r);\n\t\tx->key = nex->key;\n\t\tdelp12(nex);\n\t}\n\telse {\n\t\tdelp12(x);\n\t}\n}\nNode* rightRotate(Node* t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\nNode* leftRotate(Node* t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\nNode* _insert(Node* t, int key, int priority) {\n\tif (t->key == NIL.key) {\n\t\treturn new Node(key, priority);\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = _insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = _insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\nNode* delete1(Node* t, int key);\nNode* _delete(Node* t, int key) {\n\tif (t->left->key == NIL.key && t->right->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\telse if (t->left->key == NIL.key) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right->key == NIL.key) {\n\t\tt = rightRotate(t);\n\t}\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete1(t, key);\n}\nNode* delete1(Node* t, int key) {\n\tif (t->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\tif (key < t->key) {\n\t\tt->left = delete1(t->left, key);\n\t}\n\telse if (key > t->key) {\n\t\tt->right = delete1(t->right, key);\n\t}\n\telse return _delete(t, key);\n\treturn t;\n}\nint H;\nint left(int i) {\n\treturn i * 2 + 1;\n}\nint right(int i) {\n\treturn i * 2 + 2;\n}\n\n\nll heap[2000010];\nvoid maxHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint largest = 0;\n\tif (l < H && heap[l] > heap[i])\n\t\tlargest = l;\n\telse\n\t\tlargest = i;\n\tif (r < H && heap[r] > heap[largest])\n\t\tlargest = r;\n\n\tif (largest != i) {\n\t\tswap(heap[i], heap[largest]);\n\t\tmaxHeapify(largest);\n\t}\n}\nint pare(int i) {\n\treturn (i - 1) / 2;\n}\nvoid raise(int i) {\n\tint l = pare(i);\n\tif (l < 0) return;\n\n\tif (heap[l] < heap[i]) {\n\t\tswap(heap[i], heap[l]);\n\t\traise(l);\n\t}\n}\nvoid minHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint minimam = 0;\n\tif (l < H && heap[l] < heap[i])\n\t\tminimam = l;\n\telse\n\t\tminimam = i;\n\tif (r < H && heap[r] < heap[minimam])\n\t\tminimam = r;\n\n\tif (minimam != i) {\n\t\tswap(heap[i], heap[minimam]);\n\t\tminHeapify(minimam);\n\t}\n}\nvoid buildMaxHeap() {\n\tfor (int i = H / 2; i >= 0; i--)\n\t{\n\t\tmaxHeapify(i);\n\t}\n}\n\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,-1,0,1 };\nstd::vector<int> find_all(const std::string str, const std::string subStr) {\n\tstd::vector<int> result;\n\n\tint subStrSize = subStr.size();\n\tint pos = str.find(subStr);\n\n\twhile (pos != std::string::npos) {\n\t\tresult.push_back(pos);\n\t\tpos = str.find(subStr, pos + 1);\n\t}\n\n\treturn result;\n}\n//ll memo[100010];\n//ll next[100010];\n//ll dm[100010];\n//int f[100010];\n//ll rec(int x) {\n//\n//\tif (~memo[x]) return memo[x];\n//\tif (x == n) { \n//\t\tdm[n] = 1;\n//\t\treturn 1; \n//\t}\n//\tll *res = &memo[x];\n//\t*res = 0;\n//\tset<int> st;\n//\tst.insert(f[x]);\n//\tfor (int i = x + 1; i <= n; i++)\n//\t{\n//\t\tif (~memo[i]) {\n//\t\t\t*res += memo[i] + 1;\n//\t\t\t*res %= INF;\n//\t\t\tbreak;\n//\t\t}\n//\n//\t\t*res += rec(i);\n//\t\t*res %= INF;\n//\t\tif (st.find(f[i]) != st.end()) {break; }\n//\t\tst.insert(f[i]);\n//\t}\n//\n//\treturn *res;\n//}\n#define bit(x,v) ((ll)x << v)\n\nclass BIT {\n\n\tstatic const int MAX_N = 1000010;\npublic:\n\tBIT() { memset(bit, 0, sizeof(bit)); }\n\tint bit[MAX_N + 1], n;\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0)\n\t\t{\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n)\n\t\t{\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tvoid clear() {\n\t\tmemset(bit, 0, sizeof(bit));\n\t}\n\tint a[MAX_N];\n\tvoid bable_swap_count() {\n\t\tll ans = 0;\n\t\tfor (size_t j = 0; j < n; j++)\n\t\t{\n\t\t\tans += j - sum(a[j]);\n\t\t\tadd(a[j], 1);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\tint search(int s, int x) {\n\n\t\tll half = (s + x) / 2;\n\t\tll sh = sum(x);\n\n\t\tll sl = sum(half);\n\n\t\tll st = sum(s);\n\t\tif (sh - sl == 0) {\n\t\t\treturn x;\n\t\t}\n\t\tif (sh - sl < x - half) {\n\t\t\treturn search(half, x);\n\t\t}\n\n\t\tif (sl - st == 0) {\n\t\t\treturn half;\n\t\t}\n\n\t\tif (sl - st < half - s) {\n\t\t\treturn search(s, half);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lankSearch(int lank) {\n\t\treturn lankSearch(lank, 0, MAX_N);\n\t}\n\tint lankSearch(int lank, int s, int t) {\n\n\t\tll half = (s + t) / 2;\n\n\t\tll v = sum(half);\n\t\tll v1 = sum(t);\n\t\tll v2 = sum(s);\n\t\tif (lank == 1) {\n\t\t\tif (s + 1 >= t) return t;\n\t\t\telse if (v - v2 > 0) {\n\t\t\t\treturn lankSearch(lank, s, half);\n\t\t\t}\n\t\t\telse return lankSearch(lank, half, t);\n\t\t}\n\n\t\tif ((v - v2) < lank) {\n\t\t\treturn lankSearch(lank - (v - v2), half, t);\n\t\t}\n\t\tif ((v - v2) >= lank) {\n\t\t\treturn lankSearch(lank, s, half);\n\t\t}\n\n\t\treturn -1;\n\t}\n};\n\nclass BIT2 {\n\n\tstatic const int MAX_N = 1000010;\npublic:\n\tBIT2() { memset(bit, 0, sizeof(bit)); }\n\tll bit[MAX_N + 1], n;\n\tll gmax(int i) {\n\t\tll s = 0;\n\t\twhile (i > 0)\n\t\t{\n\t\t\ts = max(bit[i], s);\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, ll x) {\n\t\twhile (i <= n)\n\t\t{\n\t\t\tbit[i] = max(bit[i], x);\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tvoid clear() {\n\t\tmemset(bit, 0, sizeof(bit));\n\t}\n\n};\nvector<ll> getp(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tif (n % 2 == 0) {\n\t\tres.push_back(2);\n\t\twhile (n % 2 == 0)n /= 2;\n\t}\n\n\tfor (ll i = 3; i * i <= n; i += 2)\n\t{\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\twhile (n % i == 0)n /= i;\n\t\t}\n\t}\n\tif (n != 1) res.push_back(n);\n\treturn res;\n}\nvector<ll> getp2(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tif (n % 2 == 0) {\n\n\t\twhile (n % 2 == 0) { n /= 2; res.push_back(2); }\n\t}\n\n\tfor (ll i = 3; i * i <= n; i += 2)\n\t{\n\t\tif (n % i == 0) {\n\n\t\t\twhile (n % i == 0) { n /= i; res.push_back(i); }\n\t\t}\n\t}\n\tif (n != 1) res.push_back(n);\n\treturn res;\n}\nvector<pll> getp3(ll n) {\n\n\tvector<pll> res;\n\tll a = 2;\n\tint cnt = 0;\n\tif (n % 2 == 0) {\n\t\tres.push_back(make_pair(2, 0));\n\t\twhile (n % 2 == 0) { n /= 2; res[cnt].second++; }\n\t\tcnt++;\n\t}\n\n\tfor (ll i = 3; i * i <= n; i += 2)\n\t{\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(make_pair(i, 0));\n\t\t\twhile (n % i == 0) { n /= i; res[cnt].second++; }\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif (n != 1) res.push_back(make_pair(n, 1));\n\treturn res;\n}\nvector<ll> getDivisors(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tres.push_back(1);\n\tfor (ll i = 2; i * i <= n; i++)\n\t{\n\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\tif (n / i != i)\n\t\t\t\tres.push_back(n / i);\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct ve {\npublic:\n\tvector<ve> child;\n\tint _t = INF;\n\tve(int t) :_t(t) {}\n\tve(ve _left, ve _right) {\n\t\t_t = _left._t + _right._t;\n\t\tchild.push_back(_left);\n\t\tchild.push_back(_right);\n\t}\n\tbool operator<(const ve& t) const {\n\t\treturn _t > t._t;\n\t}\n};\n\nvector<bool> elas(ll n) {\n\tvector<bool> r(n);\n\tfor (ll i = 3; i < n; i += 2)\n\t{\n\t\tr[i] = 1;\n\t}\n\tr[0] = 0;\n\tr[1] = 0;\n\tr[2] = 1;\n\tfor (ll i = 3; i * i < n; i += 2)\n\t{\n\t\tif (!r[i]) continue;\n\t\tll ti = i * 2;\n\t\twhile (ti < n)\n\t\t{\n\t\t\tr[ti] = false;\n\t\t\tti += i;\n\t\t}\n\t}\n\treturn r;\n}\nbool isprime(ll v) {\n\tfor (ll i = 2; i * i <= v; i++)\n\t{\n\t\tif (v % i == 0) return false;\n\t}\n\treturn true;\n}\n\nll lcm(vector<ll> v) {\n\tif (v.size() == 0) return 0;\n\tll t = v[0];\n\tfor (size_t i = 1; i < v.size(); i++)\n\t{\n\t\tt = v[i] * t / gcd(v[i], t);\n\t}\n\treturn t;\n}\nll eulerphi(ll n) {\n\tauto p = getp(n);\n\tdouble u = n;\n\tfor (auto v : p) {\n\t\tu *= (double)(v - 1) / (double)v;\n\t}\n\treturn u;\n}\n\ndouble revs(double x) {\n\tll dig = 0;\n\tstringstream st;\n\tst << std::fixed << setprecision(0) << x;\n\tstring v = st.str();\n\treverse(v.begin(), v.end());\n\treturn stod(v);\n}\nbool chkparindrome(double x) {\n\tstringstream st;\n\tst << std::fixed << setprecision(0) << x;\n\tstring p = st.str();\n\tfor (size_t i = 0; i < p.size() / 2; i++)\n\t{\n\t\tif (p[i] != p[p.size() - i - 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nll digitC(double x) {\n\tstringstream st;\n\tst << fixed << setprecision(0) << x;\n\treturn st.str().size();\n}\nll digitSum(double x) {\n\tstringstream st;\n\tst << std::fixed << x;\n\tstring p = st.str();\n\tll rs = 0;\n\tfor (size_t i = 0; i < p.size(); i++)\n\t{\n\t\tif (p[i] == '.') break;\n\t\trs += p[i] - '0';\n\t}\n\treturn rs;\n}\npdd recs(int x) {\n\n\tif (x == 0) return make_pair(1, 2);\n\tpdd d = recs(x - 1);\n\tauto nu = d.second * 2.0 + d.first;\n\tauto de = d.second;\n\treturn make_pair(de, nu);\n}\nll caldig(ll a) {\n\tll r = 0;\n\twhile (a > 0) { a /= 10; r++; }\n\treturn r;\n}\nint chav(char v) {\n\tif (v <= 'Z') return v - 'A';\n\treturn v - 'a' + 26;\n}\nchar itoch(int i) {\n\tif (i < 26) return i + 'A';\n\treturn (i - 26) + 'a';\n}\nint crmp[1000][1000];\nint countR(ll base, ll x, ll y, int deep) {\n\n\tif (~crmp[x][y]) {\n\t\treturn deep - crmp[x][y];\n\t}\n\tcrmp[x][y] = deep;\n\tdouble nu = sqrt(base) + x;\n\tdouble de = (base - (x * x)) / y;\n\tll u = nu / de;\n\tll nx = x - (u * de);\n\treturn countR(base, -nx, de, deep + 1);\n}\n\nbool isPermutation(ll x, ll y) {\n\tint c1[10];\n\tint c2[10];\n\tmemset(c1, 0, sizeof(c1));\n\tmemset(c2, 0, sizeof(c2));\n\twhile (x > 0)\n\t{\n\t\tc1[x % 10]++;\n\t\tx /= 10;\n\t}\n\twhile (y > 0)\n\t{\n\t\tc2[y % 10]++;\n\t\ty /= 10;\n\t}\n\n\tfor (size_t i = 0; i < 10; i++)\n\t{\n\t\tif (c1[i] != c2[i]) return false;\n\t}\n\treturn true;\n}\n\ndouble heron(ll a, ll b, ll c) {\n\tdouble s = (double)(a + b + c) / 2.0;\n\treturn sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\ndouble calcThreePS(double x1, double y1, double x2, double y2, double x3, double y3) {\n\treturn abs((x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1) / 2.0);\n}\ntypedef vector<vl> mat;\nclass Matrix1 {\n\npublic:\n\tstatic const int M = INF;\n\tint n;\n\tmat mul(mat& A, mat& B) {\n\t\tmat C(A.size(), vl(B[0].size()));\n\t\tfor (size_t i = 0; i < A.size(); i++)\n\t\t{\n\t\t\tfor (size_t k = 0; k < B.size(); k++)\n\t\t\t{\n\t\t\t\tfor (size_t j = 0; j < B[0].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tC[i][j] = (C[i][j] + A[i][k] * B[k][j]) % M;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn C;\n\t}\n\n\tmat pow(mat A, ll n) {\n\t\tmat B(A.size(), vl(A.size()));\n\t\tfor (size_t i = 0; i < A.size(); i++)\n\t\t{\n\t\t\tB[i][i] = 1;\n\t\t}\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) B = mul(B, A);\n\t\t\tA = mul(A, A);\n\t\t\tn >>= 1;\n\t\t}\n\n\n\t\treturn B;\n\t}\n\n};\nll m;\nll stringDivRm(string s, ll k) {\n\n\tll v = 0;\n\t\n\tfor (size_t i = 0; i < s.size(); i++)\n\t{\n\t\tv *= 10;\n\t\tv += s[i] - '0';\n\t\tv %= k;\n\t}\n\treturn v;\n}\n\nll repPow(ll b, ll x,ll md) {\n\tll res = 1;\n\tll v = b;\n\n\twhile (x > 0)\n\t{\n\t\tif (x & 1) {\n\t\t\tres *= v;\n\t\t\tres %= md;\n\t\t}\n\t\tv *= v;\n\t\tv %= md;\n\t\tx >>= 1;\n\t}\n\n\treturn res;\n}\nll repPow(ll b, ll x) {\n\treturn repPow(b, x, INF);\n}\nll uar[1000010];\nll upr(ll u, ll r) {\n\treturn (fac[u] * finv[u-r]) % INF;\n}\nll partitionMemo[20010][110];\nll partitionNum(ll v, ll k) {\n\tif (k == 1) return 1;\n\tif (v <= 1) return 1;\n\tif (~partitionMemo[v][k]) return partitionMemo[v][k];\n\tll r = 0;\n\tif (v < k) {\n\t\tr = partitionNum(v,v);\n\t}\n\telse\n\t\tr = partitionNum(v, k - 1) + partitionNum(v - k, k);\n\tr %= INF;\n\n\treturn partitionMemo[v][k] = r;\n}\n\nclass SetTree1 {\n\npublic:\n\tstatic const int MAX_N = 100000;\n\tstatic const int MAX_Q = 100000;\n\tint N, Q;\n\tstatic const int DAT_SIZE = (1 << 18) - 1;\n\tint A[MAX_N];\n\tchar T[MAX_Q];\n\n\tll data[DAT_SIZE];\n\tvoid init(int _n) {\n\t\tmemset(data, 0, sizeof(data));\n\t\tint p = 1;\n\t\twhile (p < _n)\n\t\t{\n\t\t\tp <<= 1;\n\t\t}\n\t\tN = p;\n\t\tQ = N - 1;\n\t}\n\tvoid update(int a, int b) {\n\n\t\tfor (size_t i = a; i <= b; i++)\n\t\t{\n\t\t\tupdate(Q + i);\n\t\t}\n\t}\n\tvoid update(int a) {\n\n\t\tint x = data[a];\n\t\twhile (a > 0)\n\t\t{\n\t\t\tif (a % 2 == 0)a--;\n\t\t\ta >>= 1;\n\t\t\tdata[a] += x;\n\t\t}\n\t}\n\tvoid add(int a, int b, int x) {\n\t\tadd(a, b + 1, x, 0,0,N);\n\t}\n\tvoid add(int a, int b, int x, int k, int l, int r) {\n\t\tif (a <= l && r <= b) {\n\t\t\tdata[k] += x;\n\t\t}\n\t\telse if (l < b && a < r) {\n\t\t\tdata[k] += (min(b, r) - max(a, l)) * x;\n\t\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\t}\n\t}\n\tll sum(int a, int b) {\n\t\treturn sum(a, b + 1, 0, 0, N);\n\t}\n\tll sum(int a, int b, int k, int l, int r) {\n\t\tif (b <= l || r <= a) return 0;\n\t\telse if (a <= l && r <= b) {\n\t\t\treturn data[k];\n\t\t}\n\t\telse {\n\t\t\tll res = 0;\n\t\t\tres += sum(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tres += sum(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n};\nclass Segment;\nclass Circle;\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point& p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\tstatic double dot(Point a, Point b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\tstatic double cross(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\tstatic bool isOrthogonal(Point a, Point b) {\n\t\treturn EQ(dot(a, b), 0.0);\n\t}\n\tstatic bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isOrthogonal(a1 - a2, b1 - b2);\n\t}\n\tstatic bool isOrthogonal(Segment s1, Segment s2);\n\n\tstatic bool isPalallel(Point a, Point b) {\n\t\treturn EQ(cross(a, b), 0.0);\n\t}\n\tstatic bool isPalallel(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isPalallel(a1 - a2, b1 - b2);\n\t}\n\tstatic bool isPalallel(Segment s1, Segment s2);\n\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\tstatic const int CLOCKWISE = -1;\n\tstatic const int ONLINE_BACK = 2;\n\tstatic const int ONLINE_FRONT = -2;\n\tstatic const int ON_SEGMENT = 0;\n\tstatic int ccw(Point p0, Point p1, Point p2) {\n\t\tPoint a = p1 - p0;\n\t\tPoint b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\n\tstatic bool intersect(Point p1, Point p2, Point p3, Point p4) {\n\t\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n\t\t\t&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n\t}\n\tstatic bool intersect(Segment s1, Segment s2);\n\tstatic Point project(Segment s, Point p);\n\n\tstatic Point reflect(Segment s, Point p);\n\n\tstatic Point getDistance(Point a, Point b) {\n\t\treturn (a - b).abs();\n\t}\n\n\tstatic double getDistanceLP(Segment s, Point p);\n\n\tstatic double getDistanceSP(Segment s, Point p);\n\n\tstatic double getDistance(Segment s1, Segment s2);\n\n\tstatic Point getIntersection(Segment s1, Segment s2);\n\n\tstatic pair<Point, Point> crossPoints(Circle c, Segment s);\n\n\tstatic int contains(vector<Point> g, Point p) {\n\t\tint n = g.size();\n\t\tbool x = false;\n\t\trep(i, n) {\n\t\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\t\t// 線の上に載っているか\n\t\t\tif (std::abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\n\t\t\t// pを基準として上下にあるか\n\t\t\t// または外積が正か?(→にあるか)\n\t\t\tif (a.y > b.y) swap(a, b);\n\t\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t\t}\n\t\treturn x ? 2 : 0;\n\t}\n\n\tstatic vector<Point> andrewScan(vector<Point> s) {\n\t\tvector<Point> u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(all(s));\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\n\t\tfor (int i = 2; i < s.size(); i++) {\n\n\t\t\tfor (int _n = u.size(); _n >= 2 && ccw(u[_n - 2], u[_n - 1], s[i]) > CLOCKWISE; _n--) {\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\n\t\tfor (int i = s.size() - 3; i >= 0; i--) {\n\n\t\t\tfor (int _n = l.size(); _n >= 2 && ccw(l[_n - 2], l[_n - 1], s[i]) > CLOCKWISE; _n--) {\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\n\t\treverse(all(l));\n\t\tfor (int i = u.size() - 2; i >= 1; i--)\n\t\t{\n\t\t\tl.push_back(u[i]);\n\t\t}\n\n\t\treturn l;\n\t}\n\n\tstatic double getArea(vector<Point> g) {\n\t\tdouble res = 0;\n\t\trep(i, n) {\n\t\t\tint ne = (i + 1) % n;\n\t\t\tres += cross(g[i], g[ne]);\n\t\t}\n\t\treturn res / 2.0;\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n\tPoint p1tp2() { return p2 - p1; }\n\tPoint p2tp1() { return p1 - p2; }\n\tdouble norm() {\n\t\treturn (p2 - p1).norm();\n\t}\n\tvoid getCin() {\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t}\n};\n\nbool Point::isOrthogonal(Segment s1, Segment s2) {\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool Point::isPalallel(Segment s1, Segment s2) {\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool Point::intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint Point::project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tdouble r = Point::dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint Point::reflect(Segment s, Point p) {\n\treturn (project(s, p) * 2) - p;\n}\ndouble Point::getDistanceLP(Segment s, Point p) {\n\treturn std::abs(cross(s.p2 - s.p1, p - s.p1) / (s.p2 - s.p1).abs());\n}\ndouble Point::getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble Point::getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({ getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)\n\t\t,getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2) });\n}\nPoint Point::getIntersection(Segment s1, Segment s2) {\n\t// (s1.p1 - s2.p1).norm()\n\tauto bs = s1.p2 - s1.p1;\n\tauto n1 = s2.p1 - s1.p1;\n\tauto n2 = s2.p2 - s1.p1;\n\tauto c1 = std::abs(cross(n1, bs)) / bs.norm();\n\tauto c2 = std::abs(cross(n2, bs)) / bs.norm();\n\treturn s2.p1 + (s2.p2 - s2.p1) * (c1 / (c1 + c2));\n\t// c1:c2=t:1-t\n\t// c2t=(1-t)c1\n\t// t/(1-t)=c1/(c1+c2)\n\t// \n}\n\n\ndouble arg(Point p) { return atan2(p.y, p.x); }\nPoint polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n\tstatic pair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\t\tdouble d = (c1.c - c2.c).abs(); // 中心点どうしの距離\n\t\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\t\tdouble t = arg(c2.c - c1.c);\n\t\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n\n\t}\n\tvoid getCin() {\n\t\tcin >> c.x >> c.y >> r;\n\t}\n};\n\npair<Point, Point> Point::crossPoints(Circle c, Segment s) {\n\tauto pp = project(s, c.c);\n\tauto f = (pp - c.c).norm();\n\tauto mu = sqrt(c.r * c.r - f);\n\tauto e = s.p1tp2() / s.p1tp2().abs();\n\treturn make_pair(pp + e * mu, pp - e * mu);\n\n}\n\nll count(vector<ll> v, ll x) {\n\tll res = 0;\n\tll si = v.size();\n\trep(i, v.size()) {\n\t\tll p = lower_bound(all(v), x / v[i] + (x % v[i] > 0 ? 1 : 0)) - v.begin();\n\t\tif (i < p) p--;\n\t\tres += max(p - i,0LL);\n\t}\n\treturn res;\n}\nvoid solv() {\n\tCircle c;\n\tc.getCin();\n\tcin >> n;\n\tcout << fixed << setprecision(10);\n\trep(i, n) {\n\t\tSegment s;\n\t\ts.getCin();\n\t\t// 円と直線の交点\n\t\t// 三角形を利用する\n\t\t// 円の中点と直線の写像を取る\n\t\t// 二つの交点がある場合、写像への距離は同じとなる\n\t\t// 距離を求める\n\t\t// 写像、交点、中点の関係は直角三角形となっている\n\t\t// 斜辺は半径rなので中点写像への距離xが分かれば\n\t\t// 求められる\n\t\t// ここで、単位ベクトルに長さを掛けるか\n\t\t// 直線のそれぞれの点から写像までの距離を求めて比率を掛ける方法がある\n\t\tauto p = Point::crossPoints(c, s);\n\t\tauto p1 = p.first;\n\t\tauto p2 = p.second;\n\t\tif (p1.x > p2.x || (p1.x == p2.x && p1.y > p2.y))swap(p1, p2);\n\t\tcout << p1.x << \" \" << p1.y << \" \" << p2.x << \" \" << p2.y << endl;;\n\t}\n}\nint main() {\n\t//COMinit();\n\tsolv();\n\treturn 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??´???\n  L(){};\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const P &p,const P &q){\n  return abs(p - q) ;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\npair<P,P> crosspointCircle(const C &a,const C &b){\n  P m = (a.p+b.p)/2.0;\n  P vv = verticalvector(a.p,b.p);\n  double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n  P A = m + u * vv,B = m - u * vv;\n  return mp(A,B);\n}\n// a < b : -1, a > b : 1, a == b : 0\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\nint circle_judge(const C &a,const C &b){ // return tangent count\n  double d = distancePP(a.p,b.p);\n  double e = a.r,f = b.r;\n  if(sgn(d,e+f) == 1) return 4;\n  if(sgn(d,e+f) == 0) return 3;\n  if(sgn(d,abs(e-f)) == -1) return 0;\n  if(sgn(d,abs(e-f)) == 0 ) return 1;\n  return 2;\n}\n\npair<P,P> crosspointCircleLine(const C &a,const L &l){\n  double d = distanceLP(l,a.p);\n  double v = sqrt(a.r * a.r - d * d);\n  P p = a.p + d * verticalvector(l[0],l[1]);\n  P q = l[0] - l[1];\n  P e = p + v * q / abs(q),f = p - v * q/abs(q);\n  if(e < f){\n    return mp(e,f);\n  }\n  return mp(f,e);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  double x,y,r;\n  cin >> x >> y >> r;\n  C c1(P(x,y),r); \n  ll q;\n  cin >> q;\n  rep(i,q){\n    cin >> x >> y;\n    P a(x,y); \n    cin >> x >> y;\n    P b(x,y); \n    L l(a,b);\n    auto res = crosspointCircleLine(c1,l);\n    fcout(10) << real(res.fi) << ' ' << imag(res.fi) << ' ' << real(res.se) << ' ' << imag(res.se) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-8; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=polar(R(1.0),arg(l.t-l.s))*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}\n\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//By Vlgd\n#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nusing namespace std;\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y){}\n\tPoint operator + (Point p){return Point(x+p.x,y+p.y);}\n\tPoint operator - (Point p){return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){return Point(a*x,a*y);}\n\tPoint operator / (double a){return Point(x/a,y/a);}\n\tdouble abs() {return sqrt(norm());}\n\tdouble norm() {return x*x+y*y;}\n\tbool operator < (const Point &p) const{\n\t\treturn x!=p.x?x<p.x:y<p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment {Point p1,p2;};\ntypedef Segment Line;\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c=Point(),double r=0.0): c(c),r(r){}\n};\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint project(Segment s,Point p){\n\tVector base=s.p2-s.p1,a=p-s.p1;\n\tdouble r=dot(base,a)/base.norm();\n\treturn s.p1+base*r;\n\t\n}\npair<Point,Point> CP(Circle c,Line l){\n\tPoint x=project(l,c.c);\n\tVector pr=x-c.c,base=l.p2-l.p1;\n\tVector e=(l.p1-l.p2)/base.abs();\n\tdouble d=sqrt(c.r*c.r - pr.norm());\n\treturn make_pair(x+e*d, x-e*d);\n}\nmain(){\n\tint cx,cy,r;\n\tscanf(\"%d%d%d\",&cx,&cy,&r);\n\tPoint p(cx,cy);\n\tCircle c(p,r);\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint x1,x2,y1,y2;\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tLine l;\n\t\tl.p1=Point(x1,y1),l.p2=Point(x2,y2);\n\t\tpair<Point,Point>ans=CP(c,l);\n\t\tPoint a=ans.first;\n\t\tPoint b=ans.second;\n\t\tif(b<a) swap(a,b);\n\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",a.x,a.y,b.x,b.y);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n#define all(c) (c).begin(),(c).end()\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  bool operator < (Point p)const{return (p.x!=x)?x<p.x:y<p.y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  //点pを中心に角度r(radius)だけ半時計回りに回転する\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n\n//a -> b -> c\nint ccw(Point a, Point b, Point c) {\n  b = b-a; c = c-a;\n\n  if (b.cross(c) > 0)   return +1;       // counter clockwise\n  if (b.cross(c) < 0)   return -1;       // clockwise\n  if (b.dot(c) < 0)     return +2;       // c--a--b on line\n  if (b.norm() < c.norm()) return -2;    // a--b--c on line\n  return 0;                              // a--c--b on line\n}\n\nstruct Line{\n  Point a,b;\n\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n\n  bool on(Point c){return abs(ccw(a,b,c))!=1;}\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n\n  //射影\n  Point project(Point p){\n    Point base=b-a;\n    Real t=(p-a).dot(base)/base.dot(base);\n    return a+base*t;\n  }\n};\n\nstruct Circle{\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(Point p, Real r) : p(p) , r(r){}\n  \n  vector<Point> intersectionPoints(Line l){\n\n    if(sgn(l.dist(p),r)>0)return vector<Point>();\n\n    Point q=l.project(p);\n    Real t=(p-q).norm(),d=sqr(r*r-t*t);\n    Point base=l.a-l.b;\n    vector<Point>res;\n    res.push_back(q+base*(d/base.norm()));\n    res.push_back(q-base*(d/base.norm()));\n    return res;\n  }\n  \n};\n\nint main(void){\n\n  Circle c;\n  cin >> c.p.x >> c.p.y >> c.r;\n  int q;\n  cin >> q;\n  while(q--){\n    Line l;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n    vector<Point>res=c.intersectionPoints(l);\n    sort(all(res));\n    printf(\"%.8f %.8f \",res[0].x,res[0].y);\n    printf(\"%.8f %.8f \",res[1].x,res[1].y);\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\ndouble xmax, xmin, ymax, ymin;\nstruct vec{\n  double x, y;\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n  //double ppdist(vec p){ return sqrt( (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y) ); }\n  //double ppdist2(vec p){ return (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y); }\n};\nstruct line{\n  vec a, b;\n  vec getvec(){ return b - a; }\n  double size(){ return getvec().norm(); }\n  vec proj(vec p){ return a + (b - a).sca((p - a).dot(b - a) / (b - a).dot(b - a)); }\n  vec vref(vec p){ return proj(p).sca(2.0) - p; }\n  int ccw(vec p){\n    vec q = p - a, ba = b - a;\n    if(ba.cross(q) > 0)return 1; //ccw\n    if(ba.cross(q) < 0)return -1; //cw\n    if(ba.dot(q) < 0)return -2; //back\n    if(ba.dot(ba) < q.dot(q))return 2; //front\n    return 0; //on\n  }\n  bool paral(line l){ return abs(l.getvec().cross(getvec())) < eps; }\n  bool orth(line l){ return abs(l.getvec().dot(getvec())) < eps; }\n  bool intersec(line l){\n    bool res0 = (ccw(l.a) * ccw(l.b) == 4); //syukutai\n    bool res1 = (getvec().cross(l.a - a) * getvec().cross(l.b - a)) <= eps;\n    bool res2 = (l.getvec().cross(a - l.a) * l.getvec().cross(b - l.a)) <= eps;\n    return !res0 && res1 && res2;\n  }\n  vec crosspoint(line l){\n    return a + getvec().sca((l.a - a).cross(l.getvec()) / getvec().cross(l.getvec()));\n  }\n  double pldist(vec p){\n    double res = min((a - p).norm2(), (b - p).norm2());\n    vec h = proj(p);\n    if((a - h).dot(b - h) < 0)res = min(res, (h - p).norm2());\n    return sqrt(res);\n  }\n  double lldist(line l){\n    if(intersec(l))return 0.0;\n    return min(min(pldist(l.a), pldist(l.b)), min(l.pldist(a), l.pldist(b)));\n  }\n};\nstruct polygon{\n  vector<vec> p;  //ccw\n  double area(){\n    double res = 0.0;\n    for(int i = 0;i < p.size();++i)res += p[i].cross(p[(i + 1) % p.size()]);\n    return res / 2.0;\n  }\n  bool isconv(){\n    for(int i = 0;i < p.size();++i)\n    if((p[(i + 1) % p.size()] - p[i]).cross(p[(i + 2) % p.size()] - p[i]) < -eps)return false;\n    return true;\n  }\n  int isin(vec a){\n    line l = (line){a, a + (vec){xmax - xmin, 0.0}};\n    int cnt = 0, n = p.size();\n    for(int i = 0;i < n;++i){\n      line tmp = (line){p[i], p[(i + 1) % n]};\n      if(tmp.ccw(a) == 0)return 1; //on line\n      if(l.intersec(tmp)){\n        ++cnt;\n        if(l.ccw(p[i]) == 0 && l.ccw(p[(i + 1) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        if(l.paral(tmp)){\n          ++cnt;\n          if(l.ccw(p[(i + 2) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        }\n      }\n    }\n    return (cnt & 1) * 2;  //2:in 0:out\n  }\n};\n\nstruct circle{\n  vec o;\n  double r;\n  int intersec(circle c){\n    double d = (o - c.o).norm(), rp = r + c.r, rm = abs(r - c.r);\n    if(abs(rp - d) < eps)return 3;\n    if(rp < d + eps)return 4;\n    if(abs(rm - d) < eps)return 1;\n    if(rm < d + eps)return 2;\n    return 0;\n  }\n  pair<vec, vec> clpoint(line l){\n    pair<vec, vec> res;\n    vec h = l.proj(o);\n    double dist = (l.a - h).norm(), diff = sqrt(r * r - (o - h).norm2());\n    res.first = l.a + (l.b - l.a).sca((dist + diff) / l.size());\n    res.second = l.a + (l.b - l.a).sca((dist - diff) / l.size());\n    if(res.first.x > res.second.x ||\n      (abs(res.first.x - res.second.x) == 0.0 && res.first.y > res.second.y))\n        swap(res.first, res.second);\n    return res;\n  }\n};\n\nsigned main(void){\n  int i, j, k, q;\n  circle c;\n  cin >> c.o.x >> c.o.y >> c.r >> q;\n  for(;q--;){\n    line l;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n    pair<vec, vec> res = c.clpoint(l);\n    printf(\"%.15lf %.15lf %.15lf %.15lf\\n\", res.X.x, res.X.y, res.Y.x, res.Y.y);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n\n// Circle // verified: AOJ 1183 \nenum RCC{OUT=2,ON_OUT=1,ISC=0,ON_IN=-1,IN=-2};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\n\n// cross point between circle and line \n// verified: AOJ CGL_7_D\nP cir(C c,R t){return c.c+polar(c.r,t);}\nVP cross(C c, L l){\n\tP h=proj(l,c.c),e=polar(sq(norm(c.r)-norm(h-c.c)),arg(l.t-l.s));\n\treturn VP{h-e,h+e};\n}\n\nint main(void){\n\tint q;\n\tC c;\n\tcin >> c.c >> c.r;\n\t\t\n\tcin >> q;\n\tcout.precision(20);\n\trep(i,q){\n\t\tP a,b;\n\t\tcin >> a >> b;\n\t\tL l={a,b};\n\t\tVP res=cross(c,l);\n\t\tif(real(res[0])>real(res[1])) swap(res[0],res[1]);\n\t\tif(real(res[0])==real(res[1])&&imag(res[0])>imag(res[1])) swap(res[0],res[1]);\n\t\tcout << fixed << res[0] << \" \" << res[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define EPS 1e-10\nstatic const int COUNTER_CLOCKWISE = 1;\t\t\t\t\t//逆时针   \nstatic const int CLOCKWISE = -1;\t\t\t\t\t\t\t//顺时针\nstatic const int ONLINE_BACK = 2;\t\t\t\t\t\t//p2 在直线后面\nstatic const int ONLINE_FRONT = -2;\t\t\t\t\t\t//p2 在直线前面\nstatic const int ON_SEGMENT = 0;\t\t\t\t\t\t//p2 在直线上\nint equals(double a, double b) { return fabs(a - b) < EPS; };\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x=0, double y=0) :x(x), y(y) { };\n\tPoint operator + (Point& p) {\n\t\treturn Point(p.x + x, p.y + y);\n\t}\n\tPoint operator - (Point& p) {\n\t\t\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k*x, k*y);\n\t}\n\tdouble abs() {\t\t\t\t\t//向量长度;\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ntypedef Point Vector;\ndouble dot(Vector a, Vector b) {\t\t\t//内积 x1*x2 + y1*y2\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b) {\t\t  //外积  x1*y2 - x2*y1\n\treturn a.x * b.y - a.y * b.x;\n}\nstruct Segment           //线段\n{\n\tPoint a, b;\n};\ntypedef Segment Line;   //线段表示直线；\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double x = 0) :c(c), r(x) {};\n};\nvoid Parallel_Orthogonal() {\t\t\t\t//判断平行或正交\n\tPoint a, b,c,d;\n\tPoint e, f;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a.x >> a.y >> b.x >> b.y>>c.x>>c.y>>d.x>>d.y;\n\t\te = a - b;\n\t\tf = c - d;\n\t\tif (equals(dot(e, f), 0)) cout << \"1\" << endl;\n\t\telse if (equals(cross(e, f), 0))cout << \"2\" << endl;\n\t\telse cout <<\"0\" <<endl;\n\t}\n}\nPoint Projection(Point& a, Point& b, Point& c) {\t\t//计算投影点\n\tPoint p;\n\tVector v1 = b - a;\n\tVector v2 = c - a;\n\tdouble len = dot(v1, v2);\n\tdouble len2 = len/ v1.abs();\n\tp.x = a.x + len2 / v1.abs() * v1.x;\n\tp.y = a.y + len2 / v1.abs() * v1.y;\n\treturn p;\n}\nPoint Reflection(Point& a, Point& b, Point& c) {\t//算映像\n\tPoint p = Projection(a, b, c);\t\t\t\t\t//算出映射点\n\treturn p*2 - c;\t\t\t\t\t\t\t\t\t//映射点 是 该点与映像点中点  x + c = 2*p；\n}\ndouble getDistancePP(Point a, Point b) {\t\t\t\t//两点距离;\n\treturn ((a - b).abs());\n}\ndouble getDistancePL(Point a, Line b) {\t\t\t//求点到直线距离 外积 = |a|.|b|.sin0  在直线上取两点，然后以其中一点为端点求出外\n\tVector m = b.a - b.b;\t\t\t\t\t\t//积的大小 再除以直线上的向量大小 则可以求解。\n\tVector m2 = a - b.b;\n\treturn abs(cross(m, m2) / m.abs());\n}\nint ccw(Point a, Point b, Point c) {\t\t\t//三个点的位置关系\n\tVector p = b - a;\n\tVector p2 = c - a;\n\tif (cross(p, p2) > EPS) return COUNTER_CLOCKWISE;\t\t//逆时针方向向外 结果为正\n\tif (cross(p, p2) < -EPS) return CLOCKWISE;\t\t\t\t//顺时针方向为内 结果为负\n\tif (dot(p, p2) < -EPS) return ONLINE_BACK;\n\tif (dot(p, p2) > EPS&& p2.abs() > p.abs()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\ndouble getDistancePS(Point a, Segment b) {\t\t//点到线段的距离;\n\tPoint p1, p2;\n\tp1 = a - b.a;\n\tp2 = b.b - b.a;\n\tif (dot(p1, p2) < 0) {\n\t\treturn p1.abs();\n\t}\n\tp1 = a - b.b;\n\tp2 = b.a - b.b;\n\tif (dot(p1, p2) < 0) {\n\t\treturn p1.abs();\n\t}\n\telse {\n\t\treturn getDistancePL(a, b);\n\t}\n}\nbool Intersection(Point a, Point b, Point c, Point d) {    //判断两线段是否相交  如果相交 则两个边的两个个端点会在另一条边的两边或线上\n\treturn (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\nPoint Cross_Ponit(Point a, Point b, Point c, Point d) {\t  //求两线段交点  通过面积求两边高  通过高求两边长度比例\n\tdouble s1 = cross(b - a, c - a);\n\tdouble s2 = cross(b - a, d - a);\n\tdouble d1 =  fabs(s1 * 2 / (b - a).abs());\n\tdouble d2 = fabs(s2 * 2 / (b - a).abs());\n\tPoint p;\n\tp.x = d1 / (d1 + d2) * (d - c).x + c.x;\n\tp.y = d1 / (d1 + d2) * (d - c).y + c.y;\n\treturn p;\n}\ndouble getDistanceSS(Point a, Point b, Point c, Point d) { //如果两者相交则直接返回0 否则是4个点到另一条直线最短的为距离\n\tif (Intersection(a, b, c, d)) return 0;\n\tdouble p1,p2;\n\tSegment s1,s2;\n\ts1.a = a;\n\ts1.b = b;\n\ts2.a = c;\n\ts2.b = d;\n\tp1 = min(getDistancePS(a,s2),getDistancePS(b,s2));\n\tp2 = min(getDistancePS(c, s1), getDistancePS(d, s1));\n\treturn min(p1, p2);\n}\nvoid Cross_Points_of_Line(Line a, Circle c) {         //点与圆的交点。\n\tdouble d1 = getDistancePL(c.c,a);\t\t\t\t//点到直线距离\n\tdouble d2 =sqrt (c.r * c.r - d1 * d1);\t\t\t//求点到垂直点距离\n\tPoint p = Projection(a.a,a.b,c.c );\t\t\t\t//垂直点\n\tPoint p2 = a.b - a.a;\t\t\t\t\t\t\t//向量\n\tVector v;\n\tv.x = d2 / p2.abs() * p2.x;\n\tv.y = d2 / p2.abs() * p2.y;\n\tPoint p3, p4;\n\tp3 = p + v;\n\tp4 = p - v;\n\t\n\tif (p3.x - p4.x < -EPS) {\n\t\tprintf(\"%.10f %.10f %.10f %.10f\",p3.x,p3.y,p4.x,p4.y);\n\t}\n\telse if (p3.x - p4.x < EPS) {\n\t\tif (p3.y < p4.y) {\n\t\t\tprintf(\"%.10f %.10f %.10f %.10f\", p3.x, p3.y, p4.x, p4.y);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%.10f %.10f %.10f %.10f\", p4.x, p4.y, p3.x, p3.y);\n\t\t}\n\t}\n\telse {\n\t\tprintf(\"%.10f %.10f %.10f %.10f\", p4.x, p4.y, p3.x, p3.y);\n\t}\n\tcout << endl;\n}\nint main(void) {\t\t\t\t\n\tCircle m;\n\tLine l;\n\tcin >> m.c.x >> m.c.y >> m.r;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n\t\tCross_Points_of_Line(l, m);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a, i##end = b; i <= i##end; ++i)\n#define per(i, a, b) for (int i = a, i##end = b; i >= i##end; --i)\n#define rep0(i, a) for (int i = 0, i##end = a; i < i##end; ++i)\n#define per0(i, a) for (int i = (int)a-1; ~i; --i)\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define chkmax(a, b) a = max(a, b)\n#define chkmin(a, b) a = min(a, b)\n#define x first\n#define y second\n#define enter putchar('\\n')\n\ntypedef long long ll;\ntypedef double DB;\n\nconst DB eps = 1e-12;\nconst DB PI = acos(-1);\n\nint sgn(DB x) { return fabs(x) < eps ? 0 : (x > 0 ? 1 : -1); }\n\nstruct Point {\n\tDB x, y;\n\tPoint(DB x = 0, DB y = 0) : x(x), y(y) {}\n\tPoint operator + (Point a) { return Point(x + a.x, y + a.y); }\n\tPoint operator - (Point a) { return Point(x - a.x, y - a.y); }\n\tPoint operator - () { return Point(-x, -y); }\n\tfriend Point operator * (DB k, Point a) { return Point(k * a.x, k * a.y); }\n\tPoint operator / (DB k) { return Point(x / k, y / k); }\n\tDB operator % (Point a) { return x * a.x + y * a.y; }\n\tDB operator / (Point a) { return x * a.y - y * a.x; }\n\toperator DB() { return sqrt(x*x + y*y); }\n\tbool operator < (const Point &a) const { int d1 = sgn(x-a.x), d2 = sgn(y-a.y); return d1 < 0 || (d1 == 0 && d2 < 0); }\n};\n\nstruct Circle { Point O; DB r; };\n\nPoint Proj(Point P, Point P1, Point P2) {\n\tPoint v = P2-P1; DB t = (P-P1)%v / (v%v);\n\treturn P1 + t*v;\n}\n\nPoint GetLineInter(Point P1, Point P2, Point Q1, Point Q2) {\n\tPoint v = P2-P1, w = Q2-Q1; DB t = (Q1-P1)/w / (v/w);\n\treturn P1 + t*v;\n}\n\nint Direct1(Point P, Point P1, Point P2) { return sgn((P1-P)%(P2-P)); }\nint Direct2(Point P, Point P1, Point P2) { return sgn((P1-P)/(P2-P)); }\n\nint q;\n\nCircle GetInnerCir(Point A, Point B, Point C) {\n\tPoint v1 = B-A, v2 = C-A, v3 = C-B;\n\tv1 = v1/DB(v1), v2 = v2/DB(v2), v3 = v3/DB(v3);\n\tPoint P = GetLineInter(A, A + (v1+v2), B, B + (v3-v1));\n\treturn (Circle){P, DB(P-Proj(P, A, B))};\n}\n\nCircle GetOuterCir(Point A, Point B, Point C) {\n\tPoint M = 0.5*(A+B), N = 0.5*(A+C), v = B-A, w = C-A;\n\tPoint P = GetLineInter(M, M + Point(v.y, -v.x), N, N + Point(w.y, -w.x));\n\treturn (Circle){P, DB(P-A)};\n}\n\nstd::pair<Point, Point> GetCirLineInter(Circle C, Point P1, Point P2) {\n\tPoint P = Proj(C.O, P1, P2), v = P2-P1; v = v/DB(v);\n\tDB d = DB(C.O-P);\n\tif (!sgn(d-C.r)) return std::make_pair(P, P);\n\tDB t = sqrt(C.r*C.r - d*d);\n\treturn std::make_pair(P+t*v, P-t*v);\n}\n\nint main() {\n\tCircle C;\n\tscanf(\"%lf%lf%lf\", &C.O.x, &C.O.y, &C.r);\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tPoint P1, P2;\n\t\tscanf(\"%lf%lf%lf%lf\", &P1.x, &P1.y, &P2.x, &P2.y);\n\t\tstd::pair<Point, Point> X = GetCirLineInter(C, P1, P2);\n\t\tif (X.y < X.x) std::swap(X.x, X.y);\n\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\", X.x.x, X.x.y, X.y.x, X.y.y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\nconst int INF = 1000000005;\nconst long double EPS = 1e-10;\n\nclass Point {\n  public:\n  long double x, y;\n\n  Point(long double x = 0, long double y = 0): x(x), y(y) {}\n\n  Point operator + (Point &p) {\n    return Point(x + p.x, y + p.y);\n  }\n\n  Point operator - (Point &p) {\n    return Point(x - p.x, y - p.y);\n  }\n\n  Point operator * (long double k) {\n    return Point(x * k, y * k);\n  }\n\n  Point operator / (long double k) {\n    return Point(x / k, y / k);\n  }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\nlong double norm(Point p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nlong double abs(Point p) {\n  return sqrt(norm(p));\n}\n\nlong double dot(Point p1, Point p2) {\n  return p1.x * p2.x + p1.y * p2.y;\n}\n\nlong double cross(Point p1, Point p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Point v1 = p1 - p0, v2 = p2 - p0;\n  if (cross(v1, v2) > 0) return 1;\n  else if (cross(v1, v2) < 0) return -1;\n  else if (dot(v1, v2) < 0) return 2;\n  else if (norm(v1) < norm(v2)) return -2;\n  else return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nlong double getDistanceLP(Point p1, Point p2, Point p3) {\n  return fabs(cross(p2-p1, p3-p1) / abs(p2-p1));\n}\n\nlong double getDistanceSP(Point p1, Point p2, Point p3) {\n  if (dot(p2-p1, p3-p1) < 0) return abs(p3-p1);\n  else if (dot(p1-p2, p3-p2) < 0) return abs(p3-p2);\n  else return getDistanceLP(p1, p2, p3);\n}\n\nlong double getDistanceTS(Point p1, Point p2, Point p3, Point p4) {\n  if (intersect(p1, p2, p3, p4)) return 0;\n  long double ans = INF;\n  ans = min(ans, getDistanceSP(p1, p2, p3));\n  ans = min(ans, getDistanceSP(p1, p2, p4));\n  ans = min(ans, getDistanceSP(p3, p4, p1));\n  ans = min(ans, getDistanceSP(p3, p4, p2));\n  return ans;\n}\n\nclass Circle {\n  public:\n  Point p;\n  long double r;\n};\n\nint main() {\n  Circle c;\n  int q;\n  Point p1, p2, h, a1, a2;\n  long double d, t;\n  cin >> c.p.x >> c.p.y >> c.r >> q;\n  rep(i, q) {\n    cin >> p1.x >> p1.y >> p2.x >> p2.y;\n    h = (p2 - p1) * dot(c.p - p1, p2 - p1) / norm(p2 - p1) + p1;\n    d = getDistanceLP(p1, p2, c.p);\n    t = sqrt(c.r * c.r - d * d);\n    a1 = (p2 - p1) * t / abs(p2 - p1);\n    a2 = h - a1;\n    a1 = h + a1;\n    if (equals(a1.x, 0)) a1.x = 0;\n    if (equals(a1.y, 0)) a1.y = 0;\n    if (equals(a2.x, 0)) a2.x = 0;\n    if (equals(a2.y, 0)) a2.y = 0;\n    cout << setprecision(20) << min(a1, a2).x << \" \" << min(a1, a2).y << \" \";\n    cout << setprecision(20) << max(a1, a2).x << \" \" << max(a1, a2).y << endl;\n  }\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define eps (1e-10)\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point &p){return point(x+p.x,y+p.y);}\n    point operator - (point &p){return point(x-p.x,y-p.y);}\n    point operator * (double k){return point(x*k,y*k);}\n    point operator / (double k){return point(x/k,y/k);}\n\n    bool operator < (const point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator == (const point &p){\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ndouble norm(point p)\n{\n    return p.x*p.x+p.y*p.y;\n}\ndouble ABS(point p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n    return a.x*b.y-a.y*b.x;\n}\n\npoint project(point a,point b,point c)\n{\n    point base=b-a;\n    double r=dot(base,c-a)/norm(base);\n    base=base*r;\n    return a+base;\n}\n\npair<point,point>getcrosspoints(point xin,int r,point a,point b)\n{\n    point pr=project(a,b,xin);\n    point temp=b-a;\n    point e=temp/ABS(temp);\n    point temp1=pr-xin;\n    double base=sqrt(r*r-norm(temp1));\n    e=e*base;\n    return make_pair(pr-e,pr+e);\n}\n\nint main()\n{\n    point xin;\n    int r;\n    cin>>xin.x>>xin.y>>r;\n    int q;\n    cin>>q;\n    point a,b;\n    for(int i=0;i<q;i++){\n        cin>>a.x>>a.y>>b.x>>b.y;\n        pair<point,point>res=getcrosspoints(xin,r,a,b);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//计算几何 板子\n#include<bits/stdc++.h>\nusing namespace std ;\n#define eps 1e-10\n#define equals(a , b) (fabs((a) - (b)) < eps)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1 ;\nstatic const int ONCLICK_BACK = 2 ;\nstatic const int ONLINE_FRONT = -2 ;\nstatic const int ON_SEGMENT = 0 ;\n\nclass Point\n{\npublic:\n    double x , y;\n\n    Point(double x = 0 ,double y = 0):x(x) , y(y) {}\n\n    Point operator +(Point p){return Point(x + p.x , y + p.y) ;}\n    Point operator -(Point p){return Point(x - p.x , y - p.y) ;}\n    Point operator *(double a){return Point(a * x , a * y) ;}\n    Point operator /(double a){return Point(x / a , y / a) ;}\n\n    double abs() {return sqrt(norm()) ;}\n    double norm() {return x * x + y * y ;}\n\n    bool operator < (const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y ;\n    }\n\n    bool operator == (const Point &p) const\n    {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps ;\n    }\n\n};\n\ntypedef Point Vector ;\n\nstruct Segment  //表示线段结构体\n{\n\tPoint p1,p2;\n\tSegment(){}\n\tSegment(Point _p1,Point _p2):p1(_p1),p2(_p2){}\n};\n\ntypedef Segment Line ;\n\nclass Circle{  //表示圆的结构体\npublic:\n    Point c ;\n    double r ;\n    Circle(Point c = Point() , double r = 0.0):c(c) ,r(r){}\n};\n\ndouble dot(Vector a , Vector b)  // 向量a,b的内积,就是向量a*b\n{\n    return a.x * b.x + a.y * b.y ;\n}\n\ndouble cross(Vector a, Vector b)  //向量a,b外积\n{\n\treturn a.x * b.y - a.y * b.x ;\n}\n\nbool isOrthogonal(Vector a , Vector b)  //判断是否正交\n{\n    return equals(dot(a , b) , 0.0) ;\n}\n\nbool isOrthogonal(Point a1 , Point a2 , Point b1 , Point b2)\n{\n    return isOrthogonal(a1 - a2 , b1 - b2) ;\n}\n\nbool  isOrthogonal(Segment s1 , Segment s2)\n{\n    return equals(dot(s1.p2 - s1.p1 , s2.p2 - s2.p1) , 0.0) ;\n}\n\nbool isParallel(Vector a, Vector b)  //判断是否平行\n{\n\treturn equals(cross(a, b), 0.0) ;\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn isParallel(a1 - a2, b1 - b2) ;\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0) ;\n}\n\nPoint project(Segment s, Point p)  //p在s上的投影\n{\n    Point base = s.p2 - s.p1 ;\n    double r = dot(p - s.p1 , base) / base.norm() ;\n    return s.p1 +base * r ;\n}\n/*\n求垂足x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线引一条垂线\nbase=p2-p1;\nhypo=p-p1;\n x=s.p1+base*(hypo*base/|base|^2); hypo*base 可以用向量内积求\n*/\n\nPoint reflect(Segment s , Point p)\n{\n    return p + (project(s , p) - p) * 2.0 ;\n}\n\nint ccw(Point p0 , Point p1 , Point p2)//判断三个点相对位置  // 判断逆时针方向的时候也可以使用\n{\n\tPoint a = p1 - p0 ;\n\tPoint b = p2 - p0 ;\n\tif(cross(a , b) > eps) return 1 ;  //p0,p1,p2成逆时针方向\n\tif(cross(a , b) < -eps) return -1 ;  //p0,p1,p2成顺时针方向\n\tif(dot(a , b) < -eps) return 2 ;  //p2 p0 p1一次排列在同一直线上\n\tif(a.norm() < b.norm()) return -2 ;  // p0 p1 p2一次排列在同一直线上\n\treturn 0 ;  //p2在线段p0p1上\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4)  //判断是否相交 通过ccw来判断\n{\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1 , Segment s2)\n{\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2) ;\n}\n\ndouble getdis(Point a , Point b)  //求俩点间的距离\n{\n\treturn (a - b) . abs() ; //点a与点b之间的距离等于向量a-b或b-a的绝对值。\n}\n\n//注意：这里Segmet s是不规范的应该是 Line s 才对\ndouble getdis_Li(Segment s , Point p)  //点与直线的距离\n{\n\treturn fabs(cross(s.p2 - s.p1 , p - s.p1)/(s.p2-s.p1).abs());\n}\n\ndouble getdis_sp(Segment s , Point p)  //点与线段的距离\n{\n\tif(dot(s.p2 - s.p1 , p - s.p1) < 0.0) return (p-s.p1).abs();\n\tif(dot(s.p1 - s.p2 , p - s.p2) < 0.0) return (p-s.p2).abs();\n\treturn getdis_Li(s , p) ;\n}\n\ndouble getdis_ss(Segment s1 , Segment s2)  //线段与线段之间的距离\n{\n\tif(intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2)) return 0.0 ;\n\treturn min(min(getdis_sp(s1 , s2.p1) , getdis_sp(s1 , s2.p2)) , min(getdis_sp(s2 , s1.p1) , getdis_sp(s2 , s1.p2))) ;\n}\n\nPoint getCrossPoint(Segment s1 , Segment s2) //线段的交点，返回的是点\n{\n    Vector base = s2.p2 - s2.p1 ;\n    double d1 = abs(cross(base , s1.p1 - s2.p1)) ;\n    double d2 = abs(cross(base , s1.p2 - s2.p2)) ;\n    double t = d1 / (d1 + d2) ;\n    return s1.p1 + (s1.p2 - s1.p1) * t ;\n}\n\nbool intersect(Circle c , Line l)\n{\n    if(getdis_Li(l , c.c) > c.r)\n    {\n        return false ;\n    }\n    else\n    {\n        return true ;\n    }\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)  //直线与圆的交点\n{\n    assert(intersect(c , l)) ;\n    Vector pr = project(l , c.c) ;\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs() ;\n    double base = sqrt(c.r * c.r - (pr - c.c).norm()) ;\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nint main()\n{\n    Circle c ;\n    cin >> c.c.x >> c.c.y >> c.r ;\n    Line l ;\n    int t ;\n    cin >> t ;\n    pair<Point , Point> p ;\n    while(t --)\n    {\n        cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y ;\n        p = getCrossPoints(c , l) ;\n        if(p.first.x < p.second.x || (p.first.x == p.second.x && p.first.y <= p.second.y))\n        {\n            printf(\"%.6lf %.6lf %.6lf %.6lf\\n\" , p.first.x , p.first.y , p.second.x , p.second.y) ;\n        }\n        else\n        {\n            printf(\"%.6lf %.6lf %.6lf %.6lf\\n\", p.second.x, p.second.y, p.first.x, p.first.y);\n        }\n    }\n    return 0 ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <sstream>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-10;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nclass Point\n{\npublic:\n  double x,y;\n  Point(double x,double y): x(x),y(y){}\n  Point operator + (const Point &p)\n  {\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (const Point &p)\n  {\n    return Point(x-p.x,y-p.y);\n  }\n  Point operator * (double k)\n  {\n    return Point(x*k,y*k);\n  }\n  Point operator / (double k)\n  {\n    return Point(x/k,y/k);\n  }\n  bool operator < (const Point &p) const\n  {\n    return x!=p.x ? x<p.x : y<p.y;\n  }\n  bool operator == (const Point &p) const\n  {\n    return fabs(x-p.x)<eps && fabs(y-p.y) < eps;\n  }\n  double abs(){return sqrt(norm());}\n  double norm(){return x*x+y*y;}\n};\ntypedef Point Vector;\ndouble dot(Vector a,Vector b)\n{\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\ndouble norm(Point a)\n{\n  return a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a)\n{\n  return sqrt(norm(a));\n}\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1,Point p2): p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n  Point c;\n  double r;\n  Circle(Point c,double r):  c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\n\nbool isorthogonal(Vector a,Vector b)\n{\n  return fabs(dot(a,b)-0.0)<eps;\n}\n\nbool isparallel(Vector a,Vector b)\n{\n  return fabs(cross(a,b)-0.0)<eps;\n}\nPoint project(Segment s,Point p)\n{\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return  s.p1 + base*r;\n}\nPoint reflect(Segment s,Point p)\n{\n  return p+ (project(s,p)-p)*2.0;\n}\ndouble getdistance(Point a,Point b)\n{\n  return abs(a-b);\n}\ndouble getdistanceLP(Line l,Point p)\n{\n  return abs(cross(l.p2-l.p1,p-l.p1) / abs(l.p2-l.p1));\n}\ndouble getdistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) <0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) <0.0) return abs(p-s.p2);\n  return getdistanceLP(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps) return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps) return CLOCKWISE;\n  if(dot(a,b)<-eps) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1) * ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2)\n{\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n  Vector base =s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getdistanceSS(Segment s1,Segment s2)\n{\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getdistanceSP(s1,s2.p1),getdistanceSP(s1,s2.p2)),min(getdistanceSP(s2,s1.p1),getdistanceSP(s2,s1.p2)));\n}\n\npair<Point,Point> getcrosspoints(Circle c,Line l)\n{\n  //assert(intersect(c,l));\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r - norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\nint main(int argc,char const* argv[])\n{\n  double cx,cy,r;\n  cin >> cx >> cy >> r;\n  Point mid=Point(cx,cy);\n  Circle c=Circle(mid,r);\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++)\n    {\n      double p0x,p0y,p1x,p1y;\n      cin >> p0x >> p0y >> p1x >> p1y;\n      Point p0=Point(p0x,p0y);\n      Point p1=Point(p1x,p1y);\n      Line s=Segment(p0,p1);\n      pair<Point,Point> ans=getcrosspoints(c,s);\n      if(ans.second<ans.first)\n\t{\n\t  cout << fixed << setprecision(12) << ans.second.x << ' ' << ans.second.y << ' ' << ans.first.x << ' ' << ans.first.y << endl;\n\t}\n      else\n\t{\n      cout << fixed << setprecision(12) << ans.first.x << ' ' << ans.first.y << ' ' << ans.second.x << ' ' << ans.second.y << endl;\n\t}\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(a*x, a*y); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double norm() { return x*x+y*y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\ntypedef vector <Vector> Polygon;\n\nclass Segment {\n public:\n  Point p1, p2;\n\n  Segment(Point p1 = Point(), Point p2 = Point()): p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n// ?????????|a||b|cos\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y-a.y*b.x;\n}\n// ?????????|a||b|sin\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x+a.y*b.y;\n}\n\n// ??´???l??¨???p????????¢\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2-l.p1, p-l.p1))/abs(l.p2-l.p1);\n}\n\n// ?°???±:??´???s???p?????????????????????????????¨?????????????????????\nPoint project(Segment s, Point p) {\n  Vector base = s.p2-s.p1;\n  double r = dot(p-s.p1, base)/norm(base);\n  return s.p1+base*r;\n}\n\nclass Circle {\n public:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ???c??¨??´???l????????????????????????\nbool intersect(Circle c, Line l) {\n  return getDistanceLP(l, c.c) < c.r;\n}\n\n// ???c??¨??´???l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2-l.p1)/abs(l.p2-l.p1);\n  double base = sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base, pr-e*base);\n}\n\nint main() {\n  Circle c;\n  cin >> c.c.x >> c.c.y >> c.r;\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    Line l;\n    cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n    pair<Point, Point> ans = getCrossPoints(c, l);\n    if (ans.second < ans.first) swap(ans.first, ans.second);\n    cout << fixed << setprecision(20)\n         << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntypedef complex<double> P;\ntypedef pair<P, double> Circle;\n\n#define EPS 1e-16\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n\ninline int signum(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\n\ndouble dot(P a, P b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nP getPoint(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    double d = (dot(b, c)) / abs(b);\n    P p = a + (b / abs(b) * d);\n    return p;\n}\n\ndouble getLength(double a, double r) {\n    return sqrt(r * r - a * a);\n}\n\nint main() {\n//\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n\n    Circle c(P(cx, cy), r);\n\n    int Q;\n    cin >> Q;\n\n    while (Q--) {\n\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        P p1(x1, y1), p2(x2, y2);\n\n        P mid = getPoint(p1, p2, c.first);\n\n        double len = getLength(abs(c.first - mid), c.second);\n\n        P ans1 = mid + (p2 - p1) / (abs(p2 - p1) + EPS) * len;\n        P ans2 = mid + (p1 - p2) / (abs(p1 - p2) + EPS) * len;\n\n        if (ans1.real() > ans2.real()) swap(ans1, ans2);\n        else if (ans1.real() == ans2.real() && ans1.imag() > ans2.imag()) swap(ans1, ans2);\n\n        cout << fixed << setprecision(20) << ans1.real() << \" \" << ans1.imag() << \" \" << ans2.real() << \" \" << ans2.imag() << endl;\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\ntypedef Segment Line;                               //??´???\ntypedef struct Circle{Point c; double r;}Circle;    //???\n\n\nint main(){\n    \n    int cx, cy;\n    double r;\n    int q;\n    int x1, y1, x2, y2;\n    \n    cin >> cx >> cy >> r >> q;\n    \n    Circle c = {Point(cx, cy), r};\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        \n        Line l = {Point(x1, y1), Point(x2, y2)};\n        \n        pair<Point, Point> ans = getCrossPoints(c, l);\n        bool swap_flag = (ans.first.x == ans.second.x) ? ans.first.y > ans.second.y : (ans.first.x > ans.second.x);\n        if(swap_flag) swap(ans.first, ans.second);\n        \n        printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", ans.first.x, ans.first.y, ans.second.x, ans.second.y);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\tdouble cx,cy,r,x1,x2,y1,y2,slope,cross_x,cross_y,k,div_x,div_y;\n\tint q;\n\tbool X_FLG,Y_FLG;\n\n\tscanf(\"%lf %lf %lf\",&cx,&cy,&r);\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf\",&x1,&y1,&x2,&y2);\n\n\t\tX_FLG = false,Y_FLG = false;\n\n\t\tif(y1 == y2){\n\t\t\tX_FLG = true;\n\t\t}else if(x1 == x2){\n\t\t\tY_FLG = true;\n\t\t}else{\n\t\t\tslope = (y2-y1)/(x2-x1);\n\t\t}\n\n\t\tif(X_FLG){\n\t\t\tcross_x = cx;\n\t\t\tcross_y = y1;\n\t\t}else if(Y_FLG){\n\t\t\tcross_x = x1;\n\t\t\tcross_y = cy;\n\t\t}else{\n\t\t\tcross_x = (cy*(x2-x1)*(y2-y1)+cx*(x2-x1)*(x2-x1)-y1*(y2-y1)*(x2-x1)+x1*(y2-y1)*(y2-y1))/((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1));\n\t\t\tcross_y = ((x1-x2)*cross_x+cy*(y2-y1)+cx*(x2-x1))/(y2-y1);\n\t\t}\n\n\t\tk = sqrt(r*r-((cx - cross_x)*(cx-cross_x)+(cy-cross_y)*(cy-cross_y)));\n\n\t\tif(X_FLG){\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",cross_x - k,y1,cross_x+k,y1);\n\t\t}else if(Y_FLG){\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",x1,cross_y-k,x1,cross_y+k);\n\t\t}else{\n\t\t\tdiv_x = k*(x2-x1)/(sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)));\n\t\t\tdiv_y = k*(y2-y1)/(sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)));\n\t\t\tprintf(\"%.8lf %.8lf %.8lf %.8lf\\n\",cross_x-div_x,cross_y-div_y,cross_x + div_x,cross_y+div_y);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n\n//平面幾何\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n\n//宣言\n//--------------------------------------------\n\n//long double or double\ntypedef double Real;\n\n//ポイントクラス\ntypedef complex<Real> Point;\n\n//線分クラス\ntypedef pair<Point, Point> Line;\n\n//円\ntypedef pair<Point, Real> Circle;\n\n//ポリゴン\ntypedef vector<Point> Poly;\n\n\n//x座標優先で比較する\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n}\n\n\n//doubleの誤差\n#define EPS (1e-4)\n//double同士の比較\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n//Pointの比較\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n//角度\n//--------------------------------------------\nReal toRadian(double degree) {\n    return degree * PI / 180.0;\n}\n\nReal toDegree(double radian) {\n    return radian * 180.0 / PI;\n}\n\n\n\n\n\n\n\n//内積・外積・単位・法線\n//--------------------------------------------\n\n//ベクトルpの向きの単位ベクトルを返す\nPoint unit_vector(Point p) {\n    return p / abs(p);\n}\n\n\n//pの法線ベクトルを両方返す\npair<Point, Point> norm_vectors(Point p) {\n    return make_pair(p * Point(0, 1), p * Point(0, -1));\n}\n\n//ベクトルを反時計に回す sはラジアン\nPoint rotate_vector(Point v, double s) {\n    return Point(v.real() * cos(s) - v.imag() * sin(s), v.real() * sin(s) + v.imag() * cos(s));\n}\n\n//内積 a・b = |a||b|cosθ\ninline double dot(const Point &a, const Point &b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積 a×b = |a||b|sinθ\ninline double cross(const Point &a, const Point &b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n//三角形　角度・面積\n//--------------------------------------------\n//3点a, b, cのおける、角bacを返す\nReal args_bac(Point a, Point b, Point c) {\n    return acos(dot(b - a, c - a) / (abs(b - a) * abs(c - a)));\n}\n\n//各辺の長さがa, b, cの三角形の、aの対角の角度を返す\nReal args_bac(Real a, Real b, Real c) {\n    return acos((b * b + c * c - a * a) / (2 * b * c));\n}\n\n//三角形の面積\nReal heron_area(Real a, Real b, Real c) {\n    Real s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n//Real heron_area(Point a, Point b, Point c) {\n//    b -= a;\n//    c -= a;\n//    return (cross(b, c) / 2.0);\n//}\n\n//三角形の重心\nPoint centerOfGravity(Point a, Point b, Point c) {\n    return Point((a.real() + b.real() + c.real()) / 3.0, (a.imag() + b.imag() + c.imag()) / 3.0);\n}\n\n//三角形の外接円の半径\nReal circumScribedCircleRadius(Point a, Point b, Point c) {\n    Real edgeA = abs(b - c);\n    Real angleA = args_bac(a, b, c);\n    return (edgeA / sin(angleA) / 2.0);\n}\n\n//三角形の外接円の中心座標　外心\nPoint circumScribedCircleXY(Point a, Point b, Point c) {\n    Real angleA = args_bac(a, b, c);\n    Real angleB = args_bac(b, a, c);\n    Real angleC = args_bac(c, a, b);\n    Real A = sin(2.0 * angleA);\n    Real B = sin(2.0 * angleB);\n    Real C = sin(2.0 * angleC);\n    Point point((a.real() * A + b.real() * B + c.real() * C) / (A + B + C),\n                (a.imag() * A + b.imag() * B + c.imag() * C) / (A + B + C));\n    return point;\n}\n\n//三角形が点Pを含むか\nbool point_in_triangle(Point a, Point b, Point c, Point p) {\n    Point ab = b - a;\n    Point bp = p - b;\n\n    Point bc = c - b;\n    Point cp = p - c;\n\n    Point ca = a - c;\n    Point ap = p - a;\n\n    Real c1 = cross(ab, bp);\n    Real c2 = cross(bc, cp);\n    Real c3 = cross(ca, ap);\n\n    //内側\n    if ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0)) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\n\n//直線・線分\n//--------------------------------------------\n\n//頂点a, b, cの位置関係判定\n//別名ccw couter-clock-wise\nint points_relation(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return 1; //counter-clockwise\n    if (cross(b, c) < -EPS) return -1; //clockwise\n    if (dot(b, c) < -EPS) return 2; //c--a--b on line\n    if (abs(b) < abs(c)) return -2; //a--b--c on line\n    return 0; //on segment\n}\n\n//2直線の直行判定 Point版\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の直行判定 Line版\nbool is_orthogonal(Line line1, Line line2) {\n    return EQ(dot(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//2直線の平行判定 Point版\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の平行判定 Line版\nbool is_parallel(Line line1, Line line2) {\n    return EQ(cross(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//点cが**直線**a-b上にあるか\nbool is_point_on_long_line(Point a, Point b, Point c) {\n    return EQ(cross(b - a, c - a), 0.0);\n}\n\n//点cが**線分**a-b上にあるか\nbool is_point_on_line(Point a, Point b, Point c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//点a, bを通る**直線**と,点cとの距離d\ndouble distance_longline_point(Point a, Point b, Point c) {\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//直線と点との距離　円用\nReal line_dis(Line a, Point x) {\n    return abs(cross(a.second - a.first, x - a.first)) / abs(a.second - a.first);\n}\n\n//点a, bを端点とする**線分**と、点cとの距離d\nReal distance_line_point(Point a, Point b, Point c) {\n    if (dot(b - a, c - a) < EPS) return abs(c - a);\n    if (dot(a - b, c - b) < EPS) return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交差判定\nbool is_intersected_lines(Point a1, Point a2, Point b1, Point b2) {\n    return (points_relation(a1, a2, b1) * points_relation(a1, a2, b2) <= 0 &&\n            points_relation(b1, b2, a1) * points_relation(b1, b2, a2) <= 0);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の距離\nReal distance_line_line(Point a1, Point a2, Point b1, Point b2) {\n    if (is_intersected_lines(a1, a2, b1, b2)) {\n        return 0;\n    } else {\n        return min({\n                           distance_line_point(a1, a2, b1),\n                           distance_line_point(a1, a2, b2),\n                           distance_line_point(b1, b2, a1),\n                           distance_line_point(b1, b2, a2)\n                   });\n    }\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交点\nPoint intersection_lines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point b = b2 - b1;\n    double d1 = abs(cross(b, a1 - b1));\n    double d2 = abs(cross(b, a2 - b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2 - a1) * Point(t, 0);\n}\n\n//点a1, a2を通る直線と点b1, b2を通る直線の交点計算\nPoint intersection_longlines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1;\n    Point b = b2 - b1;\n    return a1 + a * Point(cross(b, b1 - a1), 0) / Point(cross(b, a), 0);\n}\n\n\n//直線a-bに点pから垂線をおろしたときの交点\nPoint projection_point(Point a, Point b, Point p) {\n    Real t = dot(p - a, a - b) / (abs(a - b) * abs(a - b));\n    return a + (a - b) * t;\n}\n\n//点pを線対称移動させる\nPoint reflection_point(Point a, Point b, Point p) {\n    return p + (projection_point(a, b, p) - p) * (Real) 2.0;\n}\n\n\n//多角形\n//--------------------------------------------\n\n//面積を返す 反時計回りに整列させておく\n//正なら反時計回り　負なら時計回り\nReal poly_area(Poly p) {\n    if (p.size() < 3)return 0;\n    Real res = cross(p[p.size() - 1], p[0]);\n    for (int i = 1; i < p.size(); i++) {\n        res += cross(p[i - 1], p[i]);\n    }\n    return abs(res) / 2;\n}\n\n//凸多角形か判定する\n//凸出ない場合、各辺から次の辺までの\n//時計回り・反時計回りに反対のものが出てくる\nbool is_convec_poly(Poly p) {\n    if (p.size() < 3) {\n        return false;\n    }\n\n    //sはstartのs　最初の回り方を保存する\n    int s = -3;\n    for (int i = 0; i < p.size(); i++) {\n        //2辺隣接した辺を選ぶ\n        int r = points_relation(p[i], p[(i != 0 ? i - 1 : p.size() - 1)], p[(i + 1 != p.size() ? i + 1 : 0)]);\n\n        //外積が1 時計回りか反時計なら更新\n        if (abs(r) == 1 && s == -3) s = r;\n\n        //sとrの積が-1なら異なる回り方が出てきている\n        //すべて時計回りなら-1*-1=1 反時計なら1*1=1\n        if (s * r == -1) return false;\n    }\n    return true;\n}\n\n//最遠点対　凸多角形で最も長い距離を返す\n//凸包の後に使うとよい\nReal longest_points_distance(Poly p) {\n    int n = p.size();\n    if (n == 2) {\n        return abs(p[0] - p[1]);\n    }\n\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n        if (!(p[i] < p[k])) i = k;\n        if (p[j] < p[k]) j = k;\n    }\n\n    Real res = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(p[i] - p[j]));\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n\n    return res;\n}\n\n//凸包\nvector<Point> convex_hull(vector<Point> v) {\n    int n = v.size(), k = 0;\n    sort(v.begin(), v.end());\n    vector<Point> r(2 * n);\n    for (int i = 0; i < n; i++) {\n        while (k > 1 && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        while (k > t && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    r.resize(k - 1);\n    return r;\n}\n\n//多角形をLine lで分割した際の左側の集合を返す\nPoint getcrosspointll(Line l1, Line l2) {\n    double c1 = cross(l1.first, l1.second), c2 = cross(l2.first, l2.second);\n    double de = (l1.first.imag() - l1.second.imag()) * (l2.first.real() - l2.second.real()) -\n                (l2.first.imag() - l2.second.imag()) * (l1.first.real() - l1.second.real());\n    double x = (l2.second.real() - l2.first.real()) * c1 + (l1.first.real() - l1.second.real()) * c2;\n    double y = (l2.second.imag() - l2.first.imag()) * c1 + (l1.first.imag() - l1.second.imag()) * c2;\n    return Point(x / de, y / de);\n}\n\nPoly convexcut(Poly p, Line l) {\n    int n = p.size();\n    Poly q;\n\n    for (int i = 0; i < n; i++) {\n        if (points_relation(l.first, l.second, p[i]) != -1)q.push_back(p[i]);\n        if (points_relation(l.first, l.second, p[i]) * points_relation(l.first, l.second, p[(i + 1) % n]) < 0.0) {\n            if (!is_parallel(l, Line(p[i], p[(i + 1) % n]))) {\n                q.push_back(getcrosspointll(l, Line(p[i], p[(i + 1) % n])));\n            }\n        }\n    }\n    return q;\n}\n\n//頂点pが多角形pの内外か判定する\n//2･･･in 1･･･on 0･･･out\nint point_in_poly(Poly v, Point p) {\n    bool in = false;\n    for (int i = 0; i < v.size(); ++i) {\n        Point a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n    }\n    return in ? 2 : 0;\n}\n\n\n\n//円 第一引数は中点　第二引数は半径\n//--------------------------------------------\n\n//円の面積\nReal circle_area(Circle c) {\n    return PI * c.second * c.second;\n}\n\n//円の中に点xが内部にあるか\nbool circle_in_x(Circle c, Point x) {\n    return (abs(x - c.first) + EPS < c.second);\n}\n\n//円状に点xがあるか\nbool circle_on_x(Circle c, Point x) {\n    return EQ(abs(x - c.first), c.second);\n}\n\n//2つの円a, bの関係\nint circle_relation(Circle a, Circle b) {\n    double d = abs(a.first - b.first);\n\n    if (a.second + b.second + EPS < d) return -1; //no cross point outside\n    if (b.second + d + EPS < a.second) return 1; //no cross point(inside B in A)\n    if (a.second + d + EPS < b.second) return 2; //no cross point(inside A in B)\n\n    if (abs(a.second + b.second - d) < EPS) return -3; //one cross point(outside)\n    if (abs(b.second + d - a.second) < EPS) return 3; //one cross point(inside B in A)\n    if (abs(a.second + d - b.second) < EPS) return 4; //one cross point(inside A in B)\n\n    return 0; //two cross point\n}\n\n//2円a, bの共通面積\nReal intersection_area(Circle a, Circle b) {\n    Real d = abs(a.first - b.first);\n\n    if (a.second + b.second < d + EPS) return 0;\n\n    //円aを半径が大きい方にする\n    if (a.second < b.second) swap(a, b);\n\n    //円bが円aに入ってたら\n    if (b.second + d < a.second + EPS || b.second < EPS) return circle_area(b);\n\n    Real t1 = args_bac(b.second, a.second, d);\n    Real t2 = args_bac(a.second, b.second, d);\n    Real tri = (a.second * a.second * sin(t1 * 2) + b.second * b.second * sin(t2 * 2)) / 2.0;\n    return a.second * a.second * t1 + b.second * b.second * t2 - tri;\n}\n\n//2つの円の交点を返す\nvector<Point> circle_inter_points(Circle a, Circle b) {\n    vector<Point> v;\n    int pos = circle_relation(a, b);\n    if (pos == 0) {\n        Real s = args_bac(b.second, abs(b.first - a.first), a.second);\n        Point x = a.second * unit_vector(b.first - a.first);\n        v.push_back(a.first + rotate_vector(x, s));\n        v.push_back(a.first + rotate_vector(x, -s));\n    } else if (abs(pos) >= 3) {\n        v.push_back(a.first + a.second * unit_vector(b.first - a.first));\n    }\n    return v;\n}\n\n//円と直線の交点\nvector<Point> circle_inter_line_points(Circle a, Line l) {\n//    vector<Point> v;\n//    Real d = line_dis(l, a.first);\n//    if (d < a.second + EPS) {\n//        Point x = a.second * unit_vector(l.second - l.first);\n//        if (points_relation(l.first, l.second, a.first) == 1) x = a.first + x * Point(0, -1);\n//        else x = a.first + x * Point(0, 1);\n//        if (d + EPS < a.second) {\n//            Real y = sqrt(a.second * a.second - d * d);\n//            if (d == 0) d += EPS;\n//            Real s = args_bac(y, d, a.second);\n//            v.push_back(rotate_vector(x, s));\n//            v.push_back(rotate_vector(x, -s));\n//        } else if (EQ(d, a.second)) {\n//            v.push_back(x);\n//        }\n//    }\n    vector<Point> res;\n    Real d = distance_line_point(l.first, l.second, a.first);\n    if (d > a.second + EPS) return res;\n    Real len = (d > a.second) ? 0.0 : sqrt(a.second * a.second - d * d);\n    Point nor = (l.first - l.second) / abs(l.first - l.second);\n    res.push_back(projection_point(l.first, l.second, a.first) + len * nor);\n    res.push_back(projection_point(l.first, l.second, a.first) - len * nor);\n    return res;\n    //return v;\n}\n\n//点pを通る円cの接線\nvector<Line> adjust_line(Circle c, Point p) {\n    vector<Line> res;\n    if (circle_in_x(c, p)) return res;\n    if (circle_on_x(c, p)) {\n        pair<Point, Point> n = norm_vectors(c.first - p);\n        res.push_back(Line(n.first + p, p));\n        return res;\n    }\n    Real x = c.second, z = abs(c.first - p);\n    Real y = sqrt(z * z - x * x);\n    Real s = args_bac(y, x, z);\n    Point v = unit_vector(p - c.first) * c.second;\n\n    res.push_back(Line(rotate_vector(v, s) + c.first, p));\n    res.push_back(Line(rotate_vector(v, -s) + c.first, p));\n    return res;\n}\n\n//円の共通接線を求める\nvector<Line> common_adjust_line(Circle a, Circle b) {\n    vector<Line> res;\n    if (a.second + EPS < b.second) return common_adjust_line(b, a);\n    if (EQ(a.first.real(), b.first.real()) && EQ(a.first.imag(), b.first.imag()) && EQ(a.second, b.second)) return res;\n\n    Point pos = (b.first - a.first) * a.second / (a.second + b.second) + a.first;\n    if (!circle_in_x(a, pos)) res = adjust_line(a, pos);\n\n    if (EQ(a.second, b.second)) {\n        pair<Point, Point> n = norm_vectors(unit_vector(b.first - a.first) * a.second);\n        res.push_back(Line(a.first + n.first, b.first + n.first));\n        res.push_back(Line(a.first + n.second, b.first + n.second));\n    } else {\n        Real c = abs(b.first - a.first);\n        pos = unit_vector(b.first - a.first) * ((a.second * c) / (a.second - b.second)) + a.first;\n        if (!circle_in_x(a, pos)) {\n            vector<Line> tmp = adjust_line(a, pos);\n            for (int i = 0; i < tmp.size(); i++) res.push_back(tmp[i]);\n        }\n    }\n\n    return res;\n}\n\n\n//使い方\n//--------------------------------------------\n\n//xとyの取り出し型\n//a.real(); //x\n//a.imag(); //y\n\n//単位ベクトル\n//Point unit = a / abs(a);\n\n//ベクトルの長さをk倍する\n// a = a * Point(k, 0);\n\n//ベクトルaのk倍の法線ベクトル\n//P p1 = a * P(0, k);\n//P p2 = a * P(0, -k);\n\n//ベクトルaの単位法線ベクトル\n//P p1 = (a * P(0, 1)) /abs(a);\n//P p2 = (a * P(0, -1)) /abs(a);\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\n\n\nint main() {\n\n    double cx, cy, r;\n    cin >> cx >> cy >> r;\n\n    Circle circle(Point(cx, cy), r);\n\n    int q;\n    cin >> q;\n\n    for (int i = 0; i < q; i++) {\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        auto ans = circle_inter_line_points(circle, Line(Point(x1, y1), Point(x2, y2)));\n\n        if (ans.size() >= 2) {\n            sort(ans.begin(), ans.end());\n            for (int i = 0; i < 2; i++) {\n                cout << fixed << setprecision(10) << ans[i].real() << \" \" << ans[i].imag() << \" \";\n            }\n        } else {\n            for (int i = 0; i < 2; i++) {\n                cout << fixed << setprecision(10) << ans[0].real() << \" \" << ans[0].imag() << \" \";\n            }\n        }\n\n        EL();\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <utility>\n#define EPS 1e-10\nusing namespace std;\n\ndouble add(double a,double b){\n    if(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n    return a+b;\n}\n\nclass P{\npublic:\n    double x,y;\n    P(double xx=0,double yy=0){\n        x=xx;\n        y=yy;\n    }\n    P operator +(P p){\n        return P(add(x,p.x),add(y,p.y));\n    }\n    P operator -(P p){\n        return P(add(x,-p.x),add(y,-p.y));\n    }\n    P operator *(double d){\n        return P(x*d,y*d);\n    }\n    P operator /(double d){\n        return P(x/d,y/d);\n    }\n    bool operator<(const P &p)const{\n        if(add(x,-p.x)==0.0)return y<p.y;\n        return x<p.x;\n    }\n};\n\ntypedef P Vector;\n\ndouble norm(P p){\n    return p.x*p.x+p.y*p.y;\n}\n\ndouble abs(P p){\n    return sqrt(norm(p));\n}\n\ndouble dot(Vector a,Vector b){\n    return add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(Vector a,Vector b){\n    return add(a.x*b.y,-a.y*b.x);\n}\n\nclass Segment{\npublic:\n    P p1,p2;\n    Segment(P pp1=P(),P pp2=P()){\n        p1=pp1;\n        p2=pp2;\n    }\n};\n\ntypedef Segment Line;\n\nP project(Segment s,P p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nclass Circle{\npublic:\n    P c;\n    double r;\n    Circle(P cc=P(),double rr=0.0){\n        c=cc;\n        r=rr;\n    }\n};\n\ndouble getDistanceLP(Line l,P p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\n\nbool intersect(Circle c,Line l){\n    return getDistanceLP(l,c.c)<=c.r;\n}\n\npair<P,P> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n\nint main(void){\n    Circle c;\n    scanf(\"%lf %lf %lf\",&c.c.x,&c.c.y,&c.r);\n    int q;\n    scanf(\"%d\",&q);\n    for(int i=0;i<q;i++){\n        Line l;\n        scanf(\"%lf %lf %lf %lf\",&l.p1.x,&l.p1.y,&l.p2.x,&l.p2.y);\n        pair<P,P> res=getCrossPoints(c,l);\n        if(res.second<res.first)swap(res.first,res.second);\n        printf(\"%.9f %.9f %.9f %.9f\\n\",res.first.x,res.first.y,res.second.x,res.second.y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <cmath>            // sqrt()\n#include <utility>          // pair\n\nusing namespace std;\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n};\n\nstruct Segment\n{\n\tPoint p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef pair<Point, Point> P;\n\ndouble\nnorm(Vector a)\n{\n\treturn a.x * a.x + a.y * a.y;\n}\n\ndouble\nabs(Vector a)\n{\n\treturn sqrt(norm(a));\n}\n\ndouble\ndot(Vector a, Vector b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\nPoint\nproject(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nP\ngetCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\nint\nmain(int argc, char** argv)\n{\n\tCircle c;\n\tLine l;\n\tint q;\n\n\tscanf(\"%lf %lf %lf\", &c.c.x, &c.c.y, &c.r);\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tscanf(\"%lf %lf %lf %lf\", &l.p1.x, &l.p1.y, &l.p2.x, &l.p2.y);\n\n\t\tP p = getCrossPoints(c, l);\n\t\tif (p.first.x != p.second.x)\n\t\t{\n\t\t\tif (p.first.x > p.second.x)\n\t\t\t\tswap(p.first, p.second);\n\t\t}\n\t\telse if (p.first.y > p.second.y)\n\t\t\t\tswap(p.first, p.second);\n\n\t\tprintf(\"%.8f %.8f %.8f %.8f\\n\", p.first.x, p.first.y, p.second.x, p.second.y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass point {\npublic:\n\tdouble x, y;\n\tpoint() {}\n\tpoint(double a, double b) { x = a; y = b; }\n\tpoint operator +( point p ) { return point( x + p.x, y + p.y ); }\n\tpoint operator -( point p ) { return point( x - p.x, y - p.y ); }\n\tpoint operator *( double a ) { return point( x * a, y * a ); }\n\tpoint operator /( double a ) { return point( x / a, y / a ); }\n};\n\ndouble dot( point p1, point p2 ) { return p1.x * p2.x + p1.y * p2.y; }\ndouble norm( point p ) { return p.x * p.x + p.y * p.y; }\n\nint main()\n{\n\tpoint c;\n\tdouble r;\n\tcin >> c.x >> c.y >> r;\n\tint q;\n\tcin >> q;\n\tfor( int i = 0; i < q; i++ ) {\n\t\tpoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tpoint base = p2 - p1;\n\t\tdouble rr = dot( c - p1, base ) / norm( base );\n\t\tpoint pr = p1 + base * rr;\n\t\tpoint e = (p2 - p1) / sqrt( norm( p2 - p1 ) );\n\t\tdouble b = sqrt( r * r - norm( pr - c ) );\n\t\tpoint cp1 = pr + e * b;\n\t\tpoint cp2 = pr - e * b;\n\t\tif( cp1.x > cp2.x ) swap( cp1, cp2 );\n\t\telse if( cp1.x == cp2.x && cp1.y > cp2.y ) swap( cp1, cp2 );\n\n\t\tcout << fixed << setprecision(10) << cp1.x << \" \" << cp1.y  << \" \" << cp2.x << \" \" << cp2.y << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a*x, a*y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\ndouble norm(Vector a) {\n\treturn a.norm();\n}\n\ndouble abs(Vector a) {\n\treturn a.abs();\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(Segment s, Point p) {\n\tdouble alpha = dot(p - s.p2, s.p1 - s.p2) / (s.p1 - s.p2).norm();\n\treturn s.p2 + (s.p1 - s.p2)*alpha;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn project(s, p)*2.0 - p;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\tint p1p2p3, p1p2p4, p3p4p1, p3p4p2;\n\tp1p2p3 = ccw(p1, p2, p3);\n\tp1p2p4 = ccw(p1, p2, p4);\n\tp3p4p1 = ccw(p3, p4, p1);\n\tp3p4p2 = ccw(p3, p4, p2);\n\n\tif (p1p2p3 == ON_SEGMENT) return true;\n\tif (p1p2p4 == ON_SEGMENT) return true;\n\tif (p3p4p1 == ON_SEGMENT) return true;\n\tif (p3p4p2 == ON_SEGMENT) return true;\n\tif (p1p2p3 == ONLINE_FRONT && p1p2p4 == ONLINE_BACK) return true;\n\tif (p1p2p3 == ONLINE_BACK && p1p2p4 == ONLINE_FRONT) return true;\n\tif (p1p2p3 == COUNTER_CLOCKWISE && p1p2p4 == CLOCKWISE && p3p4p1 == CLOCKWISE && p3p4p2 == COUNTER_CLOCKWISE) return true;\n\tif (p1p2p3 == CLOCKWISE && p1p2p4 == COUNTER_CLOCKWISE && p3p4p1 == COUNTER_CLOCKWISE && p3p4p2 == CLOCKWISE) return true;\n\treturn false;\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\treturn (project(l, c.c) - c.c).norm() <= c.r*c.r;\n}\n\ndouble getDistance(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\nint main() {\n\tdouble cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tint q;\n\tcin >> q;\n\tCircle C;\n\tC.c.x = cx; C.c.y = cy; C.r = r;\n\tLine L;\n\tpair<Point, Point> crossPoints;\n\tdouble x1, y1, x2, y2;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> L.p1.x >> L.p1.y >> L.p2.x >> L.p2.y;\n\t\tcout << fixed << setprecision(15);\n\t\tcrossPoints = getCrossPoints(C, L);\n\t\tx1 = crossPoints.first.x;\n\t\ty1 = crossPoints.first.y;\n\t\tx2 = crossPoints.second.x;\n\t\ty2 = crossPoints.second.y;\n\t\tif (x1 < x2) {\n\t\t\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n\t\t}\n\t\telse if (x1 > x2) {\n\t\t\tcout << x2 << \" \" << y2 << \" \" << x1 << \" \" << y1 << endl;\n\t\t}\n\t\telse {\n\t\t\tif (y1 < y2) {\n\t\t\t\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n\t\t\t}\n\t\t\telse if (y1 > y2) {\n\t\t\t\tcout << x2 << \" \" << y2 << \" \" << x1 << \" \" << y1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n#define equals (fabs((a)-(b)<EPS)\nint n;\n\nstruct Point\n{\n    double x, y;\n    Point() {}\n    Point(double x,double y):x(x),y(y) {}\n    Point operator +(Point a)\n    {\n        return Point(x+a.x,y+a.y);\n    }\n    Point operator -(Point a)\n    {\n        return Point(x-a.x,y-a.y);\n    }\n    Point operator *(double a)\n    {\n        return Point(x*a,y*a);\n    }\n    Point operator /(double a)\n    {\n        return Point(x/a,y/a);\n    }\n\n    double norm()\n    {\n        return x*x+y*y;\n    }\n    double abs()\n    {\n        return sqrt(norm());\n    }\n\n};\n\ndouble r;\nPoint PO,p1,p2;\ndouble cross(Point a,Point b)\n{\n    return a.x*b.y-b.x*a.y;\n}\ndouble dot(Point a,Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\nPoint projection()\n{\n    Point a=p2-p1;\n    Point b=PO-p1;\n    double c_ab=cross(a,b);\n    double p1q=sqrt(b.norm()-c_ab*c_ab/a.norm());\n    return p1+a*p1q/a.abs();\n}\nvoid solve()\n{\n    Point a=p2-p1;\n    Point b=PO-p1;\n     double c_ab=cross(a,b);\n    double h2=c_ab*c_ab/a.norm();\n    double d=sqrt(r*r-h2);\n    Point q=projection();\n    Point e=a/a.abs();\n    Point x1=q-e*d;\n    Point x2=q+e*d;\n    printf(\"%.6lf %.6lf %.6lf %.6lf\\n\",x1.x,x1.y,x2.x,x2.y);\n\n\n\n}\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n\n    scanf(\"%lf%lf%lf\",&PO.x,&PO.y,&r);\n     scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p1.x,&p1.y,&p2.x,&p2.y);\n        solve();\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return  arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return  imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return  real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\nvector<C> crosspointCL(C c1,double r1,L l){\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s){\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(ccw(s[0],s[1],tmp[i]) == 0)   res.push_back(tmp[i]);\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2) {\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nint main()\n{\n    int x,y,z;\n    cin >> x >> y >> z;\n    int q;\n    cin >> q;\n    rep(i,q){\n        vector<C> vec;\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        vec = crosspointCL(C(x,y),z,L(C(a,b),C(c,d)));\n        sort(vec.begin(),vec.end());\n        printf(\"%.10f %.10f %.10f %.10f\\n\",vec[0].real(),vec[0].imag(),vec[1].real(),vec[1].imag());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst double EPS =  1e-10;\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point{\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y){}\n\n    Point operator + (Point p){\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator - (Point p){\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator * (Point p){\n        return Point(x * p.x, y * p.y);\n    }\n    Point operator * (double r){\n        return Point(x * r, y * r);\n    }\n    Point operator / (Point p){\n        return Point(x / p.x, y / p.y);\n    }\n    Point operator / (double d){\n        return Point(x / d, y / d);\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n    double norm(){\n        return x * x + y * y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n    \n    \n};\n\ntypedef Point Vector;\n\nclass Segment : public Point{\n    public:\n    Point p1, p2;\n    Segment(Point p1_, Point p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n    Segment(double a, double b, double c, double d){\n        Point(a, b);\n        Point(c, d);\n    }\n    \n};\n\ntypedef Segment Line;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c_, double r_){\n        c = c_;\n        r = r_;\n    }\n};\n\ndouble dot(Point a, Point b){\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(Point a, Point b){\n    return a.x * b.y - a.y * b.x;\n}\nbool isOrthogonal(Point a, Point b){\n    return equals(dot(a, b), 0.0);\n}\nbool isParallel(Point a, Point b){\n    return equals(cross(a, b), 0.0);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s1.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s1.p1), 0.0);\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    //Vector tmp = s.p1 + base * r;\n    Vector tmp = base * r;\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2;\n}\n\nint ccw(Point p1, Point p2, Point p3){\n    Vector a = p2 - p1;\n    Vector b = p3 - p1;\n    if( cross(a, b) > EPS ) return 1;\n    else if( cross(a, b) < -EPS ) return -1;\n    else if( dot(a, b) < -EPS ) return 2;\n    else if( a.norm() < b.norm() ) return -2;\n    //std::cout << std::fixed << std::setprecision(10) << ans.x << \" \" << ans.y << std::endl;\n    else return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\n\ndouble getDistance(Point a, Point b){\n    return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p){    \n    return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\n/*\nbool intersect(Circle c, Line l){\n    double d = getDistanceLP(l, c.c);\n    std::cout << d << std::endl;\n    if( (c.r - d) < EPS ){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n*/\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n    if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if( intersect(s1, s2) ) return 0.0;\n    return std::min(std::min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), std::min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nstd::pair<Point, Point> getCrossPoints(Circle c, Line l){\n    //assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt(c.r * c.r - (pr - c.c).norm());\n    return std::make_pair(pr + e * base, pr - e * base);\n\n}\n\nint main(void){\n    Point p0, p1, p2, p3;\n    Circle c;\n    std::cin >> c.c.x >> c.c.y >> c.r;\n    int q;\n    std::cin >> q;\n\n\n    for(int i = 0; i < q; i++){\n        std::cin >> p1.x >> p1.y >> p2.x >> p2.y;\n        Line l = Line(p1, p2);\n        std::pair<Point, Point> ans;\n        \n        ans = getCrossPoints(c, l);\n        Point ans1, ans2;\n        \n        if(ans.first.x > ans.second.x){\n            ans1 = ans.second;\n            ans2 = ans.first;\n        }else if(ans.first.x == ans.second.x){\n            if(ans.first.y > ans.second.y){\n                ans1 = ans.second;\n                ans2 = ans.first;\n            }else{\n                ans1 = ans.first;\n                ans2 = ans.second;\n            }\n        }else{\n            ans1 = ans.first;\n            ans2 = ans.second;\n        }\n        \n        std::cout << std::fixed << std::setprecision(10) << ans1.x << \" \" << ans1.y\\\n        << \" \" << ans2.x << \" \" << ans2.y << std::endl;\n        \n        \n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n//#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n//#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n             ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nint main(){\n    int n;\n    double cx, cy, r;\n    cin >> cx >> cy >> r >> n;\n\n    Circle c;\n    c.c = Point(cx, cy);\n    c.r = r;\n    while(n--){\n        double a[4];\n        rep(i,4) cin >> a[i];\n\n        pair<Point, Point> p;\n        p = getCrossPoints(c, Line{Point(a[0], a[1]), Point(a[2], a[3])});\n\n        vector<Point> v;\n        v.emplace_back(p.first);\n        v.emplace_back(p.second);\n        sort(all(v));\n        cout << fixed << setprecision(10);\n        cout << v[0].real() << ' ' << v[0].imag() << ' ';\n        cout << v[1].real() << ' ' << v[1].imag() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // 内積\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // 外積\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(const Point P, const Point Q){ this->pb(P);  this->pb(Q); }\n};\n\ninline Point projectionOfLP(Line L, Point P){return L[0]+(Point(P-L[0])).dot(L[0]-L[1])/norm(L[0]-L[1])*(L[0]-L[1]);}\ninline Point reflectionOfLP(Line L, Point P){return P+2.0*(projectionOfLP(L, P)-P);}\ninline bool intersectionDeterminationOfLL(Line L, Line M){return abs(Point(L[1]-L[0]).det(M[1]-M[0]))>EPS||abs(Point(L[1]-L[0]).det(M[0]-L[0]))<EPS;}\ninline bool intersectionDeterminationOfLS(Line L, Line S){return(Point(L[1]-L[0]).det(S[0]-L[0]))\n*(Point(L[1]-L[0]).det(S[1]-L[0]))<EPS;}\ninline bool intersectionDeterminationOfLP(Line L, Point P){return abs(Point(L[1]-P).det(L[0]-P))<EPS;}\ninline bool intersectionDeterminationOfSS(Line S, Line T){return ccw(S[0],S[0],T[0])*ccw(S[0],S[1],T[1])<=0&&ccw(T[0],T[1],S[0])*ccw(T[0],T[1],S[1])<=0;}\ninline bool intersectionDeterminationOfSP(Line S, Point P){return abs(S[0]-P)+abs(S[1]-P)-abs(S[1]-S[0])<EPS;}\ninline double distanceOfLP(Line L, Point P){return abs(P-projectionOfLP(L,P));}\ninline double distanceOfLL(Line L, Line M){return intersectionDeterminationOfLL(L,M)?0.0:distanceOfLP(L,M[0]);}\ninline double distanceOfLS(Line L, Line S){return intersectionDeterminationOfLS(L,S)?0.0:min(distanceOfLP(L,S[0]),distanceOfLP(L,S[1]));}\ninline double distanceOfSP(Line S, Point P){Point r=projectionOfLP(S,P);return intersectionDeterminationOfSP(S,r)?abs(r-P):min(abs(S[0]-P),abs(S[1]-P));}\ninline double distanceOfSS(Line S, Line T){return intersectionDeterminationOfSS(S,T)?0.0:min(min(distanceOfSP(S,T[0]),distanceOfSP(S,T[1])),min(distanceOfSP(T,S[0]),distanceOfSP(T,S[1])));}\nPoint intersectionOfLL(Line L, Line M){\n  double A = Point(L[1]-L[0]).det(M[1]-M[0]);\n  double B = Point(L[1]-L[0]).det(L[1]-M[0]);\n  if(abs(A)<EPS && abs(B)<EPS) return M[0];\n  if(abs(A)<EPS) assert(false);\n  return M[0] + B / A * (M[1] - M[0]);\n}\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\n// 円と直線との交点を重複を許して丁度２つ返す。交わらないときは直線と円の中心との距離で事前に判定\nvector<Point> intersectionOfCL(Circle C, Line L)\n{\n  double r = C.radius();\n  Point H = projectionOfLP(L, C.center());\n  double d = abs(H - C.center());\n  double l = sqrt(r * r - d * d);\n  vector<Point> ret(2);\n  Point v = (L[1] - L[0]) / abs(L[1] - L[0]);\n  ret[0] = Point(H + l * v);\n  ret[1] = Point(H - l * v);\n  return ret;\n}\n\ndouble x, y, r;\nint q;\n\nint main()\n{\n  cin >> x >> y >> r;\n  Circle C = Circle(x, y, r);\n\n  cin >> q;\n  while(q--){\n    cin >> x >> y;\n    Point A = Point(x, y);\n    cin >> x >> y;\n    Point B = Point(x, y);\n    Line L = Line(A, B);\n    vector<Point> res = intersectionOfCL(C, L);\n    sort(ALL(res));\n    printf(\"%.15f %.15f %.15f %.15f\\n\", res[0].real(), res[0].imag(), res[1].real(), res[1].imag());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\n// circle\nstruct C {\n\tP p; double r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint intersectCC(const C& a, const C& b) {\n\tdouble dist = sqrt(norm(a.p-b.p)), r1 = a.r + b.r, r2 = abs(a.r - b.r);\n\tif(r1 < dist) return 4;\t\t//??\\?????????\n\tif(dist == r1) return 3;\t//?????\\\n\tif(r2 < dist && dist < r1) return 2; //?????????\n\tif(dist == r2) return 1; //?????\\\n\treturn 0;\t//??????\n}\n\nvector<P> crossPointCL(C c, L l) {\n\tdouble d = distanceLP(l, c.p), r = c.r;\n\tP m = projection(l, c.p);\n\tP x = sqrt(r*r-d*d)/abs(l[1]-l[0])*(l[1]-l[0]);\n\tvector<P> ret(2,m);\n\tret[0] -= x;\n\tret[1] += x;\n\treturn ret;\n}\n\nint main() {\n\tdouble x1, y1, r1;\n\tcin >> x1 >> y1 >> r1;\n\tC c1(P{x1, y1}, r1);\n\tint q;\n\tcin >> q;\n\tfor(int i=0; i<q; ++i) {\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tL l(P{x1, y1}, P{x2, y2});\n\t\tvector<P> ans = crossPointCL(c1, l);\n\t\tsort(ans.begin(), ans.end());\n\t\tcout << fixed << setprecision(15) << ans[0].real() << \" \" << ans[0].imag() << \" \" << ans[1].real() << \" \" << ans[1].imag() << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n#define all(c) (c).begin(),(c).end()\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  bool operator < (Point p)const{return (p.x!=x)?x<p.x:y<p.y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  //点pを中心に角度r(radius)だけ半時計回りに回転する\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n\n//a -> b -> c\nint ccw(Point a, Point b, Point c) {\n  b = b-a; c = c-a;\n\n  if (b.cross(c) > 0)   return +1;       // counter clockwise\n  if (b.cross(c) < 0)   return -1;       // clockwise\n  if (b.dot(c) < 0)     return +2;       // c--a--b on line\n  if (b.norm() < c.norm()) return -2;    // a--b--c on line\n  return 0;                              // a--c--b on line\n}\n\nstruct Line{\n  Point a,b;\n\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n\n  bool on(Point c){return abs(ccw(a,b,c))!=1;}\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n};\n\nstruct Circle{\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(Point p, Real r) : p(p) , r(r){}\n  \n  vector<Point> intersectionPoints(Line l){\n    Real a=l.b.y-l.a.y,b=l.a.x-l.b.x;\n    Real c=-(a*l.a.x+b*l.a.y);\n\n    Real L=l.a.dist(l.b);\n    Point e=(l.b-l.a)/L;\n    Point v(-e.y,e.x);\n    Real k=-(a*p.x+b*p.y+c)/(a*v.x+b*v.y);\n\n    if(r<k)vector<Point>();\n    Point q=p+v*k;\n    Real S=sqr(r*r-k*k);\n    vector<Point>res;\n    res.push_back(q+e*S);\n    res.push_back(q-e*S);\n    return res;\n  }\n  \n};\n\nint main(void){\n\n  Circle c;\n  cin >> c.p.x >> c.p.y >> c.r;\n  int q;\n  cin >> q;\n  while(q--){\n    Line l;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n    vector<Point>res=c.intersectionPoints(l);\n    sort(all(res));\n    printf(\"%.8f %.8f \",res[0].x,res[0].y);\n    printf(\"%.8f %.8f \",res[1].x,res[1].y);\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tld d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nint main()\n{\n\tint q;\n\tld x, y, r, x1, x2, y1, y2;\n\tcout << fixed << setprecision(9);\n\tcin >> x >> y >> r;\n\tCircle c = { (Point) { x, y }, r };\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tLine l = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tauto res = is_lc(c, l);\n\t\tsort(res.begin(), res.end(), [](const Point& l, const Point& r) { return l.real() < r.real() ? true : l.real() == r.real() && l.imag() < r.imag() ? true : false; });\n\t\tcout << res[0].real() << ' ' << res[0].imag() << ' ' << res[1].real() << ' ' << res[1].imag() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <utility>\n#include <cassert>\n\nconst double EPS=1e-10;\n\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Vector a,Vector b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base) / norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p+(project(s,p)-p)*2.0;\n}\n\nenum CCW {\n    COUNTER_CLOCKWISE=1,\n    CLOCKWISE=-1,\n    ONLINE_BACK=2,\n    ONLINE_FRONT=-2,\n    ON_SEGMENT=0,\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return CCW::COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CCW::CLOCKWISE;\n    if(dot(a,b)<-EPS) return CCW::ONLINE_BACK;\n    if(norm(a)<norm(b)) return CCW::ONLINE_FRONT;\n\n    return CCW::ON_SEGMENT;\n}\n\ndouble getDistance(Point a,Point b) {\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2) {\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\nbool intersect(Circle c,Line l) {\n    double d=getDistanceLP(l,c.c);\n    return !(d>c.r);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2) {\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n\n    return make_pair(pr+e*base,pr-e*base);\n\n}\n\nint main() {\n    double cx,cy,r;\n    cin>>cx>>cy>>r;\n    Circle circle({Point(cx,cy),r});\n    int q; cin>>q;\n    while(q-->0) {\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        Line l=Line({Point(x1,y1),Point(x2,y2)});\n\n        auto ans=getCrossPoints(circle,l);\n        vector<pair<double,double>> vec;\n        vec.push_back(make_pair(ans.first.X,ans.first.Y));\n        vec.push_back(make_pair(ans.second.X,ans.second.Y));\n        sort(vec.begin(),vec.end());\n        printf(\"%.10f %.10f \",vec[0].first,vec[0].second);\n        printf(\"%.10f %.10f\\n\",vec[1].first,vec[1].second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; } // cross product\n    db operator * (const point &p){ return x * p.x + y * p.y; } // dot product\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n    point unit(){ db k = (*this).len(); return point(x / k, y / k); }\n};\n\npoint err = point(INF_d, INF_d);\ndb rad(point A, point B){ return atan2((A ^ B), (A * B)); }// the ang(in rad) of two vectors A and B\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){ // find the distance of cloest pair of points in p\n//please make sure that p is sorted by x coordinate | sort(p, p + n, cmpxy);\n//this is nlognlogn, if need nlogn, replace the sort with a merge sort.\n    if (r - l <= 5){ db cloest = INF_d;\n        for (int i = l; i < r; i++) for (int j = i + 1; j < r; j++) cloest = min(cloest, (p[i] - p[j]).len());\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1; db cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid, r));\n        vector<point> v; v.clear();\n        for (int i = l; i < r; i++) if (fabs(p[i].x - p[mid].x) <= cloest) v.pb(p[i]); sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++) for (int j = i + 1; j < SZ(v) && dcmp(v[j].y - v[i].y - cloest) < 0; j++)\n                cloest = min(cloest, (v[i] - v[j]).len());\n        return cloest;\n    }\n}\n\nstruct circle{\n    point o; double r;\n    circle(){}\n    circle(point a, double b): o(a), r(b){}\n    void read(){\n        o.read(), scanf(\"%lf\", &r);\n    }\n    int inside(point p){ // 1: inside, 2: on the circle, 0: outside\n        int sgn = dcmp((o - p).len() - r) < 0; if (sgn < 0) return 1; if (!sgn) return 2; return 0;\n    }\n};\n\nint check_CC(circle C1, circle C2){ // return the number of common tangents of two circles C1 and C2\n//4: xiang_li, 3: wai_qie, 2: xiang_jiao, 1: nei_qie, 0: nei_han\n    db d =(C1.o - C2.o).len();\n    if (dcmp(d - C1.r - C2.r) > 0) return 4;\n    if (!dcmp(d - C1.r - C2.r)) return 3;\n    if (!dcmp(d - fabs(C1.r - C2.r))) return 1;\n    if (dcmp(d - fabs(C1.r - C2.r)) > 0 && dcmp(d - C1.r - C2.r) < 0) return 2;\n    return 0;\n}\n\nvector<point> inter_CL(circle C, point A, point B){ // return the intersection of a circle and a line\n// the result give in the direction from A -> B\n    point p_proj = proj_SP(A, B, C.o);\n    db d = C.r * C.r - (C.o - p_proj).len2();\n    if (dcmp(d) < 0) return {};\n    point delta = (B - A).unit() * sqrt(max((db)0, d)); return {p_proj - delta, p_proj + delta};\n}\n\nvector<point> inter_CL(circle C, line L){ // the same as the former one, but argument is different\n    return inter_CL(C, L.p[0], L.p[1]);\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\ncircle cir[2];\n\nint main(){\n    cir[0].read();\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        x.read(), y.read();\n        vector<point> itp = inter_CL(cir[0], x, y);\n        if (dcmp(itp[0].y - itp[1].y) > 0) swap(itp[0], itp[1]);\n        printf(\"%.10f %.10f %.10f %.10f\\n\", itp[0].x, itp[0].y, itp[1].x, itp[1].y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\tdouble cx,cy,r,x1,x2,y1,y2,slope,cross_x,cross_y,h,k,div_x,div_y;\n\tint q;\n\tbool X_FLG,Y_FLG;\n\n\tscanf(\"%lf %lf %lf\",&cx,&cy,&r);\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf\",&x1,&y1,&x2,&y2);\n\n\t\tX_FLG = false,Y_FLG = false;\n\n\t\tif(y1 == y2){\n\t\t\tX_FLG = true;\n\t\t}else if(x1 == x2){\n\t\t\tY_FLG = true;\n\t\t}else{\n\t\t\tslope = (y2-y1)/(x2-x1);\n\t\t}\n\n\t\tif(X_FLG){\n\t\t\tcross_x = cx;\n\t\t\tcross_y = y1;\n\t\t}else if(Y_FLG){\n\t\t\tcross_x = x1;\n\t\t\tcross_y = cy;\n\t\t}else{\n\t\t\tcross_x = (cy*(x2-x1)*(y2-y1)+cx*(x2-x1)*(x2-x1)-y1*(y2-y1)*(x2-x1)+x1*(y2-y1)*(y2-y1))/((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1));\n\t\t\tcross_y = ((x1-x2)*cross_x+cy*(y2-y1)+cx*(x2-x1))/(y2-y1);\n\t\t}\n\n\t\th = sqrt((cx - cross_x)*(cx-cross_x)+(cy-cross_y)*(cy-cross_y));\n\t\tk = sqrt(r*r-h*h);\n\n\t\tif(X_FLG){\n\t\t\tprintf(\"%lf %lf %lf %lf\\n\",cross_x - k,y1,cross_x+k,y1);\n\t\t}else if(Y_FLG){\n\t\t\tprintf(\"%lf %lf %lf %lf\\n\",x1,cross_y-k,x1,cross_y+k);\n\t\t}else{\n\t\t\tdiv_x = k*(x2-x1)/(fabs(x2-x1));\n\t\t\tdiv_y = k*(y2-y1)/(fabs(y2-y1));\n\t\t\tprintf(\"%lf %lf %lf %lf\\n\",cross_x-div_x,cross_y-div_y,cross_x + div_x,cross_y+div_y);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n    double x, y;\n\n    Point(double x_ = 0, double y_ = 0){\n        x = x_;\n        y = y_;\n    }\n\n    Point operator+ (Point p){\n        return Point(x + p.x, y + p.y);\n    };\n\n    Point operator- (Point p){\n        return Point(x - p.x, y - p.y);\n    };\n\n    Point operator* (double k){\n        return Point(x * k, y * k);\n    }\n\n    Point operator/ (double k){\n        return Point(x / k, y / k);\n    }\n\n    double norm(){\n        return x * x + y * y;\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Seg{\npublic:\n    Point p1;\n    Point p2;\n    Seg(Point p1_, Point p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n};\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\n;\ndouble getCos(Vector a, Vector b){\n    return dot(a, b) / (a.abs() * b.abs());\n}\n\ndouble dist(Point p1, Point p2){\n    return sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n}\n\nPoint project(Seg s, Point p0){\n    if(s.p1 == p0){\n        return p0;\n    }\n    if(s.p2 == p0){\n        return p0;\n    }\n    return s.p1 + (s.p2 - s.p1) / (s.p2 - s.p1).abs() * (p0 - s.p1).abs() * getCos(s.p2 - s.p1, p0 - s.p1);\n}\n\nPoint reflect(Seg s, Point p0){\n    Point p = project(s, p0);\n    return p0 + (p - p0) * 2;\n}\n\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nint counterClockwise(Point p0, Point p1, Point p2){\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n    if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(v1, v2) < -EPS) return CLOCKWISE;\n    if(dot(v1, v2) < -EPS) return ONLINE_BACK;\n    if(v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Seg s1, Seg s2){\n    int t1 = counterClockwise(s1.p1, s1.p2, s2.p1);\n    int t2 = counterClockwise(s1.p1, s1.p2, s2.p2);\n    int t3 = counterClockwise(s2.p1, s2.p2, s1.p1);\n    int t4 = counterClockwise(s2.p1, s2.p2, s1.p2);\n    if(t1 * t2 <= 0){\n        if(t3 * t4 <= 0){\n            return true;\n        }\n    }\n    return false;\n}\n\ndouble getDistanceLP(Seg s, Point p0){\n    return (project(s, p0) - p0).abs();\n}\n\ndouble getDistanceSP(Seg s, Point p0){\n    if(dot(s.p2 - s.p1, p0 - s.p1) < 0.0) return (p0 - s.p1).abs();\n    if(dot(s.p1 - s.p2, p0 - s.p2) < 0.0) return (p0 - s.p2).abs();\n    return (project(s, p0) -  p0).abs();\n}\n\ndouble getDistance(Seg s1, Seg s2){\n    if(intersect(s1, s2)){\n        return 0.0;\n    }\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n                min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint crossPoint(Seg s1, Seg s2){\n    double d1 = getDistanceLP(s2, s1.p1);\n    double d2 = getDistanceLP(s2, s1.p2);\n\n    return (s1.p2 * d1 + s1.p1 * d2) / (d1 + d2);\n}\n\npair<Point, Point> getCrossPoints(Point x, double r, Seg s){\n    double d1 = getDistanceLP(s, x);\n    double d2 = sqrt(pow(r, 2) - pow(d1, 2));\n\n    Point p1 = project(s, x);\n    Vector v1 = s.p2 - s.p1;\n\n    Point cp1 = p1 + v1 / v1.abs() * d2;\n    Point cp2 = p1 - v1 / v1.abs() * d2;\n\n    if(cp1.x < cp2.x){\n        return make_pair(cp1, cp2);\n    }else if(cp1.x > cp2.x){\n        return make_pair(cp2, cp1);\n    }else{\n        return cp1.y < cp2.y ? make_pair(cp1, cp2) : make_pair(cp2, cp1);\n    }\n\n}\n\nint main(){\n    int cx, cy, r, q;\n    scanf(\"%d\", &cx);\n    scanf(\"%d\", &cy);\n    scanf(\"%d\", &r);\n    scanf(\"%d\", &q);\n\n    Point x = Point(cx, cy);\n\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n\n        pair<Point, Point> ps = getCrossPoints(x, r, Seg(Point(xp0, yp0), Point(xp1, yp1)));\n\n        printf(\"%.10f %.10f %.10f %.10f\\n\", ps.first.x, ps.first.y, ps.second.x, ps.second.y);\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\n// VP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// // cross point between circles Verify AOJ CGL_7_E\n// VP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n/*\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}*/\n\nVP pcl(C c, L l) {\n    P h=proj(l,c.c);\n    P e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n    return VP{h-e,h+e};\n}\nVP pcc(C a,C b){\n    P d=b.c-a.c;\n    P w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n    P e=w*P(0,1);\n    return pcl(a,{w-e,w+e}); \n}\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n    int q;\n    C c;\n    {\n\t\tR x,y,r;\n\t\tcin >> x >> y >> r;\n\t\tc=C({P(x,y),R(r)});\n\t}\n         \n    cin >> q;\n    cout.precision(20);\n    rep(i,q){\n        L l;\n        {\n\t\t\tR x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n        VP res=pcl(c,l);\n        if(real(res[0])>real(res[1])) swap(res[0],res[1]);\n        if(real(res[0])==real(res[1])&&imag(res[0])>imag(res[1])) swap(res[0],res[1]);\n        cout << fixed << res[0] << \" \" << res[1] << endl;\n    }\n    return 0;\n}\n\n\n/*int main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0.0, double y = 0.0) :\n\t\t\tx(x), y(y) {\n\t}\n\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(double k) {\n\t\treturn Point(x * k, y * k);\n\t}\n\tPoint operator /(double k) {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator <(Point p) {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator ==(Point p) {\n\t\treturn equals(x, p.x) && equals(y, p.y);\n\t}\n};\ntypedef Point Vector;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\ntypedef Segment Line;\n\ndouble dot(Vector v1, Vector v2) {\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\ndouble cross(Vector v1, Vector v2) {\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\nVector unitVector(Vector v) {\n\treturn v / v.abs();\n}\nbool isOrthogonal(Vector v1, Vector v2) {\n\treturn equals(dot(v1, v2), 0.0);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isOrthogonal(Point l1, Point l2, Point m1, Point m2) {\n\treturn isOrthogonal(l2 - l1, m2 - m1);\n}\nbool isParallel(Vector v1, Vector v2) {\n\treturn equals(cross(v1, v2), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Point l1, Point l2, Point m1, Point m2) {\n\treturn isParallel(l1 - l2, m1 - m2);\n}\n\nenum PositionSP {\n\tCOUNTER_CLOCKWISE = -1,\n\tCLOCKWISE = 1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nPositionSP ccw(Point p1, Point p2, Point p) {\n\tVector a = p2 - p1, b = p - p1;\n\tif (cross(a, b) > EPS)\n\t\treturn COUNTER_CLOCKWISE;\n\telse if (cross(a, b) < -EPS)\n\t\treturn CLOCKWISE;\n\telse if (dot(a, b) < -EPS)\n\t\treturn ONLINE_BACK;\n\telse if (a.norm() < b.norm())\n\t\treturn ONLINE_FRONT;\n\telse\n\t\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n\t\t\t&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint intersection(Segment s1, Segment s2) {\n\tdouble d1 = abs(cross(s2.p2 - s2.p1, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(s2.p1 - s2.p2, s1.p2 - s2.p2));\n\treturn s1.p1 + (s1.p2 - s1.p1) * d1 / (d1 + d2);\n}\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\ndouble distancePP(Point p1, Point p2) {\n\treturn (p1 - p2).abs();\n}\ndouble distanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / distancePP(l.p2, l.p1));\n}\ndouble distanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t\treturn distancePP(s.p1, p);\n\telse if (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t\treturn distancePP(s.p2, p);\n\telse\n\t\treturn distanceLP(s, p);\n}\ndouble distanceSS(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))\n\t\treturn 0.0;\n\telse {\n\t\treturn min(min(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\t\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)));\n\t}\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :\n\t\t\tc(c), r(r) {\n\t}\n};\npair<Point, Point> intersection(Circle c, Line l) {\n\tPoint pr = projection(l, c.c);\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\tVector e = unitVector(l.p2 - l.p1);\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n\tCircle C;\n\tcin >> C.c.x >> C.c.y >> C.r;\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tLine l;\n\t\tcin >> l.p1.x >> l.p1.y;\n\t\tcin >> l.p2.x >> l.p2.y;\n\t\tpair<Point, Point> x = intersection(C, l);\n\t\tif (x.first < x.second) {\n\t\t\tcout << fixed << setprecision (10) << x.first.x << \" \" << x.first.y << \" \";\n\t\t\tcout << x.second.x << \" \" << x.second.y << endl;\n\t\t} else {\n\t\t\tcout << fixed << setprecision (10) << x.second.x << \" \" << x.second.y << \" \";\n\t\t\tcout << x.first.x << \" \" << x.first.y << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nnamespace geometry2d {\n\n\t//eps　浮動小数点誤差\n\tconst double EPS = 1e-10;\n\n\t//a > 0ならば+1, a == 0ならば0, a < 0ならば-1　を返す。　基本的にEPS込みの評価はこれで行う。\n\t//不等式は、加減算に直してこれに適用する。\n\tint sgn(const double a) {\n\t\treturn (a < -EPS ? -1 : (a > EPS ? +1 : 0));\n\t}\n\n\tstruct Point {\n\t\t//2次元ベクトルのクラス\n\n\t\tdouble x, y;\n\t\tPoint(double _x, double _y) {\n\t\t\tx = _x, y = _y;\n\t\t}\n\t\tPoint() {\n\t\t\tx = 0, y = 0;\n\t\t}\n\n\t\tPoint operator+() const {\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator-() const {\n\t\t\treturn{ -x, -y };\n\t\t}\n\t\tPoint operator+ (const Point& b) const {\n\t\t\treturn{ x + b.x, y + b.y };\n\t\t}\n\t\tPoint operator- (const Point& b) const {\n\t\t\treturn{ x - b.x, y - b.y };\n\t\t}\n\t\tPoint operator* (const double b) const {\n\t\t\treturn{ x * b, y * b };\n\t\t}\n\t\tPoint operator/ (const double b) const {\n\t\t\treturn{ x / b, y / b };\n\t\t}\n\t\tPoint operator+= (const Point& b) {\n\t\t\tx += b.x, y += b.y;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator-= (const Point& b) {\n\t\t\tx -= b.x, y -= b.y;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator*= (const double b) {\n\t\t\tx *= b, y *= b;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator/= (const double b) {\n\t\t\tx /= b, y /= b;\n\t\t\treturn *this;\n\t\t}\n\t\tbool operator== (const Point& b) {\n\t\t\treturn b.x == x && b.y == y;\n\t\t}\n\n\t\tdouble lengthSquare() const {\n\t\t\treturn (x * x + y * y);\n\t\t}\n\t\tdouble length() const {\n\t\t\treturn std::sqrt(lengthSquare());\n\t\t}\n\t\tdouble dot(const Point& b) const {\n\t\t\treturn x * b.x + y * b.y;\n\t\t}\n\t\tdouble cross(const Point& b) const {\n\t\t\t//Generally, cross product is vector, but in 2D, cross product is also scalar.\n\t\t\treturn x * b.y - y * b.x;\n\t\t}\n\t\tdouble distanceFrom(const Point& b) const {\n\t\t\treturn std::sqrt((x - b.x) * (x - b.x) + (y - b.y) * (y - b.y));\n\t\t}\n\t\tPoint normalized() const {\n\t\t\treturn{ x / length(), y / length() };\n\t\t}\n\t\tbool isZero() const {\n\t\t\treturn sgn(x) == 0 && sgn(y) == 0;\n\t\t}\n\t\t//単位法線ベクトル\n\t\tPoint normalUnitVector() const {\n\t\t\treturn{ -normalized().y, normalized().x };\n\t\t}\n\t\t//(0, 0)中心にarg(弧度法)回転した座標\n\t\tPoint rotation(double arg) const {\n\t\t\tdouble cs = cos(arg), sn = sin(arg);\n\t\t\treturn Point(x * cs - y * sn, x * sn + y * cs);\n\t\t}\n\t\t//(0, 0)中心の円上に乗ってるとしたときの、偏角\n\t\tdouble angle() const {\n\t\t\treturn atan2(y, x);\n\t\t}\n\t};\n\n\tinline Point operator*(double a, const Point& b) {\n\t\treturn{ b.x * a, b.y * a };\n\t}\n\n\ttemplate <class Char>\n\tinline std::basic_ostream<Char>& operator <<(std::basic_ostream<Char>& os, const Point& v)\n\t{\n\t\treturn os << Char('(') << v.x << Char(',') << v.y << Char(')');\n\t}\n\n\ttemplate <class Char>\n\tinline std::basic_istream<Char>& operator >> (std::basic_istream<Char>& is, Point& v)\n\t{\n\t\treturn is >> v.x >> v.y;\n\t}\n\n\t//幾何ライブラリにおいて、解なしのような状態の時に返される点の値\n\tconst Point error_val = { 114514.0, -191981.0 };\n\n\tinline bool operator==(const Point& a, const Point& b) {\n\t\treturn (sgn(a.x - b.x) == 0 && sgn(a.y - b.y) == 0);\n\t}\n\n\t//第一にx, 第二にyを小さい順にソートするためのオーバーロード\n\tinline bool operator<(const Point& a, const Point& b) {\n\t\tif (sgn(a.x - b.x) != 0)return sgn(a.x - b.x) < 0;\n\t\telse return sgn(a.y - b.y) < 0;\n\t}\n\n\t/*\n\t3点A, B, Cの位置関係を返す関数 A, Bがすべて異なった点であるのが前提\n\t//ABから見てBCは左に曲がるのなら +1\n\t//ABから見てBCは右に曲がるのなら -1\n\t//ABC(CBA)の順番で一直線上に並ぶなら +2\n\t//ACB(BCA)の順番で一直線上に並ぶなら 0\n\tBAC(CAB)の順番で一直線上に並ぶなら -2\n\t*/\n\tint iSP(const Point& a, const Point& b, const Point& c) {\n\t\tint flg = sgn((b - a).cross(c - a));\n\t\tif (flg == 1) {\n\t\t\treturn +1;\n\t\t}\n\t\telse if (flg == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\t//ABC(CBA)\n\t\t\tif (sgn((b - a).dot(c - b)) > 0)\n\t\t\t\treturn +2;\n\t\t\t//BAC(CAB)\n\t\t\telse if (sgn((a - b).dot(c - a)) > 0)\n\t\t\t\treturn -2;\n\t\t\t//ACB(BCA)　CがA or Bと一致しても、こっちに含まれる。\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t//直線に関する操作や判定\n\tnamespace line2d {\n\n\t\t//向きつき直線を想定。Segment\n\t\tstruct Line {\n\n\t\t\t//直線の通る二点。有向直線でないのならば、beginやendに違いはない。\n\t\t\tPoint begin, end;\n\n\t\t\tLine() {\n\t\t\t\tbegin = Point(), end = Point();\n\t\t\t}\n\n\t\t\tLine(const Point& b, const Point& e) {\n\t\t\t\tbegin = b, end = e;\n\t\t\t}\n\n\t\t\t//ax+by+c=0\n\t\t\tLine(const double a, const double b, const double c) {\n\t\t\t\tif (sgn(a) == 0 && sgn(b) == 0) {\n\t\t\t\t\tassert(-1);\n\t\t\t\t}\n\n\t\t\t\tif (sgn(b) == 0) {\n\t\t\t\t\t//ax+c=0になる。\n\t\t\t\t\tbegin = Point(-c / a, 0.0);\n\t\t\t\t\tend = Point(-c / a, 1.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//y=-(ax+c)/b　傾きは-a/bで、y切片が-c/b\n\t\t\t\t\tbegin = Point(0, -c / b);\n\t\t\t\t\tend = Point(1.0, -(a + c) / b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPoint vec() const {\n\t\t\t\treturn end - begin;\n\t\t\t}\n\n\t\t\tPoint countervec() const {\n\t\t\t\treturn begin - end;\n\t\t\t}\n\n\t\t};\n\n\n\t\t//線分の場合、Lineと同じものになるが、はっきりと区別する\n\t\ttypedef Line Segment;\n\n\n\t\t//直線の交点を返す。交わってなければ、error_valを返す。\n\t\tPoint lineIntersection(const Line& l1, const Line& l2) {\n\t\t\tif (sgn(l1.vec().cross(l2.vec())) == 0)return error_val;\n\n\t\t\tPoint ret;\n\t\t\tret = l1.begin + l1.vec() *\n\t\t\t\tabs((l2.end - l1.begin).cross(l2.vec()) / l1.vec().cross(l2.vec()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t//線分が共通部分を持つかどうか？と線分の交点を返す。共通部分がない、もしくは交点が一意ではないなら、error_valを返す。\n\t\t//trueなら、共通部分を持つ。falseなら、共通部分を持たない。\n\t\tpair<bool, Point> segmentIntersection(const Segment& s1, const Segment& s2) {\n\n\t\t\tif (iSP(s1.begin, s1.end, s2.begin) * iSP(s1.begin, s1.end, s2.end) <= 0 &&\n\t\t\t\tiSP(s2.begin, s2.end, s1.begin) * iSP(s2.begin, s2.end, s1.end) <= 0) {\n\n\t\t\t\t//平行ならば、交点は定まらない。(完全に重なってるので)\n\t\t\t\tif (s1.vec().cross(s2.vec()) == 0)\n\t\t\t\t\treturn make_pair(true, error_val);\n\t\t\t\telse //そうでないのなら、lineIntersection()で交点を返しておく。\n\t\t\t\t\treturn make_pair(true, lineIntersection(s1, s2));\n\n\t\t\t}\n\t\t\treturn make_pair(false, error_val);\n\t\t}\n\n\n\t\t//点と直線の距離。引数は、点、直線上の2点\n\t\tdouble distanceBetweenPointAndLine(const Point& p, const Line& l) {\n\t\t\treturn abs(l.vec().cross(p - l.begin) / l.vec().length());\n\t\t}\n\n\t\t//点と線分の距離。引数は、点、線分の両端\n\t\tdouble distanceBetweenPointAndSegment(const Point& p, const Segment& s) {\n\t\t\tif (sgn(s.vec().dot(p - s.begin)) < 0 || sgn(s.countervec().dot(p - s.end)) < 0) {\n\t\t\t\t//下した垂線は線分の上にはない\n\t\t\t\treturn min(p.distanceFrom(s.begin), p.distanceFrom(s.end));\n\t\t\t}\n\t\t\treturn distanceBetweenPointAndLine(p, s);\n\t\t}\n\n\t\t//二線分間の距離\n\t\tdouble distanceBetweenSegmentAndSegment(const Segment& s1, const Segment& s2) {\n\t\t\tif (segmentIntersection(s1, s2).first)return 0;//交点を持つ\n\n\t\t\tdouble ans = distanceBetweenPointAndSegment(s1.begin, s2);\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s1.end, s2));\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s2.begin, s1));\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s2.end, s1));\n\t\t\treturn ans;\n\t\t}\n\n\t\t//正射影\n\t\t//引数は点A, B, Cで、BAベクトルの直線BC上の正射影を求める。\n\t\tPoint projection(const Point& a, const Line& l) {\n\t\t\tPoint ret;\n\t\t\tret = l.begin +\n\t\t\t\tl.vec().normalized() * (a - l.begin).dot(l.vec()) / l.vec().length();\n\t\t\treturn ret;\n\t\t}\n\n\t\t//鏡映変換。引数は点A, B, Cで、直線BCにおいて、Aと線対称な点を求める。\n\t\tPoint reflection(const Point& a, const Line& l) {\n\t\t\tPoint ret;\n\t\t\tret = a + 2 * (projection(a, l) - a);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tnamespace circle2d {\n\n\t\tstruct Circle {\n\t\t\tPoint center;\n\t\t\tdouble r;\n\t\t\t\n\t\t\tCircle() {\n\t\t\t\tcenter = Point();\n\t\t\t\tr = 0;\n\t\t\t}\n\n\t\t\tCircle(const Point& C, const double& R) {\n\t\t\t\tcenter = C, r = R;\n\t\t\t}\n\t\t};\n\n\t\t//直線と円の交点を返す。1つ目のbool値は、trueなら交わっている、falseならば交わってない。\n\t\t//falseならば、2つ目のペアは共にerror_valとなる。\n\t\t//trueならば、2つ交点を返す。(1つしか持たない場合でも、2つ同じものを返す)\n\t\tpair<bool, pair<Point, Point>> lineAndCircleIntersection(const Circle& c, const line2d::Line& l) {\n\t\t\t//交点を持たない\n\t\t\tif (sgn(line2d::distanceBetweenPointAndLine(c.center, l) - c.r) > 0) {\n\t\t\t\treturn make_pair(false, make_pair(error_val, error_val));\n\t\t\t}\n\t\t\telse if (sgn(line2d::distanceBetweenPointAndLine(c.center, l)) == 0) {\n\t\t\t\t//中心を通るなら\n\t\t\t\tpair<Point, Point> ret;\n\t\t\t\tret.first = c.center + l.vec().normalized() * c.r;\n\t\t\t\tret.second = c.center - l.vec().normalized() * c.r;\n\t\t\t\treturn make_pair(true, ret);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t//垂線の足\n\t\t\t\tPoint H = line2d::projection(c.center, l);\n\t\t\t\tpair<Point, Point> ret;\n\n\t\t\t\tret.first = H + (c.center - H).normalUnitVector() *\n\t\t\t\t\tsqrt(max(0.0, pow(c.r, 2) - pow(line2d::distanceBetweenPointAndLine(c.center, l), 2)));\n\t\t\t\tret.second = H - (c.center - H).normalUnitVector() *\n\t\t\t\t\tsqrt(max(0.0, pow(c.r, 2) - pow(line2d::distanceBetweenPointAndLine(c.center, l), 2)));\n\t\t\t\treturn make_pair(true, ret);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\nint main() {\n\tgeometry2d::circle2d::Circle c;\n\tcin >> c.center >> c.r;\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tgeometry2d::line2d::Line l;\n\t\tcin >> l.begin >> l.end;\n\n\t\tauto ret = geometry2d::circle2d::lineAndCircleIntersection(c, l);\n\t\tvector <geometry2d::Point> ans;\n\t\tans.push_back(ret.second.first), ans.push_back(ret.second.second);\n\t\tsort(ans.begin(), ans.end());\n\t\tcout << fixed << setprecision(10) << ans[0].x << \" \" << ans[0].y << \" \" << ans[1].x << \" \" << ans[1].y << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\n\nusing R = long double;\nusing P = complex<R>;\nusing L = pair<P,P>;\nusing G = vector<P>;\nstruct C {\n  P c; R r;\n  C() {}\n  C(const P &a, const R &b) : c(a), r(b) {}\n};\nstruct S : public L {\n  S() {}\n  S(const P &a, const P &b) : L(a,b) {}\n};\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\ninline R dot(const P& a, const P& b) {\n  return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n  return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) ? real(a-b) < 0 : sgn(imag(a-b)) < 0;\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) == 0 && sgn(imag(a-b)) == 0;\n\t}\n  bool cmp_y (const P& a, const P& b) {\n    return sgn(imag(a-b)) ? imag(a-b) < 0 : sgn(real(a-b)) < 0;\n  }\n}\n\n// P,L,Sについて入力\ninline istream& operator>>(istream& is, P& p) {\n  R x, y;\n  is >> x >> y;\n  p = P(x, y);\n  return is;\n}\ninline istream& operator>>(istream& is, L& l) {\n  P a, b;\n  is >> a >> b;\n  l = L(a, b);\n  return is;\n}\ninline istream& operator>>(istream& is, S& s) {\n  P a, b;\n  is >> a >> b;\n  s = S(a, b);\n  return is;\n}\n\n// 射影\nP inline projection(const L &l, const P &p) {\n  R t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\n// 反射\nP inline reflection(const L &l, const P &p) {\n  return p + (R)2 * (projection(l, p) - p);\n}\n\n// 線分abから見たcの位置\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON_SEG=16};\nint ccw(P a, P b, P c) {\n\tP p = (c-a)/(b-a);\n\tif(sgn(imag(p)) > 0) return LEFT;\n\tif(sgn(imag(p)) < 0) return RIGHT;\n\tif(sgn(real(p)) < 0) return BACK;\n\tif(sgn(real(p)-1) > 0) return FRONT;\n\treturn ON_SEG;\n}\n\n// 垂直,平行\ninline bool vertical(L a, L b) {return sgn(dot(vec(a), vec(b))) == 0;}\ninline bool parallel(L a, L b) {return sgn(det(vec(a), vec(b))) == 0;}\ninline bool eal(L a, L b) {return vertical(a,b) && parallel(a,b);}\n\n// 交差判定\ntemplate<bool strict=false> inline bool intersect(const L&l1, const L&l2) {\n  if(strict) return sgn(det(vec(l1),vec(l2))) != 0;\n  return sgn(det(vec(l1),vec(l2))) != 0 || l1 == l2;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const S&s) {\n  if(strict) det(s.first, vec(l)) * det(s.second, vec(l)) < 0;\n  return det(s.first, vec(l)) * det(s.second, vec(l)) <= 0;\n}\ntemplate<bool strict=false> inline bool intersect(const S&s1, const S&s2) {\n  int ccw1 = ccw(s1.first, s1.second, s2.first) | ccw(s1.first, s1.second, s2.second);\n  int ccw2 = ccw(s2.first, s2.second, s1.first) | ccw(s2.first, s2.second, s1.second);\n  if(strict) return (ccw1 & ccw2) == (LEFT | RIGHT);\n  return (ccw1 & ccw2) == (LEFT | RIGHT) || ((ccw1 | ccw2) & ON_SEG);\n}\ntemplate<bool strict=false> inline bool intersect(const S&s, const P&p) {\n  return ccw(s.first, s.second, p) == ON_SEG;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const P&p) {\n  return ccw(l.first, l.second, p) == ON_SEG ||\n          ccw(l.first, l.second, p) == FRONT ||\n          ccw(l.first, l.second, p) == BACK;\n}\nint intersect(const C& a, const C& b) {\n\tR dist = sqrt(norm(a.c-b.c)), r1 = a.r + b.r, r2 = abs(a.r - b.r);\n\tif(sgn(r1-dist) < 0)  return 4;\t// 円が離れている\n\tif(sgn(r1-dist) == 0) return 3;\t// 外接\n\tif(sgn(r2-dist) < 0 && sgn(dist-r1) < 0) return 2; // 交差\n\tif(sgn(dist-r2) == 0) return 1; // 内接\n\treturn 0;\t// 内部に含む\n}\n\n// 距離\nR dist(const S& s, const P& p) {\n  P q = projection(s, p);\n  if(sgn(dot(s.second-s.first, p-s.first)) <= 0) q = s.first;\n  if(sgn(dot(s.first-s.second, p-s.second)) <= 0) q = s.second;\n  return abs(p-q);\n}\nR dist(const S& a, const S& b) {\n  if(intersect(a, b)) return 0;\n  return min({dist(a, b.first), dist(a, b.second), dist(b, a.first), dist(b, a.second)});\n}\nR dist(const L& l, const P& p) {\n  P q = projection(l, p);\n  return abs(p-q);\n}\n\n// 交点 交差判定を先にすること!!!\ninline P crosspoint(const L& l1, const L& l2) {\n  R ratio = det(vec(l2), l2.first-l1.first)/det(vec(l2),vec(l1));\n  return l1.first + vec(l1)*ratio;\n}\n// ToDo:そもそも交差しないとき\nvector<P> crosspoint(C c, L l) {\n\tR d = dist(l, c.c), r = c.r;\n\tP m = projection(l, c.c);\n\tP x = sqrt(r*r-d*d)*vec(l)/abs(vec(l));\n\tvector<P> ret(2,m);\n\tret[0] -= x;\n\tret[1] += x;\n\tif(ret[1] < ret[0]) swap(ret[0], ret[1]);\t//!!!\n\treturn ret;\n}\n// vector<P> crosspoint(C a, C b) {\n// \tdouble d = abs(a.p-b.p);\n// \tdouble t = (a.r*a.r-b.r*b.r+d*d)/2/d, h = sqrt(a.r*a.r-t*t);\n// \tP m = t/abs(b.p-a.p)*(b.p-a.p)+a.p;\n// \tP n = n_vector(a.p-b.p);\n// \tvector<P> ret(2, m);\n// \tret[0] -= h*n;\n// \tret[1] += h*n;\n// \tsort(ret.begin(), ret.end());\t//!!!\n// \treturn ret;\n// }\n\n// 面積 頂点が反時計回りに並んでいること\nR area(const G& pol) {\n  R ret = 0.0;\n  REP(i, pol.size()) ret += det(pol[i], pol[(i+1)%pol.size()]);\n  return (ret/2.0);\n}\n\n// 凸性の判定\nbool isConvex(const G& pol) {\n  REP(i, pol.size()) {\n    if(sgn(det(pol[(i+1)%pol.size()]-pol[i], pol[(i+2)%pol.size()]-pol[i])) < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 多角形と点の内包\n// 2→in 1→on 0→out\nint inPolygon(const G& pol, const P& p) {\n  bool in = false;\n  for (int i = 0; i < pol.size(); ++i) {\n  \tP a = pol[i] - p, b = pol[(i+1)%pol.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    cout << i << \" \" << det(a, b) << endl;\n    if (imag(a) <= 0 && 0 < imag(b) && sgn(det(a, b)) < 0) {\n      cout << \"rev\" << endl;\n      in = !in;\n    }\n    if (sgn(det(a, b)) == 0 && sgn(dot(a, b)) <= 0) return 1;\n  }\n  return in ? 2 : 0;\n}\n\n// 凸包 3点が一直線上に並ぶときに注意\n// 凸包のうち一番左にある頂点の中で一番下の頂点から時計回り\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G r(2*n);\n  for(int i=0; i<n; i++){\n    while(k>1 && sgn(det(r[k-1]-r[k-2], ps[i]-r[k-2])) < 0) k--;\n    r[k++] = ps[i];\n  }\n  for(int i=n-2,t=k; i>=0; i--){\n    while(k>t && sgn(det(r[k-1]-r[k-2], ps[i]-r[k-2])) < 0) k--;\n    r[k++] = ps[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  P p;\n  R r;\n  cin >> p >> r;\n  int q;\n  cin >> q;\n\n  C c(p, r);\n  REP(i, q) {\n    L l;\n    cin >> l;\n    vector<P> ret = crosspoint(c, l);\n    cout << fixed << setprecision(9) << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\npair<Point,Point>getCrossPoints(Circle c,Line l){\n    //assert(isIntersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\nint main(){\n    Circle c;\n    getCircle(c);\n\n    int q;\n    scanf(\"%d\",&q);\n\n    while(q--){\n\n        Line l;\n        getLine(l);\n        pair<Point,Point>x=getCrossPoints(c,l);\n        if(!cmpx(x.first,x.second))swap(x.first,x.second);\n        printf(\"%.20lf %.20lf %.20lf %.20lf\\n\",x.first.real(),x.first.imag(),x.second.real(),x.second.imag());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\nusing R = double;\nusing P = complex<R>;\n#define x real()\n#define y imag()\nconst R eps = 1e-9,PI = acos(-1);\n\nbool equal(R a,R b){return abs(b-a)<eps;}\nbool equal0(R a){return equal(a,0.0);}\n\nP operator*(const P& p,const R& d){\n    return P(p.x*d,p.y*d);\n}\n\nnamespace std{\n    bool operator<(const P& a,const P& b){\n        return a.x!=b.x? a.x<b.x:a.y<b.y;\n    }\n};\n\nistream &operator>>(istream& is,P& p){\n    R a,b;\n    is >> a >> b;\n    p = P(a,b);\n    return is;\n}\n\nostream &operator<<(ostream& os,P& p){\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n//内積\ndouble dot(P a,P b) {return (conj(a)*b).real();}\n//外積\ndouble cross(P a,P b) {return (conj(a)*b).imag();}\n\nstruct L{\n    P a,b;\n    L(P a,P b):a(a),b(b){}\n    L(R A,R B,R C){\n        if(equal(A,0)) a = P(0,C/B),b = P(1,C/B);\n        else if(equal(B,0)) b = P(C/A,0),b = P(C/A,1);\n        else a = P(0,C/B),b = P(C/A,0);\n    }\n};\n\nstruct S:L{\n    S(P a,P b):L(a,b){}\n};\n\nusing Polygon = vec<P>;\n\nstruct C{\n    P p;\n    R r;\n    C(P p,R r):p(p),r(r){}\n};\n//pをbに射影\nP projection(P p,P b) {return b*dot(p,b)/norm(b);}\n\n//pとp1 to p2 に射影\nP projection(L l,P p){\n    p -= l.a; l.b -= l.a;\n    P proj = projection(p,l.b);\n    return l.a+proj;\n}\n\n//点の回転方向を判定\nint ccw(P p0,P p1,P p2){\n    p1 -= p0,p2 -= p0;\n    if(cross(p1,p2)>eps) return 1; //\"COUNTER_CLOCKWISE\"\n    if(cross(p1,p2)<-eps) return -1; //\"CLOCKWISE\"\n    if(dot(p1,p2)<0) return 2; //\"ONLINE_BACK\"\n    if(norm(p1)<norm(p2)) return -2; //\"ONLINE_FRONT\"\n    return 0; //\"ON_SEGMENT\"\n}\n\nbool is_parallel(L l1,L l2){\n    return equal0(cross(l1.b-l1.a,l2.b-l2.a));\n}\n\nbool is_orthogonal(L l1,L l2){\n    return equal0(dot(l1.b-l1.a,l2.b-l2.a));\n}\n\n//pをlに関して対称移動\nP reflection(L l,P p){\n    P pj = projection(l,p);\n    return 2.0*pj-p;\n}\n\n\nR dist(L l,P p);\nR dist(P a,P b);\n//pがl上にあるか\nbool is_online(L l,P p){\n    return abs(ccw(l.a,l.b,p))!=1;\n}\n\nbool is_onsegment(S s,P p){\n    return ccw(s.a,s.b,p)==0;\n}\n\n//線分の交差判定\nbool intersect(S s,S t){\n    return ccw(s.a,s.b,t.a)*ccw(s.a,s.b,t.b)<=0 && ccw(t.a,t.b,s.a)*ccw(t.a,t.b,s.b)<=0;\n}\n\n//円と直線の交差判定\nbool intersect(C c,L l){\n    return dist(l,c.p)<=c.r+eps;\n}\n\n//点が円周上にあるか\nbool on_circle(C c,P p){\n    return abs(abs(p-c.p)-c.r)<eps;\n}\n\n/*円と直線の関係\n交点をいくつもつか？\n*/\nbool intersect(C c,S s){\n    if(norm(projection(s,c.p)-c.p)-c.r*c.r>eps) return 0;\n    R d1 = dist(c.p,s.a),d2 = dist(c.p,s.b);\n    if(d1<c.r+eps && d2<c.r+eps) return 0;\n    if(d1<c.r-eps && d2>c.r+eps || d1>c.r-eps && d2<c.r+eps) return 1;\n    const P h = projection(s,c.p);\n    if(dot(s.a-h,s.b-h)<0) return 2;\n    return 0;\n}\n\n/*円と円の関係\n4:交点を持たない\n3:外接する\n2:2つの相異なる交点をもつ\n1:内接する\n0:一方がもう一方の内部にある\n*/\nint intersect(C c1,C c2){\n    if(c1.r<c2.r) swap(c1,c2);\n    R d = dist(c1.p,c2.p);\n    if(c1.r+c2.r<d) return 4;\n    if(equal(c1.r+c2.r,d)) return 3;\n    if(c1.r-c2.r<d) return 2;\n    if(equal(c1.r-c2.r,d)) return 1;\n    return 0;\n}\n\n//2直線の交点\nP crosspoint(L l1,L l2){\n    R a = cross(l1.b-l1.a,l2.b-l2.a);\n    R b = cross(l1.b-l1.a,l1.b-l2.a);\n    if(equal0(abs(a)) && equal0(abs(b))) return l2.a;\n    return l2.a+(l2.b-l2.a)*b/a;\n}\n\nP crosspoint(S s1, S s2){\n    return crosspoint(L(s1),L(s2));\n}\n\nR dist(P a,P b){\n    return abs(a-b);\n}\n\nR dist(L l,P p){\n    return abs(p-projection(l,p));\n}\n\nR dist(L l1,L l2){\n    return is_parallel(l1,l2)? 0:dist(l1,l2.a);\n}\n\nR dist(S s,P p){\n    P r = projection(s,p);\n    if(is_onsegment(s,r)) return abs(r-p);\n    return min(dist(s.a,p),dist(s.b,p));\n}\n\nR dist (S s1,S s2){\n    if(intersect(s1,s2)) return 0;\n    return min({dist(s1,s2.a),dist(s1,s2.b),\n    dist(s2,s1.a),dist(s2,s1.b)});\n}\n\nR area_of_polygon(Polygon& v){\n    int n = v.size();\n    R res = 0;\n    for(int i=0;i+2<n;i++){\n        res += cross(v[i+1]-v[0],v[i+2]-v[0]);\n    }\n    return res/2;\n}\n\nbool is_convex(Polygon& v){\n    int n = v.size();\n    for(int i=0;i<n;i++){\n        P a = v[i%n],b = v[(i+1)%n],c = v[(i+2)%n];\n        if(cross(b-a,c-a)<-eps) return false;\n    }\n    return true;\n}\n\nenum{\n    OUT,ON,IN\n};\n\n//点pと多角形vの関係\nint contains(Polygon& v,P p){\n    bool in = false;\n    int n = v.size();\n    for(int i=0;i<n;i++){\n        P a = v[i]-p,b = v[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<=0 && 0<b.y && cross(a,b)<0) in = !in;\n        if(is_onsegment(S(a,b),P(0,0))) return ON;\n    }\n    return in? IN:OUT;\n}\n\nPolygon convex_hull(Polygon& v){\n    int n = v.size();\n    Polygon res;\n    sort(v.begin(),v.end(),[](P& a,P& b){\n        return (a.x!=b.x? a.x<b.x:a.y<b.y);\n    });\n    for(int i=0;i<n;i++){\n        if(i<2){\n            res.push_back(v[i]);\n            continue;\n        }\n        while(true){\n            int s = res.size();\n            if(s<2){\n                res.push_back(v[i]);\n                break;\n            }\n            R c = cross(res[s-1]-res[s-2],v[i]-res[s-2]);\n            if(c<-eps){\n                res.pop_back();\n            }else{\n                res.push_back(v[i]);\n                break;\n            }\n        }\n    }\n    reverse(v.begin(),v.end());\n    for(int i=0;i<n;i++){\n        while(true){\n            int s = res.size();\n            if(v[i]==res.back()) break;\n            if(s<2){\n                res.push_back(v[i]);\n                break;\n            }\n            R c = cross(res[s-1]-res[s-2],v[i]-res[s-2]);\n            if(c<-eps){\n                res.pop_back();\n            }else{\n                res.push_back(v[i]);\n                break;\n            }\n        }\n    }\n    res.pop_back();\n    return res;\n}\n\nR convex_diameter(Polygon v){\n    int n = v.size();\n    int l = 0,r = 0;\n    for(int i=1;i<n;i++){\n        if(v[i].y>v[l].y) l = i;\n        if(v[i].y<v[r].y) r = i;\n    }\n    R res = abs(v[l]-v[r]);\n    int i = l,mai = l,j = r,maj = r;\n    do{\n        if(cross(v[(i+1)%n]-v[i],v[(j+1)%n]-v[j])>=0) j = (j+1)%n;\n        else i = (i+1)%n;\n        if(abs(v[i]-v[j])>res){\n            res = abs(v[i]-v[j]);\n            mai = i; maj = j;\n        }\n    }while(i!=l || j!=r);\n    return res;\n}\n\nPolygon convex_cut(Polygon& v,L l){\n    Polygon res;\n    int n = v.size();\n    for(int i=0;i<n;i++){\n        P now = v[i],ne = v[(i+1)%n];\n        if(ccw(l.a,l.b,now)!=-1) res.push_back(now);\n        if(ccw(l.a,l.b,now)*ccw(l.a,l.b,ne)<0){\n            res.push_back(crosspoint(L(now,ne),l));\n        }\n    }\n    return res;\n}\n\npair<P,P> crosspoint(C c,L l){\n    P pr = projection(l,c.p);\n    P e = (l.b-l.a)/dist(l.b,l.a);\n    if(equal(dist(l,c.p),c.r)) return {pr,pr};\n    R base = sqrt(c.r*c.r-norm(pr-c.p));\n    return {pr-e*base,pr+e*base};\n}\n\nint main(){\n    P p;\n    R r;\n    cin >> p >> r;\n    C c(p,r);\n    int Q;\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        P a,b;\n        cin >> a >> b;\n        auto res = crosspoint(c,L(a,b));\n        if(res.second<res.first) swap(res.first,res.second);\n        cout << res.first << \" \" << res.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//点を表す構造体\nclass Point {\n  public:\n  double x,y;\n  Point(double x=0,double y=0): x(x),y(y){}\n\n  //各種演算\n  Point operator+ (Point p) { return Point(x+p.x,y+p.y); }\n  Point operator- (Point p) { return Point(x-p.x,y-p.y); }\n  Point operator* (double a) {return Point(a*x,a*y); }\n  Point operator/ (double a) {return Point(x/a,y/a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x+y*y; }\n\n  bool operator< (const Point &p) const{\n    return x!=p.x ? x<p.x : y<p.y;\n  }\n\n  bool operator> (const Point &p) const{\n    return x!=p.x ? x>p.x : y>p.y;\n  }\n\n  bool operator== (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\n//ベクトルを表す構造体\ntypedef Point Vector;\n\n//線分を表す構造体\nstruct Segment{\n  Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n  Point p1,p2;\n};\n\n//直線を表す構造体\ntypedef Segment Line;\n\n//円を表すクラス\nclass Circle{\n  public:\n  //円の中心\n  Point c;\n  //半径\n  double r;\n  Circle(Point c=Point(),double r=0.0): c(c),r(r) {}\n};\n\n//多角形の表現\ntypedef vector<Point> Polygon;\n\n//ベクトルaとbの内積\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\n\n//ベクトルaとbの外積\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\n//ベクトルaとbの直交判定\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\n//ベクトルaとbの平行判定\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\n//線分sに対する点pの射影\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/base.norm();\n  return s.p1+base*r;\n}\n\n//線分sを対称軸とした点pの線対称の点\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\n\n//反時計回りCCW\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n//反時計回りCCW\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS) return CLOCKWISE;\n  if(dot(a,b)<-EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n\n  return ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\n//点aと点bの距離\ndouble getDistace(Point a,Point b){\n  return (a-b).abs();\n}\n//直線lと点pの距離\ndouble getDistaceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n} \n//線分sと点pの距離\ndouble getDistaceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n  if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n  return getDistaceLP(s,p);\n}\n//線分s1と線分s2の距離\ndouble getDistace(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistaceSP(s1,s2.p1),getDistaceSP(s1,s2.p2))\n  ,min(getDistaceSP(s2,s1.p1),getDistaceSP(s2,s1.p2)));\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s1.p2-s1.p1;\n  double d1=abs(cross(base,s2.p2-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  if(equals(fabs(d1),0.0) && equals(fabs(d2),0.0)) return s2.p1;\n  return s2.p1+(s2.p2-s2.p1)*d2/d1;\n}\n\n//円cと線分lの交点\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  // assert(intersect(c,l));\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n  double base=sqrt(c.r*c.r-(pr-c.c).norm());\n  return make_pair(pr+e*base,pr-e*base);\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  int cx,cy,r;\n  cin>>cx>>cy>>r;\n  Point p(cx,cy);\n  Circle c(p,r);\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int x0,x1,y0,y1;\n    cin>>x0>>y0>>x1>>y1;\n    Point p1(x0,y0),p2(x1,y1);\n    Line s1(p1,p2);\n    auto p=getCrossPoints(c,s1);\n    tie(p1,p2)=p;\n    if(p1>p2){\n      swap(p1,p2);\n    }\n    cout<<fixed<<setprecision(15)<<p1.x<<' '<<p1.y<<' '<<p2.x<<' '<<p2.y<<'\\n';\n  }\n  return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    }\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(const Point &p, const double r): p(p), r(r) {}\n};\n\npair<Point, Point> get_ipoints(const Circle &c, const Line &l) {\n    double a=imag(l.first)-imag(l.second);\n    double b=real(l.second)-real(l.first);\n    double k=-b*imag(l.first)-a*real(l.first);\n\n    double d=a*real(c.p)+b*imag(c.p)+k;\n    double r=c.r;\n\n    double R=a*a+b*b;\n    double D=sqrt(R*r*r-d*d);\n    Point p1=c.p+polar(1/sqrt(R), atan2(b, a))*Point(-d, D);\n    Point p2=c.p+polar(1/sqrt(R), atan2(b, a))*Point(-d, -D);\n\n    if (p2 < p1)\n        swap(p1, p2);\n\n    return make_pair(p1, p2);\n}\n\nint main() {\n    double x, y, r;\n    scanf(\"%lf %lf %lf\", &x, &y, &r);\n    Circle c(Point(x, y), r);\n\n    size_t q;\n    scanf(\"%zu\", &q);\n\n    for (size_t i=0; i<q; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        Point p1(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p2(x, y);\n\n        Line l(p1, p2);\n        pair<Point, Point> ps=get_ipoints(c, l);\n        printf(\"%.9f %.9f \", real(ps.first), imag(ps.first));\n        printf(\"%.9f %.9f\\n\", real(ps.second), imag(ps.second));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-8; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\n\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}\n\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*<<head>> {{{*/\n#include <bits/stdc++.h>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n//INF = 1 061 109 567 ; INF + INF = 2 122 219 134 ;\n//LINF = 4 557 430 888 798 830 399 ; LINF + LINF = 9 114 861 777 597 660 798 ;\nconst int INF = 0x3f3f3f3f;     // -INF: 0xc0   abs(-INF) = INF + 1\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n/*}}}*/                         // zr, zm\nconst int MOD = (int)1e9+7;     // when MOD = 1e9+7, inv2 = 500000004\nconst int N = (int)-1;\n \n// ------- 变量 ------- //\n \n/* 注意\n  1. 点、向量\n    1. 如果角度出现 -pi ，可以加上 2pi 修正为 pi\n    2. atan2(y, x) 的参数是浮点数时，可能出现 -pi ，如 atan2(-0.0, -1.0)\n  2. 线段、直线\n    1. 线段严格相交定义为：每条线段的两个端点落在另一条线段两边，形象来说，就是可以在图形里看到四个端点和一个交点\n*/\n \ntypedef db T;  // 大部分情况下使用 db\nconst T eps = 1e-7, pi = acosl(-1.);\nint sgn(T x) { return (x > eps) - (x < -eps); }\nbool inMid(T l, T x, T r) { return sgn(l - x) * sgn(r - x) <= 0; }  // 数 x 在区间 [l, r] 内（包括边界）\n \n// 点、向量\nstruct P {\n    T x, y; P () {} P(T x, T y) : x(x), y(y) {}\n    P operator + (const P &b) const { return P(x + b.x, y + b.y); }  // 向量加\n    P operator - (const P &b) const { return P(x - b.x, y - b.y); }  // 向量减\n    T operator * (const P &b) const { return x * b.x + y * b.y; }    // 向量点积\n    T operator / (const P &b) const { return x * b.y - y * b.x; }    // 向量叉积\n    P operator * (const T &k) const { return P(x * k, y * k); }      // 向量数乘\n    P operator / (const T &k) const { return P(x / k, y / k); }      // 向量数除\n    bool operator < (const P &b) const { return sgn(x - b.x) ? x < b.x : y < b.y; }  // 左小右大，下小上大\n    bool operator == (const P &b) const { return !sgn(x - b.x) && !sgn(y - b.y); }   // 向量相等\n    P rot(T t) { return P(x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)); }  // 向量逆时针旋转 t 弧度\n    P rot90() { return P(-y, x); }           // 向量逆时针旋转 90 度\n    T arg() const { return atan2(y, x); }   // 方位角 (-pi, pi]\n    T abs() { return sqrt(x * x + y * y); }  // 向量模长\n    T abs2() { return x * x + y * y; }       // 向量模长的平方\n    P unit() { return (*this) / abs(); }     // 单位向量\n    void scan() { T tx, ty; scanf(\"%lf%lf\", &tx, &ty); x = tx; y = ty; }  // 输入\n    void print() { printf(\"%.11lf %.11lf\\n\", x, y); }                      // 输出\n    P toR() { return (sgn(x) == -1 || !sgn(x) && sgn(y) == -1) ? (*this)*(-1) : (*this); }  // 若向量在 2 3 象限，则取相反向量\n    bool isUp() const { return sgn(y) == 1 || !sgn(y) && sgn(x) == -1; }                    // 向量是否在 1 2 象限\n};\nT dis(P a, P b) { return (b - a).abs(); }   // 点 a 到点 b 的距离\nP symmetry(P p, P a) { return a + a - p; }  // 点 p 关于点 a 的中心对称点\nT cross(P o, P a, P b) { return (a - o) / (b - o); }         // 向量 oa 与 ob 的叉积\nint crossSgn(P o, P a, P b) { return sgn(cross(o, a, b)); }  // 向量 oa 与 ob 的叉积符号\nT rad(P a, P b) { return atan2(a / b, a * b); }             // 向量 a 与 b 的夹角（弧度制）\nbool order(const P &a, const P &b) { return a.isUp() < b.isUp() || a.isUp() == b.isUp() && sgn(a/b) > 0; }  // 极角排序\n \n// 线段、直线\nstruct L { P s, t; L () {} L(P s, P t) : s(s), t(t) {} };\nbool onPS(P p, L a) { return sgn((a.t-a.s)/(p-a.s))==0 && sgn((p-a.s)*(p-a.t))<=0; }   // 点 p 是否在线段 a 上\nbool inRec(P p, L a) { return inMid(a.s.x, p.x, a.t.x) && inMid(a.s.y, p.y, a.t.y); }  // 点 p 在以直线 a 为对角线的矩形内\nP proj(P p, L a) { return (a.t-a.s) * ( (p-a.s) * (a.t-a.s) / (a.t-a.s).abs2() ) + a.s; }  // 点 p 关于直线 a 的投影点\nP reflect(P p, L a) { return proj(p, a) * 2 - p; }                                         // 点 p 关于直线 a 的对称点\nbool xSSr(const L &a, const L &b) {  // 线段 a 和线段 b 严格相交\n    T c1 = (a.t-a.s) / (b.s-a.s), c2 = (a.t-a.s) / (b.t-a.s);\n    T c3 = (b.t-b.s) / (a.s-b.s), c4 = (b.t-b.s) / (a.t-b.s);\n    return sgn(c1) * sgn(c2) < 0 && sgn(c3) * sgn(c4) < 0;\n}\nbool xSS(L a, L b) {                 // 线段 a 和线段 b 不严格相交\n    T c1 = (a.t-a.s) / (b.s-a.s), c2 = (a.t-a.s) / (b.t-a.s);\n    T c3 = (b.t-b.s) / (a.s-b.s), c4 = (b.t-b.s) / (a.t-b.s);\n    return sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n           sgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n           sgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n           sgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n           sgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\nbool xSL(L a, L b) {  // 线段 a 与直线 b 相交 ( 不严格 : <= ; 严格 : < )\n    return sgn( (b.t - b.s) / (a.s - b.s) ) * sgn( (b.t - b.s) / (a.t - b.s) ) <= 0;\n}\nP xLL(L a, L b) {  // 直线 a 和直线 b 的交点\n    T s1 = (b.t - b.s) / (a.s - b.s), s2 = -( (b.t - b.s) / (a.t - b.s) );\n    return (a.s * s2 + a.t * s1) / (s1 + s2);\n}\nT disPL(P p, L a) { return fabs( (a.t-a.s) / (p-a.s) ) / (a.t-a.s).abs(); }  // 点 p 到直线 a 的距离\nT disPS(P p, L a) {                                                          // 点 p 到线段 a 的距离\n    return sgn( (a.t-a.s) * (p-a.s) ) * sgn( (a.s-a.t) * (p-a.t) ) == 1\n           ? disPL(p, a) : min( (p-a.s).abs(), (p-a.t).abs() );\n}\nT disSS(L a, L b){                                                           // 线段 a 到线段 b 的距离\n    if (xSS(a,b)) return 0;\n    return min( min( disPS(a.s,b), disPS(a.t,b) ), min( disPS(b.s,a), disPS(b.t,a) ) );\n}\nT disLL(L a, L b) { return (a.t-a.s) / (b.t-b.s) ? 0 : disPL(a.s, b); }      // 直线 a 到直线 b 的距离\n \n// 多边形、凸包\ntypedef vector<P> polygon;\npolygon Convex(polygon A) {  // 求凸包，逆时针排序（ 内角 <180 : (<=) ; 内角 <=180 : (<) ）\n    int n = sz(A); if (n <= 1) return A;\n    sort(all(A));\n    polygon B;\n    for (int i = 0; i < n; B.pb(A[i++]))\n        while (sz(B) > 1 && crossSgn(B[sz(B)-2], B.back(), A[i]) < 0) B.pop_back();  // 更改这里的 <\n    for (int i = n - 2, t = sz(B); i >= 0; B.pb(A[i--]))\n        while (sz(B) > t && crossSgn(B[sz(B)-2], B.back(), A[i]) < 0) B.pop_back();  // 同上\n    B.pop_back(); return B;\n}\nT area(polygon A) {  // 多边形 A 的面积，整型可以返回面积的两倍，保持精度\n    T res = 0;\n    rep(i, 0, sz(A)) res += A[i] / A[ (i+1) % sz(A) ];\n    return fabs(res) / 2;\n}\nbool isConvex(polygon A) {  // 多边形 A 是否是凸包，要求 A 的点集按逆时针排序\n    rep(i, 0, 2) A.pb(A[i]);\n    rep(i, 0, sz(A)-2) if ( sgn( (A[i+1]-A[i]) / (A[i+2]-A[i]) ) < 0 ) return 0;\n    return 1;\n}\nint inPPo(P p, polygon A) {  // 点和多边形关系 ( 2 : in , 1 : on , 0 : out )\n    int res = 0; A.pb(A[0]);\n    rep(i, 1, sz(A)) {\n        P u = A[i-1], v = A[i];\n        if (onPS(p, L(u, v))) return 1;\n        if (sgn(u.y - v.y) > 0) swap(u, v);\n        if (sgn(u.y - p.y) >= 0 || sgn(v.y - p.y) < 0) continue;\n        if (crossSgn(v, u, p) < 0) res ^= 1;\n    }\n    return res << 1;\n}\nT ConvexDiameter(polygon A) {  // 凸包 A 的直径，即凸包 A 上的最远点对\n    int now = 0, n = sz(A); T res = 0;\n    if (n <= 1) return 0;\n    rep(i, 0, sz(A)) {\n        now = max(now, i);\n        while (1) {\n            T t1 = dis(A[i], A[now%n]), t2 = dis(A[i], A[(now+1)%n]);\n            res = max(res, max(t1, t2));\n            if (t2 > t1) now++; else break;\n        }\n    }\n    return res;\n}\npolygon ConvexCut(polygon A, L a) {  // 半平面 a 切割凸包 A 形成的凸包（直线 a 逆时针方向）\n    int n = sz(A); A.pb(A[0]); polygon res;\n    rep(i, 0, n) {\n        int w1 = crossSgn(a.s, a.t, A[i]), w2 = crossSgn(a.s, a.t, A[i+1]);\n        if (w1 >= 0) res.pb(A[i]);\n        if (w1 * w2 < 0) res.pb(xLL(a, L(A[i], A[i+1])));\n    }\n    return res;\n}\nT _closePP(polygon &A, int l, int r) {  // 调用下面的 closePP(A)\n    if (r - l < 6) {\n        T res = 1e20;\n        rep(i, l, r+1) rep(j, i+1, r+1) res = min(res, dis(A[i], A[j]));\n        return res;\n    }\n    int m = l + r >> 1;\n    T res = min(_closePP(A, l, m), _closePP(A, m+1, r));\n    polygon B; rep(i, l, r+1) if (fabs(A[i].x - A[m].x) < res) B.pb(A[i]);\n    sort(all(B), [&](P p1, P p2){ return p1.y < p2.y; });\n    rep(i, 0, sz(B)) for (int j = i+1; j < sz(B) && B[j].y - B[i].y < res; j++)\n        res = min(res, dis(B[i], B[j]));\n    return res;\n}\nT closePP(polygon A) {  // 点集 A 中的最近点对\n    sort(all(A), [&](P a, P b){ return a.x < b.x; });\n    return _closePP(A, 0, sz(A)-1);\n}\n \nstruct C { P o; T r; C () {} C (P o, T r) : o(o), r(r) {} };\n \nint relCC(C A, C B) {  // 两圆关系 ( 4 : 相离 ; 3 : 外切 ; 2 : 相交 ; 1 : 内切 ; 0 : 内含 )\n    T dis = (A.o - B.o).abs();\n    if (sgn(dis - (A.r + B.r)) == 1) return 4;\n    if (sgn(dis - (A.r + B.r)) == 0) return 3;\n    if (sgn(dis - fabs(A.r - B.r)) == 1) return 2;\n    if (sgn(dis - fabs(A.r - B.r)) == 0) return 1;\n    return 0;\n}\n/* \nbool xCL(C c, L l, P &p1, P &p2) {\n    T x = (l.s - c.o) * (l.t - l.s), y = (l.t - l.s).abs2();\n    T d = x * x - y * ((l.s - c.o).abs2() - c.r * c.r);\n    if (sgn(d) < 0) return false;\n    d = max(d, 0.0);\n    P p = l.s - ((l.t - l.s) * (x / y)), delta = (l.t - l.s) * (sqrt(d) / y);\n    p1 = p + delta, p2 = p - delta;\n    return true;\n}*/\n\nvector<P> xCL(C A, L b) {\n    P k = proj(A.o, b);\n    T d = A.r * A.r - (k - A.o).abs2();\n    if (sgn(d) == -1) return {};\n    P del = (b.s - b.t).unit() * sqrt(max(d, 0.0));\n    return { k - del, k + del };\n}\n \nC getC(P a,P b,P c){  // 三点确定一个圆 （ 三角形外接圆 ）\n    T a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;\n    T a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;\n    T d = a1 * b2 - a2 * b1;\n    P o = P(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);\n    return C(o, dis(a, o));\n}\n \n// ------- 函数 ------- //\n \nvoid Init() { \n}\n \nint Solve() {\n    P o; int r;\n    o.scan(); scanf(\"%d\\n\", &r);\n    C c(o, r);\n    int q; scanf(\"%d\", &q);\n    while (q--) {\n        P s, t;\n        s.scan(); t.scan();\n        L l(s, t);\n        vector<P> p12 = xCL(c, l);\n        P p1 = p12[0], p2 = p12[1];\n        if (p2.x < p1.x || p2.x == p1.x && p2.y < p1.y) swap(p1, p2);\n        printf(\"%.12f %.12f %.12f %.12f\\n\", p1.x, p1.y, p2.x, p2.y);\n    }\n}\n \n// ------- main ------- //\n \nint main ()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n \n    //Pre();\n    //int t; scanf(\"%d\", &t); while (t--) {\n    //while (~scanf(\"\", )) {\n    //while(fgets(s, N, stdin)) {   // 注意 fgets 会读入换行符\n        //if (n == 0) break;\n        //static int kase = 0; printf(\"Case %d: \", ++kase);\n        Init();\n        Solve();\n        //if (t) puts(\"\");\n    //}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAX = 1e2 + 5;\nconst int L = 2;\nconst LL MOD = 10000;\nconst int dir[MAX][MAX] = {{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,1},{1,-1}};\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tif(dcmp(t1 - 1) <= 0 && dcmp(t1) >= 0)\n\t\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tif(dcmp(t2 - 1) <= 0 && dcmp(t2) >= 0)\n\t\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tPoint o;\n\tdouble r;\n\tscanf(\"%lf%lf%lf\", &o.x, &o.y, &r);\n\tint T;\n\tsfi(T);\n\twhile(T--)\n\t{\n\t\tLine l;\n\t\tscanf(\"%lf%lf%lf%lf\", &l.a.x, &l.a.y, &l.b.x, &l.b.y);\n\t\tPoint ret[3];\n\t\tint num;\n\t\tcircle_cross_line(l.a, l.b, o, r, ret, num);\n\t\tif(num == 1)\n\t\t\tret[1].x = ret[0].x, ret[1].y = ret[0].y;\n\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", ret[0].x, ret[0].y, ret[1].x, ret[1].y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<float.h>\n#include<cstdio>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) fabs((a)-(b))<DBL_EPSILON*fmax(1,fmax(fabs(a),fabs(b)))\n//点のクラス\nclass Point{\n    public:\n        double x,y;\n        Point(double x=0,double y=0):x(x),y(y){}\n\n        Point operator + (Point p){return Point(x+p.x,y+p.y);}\n        Point operator - (Point p){return Point(x-p.x,y-p.y);}\n        Point operator * (double a){return Point(a*x,a*y);}\n        Point operator / (double a){return Point(x/a,y/a);}\n\n        double norm(Point p){return p.x*p.x+p.y*p.y;}\n        double abs(Point p){return sqrt(norm(p));}    \n        bool operator < (const Point &p)const{\n            return x!=p.x?x<p.x:y<p.y;\n        }\n        bool operator == (const Point &p)const{\n            return equals(x,p.x)&&equals(y,p.y);\n        }\n};\ntypedef Point Vector;\nstruct Segment{ Point p1,p2; };\ntypedef Segment Line;\ndouble norm(Vector v){return v.x*v.x+v.y*v.y;} \ndouble abs(Vector v){return sqrt(norm(v));}    \n//円\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n//多角形\ntypedef vector<Point> Polygon;\n//内積\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\n//外戚\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n//直交\nbool isOrthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){ return isOrthogonal(a1-a2,b1-b2); }\nbool isOrthogonal(Segment s1,Segment s2){ return equals(dot(s1.p1-s1.p2,s2.p1-s2.p2),0.0); }\n//平行\nbool isParallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\nbool isParallel(Point a1,Point a2,Point b1,Point b2){ return isParallel(a1-a2,b1-b2); }\nbool isParallel(Segment s1,Segment s2){ return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); }\n//射影\nPoint project(Segment s,Point p){ //射影　p377\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n//反射　p379\nPoint reflect(Segment s,Point p){return p+(project(s,p)-p)*2.0;}\n//ベクトルa,bの位置関係\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return 1;//p0,p1,p2が反時計回り\n    if(cross(a,b)<-EPS) return -1;//p0,p1,p2が時計回り\n    if(dot(a,b)<-EPS) return 2;//p1,p0,p2の順で一直線\n    if(norm(a)<norm(b)) return -2;//p0,p1,p2の順で一直線\n    return 0; //p0,p2,p1の順で一直線\n}\n//交差判定　p389\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);//p1,p2,p3,p4の順で一直線になるのを除く\n}\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//交点の座標　p392\nPoint getCrossPoint(Segment s1,Segment s2){ \n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n//距離p380\ndouble getDistance(Point a,Point b){ return abs(a-b);} //点aと点b\ndouble getDistanceLP(Line l,Point p){//直線lと点p\n\treturn abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\ndouble getDistanceSP(Segment s,Point p){//線分sと点p\n\tif(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n\tif(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\treturn getDistanceLP(s,p);\n}\ndouble getDistance(Segment s1,Segment s2){ //線分s1と線分s2\n\tif(intersect(s1,s2))return 0.0;\n\treturn min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t\t\t  min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//円　交点\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    //asert(intersect(c,l));   交点を持つことの確認\n\tVector pr =project(l,c.c);\n\tVector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\nint main(){\n    int q;\n    Point p1,p2;\n    Circle c;\n    cin>>c.c.x>>c.c.y>>c.r;\n    cin>>q;\n    pair<Point,Point> pp;\n    Line l;\n    for(int i=0;i<q;i++){\n        cin>>p1.x>>p1.y>>p2.x>>p2.y;\n        l.p1=p1; l.p2=p2;\n        pp=getCrossPoints(c,l);                                 \n        if(pp.first.x>pp.second.x)swap(pp.first,pp.second);\n        printf(\"%.10f %.10f %.10f %.10f\\n\",pp.first.x,pp.first.y,pp.second.x,pp.second.y);\n    }\n    return 0;\n\n"
  },
  {
    "language": "C++",
    "code": "//Cross Point of a Circle and a Line\n#include <iostream>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\n\nstatic const double ESP = 1e-10;\n\nbool equals(double a, double b) { return fabs(a - b) < ESP; }\n\nclass Point {\npublic:\n    double x, y;\n\n    explicit Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(a / x, a / y); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < ESP && fabs(y - p.y) < ESP;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    explicit Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector v1, Vector v2) {\n    return equals(cross(v1, v2), 0.0);\n}\n\nbool isOrthogonal(Vector v1, Vector v2) {\n    return equals(dot(v1, v2), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    return s.p1 + (base * (dot(base, p - s.p1) / base.norm()));\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2;\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > ESP) return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -ESP) return CLOCKWISE;\n    else if (dot(a, b) < -ESP) return ONLINE_BACK;\n    else if (a.norm() < b.norm()) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) {\n        return getDistancePP(s.p1, p);\n    } else if(dot(s.p1 - s.p2, p - s.p2) < 0) {\n        return getDistancePP(s.p2, p);\n    } else {\n        return getDistanceLP(s, p);\n    }\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if(intersect(s1, s2)) return 0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s1.p2 - s1.p1;\n    double d1 = fabs(cross(base, s2.p1 - s1.p1));\n    double d2 = fabs(cross(base, s2.p2 - s1.p1));\n    return s2.p1 + (s2.p2 - s2.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l) {\n    Vector base = l.p2 - l.p1;\n    double d = getDistanceLP(l, c.c);\n    Point m = project(l, c.c);\n    double t = sqrt(pow(c.r, 2.0) - pow(d, 2.0)) / base.abs();\n    return make_pair(m + base * t, m - base * t);\n}\n\nint main() {\n    int q;\n    double cx, cy, r, x0, y0, x1, y1;\n    cin >> cx >> cy >> r >> q;\n    Circle c = Circle(Point(cx, cy), r);\n    for(int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1;\n        Line l = Line(Point(x0, y0), Point(x1, y1));\n        pair<Point, Point> p = getCrossPoint(c, l);\n        if(p.first.x > p.second.x) swap(p.first, p.second);\n        printf(\"%.8f %.8f %.8f %.8f\\n\", p.first.x, p.first.y, p.second.x, p.second.y);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-10;\n#define equals(a,b) (fabs((a)-(b))<eps)\nint n;\ndouble cx,cy,r;\nstruct point{\n    double x,y;\n    point(double x=0,double y=0):x(x),y(y){}\n    point operator +(point a){\n        return point(x+a.x,y+a.y);\n    }\n    point operator -(point a){\n        return point(x-a.x,y-a.y);\n    }\n    point operator *(double a){\n        return point(x*a,y*a);\n    }\n    point operator /(double a){\n        return point(x/a,y/a);\n    }\n    void print(){\n        printf(\"%.10lf %.10lf\",x,y);\n    }\n};\ntypedef point vector;\ndouble norm(vector a){\n    return a.x*a.x+a.y*a.y;\n}\ndouble abs(vector a){\n    return sqrt(norm(a));\n}\ndouble cross(vector a,vector b){\n    return a.x*b.y-a.y*b.x;\n}\ndouble dot(vector a,vector b){\n    return a.x*b.x+a.y*b.y;\n}\nstruct segment{\n    point p1,p2,base,e;\n    segment(point a,point b){\n        p1=a,p2=b,base=b-a;\n        e=base/abs(base);\n    }\n};\ntypedef segment line;\nstruct circle{\n    point c;\n    double r;\n    circle(point a=point(),double b=0){\n        c=a,r=b;\n    }\n}c;\ndouble d_pl(line l,point p){\n    return abs(cross(p-l.p1,l.base))/abs(l.base);\n}\npoint project(line l,point p){\n    double t=dot(p-l.p1,l.base)/abs(l.base);\n    return l.p1+l.e*t;\n}\nvoid print(point p1,point p2){\n    p1.print();\n    printf(\" \");\n    p2.print();\n    printf(\"\\n\");\n}\nvoid cp(circle c,line l){\n    double dis=d_pl(l,c.c);\n    if(dis>c.r){\n        printf(\"no!!\");\n        return;\n    }\n    point pr=project(l,c.c);\n    double t=sqrt(c.r*c.r-dis*dis);\n    point p1=pr+l.e*t,p2=pr-l.e*t;\n    if(p1.x<p2.x) print(p1,p2);\n    else if(equals(p1.x,p2.x)&&p1.y<p2.y) print(p1,p2);\n    else print(p2,p1);\n}\nint main(){\n    scanf(\"%lf%lf%lf\",&cx,&cy,&r);\n    c=circle(point(cx,cy),r);\n    scanf(\"%d\",&n);\n    double x1,y1,x2,y2;\n    for(int i=1;i<=n;++i){\n        scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n        cp(c,segment(point(x1,y1),point(x2,y2)));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-7)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4);\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r);\nVector rotateVector(Vector v, double angle); //rad\nPoint project(Point p, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble cx, x1, x2, cy, y1, y2, r;\n\t\n\tcin >> cx >> cy >> r >> q;\n\tPoint center(cx, cy);\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tPoint p1(x1, y1), p2(x2, y2);\n\t\tpair<Point, Point> ans = crossPoint(p1, p2, center, r);\n\t\tcout << setprecision(15) << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4) {\n\tdouble d1, d2, t;\n\td1 = fabs(cross(p2 - p1, p3 - p1) / (p2 - p1).norm());\n\td2 = fabs(cross(p2 - p1, p4 - p1) / (p2 - p1).norm());\n\tt = d1 / (d1 + d2);\n\treturn (p3 + (p4 - p3) * t);\n}\n\npair<Point, Point> crossPoint(Point p1, Point p2, Point center, double r) {\n\tVector pr = project(center, p1, p2) - center;\n\tdouble base = sqrt(r * r - pr.norm());\n\n\tVector ans1 = center + pr + (p2 - p1) / (p2 - p1).abs() * base;\n\tVector ans2 = center + pr - (p2 - p1) / (p2 - p1).abs() * base;\n\t\n\tif (ans1 < ans2) {\n\t\treturn make_pair(ans1, ans2);\n\t} else {\n\t\treturn make_pair(ans2, ans1);\n\t}\n\n}\n\nVector rotateVector(Vector v, double angle) {\n\tVector ans(v.x * cos(angle) - v.y * sin(angle), v.x * sin(angle) + v.y * cos(angle));\n\treturn ans;\n}\n\nPoint project(Point p, Point p1, Point p2) {\n\tVector hypo = p - p1, base = p2 - p1;\n\treturn (p1 + base * dot(hypo, base) / base.norm());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint dcmp(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    }\n    else {\n        return d < 0? -1 : 1;\n    }\n}\n\nstruct Vector {\n    double x, y;\n    Vector(double x = 0, double y = 0): x(x), y(y){\n    }\n    \n    bool operator<(const Vector& other) const {\n        return dcmp(x - other.x) < 0 || (dcmp(x - other.x) == 0 && dcmp(y - other.y) < 0);\n    }\n};\n\ntypedef Vector Point;\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x; \n}\n\nVector operator+(const Vector& a, const Vector& b) {\n    return Vector(a.x + b.x, a.y + b.y);\n}\n\nVector operator-(const Vector& a, const Vector& b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\nVector operator*(const Vector& a, const double& p) {\n    return Vector(a.x * p, a.y * p);\n}\n\ndouble angle(const Vector& a) {\n    return atan2(a.y, a.x);\n}\n\ndouble length(const Vector& a) {\n    return sqrt(dot(a, a));\n}\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(double x = 0, double y = 0,  double r = 0): c(Point(x, y)), r(r){}\n    \n    Point point(double rad) {\n        return Point(c.x + r * cos(rad), c.y + r * sin(rad));\n    }\n};\n\n\nvector<Point> interSect(const Circle& c, const Point& a, const Point& b) {\n    Vector u = b - a;\n    Vector v = c.c - a;\n    \n    double distance = fabs(cross(u, v) / length(u));\n    \n    Point x = a + u * (dot(v, u)/dot(u, u));\n    \n    double y = sqrt(c.r * c.r - distance * distance);\n    \n  \n    Point p1 = x + u * (y/length(u));\n    Point p2 = x + u * (-y/length(u));\n    \n    vector<Point> results{p1, p2};\n    sort(results.begin(), results.end());\n    \n    return results;\n}\n\nint main() {\n    double x, y, r;\n    cin >> x >> y >> r;\n    Circle c(x, y, r);\n    \n    int q;\n    cin >> q;\n    \n    for (int i = 0; i < q; i++) {\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        vector<Point> ans = interSect(c, Point(x1, y1), Point(x2, y2));\n        cout << fixed << setprecision(8) << ans[0].x << \" \" << ans[0].y \n        << \" \" << ans[1].x << \" \" << ans[1].y << endl;\n    }\n    \n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\ndouble getDistanceLP(Line, Point);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q;\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\n\t\tif (ans.first.x < ans.second.x) {\n\t\t\tans.first.show();\n\t\t\tcout << \" \";\n\t\t\tans.second.show();\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tans.second.show();\n\t\t\tcout << \" \";\n\t\t\tans.first.show();\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstdio>\n#include <algorithm>\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\n\n//点を表す構造体\nclass Point{\npublic:\n  double x, y;\n\n  Point(double x=0, double y=0){\n    this->x = x;\n    this->y = y;\n  }\n\n  Point operator+(const Point &seg2){\n    return Point(x+seg2.x, y+seg2.y);\n  }\n\n  Point operator-(const Point &seg2){\n    return Point(x-seg2.x, y-seg2.y);\n  }\n\n  Point operator*(const double k){\n    return Point(x*k, y*k);\n  }\n\n  Point operator/(const double k){\n    return Point(x/k, y/k);\n  }\n\n  Point &operator=(const Point &p){\n    x = p.x;\n    y = p.y;\n    return *this;\n  }\n\n  bool operator < (const Point &p) const{\n    return x != p.x? x<p.x : y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return equals(x, p.x) && equals(y, p.y);\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n\n  double abs(){\n    return sqrt(norm());\n  }\n\n  static double dot(Point a, Point b){\n    return a.x*b.x + a.y*b.y;\n  }\n\n  static double cross(Point a, Point b){\n    return a.x*b.y - a.y*b.x;\n  }\n\n  static bool isOrthogonal(Point a, Point b){\n    return equals(dot(a, b), 0.0);\n  }\n\n  static bool isParallel(Point a, Point b){\n    return equals(cross(a, b), 0.0);\n  }\n\n  static void swap(Point* a, Point* b){\n    Point temp = *b;\n    *b = *a;\n    *a = temp;\n  }\n};\n\n/*\n//ベクトルを点の別表記でも表せるようにしておく\n//いらない説濃厚(Pointのtypedefで済ませそう)\nclass Vector : public Point{\npublic:\n  Vector() : Point() {}\n\n  Vector(double x, double y) : Point(x, y) {}\n\n  Vector(Point p) : Point(){\n    x = p.x;\n    y = p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n\n  double abs(){\n    return sqrt(norm());\n  }\n\n  static double dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n  }\n\n  static double cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n  }\n\n  static bool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n  }\n\n  static bool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n  }\n};\n*/\n\ntypedef Point Vector;//Vectorをtypedefしておく\n\n//線分(ベクトルを用いて)を表す構造体。両端の点が定義されている点に注意\nclass Segment{\npublic:\n  Point p1, p2;\n\n  Segment(Point p1, Point p2){\n    this->p1 = p1;\n    this->p2 = p2;\n    x = p2.x-p1.x;\n    y = p2.y-p1.y;\n  }\n\n  static bool isOrthogonal(Segment a, Segment b){\n    return equals(dot(a, b), 0.0);\n  }\n\n  static bool isParallel(Segment a, Segment b){\n    return equals(cross(a, b), 0.0);\n  }\n\nprivate:\n  int x, y;\n  static double dot(Segment a, Segment b){\n    return a.x*b.x + a.y*b.y;\n  }\n\n  static double cross(Segment a, Segment b){\n    return a.x*b.y - a.y*b.x;\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\nclass Polygon{\npublic:\n  Point* ver;\n  int size;\n  Polygon(int size){\n    this->size = size;\n    ver = new Point[size];\n  }\n  ~Polygon(){\n    delete[] ver;\n  }\n\n  double area(){\n    double ans=0.0;\n\n    Vector a, b;\n    for(int i=0; i<size; i++){\n      a=ver[i%size]; b=ver[(i+1)%size];\n      ans += Vector::cross(a, b)/2;\n    }\n\n    return ans;\n  }\n\n  /*\n    ・含まれる時:2\n    ・辺上に点が存在する時:1\n    ・それ以外の場合:0\n    を返す\n  */\n  int contain(Point p){\n    bool flag = false;\n\n    int ans;\n    for(int i=0; i<size; i++){\n      Vector a = ver[i%size]-p, b = ver[(i+1)%size]-p;\n      //外積=0かつ内積<0の時辺上に点があると判定できる\n      if(fabs(Vector::cross(a, b))<EPS && Vector::dot(a, b)<EPS){\n        ans = 1;\n        return ans;\n      }\n      if(a.y > b.y)Vector::swap(&a, &b);\n      //端点をうまく処理するために以下の条件分岐ではEPSの使い方に注意\n      if(a.y < EPS && b.y > EPS && Vector::cross(a, b)>EPS) flag = !flag;\n    }\n\n    ans = flag ? 2 : 0;\n    return ans;\n  }\n};\n\nclass Tryangle : public Polygon{\npublic:\n  Tryangle(Point p1, Point p2, Point p3) : Polygon(3){\n    ver[0] = p1;\n    ver[1] = p2;\n    ver[3] = p3;\n  }\n  double area(){\n    Vector a = ver[1]-ver[0], b = ver[2]-ver[0];\n    return fabs(Vector::cross(a, b))/2.0;\n  }\n};\n\nstring ccw_str(Point p0, Point p1, Point p2){\n  //enum res {COUNTER_CLOCKWISE=0, CLOCKWISE, ONLINE_BACK, ONLINE_FRONT, ON_SEGMENT};\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(Vector::cross(a, b) > EPS) return \"COUNTER_CLOCKWISE\";\n  if(Vector::cross(a, b) < -EPS) return \"CLOCKWISE\";\n  if(Vector::dot(a, b) < -EPS) return \"ONLINE_BACK\";\n  if(a.norm() < b.norm()) return \"ONLINE_FRONT\";\n  return \"ON_SEGMENT\";\n}\n\nint ccw_int(Point p0, Point p1, Point p2){\n  enum res {COUNTER_CLOCKWISE=-1, CLOCKWISE=1, ONLINE_BACK=2, ONLINE_FRONT=-2, ON_SEGMENT=0};\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(Vector::cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(Vector::cross(a, b) < -EPS) return CLOCKWISE;\n  if(Vector::dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPoint project(Segment s, Point p){\n  Vector base = s.p2-s.p1;\n  double r = Vector::dot(p - s.p1, base) / base.norm();\n  return s.p1 + base*r;\n}\n\nPoint reflect(Segment s, Point p){\n  Point pro = project(s, p);\n  return p + (pro-p)*2.0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n  return ccw_int(p1, p2, p3)*ccw_int(p1, p2, p4)<=0 && ccw_int(p3, p4, p1)*ccw_int(p3, p4, p2)<=0;\n}\n\nbool intersect(Segment s1, Segment s2){\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint crossPoint(Point p1, Point p2, Point p3, Point p4){\n  Vector base = p2-p1;\n  double d1 = fabs(Vector::cross(base, p4-p1))/fabs(base.abs());\n  double d2 = fabs(Vector::cross(base, p3-p1))/fabs(base.abs());\n  double t = d1/(d1+d2);\n  Point x = p4 + (p3-p4)*t;\n  return x;\n}\n\ndouble getDistance(Point p1, Point p2){\n  Vector base=p2-p1;\n  return base.abs();\n}\n\ndouble getDistance(Point p, Segment s){\n  double dot1, dot2;\n  Vector base = s.p2-s.p1;\n  dot1 = Vector::dot(base, p-s.p1);\n  dot2 = Vector::dot(base*(-1.0), p-s.p2);\n\n  double ans;\n  if(dot1<-EPS) ans = getDistance(s.p1, p);\n  else if(dot2<-EPS) ans = getDistance(s.p2, p);\n  else ans = fabs(Vector::cross(p-s.p1, base))/base.abs();\n\n  return ans;\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  double ans;\n  if(intersect(s1, s2)) ans = 0.0;\n  else {\n    ans = min(min(getDistance(s1.p1, s2), getDistance(s1.p2, s2)),\n                  min(getDistance(s2.p1, s1), getDistance(s2.p2, s1)));\n  }\n  return ans;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l){\n  Point pr = project(l, c.c);\n  Vector e = (l.p1-l.p2)/(l.p1-l.p2).abs();\n  double base = sqrt(c.r*c.r - (pr-c.c).norm());\n\n  pair<Point, Point> ans;\n  Point a=pr+e*base, b=pr-e*base;\n  ans = a<b? make_pair(a, b) : make_pair(b, a);\n  return ans;\n}\n\nint main(){\n  double cx, cy, cr;\n  cin >> cx >> cy >> cr;\n  Circle c(Point(cx, cy), cr);\n\n  int q; cin >> q;\n\n  double x1, y1, x2, y2;\n  pair<Point, Point> ans;\n  for(int i=0; i<q; i++){\n    cin >> x1 >> y1 >> x2 >> y2;\n    Line l(Point(x1, y1), Point(x2, y2));\n    ans = getCrossPoints(c, l);\n    printf(\"%.10lf %.10lf %.10lf %.10lf\\n\", ans.first.x, ans.first.y,\n                                              ans.second.x, ans.second.y);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n\nusing namespace std;\n\ndouble dDISTANCE(const double &x, const double &y, const double &x1, const double &y1, const double &x2, const double &y2){    //点(x, y)と直線の距離\n    double a, b, c;    //直線をax+by+c=0 の形式で書く  \n    a = y2 - y1;\n    b = x2 - x1;\n    c = x2 * y1 - x1 * y2;\n    return fabs(a * x - b * y + c) / sqrt(a * a + b * b);\n}\n\nint iSgn(const double &x, const double &y, const double &x1, const double &y1, const double &x2, const double &y2){    //点(x,y)が直線の正領域か負領域か判定\n    if ( (y2 - y1) * x - (x2 - x1) * y + x2 * y1 - x1 * y2 >= 0 ){\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\ndouble dNORM(const double &x, const double &y){\n    return sqrt(x * x + y * y);\n}\n\nvoid swap(double &a, double &b){\n    double iTmp = a;\n    a = b; \n    b = iTmp;\n}\n\nint main(){\n    const double dTolerance = 1.0e-10;\n    double cx,cy,r;\n    scanf(\"%lf %lf %lf\", &cx, &cy, &r);\n    int q;\n    scanf(\"%d\", &q);\n    \n    for (int i = 0; i < q; i++){\n        double x1,x2,y1,y2;\n        scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n        double dLineDist = dDISTANCE(cx, cy, x1, y1, x2, y2);    //点と直線の距離\n        double dDist = dNORM(x2 - x1, y2 - y1);    //点と点の距離\n        double px,py;    //射影\n        px = cx - (double)iSgn(cx, cy, x1, y1, x2, y2) * (y2 - y1) * dLineDist / dDist;\n        py = cy - (double)iSgn(cx, cy, x1, y1, x2, y2) * (x1 - x2) * dLineDist / dDist;\n\n        if (fabs(r - dLineDist) < dTolerance){\n            printf(\"%lf %lf %lf %lf\\n\", px, py, px, py);\n        } else {\n            if (x1 - x2 >= dTolerance){\n                swap(x1,x2);\n                swap(y1,y2);\n            } \n            if (fabs(x1 - x2) < dTolerance && y1 - y2 >= dTolerance){\n                swap(x1,x2);\n                swap(y1,y2);\n            }\n            double ax1 = px - (x2 - x1) * sqrt(r * r - dLineDist * dLineDist) / dDist;\n            double ay1 = py - (y2 - y1) * sqrt(r * r - dLineDist * dLineDist) / dDist;\n            double ax2 = px + (x2 - x1) * sqrt(r * r - dLineDist * dLineDist) / dDist;\n            double ay2 = py + (y2 - y1) * sqrt(r * r - dLineDist * dLineDist) / dDist;\n            printf(\"%lf %lf %lf %lf\\n\", ax1, ay1, ax2, ay2);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#include<algorithm>\n#include<array>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\ntypedef double Real;\nconst Real EPS = 1e-8;\nint sign(Real d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\n//define class ...\n\nstruct Point {\n\tReal x, y;\n\texplicit Point(Real x_ = 0, Real y_ = 0):x(x_), y(y_) {}\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(Real s) const { return Point(x * s, y * s); }\n\tPoint operator/(Real s) const { return Point(x / s, y / s); }\n\tbool operator<(const Point &p) const {\n\t\treturn sign(x - p.x) == -1 || (sign(x - p.x) == 0 && sign(y - p.y) == -1);\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn sign(x - p.x) == 0 && sign(y - p.y) == 0;\n\t}\n};\n\nistream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n\treturn os << '(' << p.x << \", \" << p.y << ')';\n}\n\nstruct Line : public array<Point, 2> { //??????\n\tLine(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Segment : public array<Point, 2> { //??´???\n\tSegment(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Circle {\n\tPoint c;\n\tReal r;\n\tCircle(const Point &c_, Real r_): c(c_), r(r_) {}\n};\n\ntypedef vector<Point> Polygon;\n\n// define function\nPoint rotate90(const Point &p) { // ???????¨???¨???\n\treturn Point(-p.y, p.x);\n}\n\nPoint rotate(const Point &p, Real theta) {\n\tconst Real s = sin(theta), c = cos(theta);\n\treturn Point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nReal angle(const Point &p) {\n\treturn atan2(p.y, p.x);\n}\n\nReal norm(const Point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nReal abs(const Point &p) {\n\treturn sqrt(norm(p));\n}\n\nReal dot(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool is_parallel(const Line &a, const Line &b) {\n\treturn sign( cross(a[1] - a[0], b[1] - b[0]) ) == 0;\n} \n\n// define app function\nenum { CCW = 1, CW = -1, BACK = 2, FRONT = -2, ON = 0};\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n\tconst Point p = b - a;\n\tconst Point q = c - a;\n\tconst Real crs = cross(p, q); \n\t\n\tif(sign(crs) == 1) return CCW;\n\tif(sign(crs) == -1) return CW;\n\tif(sign(dot(p, q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l, const Point &p) {\n\tconst Point a = p - l[0];\n\tconst Point b = l[1] - l[0];\n\treturn l[0] + b * (dot(a, b) / norm(b));\n}\n\nPoint reflect(const Line &l, const Point &p) {\n\tconst Point t = project(l, p);\n\treturn t + (t - p);\n}\n\nbool intersect(const Segment &s, const Point &p) {\n\treturn ccw(s[0], s[1], p) == ON;\n}\n\nbool intersect(const Segment &a, const Segment &b) {\n\treturn ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0\n\t\t\t&& ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n\treturn abs(ccw(l[0], l[1], p)) != 1;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n\treturn sign(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0])) <= 0; \n}\n\nbool intersect(const Line &a, const Line &b) {\n\treturn sign(cross(a[1] - a[0], b[1] - b[0])) != 0\n\t\t\t|| sign(cross(a[1] - a[0], b[1] - a[0])) == 0;\n}\n\nReal dist(const Point &a, const Point &b) {\n\treturn abs(a - b);\n}\n\nReal dist(const Line &l, const Point &p) {\n\tconst Point a = l[1] - l[0];\n\tconst Point b = p - l[0];\t\n\treturn abs(cross(a, b)) / abs(a);\n}\n\nReal dist(const Line &l, const Segment &s) {\n\tif(intersect(l, s)) return 0;\n\treturn min(dist(l, s[0]), dist(l, s[1]));\n}\n\nReal dist(const Line &a, const Line & b) {\n\tif(intersect(a, b)) return 0;\n\treturn dist(a, b[0]);\n}\n\nReal dist(const Segment &s, const Point &p) {\n\tif(sign(dot(s[1] - s[0], p - s[0])) == -1) return dist(s[0], p);\n\tif(sign(dot(s[0] - s[1], p - s[1])) == -1) return dist(s[1], p);\n\treturn dist(Line(s[0], s[1]), p);\n}\n\nReal dist(const Segment &a, const Segment &b) {\n\tif(intersect(a, b)) return 0;\n\treturn min({dist(a, b[0]), dist(a, b[1]), dist(b, a[0]), dist(b, a[1])});\t\n}\n\nbool intersect(const Circle &a, const Circle &b) {\n\treturn sign(dist(a.c, b.c) - (a.r + b.r)) <= 0\n\t\t&& sign(dist(a.c, b.c) - abs(a.r - b.r)) >= 0;\n}\n\nbool intersect(const Circle &c, const Segment &s) {\n\treturn sign(dist(s, c.c) - c.r) <= 0;\n}\n\nbool intersect(const Circle &c, const Line &l) {\n\treturn sign(dist(l, c.c) - c.r) <= 0;\n}\n\nbool contain(const Circle &c, const Point &p) {\n\treturn sign(dist(c.c, p) - c.r) <= 0;\n}\n\nPoint crosspoint(const Line &a, const Line &b) {\n\tassert(intersect(a, b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\t\n\tif(sign(crs) == 0) return a[0];\t// same line\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\n// ???????????????????????¨?????°????????§???????????????intersect????????????\nPoint crosspoint(const Segment &a, const Segment &b) {\n\tassert(intersect(a, b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\t\n\tif(sign(crs) == 0) { //on same line\n\t\tif(intersect(a, b[0])) return b[0];\n\t\tif(intersect(a, b[1])) return b[1];\n\t\tif(intersect(b, a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\nvector<Point> crosspoint(const Circle &c, const Line &l) {\n\tconst Point p = project(l, c.c);\n\tconst Real h = dist(p, c.c);\n\n\tvector<Point> res;\n\tif(sign(h - c.r) == 1) {\n\t\t// nothing\n\t}\n\telse if(sign(h - c.r) == 0) {\n\t\tres.emplace_back(p);\n\t}\n\telse {\n\t\tconst Real b = sqrt(c.r * c.r - h * h);\n\t\tconst Point e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\t\tres.emplace_back(p + e * b);\n\t\tres.emplace_back(p - e * b);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tPoint c;\n\tReal r;\n\tint q;\t\n\tcin >> c >> r;\t\n\tcin >> q;\t\n\trep(i, q) {\n\t\tPoint p1, p2;\n\t\tcin >> p1 >> p2;\n\t\tvector<Point> ans = crosspoint(Circle(c, r), Line(p1, p2));\t\n\t\tsort(ALL(ans));\n\t\tcout << ans.front().x << \" \" << ans.front().y << \" \" << ans.back().x << \" \" << ans.back().y << endl; \n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\ndouble xmax, xmin, ymax, ymin;\nstruct vec{\n  double x, y;\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n  //double ppdist(vec p){ return sqrt( (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y) ); }\n  //double ppdist2(vec p){ return (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y); }\n};\nstruct line{\n  vec a, b;\n  vec getvec(){ return b - a; }\n  double size(){ return getvec().norm(); }\n  vec proj(vec p){ return a + (b - a).sca((p - a).dot(b - a) / (b - a).dot(b - a)); }\n  vec vref(vec p){ return proj(p).sca(2.0) - p; }\n  int ccw(vec p){\n    vec q = p - a, ba = b - a;\n    if(ba.cross(q) > 0)return 1; //ccw\n    if(ba.cross(q) < 0)return -1; //cw\n    if(ba.dot(q) < 0)return -2; //back\n    if(ba.dot(ba) < q.dot(q))return 2; //front\n    return 0; //on\n  }\n  bool paral(line l){ return abs(l.getvec().cross(getvec())) < eps; }\n  bool orth(line l){ return abs(l.getvec().dot(getvec())) < eps; }\n  bool intersec(line l){\n    bool res0 = (ccw(l.a) * ccw(l.b) == 4); //syukutai\n    bool res1 = (getvec().cross(l.a - a) * getvec().cross(l.b - a)) <= eps;\n    bool res2 = (l.getvec().cross(a - l.a) * l.getvec().cross(b - l.a)) <= eps;\n    return !res0 && res1 && res2;\n  }\n  vec crosspoint(line l){\n    return a + getvec().sca((l.a - a).cross(l.getvec()) / getvec().cross(l.getvec()));\n  }\n  double pldist(vec p){\n    double res = min((a - p).norm2(), (b - p).norm2());\n    vec h = proj(p);\n    if((a - h).dot(b - h) < 0)res = min(res, (h - p).norm2());\n    return sqrt(res);\n  }\n  double lldist(line l){\n    if(intersec(l))return 0.0;\n    return min(min(pldist(l.a), pldist(l.b)), min(l.pldist(a), l.pldist(b)));\n  }\n};\nstruct polygon{\n  vector<vec> p;  //ccw\n  double area(){\n    double res = 0.0;\n    for(int i = 0;i < p.size();++i)res += p[i].cross(p[(i + 1) % p.size()]);\n    return res / 2.0;\n  }\n  bool isconv(){\n    for(int i = 0;i < p.size();++i)\n    if((p[(i + 1) % p.size()] - p[i]).cross(p[(i + 2) % p.size()] - p[i]) < -eps)return false;\n    return true;\n  }\n  int isin(vec a){\n    line l = (line){a, a + (vec){xmax - xmin, 0.0}};\n    int cnt = 0, n = p.size();\n    for(int i = 0;i < n;++i){\n      line tmp = (line){p[i], p[(i + 1) % n]};\n      if(tmp.ccw(a) == 0)return 1; //on line\n      if(l.intersec(tmp)){\n        ++cnt;\n        if(l.ccw(p[i]) == 0 && l.ccw(p[(i + 1) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        if(l.paral(tmp)){\n          ++cnt;\n          if(l.ccw(p[(i + 2) % n]) * l.ccw(p[(i + n - 1) % n]) == -1)++cnt;\n        }\n      }\n    }\n    return (cnt & 1) * 2;  //2:in 0:out\n  }\n};\n\nstruct circle{\n  vec o;\n  double r;\n  int intersec(circle c){\n    double d = (o - c.o).norm(), rp = r + c.r, rm = abs(r - c.r);\n    if(abs(rp - d) < eps)return 3;\n    if(rp < d + eps)return 4;\n    if(abs(rm - d) < eps)return 1;\n    if(rm < d + eps)return 2;\n    return 0;\n  }\n  pair<vec, vec> clpoint(line l){\n    pair<vec, vec> res;\n    vec h = l.proj(o);\n    double dist = (l.a - h).norm(), diff = sqrt(r * r - (o - h).norm2());\n    res.first = l.a + (l.b - l.a).sca((dist + diff) / l.size());\n    res.second = l.a + (l.b - l.a).sca((dist - diff) / l.size());\n    if(res.first.x > res.second.x ||\n      (abs(res.first.x - res.second.x) = 0.0 && res.first.y > res.second.y))\n        swap(res.first, res.second);\n    return res;\n  }\n};\n\nsigned main(void){\n  int i, j, k, q;\n  circle c;\n  cin >> c.o.x >> c.o.y >> c.r >> q;\n  for(;q--;){\n    line l;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y;\n    pair<vec, vec> res = c.clpoint(l);\n    printf(\"%.15lf %.15lf %.15lf %.15lf\\n\", res.X.x, res.X.y, res.Y.x, res.Y.y);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nclass Circle {\n    public:\n    double r;\n    Point c;\n\n    Circle(double r = 0, Point c = Point()): r(r) {}\n};\n\n//ポイントpがベクトルp1-p0からみて反時計回りにいるかどうか\n//CCW: 1, CW: -1, ON:0\nint isCCW(Point p, Point p0, Point p1){\n    Vector v01 = p1 - p0;\n    Vector v02 = p - p0;\n\n    double Cross = cross(v01, v02);\n    \n    int out = 2;\n    if (Cross>0){out = 1;}\n    else if(Cross<0){out = -1;}\n    else{out = 0;}\n\n    return out;\n}\n\nPoint projection(Point p1, Point p2, Point p) {\n    Vector v = p2 - p1;\n    Vector u = p - p1;\n    Point t = p1 + v*dot(u,v)/v.norm();\n    return t;\n}\n\nvoid print(Point p0, Point p1);\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    Circle K;\n    cin >> K.c.x >> K.c.y >> K.r;\n\n    int q;\n    cin >> q;\n\n    for (int i=0; i<q; i++) {\n        Point p0, p1, proj, cross0, cross1;\n        cin >> p0.x >> p0.y >> p1.x >> p1.y;\n\n        if ( isCCW(K.c, p0, p1) == 0 ) {\n            Vector v1 = p1 - p0;\n            v1 = v1 * K.r / v1.abs();\n            cross0 = K.c + v1;\n            cross1 = K.c - v1;\n            print(cross0, cross1);\n            continue;\n        }\n\n        proj = projection(p0, p1, K.c);\n        double d = ( proj - K.c ).abs();\n        if ( d > K.r ) {\n            cout << \"Invalid Input\" << endl;\n            continue;\n        }\n        if ( d == K.r ) {\n            print(proj, proj);\n            continue;\n        }\n        \n        Vector v0 = proj - K.c;\n        Vector v1;\n        v1.x = v0.y;\n        v1.y = - v0.x;\n        v1 =  v1 * sqrt( K.r*K.r - d*d ) / v1.abs();\n        cross0 = proj + v1;\n        cross1 = proj - v1;\n        print(cross0, cross1);\n    }\n\n    return 0;\n}\n\nvoid print(Point p0, Point p1) {\n    double x0, y0, x1, y1;\n    if ( p0.x < p1.x ) {\n        x0 = p0.x;\n        y0 = p0.y;\n        x1 = p1.x;\n        y1 = p1.y;\n    }\n    else if ( p0.x > p1.x ) {\n        x0 = p1.x;\n        y0 = p1.y;\n        x1 = p0.x;\n        y1 = p0.y;\n    }\n    else {\n        if ( p0.y < p1.y ){\n            x0 = p0.x;\n            y0 = p0.y;\n            x1 = p1.x;\n            y1 = p1.y;\n        }\n        else{\n            x0 = p1.x;\n            y0 = p1.y;\n            x1 = p0.x;\n            y1 = p0.y;\n        }\n    }\n    cout << fixed << setprecision(11) << x0 << \" \" << y0 << \" \" << x1 << \" \" << y1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\ndouble getDistanceLP(Line, Point);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q;\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\n\t\tif (ans.first.x < ans.second.x) {\n\t\t\tans.first.show();\n\t\t\tcout << \" \";\n\t\t\tans.second.show();\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tif (equals(ans.first.x - ans.second.x, 0.0)) {\n\t\t\t\tif (ans.first.y < ans.second.y) {\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans.second.show();\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\tans.first.show();\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<int(n);++i)\nusing namespace std;\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) (sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg)),arg)\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) {return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-8; // [-100:100]->EPS=1e-9 [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconst R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nusing L=struct{P s,t;};\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\n// above prepared template\n\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t),s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nusing C=struct{P c;R r;};\nenum RCC{OUT=4,ON_OUT=3,ISC=2,ON_IN=1,IN=0};\nint rcc(C a,C b){ R d=abs(a.c-b.c);return 2+sgn(d-a.r-b.r)+sgn(d-abs(a.r-b.r));}\n\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\n// dsp\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\nR cc_area(C a,C b){\n\tint r=rcc(a,b);\n    if(r<=ON_OUT) return 0.0;  \n    if(r>=ON_IN) return min(norm(a.r),norm(b.r))*PI;\n    R d=abs(b.c-a.c),rc=(norm(d)+ norm(a.r) - norm(b.r))/(2.0*d),t=acos(rc/a.r),p=acos((d-rc)/b.r);\n    return norm(a.r)*t+norm(b.r)*p-d*a.r*sin(t);\n}\n\n\nVP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// cross point between circles Verify AOJ CGL_7_E\nVP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n/*\nVP pcl(C c, L l){\n\tP h=l.s+(l.t-l.s)*real((c.c-l.s)/(l.t-l.s));\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\treturn pcl(a,{a.c+w-P(0,1)*w,a.c+w+P(0,1)*w});\n}*/\n\n\n\nL tan(C c,P p){P d=(p-c.c)*P(0,1);return L{p-d,p+d};}\n\n// reg sq\nVP contact(C c,P p){\n\tVP ret; R d=abs(p-c.c); \n\trep(i,2) reg(ret,c.c+(c.r+P(0,2*i-1)*sq(norm(d)-norm(c.r)))*c.r*(p-c.c)/norm(d));\n\treturn uniq(ret);\n}\n\n// reg sq rcc\nVP contact(C a,C b){\n\tVP ret; R d=abs(a.c-b.c);\n\trep(i,2) if(rcc(a,b)>=2*i+1) rep(j,2){\n\t\tR r=a.r+(2*i-1)*b.r;\n\t\treg(ret,a.c+(r+P(0,2*j-1)*sq(norm(d)-norm(r)))*a.r*(b.c-a.c)/norm(d));\n\t}\n\treturn uniq(ret);\n}\n\n\n// int main(void){\n// \tP p;\n// \tC a,b;\n// \t{\n// \t\tint x,y,r;\n// \t\tcin >> x >> y >> r;\n// \t\ta=C({P(x,y),R(r)});\n// \t\tcin >> x >> y >> r;\n// \t\tb=C({P(x,y),R(r)});\n// \t}\n// \tauto res=pcc(a,b);\n// \tcout.precision(20);\n// \t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n// \tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t\n// \treturn 0;\n// }\n\nint main(void){\n\tC a;\n\t{\n\t\tint x,y,r;\n\t\tcin >> x >> y >> r;\n\t\ta=C({P(x,y),R(r)});\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tL l;\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tl.s=P(x,y);\n\t\t\tcin >> x >> y;\n\t\t\tl.t=P(x,y);\n\t\t}\n\t\tauto res=pcl(a,l);\n\t\tcout.precision(20);\n\t\t//for(auto &it:res) cout << fixed << real(it) << \" \" << imag(it) << endl;\n\t\tcout << fixed << real(res[0]) << \" \" << imag(res[0]) << \" \" << real(res[1]) << \" \" << imag(res[1]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n函数版本:0.3\n*/\n#include<iostream>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#define EPS (1e-15)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\n\nstruct Segment;\nclass Point;\ntypedef Point Vector;\ntypedef Segment Line;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double xx, double yy) {\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tPoint operator + (Point& p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point& p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double k) { return Point(x * k, y * k); }\n\tPoint operator / (double k) { return Point(x / k, y / k); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tdouble dot(Point p) { return x * p.x + y * p.y; }\n\tdouble cross(Point& p) { return x * p.y - y * p.x; }\n\tdouble distance(Point& p) { return (*this - p).abs(); }\n\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point& p) const {\n\t\treturn x - p.x < -EPS || (fabs(x - p.x) < EPS && y - p.y < -EPS);\n\t}\n\n\tvoid input() {\n\t\tcin >> x >> y;\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tvoid input() {\n\t\tp1.input();\n\t\tp2.input();\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tvoid input() {\n\t\tc.input();\n\t\tcin >> r;\n\t}\n};\n\ndouble distance(Point p, Line s) {\n\tVector a = s.p2 - s.p1;\n\tVector b = p - s.p1;\n\treturn a.cross(b) / a.abs();\n}\n\ndouble distanceS(Point p, Segment s) {\n\tVector p1p = p - s.p1;\n\tVector p2p = p - s.p2;\n\tVector p1p2 = s.p2 - s.p1;\n\tVector p2p1 = s.p1 - s.p2;\n\tif (p1p.dot(p1p2) < 0) {\n\t\treturn p1p.abs();\n\t}\n\telse if (p2p.dot(p2p1) < 0) {\n\t\treturn p2p.abs();\n\t}\n\telse {\n\t\treturn distance(p, s);\n\t}\n}\n\nPoint project(Point p, Segment s) {\n\tVector hepo = p - s.p1;\n\tVector base = s.p2 - s.p1;\n\tVector t = base * (hepo.dot(base) / base.norm());\n\treturn s.p1 + t;\n}\n\nint ccw(Point p0, Point p1, Point p) {\n\tVector p0p1 = p1 - p0;\n\tVector p0p;\n\tp0p = p - p0;\n\tif (p0p1.cross(p0p) > EPS) {\n\t\treturn COUNTER_CLOCKWISE;\n\t}\n\telse if (p0p1.cross(p0p) < -EPS) {\n\t\treturn CLOCKWISE;\n\t}\n\telse if (p0p1.dot(p0p) < -EPS) {\n\t\treturn ONLINE_BACK;\n\t}\n\telse if (p0p1.norm() < p0p.norm()) {\n\t\treturn ONLINE_FRONT;\n\t}\n\telse {\n\t\treturn ON_SEGMENT;\n\t}\n}\n\nbool intersection(Segment s1, Segment s2) {\n\tPoint p0 = s1.p1;\n\tPoint p1 = s1.p2;\n\tPoint p2 = s2.p1;\n\tPoint p3 = s2.p2;\n\treturn ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 &&\n\t\tccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0;\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tPoint p1 = s1.p1;\n\tPoint p2 = s1.p2;\n\tPoint p3 = s2.p1;\n\tPoint p4 = s2.p2;\n\tVector p1_p2 = p2 - p1;\n\tVector p1_p3 = p3 - p1;\n\tVector p1_p4 = p4 - p1;\n\tVector p4_p3 = p3 - p4;\n\tdouble d1 = fabs(p1_p2.cross(p1_p4)) / p1_p2.abs();\n\tdouble d2 = fabs(p1_p2.cross(p1_p3)) / p1_p2.abs();\n\tdouble r = d1 / (d1 + d2);\n\tVector p4_p = p4_p3 * r;\n\tPoint p = p4 + p4_p;\n\treturn p;\n}\npair<Point, Point> getCrossPoints(Circle circle, Line s) {\n\tPoint p, p1, p2;\n\tVector base, offset;\n\tdouble dis, d;\n\tp = project(circle.c, s);\n\tdis = distance(circle.c, s);\n\tbase = s.p2 - s.p1;\n\td = sqrt(circle.r * circle.r - dis * dis);\n\toffset = base / base.abs() * d;\n\tp1 = p + offset;\n\tp2 = p - offset;\n\tif (p1 < p2) {\n\t\treturn make_pair(p1, p2);\n\t}\n\telse {\n\t\treturn make_pair(p2, p1);\n\t}\n}\n\nint main() {\n\tCircle circle;\n\tLine s;\n\tint q;\n\tpair<Point, Point> p;\n\n\tcircle.input();\n\tcin >> q;\n\twhile (q--) {\n\t\ts.input();\n\t\tp = getCrossPoints(circle,s);\n\t\tprintf(\"%.9lf %.9lf %.9lf %.9lf\\n\", p.first.x, p.first.y, p.second.x, p.second.y);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#define ESP (1e-13)\nusing namespace std;\n\n//??§?¨????????§???????\ntypedef struct Point {\n\tdouble x; \n\tdouble y;\n\n\tPoint() { }\n\n\tPoint(double x, double y) :x(x), y(y) { }\n\n\tPoint operator+(const Point& p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\n\tPoint operator-(const Point& p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\n\tPoint operator*(const double& a) {\n\t\treturn Point(x*a, y*a);\n\t}\n\n\tPoint operator/(const double& a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tPoint operator=(const Point& p1) {\n\t\treturn Point(p1.x,p1.y);\n\t}\n\n};\n\n//??´??§?????????????§???????\ntypedef Point Vector;\n\n//??´???????§???????\n struct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(const Point& a,const Point& b) : p1(a),p2(b) { }\n};\n\n //??????????§???????\n typedef Line Segment;\n\n //???????§???????\n struct Circle {\n\t Point c;\n\t double r;\n\t Circle(){ }\n\t Circle(const Point& p,const double& r) : c(p),r(r) { }\n };\n\n//2??????????????¢????±?????????¢??°\ndouble abs(Point p1, Point p2) {\n\tdouble norm = (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);\n\treturn sqrt(norm);\n}\n\n//????????¢??°\ndouble product(Vector v1, Vector v2) {\n\treturn v1.x*v2.x + v1.y*v2.y;\n}\n\n//????????¢??°\ndouble cross(Vector p1, Vector p2) {\n\treturn p1.x*p2.y - p1.y*p2.x;\n}\n\n//3??????????????¢???????±?????????¢??°\nint ccw(Point p0, Point p1, Point p2) {\n\tVector v0 = p1 - p0;\n\tVector v1 = p2 - p0;\n\tif (cross(v0, v1) > ESP) return 1;   //p0,p1,p2??????????¨???????\n\tif (cross(v0, v1) < -ESP) return -1;   //p0,p1,p2???????¨???????\n\tif (product(v0, v1) < -ESP) return 2;  //p2,p0,p1????????§????????´??????\n\tif (abs(p0, p1) < abs(p0, p2)) return -2;  //p0,p1,p2????????§????????´??????\n\treturn 0;   //p2?????????(p0,p1)???\n}\n\n//??????????????´????????????????°???±?????§?¨?????±?????????¢??°\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble x = abs(base, Point(0.0, 0.0))*abs(base, Point(0.0, 0.0));\n\tdouble r = product(p - s.p1, base) / x;\n\treturn s.p1 + base*r;\n}\n\n//????????????????±??????¨??????????????????????§°????????§?¨?????±?????????¢??°\nPoint reflect(Segment s, Point p) {\n\treturn (project(s, p) - p)*2.0 + p;\n}\n\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n\treturn (ccw(p0, p1, p2)*ccw(p0, p1, p3) <= 0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n\t//?????????????????????????????¶\n}\n\n//????????????????????£??????????????????????????¢??°\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//??´?????¨???????????¢????±?????????¢??°\ndouble DistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)/abs(l.p1,l.p2));\n}\n\n//????????¨???????????¢????±?????????¢??°\ndouble DistanceSP(Segment s, Point p) {\n\tif (product(s.p2 - s.p1, p - s.p1) < -ESP) return abs(p, s.p1);\n\tif (product(s.p1 - s.p2, p - s.p2) < -ESP) return abs(p, s.p2);\n\treturn DistanceLP(s, p);\n}\n\n//2??????????????¢????±?????????¢??°\ndouble DistanceSS(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(DistanceSP(s1, s2.p1), DistanceSP(s1,s2.p2)), min(DistanceSP(s2, s1.p1), DistanceSP(s2, s1.p2)));\n}\n\n//?????´???????\\???¢????±?????????¢??°\nPoint CrossPoint(Line s1,Line s2) {\n\tdouble d1=DistanceLP(s2, s1.p1);\n\tdouble d2 = DistanceLP(s2, s1.p2);\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//?????¨??´?????????????????????????????¢??°\nbool intersect(Circle c, Line l) {\n\treturn DistanceLP(l, c.c) < c.r;\n}\n\n//?????¨??´????????????????±?????????¢??°\npair<Point, Point> CrossPoints(Circle c, Line l) {\n\tVector prpr = project(l, c.c);\n\tVector hshs = (l.p2 - l.p1)/abs(l.p2 ,l.p1);\n\tdouble base = sqrt(c.r*c.r - abs(c.c, prpr)*abs(c.c, prpr));\n\treturn make_pair(prpr - hshs*base, prpr + hshs*base);\n}\n\n//2??´??????????????¢???????±?????????¢??°???\n   //??´?????????\nbool isOrth(Vector a, Vector b) {\n\treturn abs(product(a, b)) < ESP;\n   }\nbool isOrth(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrth(a1 - a2, b1 - b2);\n}\nbool isOrth(Segment s1, Segment s2) {\n\treturn isOrth(s1.p2, s1.p1, s2.p2, s2.p1);\n}\n    //????????????\nbool isPara(Vector a, Vector b) {\n\treturn abs(cross(a, b)) < ESP;\n}\nbool isPara(Point a1, Point a2, Point b1, Point b2) {\n\treturn isPara(a1 - a2, b1 - b2);\n}\nbool isPara(Segment s1, Segment s2) {\n\treturn isPara(s1.p2, s1.p1, s2.p2, s2.p1);\n}\n\n\nint main() {\n\tCircle c;\n\tint q;\n\tcin >> c.c.x; cin >> c.c.y; cin >> c.r;\n\tcin >> q;\n\tfor (int i = 0;i < q;i++) {\n\t\tLine l;\n\t\tcin >> l.p1.x; cin >> l.p1.y;\n\t\tcin >> l.p2.x; cin >> l.p2.y;\n\t\tpair<Point, Point> crs = CrossPoints(c, l);\n\t\tcout << setprecision(12);\n\t\tif(crs.first.x<crs.second.x)\n\t\tcout << crs.first.x << \" \" << crs.first.y << \" \" << crs.second.x << \" \" << crs.second.y << endl;\n\t\telse if (crs.first.x>crs.second.x)\n\t\tcout << crs.second.x << \" \" << crs.second.y << \" \" << crs.first.x << \" \" << crs.first.y << endl;\n\t\telse if(crs.first.y<crs.second.y)\n\t\tcout << crs.first.x << \" \" << crs.first.y << \" \" << crs.second.x << \" \" << crs.second.y << endl;\n\t\telse\n\t\tcout << crs.second.x << \" \" << crs.second.y << \" \" << crs.first.x << \" \" << crs.first.y << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n  double x, y;\n\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator + (Point p){return Point(x + p.x, y + p.y);}\n  Point operator - (Point p){return Point(x - p.x, y - p.y);}\n  Point operator * (double a){return Point(x * a, y * a);}\n  Point operator / (double a){return Point(x / a, y / a);}\n\n  double abs(){return sqrt(norm());}\n  double norm(){return x * x + y * y;}\n\n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n};\n\ntypedef Point Vector;\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment(Point p1, Point p2): p1(p1), p2(p2){}\n};\n\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0): c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){\n  return a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n  return a.x * b.y - a.y * b.x;\n}\n\nPoint reflect(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p0.x - p1.x, p0.y - p1.y);\n  Vector v21 = Vector(p2.x - p1.x, p2.y - p1.y);\n  double t = -1 * ((p2.x - p1.x) * (p1.x - p0.x) + (p2.y - p1.y) * (p1.y - p0.y)) / (pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));\n  return (v21 * t - v01) * 2 + p0;\n}\n\nPoint project(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p0.x - p1.x, p0.y - p1.y);\n  Vector v21 = Vector(p2.x - p1.x, p2.y - p1.y);\n  double t = -1 * ((p2.x - p1.x) * (p1.x - p0.x) + (p2.y - p1.y) * (p1.y - p0.y)) / (pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));\n  return v21 * t + p1;\n}\n\ndouble dis(Point p1, Point p2){\n  return (p1 - p2).abs();\n}\n\ndouble getdis(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0) return dis(s.p1, p);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0) return dis(s.p2, p);\n  return dis(project(p, s.p1, s.p2), p);\n}\n\nstring ccw(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p1.x - p0.x, p1.y - p0.y);\n  Vector v02 = Vector(p2.x - p0.x, p2.y - p0.y);\n  if(equals(cross(v01, v02), 0)){\n    if(dot(v01, v02) < 0) return \"ONLINE_BACK\";\n    else if(equals(v01.abs(), v02.abs()) == true || v01.abs() > v02.abs()) return \"ON_SEGMENT\";\n    else return \"ONLINE_FRONT\";\n  }\n  else if(cross(v01, v02) > 0) return \"COUNTER_CLOCKWISE\";\n  else return \"CLOCKWISE\";\n}\n\nbool intersect(Segment s1, Segment s2){\n  if(ccw(s1.p1, s1.p2, s2.p2) == \"ON_SEGMENT\" || ccw(s1.p1, s1.p2, s2.p1) == \"ON_SEGMENT\") return true;\n  if(ccw(s2.p1, s2.p2, s1.p2) == \"ON_SEGMENT\" || ccw(s2.p1, s2.p2, s1.p1) == \"ON_SEGMENT\") return true;\n  if(ccw(s1.p1, s1.p2, s2.p1) != ccw(s1.p1, s1.p2, s2.p2)){\n    if(ccw(s1.p1, s2.p1, s2.p2) != ccw(s1.p2, s2.p1, s2.p2)) return true;\n  }\n  return false;\n}\n\nPoint getcrosspoint(Segment s1, Segment s2){\n  Vector base = s2.p2 - s2.p1;\n  Vector hypo1 = s1.p1 - s2.p1;\n  Vector hypo2 = s1.p2 - s2.p2;\n  double d1, d2;\n  d1 = abs(cross(base, hypo1)) / base.abs();\n  d2 = abs(cross(base, hypo2)) / base.abs();\n  return s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getcrosspointcl(Circle c, Line l){\n  Point p = project(c.c, l.p1, l.p2), s;\n  if(p == l.p1) s = l.p2;\n  else s = l.p1;\n  Vector v1 = Vector(p - s);\n  Vector v2 = Vector(c.c - p);\n  double k1, k2, a, b, d;\n  a = v1.abs() * v1.abs();\n  b = -2 * pow(v1.abs(), 2) -2 * dot(v1, v2);\n  d = pow(v1.abs(), 2) + 2 * dot(v1, v2) + pow(v2.abs(), 2) - pow(c.r, 2);\n  k1 = (-1 * b + pow(b * b - 4 * a * d, 0.5)) / (2 * a);\n  k2 = (-1 * b - pow(b * b - 4 * a * d, 0.5)) / (2 * a);\n  return make_pair(s + v1 * k1, s + v1 * k2);\n}\n\nvoid printans(double a, double b, double c, double d){\n  cout << fixed << setprecision(10) << a << \" \" << b << \" \" << c << \" \" << d << endl;\n}\n\nvoid solve(){\n  double cx, cy, r; cin >> cx >> cy >> r;\n  Circle c = Circle(Point(cx, cy), r);\n  int q; cin >> q;\n  vector<pair<Point, Point> > ans(q);\n  for(int i = 0; i < q; i++){\n    double x[2], y[2];\n    Point p[2];\n    for(int i = 0; i < 2; i++){\n      cin >> x[i] >> y[i];\n      p[i] = Point(x[i], y[i]);\n    }\n    Line l = Line(p[0], p[1]);\n    ans[i] = getcrosspointcl(c, l);\n  }\n  for(int i = 0; i < q; i++){\n    double x1 = ans[i].first.x, y1 = ans[i].first.y, x2 = ans[i].second.x, y2 = ans[i].second.y;\n    if(x1 == x2){\n      if(y1 <= y2) printans(x1, y1, x2, y2);\n      else printans(x2, y2, x1, y1);\n    }\n    else if(x1 < x2) printans(x1, y1, x2, y2);\n    else printans(x2, y2, x1, y1);\n  }\n  return;\n}\n\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometry\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ??§ ???????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ??§ ????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b??§?????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c??§?????´??????\n    return 0;  // a -- c -- b??§?????´??????\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  { //OK\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  { //OK\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  { //OK\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n};\n\nvoid solve()\n{\n  Geometry::Circle c;\n  cin >> c.p >> c.r;\n  int N;\n  cin >> N;\n  while(N--) {\n    Geometry::Line l;\n    cin >> l;\n    auto pp = Geometry::Crosspoint(c, l);\n    if(pp.second < pp.first)swap(pp.first, pp.second);\n    cout << pp.first.x << \" \" << pp.first.y << \" \" << pp.second.x << \" \" << pp.second.y << endl;\n  }\n\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 5;\nconst int MOD = 1e9+7;\n\nconst lf eps = 1e-9;\ntypedef double T;\nstruct pt {\n  T x, y;\n  pt operator + (pt p) { return {x+p.x, y+p.y}; }\n  pt operator - (pt p) { return {x-p.x, y-p.y}; }\n  pt operator * (pt p) { return {x*p.x-y*p.y, x*p.y+y*p.x}; }\n  pt operator * (T d) { return {x*d, y*d}; }\n  pt operator / (lf d) { return {x/d, y/d}; } /// only for floating point\n  bool operator == (pt b) { return x == b.x && y == b.y; }\n  bool operator != (pt b) { return !(*this == b); }\n  bool operator < (const pt &o) const { return y < o.y || (y == o.y && x < o.x); }\n  bool operator > (const pt &o) const { return y > o.y || (y == o.y && x > o.x); }\n};\nint cmp (lf a, lf b) { return (a + eps < b ? -1 :(b + eps < a ? 1 : 0)); }\n/** Already in complex **/\nT norm(pt a) { return a.x*a.x + a.y*a.y; }\nlf abs(pt a) { return sqrt(norm(a)); }\nlf arg(pt a) { return atan2(a.y, a.x); }\nostream& operator << (ostream& os, pt &p) {\n  return os << \"(\"<< p.x << \",\" << p.y << \")\";\n}\n/***/\nistream &operator >> (istream &in, pt &p) {\n    T x, y; in >> x >> y;\n    p = {x, y};\n    return in;\n}\nT dot(pt a, pt b) { return a.x*b.x + a.y*b.y; }\nT cross(pt a, pt b) { return a.x*b.y - a.y*b.x; }\nT orient(pt a, pt b, pt c) { return cross(b-a,c-a); }\n//pt rot(pt p, lf a) { return {p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a)}; }\n//pt rot(pt p, double a) { return p * polar(1.0, a); } /// for complex\n//pt rotate_to_b(pt a, pt b, lf ang) { return rot(a-b, ang)+b; }\npt rot90ccw(pt p) { return {-p.y, p.x}; }\npt rot90cw(pt p) { return {p.y, -p.x}; }\npt translate(pt p, pt v) { return p+v; }\npt scale(pt p, double f, pt c) { return c + (p-c)*f; }\nbool are_perp(pt v, pt w) { return dot(v,w) == 0; }\nint sign(T x) { return (T(0) < x) - (x < T(0)); }\npt unit(pt a) { return a/abs(a); }\n\nbool in_angle(pt a, pt b, pt c, pt x) {\n  assert(orient(a,b,c) != 0);\n  if (orient(a,b,c) < 0) swap(b,c);\n  return orient(a,b,x) >= 0 && orient(a,c,x) <= 0;\n}\n\n//lf angle(pt a, pt b) { return acos(max(-1.0, min(1.0, dot(a,b)/abs(a)/abs(b)))); }\n//lf angle(pt a, pt b) { return atan2(cross(a, b), dot(a, b)); }\n/// returns vector to transform points\npt get_linear_transformation(pt p, pt q, pt r, pt fp, pt fq) {\n  pt pq = q-p, num{cross(pq, fq-fp), dot(pq, fq-fp)};\n  return fp + pt{cross(r-p, num), dot(r-p, num)} / norm(pq);\n}\n\nbool half(pt p) { /// true if is in (0, 180]\n  assert(p.x != 0 || p.y != 0); /// the argument of (0,0) is undefined\n  return p.y > 0 || (p.y == 0 && p.x < 0);\n}\nbool half_from(pt p, pt v = {1, 0}) {\n  return cross(v,p) < 0 || (cross(v,p) == 0 && dot(v,p) < 0);\n}\nbool polar_cmp(const pt &a, const pt &b) {\n  return make_tuple(half(a), 0) < make_tuple(half(b), cross(a,b));\n}\n\nstruct line {\n  pt v; T c;\n  line(pt v, T c) : v(v), c(c) {}\n  line(T a, T b, T c) : v({b,-a}), c(c) {}\n  line(pt p, pt q) : v(q-p), c(cross(v,p)) {}\n  T side(pt p) { return cross(v,p)-c; }\n  lf dist(pt p) { return abs(side(p)) / abs(v); }\n  lf sq_dist(pt p) { return side(p)*side(p) / (lf)norm(v); }\n  line perp_through(pt p) { return {p, p + rot90ccw(v)}; }\n  bool cmp_proj(pt p, pt q) { return dot(v,p) < dot(v,q); }\n  line translate(pt t) { return {v, c + cross(v,t)}; }\n  line shift_left(double d) { return {v, c + d*abs(v)}; }\n  pt proj(pt p) { return p - rot90ccw(v)*side(p)/norm(v); }\n  pt refl(pt p) { return p - rot90ccw(v)*2*side(p)/norm(v); }\n};\n\nbool inter_ll(line l1, line l2, pt &out) {\n  T d = cross(l1.v, l2.v);\n  if (d == 0) return false;\n  out = (l2.v*l1.c - l1.v*l2.c) / d;\n  return true;\n}\n/*line bisector(line l1, line l2, bool interior) {\n  assert(cross(l1.v, l2.v) != 0); /// l1 and l2 cannot be parallel!\n  lf sign = interior ? 1 : -1;\n  return {l2.v/abs(l2.v) + l1.v/abs(l1.v) * sign,\n          l2.c/abs(l2.v) + l1.c/abs(l1.v) * sign};\n}*/\n\nbool in_disk(pt a, pt b, pt p) {\n  return dot(a-p, b-p) <= 0;\n}\nbool on_segment(pt a, pt b, pt p) {\n  return orient(a,b,p) == 0 && in_disk(a,b,p);\n}\nbool proper_inter(pt a, pt b, pt c, pt d, pt &out) {\n  T oa = orient(c,d,a),\n  ob = orient(c,d,b),\n  oc = orient(a,b,c),\n  od = orient(a,b,d);\n  /// Proper intersection exists iff opposite signs\n  if (oa*ob < 0 && oc*od < 0) {\n    out = (a*ob - b*oa) / (ob-oa);\n    return true;\n  }\n  return false;\n}\nset<pt> inter_ss(pt a, pt b, pt c, pt d) {\n  pt out;\n  if (proper_inter(a,b,c,d,out)) return {out};\n  set<pt> s;\n  if (on_segment(c,d,a)) s.insert(a);\n  if (on_segment(c,d,b)) s.insert(b);\n  if (on_segment(a,b,c)) s.insert(c);\n  if (on_segment(a,b,d)) s.insert(d);\n  return s;\n}\nlf pt_to_seg(pt a, pt b, pt p) {\n  if(a != b) {\n    line l(a,b);\n    if (l.cmp_proj(a,p) && l.cmp_proj(p,b)) /// if closest to  projection\n      return l.dist(p); /// output distance to line\n  }\n  return min(abs(p-a), abs(p-b)); /// otherwise distance to A or B\n}\nlf seg_to_seg(pt a, pt b, pt c, pt d) {\n  pt dummy;\n  if (proper_inter(a,b,c,d,dummy)) return 0;\n  return min({pt_to_seg(a,b,c), pt_to_seg(a,b,d),\n              pt_to_seg(c,d,a), pt_to_seg(c,d,b)});\n}\n\nenum {IN, OUT, ON};\nstruct polygon {\n  vector<pt> p;\n  polygon(int n) : p(n) {}\n  int top = -1, bottom = -1;\n  void delete_repetead() {\n    vector<pt> aux;\n    sort(p.begin(), p.end());\n    for(pt &i : p)\n      if(aux.empty() || aux.back() != i)\n        aux.push_back(i);\n    p.swap(aux);\n  }\n  bool is_convex() {\n    bool pos = 0, neg = 0;\n    for (int i = 0, n = p.size(); i < n; i++) {\n      int o = orient(p[i], p[(i+1)%n], p[(i+2)%n]);\n      if (o > 0) pos = 1;\n      if (o < 0) neg = 1;\n    }\n    return !(pos && neg);\n  }\n  lf area(bool s = false) {\n    lf ans = 0;\n    for (int i = 0, n = p.size(); i < n; i++)\n      ans += cross(p[i], p[(i+1)%n]);\n    ans /= 2;\n    return s ? ans : abs(ans);\n  }\n  lf perimeter() {\n    lf per = 0;\n    for(int i = 0, n = p.size(); i < n; i++)\n      per += abs(p[i] - p[(i+1)%n]);\n    return per;\n  }\n  bool above(pt a, pt p) { return p.y >= a.y; }\n  bool crosses_ray(pt a, pt p, pt q) {\n    return (above(a,q)-above(a,p))*orient(a,p,q) > 0;\n  }\n  int in_polygon(pt a) {\n    int crosses = 0;\n    for(int i = 0, n = p.size(); i < n; i++) {\n      if(on_segment(p[i], p[(i+1)%n], a)) return ON;\n      crosses += crosses_ray(a, p[i], p[(i+1)%n]);\n    }\n    return (crosses&1 ? IN : OUT);\n  }\n  void normalize() { /// polygon is CCW\n    bottom = min_element(p.begin(), p.end()) - p.begin();\n    vector<pt> tmp(p.begin()+bottom, p.end());\n    tmp.insert(tmp.end(), p.begin(), p.begin()+bottom);\n    p.swap(tmp);\n    bottom = 0;\n    top = max_element(p.begin(), p.end()) - p.begin();\n  }\n  int in_convex(pt a) {\n    assert(bottom == 0 && top != -1);\n    if(a < p[0] || a > p[top]) return OUT;\n    T orientation = orient(p[0], p[top], a);\n    if(orientation == 0) {\n      if(a == p[0] || a == p[top]) return ON;\n      return top == 1 || top + 1 == p.size() ? ON : IN;\n    } else if (orientation < 0) {\n      auto it = lower_bound(p.begin()+1, p.begin()+top, a);\n      T d = orient(*prev(it), a, *it);\n      return d < 0 ? IN : (d > 0 ? OUT: ON);\n    }\n    else {\n      auto it = upper_bound(p.rbegin(), p.rend()-top-1, a);\n      T d = orient(*it, a, it == p.rbegin() ? p[0] : *prev(it));\n      return d < 0 ? IN : (d > 0 ? OUT: ON);\n    }\n  }\n  polygon cut(pt a, pt b) {\n    line l(a, b);\n    polygon new_polygon(0);\n    for(int i = 0, n = p.size(); i < n; ++i) {\n      pt c = p[i], d = p[(i+1)%n];\n      lf abc = cross(b-a, c-a), abd = cross(b-a, d-a);\n      if(abc >= 0) new_polygon.p.push_back(c);\n      if(abc*abd < 0) {\n        pt out; inter_ll(l, line(c, d), out);\n        new_polygon.p.push_back(out);\n      }\n    }\n    return new_polygon;\n  }\n  void convex_hull() {\n    sort(p.begin(), p.end());\n    vector<pt> ch;\n    ch.reserve(p.size()+1);\n    for(int it = 0; it < 2; it++) {\n      int start = ch.size();\n      for(auto &a : p) {\n        /// if colineal are needed, use < and remove repeated points\n        while(ch.size() >= start+2 && orient(ch[ch.size()-2], ch.back(), a) <= 0)\n          ch.pop_back();\n        ch.push_back(a);\n      }\n      ch.pop_back();\n      reverse(p.begin(), p.end());\n    }\n    if(ch.size() == 2 && ch[0] == ch[1]) ch.pop_back();\n    /// be careful with CH of size < 3\n    p.swap(ch);\n  }\n  vector<pii> antipodal() {\n    vector<pii> ans;\n    int n = p.size();\n    if(n == 2) ans.push_back({0, 1});\n    if(n < 3) return ans;\n    auto nxt = [&](int x) { return (x+1 == n ? 0 : x+1); };\n    auto area2 = [&](pt a, pt b, pt c) { return cross(b-a, c-a); };\n    int b0 = 0;\n    while(abs(area2(p[n - 1], p[0], p[nxt(b0)])) >\n          abs(area2(p[n - 1], p[0], p[b0])))\n      ++b0;\n    for(int b = b0, a = 0; b != 0 && a <= b0; ++a) {\n      ans.push_back({a, b});\n      while (abs(area2(p[a], p[nxt(a)], p[nxt(b)])) >\n             abs(area2(p[a], p[nxt(a)], p[b]))) {\n        b = nxt(b);\n        if(a != b0 || b != 0) ans.push_back({ a, b });\n        else return ans;\n      }\n      if(abs(area2(p[a], p[nxt(a)], p[nxt(b)])) ==\n         abs(area2(p[a], p[nxt(a)], p[b]))) {\n        if(a != b0 || b != n-1) ans.push_back({ a, nxt(b) });\n        else ans.push_back({ nxt(a), b });\n      }\n    }\n    return ans;\n  }\n  pt centroid() {\n    pt c{0, 0};\n    lf scale = 6. * area(true);\n    for(int i = 0, n = p.size(); i < n; ++i) {\n      int j = (i+1 == n ? 0 : i+1);\n      c = c + (p[i] + p[j]) * cross(p[i], p[j]);\n    }\n    return c / scale;\n  }\n  ll pick() {\n    ll boundary = 0;\n    for(int i = 0, n = p.size(); i < n; i++) {\n      int j = (i+1 == n ? 0 : i+1);\n      boundary += __gcd((ll)abs(p[i].x - p[j].x), (ll)abs(p[i].y - p[j].y));\n    }\n    return area() + 1 - boundary/2;\n  }\n  pt& operator[] (int i){ return p[i]; }\n};\n\nstruct circle {\n  pt c; T r;\n};\n\ncircle center(pt a, pt b, pt c) {\n  b = b-a, c = c-a;\n  assert(cross(b,c) != 0); /// no circumcircle if A,B,C aligned\n  pt cen = a + rot90ccw(b*norm(c) - c*norm(b))/cross(b,c)/2;\n  return {cen, abs(a-cen)};\n}\nint inter_cl(circle c, line l, pair<pt, pt> &out) {\n  lf h2 = c.r*c.r - l.sq_dist(c.c);\n  if(h2 >= 0) {\n    pt p = l.proj(c.c);\n    pt h = l.v*sqrt(h2)/abs(l.v);\n    out = {p-h, p+h};\n  }\n  return 1 + sign(h2);\n}\nint inter_cc(circle c1, circle c2, pair<pt, pt> &out) {\n  pt d=c2.c-c1.c; double d2=norm(d);\n  if(d2 == 0) { assert(c1.r != c2.r); return 0; } // concentric circles\n  double pd = (d2 + c1.r*c1.r - c2.r*c2.r)/2; // = |O_1P| * d\n  double h2 = c1.r*c1.r - pd*pd/d2; // = hˆ2\n  if(h2 >= 0) {\n    pt p = c1.c + d*pd/d2, h = rot90ccw(d)*sqrt(h2/d2);\n    out = {p-h, p+h};\n  }\n  return 1 + sign(h2);\n}\n\nint tangents(circle c1, circle c2, bool inner, vector<pair<pt,pt>> &out) {\n  if(inner) c2.r = -c2.r;\n  pt d = c2.c-c1.c;\n  double dr = c1.r-c2.r, d2 = norm(d), h2 = d2-dr*dr;\n  if(d2 == 0 || h2 < 0) { assert(h2 != 0); return 0; }\n  for(double s : {-1,1}) {\n    pt v = (d*dr + rot90ccw(d)*sqrt(h2)*s)/d2;\n    out.push_back({c1.c + v*c1.r, c2.c + v*c2.r});\n  }\n  return 1 + (h2 > 0);\n}\n\nint main() {\n//  ios::sync_with_stdio(0);\n//  cin.tie(0);\n\n  #ifdef LOCAL\n      freopen(\"input.txt\", \"r\", stdin);\n      freopen(\"output.txt\", \"w\", stdout);\n  #else\n      #define endl '\\n'\n  #endif // LOCAL\n\n  cout << fixed << setprecision(10);\n\n  circle c;\n  cin >> c.c >> c.r;\n  int q; cin >> q;\n  while(q--) {\n    pt a, b; cin >>  a>> b;\n    line l(a, b);\n    pair<pt, pt> ans;\n    inter_cl(c, l, ans);\n    if(ans.first.x > ans.second.x) swap(ans.first, ans.second);\n    if(ans.first.x == ans.second.x && ans.first.y > ans.second.y) swap(ans.first, ans.second);\n    cout << ans.first.x << \" \" << ans.first.y << \" \" << ans.second.x << \" \" << ans.second.y << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<utility>\nusing namespace std;\n\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator+(Point p){\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator*(double d){\n        return Point(x * d, y * d);\n    }\n};\ntypedef Point Vector;\ndouble dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\ndouble cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\nstruct Line{\n    Point p1;\n    Point p2;\n    Line(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c, double r): c(c), r(r) {}\n};\n\npair<Point, Point> cross_point(Circle c, Line l){\n    Vector b = l.p2 - l.p1;\n    Vector h = c.c - l.p1;\n    double d = fabs(cross(b, h)) / sqrt(dot(b, b));\n    Point x =  l.p1 + b * (dot(h, b) / dot(b, b));\n    Point alpha = b * (sqrt(c.r * c.r - d * d) / sqrt(dot(b, b)));\n    return make_pair(x + alpha, x - alpha);\n}\n\nvoid disp(pair<Point, Point> p){\n    Point f = p.first;\n    Point s = p.second;\n    if (f.x > s.x || (f.x == s.x && f.y > s.y)) swap(f, s);\n    cout << fixed << setprecision(10);\n    cout << f.x << \" \" << f.y << \" \" << s.x << \" \" << s.y << endl;\n}\n\nint main(){\n    int cx, cy, r;\n    cin >> cx >> cy >> r;\n    Circle c(Point(cx, cy), r);\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line l(Point(x1, y1), Point(x2, y2));\n        disp(cross_point(c, l));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem\nusing namespace placeholders;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P = complex<R>;\nusing L = struct {P s, t;};\nusing VP = vector<P>;\nusing C = struct {P c; R r;};\n\n#define at(a,i) (a[(i + a.size()) % a.size()])\n\nauto& operator >> (istream& is, P& p) { R x, y; is >> x >> y, p = P(x, y); return is;}\nauto& operator << (ostream& os, P& p) { os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\nbool operator <  (const P& a, const P& b) { return sgn(real(a - b)) ? real(a - b) < 0 : sgn(imag(a - b)) < 0;}\nbool operator == (const P& a, const P& b) { return sgn(real(a - b)) == 0 && sgn(imag(a - b)) == 0;}\n}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline P vec(L l) {return l.t - l.s;}\nauto sdot = bind(sgn, bind(dot, _1, _2, _3));\nauto sdet = bind(sgn, bind(det, _1, _2, _3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l, P p) { R u = real((p - l.s) / vec(l)); return (1 - u) * l.s + u * l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a, L b) {return sdot(0, vec(a), vec(b)) == 0;}\nbool parallel(L a, L b) {return sdet(0, vec(a), vec(b)) == 0;}\nbool eql(L a, L b) { return parallel(a, b) and sdet(a.s, a.t, b.s) == 0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\n// crossing point\n// verified: AOJ CGL_2_C\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(0, vec(a), vec(b));\n\treturn (1 - u) * a.s + u * a.t;\n}\n\n// distance\n// verified: AOJ CGL_2_D\nR dsp(L l, P p) {\n\tP h = proj(l, p);\n\tif (sdot(l.s, l.t, p) <= 0) h = l.s;\n\tif (sdot(l.t, l.s, p) <= 0) h = l.t;\n\treturn abs(p - h);\n}\n\nR dss(L a, L b) {return iss(a, b) ? 0 : min({dsp(a, b.s), dsp(a, b.t), dsp(b, a.s), dsp(b, a.t)});}\n\n// Polygon\n\n// area\n// verified: AOJ 1100 CGL_3_A\nR area(const VP& pol) {\n\tR sum = 0.0;\n\trep(i, pol.size()) sum += det(0, at(pol, i), at(pol, i + 1));\n\treturn abs(sum / 2.0L);\n}\n\n// convex_polygon determination\n// verified: CGL_3_B\nbool is_convex(const VP& pol) {\n\trep(i, pol.size())if (sdet(at(pol, i), at(pol, i + 1), at(pol, i + 2)) < 0) return false;\n\treturn true;\n}\n\n// polygon realation determination  in  2 on 1 out 0???(possible non-convex)\n// verified: AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p) {\n\tint res = 0;\n\tauto simag = [](const P & p) {return sgn(imag(p));};\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tif (sdet(p, a, b) == 0 and sdot(p, a, b) <= 0) return 1;\n\t\tbool f = simag(p - a) >= 0, s = simag(p - b) < 0;\n\t\tif (simag(b - a)*sdet(a, b, p) == 1 and f == s) res += (2 * f - 1);\n\t}\n\treturn res ? 2 : 0;\n}\n\n// polygon realation determination???(possible non-convex)\n// verified: not AOJ 2514\nbool in_polygon(const VP& pol, const L& l) {\n\tVP check = {l.s, l.t};\n\trep(i, pol.size()) {\n\t\tL edge = {at(pol, i), at(pol, i + 1)};\n\t\tif (iss(l, edge)) check.emplace_back(cross(l, edge));\n\t}\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tsort(begin(check), end(check), cmp_x);\n\trep(i, check.size() - 1) {\n\t\tP m = (at(check, i) + at(check, i + 1)) / 2.0L;\n\t\tif (in_polygon(pol, m) == false) return false;\n\t}\n\treturn true;\n}\n\n// convex_cut\n// verified: AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tint da = sdet(l.s, l.t, a), db = sdet(l.s, l.t, b);\n\t\tif (da >= 0) res.emplace_back(a);\n\t\tif (da * db < 0) res.emplace_back(cross({a, b}, l));\n\t}\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol) {\n\tint n = pol.size(), i = 0, j = 0;\n\tif (n <= 2) return abs(pol[0] - pol[1]);\n\tR res = 0.0;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\trep(k, n) {\n\t\tif (!cmp_x(pol[i], pol[k]))i = k;\n\t\tif (cmp_x(pol[j], pol[k]))j = k;\n\t}\n\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) {\n\t\tres = max(res, abs(pol[i] - pol[j]));\n\t\tif (sdet(0, vec(L{at(pol, i), at(pol, i + 1)}), vec(L{at(pol, j), at(pol, j + 1)})) < 0)\n\t\t\ti = (i + 1) % n;\n\t\telse\n\t\t\tj = (j + 1) % n;\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR iscp(VP a, int flag = 1) {\n\tconst int n = a.size(), m = n / 2;\n\tif (n <= 1) return INF;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tif (flag) sort(begin(a), end(a), cmp_x);\n\n\tVP b(begin(a), begin(a) + m), c(begin(a) + m, end(a));\n\tR x = real(a[m]), d = min(iscp(b, 0), iscp(c, 0));\n\n\n\tauto cmp_y = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn si ? si < 0 : sr < 0;\n\t};\n\n\tsort(begin(a), end(a), cmp_y);\n\tdeque<P> e;\n\n\tfor (auto &p : a) {\n\t\tif (abs(real(p) - x) >= d) continue;\n\n\t\tfor (auto &q : e) {\n\t\t\tif (imag(p - q) >= d) break;\n\t\t\td = min(d, abs(p - q));\n\t\t}\n\t\te.push_front(p);\n\t}\n\treturn d;\n}\n\n// Circle // verified: AOJ 1183\nenum RCC {OUT = 2, ON_OUT = 1, ISC = 0, ON_IN = -1, IN = -2};\nint rcc(C a, C b) { R d = abs(a.c - b.c); return sgn(d - a.r - b.r) + sgn(d - abs(a.r - b.r));}\n\n// circle crossing determination\nbool iisc(C c, P p, int end = 0) {return sgn(abs(p - c.c) - c.r) <= -end;}\nbool ics(C c, L s, int end = 0) {return sgn(dsp(s, c.c) - c.r) <= -end;}\nbool icsc(C c, L l, int end = 0) {\n\treturn ics(c, l) and sgn(max(abs(l.s - c.c), abs(l.t - c.c)) - c.r) <= 0;\n}\n\n// common area between circles\nR area(C a, C b) {\n\tint r = rcc(a, b);\n\tif (r >= ON_OUT) return 0.0L;\n\tif (r <= ON_IN) return min(norm(a.r), norm(b.r)) * PI;\n\tR d = abs(b.c - a.c), rc = (norm(d) + norm(a.r) - norm(b.r)) / (2.0 * d);\n\tR t = acos(rc / a.r), p = acos((d - rc) / b.r);\n\treturn norm(a.r) * t + norm(b.r) * p - d * a.r * sin(t);\n}\n\n// cross point between circle and line\n// verified: AOJ CGL_7_D\nP cir(C c, R t) {return c.c + polar(c.r, t);}\nVP cross(C c, L l) {\n\tP h = proj(l, c.c);\n\tP e = polar(sq(norm(c.r) - norm(h - c.c)), arg(vec(l)));\n\treturn VP{h - e, h + e};\n}\n\n// cross point between circles\n// verified: AOJ CGL_7_E\nVP cross(C a, C b) {\n\tP d = b.c - a.c;\n\tP w = (norm(d) + norm(a.r) - norm(b.r)) / (2.0L * norm(d)) * d;\n\treturn cross(a, {a.c + w, a.c + w + 1il * d});\n}\n\n// circle tangent\n// verified: AOJ CGL_7_F\nL tan(C c, P p) {return L{p, p + 1il * (p - c.c)};}\n\nP helper(C c, P d, R r, P j) {\n\tP tmp = sq(norm(d) - norm(r)) * j;\n\tP dir = (r + tmp) / norm(d) * d;\n\treturn c.c + c.r * dir;\n}\n\nVP contact(C c, P p) {\n\tVP ret;\n\tP d = p - c.c;\n\tfor (P j : { -1il, 1il}) ret.emplace_back(helper(c, d, c.r, j));\n\tsort(begin(ret), end(ret));\n\tret.erase(unique(begin(ret), end(ret)), end(ret));\n\treturn ret;\n}\n\n// circle tangent\n// Verified: AOJ CGL_7_G\nVP contact(C a, C b) {\n\tVP ret;\n\tP d = b.c - a.c;\n\tfor (int s : { -1, 1}) {\n\t\tif (rcc(a, b) >= s) {\n\t\t\tfor (P j : { -1i, 1i}) {\n\t\t\t\tR r = a.r + s * b.r;\n\t\t\t\tret.emplace_back(helper(a, d, r, j));\n\t\t\t}\n\t\t}\n\t}\n\tsort(begin(ret), end(ret));\n\tret.erase(unique(begin(ret), end(ret)), end(ret));\n\treturn ret;\n}\n/*\n// common area of circle and polygon\nR area(R r, P a, P b) {\n\treturn sgn(abs((a + b) / 2.0l) - r) <= 0 ? det(0, a, b) / 2.0l : norm(r) * arg(b - a) / 2.0l;\n}\n\nR area(C c, VP pol) {\n\tR res = 0;\n\trep(i, pol.size()){\n\t\tR r = c.r;\n\t\tP a = at(pol, i) - c.c , b = at(pol, i + 1) - c.c;\n\t\tif (sgn(min({r, abs(a), abs(b), abs(b - a)})) == 0) continue;\n\n\t\tVP isc = cross(C{0.0l, r}, L{a, b});\n\t\tif (sdot(a, isc[0], isc[1]) <= 0 and sdot(b, isc[0], isc[1]) <= 0) \n\t\t\tres += area(r, a, b);\n\t\telse \n\t\t\tres += area(r, a, isc[0]) + area(r, isc[0], isc[1]) + area(r, isc[1], b);\n\t}\n\treturn res;\n}\n*/int main(void){\n\tint q;\n\tC c;\n\tcin >> c.c >> c.r;\n\t\t\n\tcin >> q;\n\tcout.precision(20);\n\trep(i,q){\n\t\tP a,b;\n\t\tcin >> a >> b;\n\t\tL l={a,b};\n\t\tVP res=cross(c,l);\n\t\tif(sgn(real(res[0])-real(res[1])>0)) swap(res[0],res[1]);\n\t\tif(sgn(real(res[0])-real(res[1]))==0 and sgn(imag(res[0])-imag(res[1]))>0) swap(res[0],res[1]);\n\t\tcout << fixed << res[0] << \" \" << res[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); i++)\n#define pb push_back\n#define all(X) X.begin(), X.end()\n\n#define X real()\n#define Y imag()\n#define x(p) real(p)\n#define y(p) imag(p)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1)%P.size()]\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n\t\t\tcross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n// enum { OUT, ON, IN };\n// int contains(const G& pol, const P& p){\n// \tif(pol.size() < 2) return OUT;\n// \tif(intersectSP({pol[0], pol[1]}, p)) return ON;\n// \tbool f = cross(pol[1]-pol[0], p - pol[0]) > 0;\n// \tfor(int i = 1; i < pol.size(); i++) {\n// \t\tauto& now = curr(pol, i);\n// \t\tauto& nxt = next(pol, i);\n// \t\tif(intersectSP({nxt, now}, p)) return ON;\n// \t\tif(f^(cross(nxt-now, p-now)>0)) return OUT;\n// \t}\n// \treturn IN;\n// }\n//??????????§???¢?????????????????????(polygon??????????¨???????)\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\nbool contains(const polygon& a, const polygon& b) {\n\trep(i, a.size()) if(contains(b, a[i]) == OUT) return false;\n\treturn true;\n}\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT, HIT, A_IN_B, B_IN_A};\nint isHit(const polygon& a, const polygon& b){\n\tif(contains(a, b)) return A_IN_B;\n\tif(contains(b, a)) return B_IN_A;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n\n//point???theta???????????¢\npoint spinP(const point& p, double theta, double ext = 1.0) {\n\treturn p*P(cos(theta),sin(theta))*ext;\n}\n\npoint makeP(double r, double arg) {return P(r*cos(arg), r*sin(arg));}\n\n//?????¨????????????????±???????\nvector<P> crossPoint(const C& a, const C& b){\n\tdouble d = abs(b.p-a.p);\n\tdouble arg = atan2(y(b.p-a.p), x(b.p-a.p));\n\tdouble arg2 = acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r));\n\tif(abs(arg2)<EPS) return {a.r*makeP(1.0, arg)+a.p};\n\tif(abs(a.r-b.r)<d && d < a.r+b.r) return {a.r*makeP(1.0, arg+arg2)+a.p, a.r*makeP(1.0, arg-arg2)+a.p};\n\treturn {};\n}\n\n//????????±?????\\???\nvector<L> comonTang(C c1, C c2) {\n\tvector<L> ret;\n\tif(c1.r > c2.r) swap(c1, c2);\n\tP sub = c1.p;\n\tc1.p -= sub;\n\tc2.p -= sub;\n\tdouble theta = atan2(c2.p.Y, c2.p.X);\n\n\tc2.p = spinP(c2.p, -theta);\n\tint signX = 0;\n\tif(c2.p.X > 0) signX = 1;\n\tif(c2.p.X < 0) signX = -1;\n\n\tdouble x = abs(c2.p.X), r1 = c1.r, r2 = c2.r;\n\tif(abs(x*x -(r2 - r1) * (r2 - r1))<EPS) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t}\n\telse if(x*x > (r2 - r1) * (r2 - r1)) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t\tret.pb({spinP({0, -r1}, -theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), -r1}, -theta2)});\n\t}\n\tif(abs(r1+r2-x)<EPS) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t}\n\telse if(x > r1+r2) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t\tret.pb({spinP({0, -r1}, -theta3), spinP({len, -r1}, theta3)});\n\t}\n\n\tfor(auto& l : ret) {\n\t\tif(signX == -1) l[1] = {-l[1].X, l[1].Y};\n\t\tl[0] = spinP(l[0], theta);\n\t\tl[1] = spinP(l[1], theta);\n\t\tl[0] += sub;\n\t\tl[1] += sub;\n\t}\n\treturn ret;\n}\n\ndouble getArea(const polygon& pol) {\n\tint n = pol.size();\n\tdouble s = 0.0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint now = i, nxt = (i + 1) % n;\n\t\ts += (pol[now].X - pol[nxt].X) * (pol[now].Y + pol[nxt].Y);\n\t}\n\treturn abs(s/2.0);\n}\n\n//?????? - convex hull\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n  \tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n  \t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  \tfor (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n  \t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  \tch.resize(k-1);\n  \treturn ch;\n}\n//???????¨??????????polygon????????????????????????\t\t\tCGL_3_B\nbool isHull(const G& g) {\n\tint n = g.size();\n\tif(n < 3) return false;\n\trep(i, n) if(ccw(prev(g, i), curr(g, i), next(g, i)) == -1) return false;\n\treturn true;\n}\nbool contains(const P& p, const C& c) {\n\treturn abs(p-c.p) < c.r+EPS;\n}\nint posRel(const L&s, const C&c){\n\tif(abs(distanceSP(s,c.p)-c.r)<EPS)\treturn 1;\t//??\\?????????\n\tif(distanceSP(s,c.p) > c.r+EPS) \treturn 0;\t//????????£????????????\n\tif(contains(s[0], c) && contains(s[1], c))\treturn 2;\t//????????????\n\tif(contains(s[0], c)||contains(s[1], c))\treturn 3;\t//?????´???????????????\n\treturn 4;\t//????????????\n}\nvector<P> crossPoint(C c, L l) {\n\tint hit = posRel(l, c);\n\t//if(hit == 0) return {};\n\t\n\tdouble R = c.r;\n\tP sub = c.p;\n\tdouble theta;\n\n\tl[0] -= sub;\n\tl[1] -= sub;\n\n\ttheta = atan2(imag(l[1]-l[0]), real(l[1]-l[0]));\n\n\tl[0] = spinP(l[0], -theta);\n\tl[1] = spinP(l[1], -theta);\n\n\tassert(abs(imag(l[0]-l[1])) < EPS);\n\n\tvector<P> ret;\n\tif(abs(abs(l[0].Y) - R) < EPS) ret.pb({0.0, l[0].Y});\n\telse {\n\t\tdouble y = l[0].Y;\n\t\tdouble x = sqrt(R*R-y*y);\n\t\tret.pb({x, y});\n\t\tret.pb({-x, y});\n\t}\n\n\trep(i, ret.size()) {\n\t\tret[i] = spinP(ret[i], theta);\n\t\tret[i] += sub;\n\t}\n\trep(i, ret.size()) {\n\t\tif(abs(ret[i].X) < EPS) ret[i] = {0.0, ret[i].Y};\n\t}\n\treturn ret;\n}\n\nint main() {\n\tdouble x, y, r;\n\tcin >> x >> y >> r;\n\tC c({x, y}, r);\n\tint q;\n\tcin >> q;\n\trep(i, q) {\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tL l({x1, y1}, {x2, y2});\n\t\tvector<P> a = crossPoint(c, l);\n\t\tif(a.size() == 1) a.pb(a[0]);\n\t\tsort(all(a));\n\t\tassert(a.size() == 2);\n\t\tprintf(\"%.15lf %.15lf %.15lf %.15lf\\n\", a[0].X, a[0].Y, a[1].X, a[1].Y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n\tvoid show() { printf(\"%.10lf %.10lf\", x, y); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\tdouble d = getDistanceLP(l, c.c);\n\treturn d <= c.r;\n}\ndouble getDistance(Point a, Point b) {\n\treturn absv(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / absv(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absv(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absv(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1)*(d1 / (d1 + d2));\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tPoint pr = project(l, c.c);\n\tVector lv = l.p2 - l.p1;\n\tVector le = lv / absv(lv);\n\tdouble base = sqrt(c.r*c.r - norm(c.c - pr));\n\treturn make_pair(pr + le*base, pr - le*base);\n}\n\nint main() {\n\tint q, x[2], y[2];\n\tint cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tCircle c = Circle(Point(cx, cy), r);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tLine l = { p1,p2 };\n\t\tpair<Point, Point> ans = getCrossPoints(c, l);\n\t\tans.first.show();\n\t\tcout << \" \";\n\t\tans.second.show();\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 50000 + 10;\nconst double pi = acos(-1.0);\nconst double inf = 1e100;\nconst double eps = 1e-12;\n\nstruct vec { //点的基本数据结构\n    double x, y;\n    vec(double _x = 0, double _y = 0)\n        : x(_x)\n        , y(_y)\n    {\n    }\n    vec operator*(const vec& i_T) const\n    {\n        return vec(x * i_T.x, y * i_T.y);\n    }\n    vec operator*(double u) const\n    {\n        return vec(x * u, y * u);\n    }\n    bool operator==(const vec& i_T) const\n    {\n        return x == i_T.x && y == i_T.y;\n    }\n    vec operator/(double u) const\n    {\n        return vec(x / u, y / u);\n    }\n    vec operator+(const vec& i_T)\n    {\n        return vec(x + i_T.x, y + i_T.y);\n    }\n    vec operator-(const vec& i_T)\n    {\n        return vec(x - i_T.x, y - i_T.y);\n    }\n    friend bool operator<(vec a, vec b)\n    {\n        return a.y == b.y ? a.x < b.x : a.y < b.y;\n    }\n    friend ostream& operator<<(ostream& out, vec& a)\n    {\n        //cout << a.x << ' ' << a.y;\n        printf(\"%.8f %.8f\", a.x, a.y);\n        return out;\n    }\n    friend istream& operator>>(istream& in, vec& a)\n    {\n        in >> a.x >> a.y;\n        return in;\n    }\n};\nstruct cirles {\n    vec o;\n    double r;\n    friend istream& operator>>(istream& in, cirles& a)\n    {\n        in >> a.o >> a.r;\n        return in;\n    }\n    friend ostream& operator<<(ostream& out, cirles& a)\n    {\n        out << a.o << ' ' << a.r;\n        return out;\n    }\n};\nstruct Line {\n    vec a, b;\n    friend istream& operator>>(istream& in, Line& a)\n    {\n        cin >> a.a >> a.b;\n        return in;\n    }\n    friend ostream& operator<<(ostream& out, Line& a)\n    {\n        out << a.a << ' ' << a.b;\n        return out;\n    }\n};\ndouble changdu(vec a) //长度\n{\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble chaji(vec A, vec B) //求向量叉积\n{\n    return A.x * B.y - A.y * B.x; // 正为A->B左旋\n}\ndouble dianji(vec A, vec B) //点积\n{\n    return A.x * B.x + A.y * B.y;\n}\nvec touying(Line l, vec c) //c投影在ab上的位置\n{\n    vec A = l.b - l.a;\n    vec B = c - l.a;\n    double La = changdu(A);\n    double Lc = dianji(A, B) / (La * La);\n    return vec(Lc * A.x, Lc * A.y) + l.a;\n}\nint zhengfu(double d) //判断正负\n{\n    if (fabs(d) < eps)\n        return 0;\n    if (d > 0)\n        return 1;\n    return -1;\n}\nint dayu_dengyu(double x, double y)\n{\n    if (x > y || fabs(x - y) < eps)\n        return 1;\n    return 0;\n}\ndouble zhixian_yuanxin_juli(Line l, cirles a) //直线到圆心的距离\n{\n    return fabs(chaji(a.o - l.a, l.b - l.a)) / changdu(l.b - l.a);\n}\npair<vec, vec> zhixian_yuan_jiaodian(Line l, cirles a)\n{\n    if (dayu_dengyu(a.r, zhixian_yuanxin_juli(l, a))) {\n        vec a_i = touying(l, a.o);\n        double L = changdu(l.b - l.a);\n        double lt = changdu(a.o - a_i);\n        double lr = sqrt(a.r * a.r - lt * lt);\n        vec p = (l.b - l.a) / L * lr + a_i;\n        return make_pair(a_i - (l.b - l.a) / L * lr, a_i + (l.b - l.a) / L * lr);\n    } else\n        return make_pair(0, 0);\n}\n/*\n2 1 1\n1\n0 1 4 1\n*/\nint main()\n{\n  //  freopen(\"txt.txt\", \"w\", stdout);\n    cirles a;\n    cin >> a;\n    int q;\n    cin >> q;\n    while (q--) {\n        Line l;\n        cin >> l;\n\n        pair<vec, vec> q = zhixian_yuan_jiaodian(l, a);\n        if (fabs(q.first.x - q.second.x) < eps) {\n            if (dayu_dengyu(q.first.y, q.second.y))\n                cout << q.second << ' ' << q.first << endl;\n            else\n                cout << q.first << ' ' << q.second << endl;\n        } else if (dayu_dengyu(q.first.x, q.second.x))\n            cout << q.second << ' ' << q.first << endl;\n        else\n            cout << q.first << ' ' << q.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < (EPS))\n#define SQR(n) ((n) * (n))\n\n#define COUNTER_CLOCKWISE (1)\n#define CLOCKWISE (-1)\n#define ONLINE_BACK (2)\n#define ONLINE_FRONT (-2)\n#define ON_SEGMENT (0)\n\nstruct Point \n{\n  double x, y;\n  \n  Point() {}\n  \n  Point(double x, double y) : x(x), y(y) {}\n  \n  void input() { scanf(\"%lf %lf\", &x, &y); }\n  void output() { printf(\"%.10f %.10f\", x, y); }\n  void outputspace() { output(); putchar(' '); }\n  void outputln() { output(); putchar('\\n'); }\n  \n  double abs() { return (sqrt(norm())); }\n  double norm() { return (x * x + y * y); }\n  \n  Point operator + (Point d) { return (Point(x + d.x, y + d.y)); }\n  Point operator - (Point d) { return (Point(x - d.x, y - d.y)); }\n  Point operator - () { return (Point(-x, -y)); }\n  Point operator * (double a) { return (Point(x * a, y * a)); }\n  Point operator / (double a) { return (Point(x / a, y / a)); }\n  \n  bool operator < (Point d) {\n    if(x < d.x) return (true);\n    if(x > d.x) return (false);\n    return (y < d.y);\n  }\n\n};\n\nstruct Segment\n{\n  Point p1, p2;\n  \n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\n  void input() { p1.input(); p2.input(); }\n  \n};\n\nstruct Circle\n{\n  Point c;\n  double r;\n  Circle() {}\n  Circle(Point c, double r) : c(c), r(r) {}\n  \n  void inputcr() { c.input(); scanf(\"%lf\", &r); }\n  \n};\n\ntypedef pair < Point, Point > TwoPoint;\ntypedef Point Vector;\ntypedef vector < Point > Polygon;\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b)\n{\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n  return (a.x * b.y - a.y * b.x);\n}\n\nPoint project(Line l, Point p)\n{\n  Vector base = l.p2 - l.p1;\n  return (l.p1 + base * (dot(p - l.p1, base) / base.norm()));\n}\n\nPoint reflect(Line l, Point p)\n{\n  return (-p + project(l, p) * 2.0);\n}\n\n\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0, b = p2 - p0;\n  \n  if(cross(a, b) > EPS) return (COUNTER_CLOCKWISE);\n  if(cross(a, b) < -EPS) return (CLOCKWISE);\n  if(dot(a, b) < -EPS) return (ONLINE_BACK);\n  if(a.norm() < b.norm()) return (ONLINE_FRONT);\n  \n  return (ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n  return (intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\n\ndouble getDistanceLP(Line l, Point p)\n{\n  return (abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return ((p - s.p1).abs());\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return ((p - s.p2).abs());\n  return (getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n  double ans;\n\n  if(intersect(s1, s2)) {\n    ans = 0.0;\n  } else {\n    ans = min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n    ans = min(ans, min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)));\n  }\n\n  return (ans);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  double d1 = getDistanceLP(s2, s1.p1);\n  double d2 = getDistanceLP(s2, s1.p2);\n  \n  return (s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2)));\n}\n\nbool intersect(Circle c, Line l)\n{\n  return (getDistanceLP(l, c.c) - c.r > EPS);\n}\n\nTwoPoint getCrossPoints(Circle c, Line l)\n{\n  Vector pr, e;\n  double base;\n  if(intersect(c, l)) abort();\n  \n  pr = project(l, c.c);\n  base = sqrt(SQR(c.r) - (pr - c.c).norm());\n  e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  \n  return (make_pair(pr + (e * base), pr - (e * base)));\n}\n\nmain()\n{\n  int n;\n  Circle c;\n  \n  c.inputcr(); cin >> n;\n  for(int i = 0; i < n; i++) {\n    Line l;\n    TwoPoint tp;\n    \n    l.input();\n    tp = getCrossPoints(c, l);\n\n    if(tp.second < tp.first) swap(tp.first, tp.second);\n    tp.first.outputspace(); tp.second.outputln();\n  }\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\n\nstruct Circle {\n    double x, y, r;\n};\nstruct Line {\n    double a, b, c;\n};\nvector<pair<double, double>> CrossPoints_of_Circles(Circle c1, Circle c2) {\n    double x1, y1, r1, x2, y2, r2;\n    x1 = c1.x, y1 = c1.y, r1 = c1.r;\n    x2 = c2.x, y2 = c2.y, r2 = c2.r;\n    vector<pair<double, double>> ret;\n    if ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) > (r1 + r2) * (r1 + r2))\n        return ret;\n    if ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) < (r1 - r2) * (r1 - r2))\n        return ret;\n    double a = 2 * (x1 - x2), b = 2 * (y1 - y2),\n           c = -x1 * x1 - y1 * y1 + x2 * x2 + y2 * y2 + r1 * r1 - r2 * r2;\n\n    double d = a * x1 + b * y1 + c;\n    double X, Y;\n    X = (-a * d + b * sqrt((a * a + b * b) * r1 * r1 - d * d)) /\n            (a * a + b * b) +\n        x1;\n    Y = (-b * d - a * sqrt((a * a + b * b) * r1 * r1 - d * d)) /\n            (a * a + b * b) +\n        y1;\n    ret.emplace_back(X, Y);\n    X = (-a * d - b * sqrt((a * a + b * b) * r1 * r1 - d * d)) /\n            (a * a + b * b) +\n        x1;\n    Y = (-b * d + a * sqrt((a * a + b * b) * r1 * r1 - d * d)) /\n            (a * a + b * b) +\n        y1;\n    ret.emplace_back(X, Y);\n    sort(all(ret));\n    return ret;\n}\n\nvector<pair<double, double>> CrossPoints_of_a_Circle_and_a_Line(Circle c1,\n                                                                Line l1) {\n    double x, y, r, a, b, c;\n    x = c1.x, y = c1.y, r = c1.r;\n    a = l1.a, b = l1.b, c = l1.c;\n    vector<pair<double, double>> ret;\n\n    if (abs(a * x + b * y + c) / sqrt(a * a + b * b) > r) return ret;\n\n    double d = a * x + b * y + c;\n    double X, Y;\n    X = (-a * d + b * sqrt((a * a + b * b) * r * r - d * d)) / (a * a + b * b) +\n        x;\n    Y = (-b * d - a * sqrt((a * a + b * b) * r * r - d * d)) / (a * a + b * b) +\n        y;\n    ret.emplace_back(X, Y);\n    X = (-a * d - b * sqrt((a * a + b * b) * r * r - d * d)) / (a * a + b * b) +\n        x;\n    Y = (-b * d + a * sqrt((a * a + b * b) * r * r - d * d)) / (a * a + b * b) +\n        y;\n    ret.emplace_back(X, Y);\n    sort(all(ret));\n    return ret;\n}\n\nint main() {\n    cout << fixed << setprecision(20);\n    Circle c;\n    cin >> c.x >> c.y >> c.r;\n    int q;\n    cin >> q;\n    while (q--) {\n        double x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line l = {y2 - y1, x1 - x2, -x1 * (y2 - y1) + y1 * (x2 - x1)};\n        auto ans = CrossPoints_of_a_Circle_and_a_Line(c, l);\n        for (auto p : ans) cout << p.first << \" \" << p.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point\n{\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) {return Point(x - p.x, y - p.y); }\n    Point operator * (double a) {return Point(x * a, y * a);}\n    Point operator / (double a) {return Point(x / a, y / a);}\n\n    double abs() {return sqrt(norm());}\n    double norm() {return x * x + y * y;}\n    \n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};typedef Point Vector;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c,double r):c(c), r(r){}\n};\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2):p1(p1), p2(p2){}\n};typedef Segment Line;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\nPoint projection(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p-s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS) return 1;\n    if (cross(a, b) < -EPS) return -1;\n    if (dot(a, b) < -EPS) return 2;\n    if (a.norm() < b.norm()) return -2;\n    return 0;\n}\nbool intersection(Point p0, Point p1, Point p2, Point p3){\n    if (ccw(p0, p1, p2) == 0 || ccw(p0, p1, p3) == 0 || \n        ccw(p2, p3, p0) == 0 || ccw(p2, p3, p1) == 0)\n        return true;\n    if (ccw(p0, p1, p2) * ccw(p0, p1, p3) == -1 && ccw(p2, p3, p0) * ccw(p2, p3, p1) == -1)\n        return true;\n    return false;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = projection(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt(c.r * c.r - (pr - c.c).norm());\n    return make_pair(pr + e * base, pr - e * base);\n}\nint main(){\n    int cx, cy, r, q; cin >> cx >> cy >> r >> q;\n    Circle c = Circle(Point(cx, cy), r);\n    int x1, y1, x2, y2;\n    for (int i = 0; i < q; i++)\n    {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Line l = Line(Point(x1, y1), Point(x2, y2));\n        pair<Point, Point> p = getCrossPoints(c, l);\n        if (p.first.x < p.second.x)\n            cout << fixed << setprecision(10) \n            << p.first.x << \" \" << p.first.y << \" \"\n            << p.second.x << \" \" << p.second.y << endl;\n        else if(p.first.x > p.second.x)\n            cout << fixed << setprecision(10) \n            << p.second.x << \" \" << p.second.y << \" \"\n            << p.first.x << \" \" << p.first.y << endl;\n        else if (equals(p.first.x, p.second.x))\n            if (equals(p.first.y, p.second.y))\n            cout << fixed << setprecision(10) \n            << p.first.x << \" \" << p.first.y << \" \"\n            << p.second.x << \" \" << p.second.y << endl;\n            else if (p.first.y < p.second.y)\n            cout << fixed << setprecision(10) \n            << p.first.x << \" \" << p.first.y << \" \"\n            << p.second.x << \" \" << p.second.y << endl;\n            else if(p.first.y > p.second.y)\n            cout << fixed << setprecision(10) \n            << p.second.x << \" \" << p.second.y << \" \"\n            << p.first.x << \" \" << p.first.y << endl;\n    }\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\n#define EPS 1e-12\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nVP crosspointLC(Point a1, Point a2, Point c, double r) {\n  VP ps;\n  Point ft = proj(a1, a2, c);\n  //if (!GE(r*r, norm(ft-c))) return ps;\n\n  Point dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  ps.push_back(ft - dir);\n  return ps;\n}\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nint main(void){\n    double cx,cy,r;\n    int q;\n    cin>>cx>>cy>>r>>q;\n    rep(i,q){\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        VP ps = crosspointLC(Point(x1,y1),Point(x2,y2),Point(cx,cy),r);\n        sort(all(ps));\n        printf(\"%.9f %.9f \" ,ps[0].X,ps[0].Y);\n        printf(\"%.9f %.9f\\n\",ps[1].X,ps[1].Y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAX = 1e2 + 5;\nconst int L = 2;\nconst LL MOD = 10000;\nconst int dir[MAX][MAX] = {{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,1},{1,-1}};\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tif(dcmp(t1 - 1) <= 0 && dcmp(t1) >= 0)\n\t\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tif(dcmp(t2 - 1) <= 0 && dcmp(t2) >= 0)\n\t\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tPoint o;\n\tdouble r;\n\tscanf(\"%lf%lf%lf\", &o.x, &o.y, &r);\n\tint T;\n\tsfi(T);\n\twhile(T--)\n\t{\n\t\tLine l;\n\t\tscanf(\"%lf%lf%lf%lf\", &l.a.x, &l.a.y, &l.b.x, &l.b.y);\n\t\tPoint ret[3];\n\t\tint num;\n\t\tcircle_cross_line(l.a, l.b, o, r, ret, num);\n\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", ret[0].x, ret[0].y, ret[1].x, ret[1].y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (Point p) { return Point(x * p.x, y * p.y); }\n\tPoint operator * (double p) { return Point(x * p, y * p); }\n\tPoint operator / (Point p) { return Point(x / p.x, y / p.y); }\n\tPoint operator / (double p) { return Point(x / p, y / p); }\n\tvoid insert(double a, double b) { x = a; y = b; }\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\nstruct Segment {\n\tVector p1, p2;\n\tSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0):\n\t\tp1(x1, y1), p2(x2, y2) {}\n\tSegment(Point a1, Point a2) : p1(a1), p2(a2) {}\n\tvoid insert(Vector a1, Vector a2) { p1 = a1; p2 = a2; }\n};\ntypedef Segment Line;\ninline double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ninline double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\ninline bool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\ninline bool isOrthogonal(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\ninline bool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\ninline bool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\ninline bool isParallel(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\ninline bool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point &p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point &p1, Point &p2, Point &p3, Point &p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Point &a, Point &b) { return (a - b).abs(); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn mp(pr + e * base, pr - e * base);\n}\nint main() {\n\tcout << setprecision(10) << fixed;\n\tdouble x, y, r; cin >> x >>  y >> r;\n\tCircle ci(Point(x, y), r);\n\tint q; cin >> q;\n\tdouble x1, y1, x2, y2;\n\tpair<Point, Point> ppp;\n\trep(i, 0, q) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tppp = getCrossPoints(ci, Line(x1, y1, x2, y2));\n\t\tcout << ppp.se.x << \" \" << ppp.se.y << \" \" << ppp.fi.x << \" \" << ppp.fi.y << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <math.h>\n#include <algorithm>\nconst double EPS = 1e-9;\nusing namespace std;\nclass vector {\npublic:\n\tdouble x, y;\n\tvector(double a, double  b) {\n\t\tx = a;\n\t\ty = b;\n\t};\n\tvector operator * (const vector &v)const {\n\t\treturn vector(x*v.x, y* v.y);\n\t}\n\tvector operator * (double a) {\n\t\treturn vector(x * a, y * a);\n\t}\n\tvector operator - (vector v) {\n\t\treturn vector(x - v.x, y - v.y);\n\t}\n\tvector operator + (vector v) {\n\t\treturn vector(x + v.x, y + v.y);\n\t}\n};\ninline double dot(vector v1, vector v2) {\n\treturn v1.x*v2.x + v1.y*v2.y;\n}\ninline double squ(vector v) {\n\treturn v.x*v.x + v.y*v.y;\n}\ninline double norm(vector v) {\n\treturn sqrt(squ(v));\n}\ninline void print(vector v) {\n\tprintf(\"%.10f %.10f\\n\", v.x, v.y);\n}\ninline void printc(vector v1, vector v2) {\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", v1.x, v1.y, v2.x, v2.y);\n}\ninline vector pro(vector base, vector v, vector be) {\n\tdouble a = dot(base, v) / squ(base);\n\tvector v1 = base * a;\n\treturn v1 + be;\n}\ninline vector ref(vector v, vector be) {\n\treturn (v - be)*2 + be;\n}\ninline double cross(vector v1, vector v2) {\n\treturn v1.x*v2.y - v1.y*v2.x;\n}\ninline int ccw(vector v1, vector v2, vector v3) {\n\tvector a = v2 - v1;\n\tvector b = v3 - v1;\n\tif (cross(a, b) < 0.0) return -1;\n\telse if (cross(a, b) > 0.0) return 1;\n\telse if (dot(a, b) < 0.0) return -2;\n\telse if (dot(a, b) > squ(a)) return 2;\n\telse return 0;\n}\ninline int inter(vector v1, vector v2, vector v3, vector v4) {\n\treturn (ccw(v1, v2, v3) * ccw(v1, v2, v4) <= 0) && (ccw(v3, v4, v1) * ccw(v3, v4, v2) <= 0);\n}\ninline double disPP(vector v1, vector v2) {\n\treturn norm(v2 - v1);\n}\ninline double disLP(vector v1, vector v2, vector v3) {\n\tvector a = v2 - v1;\n\tvector b = v3 - v1;\n\treturn fabs(cross(a, b) / norm(a));\n}\ninline double disSP(vector v1, vector v2, vector v3) {\n\tvector a = v2 - v1;\n\tvector b = v3 - v1;\n\tvector c = v1 - v2;\n\tvector d = v3 - v2;\n\tif (dot(a, b) < 0.0) return disPP(v1, v3);\n\telse if (dot(c, d) < 0.0) return disPP(v2, v3);\n\telse return disLP(v1, v2, v3);\n}\ninline double disSS(vector v1, vector v2, vector v3, vector v4) {\n\tif (inter(v1, v2, v3, v4)) return 0;\n\tdouble a = disSP(v1, v2, v3);\n\tdouble b = disSP(v1, v2, v4);\n\tdouble c = disSP(v3, v4, v1);\n\tdouble d = disSP(v3, v4, v2);\n\treturn min(min(a, b), min(c, d));\n}\ninline vector getcross(vector v1, vector v2, vector v3, vector v4) {\n\tvector v5 = pro(v2 - v1, v3 - v1, v1);\n\tvector v6 = pro(v2 - v1, v4 - v1, v1);\n\tdouble a = disPP(v3, v5);\n\tdouble b = disPP(v4, v6);\n\tvector vans = (v6 - v5)*a*(1 / (a + b)) + v5;\n\treturn vans;\n\n}\nint main() {\n\tint n, cx, cy, r,  x1, x2,y1, y2;\n\tcin >>cx >> cy >> r >>  n;\n\tvector o(cx, cy);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tvector v1(x1, y1);\n\t\tvector v2(x2, y2);\n\t\tvector ev = (v2 - v1)*(1 / norm(v2 - v1));\n\t\tvector pr = pro(v2 - v1, o - v1, v1);\n\t\tdouble l = sqrt(r *r - squ(o - pr));\n\t\tvector ans1 = ev * l + pr;\n\t\tvector ans2 = pr - ev * l;\n\t\tif (ans1.x > ans2.x) swap(ans1, ans2);\n\t\telse if (ans1.x == ans2.x)\n\t\t\tif (ans1.y > ans2.y) swap(ans1, ans2); \n\t\tprintc(ans1, ans2);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef Line Segment;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Line a, Point p){\n    Point a1 = a.first, a2 = a.second;\n    return abs(CCW(a1, a2, p)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Line a, Line b) {\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    return !IsecLP(Line(a2-a1, b2-b1), 0) || IsecLP(Line(a1, b1), b2);\n}\n\n// 直線と線分\nbool IsecLS(Line a, Segment b) {\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Segment a, Segment b) {\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Segment a, Point p) {\n    Point a1 = a.first, a2 = a.second;\n    return !CCW(a1, a2, p);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Line a, Point p){\n    Point a1 = a.first, a2 = a.second;\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Line a, Point p){\n    return 2.0L*Proj(a, p) - p;\n}\n\n// 点と点\nLD DistPP(Point p1, Point p2){\n    return abs(p1-p2);\n}\n\n// 直線と点\nLD DistLP(Line a, Point p){\n    return abs(Proj(a, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Line a, Line b) {\n    Point b1 = b.first;\n    return IsecLL(a, b) ? 0 : DistLP(a, b1);\n}\n\n// 直線と線分\nLD DistLS(Line a, Segment b) {\n    Point b1 = b.first, b2 = b.second;\n    return IsecLS(a, b) ? 0 : min(DistLP(a, b1), DistLP(a, b2));\n}\n\n// 線分と点\nLD DistSP(Segment a, Point p) {\n    Point a1 = a.first, a2 = a.second;\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Segment a, Segment b) {\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    if(IsecSS(a, b)) return 0;\n    return min(min(DistSP(a, b1), DistSP(a, b2)), min(DistSP(b, a1), DistSP(b, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Line a, Line b){\n    Point a1 = a.first, a2 = a.second, b1 = b.first, b2 = b.second;\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(cpol[i]) > imag(cpol[is])) is = i;\n        if (imag(cpol[i]) < imag(cpol[js])) js = i;\n    }\n    LD maxd = norm(cpol[is]-cpol[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if(norm(cpol[i]-cpol[j]) > maxd) {\n            maxd = norm(cpol[i]-cpol[j]);\n            maxi = i; maxj = j;\n        }\n    } while(i != is || j != js);\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n\n// 凸多角形の切断 (ConvexPolygonCut) **********\nPolygon ConvexPolygonCut(Polygon cpol, Line l){\n    int n = cpol.size();\n    Point l1 = l.first, l2 = l.second;\n    Polygon q;\n    for(int i = 0; i < n; i++){\n        Point a = cpol[i], b = cpol[(i+1)%n];\n        if(CCW(l1, l2, a) != -1) q.push_back(a);\n        if(CCW(l1, l2, a) * CCW(l1, l2, b) < 0) q.push_back(CrossPointLL(Line(a, b), l));\n    }\n    return q;\n}\n// ********************************************\n\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n// 最近点対 (ClosestPair) *********************\npair<Point, Point> ClosestPair(Polygon p){\n    int n = p.size();\n    sort(p.begin(), p.end(), [](Point p, Point q) { return p.Y < q.Y; });\n    \n    auto u = p[0], v = p[1];\n    auto best = Dot(u-v, u-v);\n    auto update = [&](Point p, Point q) {\n        auto dist = Dot(p-q, p-q);\n        if (best > dist) { best = dist; u = p; v = q; }\n    };\n    set<Point> S; S.insert(u); S.insert(v);\n    for (int l = 0, r = 2; r < n; ++r) {\n        if (S.count(p[r])) return {p[r], p[r]};\n        if ((p[l].Y-p[r].Y)*(p[l].Y-p[r].Y) > best) S.erase(p[l++]);\n        auto i = S.insert(p[r]).first;\n        for (auto j = i; ; ++j) {\n            if (j == S.end() || (i->X-j->X)*(i->X-j->X) > best) break;\n            if (i != j) update(*i, *j);\n        }\n        for (auto j = i; ; --j) {\n            if (i != j) update(*i, *j);\n            if (j == S.begin() || (i->X-j->X)*(i->X-j->X) > best) break;\n        }\n    }\n    return make_pair(u, v);\n}\n// ********************************************\n\n\n//*********************************************\n//                円(Circle)                  *\n//*********************************************\ntypedef pair<Point, LD> Circle;\n\n// 円と円の交差判定 ***************************\nint IsecCC(Circle c1, Circle c2){\n    // 0: 包含, 1: 内接, 2: 2点で交わる, 3: 外接, 4: 離れている\n    enum{INCLUSION, INSCRIBED, INTERSECT, CIRCUMSCRIBED, LEAVE};\n    LD d = DistPP(c1.first, c2.first);\n    if(d > c1.second + c2.second) return LEAVE;\n    else if(EQ(d, c1.second + c2.second)) return CIRCUMSCRIBED;\n    else if(abs(c1.second - c2.second) < d && d < c1.second + c2.second) return INTERSECT;\n    else if(EQ(d, abs(c1.second - c2.second))) return INSCRIBED;\n    else return INCLUSION;\n}\n// ********************************************\n\n// 円と直線の交点 *****************************\npair<Point, Point> CrossPointCL(Circle c, Line l){\n    Point l1 = l.first, l2 = l.second, cp = c.first;\n    LD r = c.second;\n    Point ft = Proj(l, cp);\n    if(!GE(r * r, norm(ft-cp))) throw \"not exist crosspoint\";\n\n    Point dir = sqrt(max(r*r - norm(ft-cp), 0.0L)) / abs(l2-l1) * (l2-l1);\n    \n    if(!EQ(r*r, norm(ft-cp))) return make_pair(ft - dir, ft + dir);\n    else return make_pair(ft + dir, ft + dir);\n}\n\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nCircle c;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    LD xp, yp, r;\n    cin >> xp >> yp >> r;\n    c = Circle(Point(xp, yp), r);\n    cin >> q;\n    REP(i, q){\n        LD x1p, y1p, x2p, y2p;\n        cin >> x1p >> y1p >> x2p >> y2p;\n        pair<Point, Point> ans = CrossPointCL(c, Line(Point(x1p, y1p), Point(x2p, y2p)));\n        //if(ans.first.X > ans.second.X) swap(ans.first, ans.second);\n        //else if(ans.first.X == ans.second.X && ans.first.Y > ans.second.Y) swap(ans.first, ans.second);\n        printf(\"%.9Lf %.9Lf %.9Lf %.9Lf\\n\", ans.first.X, ans.first.Y, ans.second.X, ans.second.Y);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nusing vec = complex<double>;\nusing line = pair<vec,vec>;\nusing polygon = vector<vec>;\nconst double eps = 0.0000001;\n\ndouble inner_product(vec u,vec v){\n    return real(u*conj(v));\n}\ndouble cross_product(vec u,vec v){\n    return imag(conj(u)*v);\n}\n\nvec projection(line l,vec p){//p???l???????°???±\n    vec s=l.first, t=l.second;\n    double k = inner_product(t-s,p-s)/inner_product(t-s,t-s);\n    return (1.0-k)*s+k*t;\n}\n\nvec reflection(line l,vec p){\n    return 2.0*projection(l,p)-p;\n}\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = cross_product(ab,ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(inner_product(ab,ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(inner_product(ab,ab)<inner_product(ac,ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nbool isIntersect(line l0, line l1){\n    int s = ccw(l0.first,l0.second,l1.first)*ccw(l0.first,l0.second,l1.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    s=ccw(l1.first,l1.second,l0.first)*ccw(l1.first,l1.second,l0.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    else return true;\n}\n\nvec interSection(line l0, line l1){\n    vec s0, t0, s1, t1;\n    tie(s0,t0)=l0; tie(s1,t1)=l1;\n    double k = cross_product(t1-s1,s1-s0)/cross_product(t1-s1,t0-s0);\n    return s0+(t0-s0)*k;\n}\n\ndouble segLength(line l){\n    return abs(l.first-l.second);\n}\n\ndouble distLine2point(line l, vec p){\n    return abs(cross_product(l.second-l.first,p-l.first))/abs(l.second-l.first);\n}\n\ndouble distSeg2Point(line l, vec p){\n    vec x = projection(l,p);\n    double L = segLength(l);\n    if(abs(x-l.first)<L&&abs(x-l.second)<L){\n        return abs(x-p);\n    }else{\n        return min(abs(l.first-p),abs(l.second-p));\n    }\n}\n\ndouble distSeg2Seg(line l1, line l2){\n    if(isIntersect(l1,l2)) return 0;\n    double ret = 1e20;\n    ret = min(ret,distSeg2Point(l1,l2.first));\n    ret = min(ret,distSeg2Point(l1,l2.second));\n    swap(l1,l2);\n    ret = min(ret,distSeg2Point(l1,l2.first));\n    ret = min(ret,distSeg2Point(l1,l2.second));\n    return ret;\n}\n\ndouble area(polygon& g){\n    double S=0;\n    int n=g.size();\n    for(int i=0;i<n;i++){\n        S+=cross_product(g[i],g[(i+1)%n]);\n    }\n    S/=2;\n    return S;\n}\n\n//???????????§???????????????\n\npair<vec,vec> cross_point(vec& C, double r, line l){\n    vec P1,P2,P,s,t; tie(s,t)=l;\n    P=(t-s)*(inner_product(t-s,C-s)/norm(t-s))+s;\n    P1=P+(t-s)*(sqrt(r*r-norm(P-C))/abs(t-s));\n    P2=P-(t-s)*(sqrt(r*r-norm(P-C))/abs(t-s));\n    if(P1.real()==P2.real()){\n        if(P1.imag()<P2.imag()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }else{\n        if(P1.real()<P2.real()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }\n}\n\nint main(){\n    double r;\n    int x,y,q;\n    cin >> x >> y >> r >> q;\n    vec C(x,y);\n    cout.precision(8);\n    cout << fixed;\n    while(q--){\n        int x,y;\n        cin>>x>>y; vec s(x,y);\n        cin>>x>>y; vec t(x,y);\n        pair<vec,vec> P = cross_point(C,r,line(s,t));\n        cout << P.first.real() << \" \" << P.first.imag() << \" \" << P.second.real() << \" \" << P.second.imag() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Cross Point of a Circle and a Line\n#include <iostream>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\n\nstatic const double ESP = 1e-10;\n\nbool equals(double a, double b) { return fabs(a - b) < ESP; }\n\nclass Point {\npublic:\n    double x, y;\n\n    explicit Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(a / x, a / y); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < ESP && fabs(y - p.y) < ESP;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    explicit Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector v1, Vector v2) {\n    return equals(cross(v1, v2), 0.0);\n}\n\nbool isOrthogonal(Vector v1, Vector v2) {\n    return equals(dot(v1, v2), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    return s.p1 + (base * (dot(base, p - s.p1) / base.norm()));\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2;\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > ESP) return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -ESP) return CLOCKWISE;\n    else if (dot(a, b) < -ESP) return ONLINE_BACK;\n    else if (a.norm() < b.norm()) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) {\n        return getDistancePP(s.p1, p);\n    } else if(dot(s.p1 - s.p2, p - s.p2) < 0) {\n        return getDistancePP(s.p2, p);\n    } else {\n        return getDistanceLP(s, p);\n    }\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if(intersect(s1, s2)) return 0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s1.p2 - s1.p1;\n    double d1 = fabs(cross(base, s2.p1 - s1.p1));\n    double d2 = fabs(cross(base, s2.p2 - s1.p1));\n    return s2.p1 + (s2.p2 - s2.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l) {\n    Vector base = l.p2 - l.p1;\n    double d = getDistanceLP(l, c.c);\n    Point m = project(l, c.c);\n    double t = sqrt(pow(c.r, 2.0) - pow(d, 2.0)) / base.abs();\n    return make_pair(m - base * t, m + base * t);\n}\n\nint main() {\n    int q;\n    double cx, cy, r, x0, y0, x1, y1;\n    cin >> cx >> cy >> r >> q;\n    Circle c = Circle(Point(cx, cy), r);\n    for(int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1;\n        Line l = Line(Point(x0, y0), Point(x1, y1));\n        pair<Point, Point> p = getCrossPoint(c, l);\n        if(p.first.x < p.second.x) {\n            cout << setprecision(15) << p.first.x << \" \" << p.first.y << \" \" << p.second.x << \" \" << p.second.y << endl;\n        } else {\n            cout << setprecision(15) << p.second.x << \" \" << p.second.y << \" \" << p.first.x << \" \" << p.first.y << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#pragma warning(disable: 4996)\n#define EPS (1e-10)\n#define equals(a,b) (fabs(a)-fabs(b)<EPS)\n\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n///Program 16.3 表示线段的结构体\nstruct Segment {\n\tPoint p1, p2;\n};\n\n///Program 16.4 表示直线的结构体\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\n\n///内积\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n///外积\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) {//printf(\"COUNTER_CLOCKWISE\\n\");\n\t\treturn 1;\n\t}///p2位于p0-->p1的逆时针方向\n\tif (cross(a, b) < -EPS) {//printf(\"CLOCKWISE\\n\");\n\t\treturn -1;\n\t}///p2位于p0-->p1的顺时针方向\n\tif (dot(a, b) < -EPS) {//printf(\"ONLINE_BACK\\n\");\n\t\treturn 2;\n\t}///p2位于线段p0p1后方\n\tif (a.norm() < b.norm()) { //printf(\"ONLINE_FRONT\\n\");\n\t\treturn -2;\n\t}///p2位于线段p0p1前方\n\n//  printf(\"ON_SEGMENT\\n\");///p2位于线段p0p1的中间\n\treturn 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\t//   return s.p1 + (base*r);\n\tPoint ans;\n\tans.x = s.p1.x + (base * r).x;\n\tans.y = s.p1.y + (base * r).y;\n\treturn ans;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\t// assert(intersect(c.c,l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr - e * base, pr + e * base);\n}\n\nint main()\n{\n\tCircle c;\n\tscanf(\"%lf%lf%lf\", &c.c.x, &c.c.y, &c.r);\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tLine l;\n\t\tscanf(\"%lf%lf%lf%lf\", &l.p1.x, &l.p1.y, &l.p2.x, &l.p2.y);\n\t\tpair<Point, Point> p = getCrossPoints(c, l);\n\t\tif((p.first.x<p.second.x)||(p.first.x==p.second.x&&p.first.y<p.second.y))\n\t\t\tprintf(\"%.8f %.8f %.8f %.8f\\n\", p.first.x, p.first.y, p.second.x, p.second.y);\n\t\telse \n\t\t\tprintf(\"%.8f %.8f %.8f %.8f\\n\", p.second.x, p.second.y, p.first.x, p.first.y);\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\nconst double INFD = numeric_limits<double>::infinity();\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool fge(double x, double y) { return x >= y - eps; }\ndouble fsqrt(double x) { return feq(x, 0) ? 0 : sqrt(x); }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\n// Ongoing\n\n\nstruct pt_t {\n\tdouble x, y;\n\tpt_t operator+(const pt_t &p) { return { x + p.x, y + p.y }; }\n\tpt_t operator-(const pt_t &p) { return { x - p.x, y - p.y }; }\n\tpt_t operator*(const double &c) { return { x * c, y * c }; }\n\tbool operator<(const pt_t &another) const {\n\t\treturn (x != another.x ? x < another.x : y < another.y);\n\t}\n};\n\n// aX + bY + c = 0\nstruct line_t {\n\tdouble a, b, c;\n};\n\n// (X - x)^2 + (Y - y)^2 = r^2\nstruct circle_t {\n\tdouble x, y, r;\n};\n\n// normal vector = (a, b), passing p\nline_t solve_line(double a, double b, pt_t p) {\n\treturn { a, b, -a * p.x - b * p.y };\n}\n\n// passing p, q\nline_t solve_line(pt_t p, pt_t q) {\n\treturn solve_line(q.y - p.y, -q.x + p.x, p);\n}\n\n// t should be radius\npt_t rot(pt_t p, double r) {\n\treturn {\n\t\tcos(r) * p.x - sin(r) * p.y,\n\t\tsin(r) * p.x + cos(r) * p.y\n\t};\n}\n\ndouble norm2(pt_t p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble norm(pt_t p) {\n\treturn sqrt(norm2(p));\n}\n\n// angle [0, 2PI) of vector p to vector q\ndouble angle(pt_t p, pt_t q) {\n\tp = p * (1.0 / norm(p));\n\tq = q * (1.0 / norm(q));\n\tdouble r0 = acos(max(min(p.x * q.x + p.y * q.y, 1.0), -1.0));\n\tdouble r1 = asin(max(min(p.x * q.y - p.y * q.x, 1.0), -1.0));\n\tif (r1 >= 0) return r0;\n\telse return 2 * M_PI - r0;\n}\n\ndouble dist(line_t l, pt_t p) {\n\treturn abs(l.a * p.x + l.b * p.y + l.c)\n\t\t/ sqrt(l.a * l.a + l.b * l.b);\n}\n\nbool on_same_line(pt_t t, pt_t p) {\n\tline_t l = solve_line({ 0, 0 }, t);\n\tif (feq(dist(l, p), 0)) return true;\n\telse return false;\n}\n\nbool on_same_halfline(pt_t t, pt_t p) {\n\tline_t l = solve_line({ 0, 0 }, t);\n\tif (feq(dist(l, p), 0) && feq(angle(t, p), 0)) return true;\n\telse return false;\n}\n\ndouble in_segment(pt_t s, pt_t t, pt_t p) {\n\tif (on_same_halfline(t - s, p - s) && on_same_halfline(s - t, p - t)) {\n\t\treturn true;\n\t}\n\telse return false;\n}\n\n// (NAN, NAN) if lines coincide with each other\n// (INF, INF) if lines are parallel but not coincide\npt_t cross_point(line_t l, line_t m) {\n\tdouble d = l.a * m.b - l.b * m.a;\n\tif (feq(d, 0)) {\n\t\tif (feq(l.a * m.c - l.c * m.a, 0)) return { INF, INF };\n\t\telse return { NAN, NAN };\n\t}\n\telse {\n\t\tdouble x = l.b * m.c - m.b * l.c;\n\t\tdouble y = l.a * m.c - m.a * l.c;\n\t\treturn { x / d, y / -d };\n\t}\n}\n\n// if size is 0, then not crossed\nvector<pt_t> cross_point(circle_t f, line_t l) {\n\tdouble d = dist(l, { f.x, f.y });\n\tif (!fge(f.r, d)) return {};\n\tline_t m = solve_line(l.b, -l.a, { f.x, f.y });\n\tpt_t p = cross_point(l, m);\n\tif (feq(d, f.r)) return { p };\n\telse {\n\t\tpt_t u = { l.b, -l.a };\n\t\tpt_t v = u * (sqrt(pow(f.r, 2) - pow(d, 2)) / norm(u));\n\t\treturn { p + v, p - v };\n\t}\n}\n\n// if size is 0, then not crossed\nvector<pt_t> cross_point(circle_t f, circle_t g) {\n\tline_t l = {\n\t\t-2 * f.x + 2 * g.x,\n\t\t-2 * f.y + 2 * g.y,\n\t\t(f.x * f.x + f.y * f.y - f.r * f.r) - (g.x * g.x + g.y * g.y - g.r * g.r)\n\t};\n\treturn cross_point(f, l);\n}\n\n// tangent points of f through p\n// if size is 0, then p is strictly contained in f\n// if size is 1, then p is on f\n// otherwise size is 2\nvector<pt_t> tangent_point(circle_t f, pt_t p) {\n\tvector<pt_t> ret;\n\tdouble d2 = norm2(pt_t({ f.x, f.y }) - p);\n\tdouble r2 = d2 - f.r * f.r;\n\tif (fge(r2, 0)) {\n\t\tcircle_t g = { p.x, p.y, fsqrt(r2) };\n\t\tret = cross_point(f, g);\n\t}\n\treturn ret;\n}\n\n// tangent lines of f through p\n// if size is 0, then p is strictly contained in f\n// if size is 1, then p is on f\n// otherwise size is 2\nvector<line_t> tangent_line(circle_t f, pt_t p) {\n\tvector<pt_t> qs = tangent_point(f, p);\n\tvector<line_t> ret(qs.size());\n\tLoop(i, ret.size()) {\n\t\tret[i] = solve_line(p, qs[i]);\n\t}\n\treturn ret;\n}\n\n// tangent points on f through which there is a line tangent to g\n// if size is 0, then one is strictly contained in the other\n// if size is 1, then they are touched inside\n// if size is 2, then they are crossed\n// if size is 3, then they are touched outside\n// otherwise size is 4\nvector<pt_t> tangent_point(circle_t f, circle_t g) {\n\tvector<pt_t> ret;\n\tdouble d2 = norm2({ g.x - f.x, g.y - f.y });\n\tvector<double> r2(2);\n\tr2[0] = d2 - f.r * f.r + 2 * f.r * g.r;\n\tr2[1] = d2 - f.r * f.r - 2 * f.r * g.r;\n\tLoop(k, 2) {\n\t\tif (fge(r2[k], 0)) {\n\t\t\tcircle_t g2 = { g.x, g.y, fsqrt(r2[k]) };\n\t\t\tvector<pt_t> buf = cross_point(f, g2);\n\t\t\tLoop(i, buf.size()) ret.push_back(buf[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n// common tangent lines between two circles\n// if size is 0, then one is strictly contained in the other\n// if size is 2, then they are crossed\n// if size is 3, then they are touched\n// otherwise size is 4\nvector<line_t> tangent_line(circle_t f, circle_t g) {\n\tvector<pt_t> qs = tangent_point(f, g);\n\tvector<line_t> ret(qs.size());\n\tLoop(i, ret.size()) {\n\t\tret[i] = tangent_line(f, qs[i]).front();\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcout << fixed << setprecision(12);\n\tcircle_t f;\n\tcin >> f.x >> f.y >> f.r;\n\tint q; cin >> q;\n\tLoop(_, q) {\n\t\tvector<pt_t> p(2);\n\t\tLoop(i, 2) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tvector<pt_t> ans = cross_point(f, solve_line(p[0], p[1]));\n\t\tif (ans.size() == 1) ans.push_back(ans.back());\n\t\tsort(ans.begin(), ans.end());\n\t\tcout << ans[0].x << \" \" << ans[0].y << \" \" << ans[1].x << \" \" << ans[1].y << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <utility>\n#include <cassert>\n#include <algorithm>\n\nconst double EPS=1e-10;\n\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Vector a,Vector b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base) / norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p+(project(s,p)-p)*2.0;\n}\n\nenum CCW {\n    COUNTER_CLOCKWISE=1,\n    CLOCKWISE=-1,\n    ONLINE_BACK=2,\n    ONLINE_FRONT=-2,\n    ON_SEGMENT=0,\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return CCW::COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CCW::CLOCKWISE;\n    if(dot(a,b)<-EPS) return CCW::ONLINE_BACK;\n    if(norm(a)<norm(b)) return CCW::ONLINE_FRONT;\n\n    return CCW::ON_SEGMENT;\n}\n\ndouble getDistance(Point a,Point b) {\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2) {\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\nbool intersect(Circle c,Line l) {\n    double d=getDistanceLP(l,c.c);\n    return !(d>c.r);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2) {\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n\n    return make_pair(pr+e*base,pr-e*base);\n\n}\n\nint main() {\n    double cx,cy,r;\n    cin>>cx>>cy>>r;\n    Circle circle({Point(cx,cy),r});\n    int q; cin>>q;\n    while(q-->0) {\n        double x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        Line l=Line({Point(x1,y1),Point(x2,y2)});\n\n        auto ans=getCrossPoints(circle,l);\n        vector<pair<double,double>> vec;\n        vec.push_back(make_pair(ans.first.X,ans.first.Y));\n        vec.push_back(make_pair(ans.second.X,ans.second.Y));\n        sort(vec.begin(),vec.end());\n        printf(\"%.10f %.10f \",vec[0].first,vec[0].second);\n        printf(\"%.10f %.10f\\n\",vec[1].first,vec[1].second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tld d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nint main()\n{\n\tint q;\n\tld x, y, r, x1, x2, y1, y2;\n\tcout << fixed << setprecision(9);\n\tcin >> x >> y >> r;\n\tCircle c = { (Point) { x, y }, r };\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tLine l = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tauto res = is_lc(c, l);\n\t\tsort(res.begin(), res.end());\n\t\tcout << res[0].real() << ' ' << res[0].imag() << ' ' << res[1].real() << ' ' << res[1].imag() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(ll i=0;i<n;i++)\nusing namespace std;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\ntemplate<class T>\nbool equals(T a,T b){ return fabs((a)-(b)) < eps; }\n\nstruct Point{\n    double x, y;\n    Point(){}\n    Point(double x, double y) : x(x), y(y){}\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(x*a, y*a); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n    double norm() {return x*x+y*y;}\n    double abs() {return sqrt(norm());}\n\n    bool operator < (const Point &p) const {\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    bool operator > (const Point &p) const {\n        return x!=p.x ? x>p.x : y>p.y;\n    }\n    bool operator == (const Point &p) const {\n        return fabs(x-p.x) < eps && fabs(y-p.y) < eps;\n    }\n};\n\nbool sort_x(Point a, Point b){ return !equals(a.x,b.x)?a.x<b.x:a.y<b.y; }\nbool sort_y(Point a, Point b){ return !equals(a.y,b.y)?a.y<b.y:a.x<b.x; }\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm(Vector a) { return a.x*a.x+a.y*a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y-a.y*b.x; }\n\nstruct Segment {\n    Point p1, p2;\n    Segment(){}\n    Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c, double r) : c(c),r(r) {}\n};\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>eps) return COUNTER_CLOCKWISE;\n    if(cross(a,b)< -eps) return CLOCKWISE;\n    if(dot(a,b)< -eps) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point  p3, Point p4){\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a,b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a,b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s, Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a-b);\n}\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2-l.p1, p-l.p1))/abs(l.p2-l.p1);\n}\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1,p-s.p1) < 0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2) < 0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\ndouble getDistanceSS(Segment s1, Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min( min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n                min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base, s1.p1-s2.p1));\n    double d2=abs(cross(base, s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base, pr-e*base);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    double c0,c1,r;\n    cin>>c0>>c1>>r;\n    Circle c(Point(c0,c1),r);\n    ll q;cin>>q;\n    rep(Q,q){\n        double x0,y0,x1,y1;\n        cin>>x0>>y0>>x1>>y1;\n        Point p0(x0,y0),p1(x1,y1);\n        Line l(p0,p1);\n        pair<Point,Point> p=getCrossPoints(c,l);\n        if(p.first>p.second) swap(p.first,p.second);\n        cout<<p.first.x<<\" \"<<p.first.y<<\" \";\n        cout<<p.second.x<<\" \"<<p.second.y<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n#define EPS  (1e-10)\n#define equals(a,b) (fabs(a-b)<EPS>()\nstatic const int COUNTE_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\nclass Point\n{\npublic:\n    double x,y;\n    Point(double x=0,double y=0):x(x),y(y) {}\n    Point operator +(Point c)\n    {\n        return Point(x+c.x,y+c.y);\n    }\n    Point operator -(Point c)\n    {\n        return Point(x-c.x,y-c.y);\n    }\n    Point operator *(double k)\n    {\n        return Point(x*k,y*k);\n    }\n    Point operator /(double a)\n    {\n        return Point(x/a,y/a);\n    }\n   friend  ostream& operator<<(ostream&out,const Point&p);\n};\ntypedef Point Vector;\ndouble norm(Vector c)\n{\n    return c.x*c.x+c.y*c.y;\n}\ndouble abs(Vector c)\n{\n    return sqrt(norm(c));\n}\nstruct Segment{\n  Vector a,b;\n};\ndouble dot(Vector a,Vector b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b)\n{\n    return a.x*b.y-a.y*b.x;\n}\nPoint projection(Segment s,Point p)\n{\n    Vector base=s.a-s.b;\n    double r=dot(p-s.a,base)/norm(base);\n    return s.a+base*r;\n}\nint ccw(Point p0,Point p1,Point p2)\n{\n    Vector a=p1-p2;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTE_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool intersection(Point p1,Point p2,Point p3,Point p4)\n{\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersection(Segment s1,Segment s2)\n{\n    return intersection(s1.a,s1.b,s2.a,s2.b);\n}\nclass Cirlce{\npublic:\n    Point c;\n    double r;\n    Cirlce(Point c=Point(),double r=0.0):c(c),r(r){}\n};\npair<Point,Point>getCrossPoint(Cirlce c,Segment l)\n{\n    //assert(intersection(c,l));\n    Vector pr=projection(l,c.c);\n    Vector e=(l.b-l.a)/abs(l.b-l.a);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\nostream& operator<<(ostream&out,const Point&p)\n{\n    out<<p.x<<\" \"<<p.y;\n    return out;\n}\nint main()\n{\n   Vector v;\n\n   double r;\n   cin>>v.x>>v.y>>r;\n    Cirlce c(v,r);\n   int n;\n   cin>>n;\n   Segment s;\n   pair<Point,Point> p;\n   while(n--){\n    cin>>s.a.x>>s.a.y>>s.b.x>>s.b.y;\n    p=getCrossPoint(c,s);\n    cout<<fixed<<setprecision(10)<<p.first<<\" \"<<p.second<<endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a*x, a*y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\ndouble norm(Vector a) {\n\treturn a.norm();\n}\n\ndouble abs(Vector a) {\n\treturn a.abs();\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(Segment s, Point p) {\n\tdouble alpha = dot(p - s.p2, s.p1 - s.p2) / (s.p1 - s.p2).norm();\n\treturn s.p2 + (s.p1 - s.p2)*alpha;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn project(s, p)*2.0 - p;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\tint p1p2p3, p1p2p4, p3p4p1, p3p4p2;\n\tp1p2p3 = ccw(p1, p2, p3);\n\tp1p2p4 = ccw(p1, p2, p4);\n\tp3p4p1 = ccw(p3, p4, p1);\n\tp3p4p2 = ccw(p3, p4, p2);\n\n\tif (p1p2p3 == ON_SEGMENT) return true;\n\tif (p1p2p4 == ON_SEGMENT) return true;\n\tif (p3p4p1 == ON_SEGMENT) return true;\n\tif (p3p4p2 == ON_SEGMENT) return true;\n\tif (p1p2p3 == ONLINE_FRONT && p1p2p4 == ONLINE_BACK) return true;\n\tif (p1p2p3 == ONLINE_BACK && p1p2p4 == ONLINE_FRONT) return true;\n\tif (p1p2p3 == COUNTER_CLOCKWISE && p1p2p4 == CLOCKWISE && p3p4p1 == CLOCKWISE && p3p4p2 == COUNTER_CLOCKWISE) return true;\n\tif (p1p2p3 == CLOCKWISE && p1p2p4 == COUNTER_CLOCKWISE && p3p4p1 == COUNTER_CLOCKWISE && p3p4p2 == CLOCKWISE) return true;\n\treturn false;\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n\treturn (project(l, c.c) - c.c).norm() <= c.r*c.r;\n}\n\ndouble getDistance(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\nint main() {\n\tdouble cx, cy, r;\n\tcin >> cx >> cy >> r;\n\tint q;\n\tcin >> q;\n\tCircle C;\n\tC.c.x = cx; C.c.y = cy; C.r = r;\n\tLine L;\n\tpair<Point, Point> crossPoints;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> L.p1.x >> L.p1.y >> L.p2.x >> L.p2.y;\n\t\tcout << fixed << setprecision(15);\n\t\tcrossPoints = getCrossPoints(C, L);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// InterestingLSY\n// 2659723130\n// 《幽灵公主》是真的好看！\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1048576\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+\".in\").c_str());\n\t\tFout((pname+\".out\").c_str());\n\t#else\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << (x) << endl;\n#define o(x) cerr << #x << \" \" << (x) << \"  \";\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define MyMax(a,b) (a) = Max((a),(b))\n#define MyMin(a,b) (a) = Min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n\tvc<int> ret{};\n\tForx(i,l,r) ret.Pb(i);\n\treturn ret;\n}\nmt19937 Rand(0xe38195e38293*time(0));\t// さん\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#undef ld\n#define ld long double\nconst ld Eps = 1e-10;\nstruct Point{\n\tld x,y;\n\til ld Len2(){ return x*x+y*y; }\n\til ld Len(){ return sqrt(x*x+y*y); }\n};\nil Point operator+( const Point &a , const Point &b ){ return {a.x+b.x,a.y+b.y}; }\nil Point operator-( const Point &a , const Point &b ){ return {a.x-b.x,a.y-b.y}; }\nil auto operator^( const Point &a , const Point &b ){ return a.x*b.x + a.y*b.y; }\nil auto operator*( const Point &a , const Point &b ){ return a.x*b.y - b.x*a.y; }\nil Point operator*( const Point &a , const ld &b ){ return {a.x*b,a.y*b}; }\nil Point operator/( const Point &a , const ld &b ){ return {a.x/b,a.y/b}; }\nil bool operator==( const Point &a , const Point &b ){ return a.x == b.x and a.y == b.y; }\nil ld Dis( const Point &a , const Point &b ){ return sqrt((ld)Sqr(a.x-b.x)+Sqr(a.y-b.y)); }\nil ld Dis2( const Point &a , const Point &b ){ return Sqr(a.x-b.x)+Sqr(a.y-b.y); }\nostream& operator<<( ostream &out , const Point &p ){\n\tout << p.x << \" \" << p.y << \"  \";\n\treturn out;\n}\nil bool OnSeg( const Point &a , const Point &b , const Point &c ){\n\tPoint ab = b-a, ac = c-a;\n\tif( fabs(ab*ac) > Eps ) return 0;\n\tif( (ab^ac) < -Eps ) return 0;\n\tif( fabs(ab.y*ab.y+ab.x*ab.x) > fabs(ac.y*ac.y+ac.x*ac.x) ) return 0;\n\t// cout << a.x << \" \" << a.y << \"  \" << b.x << \" \" << b.y << \"  \" << c.x << \" \" << c.y << endl;\n\treturn 1;\n}\nbool Ins( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif( p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4 ) return 1;\n\tif( OnSeg(p1,p3,p2) or OnSeg(p1,p4,p2) or OnSeg(p3,p1,p4) or OnSeg(p3,p2,p4) ) return 1;\n\tif( ((p2-p1)*(p3-p1)<-Eps) == ((p2-p1)*(p4-p1)<-Eps) ) return 0;\n\tif( ((p4-p3)*(p1-p3)<-Eps) == ((p4-p3)*(p2-p3)<-Eps) ) return 0;\n\treturn 1;\n}\nPoint InsPoint( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tld d1 = (ld)abs((p2-p3)*(p3-p1)) / Dis(p1,p2);\n\tld d2 = (ld)abs((p2-p4)*(p4-p1)) / Dis(p1,p2);\n\tld ratio = d1 / (d1+d2);\n\treturn (p4-p3)*ratio + p3;\n}\nPoint H( Point a , Point b , Point p ){\n\tPoint ab = b-a;\n\tld dis2 = Dis2(a,b);\n\tPoint ret = a + ab * (((p-a)^ab)/dis2);\n\treturn ret;\n}\nld Distance( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif(Ins(p1,p2,p3,p4)) return 0;\n\tld ans = min({ Dis(p1,p3) , Dis(p1,p4) , Dis(p2,p3) , Dis(p2,p4) });\n\tauto Check = [&]( Point a , Point b , Point p ){\n\t\tPoint h = H(a,b,p);\n\t\tif(!OnSeg(a,h,b)) return;\n\t\tld tans = Dis(h,p);\n\t\tMymin(ans,tans);\n\t};\n\tCheck(p1,p2,p3);\n\tCheck(p1,p2,p4);\n\tCheck(p3,p4,p1);\n\tCheck(p3,p4,p2);\n\treturn ans;\n}\n\nPoint o;\nld r;\n\nint main(){\n\tFILEIO();\n\tcout << setprecision(10) << fixed;\n\n\tcin >> o.x >> o.y >> r;\n\tint q; cin >> q;\n\tFor(qi,q){\n\t\tPoint p1,p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tPoint p1p2 = p2-p1;\n\t\tp1 = p1-p1p2*(1e6);\n\t\tp2 = p2+p1p2*(1e6);\n\t\tPoint h = H(p1,p2,o);\n\t\tPoint oh = h-o;\n\t\tld tlen = sqrt( r*r - oh.Len2() );\n\t\tPoint add = (p1-h) / (p1-h).Len() * tlen;\n\t\tPoint a1 = h+add, a2 = h-add;\n\t\tif( a1.x < a2.x-Eps or ( fabs(a1.x-a2.x)<Eps and a1.y < a2.y ) ){}\n\t\telse swap(a1,a2);\n\t\tcout << a1 << a2 << endl;\n\t}\n\n\tEND();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n#include<array>\n#include<vector>\n#include<iostream>\n#include<cmath>\n*/\n\nusing namespace std;\n\ntypedef double Real;\nconstexpr Real EPS = 1e-8;\n\nenum { CCW=1, CW = -1, BACK= 2, FRONT=-2, ON=0}; //Counter Clock Wise\n\n//???????????£\nint sign(Real d) {\n\tif (d>EPS) { return 1; }\n\tif (d<-EPS) { return -1; }\n\treturn 0;\n}\n\n/*\n * ???????§?????????????\n */\nstruct Point {\n\tReal x,y;\n\n\t//Point p(2,3)????¨±???\n\texplicit Point(Real x_=0, Real y_=0): x(x_), y(y_) {} //explicit?????£??\\Point p = x;????¨±????????????????????????\n\n\tPoint operator+(const Point &p) const {\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\tPoint operator-(const Point &p) const {\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tPoint operator*(Real s) const {\n\t\treturn Point(x*s,y*s);\n\t}\n\tPoint operator/(Real s) const {\n\t\treturn Point(x/s,y/s);\n\t}\n\tbool operator<(const Point &p) const {\n\t\treturn sign(x - p.x) == -1 || (sign(x - p.x)==0 && sign(y - p.y)==-1);\n\t}\n\tbool operator==(const Point &p) const { return sign(x-p.x) == 0 && sign(y - p.y)==0; }\n\n};\n\n//Point??????????????°????????¬??????\nistream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\nostream &operator<<(ostream &os, const Point &p) {\n\t//return os << '(' << p.x << \", \" << p.y << ')';\n\treturn os << p.x << \" \" << p.y;\n}\n\nstruct Line : public array<Point, 2> { //??????\n\tLine(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Segment : public array<Point, 2> { //??´???\n\tSegment(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\n/*\n *???\n */\nstruct Circle {\n\tPoint c;\n\tReal r;\n\tCircle(const Point &c_, Real r_): c(c_), r(r_) {}\n};\n\n/*\n * ????§???¢\n */\ntypedef vector<Point> Polygon;\n\n\n\n/*\n * Calc\n */\n//???????¨??????????90??????\nPoint rotate90(const Point &p) { return Point(-p.y,p.x); }\n\n//???????¨???????????????±???\nPoint rotate(const Point &p, Real theta) {\n\tconst Real s = sin(theta), c = cos(theta);\n\treturn Point(c*p.x - s*p.y, s*p.x + c*p.y);\n}\n\n//[X???]??¨[???????????????P??????]????§????\nReal angle(const Point &p) { return atan2(p.y, p.x); }\n\n//??????0????????????P?????§????????¢?????????\nReal norm(const Point &p) { return p.x * p.x + p.y * p.y; }\n\n//??????0????????????P?????§????????¢\nReal abs(const Point &p) { return sqrt(norm(p)); }\n\n//????????????\nReal dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; } //??????(?????????????????£?????????)\nReal cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; } //??????\n\n //?°???±\nPoint project(const Line &l, const Point &p) {\n\tconst Point a = p - l[0];\n\tconst Point b = l[1] - l[0];\n\treturn l[0] + b * (dot(a,b) / norm(b));\n}\n//???????§°\nPoint reflect(const Line &l, const Point &p) {\n\tconst Point t = project(l, p);\n\treturn t + (t-p);\n}\n\n//Counter Clock Wise\nint ccw(const Point &a, const Point &b, const Point &c) { //????¨????????????¶??????\n\tconst Point p = b - a;\n\tconst Point q = c - a;\n\tconst Real cr = cross(p,q);\n\n\tif (sign(cr) == 1) { return CCW; }\n\tif (sign(cr) == -1) { return CW; }\n\tif (sign(dot(p,q)) == -1) { return BACK; }\n\tif (sign(norm(p) - norm(q)) == -1) { return FRONT; }\n\treturn ON;\n}\n\n//????????????\nbool intersect(const Segment &s, const Point &p) {\n\treturn ccw(s[0], s[1], p) == ON;\n}\n\nbool intersect(const Segment &a, const Segment &b) { //????????£?????????????????????\n\treturn ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0 \n\t\t   && ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <=0;\n}\n\nbool intersect(const Line &l, const Point &p) { //\n\treturn abs(ccw(l[0], l[1], p)) != 1;\n}\n\nbool intersect(const Line &l, const Segment &s) { //\n\treturn sign(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0])) <=0;\n}\n\nbool intersect(const Line &a, const Line &b) { \n\treturn sign(cross(a[1]-a[0], b[1]-b[0])) != 0\n\t\t|| sign(cross(a[1]-a[0], b[1]-a[0])) == 0;\n}\n\n\n//?????¢\nReal dist(const Point &a, const Point &b) {\n\treturn abs(a - b);\n}\nReal dist(const Line &l, const Point &p) {\n\tPoint a = l[1] - l[0];\n\tPoint b = p - l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\nReal dist(const Line &l, const Segment &s) {\n\tif (intersect(l,s)) { return 0; }\n\treturn min(dist(l,s[0]), dist(l,s[1]));\n}\nReal dist(const Line &a, const Line &b) {\n\tif (intersect(a,b)) { return 0; }\n\treturn dist(a,b[0]);\n}\nReal dist(const Segment &s, const Point &p) {\n\tif (sign(dot(s[1] - s[0], p - s[0])) == -1) { return dist(s[0],p); } \n\tif (sign(dot(s[0] - s[1], p - s[1])) == -1) { return dist(s[1],p); } \n\treturn dist(Line(s[0],s[1]), p);\n}\n\nReal dist(const Segment &a, const Segment &b) {\n\tif (intersect(a,b)) { return 0; }\n\treturn min({dist(a,b[0]), dist(a,b[1]), dist(b,a[0]), dist(b,a[1])});\n}\n\n//???????????¨?????´?????¨????????????\nbool intersect(const Circle &a, const Circle &b) {\n\treturn sign(dist(a.c,b.c) - (a.r + b.r)) <= 0\n\t\t&& sign(dist(a.c,b.c) - abs(a.r - b.r)) >= 0;\n}\n\nbool intersect(const Circle &c, Segment &s) {\n\treturn sign(dist(s, c.c) - c.r) <= 0;\n}\n\nbool intersect(const Circle &c, Line &l) {\n\treturn sign(dist(l, c.c) - c.r) <= 0;\n}\n\n\nPoint crosspoint(const Line &a, const Line &b) {\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\n\tif (sign(crs) == 0) { return a[0]; };\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1]-a[0], a[1]-b[0]) / crs);\n}\n\n//??????\nPoint crosspoint(const Segment &a, const Segment &b) {\n\tassert(intersect(a,b));\n\t\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\n\tif (sign(crs) == 0) {\n\t\tif(intersect(a, b[0])) { return b[0]; }\n\t\tif(intersect(a, b[1])) { return b[1]; }\n\t\tif(intersect(b, a[0])) { return a[0]; }\n\t\treturn a[1];\n\t}\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1]-a[0], a[1]-b[0]) / crs);\n}\n\nvector<Point> crosspoint(const Circle &c, const Line &l) {\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h - c.r) == 1) {\n\t\t//nothing\n\t}\n\telse if (sign(h - c.r) == 0) {\n\t\tres.emplace_back(p);\n\t}\n\telse {\n\t\tconst Real b = sqrt(c.r*c.r - h*h);\n\t\tconst Point e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\n\treturn res;\n}\n\n//\nbool contain(const Circle &c, const Point &p) {\n\treturn sign(dist(c.c, p) - c.r) <= 0;\n}\n\n\n/*\n * Test Code\n */\nint main() {\n\t//CCW=1, CW = -1, BACK= 2, FRONT=-2, ON=0\n\tint q;\n\tint cx,cy,r;\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10); //?°???°???10?????¨???\n\n\tcin >> cx >> cy >> r;\n\t\n\tCircle c(Point(cx,cy),r);\n\tcin >> q;\n\tfor(int i=0; i<q; i++) {\n\t\tLine l = Line(Point(),Point());\n\t\tcin >> l[0].x >> l[0].y >> l[1].x >> l[1].y;\n\n\t\tvector<Point> result = crosspoint(c, l);\n\t\tassert(!result.empty());\n\t\tsort(result.begin(), result.end());\n\t\tcout << result.front() << \" \" << result.back() << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAX = 1e2 + 5;\nconst int L = 2;\nconst LL MOD = 10000;\nconst int dir[MAX][MAX] = {{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,1},{1,-1}};\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tif(dcmp(t2 - 1) <= 0 && dcmp(t1) >= 0)\n\t\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tif(dcmp(t1 - 1) <= 0 && dcmp(t2) >= 0)\n\t\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tPoint o;\n\tdouble r;\n\tscanf(\"%lf%lf%lf\", &o.x, &o.y, &r);\n\tint T;\n\tsfi(T);\n\twhile(T--)\n\t{\n\t\tLine l;\n\t\tscanf(\"%lf%lf%lf%lf\", &l.a.x, &l.a.y, &l.b.x, &l.b.y);\n\t\tPoint ret[3];\n\t\tint num;\n\t\tcircle_cross_line(l.a, l.b, o, r, ret, num);\n\t\tprintf(\"%.6lf %.6lf %.6lf %.6lf\\n\", ret[0].x, ret[0].y, ret[1].x, ret[1].y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Float = double;\nusing Point = complex<Float>;\nstruct Line{ Point a,b; };\nstruct Circle{ Point center; Float r; };\n\nconst Float EPS = 1e-8;\n\ninline bool eq(Float a,Float b) { return abs(a - b) < EPS; }\ninline Float dot(const Point &p1,const Point &p2){ return real(conj(p1) * p2); }\ninline Float cross(const Point &p1,const Point &p2){ return imag(conj(p1) * p2); }\n\nnamespace std{\n\tbool operator<(const Point &p1,const Point &p2){\n\t\treturn eq(real(p1),real(p2)) ? imag(p1) < imag(p2) : real(p1) < real(p2);\n\t}\n}\n\nPoint projection(const Line &l,const Point &p){\n\tFloat t = dot(l.b - l.a,p - l.a) / norm(l.b - l.a);\n\treturn l.a + (l.b - l.a) * t;\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tvector<Point> ret;\n\tPoint p = projection(l,c.center),vect = (l.b - l.a) / abs(l.b - l.a);\n\tif(abs(p - c.center) > c.r) return ret;\n\tFloat d = sqrt(c.r * c.r - norm(p - c.center));\n\tret.push_back(p + vect * d);\n\tif(!eq(abs(p - c.center),c.r)) ret.push_back(p - vect * d);\n\treturn ret;\n}\n\nsigned main(){\n\tFloat cx,cy,r;\n\tcin >> cx >> cy >> r;\n\tCircle c = {Point(cx,cy),r};\n\tint q;\n\tcin >> q;\n\tfor(int i = 0;i < q;i++){\n\t\tFloat x1,x2,y1,y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tvector<Point> ps = crosspoint(c,{Point(x1,y1),Point(x2,y2)});\n\t\tif(ps.size() == 1) ps.push_back(ps[0]);\n\t\tif(ps[1] < ps[0]) swap(ps[0],ps[1]);\n\t\tprintf(\"%.15lf %.15lf %.15lf %.15lf\\n\",real(ps[0]),imag(ps[0]),real(ps[1]),imag(ps[1]));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <limits.h>\n#include <map>\n#include <queue>\n#include <set>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-9;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n  double x;\n  double y;\n\n  Point(double x = 0.0, double y = 0.0) {\n    this->x = x;\n    this->y = y;\n  }\n\n  Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n\n  Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n\n  Point operator*(double a) { return Point(a * x, a * y); }\n\n  Point operator/(double a) { return Point(x / a, y / a); }\n\n  double norm() { return x * x + y * y; }\n\n  double abs() { return sqrt(norm()); }\n\n  bool operator<(const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator==(const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\nstruct Segment {\n  Point p1, p2;\n\n  Segment (Point p1 = Point(), Point p2 = Point()) {\n    this->p1 = p1;\n    this->p2 = p2;\n  }\n};\n\ntypedef Segment Line;\n\ndouble dot(const Vector &a, const Vector &b) {\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector &a, const Vector &b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nclass Circle {\npublic:\n  Point c;\n  double r;\n\n  Circle(Point c = Point(), double r = 0.0) {\n    this->c = c;\n    this->r = r;\n  }\n};\n\ntypedef vector <Point> Polygon;\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n  return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return fabs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n  if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\n  return getDistanceLP(s, p);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n  return getDistanceLP(l, c.c) < c.r + EPS;\n}\n\nbool intersect(Circle c1, Circle c2) {\n  return abs(c1.r - c2.r) <= getDistance(c1.c, c2.c) && getDistance(c1.c, c2.c) < c1.r + c2.r + EPS;\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) return 0.0;\n  return min(\n    min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n    min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n  );\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair <Point, Point> getCrossPoints(Circle c, Line l) {\n  assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  double base = sqrt(c.r * c.r - (pr - c.c).norm());\n\n  return make_pair(pr + e * base, pr - e * base);\n}\n\nint main() {\n  int cx, cy, r;\n  cin >> cx >> cy >> r;\n\n  Circle c(Point(cx, cy), r);\n\n  int Q;\n  cin >> Q;\n\n  int x1, y1, x2, y2;\n\n  for (int i = 0; i < Q; ++i) {\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    Point p1(x1, y1);\n    Point p2(x2, y2);\n    Line l(p1, p2);\n\n    pair <Point, Point> res = getCrossPoints(c, l);\n    Point p3 = res.first;\n    Point p4 = res.second;\n\n    if (p3.x < p4.x) {\n      cout << fixed << setprecision(10) << p3.x << \" \" << p3.y << \" \" << p4.x << \" \" << p4.y << endl;\n    } else if (p3.x == p4.x) {\n      if (p3.y < p4.y) {\n        cout << fixed << setprecision(10) << p3.x << \" \" << p3.y << \" \" << p4.x << \" \" << p4.y << endl;\n      } else {\n        cout << fixed << setprecision(10) << p4.x << \" \" << p4.y << \" \" << p3.x << \" \" << p3.y << endl;\n      }\n    } else {\n      cout << fixed << setprecision(10) << p4.x << \" \" << p4.y << \" \" << p3.x << \" \" << p3.y << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n    double x, y;\n\n    Point(double x_ = 0, double y_ = 0){\n        x = x_;\n        y = y_;\n    }\n\n    Point operator+ (Point p){\n        return Point(x + p.x, y + p.y);\n    };\n\n    Point operator- (Point p){\n        return Point(x - p.x, y - p.y);\n    };\n\n    Point operator* (double k){\n        return Point(x * k, y * k);\n    }\n\n    Point operator/ (double k){\n        return Point(x / k, y / k);\n    }\n\n    double norm(){\n        return x * x + y * y;\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Seg{\npublic:\n    Point p1;\n    Point p2;\n    Seg(Point p1_, Point p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n};\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\n;\ndouble getCos(Vector a, Vector b){\n    return dot(a, b) / (a.abs() * b.abs());\n}\n\ndouble dist(Point p1, Point p2){\n    return sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n}\n\nPoint project(Seg s, Point p0){\n    if(s.p1 == p0){\n        return p0;\n    }\n    if(s.p2 == p0){\n        return p0;\n    }\n    return s.p1 + (s.p2 - s.p1) / (s.p2 - s.p1).abs() * (p0 - s.p1).abs() * getCos(s.p2 - s.p1, p0 - s.p1);\n}\n\nPoint reflect(Seg s, Point p0){\n    Point p = project(s, p0);\n    return p0 + (p - p0) * 2;\n}\n\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nint counterClockwise(Point p0, Point p1, Point p2){\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n    if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(v1, v2) < -EPS) return CLOCKWISE;\n    if(dot(v1, v2) < -EPS) return ONLINE_BACK;\n    if(v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Seg s1, Seg s2){\n    int t1 = counterClockwise(s1.p1, s1.p2, s2.p1);\n    int t2 = counterClockwise(s1.p1, s1.p2, s2.p2);\n    int t3 = counterClockwise(s2.p1, s2.p2, s1.p1);\n    int t4 = counterClockwise(s2.p1, s2.p2, s1.p2);\n    if(t1 * t2 <= 0){\n        if(t3 * t4 <= 0){\n            return true;\n        }\n    }\n    return false;\n}\n\ndouble getDistanceLP(Seg s, Point p0){\n    return (project(s, p0) - p0).abs();\n}\n\ndouble getDistanceSP(Seg s, Point p0){\n    if(dot(s.p2 - s.p1, p0 - s.p1) < 0.0) return (p0 - s.p1).abs();\n    if(dot(s.p1 - s.p2, p0 - s.p2) < 0.0) return (p0 - s.p2).abs();\n    return (project(s, p0) -  p0).abs();\n}\n\ndouble getDistance(Seg s1, Seg s2){\n    if(intersect(s1, s2)){\n        return 0.0;\n    }\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n                min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint crossPoint(Seg s1, Seg s2){\n    double d1 = getDistanceLP(s2, s1.p1);\n    double d2 = getDistanceLP(s2, s1.p2);\n\n    return (s1.p2 * d1 + s1.p1 * d2) / (d1 + d2);\n}\n\npair<Point, Point> getCrossPoints(Point x, double r, Seg s){\n    double d1 = getDistanceLP(s, x);\n    double d2 = sqrt(pow(r, 2) - pow(d1, 2));\n\n    Point p1 = project(s, x);\n    Vector v1 = s.p2 - s.p1;\n    return make_pair(p1 + v1 / v1.abs() * d2, p1 - v1 / v1.abs() * d2);\n}\n\nint main(){\n    int cx, cy, r, q;\n    scanf(\"%d\", &cx);\n    scanf(\"%d\", &cy);\n    scanf(\"%d\", &r);\n    scanf(\"%d\", &q);\n\n    Point x = Point(cx, cy);\n\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n\n        pair<Point, Point> ps = getCrossPoints(x, r, Seg(Point(xp0, yp0), Point(xp1, yp1)));\n\n        printf(\"%.10f %.10f %.10f %.10f\\n\", ps.first.x, ps.first.y, ps.second.x, ps.second.y);\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst long double PI = acos(-1.0L);\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nusing CP = complex<long double>;\n\nconst long double EPS = 1e-10;     // 許容する誤差ε\n#define EQ(a, b) (abs((a)-(b)) < EPS)   // 2つのスカラーが等しいかどうか\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))    // 2つのベクトルが等しいかどうか\n\n// double length = abs(a);     // ベクトルaの絶対値\n// double distance = abs(a-b);     // 2点a,b間の距離\n// CP b = a/abs(a);    // ベクトルaの単位ベクトル\n// CP n1 = a*CP(0,+1); CP n2 = a*CP(0,-1);  // ベクトルaの法線ベクトル\n// CP un1 = (a*CP(0,+1)/abs(a)); CP un2 = (a*CP(0,-1)/abs(a));  // ベクトルaの単位法線ベクトル\n\n// 内積(dot product) : a・b = |a||b|cosΘ\nlong double dot(CP a, CP b) {\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\n\n// 外積(cross product) : a×b = |a||b|sinΘ\nlong double cross(CP a, CP b) {\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// 2直線の直交判定 : a⊥b ⇔ dot(a,b) = 0\nint is_orthogonal(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(dot(a1-a2, b1-b2), 0.0);\n}\n\n// 2直線の平行判定 : a//b ⇔ cross(a,b) = 0\nint is_parallel(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(CP a, CP b, CP c) {\n    return EQ(cross(b-a, c-a), 0.0);\n}\n\n// 点cが線分a,b上にあるかないか\nint is_point_on_lines(CP a, CP b, CP c) {\n    // |a-c|+|c-b| <= |a-b|なら線分上\n    return (abs(a-c)+abs(c-b) < abs(a-b)+EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_lines(CP a1, CP a2, CP b1, CP b2) {\n    if(is_parallel(a1, a2, b1, b2)) {\n        // 平行なので線分の重なり判定\n        return is_point_on_lines(a1, a2, b1) || is_point_on_lines(a1, a2, b2) ||\n               is_point_on_lines(b1, b2, a1) || is_point_on_lines(b1, b2, a2);\n    }\n    return (cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < EPS) &&\n           (cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nCP intersection_lines(CP a1, CP a2, CP b1, CP b2) {\n    CP b = b2-b1;\n    long double d1 = abs(cross(b, a1-b1));\n    long double d2 = abs(cross(b, a2-b1));\n    long double t = d1/(d1+d2);\n    return a1+(a2-a1)*t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_line(CP a1, CP a2, CP b1, CP b2) {\n    return !EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算(平行ではない前提)\nCP intersection_line(CP a1, CP a2, CP b1, CP b2) {\n    CP a = a2-a1; CP b = b2-b1;\n    return a1 + a*cross(b, b1-a1)/cross(b, a);\n}\n\n// 点a,bを通る直線と点cとの距離\nlong double distance_line_p(CP a, CP b, CP c) {\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\nlong double distance_lines_p(CP a, CP b, CP c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a1,a2を端点とする線分と点b1,b2を端点とする線分の最短距離\nlong double distance_lines_lines(CP a1, CP a2, CP b1, CP b2) {\n    long double res = 1e18;\n    if(is_intersected_lines(a1, a2, b1, b2)) return 0.0L;\n    res = min(res, distance_lines_p(a1, a2, b1));\n    res = min(res, distance_lines_p(a1, a2, b2));\n    res = min(res, distance_lines_p(b1, b2, a1));\n    res = min(res, distance_lines_p(b1, b2, a2));\n    return res;\n}\n\n// s,tを通る直線に対する点pの射影\nCP projection(CP s, CP t, CP p) {\n    if(EQV(s, t)) return s;\n    CP base = t-s;\n    return s + base*(dot(p-s, base)/norm(base));\n}\n\n// s,tを通る直線に対する点pの反射\nCP reflection(CP s, CP t, CP p) {\n    CP tmp = projection(s, t, p) - p;\n    return p + tmp*2.0L;\n}\n\n// 角度Θ回転\nCP translate(CP v, long double theta) {\n    CP res = v * CP(cosl(theta), sinl(theta));\n    return res;\n}\n\n// n多角形の面積計算\nlong double polygon_area(const vector<CP> &v) {\n    int n = v.size();\n    long double res = 0;\n    for(int i = 0; i < n; ++i) {\n        res += cross(v[(i+n-1)%n], v[(i+n)%n]);\n    }\n    return fabsl(res)/2.0L;\n}\n\n// n多角形の凸性判定\nint is_convex(const vector<CP> &v) {\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        if(cross(v[(i+1)%n]-v[i], v[(i+2)%n]-v[(i+1)%n]) < -EPS) return 0;\n    }\n    return 1;\n}\n\n// 凸包\nvector<CP> convex_hull(vector<CP> &v) {\n    // x座標→y座標で頂点をソート\n    auto lmd = [&](const CP &l, const CP &r) {\n        if(l.imag() != r.imag()) return l.imag() < r.imag();\n        return l.real() < r.real();\n        return l.imag() < r.imag();\n    };\n    vector<CP> res;     // 凸包を構成する頂点\n    int n = v.size();\n    sort(v.begin(), v.end(), lmd);\n    int k = 0;\n    res.resize(n*2);\n    // 下側凸包\n    for(int i = 0; i < n; ++i) {\n        while(k > 1 && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    // 上側凸包\n    for(int i = n-2, t = k; i >= 0; --i) {\n        while(k > t && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    res.resize(k-1);\n    return res;\n}\n\n// 凸多角形の直径\nlong double convex_diameter(vector<CP> &v) {\n    vector<CP> cv = convex_hull(v);\n    int n = cv.size();\n    if(n == 2) return abs(cv[0]-cv[1]);     // 凸包が潰れている例外処理\n    int i = 0, j = 0;   // x軸方向に最も遠い点対\n    for(int k = 0; k < n; ++k) {\n        if(cv[k].real() < cv[i].real()) i = k;\n        if(cv[k].real() > cv[j].real()) j = k;\n    }\n    long double res = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si) {     // 180度回転で終了\n        res = max(res, abs(cv[i]-cv[j]));\n        if(cross(cv[(i+1)%n]-cv[i], cv[(j+1)%n]-cv[j]) < 0) {\n            (++i) %= n;\n        }else {\n            (++j) %= n;\n        }\n    }\n    return res;\n}\n\n// 凸多角形を点s,tを通る直線で切断(左側が取得できる)\nvector<CP> convex_cut(const vector<CP> &v, const CP &s, const CP &t) {\n    vector<CP> res;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        CP nows = v[i], nowt = v[(i+1)%n];\n        if(cross(t-s, nows-s) >= -EPS) res.emplace_back(nows);\n        if(cross(t-s, nows-s)*cross(t-s, nowt-s) < 0) {\n            res.emplace_back(intersection_line(s, t, nows, nowt));\n        }\n    }\n    return res;\n}\n\n// n多角形に対する点pの包含関係(自己交差多角形は例外)\nint contain_polygon_point(const vector<CP> &v, CP p) {\n    int contain = 0, on_segment = 0;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        on_segment |= is_point_on_lines(v[i], v[(i+1)%n], p);   // 辺上判定\n        CP s = v[i]-p, t = v[(i+1)%n]-p;\n        if(s.imag() > t.imag()) swap(s, t);     // 下側を基準にする\n        if(s.imag()*t.imag() <= 0 && t.imag() > 0 && cross(s, t) > 0) {\n            contain = !contain;     // 交差回数が奇数なら内側\n        }\n    }\n    if(on_segment) return 1;    // 辺上\n    if(contain) return 2;       // 内側\n    return 0;       // 外側\n}\n\n// 最近点対距離\nlong double closest_pair(vector<CP> &v, int l = -1, \n                         int r = -1, bool reqsqrt = 0) {\n    if(l == r && l == -1) {\n        l = 0; r = v.size(); reqsqrt = 1;\n        // x座標→y座標で昇順ソート\n        auto lmd = [&](const CP &l, const CP &r) {\n            if(l.real() != r.real()) return l.real() < r.real();\n            return l.imag() < r.imag();\n        };\n        sort(v.begin(), v.end(), lmd);\n    }\n    if(r-l < 2) return 1e18;    // 2点存在しない\n    if(r-l == 2) {      // ちょうど2点の時\n        if(v[l].imag() > v[l+1].imag()) swap(v[l], v[l+1]);\n        if(reqsqrt) return abs(v[l]-v[l+1]);\n        return norm(v[l]-v[l+1]);\n    }\n    // 2点以上に関して分割統治法\n    int mid = (l+r)/2;\n    long double x = v[mid].real();  // 分断する線のx座標\n    // 左半分，右半分について再帰，同一領域内の最小距離resを求める\n    long double res = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    auto f = [](CP pl, CP pr) { return pl.imag() < pr.imag(); };\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, f);\n    vector<CP> tmp;\n    // 異なる領域の2点について最小距離res未満で探索\n    for(int i = l; i < r; ++i) {\n        long double dx = abs(v[i].real()-x);\n        int tsize = tmp.size();\n        if(dx*dx >= res) continue;\n        for(int j = 0; j < tsize; ++j) {\n            CP delta = v[i]-tmp[tsize-1-j];\n            if(delta.imag()*delta.imag() >= res) break;\n            res = min(res, norm(delta));\n        }\n        tmp.emplace_back(v[i]);\n    }\n    if(reqsqrt) res = sqrtl(res);\n    return res;\n}\n\n// 円の表現\nstruct Circle {\n    CP o;\n    long double r;\n    Circle(long double _x = 0.0L, long double _y = 0.0L,\n           long double _r = 0.0L)\n        : o(CP(_x, _y)), r(_r) {}\n    Circle(CP _o, long double _r = 0.0) : o(_o), r(_r) {}\n};\n\n// 2円の位置関係\nint is_cross_circles(Circle l, Circle r) {\n    long double distlr = abs(l.o-r.o);\n    if(l.r+r.r+EPS < distlr) return 4;         // 交点無し外側\n    if(r.r+distlr+EPS < l.r) return -2;          // 交点無し内側(R in L)\n    if(l.r+distlr+EPS < r.r) return 2;          // 交点無し内側(L in R)\n    if(abs(l.r+r.r-distlr) < EPS) return 3;    // 外接\n    if(abs(l.r+distlr-r.r) < EPS) return -1;     // 内接(R in L)\n    if(abs(r.r+distlr-l.r) < EPS) return 1;     // 内接(L in R)\n    return 0;                                   // 2点で交わる\n}\n\n// 円と直線の交点\nvector<CP> intersection_circle_line(Circle ci, CP s, CP t) {\n    vector<CP> res(2);  // 1点の場合同じ座標\n    res[0] = res[1] = projection(s, t, ci.o);\n    long double d = sqrtl(ci.r*ci.r - norm(res[0]-ci.o));\n    CP ust = (t-s)/abs(t-s);\n    res[0] += (ust*d);\n    res[1] -= (ust*d);\n    if(res[0].real() > res[1].real() ||\n       (res[0].real() == res[1].real() && res[0].imag() > res[1].imag())) {\n           swap(res[0], res[1]);\n    }\n    return res;\n}\n\n// 三角形の内接円\nCircle inscribed_circle(CP A, CP B, CP C) {\n    if(cross(B-A, C-A) < 0) swap(B, C);\n    long double a = abs(B-C), b = abs(C-A), c = abs(A-B);\n    long double alpha = acos((b*b+c*c-a*a)/(2.0L*b*c));\n    long double beta = acos((c*c+a*a-b*b)/(2.0L*c*a));\n    // AとxABを通る直線とBとxBCを通る直線の交点が内心\n    CP I = intersection_line(A, A+translate(B-A, alpha/2.0L), B, B+translate(C-B, beta/2.0L));\n    // ABとIの最短距離が内心半径\n    long double Ir = distance_lines_p(A, B, I);\n    return Circle(I, Ir);\n}\n\n// 3点の位置関係を判定\nint calc_clockwise(CP p0, CP p1, CP p2) {\n    CP x = p1-p0, y = p2-p0;\n    if(cross(x, y) > EPS) return 1;     // \"COUNTER_CLOCKWISE\"\n    if(cross(x, y) < -EPS) return -1;   // \"CLOCKWISE\"\n    if(dot(x, y) < 0) return 2;         // \"ONLINE_BACK\"\n    if(norm(x) < norm(y)) return -2;    // \"ONLINE_FRONT\"\n    return 0;                           // \"ON_SEGMENT\" \n}\n\nint main() {\n    long double a, b, c; cin >> a >> b >> c;\n    Circle C(CP(a, b), c);\n    int q; cin >> q;\n    while(q--) {\n        long double d, e; cin >> d >> e;\n        long double f, g; cin >> f >> g;\n        CP x(d, e), y(f, g);\n        cout << fixed << setprecision(10);\n        vector<CP> ans = intersection_circle_line(C, x, y);\n        cout << ans[0].real() << \" \" << ans[0].imag() << \" \" << ans[1].real() << \" \" << ans[1].imag() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << std::endl; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) { std::cerr << std::boolalpha << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); std::cerr << std::noboolalpha; }\n#else\n\t#define debug(...) {}\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\ttemplate<typename T> class dvector : public std::vector<T> {\n\tpublic:\n\t\tdvector() : std::vector<T>() {}\n\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\tT& operator[](size_t n) {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t\tconst T& operator[](size_t n) const {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t};\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool &b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector<T>& v) {\n\t\tfor (int i = 0, len = v.size(); i < len; ++i){ s << v[i]; if (i < len - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector< dvector<T> >& vv) {\n\t\tfor (int i = 0, len = vv.size(); i < len; ++i){ s << vv[i] << std::endl; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\" << std::endl; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << std::endl; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) { \n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(vector<T> &v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T &a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(vector<T> &v) { v.erase(unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\n//doubleにおける == 判定\ninline double equals(double a,double b){ return std::abs(a-b)<EPS; }\n\n//点、ベクトル\nclass Point {\npublic:\n\tdouble x,y;\n\tPoint(double x=0., double y=0.) : x(x), y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x, y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x, y-p.y);}\n\tPoint operator * (Point p) {return Point(x*p.x, y*p.y);}\n\tPoint operator / (Point p) {return Point(x/p.x, y/p.y);}\n\tPoint operator + (double n) {return Point(x+n, y+n);}\n\tPoint operator - (double n) {return Point(x-n, y-n);}\n\tPoint operator * (double n) {return Point(x*n, y*n);}\n\tPoint operator / (double n) {return Point(x/n, y/n);}\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x!=p.x ? x<p.x : y<p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn std::abs(x-p.x)<EPS && std::abs(y-p.y)<EPS;\n\t}\n\t\n};\nusing Vector = Point;\nstd::ostream& operator<<(std::ostream& s, const Point& p) {\n\treturn s << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\n//線分、直線\nclass Segment {\npublic:\n\tPoint p1,p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\t// Ax + By + C = 0 を満たす直線\n\tSegment(double A, double B, double C) {\n\t\tif (std::abs(A) < EPS && std::abs(B) < EPS) {\n\t\t\tabort();\n\t\t} else if (std::abs(A) < EPS) {\n\t\t\t*this = Segment(Point(0, -C / B), Point(1, -C / B));\n\t\t} else if (std::abs(B) < EPS) {\n\t\t\t*this = Segment(Point(-C / A, 0), Point(-C / A, 1));\n\t\t} else {\n\t\t\t*this = Segment(Point(0, -C / B), Point(-C / A, 0));\n\t\t}\n\t}\n\tbool operator == (const Segment &p) const {\n\t\treturn p1==p.p1 && p2==p.p2;\n\t}\n};\nusing Line = Segment;\nstd::ostream& operator<<(std::ostream& s, const Segment& se) {\n\treturn s << \"(\" << se.p1 << \", \" << se.p2 << \")\";\n}\n\n//点を回転させる\n//角度radはラジアンで指定すること\nVector rotate(Vector a, double rad){\n\treturn Vector(a.x*cos(rad)-a.y*sin(rad), a.x*sin(rad)+a.y*cos(rad));\n}\n//90度左回転させたベクトルを返す\nVector rotate90(Vector a){\n\treturn Vector(-a.y, a.x);\n}\n//180度回転させたベクトルを返す\nVector rotate180(Vector a){\n\treturn Vector(-a.x, -a.y);\n}\n//ベクトルの内積\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n//ベクトルの外積\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n//ベクトルa,bの角度を[0, π]の範囲で返す\ndouble angle(Vector a,Vector b){\n\treturn acos(dot(a,b)/a.abs()/b.abs());\n}\n//直交判定\nbool isOrthogonal(Vector a,Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n\treturn isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n\treturn equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//平行判定\nbool isParallel(Vector a,Vector b){\n\treturn equals(cross(a,b), 0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n\treturn isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n\treturn equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//射影\nPoint project(Segment s,Point p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/base.norm();\n\treturn base*r + s.p1;\n}\n//反射\nPoint reflect(Segment s,Point p){\n\treturn p + (project(s,p)-p)*2;\n}\n\n//p0,p1,p2が反時計回りになる\nstatic constexpr int COUNTER_CLOCKWISE = 1;\n//p0,p1,p2が時計回りになる\nstatic constexpr int CLOCKWISE = -1;\n//p2,p0,p1がこの順で同一直線上にある\nstatic constexpr int ONLINE_BACK = 2;\n//p0,p1,p2がこの順で同一直線上にある\nstatic constexpr int ONLINE_FRONT = -2;\n//p2が線分p0p1上にある\nstatic constexpr int ON_SEGMENT = 0;\n/*\n\t\t\t\t\tCOUNTER_CLOCKWISE\n\n ONLINE_BACK -- [p0 -- ON_SEGMENT -- p1] --- ONLINE_FRONT\n\n\t\t\t\t\t\tCLOCKWISE\n*/\nint ccw(Point p0, Point p1, Point p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b)<-EPS)return CLOCKWISE;\n\tif(dot(a,b)<-EPS)return ONLINE_BACK;\n\tif(a.norm()<b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\n//端点が他方の線分上にある場合、線分二つが平行に重なる場合も交差しているとみなす\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//二点間の距離\ndouble getDistance(Point a,Point b){\n\treturn (a-b).abs();\n}\n//点と直線の距離\ndouble getDistanceLP(Line l,Point p){\n\treturn std::abs(cross(l.p2-l.p1, p-l.p1)) / (l.p2-l.p1).abs();\n}\n//点と線分の距離\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(s.p2-s.p1, p-s.p1)<0.)return (p-s.p1).abs();\n\tif(dot(s.p1-s.p2, p-s.p2)<0.)return (p-s.p2).abs();\n\treturn getDistanceLP(s,p);\n}\n//線分と線分の距離\ndouble getDistance(Segment s1,Segment s2){\n\tif(intersect(s1,s2))return 0.;\n\treturn min({getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2), getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)});\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2){\n    double A = cross(s1.p2 - s1.p1, s2.p2 - s2.p1);\n    double B = cross(s1.p2 - s1.p1, s1.p2 - s2.p1);\n    if (std::abs(A) < EPS && std::abs(B) < EPS) return s1.p1;// same line\n    if (std::abs(A) < EPS) assert(false);// !!!PRECONDITION NOT SATISFIED!!!\n    return s2.p1 + (s2.p2 - s2.p1) * B / A;\n}\n\n//円\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\t//c:中心の点、r=半径\n\tCircle(Point c=Point(), double r=0.) : c(c), r(r) {}\n\tbool operator == (const Circle &circle) const {\n\t\treturn c==circle.c && std::abs(r-circle.r)<EPS;\n\t}\n};\nstd::ostream& operator<<(std::ostream& s, const Circle& c) {\n\treturn s << \"(c = \" << c.c << \", r = \" << c.r << \")\";\n}\n\n\n//円cと線分lの交点を返す\nvector<Point> getCrossPointCL(Circle &c, Line &l) {\n\tvector<Point> res;\n\tdouble d = getDistanceLP(l, c.c); // 中心と直線の距離\n\tif (std::abs(d - c.r) < EPS) { // 触れている\n\t\tres.push_back(project(l, c.c));\n\t\treturn res;\n\t}\n\tif (d > c.r) return res; // 離れている\n\tPoint h = project(l, c.c);\n\tPoint u = (l.p2 - l.p1) * sqrt(c.r * c.r - d * d) / (l.p2 - l.p1).abs();\n\tres.push_back(h + u);\n\tres.push_back(h - u);\n\treturn res;\n}\n//円の交差判定\n// 0 : 離れている\n// 1 : c1 が c2 の中で内接\n//-1 : c2 が c1 の中で内接\n// 2 : 2つの交点を持つ\n//-2 : 外接\n// 3 : c1 が c2 の中\n//-3 : c2 が c1 の中\nint intersectCC(Circle &c1, Circle &c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tif (c1.r + c2.r < d) return 0;\t\t\t\t   // 離れている\n\tif (std::abs(c1.r + c2.r - d) < EPS) return -2;  // 外接\n\tif (std::abs(d + c1.r - c2.r) < EPS) return +1;  // c1 が c2 の中で内接\n\tif (std::abs(d + c2.r - c1.r) < EPS) return -1;  // c2 が c1 の中で内接\n\tif (d + c1.r < c2.r) return +3;\t\t\t\t  // c1 が c2 の中\n\tif (d + c2.r < c1.r) return -3;\t\t\t\t  // c2 が c1 の中\n\treturn 2;\t\t\t\t\t\t\t\t\t// 2つの交点を持つ\n}\n//円c1,c2の交点を返す\nvector<Point> getCrossPointCC(Circle &c1, Circle &c2) {\n\tvector<Point> res;\n\tdouble r1 = c1.r, r2 = c2.r, d = (c1.c - c2.c).abs();\n\tif (c1.c == c2.c) return res; // 中心が同じ\n\tint i = intersectCC(c1, c2);\n\tif (i == +1 || i == -1) { // 内接\n\t\tif (r2 < r1)\n\t\t\tres.push_back(c1.c + (c2.c - c1.c) * r1 / d);\n\t\telse\n\t\t\tres.push_back(c2.c + (c1.c - c2.c) * r2 / d);\n\t\treturn res;\n\t}\n\tif (i == -2) { // 外接\n\t\tres.push_back((c1.c * c1.r + c2.c * c2.r) / (c1.r + c2.r));\n\t\treturn res;\n\t}\n\tif (i == 0 || i == +3 || i == -3) { // 共通部分なし || 内部\n\t\treturn res;\n\t}\n\t// 2つの交点を持つ\n\tPoint p = c1.c - c2.c;\n\tdouble A = -2. * p.x, B = 2 * p.y;\n\tdouble C = (c1.c).abs() - (c2.c).abs() - r1 * r1 + r2 * r2;\n\tLine l(A, B, C);\n\treturn getCrossPointCL(c1, l);  // Ax + By + C = 0\n}\n\n\n//ベクトルpとx軸との角度を返す 返却値の範囲[-π, π]\ninline double arg(Vector p){ return atan2(p.y, p.x); }\ninline double arg(Line l){ return arg(Point(l.p1.x-l.p2.x, l.p1.y-l.p2.y)); }\n//大きさa, x軸との角度rのベクトルを返す\ninline Vector polar(double a, double r){ return Point(cos(r)*a, sin(r)*a); }\n//円c1と円c2の交点を返す\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n\tassert(getDistance(c1.c,c2.c) < c1.r+c2.r+EPS);\n\tdouble d = (c1.c-c2.c).abs();\n\tdouble a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(c1.r*d*2.));\n\tdouble t = arg(c2.c-c1.c);\n\treturn {c1.c+polar(c1.r,t+a), c1.c+polar(c1.r,t-a)};\n}\n\nusing Polygon = vector<Point>;\n//多角形gと点pの内包関係を返す\nstatic constexpr int INSIDE = 2;\nstatic constexpr int ONLINE = 1;\nstatic constexpr int OUTSIDE = 0;\nll contains(Polygon &g, Point p){\n\tll n=g.size();\n\tbool x=false;\n\tfor(ll i=0; i<n; i++){\n\t\tPoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(std::abs(cross(a,b)) < EPS && dot(a,b) < EPS) return ONLINE;\n\t\tif(a.y > b.y) swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x=!x;\n\t}\n\treturn (x ? INSIDE : OUTSIDE);\n}\n\n//点の集合sに対する凸包を返す \nPolygon andrewScan(Polygon &s){\n\tPolygon u,l;\n\tif(s.size()<3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(ll i=2; i<(ll)s.size(); i++){\n\t\tfor(ll n=u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor(ll i=s.size()-3; i>=0; i--){\n\t\tfor(ll n=l.size(); n>=2 && ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor(ll i=u.size()-2; i>=1; i--)l.push_back(u[i]);\n\treturn l;\n}\n\n//線分の集合sの交点の数を返す\nclass EndPoint {\npublic:\n\tPoint p;\n\tll seg,st; //入力線分のID, 端点の種類\n\tEndPoint() {}\n\tEndPoint(Point p, ll seg, ll st) : p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\tif(p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\nvector<Point> manhattanIntersection(vector<Segment> &S){\n\tstatic const int BOTTOM = 0;\n\tstatic const int LEFT = 1;\n\tstatic const int RIGHT = 2;\n\tstatic const int TOP = 3;\n\tll n=S.size();\n\tvector<EndPoint> EP(2*n);\n\tfor(ll i=0,k=0; i<n; i++){\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tif(S[i].p1.x>S[i].p2.x) swap(S[i].p1, S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y){\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, RIGHT);\n\t\t}else{\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP.begin(), EP.end());\n\n\tset<ll> BT;\n\tBT.insert(INF);\n\tvector<Point> ans;\n\tfor(ll i=0; i<2*n; i++){\n\t\tif(EP[i].st==TOP){\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}else if(EP[i].st==BOTTOM){\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}else if(EP[i].st==LEFT){\n\t\t\tauto b=BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tauto e=BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tfor(; b!=e; advance(b,1)){\n\t\t\t\tans.push_back(Point(*b,EP[i].p.y));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn ans;\n}\n\n//最小包含円(pointvの点を内部に含む半径最小の円)を返す\n//ハックのあるコンテストではseedに time(0), random_device()() を渡した方がよい\nCircle minimumBoundingCircle(vector<Point> &pointv, ll seed = 2326) {\n\tconst ll n = pointv.size();\n\tassert(n >= 1);\n\tif (n == 1) {\n\t\treturn Circle(pointv[0], 0.);\n\t}\n\n\tstd::mt19937 mt(seed);\n\tstd::shuffle(pointv.begin(), pointv.end(), mt);\n\t// std::random_shuffle(left, right); // simple but deprecated\n\n\tauto make_circle_3 = [](Point &a, Point &b, Point &c) -> Circle {\n\t\tdouble A = (b - c).norm();\n\t\tdouble B = (c - a).norm();\n\t\tdouble C = (a - b).norm();\n\t\tdouble S = cross(b - a, c - a);\n\t\tPoint p = (a * A * (B + C - A) + b * B * (C + A - B)  + c * C * (A + B - C)) / (S * S * 4.);\n\t\tdouble r2 = (p - a).abs();\n\t\treturn Circle(p, r2);\n\t};\n\n\tauto make_circle_2 = [](Point &a, Point &b) -> Circle {\n\t\tPoint c = (a + b) / 2.;\n\t\tdouble r2 = (a - c).abs();\n\t\treturn Circle(c, r2);\n\t};\n\n\tauto in_circle = [](Point &a, Circle &c) -> bool {\n\t\treturn (a - c.c).norm() <= c.r * c.r + EPS;\n\t};\n\n\tCircle c = make_circle_2(pointv[0], pointv[1]);\n\n\t// MiniDisc\n\tfor (ll i = 2; i < n; ++i) {\n\t\tif (!in_circle(pointv[i], c)) {\n\t\t\t// MiniDiscWithPoint\n\t\t\tc = make_circle_2(pointv[0], pointv[i]);\n\t\t\tfor (ll j = 1; j < i; ++j) {\n\t\t\t\tif (!in_circle(pointv[j], c)) {\n\t\t\t\t\t// MiniDiscWith2Points\n\t\t\t\t\tc = make_circle_2(pointv[i], pointv[j]);\n\t\t\t\t\tfor (ll k = 0; k < j; ++k) {\n\t\t\t\t\t\tif (!in_circle(pointv[k], c)) {\n\t\t\t\t\t\t\tc = make_circle_3(pointv[i], pointv[j], pointv[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\n\n//最近点対(距離が最小の2点)を返す\n//関数適用後、pointsには破壊的操作(y座標によるソート)が行われる点に注意\n//使うときは closest_pair(points) を呼んでください\ntemplate<class iter>\npair<double, pair<Point,Point>> closest_pair_core(iter left, iter right) {\n\t\tll n = distance(left, right);\n\t\tif (n == 1) {\n\t\t\treturn {numeric_limits<double>::max(), {*left, *left}};\n\t\t}\n\t\tif (n == 2) {\n\t\t\tif(left[0].y > left[1].y) swap(left[0], left[1]);\n\t\t\treturn {(left[0]-left[1]).abs(), {left[0], left[1]}};\n\t\t}\n        \n\t\titer middle = next(left, n/2);\n        double x = middle->x;\n\t\tpair<double, pair<Point,Point>> d1 = closest_pair_core(left, middle);\n\t\tpair<double, pair<Point,Point>> d2 = closest_pair_core(middle, right);\n\t\tpair<double, pair<Point,Point>> d = (d1.first < d2.first) ? d1 : d2;\n\n\t\tstd::inplace_merge(left, middle, right,\n\t\t\t[](const Point &a, const Point &b) { return a.y < b.y; });\n\n\t\tvector<iter> around;\n\t\tfor(iter i = left; i != right; ++i){\n            if(std::abs(i->x - x) >= d.first) continue;\n            for(auto j = around.rbegin(); j != around.rend(); ++j){\n                double dx = i->x - (*j)->x;\n                double dy = i->y - (*j)->y;\n                if (dy >= d.first) break;\n                double absval = sqrt(dx * dx + dy * dy);\n                if (d.first > absval) {\n                    d = {absval, {*i, **j}};\n                }\n            }\n            around.push_back(i);\n\t\t}\n\t\treturn d;\n}\npair<Point,Point> closest_pair(vector<Point> &points){\n\tsort(points.begin(), points.end());\n\treturn closest_pair_core(points.begin(), points.end()).second;\n}\n\n//pointsで囲まれた領域の面積を返す\ndouble area2(vector<Point>& points) {\n\tdouble s = 0;\n\tll n = points.size();\n\tfor (int i = 0; i < n; ++i) s += cross(points[i], points[(i + 1) % n]);\n\treturn s / 2.;\n}\n\n//キャリパー法により、凸多角形の中から最も遠い2点を返す\npair<Point,Point> convex_diameter(vector<Point> &ps) {\n\tll n = ps.size();\n\tll i = min_element(ps.begin(), ps.end()) - ps.begin();\n\tll j = max_element(ps.begin(), ps.end()) - ps.begin();\n\tll maxI, maxJ;\n\tdouble maxD = 0;\n\tfor(ll k=0; k<2*n; k++) {\n\t\tif(maxD < (ps[i] - ps[j]).norm()) {\n\t\t\tmaxD = (ps[i] - ps[j]).norm();\n\t\t\tmaxI = i;\n\t\t\tmaxJ = j;\n\t\t}\n\t\tif(cross(ps[i] - ps[(i+1) % n], ps[(j+1) % n] - ps[j]) <= 0) j = (j+1) % n;\n\t\telse i = (i+1) % n;\n\t}\n\treturn {ps[maxI], ps[maxJ]};\n}\n\n//多角形pointsを直線lで切り，新しく出来た2つの多角形を求める\n//直線lの進行方向に対して左側の多角形のみ返す\nvector<Point> convex_cut(vector<Point> &points, Line &l) {\n\tvector<Point> res;\n\tll n = points.size();\n\tfor (ll i = 0; i < n; ++i) {\n\t\tPoint A = points[i], B = points[(i + 1) % n];\n\t\tif (ccw(l.p1, l.p2, A) != CLOCKWISE) res.push_back(A);\n\t\tif (ccw(l.p1, l.p2, A) * ccw(l.p1, l.p2, B) < 0) res.push_back(getCrossPoint(Line(A, B), l));\n\t}\n\treturn res;\n}\n\n/*-----8<-----library-----8<-----*/\n\n\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\nvoid CGL_2_A(){\n\tll N;\n\tcin>>N;\n\tvector<ll> ans(N,0);\n\trep(i,N){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tll t=0;\n\t\tif(isOrthogonal(p0,p1,p2,p3)){\n\t\t\tt=1;\n\t\t}else if(isParallel(p0,p1,p2,p3)){\n\t\t\tt=2;\n\t\t}\n\t\tans[i]=t;\n\t}\n\trep(i,N)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\nvoid CGL_1_A(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=project(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\nvoid CGL_1_B(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=reflect(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\nvoid CGL_2_D(){\n\tll Q;\n\tcin>>Q;\n\tvector<double> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tSegment s0(Point(x0,y0),Point(x1,y1)), s1(Point(x2,y2),Point(x3,y3));\n\t\tdouble t=getDistance(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\nvoid CGL_1_C(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tPoint p0(x0,y0),p1(x1,y1);\n\tll Q;\n\tcin>>Q;\n\tvector<string> ans(Q,\"\");\n\tmap<ll,string> m;\n\tm[1]=\"COUNTER_CLOCKWISE\";\n\tm[-1]=\"CLOCKWISE\";\n\tm[2]=\"ONLINE_BACK\";\n\tm[-2]=\"ONLINE_FRONT\";\n\tm[0]=\"ON_SEGMENT\";\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint pq(xq,yq);\n\t\tll t=ccw(p0,p1,pq);\n\t\tans[i]=m[t];\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\nvoid CGL_2_B(){\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tbool t=intersect(p0,p1,p2,p3);\n\t\tans[i]=t ? 1 : 0;\n\t}\n\trep(i,Q)p(ans[i]);\t\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\nvoid CGL_2_C(){\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tSegment s0(p0,p1),s1(p2,p3);\n\t\tPoint t=getCrossPoint(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i].x,ans[i].y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=ja\nvoid CGL_7_D(){\n\tll cx,cy,r,Q;\n\tcin>>cx>>cy>>r>>Q;\n\tCircle c(Point(cx,cy),r);\n\tvector<pair<Point,Point>> ans(Q);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1;\n\t\tcin>>x0>>y0>>x1>>y1;\n\t\tPoint p0(x0,y0),p1(x1,y1);\n\t\tLine l(p0,p1);\n\t\tvector<Point> tv=getCrossPointCL(c,l);\n\t\tpair<Point,Point> t;\n\t\tif(tv.size()==2)t={tv[0],tv[1]};\n\t\telse t={tv[0],tv[0]};\n\t\tif(t.first.x>t.second.x || (equals(t.first.x,t.second.x) && t.first.y>t.second.y))swap(t.first,t.second);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i].first.x, ans[i].first.y, ans[i].second.x, ans[i].second.y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=ja\nvoid CGL_7_E(){\n\tdouble c0x,c0y,r0,c1x,c1y,r1;\n\tcin>>c0x>>c0y>>r0>>c1x>>c1y>>r1;\n\tCircle c0(Point(c0x,c0y), r0), c1(Point(c1x,c1y), r1);\n\tpair<Point,Point> t=getCrossPoints(c0, c1);\n\tif(t.first.x>t.second.x || (equals(t.first.x,t.second.x) && t.first.y>t.second.y))swap(t.first,t.second);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(t.first.x, t.first.y, t.second.x, t.second.y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\nvoid CGL_3_C(){\n\tll N;\n\tcin>>N;\n\tvector<Point> g(N);\n\trep(i,N)cin>>g[i].x>>g[i].y;\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tll t=contains(g,Point(x,y));\n\t\tans[i]=t;\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\nvoid CGL_4_A(){\n\tll N;\n\tcin>>N;\n\tvector<Point> g(N);\n\trep(i,N)cin>>g[i].x>>g[i].y;\n\tvector<Point> ch=andrewScan(g);\n\tprintf(\"%lld\\n\",(ll)ch.size());\n\tll f=0;\n\trepeq(i,ch.size()-1){\n\t\tif(ch[f].y>ch[i].y || (ch[f].y==ch[i].y && ch[f].x>ch[i].x)){\n\t\t\tf=i;\n\t\t}\n\t}\n\trep(i,ch.size()){\n\t\tprintf(\"%lld %lld\\n\",(ll)ch[(i+f)%ch.size()].x, (ll)ch[(i+f)%ch.size()].y);\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_6_A&lang=ja\nvoid CGL_6_A(){\n\tll N;\n\tcin>>N;\n\tvector<Segment> a(N);\n\trep(i,N)cin>>a[i].p1.x>>a[i].p1.y>>a[i].p2.x>>a[i].p2.y;\n\tvector<Point> ans=manhattanIntersection(a);\n\tp(ans.size());\n}\n\n//https://atcoder.jp/contests/abc151/tasks/abc151_f\nvoid ABC151F() {\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tCircle ans=minimumBoundingCircle(v);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(ans.r);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\nvoid CGL_5_A() {\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tpair<Point,Point> anspr=closest_pair(v);\n\tdouble ans=getDistance(anspr.first, anspr.second);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(ans);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=ja\nvoid CGL_3_A(){\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tdouble ans=area2(v);\n\tcout.setf(ios::fixed), cout.precision(1);\n\tp(ans);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=ja\nvoid CGL_3_B(){\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tif(N==3){\n\t\tll cc=ccw(v[0],v[1],v[2]);\n\t\tif(cc!=CLOCKWISE && cc!=COUNTER_CLOCKWISE){\n\t\t\tp(1);return;\n\t\t}\n\t}\n\tvector<Point> convex=andrewScan(v);\n\tif(v.size()==convex.size())p(1);\n\telse p(0);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=ja\nvoid CGL_4_B(){\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tpair<Point,Point> anspr=convex_diameter(v);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(getDistance(anspr.first, anspr.second));\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=ja\nvoid CGL_4_C(){\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tll Q;\n\tcin>>Q;\n\tvector<double> ans(Q,0);\n\trep(i,Q){\n\t\tll s1,s2,t1,t2;\n\t\tcin>>s1>>s2>>t1>>t2;\n\t\tLine l(Point(s1,s2),Point(t1,t2));\n\t\tvector<Point> cutv=convex_cut(v,l);\n\t\tdouble a=area2(cutv);\n\t\tdebug(cutv,a);\n\t\tans[i]=a;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=ja\nvoid CGL_7_A(){\n\tmap<ll,ll> m;\n\tm[0]=4;\n\tm[1]=1;\n\tm[-1]=1;\n\tm[2]=2;\n\tm[-2]=3;\n\tm[3]=0;\n\tm[-3]=0;\n\tll c1x,c1y,c1r,c2x,c2y,c2r;\n\tcin>>c1x>>c1y>>c1r>>c2x>>c2y>>c2r;\n\tCircle c1(Point(c1x,c1y),c1r), c2(Point(c2x,c2y),c2r);\n\tp(m[intersectCC(c1,c2)]);\n}\n\nsigned main() {\n\t//CGL_2_A();\n\t//CGL_1_A();\n\t//CGL_1_B();\n\t//CGL_2_D();\n\t//CGL_1_C();\n\t//CGL_2_B();\n\t//CGL_2_C();\n\tCGL_7_D();\n\t//CGL_7_E();\n\t//CGL_3_C();\n\t//CGL_4_A();\n\t//CGL_6_A();\n\t//ABC151F();\n\t//CGL_5_A();\n\t//CGL_3_A();\n\t//CGL_3_B();\n\t//CGL_4_B();\n\t//CGL_4_C();\n\t//CGL_7_A();\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"GC_template.h\"\nusing namespace std;\n\nnamespace CG{\n    const double eps = 1e-8;\n    int sgn(double x) {\n        if (x < -eps) return -1;\n        if (x > eps) return 1;\n        return 0;\n    }\n\n    struct point {\n        double x, y;\n        point() = default;\n        point(double x, double y) : x(x), y(y) {}\n        point(const point &) = default;\n    };\n\n    typedef point vector;\n\n    bool cmpx(const point &A, const point &B) {return A.x < B.x || (A.x == B.x && A.y < B.y);}\n    point operator + (const point &A, const vector &B) {return point(A.x+B.x,A.y+B.y);}\n    vector operator - (const point &A, const point &B) {return vector(A.x-B.x,A.y-B.y);}\n    double operator * (const vector &A, const vector &B) {return A.x*B.x+A.y*B.y;}\n    vector operator * (const vector &A, double r) {return vector(A.x*r,A.y*r);}\n    vector operator * (double r, const vector &A) {return vector(A.x*r,A.y*r);}\n    vector operator / (const vector &A, double r) {return vector(A.x/r,A.y/r);}\n    double cross (const vector &A, const vector &B) {return A.x*B.y-A.y*B.x;}\n\n    double sqr(double x) {return x*x;}\n    double sqr_length(const vector &A) {return sqr(A.x)+sqr(A.y);}\n    double length(const vector &A) {return sqrt(sqr_length(A));}\n    double sqr_dist(const point &A,const point &B) {return sqr(A.x-B.x)+sqr(A.y-B.y);}\n    double dist(const point &A,const point &B) {return sqrt(sqr_dist(A,B));}\n    vector rot(const vector &A,double theta) {return vector(A.x*cos(theta)-A.y*sin(theta),A.x*sin(theta)+A.y*cos(theta));}\n    vector lerp(const vector &A, const vector &B, double t) {return A*(1-t)+B*t;}\n    int quadartic(double A, double B, double C,std::vector<double> &vec) {\n        double det = sqr(B) - 4*A*C;\n        if(det < 0) return 0;\n        if(sgn(det) == 0) vec.push_back(-B/(2*A));\n        else {\n            vec.push_back((-B-sqrt(det))/(2*A));\n            vec.push_back((-B+sqrt(det))/(2*A));\n            if(A<0) std::swap(vec[0],vec[1]);\n        }\n        return vec.size();\n    }\n\n    struct segment {\n        point a, b;\n        vector v;\n        segment() = default;\n        segment(const point &a, const point &b) : a(a), b(b) { v = b - a; }\n        segment(double x1, double y1, double x2, double y2) : a(x1, y1), b(x2, y2) { v = b - a; }\n        segment(const segment &) = default;\n    };\n\n    typedef segment line;\n\n    bool point_in_segment(const point &p, const segment &s) {\n        return sgn(cross(s.b-s.a,p-s.a)) == 0 && sgn((p-s.a)*(p-s.b)) <= 0;\n    }\n\n    struct circle {\n        point O;\n        double r;\n        circle() = default;\n        circle(const point &O, double r) : O(O), r(r) {};\n        circle(const circle &) = default;\n    };\n    const double pi = acos(-1);\n\n    int get_tangents(const point &p, const circle &cir, std::vector<line> &vec) {\n        vector u = p-cir.O;\n        double l = dist(p,cir.O);\n        if(sgn(l-cir.r) < 0) return 0;\n        if(sgn(l-cir.r) == 0) {\n            vec.emplace_back(p,p+rot(u,pi/2));\n            return 1;\n        }\n        double theta = asin(cir.r/l);\n        vec.emplace_back(p,p+rot(u,theta));\n        vec.emplace_back(p,p+rot(u,-theta));\n        return 2;\n    }\n\n    int get_tangents(circle A, circle B, std::vector<line> &vec) {\n        if (A.r < B.r) std::swap(A, B);\n        double l = dist(A.O, B.O);\n        if (sgn(l) == 0 && sgn(A.r - B.r) == 0) return -1;\n        if (sgn(A.r - B.r - l) > 0) return 0;\n        if (sgn(A.r - B.r - l) == 0) {\n            vec.emplace_back(lerp(A.O, B.O, A.r / l), rot(B.O - A.O, pi / 2));\n            return 1;\n        }\n\n        {\n            double theta = acos((A.r - B.r) / l);\n            vector unit = (A.O - B.O) / l;\n            vec.emplace_back(A.O + (A.r * rot(unit, theta)), B.O + (B.r * rot(unit, theta)));\n            vec.emplace_back(A.O + (A.r * rot(unit, -theta)), B.O + (B.r * rot(unit, -theta)));\n        }\n\n        {\n            if (sgn(A.r + B.r - l) > 0) return 2;\n            if (sgn(A.r + B.r - l) == 0) {\n                vec.emplace_back(lerp(A.O, B.O, A.r / l), rot(A.O - B.O, pi / 2));\n                return 3;\n            }\n            double theta = acos((A.r + B.r) / l);\n            vector unit = (A.O - B.O) / l;\n            vec.emplace_back(A.O + (A.r * rot(unit, theta)), B.O + (B.r * rot(unit, theta)));\n            vec.emplace_back(A.O + (A.r * rot(unit, -theta)), B.O + (B.r * rot(unit, -theta)));\n            return 4;\n        }\n    }\n\n    int circle_line_intersection(const circle &c, const line &l,std::vector<point> &vec) {\n        vector d = l.v;\n        double A = d * d, B = d * (l.a - c.O) * 2, C = sqr_dist(l.a, c.O) - sqr(c.r);\n        std::vector<double> vect;\n        int t = quadartic(A, B, C, vect);\n        if (t == 0) return 0;\n        for (auto v : vect)\n            vec.emplace_back(lerp(l.a, l.b, v));\n        return t;\n    }\n\n    int circle_circle_intersection(circle A, circle B,std::vector<point> &vec) {\n        if (A.r < B.r) std::swap(A, B);\n        double l = dist(A.O, B.O);\n        if (sgn(l) == 0) {\n            if (sgn(A.r - B.r) == 0) return -1;\n            else return 0;\n        }\n        if (sgn(A.r + B.r - l) < 0 || sgn(A.r - B.r - l) > 0) return 0;\n        double theta = acos((sqr(A.r) + sqr(l) - sqr(B.r)) / (2 * A.r * l));\n        if (sgn(A.r + B.r - l) == 0) {\n            vec.emplace_back(lerp(A.O, B.O, A.r / l));\n            return 1;\n        }\n        vector unit = (A.O - B.O) / l;\n        vec.emplace_back(A.r * rot(unit, theta));\n        vec.emplace_back(A.r * rot(unit, -theta));\n    }\n}\nint main() {\n    CG::circle A;\n    cin >> A.O.x >> A.O.y >> A.r;\n    int t;\n    cin >> t;\n    while(t--) {\n        double x1,x2,y1,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        CG::line l(x1,y1,x2,y2);\n        vector<CG::point> vec;\n        int t = CG::circle_line_intersection(A,l,vec);\n        sort(vec.begin(),vec.end(),CG::cmpx);\n        assert(t != 0);\n        if(t == 1) {\n            printf(\"%.12f %.12f \",vec[0].x,vec[0].y);\n            printf(\"%.12f %.12f\\n\",vec[0].x,vec[0].y);\n        }\n        else {\n            printf(\"%.12f %.12f \",vec[0].x,vec[0].y);\n            printf(\"%.12f %.12f\\n\",vec[1].x,vec[1].y);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\ntypedef struct LINE{\n\tPOINT s;//start point\n\tPOINT e;//end point\n}LINE;\ntypedef struct COMPLEX{\n\tdouble r;//?????¢\n\tdouble q;//????§???????theta\n}COMPLEX;\ntypedef struct CIRCLE{\n\tdouble r;//??????\n\tPOINT p;//??????\n}CIRCLE;\n\n//POINT????????????\nvoid print_p(POINT a){\n\tprintf(\"(%lf,%lf)\\n\",a.x,a.y);\n}\n\n//LINE????????????\nvoid print_l(LINE a){\n\tprintf(\"(%lf,%lf) -> (%lf,%lf)\\n\",(a.s).x,(a.s).y,(a.e).x,(a.e).y);\n}\n\n//COMPLEX????????????\nvoid print_c(COMPLEX a){\n\tprintf(\"(%lf,%lf)\\n\",a.r,a.q);\n}\n\n//????????????????????¢?????????\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\n//2???a,b???????????¢\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n//??´??§????????????\nPOINT sum_vec(POINT a,POINT b){\n\ta.x += b.x;\n\ta.y += b.y;\n\treturn a;\n}\n\n//??´??§????????????\n//mkae_vec??¨?????£??????????????¨???????????????\n//??????????????????\nPOINT dif_vec(POINT a,POINT b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\treturn a;\n}\n\n//??´??§????????????????????????\nPOINT scalar_vec(POINT a,double k){\n\ta.x *= k;\n\ta.y *= k;\n\treturn a;\n}\n\n//???????????????\nPOINT minus_vec(POINT a){\n\treturn scalar_vec(a,-1.0);\n}\n\n//??????\ndouble dot(POINT a,POINT b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//??????\ndouble cross(POINT a,POINT b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n//AP:PB=t:s??¨?????????????±???????\n//k, 0:??????, 1:??????\n//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???\nPOINT division(POINT a,POINT b,double t,double s,int k){\n\tdouble tmp = t + s * (1 - k*2);\n\ta.x += (make_vec(a,b)).x / tmp * t;\n\ta.y += (make_vec(a,b)).y / tmp * t;\n\treturn a;\n}\n\n//???p????????´???a?????????????????????????¶??????????\nPOINT perpendicular(LINE a,POINT p){\n\tPOINT ps = make_vec(p,a.s);\n\tPOINT pe = make_vec(p,a.e);\n\tdouble t = norm2(ps) - dot(ps,pe);\n\tdouble s = norm2(pe) - dot(ps,pe);\n\treturn division(a.s,a.e,t,s,0);\n}\n\n//??´???a???????????????p??¨????§°???????????????\nPOINT reflection(LINE a,POINT p){\n\tPOINT h = perpendicular(a,p);\n\treturn sum_vec(h,make_vec(p,h));\n}\n\n//* ????§???¢?????????\nint inclusion(POINT a[],int n,POINT p){\n\tint ans = 0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 0;i < n;i++){\n\t\tif(g[i].x == p.x && g[i].y == p.y){\n\t\t\treturn ans = 1;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tw = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),\n\t\t\t\tdot(make_vec(p,g[i]),make_vec(p,g[i+1])));\n\t\trad += w;\n\t\tif(fabs(w - M_PI) <= 0.000001 ||\n\t\t\t fabs(w + M_PI) <= 0.000001)\n\t\t\treturn ans = 1;\n\t}\n\tif(fabs(rad - M_PI*2)<=0.000001){//2??\n\t\treturn ans = 2;//in!\n\t}\n\treturn ans;\n}\n\n// a.s, a.e, p?????????????????????\n// ???????¨???????????????????????????????  1\n// ????¨?????????????????????????????????? -1\n// p, a.s, a.e????????????????????? 2\n// a.s, a.e, p?????????????????????-2\n// ???p?????´???a???????????????????????? 0\nint ccw(LINE a,POINT p){\n\tint cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));\n\tif(cls > 0){\n\t\treturn  1;\n\t}else if(cls < 0){\n\t\treturn -1;\n\t}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0){\n\t\treturn  2;\n\t}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0){\n\t\treturn -2;\n\t}else{\n\t\treturn  0;\n\t}\n}\n\n// ??????????????????\nint parallel(LINE a,LINE b){\n\tif(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ?????´????????????\nint orthogonal(LINE a,LINE b){\n\tif(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ??????a,b???????????????????????????\nint intersection(LINE a,LINE b){\n\tif(ccw(a,b.s)*ccw(a,b.e) <= 0 &&\n\t   ccw(b,a.s)*ccw(b,a.e) <= 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n//??????a,b?????????\nPOINT cross_point(LINE a,LINE b){\n\tdouble c1 = cross(make_vec(a.s,b.s),make_vec(a.s,b.e));\n\tdouble c2 = cross(make_vec(a.e,b.s),make_vec(a.e,b.e));\n\treturn division(a.s,a.e,fabs(c1),fabs(c2),0);\n}\n\n//??´???a??¨???p????????¢\ndouble distanceLP(LINE a,POINT p){\n\tif(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0)\n\t\treturn norm(make_vec(a.s,p));\n\tif(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0)\n\t\treturn norm(make_vec(a.e,p));\n\treturn norm(make_vec(p,perpendicular(a,p)));\n}\n\n//??´???a??¨??´???b????????¢\ndouble distanceLL(LINE a,LINE b){\n\tdouble a1,a2,a3,a4;\n\tif(intersection(a,b) == 1)\n\t\treturn 0.0000000000;\n\ta1 = distanceLP(a,b.s);\n\ta2 = distanceLP(a,b.e);\n\ta3 = distanceLP(b,a.s);\n\ta4 = distanceLP(b,a.e);\n\t//a1 = min(a1,min(a2,min(a3,a4)));\n\ta1 = min(a1,a2);\n\ta3 = min(a3,a4);\n\ta1 = min(a1,a3);\n\treturn a1;\n}\n\n//????§???¢?????¢???\ndouble area(POINT a[],int n){\n\tdouble ans = 0.0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n-1;i ++){\n\t\tans += cross(make_vec(g[0],g[i]),make_vec(g[0],g[i+1]));\n\t}\n\treturn fabs(ans);\n}\n\n\n//* ?????§??????\nint is_convex(POINT a[],int n){\n\tint ans = 0;\n\tint i,j;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n;i++){\n\t\tw = cross(make_vec(g[i],g[i-1]),make_vec(g[i],g[i+1]))/norm(make_vec(g[i],g[i-1]))/norm(make_vec(g[i],g[i+1]));\n\t\tif(w > 0.00000000){\n\t\t\treturn 0;\n\t\t}\t\t\t\n\t}\n\treturn 1;\n}\n\n//* ??????????????????\n//4\n//3\n//2\n//1\n//0\n//??\\?????°?????????\nint inter_c(CIRCLE a,CIRCLE b){\n\tdouble tmp = distance(a.p,b.p);\n\tif(tmp > a.r+b.r)\n\t\treturn 4;\n\telse if(fabs(tmp-(a.r+b.r)) <= 0.00000001)\n\t\treturn 3;\n\telse if(fabs(tmp-fabs(a.r-b.r)) <= 0.00000001)\n\t\treturn 1;\n\telse if(tmp < fabs(a.r-b.r))\n\t\treturn 0;\n\telse return 2;\n}\n\n//?????¨??´????????????\nPOINT *cross_pointCL(CIRCLE a,LINE b){\n\tdouble k,p = distanceLP(b,a.p);\n\tstatic POINT ans[2];\n\tPOINT q,c= perpendicular(b,a.p);\n\tif(fabs(p-a.r) <= 0.000001){\n\t\tans[0] = c;\n\t\tans[1] = c;\n\t\treturn ans;\n\t}else if(p < a.r){\n\t\tk = a.r*sin(acos(p/a.r));\n\t\tq = scalar_vec(make_vec(b.s,b.e),1/norm(make_vec(b.s,b.e)));\n\t\tq = scalar_vec(q,k);\n\t\tans[0] = sum_vec(c,q);\n\t\tq = scalar_vec(q,-k);\n\t\tans[1] = sum_vec(c,q);\n\t}else{\n\t\treturn -1;//??¨??????\n\t}\n} \n\nint main(){\n\tCIRCLE b;\n\tLINE a;\n\tint k;\n\tPOINT ans[2];\n\tscanf(\"%lf%lf%lf\",&b.p.x,&b.p.y,&b.r);\n\tscanf(\"%d\",&k);\n\twhile(1){\n\t\tscanf(\"%lf%lf%lf%lf\",&a.s.x,&a.s.y,&b.s.x,&b.s.y);\n\t\tans = cross_pointCL(b,a)\n\t\tif(ans[0].y<ans[1].y)\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n\t\telse\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[1].x,ans[1].y,ans[0].x,ans[0].y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(a[0][0]<a[1][0]||fabs(a[0][0]-a[1][0])<0.0000000001&&a[0][1]<a[1][1]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<0.0000000001&&a[0][1]<a[1][1]||a[0][0]<a[1][0]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n/*void cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  s[0]=p0[0]+x1*((b+d)/a);\n  s[1]=p0[1]+y1*((b+d)/a);\n  t[0]=p0[0]+x1*((b-d)/a);\n  t[1]=p0[1]+y1*((b-d)/a);\n  }//*/\nvoid ashi(int p0[2],int p1[2],int p2[2],double p3[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  p3[0]=1.0*(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0];\n  p3[1]=1.0*(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1];\n}\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1];\n  double p3[2],l;\n  ashi(p0,p1,p2,p3);\n  l=sqrt(r*r-(p3[0]-p2[0])*(p3[0]-p2[0])-(p3[1]-p2[1])*(p3[1]-p2[1]));\n  s[0]=p3[0]+x1/hypot(x1,y1)*l;\n  s[1]=p3[1]+y1/hypot(x1,y1)*l;\n  t[0]=p3[0]-x1/hypot(x1,y1)*l;\n  t[1]=p3[1]-y1/hypot(x1,y1)*l;\n}  \nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)j=a[0][1]+e<a[1][1]?0:1;\n    else                       j=a[0][0]+e<a[1][0]?0:1;\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n/*void cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  s[0]=p0[0]+x1*((b+d)/a);\n  s[1]=p0[1]+y1*((b+d)/a);\n  t[0]=p0[0]+x1*((b-d)/a);\n  t[1]=p0[1]+y1*((b-d)/a);\n  }//*/\nvoid ashi(int p0[2],int p1[2],int p2[2],double p3[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  p3[0]=1.0*(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0];\n  p3[1]=1.0*(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1];\n}\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1];\n  double p3[2],l,x3,y3;\n  ashi(p0,p1,p2,p3);\n  x3=p3[0]-p2[0];\n  y3=p3[1]-p2[1];\n  l=sqrt(r*r-x3*x3-y3*y3);\n  s[0]=p3[0]+x1/hypot(x1,y1)*l;\n  s[1]=p3[1]+y1/hypot(x1,y1)*l;\n  t[0]=p3[0]-x1/hypot(x1,y1)*l;\n  t[1]=p3[1]-y1/hypot(x1,y1)*l;\n}  \nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)j=a[0][1]+e<a[1][1]?0:1;\n    else                       j=a[0][0]+e<a[1][0]?0:1;\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\ntypedef struct LINE{\n\tPOINT s;//start point\n\tPOINT e;//end point\n}LINE;\ntypedef struct COMPLEX{\n\tdouble r;//?????¢\n\tdouble q;//????§???????theta\n}COMPLEX;\ntypedef struct CIRCLE{\n\tdouble r;//??????\n\tPOINT p;//??????\n}CIRCLE;\n\n//POINT????????????\nvoid print_p(POINT a){\n\tprintf(\"(%lf,%lf)\\n\",a.x,a.y);\n}\n\n//LINE????????????\nvoid print_l(LINE a){\n\tprintf(\"(%lf,%lf) -> (%lf,%lf)\\n\",(a.s).x,(a.s).y,(a.e).x,(a.e).y);\n}\n\n//COMPLEX????????????\nvoid print_c(COMPLEX a){\n\tprintf(\"(%lf,%lf)\\n\",a.r,a.q);\n}\n\n//????????????????????¢?????????\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\n//2???a,b???????????¢\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n//??´??§????????????\nPOINT sum_vec(POINT a,POINT b){\n\ta.x += b.x;\n\ta.y += b.y;\n\treturn a;\n}\n\n//??´??§????????????\n//mkae_vec??¨?????£??????????????¨???????????????\n//??????????????????\nPOINT dif_vec(POINT a,POINT b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\treturn a;\n}\n\n//??´??§????????????????????????\nPOINT scalar_vec(POINT a,double k){\n\ta.x *= k;\n\ta.y *= k;\n\treturn a;\n}\n\n//???????????????\nPOINT minus_vec(POINT a){\n\treturn scalar_vec(a,-1.0);\n}\n\n//??????\ndouble dot(POINT a,POINT b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//??????\ndouble cross(POINT a,POINT b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n//AP:PB=t:s??¨?????????????±???????\n//k, 0:??????, 1:??????\n//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???\nPOINT division(POINT a,POINT b,double t,double s,int k){\n\tdouble tmp = t + s * (1 - k*2);\n\ta.x += (make_vec(a,b)).x / tmp * t;\n\ta.y += (make_vec(a,b)).y / tmp * t;\n\treturn a;\n}\n\n//???p????????´???a?????????????????????????¶??????????\nPOINT perpendicular(LINE a,POINT p){\n\tPOINT ps = make_vec(p,a.s);\n\tPOINT pe = make_vec(p,a.e);\n\tdouble t = norm2(ps) - dot(ps,pe);\n\tdouble s = norm2(pe) - dot(ps,pe);\n\treturn division(a.s,a.e,t,s,0);\n}\n\n//??´???a???????????????p??¨????§°???????????????\nPOINT reflection(LINE a,POINT p){\n\tPOINT h = perpendicular(a,p);\n\treturn sum_vec(h,make_vec(p,h));\n}\n\n//* ????§???¢?????????\nint inclusion(POINT a[],int n,POINT p){\n\tint ans = 0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 0;i < n;i++){\n\t\tif(g[i].x == p.x && g[i].y == p.y){\n\t\t\treturn ans = 1;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tw = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),\n\t\t\t\tdot(make_vec(p,g[i]),make_vec(p,g[i+1])));\n\t\trad += w;\n\t\tif(fabs(w - M_PI) <= 0.000001 ||\n\t\t\t fabs(w + M_PI) <= 0.000001)\n\t\t\treturn ans = 1;\n\t}\n\tif(fabs(rad - M_PI*2)<=0.000001){//2??\n\t\treturn ans = 2;//in!\n\t}\n\treturn ans;\n}\n\n// a.s, a.e, p?????????????????????\n// ???????¨???????????????????????????????  1\n// ????¨?????????????????????????????????? -1\n// p, a.s, a.e????????????????????? 2\n// a.s, a.e, p?????????????????????-2\n// ???p?????´???a???????????????????????? 0\nint ccw(LINE a,POINT p){\n\tint cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));\n\tif(cls > 0){\n\t\treturn  1;\n\t}else if(cls < 0){\n\t\treturn -1;\n\t}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0){\n\t\treturn  2;\n\t}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0){\n\t\treturn -2;\n\t}else{\n\t\treturn  0;\n\t}\n}\n\n// ??????????????????\nint parallel(LINE a,LINE b){\n\tif(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ?????´????????????\nint orthogonal(LINE a,LINE b){\n\tif(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ??????a,b???????????????????????????\nint intersection(LINE a,LINE b){\n\tif(ccw(a,b.s)*ccw(a,b.e) <= 0 &&\n\t   ccw(b,a.s)*ccw(b,a.e) <= 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n//??????a,b?????????\nPOINT cross_point(LINE a,LINE b){\n\tdouble c1 = cross(make_vec(a.s,b.s),make_vec(a.s,b.e));\n\tdouble c2 = cross(make_vec(a.e,b.s),make_vec(a.e,b.e));\n\treturn division(a.s,a.e,fabs(c1),fabs(c2),0);\n}\n\n//??´???a??¨???p????????¢\ndouble distanceLP(LINE a,POINT p){\n\tif(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0)\n\t\treturn norm(make_vec(a.s,p));\n\tif(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0)\n\t\treturn norm(make_vec(a.e,p));\n\treturn norm(make_vec(p,perpendicular(a,p)));\n}\n\n//??´???a??¨??´???b????????¢\ndouble distanceLL(LINE a,LINE b){\n\tdouble a1,a2,a3,a4;\n\tif(intersection(a,b) == 1)\n\t\treturn 0.0000000000;\n\ta1 = distanceLP(a,b.s);\n\ta2 = distanceLP(a,b.e);\n\ta3 = distanceLP(b,a.s);\n\ta4 = distanceLP(b,a.e);\n\t//a1 = min(a1,min(a2,min(a3,a4)));\n\ta1 = min(a1,a2);\n\ta3 = min(a3,a4);\n\ta1 = min(a1,a3);\n\treturn a1;\n}\n\n//????§???¢?????¢???\ndouble area(POINT a[],int n){\n\tdouble ans = 0.0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n-1;i ++){\n\t\tans += cross(make_vec(g[0],g[i]),make_vec(g[0],g[i+1]));\n\t}\n\treturn fabs(ans);\n}\n\n\n//* ?????§??????\nint is_convex(POINT a[],int n){\n\tint ans = 0;\n\tint i,j;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n;i++){\n\t\tw = cross(make_vec(g[i],g[i-1]),make_vec(g[i],g[i+1]))/norm(make_vec(g[i],g[i-1]))/norm(make_vec(g[i],g[i+1]));\n\t\tif(w > 0.00000000){\n\t\t\treturn 0;\n\t\t}\t\t\t\n\t}\n\treturn 1;\n}\n\n//* ??????????????????\n//4\n//3\n//2\n//1\n//0\n//??\\?????°?????????\nint inter_c(CIRCLE a,CIRCLE b){\n\tdouble tmp = distance(a.p,b.p);\n\tif(tmp > a.r+b.r)\n\t\treturn 4;\n\telse if(fabs(tmp-(a.r+b.r)) <= 0.00000001)\n\t\treturn 3;\n\telse if(fabs(tmp-fabs(a.r-b.r)) <= 0.00000001)\n\t\treturn 1;\n\telse if(tmp < fabs(a.r-b.r))\n\t\treturn 0;\n\telse return 2;\n}\n\n//?????¨??´????????????\nPOINT *cross_pointCL(CIRCLE a,LINE b){\n\tdouble k,p = distanceLP(b,a.p);\n\tstatic POINT ans[2];\n\tPOINT q,c= perpendicular(b,a.p);\n\tif(fabs(p-a.r) <= 0.000001){\n\t\tans[0] = c;\n\t\tans[1] = c;\n\t\treturn ans;\n\t}else if(p < a.r){\n\t\tk = p.r*sin(acos(p/a.r));\n\t\tq = scalar_vec(make_vec(b.s,b.e),1/norm(make_vec(b.s,b.e)));\n\t\tq = scalar_vec(q,k);\n\t\tans[0] = sum_vec(c,q);\n\t\tq = scalar_vec(q,-k);\n\t\tans[1] = sum_vec(c,q);\n\t}else{\n\t\treturn -1;//??¨??????\n\t}\n} \n\nint main(){\n\tCIRCLE b;\n\tLINE a;\n\tint k;\n\tPOINT ans[2];\n\tscanf(\"%lf%lf%lf\",&b.p.x,&b.p.y,&b.r);\n\tscanf(\"%d\",&k);\n\twhile(1){\n\t\tscanf(\"%lf%lf\",&a.x,&a.y);\n\t\tans = cross_pointCL(b,a)\n\t\tif(ans[0].y<ans[1].y)\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n\t\telse\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[1].x,ans[1].y,ans[0].x,ans[0].y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n/*void cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  s[0]=p0[0]+x1*((b+d)/a);\n  s[1]=p0[1]+y1*((b+d)/a);\n  t[0]=p0[0]+x1*((b-d)/a);\n  t[1]=p0[1]+y1*((b-d)/a);\n  }//*/\nvoid ashi(int p0[2],int p1[2],int p2[2],double p3[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  p3[0]=1.0*(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0];\n  p3[1]=1.0*(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1];\n}\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  //int x1=p1[0]-p0[0],y1=p1[1]-p0[1];\n  double p3[2],x1=p1[0]-p0[0],y1=p1[1]-p0[1],l;\n  ashi(p0,p1,p2,p3);\n  l=sqrt(r*r-(p3[0]-p2[0])*(p3[0]-p2[0])-(p3[1]-p2[1])*(p3[1]-p2[1]));\n  s[0]=p3[0]+x1/hypot(x1,y1)*l;\n  s[1]=p3[1]+y1/hypot(x1,y1)*l;\n  t[0]=p3[0]-x1/hypot(x1,y1)*l;\n  t[1]=p3[1]-y1/hypot(x1,y1)*l;\n}  \nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)j=a[0][1]+e<a[1][1]?0:1;\n    else                       j=a[0][0]+e<a[1][0]?0:1;\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_7_D Cross Points of a Circle and a Line\n// 2018.5.3 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\ntypedef struct { double x, y, r; } C;\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define INF 1e8\n#define EPS 1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble dist(PP p1, PP p2) {\treturn vabs(vsub(p1, p2)); }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\ndouble distancePL(PP p, LINE ln)\n{\n\tPP a = vsub(ln.e, ln.s);\n\treturn fabs(cross(vsub(p, ln.s), a)) / vabs(a);\n}\n\nPP projection(PP p1, PP p2, PP p)\n{\n\tPP p2p1 = vsub(p2, p1);\n\tPP pp1 = vsub(p, p1);\n\treturn vadd(p1, vsmul(p2p1, dot(pp1, p2p1)/norm(p2p1)));\n}\n\nint cmp(PP *a, PP *b)\n{\n\tif (EQ(a->x, b->x)) return dcmp(a->y - b->y);\n\treturn dcmp(a->x - b->x);\n}\n\nint main()\n{\n\tint q, i;\n\tC c;\n\tPP p[2], p0, c0;\n\tLINE line;\n\tdouble a, b;\n\n\tc.x = in(), c.y = in(), c.r = in();\n\tq = in();\n\twhile (q--) {\n\t\tline.s.x = in(), line.s.y = in(), line.e.x = in(), line.e.y = in();\n\t\tc0 = vset(c.x, c.y);\n\t\ta = distancePL(c0, line), b = sqrt(c.r*c.r - a*a);\n\t\tp0 = projection(line.s, line.e, c0);\n\t\tp[0] = vadd(p0, vsmul(vsub(line.s, line.e), b/dist(line.s, line.e)));\n\t\tp[1] = vadd(p0, vsmul(vsub(line.e, line.s), b/dist(line.s, line.e)));\n\t\tqsort(p, 2, sizeof(PP), cmp);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tprintf(\"%.10lf %.10lf\", p[i].x, p[i].y);\n\t\t\tputchar(' ');\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid ashi(int p0[2],int p1[2],int p2[2],double p3[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  p3[0]=1.0*(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0];\n  p3[1]=1.0*(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1];\n}\nint cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  double p3[2],x1=p1[0]-p0[0],y1=p1[1]-p0[1],l;\n  ashi(p0,p1,p2,p3);\n  l=r*r-(p3[0]-p2[0])*(p3[0]-p2[0])-(p3[1]-p2[1])*(p3[1]-p2[1]);\n  if(l<0)return 0;\n  s[0]=p3[0]+x1/hypot(x1,y1)*sqrt(l);\n  s[1]=p3[1]+y1/hypot(x1,y1)*sqrt(l);\n  t[0]=p3[0]-x1/hypot(x1,y1)*sqrt(l);\n  t[1]=p3[1]-y1/hypot(x1,y1)*sqrt(l);\n  return 1;\n}\nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)j=a[0][1]+e<a[1][1]?0:1;\n    else                       j=a[0][0]+e<a[1][0]?0:1;\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  s[0]=p0[0]+x1*(b+d)/a;\n  s[1]=p0[1]+y1*(b+d)/a;\n  t[0]=p0[0]+x1*(b-d)/a;\n  t[1]=p0[1]+y1*(b-d)/a;\n}\nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.0000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)a[0][1]+e<a[1][1]?j=0:(j=1);\n    else                       a[0][0]+e<a[1][0]?j=0:(j=1);\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n/*int cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  double d=(y1*p2[0]+x1*p2[1]+p0[1]*p1[0]-p1[1]*p0[0])/hypot(y1,x1),l=r*r-d*d;\n  if(l<0)return 1;\n  s[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]-sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]-sqrt(l/(x1*x1+y1*y1))*p1[1];\n  s[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]+sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]+sqrt(l/(x1*x1+y1*y1))*p1[1];\n  return 0;\n  }//*/\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+1.0*(b-sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  s[1]=p0[1]+1.0*(b-sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n  t[0]=p0[0]+1.0*(b+sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  t[1]=p0[1]+1.0*(b+sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(a[0][0]<a[1][0]||fabs(a[0][0]-a[1][0])<0.000001&&a[0][1]<a[1][1]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\ntypedef struct LINE{\n\tPOINT s;//start point\n\tPOINT e;//end point\n}LINE;\ntypedef struct COMPLEX{\n\tdouble r;//?????¢\n\tdouble q;//????§???????theta\n}COMPLEX;\ntypedef struct CIRCLE{\n\tdouble r;//??????\n\tPOINT p;//??????\n}CIRCLE;\n\n//POINT????????????\nvoid print_p(POINT a){\n\tprintf(\"(%lf,%lf)\\n\",a.x,a.y);\n}\n\n//LINE????????????\nvoid print_l(LINE a){\n\tprintf(\"(%lf,%lf) -> (%lf,%lf)\\n\",(a.s).x,(a.s).y,(a.e).x,(a.e).y);\n}\n\n//COMPLEX????????????\nvoid print_c(COMPLEX a){\n\tprintf(\"(%lf,%lf)\\n\",a.r,a.q);\n}\n\n//????????????????????¢?????????\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\n//2???a,b???????????¢\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n//??´??§????????????\nPOINT sum_vec(POINT a,POINT b){\n\ta.x += b.x;\n\ta.y += b.y;\n\treturn a;\n}\n\n//??´??§????????????\n//mkae_vec??¨?????£??????????????¨???????????????\n//??????????????????\nPOINT dif_vec(POINT a,POINT b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\treturn a;\n}\n\n//??´??§????????????????????????\nPOINT scalar_vec(POINT a,double k){\n\ta.x *= k;\n\ta.y *= k;\n\treturn a;\n}\n\n//???????????????\nPOINT minus_vec(POINT a){\n\treturn scalar_vec(a,-1.0);\n}\n\n//??????\ndouble dot(POINT a,POINT b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//??????\ndouble cross(POINT a,POINT b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n//AP:PB=t:s??¨?????????????±???????\n//k, 0:??????, 1:??????\n//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???\nPOINT division(POINT a,POINT b,double t,double s,int k){\n\tdouble tmp = t + s * (1 - k*2);\n\ta.x += (make_vec(a,b)).x / tmp * t;\n\ta.y += (make_vec(a,b)).y / tmp * t;\n\treturn a;\n}\n\n//???p????????´???a?????????????????????????¶??????????\nPOINT perpendicular(LINE a,POINT p){\n\tPOINT ps = make_vec(p,a.s);\n\tPOINT pe = make_vec(p,a.e);\n\tdouble t = norm2(ps) - dot(ps,pe);\n\tdouble s = norm2(pe) - dot(ps,pe);\n\treturn division(a.s,a.e,t,s,0);\n}\n\n//??´???a???????????????p??¨????§°???????????????\nPOINT reflection(LINE a,POINT p){\n\tPOINT h = perpendicular(a,p);\n\treturn sum_vec(h,make_vec(p,h));\n}\n\n//* ????§???¢?????????\nint inclusion(POINT a[],int n,POINT p){\n\tint ans = 0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 0;i < n;i++){\n\t\tif(g[i].x == p.x && g[i].y == p.y){\n\t\t\treturn ans = 1;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tw = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),\n\t\t\t\tdot(make_vec(p,g[i]),make_vec(p,g[i+1])));\n\t\trad += w;\n\t\tif(fabs(w - M_PI) <= 0.000001 ||\n\t\t\t fabs(w + M_PI) <= 0.000001)\n\t\t\treturn ans = 1;\n\t}\n\tif(fabs(rad - M_PI*2)<=0.000001){//2??\n\t\treturn ans = 2;//in!\n\t}\n\treturn ans;\n}\n\n// a.s, a.e, p?????????????????????\n// ???????¨???????????????????????????????  1\n// ????¨?????????????????????????????????? -1\n// p, a.s, a.e????????????????????? 2\n// a.s, a.e, p?????????????????????-2\n// ???p?????´???a???????????????????????? 0\nint ccw(LINE a,POINT p){\n\tint cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));\n\tif(cls > 0){\n\t\treturn  1;\n\t}else if(cls < 0){\n\t\treturn -1;\n\t}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0){\n\t\treturn  2;\n\t}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0){\n\t\treturn -2;\n\t}else{\n\t\treturn  0;\n\t}\n}\n\n// ??????????????????\nint parallel(LINE a,LINE b){\n\tif(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ?????´????????????\nint orthogonal(LINE a,LINE b){\n\tif(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ??????a,b???????????????????????????\nint intersection(LINE a,LINE b){\n\tif(ccw(a,b.s)*ccw(a,b.e) <= 0 &&\n\t   ccw(b,a.s)*ccw(b,a.e) <= 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n//??????a,b?????????\nPOINT cross_point(LINE a,LINE b){\n\tdouble c1 = cross(make_vec(a.s,b.s),make_vec(a.s,b.e));\n\tdouble c2 = cross(make_vec(a.e,b.s),make_vec(a.e,b.e));\n\treturn division(a.s,a.e,fabs(c1),fabs(c2),0);\n}\n\n//??´???a??¨???p????????¢\ndouble distanceLP(LINE a,POINT p){\n\tif(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0)\n\t\treturn norm(make_vec(a.s,p));\n\tif(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0)\n\t\treturn norm(make_vec(a.e,p));\n\treturn norm(make_vec(p,perpendicular(a,p)));\n}\n\n//??´???a??¨??´???b????????¢\ndouble distanceLL(LINE a,LINE b){\n\tdouble a1,a2,a3,a4;\n\tif(intersection(a,b) == 1)\n\t\treturn 0.0000000000;\n\ta1 = distanceLP(a,b.s);\n\ta2 = distanceLP(a,b.e);\n\ta3 = distanceLP(b,a.s);\n\ta4 = distanceLP(b,a.e);\n\t//a1 = min(a1,min(a2,min(a3,a4)));\n\ta1 = min(a1,a2);\n\ta3 = min(a3,a4);\n\ta1 = min(a1,a3);\n\treturn a1;\n}\n\n//????§???¢?????¢???\ndouble area(POINT a[],int n){\n\tdouble ans = 0.0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n-1;i ++){\n\t\tans += cross(make_vec(g[0],g[i]),make_vec(g[0],g[i+1]));\n\t}\n\treturn fabs(ans);\n}\n\n\n//* ?????§??????\nint is_convex(POINT a[],int n){\n\tint ans = 0;\n\tint i,j;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n;i++){\n\t\tw = cross(make_vec(g[i],g[i-1]),make_vec(g[i],g[i+1]))/norm(make_vec(g[i],g[i-1]))/norm(make_vec(g[i],g[i+1]));\n\t\tif(w > 0.00000000){\n\t\t\treturn 0;\n\t\t}\t\t\t\n\t}\n\treturn 1;\n}\n\n//* ??????????????????\n//4\n//3\n//2\n//1\n//0\n//??\\?????°?????????\nint inter_c(CIRCLE a,CIRCLE b){\n\tdouble tmp = distance(a.p,b.p);\n\tif(tmp > a.r+b.r)\n\t\treturn 4;\n\telse if(fabs(tmp-(a.r+b.r)) <= 0.00000001)\n\t\treturn 3;\n\telse if(fabs(tmp-fabs(a.r-b.r)) <= 0.00000001)\n\t\treturn 1;\n\telse if(tmp < fabs(a.r-b.r))\n\t\treturn 0;\n\telse return 2;\n}\n\n//?????¨??´????????????\nPOINT *cross_pointCL(CIRCLE a,LINE b){\n\tdouble k,p = distanceLP(b,a.p);\n\tstatic POINT ans[2];\n\tPOINT q,c= perpendicular(b,a.p);\n\tif(fabs(p-a.r) <= 0.000001){\n\t\tans[0] = c;\n\t\tans[1] = c;\n\t\treturn ans;\n\t}else if(p < a.r){\n\t\tk = a.r*sin(acos(p/a.r));\n\t\tq = scalar_vec(make_vec(b.s,b.e),1/norm(make_vec(b.s,b.e)));\n\t\tq = scalar_vec(q,k);\n\t\tans[0] = sum_vec(c,q);\n\t\tq = scalar_vec(q,-k);\n\t\tans[1] = sum_vec(c,q);\n\t}else{\n\t\treturn -1;//??¨??????\n\t}\n} \n\nint main(){\n\tCIRCLE b;\n\tLINE a;\n\tint k;\n\tPOINT ans[2];\n\tscanf(\"%lf%lf%lf\",&b.p.x,&b.p.y,&b.r);\n\tscanf(\"%d\",&k);\n\twhile(1){\n\t\tscanf(\"%lf%lf%lf%lf\",&a.s.x,&a.s.y,&a.s.x,&a.s.y);\n\t\tans = cross_pointCL(b,a);\n\t\tif(ans[0].y<ans[1].y)\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n\t\telse\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[1].x,ans[1].y,ans[0].x,ans[0].y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  long long a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  if(d<0)return 0;\n  s[0]=p0[0]+x1*(b+d)/a;\n  s[1]=p0[1]+y1*(b+d)/a;\n  t[0]=p0[0]+x1*(b-d)/a;\n  t[1]=p0[1]+y1*(b-d)/a;\n  return 1;\n}\nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)j=a[0][1]+e<a[1][1]?0:1;\n    else                       j=a[0][0]+e<a[1][0]?0:1;\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  s[0]=p0[0]+x1*((b+d)/a);\n  s[1]=p0[1]+y1*((b+d)/a);\n  t[0]=p0[0]+x1*((b-d)/a);\n  t[1]=p0[1]+y1*((b-d)/a);\n}\nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)a[0][1]+e<a[1][1]?j=0:(j=1);\n    else                       a[0][0]+e<a[1][0]?j=0:(j=1);\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define DOT(v1, v2) (v1.x * v2.x + v1.y * v2.y)\n#define CROSS(v1, v2) (v1.x * v2.y - v1.y * v2.x)\n#define NORM(v) (v.x * v.x + v.y * v.y)\n#define ABS(v) (sqrt(NORM(v)))\n\ntypedef struct { double x, y; } point_t;\ntypedef point_t vector_t;\ntypedef struct { point_t p0, p1; } segment_t;\ntypedef segment_t line_t;\ntypedef struct { point_t p; double r; } circle_t;\n\nstatic vector_t plus(vector_t v1, vector_t v2) {\n  vector_t ret = { v1.x + v2.x, v1.y + v2.y };\n  return ret;\n}\n\nstatic vector_t minus(vector_t v1, vector_t v2) {\n  vector_t ret = { v1.x - v2.x, v1.y - v2.y };\n  return ret;\n}\n\nstatic vector_t multiple(vector_t v, double s) {\n  vector_t ret = { v.x * s, v.y * s };\n  return ret;\n}\n\nstatic vector_t divide(vector_t v, double s) {\n  vector_t ret = { v.x / s, v.y / s };\n  return ret;\n}\n\nstatic point_t projection(line_t l, point_t p) {\n  vector_t base = minus(l.p1, l.p0);\n  double r = DOT(minus(p, l.p0), base) / NORM(base);\n  return plus(l.p0, multiple(base, r));\n}\n\nstatic segment_t cross_points(circle_t c, line_t l) {\n  segment_t s;\n  vector_t e, v, x, tmp;\n  double base;\n\n  x = projection(l, c.p);\n  v = minus(l.p1, l.p0);\n  e = divide(v, ABS(v));\n  base = sqrt(c.r * c.r - NORM(minus(c.p, x)));\n  v = multiple(e, base);\n  s.p0 = plus(x, v);\n  s.p1 = minus(x, v);\n  if (s.p0.x > s.p1.x || (s.p0.x == s.p1.x && s.p0.y > s.p1.y)) {\n    tmp = s.p0;\n    s.p0 = s.p1;\n    s.p1 = tmp;\n  }\n  return s;\n}\n\nint main(int argc, char **argv) {\n  circle_t c;\n  line_t l;\n  segment_t s;\n  int q, i;\n\n  scanf(\"%lf %lf %lf %d\", &c.p.x, &c.p.y, &c.r, &q);\n  for (i = 0; i < q; ++i) {\n    scanf(\"%lf %lf %lf %lf\", &l.p0.x, &l.p0.y, &l.p1.x, &l.p1.y);\n    s = cross_points(c, l);\n    printf(\"%.8lf %.8lf %.8lf %.8lf\\n\", s.p0.x, s.p0.y, s.p1.x, s.p1.y);\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n/*int cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  double d=(y1*p2[0]+x1*p2[1]+p0[1]*p1[0]-p1[1]*p0[0])/hypot(y1,x1),l=r*r-d*d;\n  if(l<0)return 1;\n  s[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]-sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]-sqrt(l/(x1*x1+y1*y1))*p1[1];\n  s[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]+sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]+sqrt(l/(x1*x1+y1*y1))*p1[1];\n  return 0;\n  }//*/\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=p2[0]*x1+p2[1]*y1,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+1.0*(b-sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  s[1]=p0[1]+1.0*(b-sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n  t[0]=p0[0]+1.0*(b+sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  t[1]=p0[1]+1.0*(b+sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(a[0][0]<a[1][0]||fabs(a[0][0]-a[1][0])<0.000001&&a[0][1]<a[1][1]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(a[0][0]<a[1][0]||fabs(a[0][0]-a[1][0])<0.00000001&&a[0][1]<a[1][1]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(a[0][0]<a[1][0]||fabs(a[0][0]-a[1][0])<0.00000001&&a[0][1]<a[1][1]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}\n\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\ntypedef struct LINE{\n\tPOINT s;//start point\n\tPOINT e;//end point\n}LINE;\ntypedef struct COMPLEX{\n\tdouble r;//?????¢\n\tdouble q;//????§???????theta\n}COMPLEX;\ntypedef struct CIRCLE{\n\tdouble r;//??????\n\tPOINT p;//??????\n}CIRCLE;\n\n//POINT????????????\nvoid print_p(POINT a){\n\tprintf(\"(%lf,%lf)\\n\",a.x,a.y);\n}\n\n//LINE????????????\nvoid print_l(LINE a){\n\tprintf(\"(%lf,%lf) -> (%lf,%lf)\\n\",(a.s).x,(a.s).y,(a.e).x,(a.e).y);\n}\n\n//COMPLEX????????????\nvoid print_c(COMPLEX a){\n\tprintf(\"(%lf,%lf)\\n\",a.r,a.q);\n}\n\n//????????????????????¢?????????\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\n//2???a,b???????????¢\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n//??´??§????????????\nPOINT sum_vec(POINT a,POINT b){\n\ta.x += b.x;\n\ta.y += b.y;\n\treturn a;\n}\n\n//??´??§????????????\n//mkae_vec??¨?????£??????????????¨???????????????\n//??????????????????\nPOINT dif_vec(POINT a,POINT b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\treturn a;\n}\n\n//??´??§????????????????????????\nPOINT scalar_vec(POINT a,double k){\n\ta.x *= k;\n\ta.y *= k;\n\treturn a;\n}\n\n//???????????????\nPOINT minus_vec(POINT a){\n\treturn scalar_vec(a,-1.0);\n}\n\n//??????\ndouble dot(POINT a,POINT b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//??????\ndouble cross(POINT a,POINT b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n//AP:PB=t:s??¨?????????????±???????\n//k, 0:??????, 1:??????\n//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???\nPOINT division(POINT a,POINT b,double t,double s,int k){\n\tdouble tmp = t + s * (1 - k*2);\n\ta.x += (make_vec(a,b)).x / tmp * t;\n\ta.y += (make_vec(a,b)).y / tmp * t;\n\treturn a;\n}\n\n//???p????????´???a?????????????????????????¶??????????\nPOINT perpendicular(LINE a,POINT p){\n\tPOINT ps = make_vec(p,a.s);\n\tPOINT pe = make_vec(p,a.e);\n\tdouble t = norm2(ps) - dot(ps,pe);\n\tdouble s = norm2(pe) - dot(ps,pe);\n\treturn division(a.s,a.e,t,s,0);\n}\n\n//??´???a???????????????p??¨????§°???????????????\nPOINT reflection(LINE a,POINT p){\n\tPOINT h = perpendicular(a,p);\n\treturn sum_vec(h,make_vec(p,h));\n}\n\n//* ????§???¢?????????\nint inclusion(POINT a[],int n,POINT p){\n\tint ans = 0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 0;i < n;i++){\n\t\tif(g[i].x == p.x && g[i].y == p.y){\n\t\t\treturn ans = 1;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tw = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),\n\t\t\t\tdot(make_vec(p,g[i]),make_vec(p,g[i+1])));\n\t\trad += w;\n\t\tif(fabs(w - M_PI) <= 0.000001 ||\n\t\t\t fabs(w + M_PI) <= 0.000001)\n\t\t\treturn ans = 1;\n\t}\n\tif(fabs(rad - M_PI*2)<=0.000001){//2??\n\t\treturn ans = 2;//in!\n\t}\n\treturn ans;\n}\n\n// a.s, a.e, p?????????????????????\n// ???????¨???????????????????????????????  1\n// ????¨?????????????????????????????????? -1\n// p, a.s, a.e????????????????????? 2\n// a.s, a.e, p?????????????????????-2\n// ???p?????´???a???????????????????????? 0\nint ccw(LINE a,POINT p){\n\tint cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));\n\tif(cls > 0){\n\t\treturn  1;\n\t}else if(cls < 0){\n\t\treturn -1;\n\t}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0){\n\t\treturn  2;\n\t}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0){\n\t\treturn -2;\n\t}else{\n\t\treturn  0;\n\t}\n}\n\n// ??????????????????\nint parallel(LINE a,LINE b){\n\tif(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ?????´????????????\nint orthogonal(LINE a,LINE b){\n\tif(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ??????a,b???????????????????????????\nint intersection(LINE a,LINE b){\n\tif(ccw(a,b.s)*ccw(a,b.e) <= 0 &&\n\t   ccw(b,a.s)*ccw(b,a.e) <= 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n//??????a,b?????????\nPOINT cross_point(LINE a,LINE b){\n\tdouble c1 = cross(make_vec(a.s,b.s),make_vec(a.s,b.e));\n\tdouble c2 = cross(make_vec(a.e,b.s),make_vec(a.e,b.e));\n\treturn division(a.s,a.e,fabs(c1),fabs(c2),0);\n}\n\n//??´???a??¨???p????????¢\ndouble distanceLP(LINE a,POINT p){\n\tif(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0)\n\t\treturn norm(make_vec(a.s,p));\n\tif(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0)\n\t\treturn norm(make_vec(a.e,p));\n\treturn norm(make_vec(p,perpendicular(a,p)));\n}\n\n//??´???a??¨??´???b????????¢\ndouble distanceLL(LINE a,LINE b){\n\tdouble a1,a2,a3,a4;\n\tif(intersection(a,b) == 1)\n\t\treturn 0.0000000000;\n\ta1 = distanceLP(a,b.s);\n\ta2 = distanceLP(a,b.e);\n\ta3 = distanceLP(b,a.s);\n\ta4 = distanceLP(b,a.e);\n\t//a1 = min(a1,min(a2,min(a3,a4)));\n\ta1 = min(a1,a2);\n\ta3 = min(a3,a4);\n\ta1 = min(a1,a3);\n\treturn a1;\n}\n\n//????§???¢?????¢???\ndouble area(POINT a[],int n){\n\tdouble ans = 0.0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n-1;i ++){\n\t\tans += cross(make_vec(g[0],g[i]),make_vec(g[0],g[i+1]));\n\t}\n\treturn fabs(ans);\n}\n\n\n//* ?????§??????\nint is_convex(POINT a[],int n){\n\tint ans = 0;\n\tint i,j;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n;i++){\n\t\tw = cross(make_vec(g[i],g[i-1]),make_vec(g[i],g[i+1]))/norm(make_vec(g[i],g[i-1]))/norm(make_vec(g[i],g[i+1]));\n\t\tif(w > 0.00000000){\n\t\t\treturn 0;\n\t\t}\t\t\t\n\t}\n\treturn 1;\n}\n\n//* ??????????????????\n//4\n//3\n//2\n//1\n//0\n//??\\?????°?????????\nint inter_c(CIRCLE a,CIRCLE b){\n\tdouble tmp = distance(a.p,b.p);\n\tif(tmp > a.r+b.r)\n\t\treturn 4;\n\telse if(fabs(tmp-(a.r+b.r)) <= 0.00000001)\n\t\treturn 3;\n\telse if(fabs(tmp-fabs(a.r-b.r)) <= 0.00000001)\n\t\treturn 1;\n\telse if(tmp < fabs(a.r-b.r))\n\t\treturn 0;\n\telse return 2;\n}\n\n//?????¨??´????????????\nPOINT *cross_pointCL(CIRCLE a,LINE b){\n\tdouble k,p = distanceLP(b,a.p);\n\tstatic POINT ans[2];\n\tPOINT q,c= perpendicular(b,a.p);\n\tif(fabs(p-a.r) <= 0.000001){\n\t\tans[0] = c;\n\t\tans[1] = c;\n\t\treturn ans;\n\t}else if(p < a.r){\n\t\tk = a.r*sin(acos(p/a.r));\n\t\tq = scalar_vec(make_vec(b.s,b.e),1/norm(make_vec(b.s,b.e)));\n\t\tq = scalar_vec(q,k);\n\t\tans[0] = sum_vec(c,q);\n\t\tq = scalar_vec(q,-k);\n\t\tans[1] = sum_vec(c,q);\n\t}else{\n\t\treturn -1;//??¨??????\n\t}\n} \n\nint main(){\n\tCIRCLE b;\n\tLINE a;\n\tint k;\n\tPOINT *ans;\n\tscanf(\"%lf%lf%lf\",&b.p.x,&b.p.y,&b.r);\n\tscanf(\"%d\",&k);\n\twhile(1){\n\t\tscanf(\"%lf%lf%lf%lf\",&a.s.x,&a.s.y,&a.s.x,&a.s.y);\n\t\tans = cross_pointCL(b,a);\n\t\tif(ans[0].y<ans[1].y)\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n\t\telse\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[1].x,ans[1].y,ans[0].x,ans[0].y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define zahyoutype double\ntypedef struct Point{zahyoutype x,y;}P;\ntypedef struct line{P p1,p2;}L;\n\nP crosspoint(L s,L t){\n\tzahyoutype x=1;if(x/2==0){puts(\"type error\");exit(0);}\n\tdouble deno=(s.p1.x-s.p2.x)*(t.p1.y-t.p2.y)-(t.p1.x-t.p2.x)*(s.p1.y-s.p2.y);\n\tzahyoutype xnume=  s.p1.x*t.p1.x*(s.p2.y-t.p2.y)-s.p1.x*t.p2.x*(s.p2.y-t.p1.y)-s.p2.x*t.p1.x*(s.p1.y-t.p2.y)+s.p2.x*t.p2.x*(s.p1.y-t.p1.y);\n\tzahyoutype ynume=-(s.p1.y*t.p1.y*(s.p2.x-t.p2.x)-s.p1.y*t.p2.y*(s.p2.x-t.p1.x)-s.p2.y*t.p1.y*(s.p1.x-t.p2.x)+s.p2.y*t.p2.y*(s.p1.x-t.p1.x));\n\tP p={xnume/deno,ynume/deno};\n\treturn p;\n}\ndouble seglen(L s){return hypot(s.p2.x-s.p1.x,s.p2.y-s.p1.y);}\ndouble distPP(P p,P q){return hypot(p.x-q.x,p.y-q.y);}\n\nvoid readpoint(P*p){zahyoutype x=1;scanf(x/2?\"%lf%lf\":\"%ld%ld\",&p->x,&p->y);}\nvoid printpoint(P p){zahyoutype x=1;printf(x/2?\"%.f %.f\\n\":\"%ld %ld\\n\",p.x,p.y);}\n\nint main(){\n\tP p;\n\tint r;\n\treadpoint(&p);\n\tscanf(\"%d\",&r);\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tL s,t;\n\t\treadpoint(&s.p1);\n\t\treadpoint(&s.p2);\n\t\tt.p1=p;\n\t\tP q={p.x+(s.p2.y-s.p1.y),p.y-(s.p2.x-s.p1.x)};\n\t\tt.p2=q;\n\t\tP c=crosspoint(s,t);\n\t\tdouble d=distPP(c,p);\n\t\tdouble coe=sqrt(r*r-d*d)/seglen(s);\n\t\tdouble x1,y1,x2,y2;\n\t\tx1=c.x+coe*(s.p2.x-s.p1.x);\n\t\ty1=c.y+coe*(s.p2.y-s.p1.y);\n\t\tx2=c.x-coe*(s.p2.x-s.p1.x);\n\t\ty2=c.y-coe*(s.p2.y-s.p1.y);\n\t\tif(x2<x1||(x2==x1&&y2<y1)){\n\t\t\tdouble t=x1;x1=x2;x2=t;\n\t\t\tt=y1;y1=y2;y2=t;\n\t\t}\n\t\tprintf(\"%.9f %.9f %.9f %.9f\\n\",x1,y1,x2,y2);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2],e=0.0000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e&&a[0][1]<a[1][1]||a[0][0]+e<a[1][0]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2],e=0.000001;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e&&a[0][1]+e<a[1][1]||a[0][0]+e<a[1][0]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n/*int cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  double d=(y1*p2[0]+x1*p2[1]+p0[1]*p1[0]-p1[1]*p0[0])/hypot(y1,x1),l=r*r-d*d;\n  if(l<0)return 1;\n  s[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]-sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]-sqrt(l/(x1*x1+y1*y1))*p1[1];\n  s[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]+sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]+sqrt(l/(x1*x1+y1*y1))*p1[1];\n  return 0;\n  }//*/\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+1.0*(b+sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  s[1]=p0[1]+1.0*(b+sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n  t[0]=p0[0]+1.0*(b-sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  t[1]=p0[1]+1.0*(b-sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(a[0][0]<a[1][0]||fabs(a[0][0]-a[1][0])<0.00000001&&a[0][1]<a[1][1]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  s[0]=p0[0]+x1*(b+d)/a;\n  s[1]=p0[1]+y1*(b+d)/a;\n  t[0]=p0[0]+x1*(b-d)/a;\n  t[1]=p0[1]+y1*(b-d)/a;\n}\nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.00000000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)a[0][1]+e<a[1][1]?j=0:(j=1);\n    else                       a[0][0]+e<a[1][0]?j=0:(j=1);\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n/*int cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  double d=(y1*p2[0]+x1*p2[1]+p0[1]*p1[0]-p1[1]*p0[0])/hypot(y1,x1),l=r*r-d*d;\n  if(l<0)return 1;\n  s[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]-sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]-sqrt(l/(x1*x1+y1*y1))*p1[1];\n  s[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]+sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]+sqrt(l/(x1*x1+y1*y1))*p1[1];\n  return 0;\n  }//*/\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=p2[0]*x1+p2[1]*y1,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+(b-sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  s[1]=p0[1]+(b-sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n  t[0]=p0[0]+(b+sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  t[1]=p0[1]+(b+sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2],e=0.0000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e&&a[0][1]+e<a[1][1]||a[0][0]+e<a[1][0]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\ntypedef struct LINE{\n\tPOINT s;//start point\n\tPOINT e;//end point\n}LINE;\ntypedef struct COMPLEX{\n\tdouble r;//?????¢\n\tdouble q;//????§???????theta\n}COMPLEX;\ntypedef struct CIRCLE{\n\tdouble r;//??????\n\tPOINT p;//??????\n}CIRCLE;\n\n//POINT????????????\nvoid print_p(POINT a){\n\tprintf(\"(%lf,%lf)\\n\",a.x,a.y);\n}\n\n//LINE????????????\nvoid print_l(LINE a){\n\tprintf(\"(%lf,%lf) -> (%lf,%lf)\\n\",(a.s).x,(a.s).y,(a.e).x,(a.e).y);\n}\n\n//COMPLEX????????????\nvoid print_c(COMPLEX a){\n\tprintf(\"(%lf,%lf)\\n\",a.r,a.q);\n}\n\n//????????????????????¢?????????\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\n//2???a,b???????????¢\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n//??´??§????????????\nPOINT sum_vec(POINT a,POINT b){\n\ta.x += b.x;\n\ta.y += b.y;\n\treturn a;\n}\n\n//??´??§????????????\n//mkae_vec??¨?????£??????????????¨???????????????\n//??????????????????\nPOINT dif_vec(POINT a,POINT b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\treturn a;\n}\n\n//??´??§????????????????????????\nPOINT scalar_vec(POINT a,double k){\n\ta.x *= k;\n\ta.y *= k;\n\treturn a;\n}\n\n//???????????????\nPOINT minus_vec(POINT a){\n\treturn scalar_vec(a,-1.0);\n}\n\n//??????\ndouble dot(POINT a,POINT b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//??????\ndouble cross(POINT a,POINT b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n//AP:PB=t:s??¨?????????????±???????\n//k, 0:??????, 1:??????\n//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???\nPOINT division(POINT a,POINT b,double t,double s,int k){\n\tdouble tmp = t + s * (1 - k*2);\n\ta.x += (make_vec(a,b)).x / tmp * t;\n\ta.y += (make_vec(a,b)).y / tmp * t;\n\treturn a;\n}\n\n//???p????????´???a?????????????????????????¶??????????\nPOINT perpendicular(LINE a,POINT p){\n\tPOINT ps = make_vec(p,a.s);\n\tPOINT pe = make_vec(p,a.e);\n\tdouble t = norm2(ps) - dot(ps,pe);\n\tdouble s = norm2(pe) - dot(ps,pe);\n\treturn division(a.s,a.e,t,s,0);\n}\n\n//??´???a???????????????p??¨????§°???????????????\nPOINT reflection(LINE a,POINT p){\n\tPOINT h = perpendicular(a,p);\n\treturn sum_vec(h,make_vec(p,h));\n}\n\n//* ????§???¢?????????\nint inclusion(POINT a[],int n,POINT p){\n\tint ans = 0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 0;i < n;i++){\n\t\tif(g[i].x == p.x && g[i].y == p.y){\n\t\t\treturn ans = 1;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tw = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),\n\t\t\t\tdot(make_vec(p,g[i]),make_vec(p,g[i+1])));\n\t\trad += w;\n\t\tif(fabs(w - M_PI) <= 0.000001 ||\n\t\t\t fabs(w + M_PI) <= 0.000001)\n\t\t\treturn ans = 1;\n\t}\n\tif(fabs(rad - M_PI*2)<=0.000001){//2??\n\t\treturn ans = 2;//in!\n\t}\n\treturn ans;\n}\n\n// a.s, a.e, p?????????????????????\n// ???????¨???????????????????????????????  1\n// ????¨?????????????????????????????????? -1\n// p, a.s, a.e????????????????????? 2\n// a.s, a.e, p?????????????????????-2\n// ???p?????´???a???????????????????????? 0\nint ccw(LINE a,POINT p){\n\tint cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));\n\tif(cls > 0){\n\t\treturn  1;\n\t}else if(cls < 0){\n\t\treturn -1;\n\t}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0){\n\t\treturn  2;\n\t}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0){\n\t\treturn -2;\n\t}else{\n\t\treturn  0;\n\t}\n}\n\n// ??????????????????\nint parallel(LINE a,LINE b){\n\tif(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ?????´????????????\nint orthogonal(LINE a,LINE b){\n\tif(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ??????a,b???????????????????????????\nint intersection(LINE a,LINE b){\n\tif(ccw(a,b.s)*ccw(a,b.e) <= 0 &&\n\t   ccw(b,a.s)*ccw(b,a.e) <= 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n//??????a,b?????????\nPOINT cross_point(LINE a,LINE b){\n\tdouble c1 = cross(make_vec(a.s,b.s),make_vec(a.s,b.e));\n\tdouble c2 = cross(make_vec(a.e,b.s),make_vec(a.e,b.e));\n\treturn division(a.s,a.e,fabs(c1),fabs(c2),0);\n}\n\n//??´???a??¨???p????????¢\ndouble distanceLP(LINE a,POINT p){\n\tif(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0)\n\t\treturn norm(make_vec(a.s,p));\n\tif(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0)\n\t\treturn norm(make_vec(a.e,p));\n\treturn norm(make_vec(p,perpendicular(a,p)));\n}\n\n//??´???a??¨??´???b????????¢\ndouble distanceLL(LINE a,LINE b){\n\tdouble a1,a2,a3,a4;\n\tif(intersection(a,b) == 1)\n\t\treturn 0.0000000000;\n\ta1 = distanceLP(a,b.s);\n\ta2 = distanceLP(a,b.e);\n\ta3 = distanceLP(b,a.s);\n\ta4 = distanceLP(b,a.e);\n\t//a1 = min(a1,min(a2,min(a3,a4)));\n\ta1 = min(a1,a2);\n\ta3 = min(a3,a4);\n\ta1 = min(a1,a3);\n\treturn a1;\n}\n\n//????§???¢?????¢???\ndouble area(POINT a[],int n){\n\tdouble ans = 0.0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n-1;i ++){\n\t\tans += cross(make_vec(g[0],g[i]),make_vec(g[0],g[i+1]));\n\t}\n\treturn fabs(ans);\n}\n\n\n//* ?????§??????\nint is_convex(POINT a[],int n){\n\tint ans = 0;\n\tint i,j;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n;i++){\n\t\tw = cross(make_vec(g[i],g[i-1]),make_vec(g[i],g[i+1]))/norm(make_vec(g[i],g[i-1]))/norm(make_vec(g[i],g[i+1]));\n\t\tif(w > 0.00000000){\n\t\t\treturn 0;\n\t\t}\t\t\t\n\t}\n\treturn 1;\n}\n\n//* ??????????????????\n//4\n//3\n//2\n//1\n//0\n//??\\?????°?????????\nint inter_c(CIRCLE a,CIRCLE b){\n\tdouble tmp = distance(a.p,b.p);\n\tif(tmp > a.r+b.r)\n\t\treturn 4;\n\telse if(fabs(tmp-(a.r+b.r)) <= 0.00000001)\n\t\treturn 3;\n\telse if(fabs(tmp-fabs(a.r-b.r)) <= 0.00000001)\n\t\treturn 1;\n\telse if(tmp < fabs(a.r-b.r))\n\t\treturn 0;\n\telse return 2;\n}\n\n//?????¨??´????????????\nPOINT *cross_pointCL(CIRCLEa,LINE b){\n\tdouble k,p = distanceLP(b,a.p);\n\tstatic POINT ans[2];\n\tPOINT q,c= perpendicular(b,a.p);\n\tif(fabs(p-a.r) <= 0.000001){\n\t\tans[0] = c;\n\t\tans[1] = c;\n\t\treturn ans;\n\t}else if(p < a.r){\n\t\tk = p.r*sin(acos(p/a.r));\n\t\tq = scalar_vec(make_vec(b.s,b.e),1/norm(make_vec(b.s,b.e)));\n\t\tq = scalar_vec(q,k);\n\t\tans[0] = sum_vec(c,q);\n\t\tq = scalar_vec(q,-k);\n\t\tans[1] = sum_vec(c,q);\n\t}else{\n\t\treturn -1;//??¨??????\n\t}\n} \n\nint main(){\n\tCIRCLE b;\n\tLINE a;\n\tint k;\n\tPOINT ans[2];\n\tscanf(\"%lf%lf%lf\",&b.p.x,&b.p.y,&b.r);\n\tscanf(\"%d\",&k);\n\twhile(1){\n\t\tscanf(\"%lf%lf\",&a.x,&a.y);\n\t\tans = cross_pointCL(b,a)\n\t\tif(ans[0].y<ans[1].y)\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n\t\telse\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[1].x,ans[1].y,ans[0].x,ans[0].y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  long long a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  if(b*b<a*c)return 0;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n  return 1;\n}\nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)j=a[0][1]+e<a[1][1]?0:1;\n    else                       j=a[0][0]+e<a[1][0]?0:1;\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  s[0]=p0[0]+x1*(b+d)/a;\n  s[1]=p0[1]+y1*(b+d)/a;\n  t[0]=p0[0]+x1*(b-d)/a;\n  t[1]=p0[1]+y1*(b-d)/a;\n}\nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)a[0][1]+e<a[1][1]?j=0:(j=1);\n    else                       a[0][0]+e<a[1][0]?j=0:(j=1);\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  double d=sqrt(b*b-a*c);\n  s[0]=p0[0]+x1*((b+d)/a);\n  s[1]=p0[1]+y1*((b+d)/a);\n  t[0]=p0[0]+x1*((b-d)/a);\n  t[1]=p0[1]+y1*((b-d)/a);\n}\nint main(){\n  int p[4][2],n,i,r,j=0;\n  double a[2][2],e=0.000005;\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(fabs(a[0][0]-a[1][0])<e)a[0][1]+e<a[1][1]?j=0:(j=1);\n    else                       a[0][0]+e<a[1][0]?j=0:(j=1);\n    printf(\"%.9f %.9f %.9f %.9f\\n\",a[j][0],a[j][1],a[1-j][0],a[1-j][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=x1*x2+y1*y2,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+x1*(b+sqrt(b*b-a*c))/a;\n  s[1]=p0[1]+y1*(b+sqrt(b*b-a*c))/a;\n  t[0]=p0[0]+x1*(b-sqrt(b*b-a*c))/a;\n  t[1]=p0[1]+y1*(b-sqrt(b*b-a*c))/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(a[0][0]<a[1][0]||fabs(a[0][0]-a[1][0])<0.00000001&&a[0][1]<a[1][1]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\ntypedef struct LINE{\n\tPOINT s;//start point\n\tPOINT e;//end point\n}LINE;\ntypedef struct COMPLEX{\n\tdouble r;//?????¢\n\tdouble q;//????§???????theta\n}COMPLEX;\ntypedef struct CIRCLE{\n\tdouble r;//??????\n\tPOINT p;//??????\n}CIRCLE;\n\n//POINT????????????\nvoid print_p(POINT a){\n\tprintf(\"(%lf,%lf)\\n\",a.x,a.y);\n}\n\n//LINE????????????\nvoid print_l(LINE a){\n\tprintf(\"(%lf,%lf) -> (%lf,%lf)\\n\",(a.s).x,(a.s).y,(a.e).x,(a.e).y);\n}\n\n//COMPLEX????????????\nvoid print_c(COMPLEX a){\n\tprintf(\"(%lf,%lf)\\n\",a.r,a.q);\n}\n\n//????????????????????¢?????????\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\n//2???a,b???????????¢\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n//??´??§????????????\nPOINT sum_vec(POINT a,POINT b){\n\ta.x += b.x;\n\ta.y += b.y;\n\treturn a;\n}\n\n//??´??§????????????\n//mkae_vec??¨?????£??????????????¨???????????????\n//??????????????????\nPOINT dif_vec(POINT a,POINT b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\treturn a;\n}\n\n//??´??§????????????????????????\nPOINT scalar_vec(POINT a,double k){\n\ta.x *= k;\n\ta.y *= k;\n\treturn a;\n}\n\n//???????????????\nPOINT minus_vec(POINT a){\n\treturn scalar_vec(a,-1.0);\n}\n\n//??????\ndouble dot(POINT a,POINT b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//??????\ndouble cross(POINT a,POINT b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n//AP:PB=t:s??¨?????????????±???????\n//k, 0:??????, 1:??????\n//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???\nPOINT division(POINT a,POINT b,double t,double s,int k){\n\tdouble tmp = t + s * (1 - k*2);\n\ta.x += (make_vec(a,b)).x / tmp * t;\n\ta.y += (make_vec(a,b)).y / tmp * t;\n\treturn a;\n}\n\n//???p????????´???a?????????????????????????¶??????????\nPOINT perpendicular(LINE a,POINT p){\n\tPOINT ps = make_vec(p,a.s);\n\tPOINT pe = make_vec(p,a.e);\n\tdouble t = norm2(ps) - dot(ps,pe);\n\tdouble s = norm2(pe) - dot(ps,pe);\n\treturn division(a.s,a.e,t,s,0);\n}\n\n//??´???a???????????????p??¨????§°???????????????\nPOINT reflection(LINE a,POINT p){\n\tPOINT h = perpendicular(a,p);\n\treturn sum_vec(h,make_vec(p,h));\n}\n\n//* ????§???¢?????????\nint inclusion(POINT a[],int n,POINT p){\n\tint ans = 0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 0;i < n;i++){\n\t\tif(g[i].x == p.x && g[i].y == p.y){\n\t\t\treturn ans = 1;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tw = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),\n\t\t\t\tdot(make_vec(p,g[i]),make_vec(p,g[i+1])));\n\t\trad += w;\n\t\tif(fabs(w - M_PI) <= 0.000001 ||\n\t\t\t fabs(w + M_PI) <= 0.000001)\n\t\t\treturn ans = 1;\n\t}\n\tif(fabs(rad - M_PI*2)<=0.000001){//2??\n\t\treturn ans = 2;//in!\n\t}\n\treturn ans;\n}\n\n// a.s, a.e, p?????????????????????\n// ???????¨???????????????????????????????  1\n// ????¨?????????????????????????????????? -1\n// p, a.s, a.e????????????????????? 2\n// a.s, a.e, p?????????????????????-2\n// ???p?????´???a???????????????????????? 0\nint ccw(LINE a,POINT p){\n\tint cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));\n\tif(cls > 0){\n\t\treturn  1;\n\t}else if(cls < 0){\n\t\treturn -1;\n\t}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0){\n\t\treturn  2;\n\t}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0){\n\t\treturn -2;\n\t}else{\n\t\treturn  0;\n\t}\n}\n\n// ??????????????????\nint parallel(LINE a,LINE b){\n\tif(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ?????´????????????\nint orthogonal(LINE a,LINE b){\n\tif(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ??????a,b???????????????????????????\nint intersection(LINE a,LINE b){\n\tif(ccw(a,b.s)*ccw(a,b.e) <= 0 &&\n\t   ccw(b,a.s)*ccw(b,a.e) <= 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n//??????a,b?????????\nPOINT cross_point(LINE a,LINE b){\n\tdouble c1 = cross(make_vec(a.s,b.s),make_vec(a.s,b.e));\n\tdouble c2 = cross(make_vec(a.e,b.s),make_vec(a.e,b.e));\n\treturn division(a.s,a.e,fabs(c1),fabs(c2),0);\n}\n\n//??´???a??¨???p????????¢\ndouble distanceLP(LINE a,POINT p){\n\tif(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0)\n\t\treturn norm(make_vec(a.s,p));\n\tif(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0)\n\t\treturn norm(make_vec(a.e,p));\n\treturn norm(make_vec(p,perpendicular(a,p)));\n}\n\n//??´???a??¨??´???b????????¢\ndouble distanceLL(LINE a,LINE b){\n\tdouble a1,a2,a3,a4;\n\tif(intersection(a,b) == 1)\n\t\treturn 0.0000000000;\n\ta1 = distanceLP(a,b.s);\n\ta2 = distanceLP(a,b.e);\n\ta3 = distanceLP(b,a.s);\n\ta4 = distanceLP(b,a.e);\n\t//a1 = min(a1,min(a2,min(a3,a4)));\n\ta1 = min(a1,a2);\n\ta3 = min(a3,a4);\n\ta1 = min(a1,a3);\n\treturn a1;\n}\n\n//????§???¢?????¢???\ndouble area(POINT a[],int n){\n\tdouble ans = 0.0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n-1;i ++){\n\t\tans += cross(make_vec(g[0],g[i]),make_vec(g[0],g[i+1]));\n\t}\n\treturn fabs(ans);\n}\n\n\n//* ?????§??????\nint is_convex(POINT a[],int n){\n\tint ans = 0;\n\tint i,j;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n;i++){\n\t\tw = cross(make_vec(g[i],g[i-1]),make_vec(g[i],g[i+1]))/norm(make_vec(g[i],g[i-1]))/norm(make_vec(g[i],g[i+1]));\n\t\tif(w > 0.00000000){\n\t\t\treturn 0;\n\t\t}\t\t\t\n\t}\n\treturn 1;\n}\n\n//* ??????????????????\n//4\n//3\n//2\n//1\n//0\n//??\\?????°?????????\nint inter_c(CIRCLE a,CIRCLE b){\n\tdouble tmp = distance(a.p,b.p);\n\tif(tmp > a.r+b.r)\n\t\treturn 4;\n\telse if(fabs(tmp-(a.r+b.r)) <= 0.00000001)\n\t\treturn 3;\n\telse if(fabs(tmp-fabs(a.r-b.r)) <= 0.00000001)\n\t\treturn 1;\n\telse if(tmp < fabs(a.r-b.r))\n\t\treturn 0;\n\telse return 2;\n}\n\n//?????¨??´????????????\nPOINT *cross_pointCL(CIRCLE a,LINE b){\n\tdouble k,p = distanceLP(b,a.p);\n\tstatic POINT ans[2];\n\tPOINT q,c= perpendicular(b,a.p);\n\tif(fabs(p-a.r) <= 0.000001){\n\t\tans[0] = c;\n\t\tans[1] = c;\n\t\treturn ans;\n\t}else if(p < a.r){\n\t\tk = a.r*sin(acos(p/a.r));\n\t\tq = scalar_vec(make_vec(b.s,b.e),1/norm(make_vec(b.s,b.e)));\n\t\tq = scalar_vec(q,k);\n\t\tans[0] = sum_vec(c,q);\n\t\tq = scalar_vec(q,-k);\n\t\tans[1] = sum_vec(c,q);\n\t}else{\n\t\treturn -1;//??¨??????\n\t}\n} \n\nint main(){\n\tCIRCLE b;\n\tLINE a;\n\tint k;\n\tPOINT ans[2];\n\tscanf(\"%lf%lf%lf\",&b.p.x,&b.p.y,&b.r);\n\tscanf(\"%d\",&k);\n\twhile(1){\n\t\tscanf(\"%lf%lf%lf%lf\",&a.s.x,&a.s.y,&a.s.x,&a.s.y);\n\t\tans = cross_pointCL(b,a)\n\t\tif(ans[0].y<ans[1].y)\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n\t\telse\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[1].x,ans[1].y,ans[0].x,ans[0].y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n/*int cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],x2=p2[0]-p0[0],y1=p1[1]-p0[1],y2=p2[1]-p0[1];\n  double d=(y1*p2[0]+x1*p2[1]+p0[1]*p1[0]-p1[1]*p0[0])/hypot(y1,x1),l=r*r-d*d;\n  if(l<0)return 1;\n  s[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]-sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[0]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]-sqrt(l/(x1*x1+y1*y1))*p1[1];\n  s[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*x1+p0[0]+sqrt(l/(x1*x1+y1*y1))*p1[0];\n  t[1]=(x1*x2+y1*y2)/(x1*x1+y1*y1)*y1+p0[1]+sqrt(l/(x1*x1+y1*y1))*p1[1];\n  return 0;\n  }//*/\nvoid cplc(int p0[2],int p1[2],int p2[2],int r,double s[2],double t[2]){\n  int x1=p1[0]-p0[0],y1=p1[1]-p0[1],x2=p2[0]-p0[0],y2=p2[1]-p0[1];\n  int a=x1*x1+y1*y1,b=p2[0]*x1+p2[1]*y1,c=x2*x2+y2*y2-r*r;\n  s[0]=p0[0]+(b-sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  s[1]=p0[1]+(b-sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n  t[0]=p0[0]+(b+sqrt(b*b-a*c))*(p1[0]-p0[0])/a;\n  t[1]=p0[1]+(b+sqrt(b*b-a*c))*(p1[1]-p0[1])/a;\n}\nint main(){\n  int p[4][2],n,i,r;\n  double a[2][2];\n  scanf(\"%d %d %d %d\",&p[2][0],&p[2][1],&r,&n);\n  while(n--){\n    for(i=0;i<4;i++)scanf(\"%d\",&p[i/2][i%2]);\n    cplc(p[0],p[1],p[2],r,a[0],a[1]);\n    if(a[0][0]<a[1][0]||fabs(a[0][0]-a[1][0])<0.000001&&a[0][1]<a[1][1]){\n      printf(\"%.9f %.9f %.9f %.9f\\n\",a[0][0],a[0][1],a[1][0],a[1][1]);\n    }\n    else printf(\"%.9f %.9f %.9f %.9f\\n\",a[1][0],a[1][1],a[0][0],a[0][1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_7_D Cross Points of a Circle and a Line\n// 2018.5.3 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\ntypedef struct { double x, y, r; } C;\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define INF 1e8\n#define EPS 1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble dist(PP p1, PP p2) {\treturn vabs(vsub(p1, p2)); }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\ndouble distancePL(PP p, LINE ln)\n{\n\tPP a = vsub(ln.e, ln.s);\n\treturn fabs(cross(vsub(p, ln.s), a)) / vabs(a);\n}\n\nPP projection(PP p1, PP p2, PP p)\n{\n\tPP p2p1 = vsub(p2, p1);\n\tPP pp1 = vsub(p, p1);\n\treturn vadd(p1, vsmul(p2p1, dot(pp1, p2p1)/norm(p2p1)));\n}\n\nint cmp(PP *a, PP *b)\n{\n\tif (EQ(a->x, b->x)) return dcmp(a->y - b->y);\n\treturn dcmp(a->x - b->x);\n}\n\nvoid crossPointCL(PP *p, C c, LINE line)\n{\n\tPP c0 = vset(c.x, c.y);\n\tPP p0;\n\tdouble a, b;\n\n\ta = distancePL(c0, line), b = sqrt(c.r*c.r - a*a);\n\tp0 = projection(line.s, line.e, c0);\n\tp[0] = vadd(p0, vsmul(vsub(line.s, line.e), b/dist(line.s, line.e)));\n\tp[1] = vadd(p0, vsmul(vsub(line.e, line.s), b/dist(line.s, line.e)));\n}\n\t\t\nint main()\n{\n\tint q, i;\n\tC c;\n\tPP p[2];\n\tLINE line;\n\n\tc.x = in(), c.y = in(), c.r = in();\n\tq = in();\n\twhile (q--) {\n\t\tline.s.x = in(), line.s.y = in(), line.e.x = in(), line.e.y = in();\n\n\t\tcrossPointCL(p, c, line);\n\n\t\tqsort(p, 2, sizeof(PP), cmp);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tprintf(\"%.10lf %.10lf\", p[i].x, p[i].y);\n\t\t\tputchar(' ');\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\ntypedef struct LINE{\n\tPOINT s;//start point\n\tPOINT e;//end point\n}LINE;\ntypedef struct COMPLEX{\n\tdouble r;//?????¢\n\tdouble q;//????§???????theta\n}COMPLEX;\ntypedef struct CIRCLE{\n\tdouble r;//??????\n\tPOINT p;//??????\n}CIRCLE;\n\n//POINT????????????\nvoid print_p(POINT a){\n\tprintf(\"(%lf,%lf)\\n\",a.x,a.y);\n}\n\n//LINE????????????\nvoid print_l(LINE a){\n\tprintf(\"(%lf,%lf) -> (%lf,%lf)\\n\",(a.s).x,(a.s).y,(a.e).x,(a.e).y);\n}\n\n//COMPLEX????????????\nvoid print_c(COMPLEX a){\n\tprintf(\"(%lf,%lf)\\n\",a.r,a.q);\n}\n\n//????????????????????¢?????????\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\n//2???a,b???????????¢\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n//??´??§????????????\nPOINT sum_vec(POINT a,POINT b){\n\ta.x += b.x;\n\ta.y += b.y;\n\treturn a;\n}\n\n//??´??§????????????\n//mkae_vec??¨?????£??????????????¨???????????????\n//??????????????????\nPOINT dif_vec(POINT a,POINT b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\treturn a;\n}\n\n//??´??§????????????????????????\nPOINT scalar_vec(POINT a,double k){\n\ta.x *= k;\n\ta.y *= k;\n\treturn a;\n}\n\n//???????????????\nPOINT minus_vec(POINT a){\n\treturn scalar_vec(a,-1.0);\n}\n\n//??????\ndouble dot(POINT a,POINT b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//??????\ndouble cross(POINT a,POINT b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n//AP:PB=t:s??¨?????????????±???????\n//k, 0:??????, 1:??????\n//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???\nPOINT division(POINT a,POINT b,double t,double s,int k){\n\tdouble tmp = t + s * (1 - k*2);\n\ta.x += (make_vec(a,b)).x / tmp * t;\n\ta.y += (make_vec(a,b)).y / tmp * t;\n\treturn a;\n}\n\n//???p????????´???a?????????????????????????¶??????????\nPOINT perpendicular(LINE a,POINT p){\n\tPOINT ps = make_vec(p,a.s);\n\tPOINT pe = make_vec(p,a.e);\n\tdouble t = norm2(ps) - dot(ps,pe);\n\tdouble s = norm2(pe) - dot(ps,pe);\n\treturn division(a.s,a.e,t,s,0);\n}\n\n//??´???a???????????????p??¨????§°???????????????\nPOINT reflection(LINE a,POINT p){\n\tPOINT h = perpendicular(a,p);\n\treturn sum_vec(h,make_vec(p,h));\n}\n\n//* ????§???¢?????????\nint inclusion(POINT a[],int n,POINT p){\n\tint ans = 0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 0;i < n;i++){\n\t\tif(g[i].x == p.x && g[i].y == p.y){\n\t\t\treturn ans = 1;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tw = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),\n\t\t\t\tdot(make_vec(p,g[i]),make_vec(p,g[i+1])));\n\t\trad += w;\n\t\tif(fabs(w - M_PI) <= 0.000001 ||\n\t\t\t fabs(w + M_PI) <= 0.000001)\n\t\t\treturn ans = 1;\n\t}\n\tif(fabs(rad - M_PI*2)<=0.000001){//2??\n\t\treturn ans = 2;//in!\n\t}\n\treturn ans;\n}\n\n// a.s, a.e, p?????????????????????\n// ???????¨???????????????????????????????  1\n// ????¨?????????????????????????????????? -1\n// p, a.s, a.e????????????????????? 2\n// a.s, a.e, p?????????????????????-2\n// ???p?????´???a???????????????????????? 0\nint ccw(LINE a,POINT p){\n\tint cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));\n\tif(cls > 0){\n\t\treturn  1;\n\t}else if(cls < 0){\n\t\treturn -1;\n\t}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0){\n\t\treturn  2;\n\t}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0){\n\t\treturn -2;\n\t}else{\n\t\treturn  0;\n\t}\n}\n\n// ??????????????????\nint parallel(LINE a,LINE b){\n\tif(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ?????´????????????\nint orthogonal(LINE a,LINE b){\n\tif(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ??????a,b???????????????????????????\nint intersection(LINE a,LINE b){\n\tif(ccw(a,b.s)*ccw(a,b.e) <= 0 &&\n\t   ccw(b,a.s)*ccw(b,a.e) <= 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n//??????a,b?????????\nPOINT cross_point(LINE a,LINE b){\n\tdouble c1 = cross(make_vec(a.s,b.s),make_vec(a.s,b.e));\n\tdouble c2 = cross(make_vec(a.e,b.s),make_vec(a.e,b.e));\n\treturn division(a.s,a.e,fabs(c1),fabs(c2),0);\n}\n\n//??´???a??¨???p????????¢\ndouble distanceLP(LINE a,POINT p){\n\tif(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0.0)\n\t\treturn norm(make_vec(a.s,p));\n\tif(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0.0)\n\t\treturn norm(make_vec(a.e,p));\n\treturn norm(make_vec(p,perpendicular(a,p)));\n}\n\n//??´???a??¨??´???b????????¢\ndouble distanceLL(LINE a,LINE b){\n\tdouble a1,a2,a3,a4;\n\tif(intersection(a,b) == 1)\n\t\treturn 0.0000000000;\n\ta1 = distanceLP(a,b.s);\n\ta2 = distanceLP(a,b.e);\n\ta3 = distanceLP(b,a.s);\n\ta4 = distanceLP(b,a.e);\n\t//a1 = min(a1,min(a2,min(a3,a4)));\n\ta1 = min(a1,a2);\n\ta3 = min(a3,a4);\n\ta1 = min(a1,a3);\n\treturn a1;\n}\n\n//????§???¢?????¢???\ndouble area(POINT a[],int n){\n\tdouble ans = 0.0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n-1;i ++){\n\t\tans += cross(make_vec(g[0],g[i]),make_vec(g[0],g[i+1]));\n\t}\n\treturn fabs(ans);\n}\n\n\n//* ?????§??????\nint is_convex(POINT a[],int n){\n\tint ans = 0;\n\tint i,j;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 1;i < n;i++){\n\t\tw = cross(make_vec(g[i],g[i-1]),make_vec(g[i],g[i+1]))/norm(make_vec(g[i],g[i-1]))/norm(make_vec(g[i],g[i+1]));\n\t\tif(w > 0.00000000){\n\t\t\treturn 0;\n\t\t}\t\t\t\n\t}\n\treturn 1;\n}\n\n//* ??????????????????\n//4\n//3\n//2\n//1\n//0\n//??\\?????°?????????\nint inter_c(CIRCLE a,CIRCLE b){\n\tdouble tmp = distance(a.p,b.p);\n\tif(tmp > a.r+b.r)\n\t\treturn 4;\n\telse if(fabs(tmp-(a.r+b.r)) <= 0.00000001)\n\t\treturn 3;\n\telse if(fabs(tmp-fabs(a.r-b.r)) <= 0.00000001)\n\t\treturn 1;\n\telse if(tmp < fabs(a.r-b.r))\n\t\treturn 0;\n\telse return 2;\n}\n\n//?????¨??´????????????\nPOINT *cross_pointCL(CIRCLE a,LINE b){\n\tdouble k,p = distanceLP(b,a.p);\n\tstatic POINT ans[2];\n\tPOINT q,c= perpendicular(b,a.p);\n\tif(fabs(p-a.r) <= 0.000001){\n\t\tans[0] = c;\n\t\tans[1] = c;\n\t\treturn ans;\n\t}else if(p < a.r){\n\t\tk = a.r*sin(acos(p/a.r));\n\t\tq = scalar_vec(make_vec(b.s,b.e),1/norm(make_vec(b.s,b.e)));\n\t\tq = scalar_vec(q,k);\n\t\tans[0] = sum_vec(c,q);\n\t\tq = scalar_vec(q,-k);\n\t\tans[1] = sum_vec(c,q);\n\t}else{\n\t\treturn -1;//??¨??????\n\t}\n} \n\nint main(){\n\tCIRCLE b;\n\tLINE a;\n\tint k;\n\tPOINT ans*;\n\tscanf(\"%lf%lf%lf\",&b.p.x,&b.p.y,&b.r);\n\tscanf(\"%d\",&k);\n\twhile(1){\n\t\tscanf(\"%lf%lf%lf%lf\",&a.s.x,&a.s.y,&a.s.x,&a.s.y);\n\t\tans = cross_pointCL(b,a);\n\t\tif(ans[0].y<ans[1].y)\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[0].x,ans[0].y,ans[1].x,ans[1].y);\n\t\telse\n\t\t\tprintf(\"%.10lf %.10lf %.10lf %.10lf\\n\",ans[1].x,ans[1].y,ans[0].x,ans[0].y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// 入力\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble cx = sc.nextDouble();\n\t\tdouble cy = sc.nextDouble();\n\t\tdouble r = sc.nextDouble();\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tSystem.out.println(solve(cx, cy, r, x1, y1, x2, y2));\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic class Vector2d {\n\t\tVector2d(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"%1$.6f %2$.6f\", x, y);\n\t\t}\n\n\t\tpublic static double product(Vector2d v1, Vector2d v2) {\n\t\t\treturn v1.x;\n\t\t}\n\n\t}\n\n\tstatic class Vector2dComparator implements Comparator<Vector2d> {\n\t\t@Override\n\t\tpublic int compare(Vector2d v1, Vector2d v2) {\n\t\t\tdouble x = v1.x - v2.x;\n\t\t\tdouble y = v1.y - v2.y;\n\t\t\tif (x == 0) {\n\t\t\t\tif (y < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else if (x < 0) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String solve(double cx, double cy, double r, double x1, double y1, double x2, double y2) {\n\t\tList<Vector2d> ans = new ArrayList<>();\n\t\tdouble lx = x2 - x1;\n\t\tdouble ly = y2 - y1;\n\t\tdouble pcx = cx - x1;\n\t\tdouble pcy = cy - y1;\n\t\tdouble lSqNorm = lx * lx + ly * ly;\n\t\tdouble discriminant = Math.sqrt(r * r * lSqNorm - Math.pow(lx * pcy - ly * pcx, 2));\n\t\tdouble k1 = (lx * pcx + ly * pcy + discriminant) / lSqNorm;\n\t\tdouble k2 = (lx * pcx + ly * pcy - discriminant) / lSqNorm;\n\t\tans.add(new Vector2d(x1 + k1 * (x2 - x1), y1 + k1 * (y2 - y1)));\n\t\tans.add(new Vector2d(x1 + k2 * (x2 - x1), y1 + k2 * (y2 - y1)));\n\t\tans.sort(new Vector2dComparator());\n\t\treturn String.format(\"%1$.8f %2$.8f %3$.8f %4$.8f\", ans.get(0).x, ans.get(0).y, ans.get(1).x, ans.get(1).y);\n\t}\n\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Point project(Segment s, Point p) {\n\t\tVector base = s.p2.diff(s.p1);\n\t\tdouble r = p.diff(s.p1).dotProduct(base) / base.norm();\n\t\treturn s.p1.sum(base.mult(r));\n\t}\n\tstatic Point[] getCrossPoints(Circle c, Line l) {\n\t\tPoint pr = project(l, c.c);\n\t\tVector e = l.p2.diff(l.p1).div(l.p2.diff(l.p1).abs()); \n\t\tdouble base = Math.sqrt(c.r*c.r-pr.diff(c.c).norm());\n\t\treturn new Point[]{pr.sum(e.mult(base)), pr.diff(e.mult(base))};\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tCircle c = new Circle(new Point(scan.nextInt(),scan.nextInt()),scan.nextInt());\n\t\tSystem.out.println(c);\n\t\tint q = scan.nextInt();\n\t\tfor (int i=0;i<q;i++) {\n\t\t\tLine l = new Line(new Point(scan.nextInt(),scan.nextInt()),new Point(scan.nextInt(),scan.nextInt()));\n\t\t\tSystem.out.println(l);\n\t\t\tPoint[] res = getCrossPoints(c,l);\n\t\t\tSystem.out.println(res[1].x+\" \"+res[1].y+\" \"+res[0].x+\" \"+res[0].y);\n\t\t}\n\t}\n}\nclass Point {\n\tstatic double EPS = 0.0000000001;\n\tdouble x; double y;\n\tpublic Point(double ax, double ay){x=ax;y=ay;}\n\tpublic Vector sum(Point p) { return new Vector(x+p.x,y+p.y); }\n\tpublic Vector diff(Point p) { return new Vector(x-p.x,y-p.y); }\n\tpublic Vector mult(double k) { return new Vector(x*k,y*k); }\n\tpublic Vector div(double k) { return new Vector(x*(1.0/k),y*(1.0/k)); }\n\tpublic boolean equals(Point p){return Math.abs(x-p.x)<EPS && Math.abs(y-p.y)<EPS;}\n\tpublic String toString(){return \"(\"+x+\",\"+y+\")\";}\n}\nclass Vector extends Point {\n\tpublic Vector(double ax, double ay) {super(ax,ay);}\n\tpublic Vector(Point p1, Point p2) {super(p1.x-p2.x,p2.x-p2.y);}\n\tpublic double norm() {return x*x+y*y;}\n\tpublic double abs() {return Math.sqrt(norm());}\n\t// TODO:\n\tpublic boolean isSmallerThan(Vector v) {return x!=v.x?x<v.x:y<v.y;}\n\tpublic double dotProduct(Vector v) {return x*v.x+y*v.y;}\n\tpublic double crossProduct(Vector v) {return x*v.y - y*v.x;}\n}\n\nclass Segment {\n\tPoint p1; Point p2;\n\tpublic Segment(Point ap1, Point ap2){p1=ap1;p2=ap2;}\n\tpublic double dotProduct(Segment s) {return (p1.x-p2.x)*(s.p1.x-s.p2.x)+(p1.y-p2.y)*(s.p1.y-s.p2.y);}\n\tpublic double crossProduct(Segment s) {return (p1.x-p2.x)*(s.p1.y-s.p2.y) - (p1.y-p2.y)*(s.p1.x-s.p2.x);}\n\tpublic String toString(){return p1.toString()+\"->\"+p2.toString();}\n\tpublic Line toLine() {return new Line(p1,p2);}\n}\nclass Line extends Segment{public Line(Point ap1, Point ap2){super(ap1,ap2);}}\n\nclass Circle {Point c;double r;Circle(Point ac, double ar){c=ac;r=ar;}public String toString(){return \"c:\"+c.toString()+\",r:\"+r;}}\nclass Polygon extends ArrayList<Point>{}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    double cx, cy, r, x1, y1, x2, y2;\n    int q, i;\n    double l1x, l1y, l2x, l2y, d, t1, t2, ax, ay, bx, by, a, bb, c, tmp;\n\n    cx = sc.nextDouble(); cy = sc.nextDouble(); r = sc.nextDouble();\n    q = sc.nextInt();\n\n    for(i = 0;i < q;i++){\n      x1 = sc.nextDouble(); y1 = sc.nextDouble();\n      x2 = sc.nextDouble(); y2 = sc.nextDouble();\n\n      l1x = x2 - x1; l1y = y2 - y1;\n      l2x = x1 - cx; l2y = y1 - cy;\n      a = l1x * l1x + l1y * l1y;\n      bb = l1x * l2x + l1y * l2y;\n      c = l2x * l2x + l2y * l2y - r * r;\n      d = Math.sqrt(bb * bb - a * c);\n\n      t1 = (-bb + d) / a;\n      t2 = (-bb - d) / a;\n      ax = x1 + t1 * l1x; ay = y1 + t1 * l1y;\n      bx = x1 + t2 * l1x; by = y1 + t2 * l1y;\n\n      if(ax > bx || (ax == bx && ay > by)){\n        tmp = ax; ax = bx; bx = tmp;\n        tmp = ay; ay = by; by = tmp;\n      }\n\n      out.println(ax + \" \" + ay + \" \" + bx + \" \" + by);\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Point project(Segment s, Point p) {\n\t\tVector base = s.p2.diff(s.p1);\n\t\tdouble r = p.diff(s.p1).dotProduct(base) / base.norm();\n\t\treturn s.p1.sum(base.mult(r));\n\t}\n\tstatic Point[] getCrossPoints(Circle c, Line l) {\n\t\tPoint pr = project(l, c.c);\n\t\tVector e = l.p2.diff(l.p1).div(l.p2.diff(l.p1).abs()); \n\t\tdouble base = Math.sqrt(c.r*c.r-pr.diff(c.c).norm());\n\t\treturn new Point[]{pr.sum(e.mult(base)), pr.diff(e.mult(base))};\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tCircle c = new Circle(new Point(scan.nextInt(),scan.nextInt()),scan.nextInt());\n\t\tint q = scan.nextInt();\n\t\tfor (int i=0;i<q;i++) {\n\t\t\tLine l = new Line(new Point(scan.nextInt(),scan.nextInt()),new Point(scan.nextInt(),scan.nextInt()));\n\t\t\tPoint[] res = getCrossPoints(c,l);\n\t\t\tSystem.out.println(res[1].x+\" \"+res[1].y+\" \"+res[0].x+\" \"+res[0].y);\n\t\t}\n\t}\n}\nclass Point {\n\tstatic double EPS = 0.0000000001;\n\tdouble x; double y;\n\tpublic Point(double ax, double ay){x=ax;y=ay;}\n\tpublic Vector sum(Point p) { return new Vector(x+p.x,y+p.y); }\n\tpublic Vector diff(Point p) { return new Vector(x-p.x,y-p.y); }\n\tpublic Vector mult(double k) { return new Vector(x*k,y*k); }\n\tpublic Vector div(double k) { return new Vector(x*(1.0/k),y*(1.0/k)); }\n\tpublic boolean equals(Point p){return Math.abs(x-p.x)<EPS && Math.abs(y-p.y)<EPS;}\n\tpublic String toString(){return \"(\"+x+\",\"+y+\")\";}\n}\nclass Vector extends Point {\n\tpublic Vector(double ax, double ay) {super(ax,ay);}\n\tpublic Vector(Point p1, Point p2) {super(p1.x-p2.x,p2.x-p2.y);}\n\tpublic double norm() {return x*x+y*y;}\n\tpublic double abs() {return Math.sqrt(norm());}\n\t// TODO:\n\tpublic boolean isSmallerThan(Vector v) {return x!=v.x?x<v.x:y<v.y;}\n\tpublic double dotProduct(Vector v) {return x*v.x+y*v.y;}\n\tpublic double crossProduct(Vector v) {return x*v.y - y*v.x;}\n}\n\nclass Segment {\n\tPoint p1; Point p2;\n\tpublic Segment(Point ap1, Point ap2){p1=ap1;p2=ap2;}\n\tpublic double dotProduct(Segment s) {return (p1.x-p2.x)*(s.p1.x-s.p2.x)+(p1.y-p2.y)*(s.p1.y-s.p2.y);}\n\tpublic double crossProduct(Segment s) {return (p1.x-p2.x)*(s.p1.y-s.p2.y) - (p1.y-p2.y)*(s.p1.x-s.p2.x);}\n\tpublic String toString(){return p1.toString()+\"->\"+p2.toString();}\n\tpublic Line toLine() {return new Line(p1,p2);}\n}\nclass Line extends Segment{public Line(Point ap1, Point ap2){super(ap1,ap2);}}\n\nclass Circle {Point c;double r;Circle(Point ac, double ar){c=ac;ar=r;}}\nclass Polygon extends ArrayList<Point>{}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tdouble[]c = new double[3];\n\t\tc[0] = scan.nextDouble();\n\t\tc[1] = scan.nextDouble();\n\t\tc[2] = scan.nextDouble();\n\t\tint q  =scan.nextInt();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tdouble[]p1 = {scan.nextDouble(), scan.nextDouble()};\n\t\t\tdouble[]p2 = {scan.nextDouble(), scan.nextDouble()};\n\t\t\tdouble[]ans = getCrossPoints(c, p1, p2);\n\t\t\tif(ans[0] > ans[2]) {\n\t\t\t\tSystem.out.printf(\"%10.8f %10.8f %10.8f %10.8f\\n\", ans[2], ans[3], ans[0], ans[1]);\n\t\t\t}else if(ans[0] == ans[2]) {\n\t\t\t\tif(ans[1] > ans[3]) {\n\t\t\t\t\tSystem.out.printf(\"%10.8f %10.8f %10.8f %10.8f\\n\", ans[2], ans[3], ans[0], ans[1]);\n\t\t\t\t}else {\n\t\t\t\t\tSystem.out.printf(\"%10.8f %10.8f %10.8f %10.8f\\n\", ans[0], ans[1], ans[2], ans[3]);\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tSystem.out.printf(\"%10.8f %10.8f %10.8f %10.8f\\n\", ans[0], ans[1], ans[2], ans[3]);\n\t\t\t}\n\t\t}\n\t\tscan.close();\n\t}\n\tstatic double[] getCrossPoints(double[]c, double[]p1, double[]p2) {\n\t\tdouble[]p3 = {c[0], c[1]};\n\t\tdouble[]h = project(p1, p2, p3);\n\t\tdouble[]e = vec(p1, p2);\n\t\tdouble l = abs(e);\n\n\t\tdouble base = Math.sqrt(c[2] * c[2] - norm(vec(p3, h)));\n\t\te[0] *= base / l;\n\t\te[1] *= base / l;\n\t\tdouble[]a = {h[0] + e[0], h[1] + e[1], h[0] - e[0], h[1] - e[1]};\n\t\treturn a;\n\t}\n\tstatic double[] project(double[]p1, double[]p2, double[]p3) {\n\t\tdouble[]base = vec(p1, p2);\n\t\tdouble[]u = vec(p1, p3);\n\t\tdouble r = dot(u, base) / norm(base);\n\t\tdouble x = p1[0] + base[0]  * r;\n\t\tdouble y = p1[1] + base[1]  * r;\n\t\tdouble[]h = {x, y};\n\t\treturn h;\n\t}\n\tstatic double abs(double[]p) {\n\t\treturn Math.sqrt(norm(p));\n\t}\n\tstatic double norm(double[]p) {\n\t\treturn p[0] * p[0] + p[1] * p[1];\n\t}\n\tstatic double[] vec(double[]p1, double[]p2) {\n\t\tdouble[]u = {p2[0] - p1[0], p2[1] - p1[1]};\n\t\treturn u;\n\t}\n\tstatic double dot(double[]u, double[]v) {\n\t\treturn u[0] * v[0] + u[1] * v[1];\n\t}\n\tstatic double cross(double[]u, double[]v) {\n\t\treturn u[0] * v[1] - u[1] * v[0];\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tpublic static void cross_cl(Circle c, Line l){\n\t\tif(l.x1 == l.x2){\n\t\t\tdouble ans1 = (double)c.y - Math.sqrt(Math.pow((double)c.r,2)-Math.pow((double)(l.x1-c.x),2));\n\t\t\tdouble ans2 = (double)c.y + Math.sqrt(Math.pow((double)c.r,2)-Math.pow((double)(l.x1-c.x),2));\n\t\t\tSystem.out.printf(\"%.8f %.8f %.8f %.8f\\n\",(double)l.x1,ans1,(double)l.x1,ans2);\n\t\t}\n\t\telse if(l.y1 == l.y2){\n\t\t\tdouble ans1 = (double)c.x - Math.sqrt(Math.pow((double)c.r,2)-Math.pow((double)(l.y1-c.y),2));\n\t\t\tdouble ans2 = (double)c.x + Math.sqrt(Math.pow((double)c.r,2)-Math.pow((double)(l.y1-c.y),2));\n\t\t\tSystem.out.printf(\"%.8f %.8f %.8f %.8f\\n\",ans1,(double)l.y1,ans2,(double)l.y1);\n\t\t}\n\t\telse{\n\t\t\tdouble a = (double)(l.y2 - l.y1) / (l.x2 - l.x1);\n\t\t\tdouble ans1 = 1.0 + Math.pow(a,2);\n\t\t\tdouble ans2 = (double)c.x + a * a * l.x1 + a * c.y - a * l.y1;\n\t\t\tdouble ans3 = (double)(c.x * c.x) + Math.pow(a* l.x1 + (double)(c.y - l.y1),2) - (double)(c.r * c.r);\n\t\t\tdouble ansx1 = (ans2 - Math.sqrt(Math.pow(ans2,2)- ans1 * ans3))/ans1;\n\t\t\tdouble ansx2 = (ans2 + Math.sqrt(Math.pow(ans2,2)- ans1 * ans3))/ans1;\n\t\t\tdouble ansy1 = (ansx1 - (double)l.x1) * a + (double)l.y1;\n\t\t\tdouble ansy2 = (ansx2 - (double)l.x1) * a + (double)l.y1;\n\t\t\tSystem.out.printf(\"%.8f %.8f %.8f %.8f\\n\",ansx1,ansy1,ansx2,ansy2);\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tCircle c = new Circle(sc.nextLong(),sc.nextLong(),sc.nextLong());\n\t\tint q = sc.nextInt();\n\t\tfor(int i = 0 ; i < q ; i++){\n\t\t\tLine l = new Line(sc.nextLong(),sc.nextLong(),sc.nextLong(),sc.nextLong());\n\t\t\tcross_cl(c,l);\n\t\t}\n\t}\n}\nclass Circle{\n\tlong x;\n\tlong y;\n\tlong r;\n\tCircle(long x, long y, long r){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.r = r;\n\t}\n}\nclass Line{\n\tlong x1;\n\tlong y1;\n\tlong x2;\n\tlong y2;\n\tLine(long x1, long y1, long x2, long y2){\n\t\tthis.x1 = x1;\n\t\tthis.y1 = y1;\n\t\tthis.x2 = x2;\n\t\tthis.y2 = y2;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Diagnostics;\nusing Aoj.CGL.Lib;\n\nnamespace Aoj.CGL.Chapter7D\n{\n    using Point = Vector;\n\n    class Program\n    {\n        public static void Solve()\n        {\n            int[] p_r = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var circle = new Circle(new Point(p_r[0], p_r[1]), p_r[2]);\n\n            int q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < q; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                var seg = new Segment(input[0],input[1],input[2],input[3]);\n                var points = MathUtil.GetCrossPoints(seg, circle);\n\n                Point p1, p2;\n                if (points[0].X < points[1].X) {\n                    p1 = points[0];\n                    p2 = points[1];\n                } else if (points[0].X > points[1].X) {\n                    p1 = points[1];\n                    p2 = points[0];\n                } else if (points[0].Y < points[1].Y) {\n                    p1 = points[0];\n                    p2 = points[1];\n                } else {\n                    p1 = points[1];\n                    p2 = points[0];\n                }\n                \n                Console.WriteLine(\n                    \"{0:0.0000000000} {1:0.0000000000} {2:0.0000000000} {3:0.0000000000}\",\n                    p1.X,\n                    p1.Y,\n                    p2.X,\n                    p2.Y\n                );\n            }\n        }\n\n        public static void Main()\n        {\n            // Console.SetIn(new System.IO.StreamReader(\"ComputationalGeometry/Input/07_Circle_D_01.txt\"));\n            // var sw = new Stopwatch();\n            // sw.Start();\n\n            Solve();\n\n            // Console.WriteLine(\"{0}ms\", sw.ElapsedMilliseconds);\n        }\n    }\n}\n\nnamespace Aoj.CGL.Lib\n{\n    using Line = Segment;\n\n    using Point = Vector;\n\n    using Polygon = List<Vector>;\n\n    public struct Segment\n    {\n        private Point _p1;\n        private Point _p2;\n\n        public Point P1 { get { return _p1; } }\n        public Point P2 { get { return _p2; } }\n\n        public Segment(Point p1, Point p2)\n        {\n            _p1 = p1;\n            _p2 = p2;\n        }\n\n        public Segment(double x1, double y1, double x2, double y2)\n        {\n            _p1 = new Point(x1, y1);\n            _p2 = new Point(x2, y2);\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"P1x:{0},P1y:{1}, P2x:{2},P2y:{3}\", P1.X, P1.Y, P2.X, P2.Y);\n        }\n    }\n\n    public struct Circle\n    {\n        private Point _p;\n        private double _r;\n\n        public Point P { get { return _p; } }\n        public double R { get { return _r; } }\n\n        public Circle(Point p, double r)\n        {\n            _p = p;\n            _r = r;\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"px:{0},py:{1},r:{2}\", P.X, P.Y, R);\n        }\n    }\n\n    public struct Vector\n    {\n        private double _x;\n        private double _y;\n\n        public double X { get { return _x; } }\n        public double Y { get { return _y; } }\n\n        public Vector(double x, double y)\n        {\n            _x = x;\n            _y = y;\n        }\n\n        public double Norm()\n        {\n            return X * X + Y * Y;\n        }\n\n        public double Abs()\n        {\n            return Math.Sqrt(Norm());\n        }\n\n        public Vector Normalize()\n        {\n            double mag = Abs();\n            return new Vector(X / mag, Y / mag);\n        }\n\n        public static Vector operator +(Vector v1, Vector v2)\n        {\n            return new Vector(v1.X + v2.X, v1.Y + v2.Y);\n        }\n\n        public static Vector operator -(Vector v1, Vector v2)\n        {\n            return new Vector(v1.X - v2.X, v1.Y - v2.Y);\n        }\n\n        public static Vector operator *(Vector v, double k)\n        {\n            return new Vector(v.X * k, v.Y * k);\n        }\n\n        public static Vector operator *(double k, Vector v)\n        {\n            return v * k;\n        }\n\n        public static Vector operator /(Vector v, double k)\n        {\n            return new Vector(v.X / k, v.Y / k);\n        }\n\n        public static Vector operator /(double k, Vector v)\n        {\n            return v / k;\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"x:{0},y:{1}\", X, Y);\n        }\n    }\n\n    public static class MathUtil\n    {\n        public static double Dot(Vector v1, Vector v2)\n        {\n            return v1.X * v2.X + v1.Y * v2.Y;\n        }\n\n        public static double Cross(Vector v1, Vector v2)\n        {\n            return v1.X * v2.Y - v1.Y * v2.X;\n        }\n\n        public static bool IsOrthogonal(Vector v1, Vector v2)\n        {\n            return Dot(v1, v2) == 0.0;\n        }\n\n        public static bool IsOrthogonal(Point a1, Point a2, Point b1, Point b2)\n        {\n            return IsOrthogonal(a1 - a2, b1 - b2);\n        }\n\n        public static bool IsOrthogonal(Segment s1, Segment s2)\n        {\n            return IsOrthogonal((Vector)(s1.P1 - s1.P2), (Vector)(s2.P1 - s2.P2));\n        }\n\n        public static bool IsParallel(Vector v1, Vector v2)\n        {\n            return Cross(v1, v2) == 0.0;\n        }\n\n        public static bool IsParallel(Point a1, Point a2, Point b1, Point b2)\n        {\n            return IsParallel(a1 - a2, b1 - b2);\n        }\n        public static bool IsParallel(Segment s1, Segment s2)\n        {\n            return IsParallel((Vector)(s1.P1 - s1.P2), (Vector)(s2.P1 - s2.P2));\n        }\n\n        public static Vector Project(Vector v, Vector onNormal)\n        {\n            // mag = |b|cos?? / |a|\n            //     = |a||b|cos?? / |a|^2\n            double mag = Dot(v, onNormal) / onNormal.Norm();\n            return new Vector(onNormal.X * mag, onNormal.Y * mag);\n        }\n\n        public static Point Project(Point p, Segment s)\n        {\n            Vector v = p - s.P1;\n            Vector baseV = s.P2 - s.P1;\n            Vector project = Project(v, baseV);\n            return s.P1 + project;\n        }\n\n        public static Point Reflect(Point p, Segment s)\n        {\n            Point project = Project(p, s);\n            return p + (project - p) * 2.0;\n        }\n\n        // ??????????????????????¨??????? ~ ????¨????????????¢???????????°???\n        public const int OnLineBack = 2;\n        public const int CounterClockwise = 1;\n        public const int OnSegment = 0;\n        public const int Clockwise = -1;\n        public const int OnLineFront = -2;\n\n        /// <summary>\n        /// ??????p0p1??????????????????p0p2??????????¨??????? ~ ????¨?????????????????????????????????????int??§?????????\n        /// </summary>\n        /// <param name=\"p0\"></param>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <returns></returns>\n        public static int Ccw(Point p0, Point p1, Point p2)\n        {\n            var baseV = p1 - p0;\n            var v = p2 - p0;\n            if (Cross(baseV, v) > 0)\n                return CounterClockwise;\n            else if (Cross(baseV, v) < 0)\n                return Clockwise;\n            else if (Dot(baseV, v) < 0)\n                return OnLineBack;\n            else if (baseV.Norm() < v.Norm())\n                return OnLineFront;\n            return OnSegment;\n        }\n\n        /// <summary>\n        /// ????????????????????´??????????????????????¢?????????????\n        /// http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool Intersect(Segment s1, Segment s2)\n        {\n            return Intersect(s1.P1, s1.P2, s2.P1, s2.P2);\n        }\n\n        public static bool Intersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            return (\n                Ccw(p1, p2, p3) * Ccw(p1, p2, p4) <= 0 &&\n                Ccw(p3, p4, p1) * Ccw(p3, p4, p2) <= 0\n            );\n        }\n\n\n        public static double GetDistancePP(Point p1, Point p2)\n        {\n            return (p1 - p2).Abs();\n        }\n\n        public static double GetDistancePL(Point p, Line l)\n        {\n            var v1 = p - l.P1;\n            var v2 = l.P2 - l.P1;\n\n            var area = Math.Abs(Cross(v1, v2));\n            var bottom = v2.Abs();\n            return area / bottom;\n        }\n\n        public static double GetDistancePS(Point p, Segment s)\n        {\n            // p??¨???????????????????????????????????????????§????90???????????§????????´??????????????¨???????????¢???\n            if (Dot(p - s.P1, s.P2 - s.P1) < 0.0)\n                return GetDistancePP(p, s.P1);\n            if (Dot(p - s.P2, s.P1 - s.P2) < 0.0)\n                return GetDistancePP(p, s.P2);\n\n            // ????????\\??????????????¨??´???????????¢???\n            return GetDistancePL(p, s);\n        }\n        public static double GetDistanceSS(Segment s1, Segment s2)\n        {\n            // ?????????????????????????????¢???0???\n            if (Intersect(s1, s2))\n                return 0.0;\n\n            // ????????\\????????´??????????????????????????¨????????????????????¢?????????????????????????°????????????????\n            return Math.Min(\n                Math.Min(GetDistancePS(s1.P1, s2), GetDistancePS(s1.P2, s2)),\n                Math.Min(GetDistancePS(s2.P1, s1), GetDistancePS(s2.P2, s1))\n            );\n        }\n        public static double GetDistanceLL(Line l1, Line l2)\n        {\n            // ?????????????????????????????¢???0???\n            if (!IsParallel(l1, l2))\n                return 0.0;\n            return GetDistancePL(l1.P1, l2);\n        }\n\n        public static Point GetCrossPoint(Segment s1, Segment s2)\n        {\n            if (!Intersect(s1, s2))\n                throw new ArgumentException(\"\");\n\n            var baseV = s1.P2 - s1.P1;\n            var bottom = baseV.Abs();\n\n            var v1 = s2.P1 - s1.P1;\n            var h1 = Math.Abs(Cross(baseV, v1)) / bottom;\n\n            var v2 = s2.P2 - s1.P1;\n            var h2 = Math.Abs(Cross(baseV, v2)) / bottom;\n\n            return s2.P1 + (s2.P2 - s2.P1) * (h1 / (h1 + h2));\n        }\n\n        public static Point[] GetCrossPoints(Segment s, Circle c)\n        {\n            Vector project = Project(c.P, s);\n            Vector normal = project - c.P;\n\n            if (normal.Abs() > c.R)\n                throw new ArgumentException(\"\");\n\n            double coefficient = Math.Sqrt(Math.Pow(c.R, 2) - Math.Pow(normal.Abs(), 2));\n\n            Vector e = (s.P2 - s.P1).Normalize();\n\n            var points = new Point[2];\n            points[0] = project + coefficient * e * (-1);\n            points[1] = project + coefficient * e;\n\n            return points;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nusing static Exg;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tconst double eps=1e-11;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar a=sc.Da;\n\t\tvar p1=new Pair(a);\n\t\tint q=sc.I;\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 0;i<q;i++) {\n\t\t\tvar e=sc.Da;\n\t\t\tvar p2=new Pair(e[0],e[1]);\n\t\t\tvar p3=new Pair(e[2],e[3]);\n\t\t\tvar ans=Gp10b(p1,a[2],p2,p3);\n\t\t\tans=ans.OrderBy(x=>x.x).ThenBy(x=>x.y).ToArray();\n\t\t\tsb.Append(String.Join(\" \",ans)+\"\\n\");\n\t\t}\n\t\tConsole.Write(sb);\n\t}\n}\n\npublic struct Pair{\n\tpublic double x,y;\n\tpublic Pair(double x,double y){this.x=x;this.y=y;}\n\tpublic Pair(double[] da){x=da[0];y=da[1];}\n\tpublic Pair(Pair p){x=p.x;y=p.y;}\n\tpublic override string ToString()=>x.ToString()+\" \"+y.ToString();\n\tpublic static Pair operator+(Pair a,Pair b){a.x+=b.x;a.y+=b.y;return a;}\n\tpublic static Pair operator-(Pair a,Pair b){a.x-=b.x;a.y-=b.y;return a;}\n\tpublic static Pair operator*(Pair a,double n){a.x*=n;a.y*=n;return a;}\n\tpublic static Pair operator/(Pair a,double n){a.x/=n;a.y/=n;return a;}\n}\nstatic class Exg{\n\tstatic public double Gp0(Pair a,Pair b){return Sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\n\tstatic public Tuple<bool,Pair> Gp1(Pair p1,Pair p2,Pair p3,Pair p4){\n\t\tdouble t1=(p4.y-p3.y)*(p4.x-p1.x)-(p4.x-p3.x)*(p4.y-p1.y);\n\t\tdouble t2=(p2.x-p1.x)*(p4.y-p1.y)-(p2.y-p1.y)*(p4.x-p1.x);\n\t\tdouble t3=(p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n\t\tif(t3==0){\n\t\t\tif(Abs(Atan2(p2.y-p1.y,p2.x-p1.x))!=Abs(Atan2(p3.y-p1.y,p3.x-p1.x))){return Tuple.Create(p1.x==p3.x&&p1.y==p3.y?true:false,p1);}\n\t\t\tvar a=new Tuple<Pair,int>[]{Tuple.Create(p1,1),Tuple.Create(p2,2),Tuple.Create(p3,3),Tuple.Create(p4,4)};\n\t\t\tArray.Sort(a,(d,e)=>{var c=d.Item1.x.CompareTo(e.Item1.y);return c==0?e.Item1.y.CompareTo(d.Item1.y):c;});\n\t\t\treturn Tuple.Create((Abs(a[0].Item2-a[1].Item2)!=1||Abs(a[2].Item2-a[3].Item2)!=1)||(a[1].Item1.x==a[2].Item1.x&&a[1].Item1.y==a[2].Item1.y)?true:false,a[1].Item1);\n\t\t}\n\t\tdouble t4=t1/t3,t5=t2/t3;\n\t\tif(t4<0||t4>1||t5<0||t5>1){return Tuple.Create(false,new Pair(0,0));}\n\t\telse{return Tuple.Create(true,new Pair(p1.x+t4*(p2.x-p1.x),p1.y+t4*(p2.y-p1.y)));}\n\t}\n\tstatic public double Gp2(Pair p1,Pair p2,Pair p0){return Abs((p2.y-p1.y)*p0.x-(p2.x-p1.x)*p0.y+p2.x*p1.y-p1.x*p2.y)/Sqrt((p2.y-p1.y)*(p2.y-p1.y)+(p2.x-p1.x)*(p2.x-p1.x));}\n\tstatic public double Gp3(Pair p1,Pair p2,Pair p0){return (p1.x-p2.x)*(p0.y-p1.y)+(p1.y-p2.y)*(p1.x-p0.x);}\n\tstatic public double Gp4(Pair a,Pair b,Pair c){\n\t\tdouble a1=a.x-b.x,a2=a.y-b.y,c1=c.x-b.x,c2=c.y-b.y;\n\t\treturn Acos((a1*c1+a2*c2)/Sqrt((a1*a1+a2*a2)*(c1*c1+c2*c2)))*180/PI;\n\t}\n\tstatic public Tuple<bool,Pair> Gp5(Pair p1,Pair p2,Pair p0){\n\t\tdouble rx=p0.x,ry=p0.y;\n\t\tif(p1.x==p2.x){rx=p1.x;}\n\t\telse if(p1.y==p2.y){ry=p1.y;}\n\t\telse{\n\t\t\tdouble m1=(p2.y-p1.y)/(p2.x-p1.x),b1=p1.y-(m1*p1.x),m2=-1.0/m1,b2=p0.y-(m2*p0.x);\n\t\t\trx=(b2-b1)/(m1-m2);\n\t\t\try=(b2*m1-b1*m2)/(m1-m2);\n\t\t}\n\t\treturn Tuple.Create(((p1.x>=rx&&p2.x<=rx)||(p2.x>=rx&&p1.x<=rx))&&((p1.y>=ry&&p2.y<=ry)||(p2.y>=ry&&p1.y<=ry)),new Pair(rx,ry));\n\t}\n\tstatic public Pair Gp6(Pair a,Pair b,Pair c,int n){\n\t\tdouble l1=Sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n\t\tdouble l2=Sqrt((c.x-b.x)*(c.x-b.x)+(c.y-b.y)*(c.y-b.y));\n\t\tdouble ex=(a.x+(b.x+(c.x-b.x)*(l1/l2)))/2,ey=(a.y+(b.y+(c.y-b.y)*(l1/l2)))/2;\n\t\tex+=(ex-b.x)*n;ey+=(ey-b.y)*n;\n\t\treturn new Pair(ex,ey);\n\t}\n\tstatic public Pair Gp7(Pair a,double k,double p){return new Pair(a.x+k*Cos(p),a.y+k*Sin(p));}\n\tstatic public bool Gp8(Pair a,Pair b,Pair c){return (c.x-a.x)*(b.y-a.y)==(b.x-a.x)*(c.y-a.y);}\n\tstatic public Pair Gp9(Pair a,Pair b,Pair c){\n\t\tdouble d=a.x*a.x+a.y*a.y,e=b.x*b.x+b.y*b.y,f=c.x*c.x+c.y*c.y,g=2*(a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y));\n\t\treturn new Pair((d*(b.y-c.y)+e*(c.y-a.y)+f*(a.y-b.y))/g,(d*(c.x-b.x)+e*(a.x-c.x)+f*(b.x-a.x))/g);\n\t}\n\tstatic public Pair[] Gp10(Pair p0,double r,Pair p1,Pair p2){\n\t\tdouble xp=p2.y-p1.y,yp=p1.x-p2.x;\n\t\tdouble ex=p2.x-p1.x,ey=p2.y-p1.y;\n\t\tdouble k=Sqrt(ex*ex+ey*ey);\n\t\tex/=k;\n\t\tey/=k;\n\t\tk=-(xp*p0.x+yp*p0.y-(xp*p1.x+yp*p1.y))/(xp*-ey+yp*ex);\n\t\txp=p0.x+k*-ey;\n\t\typ=p0.y+k*ex;\n\t\tk=r*r-k*k;\n\t\tif(k<0){return new Pair[]{};}\n\t\tif(k==0){return new Pair[]{new Pair(xp,yp)};}\n\t\tk=Sqrt(k);\n\t\treturn new Pair[]{new Pair(xp+k*ex,yp+k*ey),new Pair(xp-k*ex,yp-k*ey)};\n\t}\n\tstatic public Pair[] Gp10b(Pair p0,double r,Pair p1,Pair p2){\n\t\tdouble a=p2.y-p1.y,b=p1.x-p2.x;\n\t\tdouble d=p0.x*-a+p0.y*-b+a*p1.x+b*p1.y;\n\t\tdouble g=a*a+b*b;\n\t\tdouble k=g*r*r-d*d;\n\t\tif(k<0){return new Pair[]{};}\n\t\t\n\t\tk=Sqrt(k);\n\t\treturn new Pair[]{new Pair((a*d-b*k)/g+p0.x,(b*d+a*k)/g+p0.y),new Pair((a*d+b*k)/g+p0.x,(b*d-a*k)/g+p0.y)};\n\t}\n\tstatic public Pair[] Gp11(Pair p1,double r1,Pair p2,double r2){\n\t\tvar p3=p1;\n\t\tp2-=p1;\n\t\tp1.x=p1.y=0;\n\t\tdouble a=(p2.x*p2.x+p2.y*p2.y+r1*r1-r2*r2)/2;\n\t\tdouble d=p1.x*p2.x+p1.y*p2.y+a;\n\t\tdouble g=p2.x*p2.x+p2.y*p2.y;\n\t\tdouble k=g*r1*r1-d*d;\n\t\tif(k<0){return new Pair[]{};}\n\t\tif(k==0){return new Pair[]{new Pair((-p2.x*d)/g+p1.x,(-p2.y*d)/g+p1.y)};}\n\t\tk=Sqrt(k);\n\t\treturn new Pair[]{new Pair((-p2.x*d+p2.y*k)/g+p1.x,(-p2.y*d-p2.x*k)/g+p1.y),new Pair((-p2.x*d-p2.y*k)/g+p1.x,(-p2.y*d+p2.x*k)/g+p1.y)};\n\t}\n\tstatic public Tuple<Pair,double>[] Psort(Pair[] pa,Pair p){\n\t\tvar arr=new Tuple<Pair,double>[pa.Length];\n\t\tfor(int i = 0;i<pa.Length;i++) {arr[i]=Tuple.Create(pa[i],Atan2(pa[i].y-p.y,pa[i].x-p.x)*180/PI+180);}\n\t\tArray.Sort(arr,(u,v)=>u.Item2.CompareTo(v.Item2));\n\t\treturn arr;\n\t}\n\tstatic public Tuple<Pair,double>[] Psort2(Pair[] pa,Pair p){\n\t\tint n=pa.Length;\n\t\tvar arr=new Tuple<Pair,double>[n];\n\t\tfor(int i = 0;i<n;i++) {arr[i]=Tuple.Create(pa[i],Atan2(pa[i].y-p.y,pa[i].x-p.x)*180/PI+180);}\n\t\tArray.Sort(arr,(u,v)=>u.Item2.CompareTo(v.Item2));\n\t\tArray.Resize(ref arr,n<<1);\n\t\tfor(int i = 0;i<n;i++) {arr[i+n]=Tuple.Create(arr[i].Item1,arr[i].Item2+360);}\n\t\treturn arr;\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),double.Parse);}\n\tpublic double[] Da3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        var P = new Point(Reader.Double(), Reader.Double());\n        double R = Reader.Double();\n        int NQ = Reader.Int();\n\n\n        for (int q = 0; q < NQ; q++)\n        {\n            var A = new Point(Reader.Double(), Reader.Double());\n            var B = new Point(Reader.Double(), Reader.Double());\n            var line = new Line(A, B);\n            var cross = Intersection(P, R, line);\n            if (cross.Length == 1) Console.WriteLine(cross[0] + \" \" + cross[0]);\n            else Console.WriteLine(cross[0] + \" \" + cross[1]);\n        }\n\n        Console.ReadLine();\n    }\n\n    public Point[] Intersection(Point circleCenter, double r, Line line)\n    {\n        const double EPS = 1e-10;\n        var v = line.B - line.A;\n        var p = line.A + v * (v.Dot(circleCenter - line.A) / v.Dot(v));\n        double d = p.Distance(circleCenter);\n        if (d > r) return new Point[0];\n        if (Math.Abs(d - r) < EPS) return new Point[1] { p };\n        var e = (line.B - line.A) * (1.0 / (line.B - line.A).Norm);\n        var m = Math.Sqrt(r * r - (p - circleCenter).Dot(p - circleCenter));\n        var A = p - e * m;\n        var B = p + e * m;\n        if (A.CompareTo(B) <= 0) return new Point[] { A, B };\n        return new Point[] { B, A };\n    }\n\n    public class Line\n    {\n        public Point A, B;\n        public Point this[int i]\n        {\n            get { if (i == 0) return A; if (i == 1) return B; throw new ArgumentException(); }\n        }\n        public Line(Point a, Point b) { Debug.Assert(a != b); A = a; B = b; }\n        public override string ToString() { return A + \" - \" + B; }\n    }\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-10;\n        public double X, Y;\n        public string Label;\n\n        public Point(double x, double y) { X = x; Y = y; Label = \"\"; }\n        public Point(double x, double y, string s) { X = x; Y = y; Label = s; }\n\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(double d, Point p)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public static Point operator *(Point p, double d) { return d * p; }\n        public double Norm { get { return Math.Sqrt(Add(X * X, Y * Y)); } }\n        public double Distance(Point b) { return (b - this).Norm; }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public override bool Equals(object obj) { return Equals((Point)obj); }\n        public static bool operator ==(Point a, Point b) { return a.Equals(b); }\n        public static bool operator !=(Point a, Point b) { return !a.Equals(b); }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \" \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    private static TextReader reader = Console.In;\n    private static readonly char[] separator = { ' ' };\n    private static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    private static string[] A = new string[0];\n    private static int i;\n    private static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Enu.Range(0, N).Select(i => Int()).ToArray(); }\n    public static int[][] IntTable(int H) { return Enu.Range(0, H).Select(i => IntLine()).ToArray(); }\n    public static string[] StringArray(int N) { return Enu.Range(0, N).Select(i => Next()).ToArray(); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    private static string[] Split(string s) { return s.Split(separator, op); }\n    private static string Next() { CheckNext(); return A[i++]; }\n    private static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n//using System.Linq;\n//using Vector = CGL.Point;\n//using Line = CGL.Segment;\n//using Polygon = System.Collections.Generic.List<CGL.Point>;\n\nnamespace CGL\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var k = scan;\n            var C = new Circle(new Point(k[0], k[1]), k[2]);\n            var q = scan[0];\n            for (int i = 0; i < q; i++)\n            {\n                var t = scan;\n                var P = new Point[2];\n                for (int j = 0; j < 2; j++)\n                {\n                    P[j] = new Point(t[j * 2], t[j * 2 + 1]);\n                }\n                var s1 = new Segment(P[0], P[1]);\n                var p = C.GetCrossPoints(s1);\n                if(p.Key < p.Value)\n                {\n                    Console.WriteLine(\"{0:F7} {1:F7} {2:F7} {3:F7}\", p.Key.x, p.Key.y, p.Value.x, p.Value.y);                \n                }\n                else\n                {\n                    Console.WriteLine(\"{0:F7} {1:F7} {2:F7} {3:F7}\", p.Value.x, p.Value.y, p.Key.x, p.Key.y);\n                }\n            }\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n    \n    struct Point\n    {\n        static readonly double EPS = 1E-10;\n        public double x, y;\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point a, double k) { return new Point(k * a.x, k * a.y); }\n        public static Point operator /(Point a, double k) { return new Point(a.x / k, a.y / k); }\n        \n        public double Abs { get { return Math.Sqrt(Norm); } }  \n        public double Norm { get { return x * x + y * y; } }\n\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public override bool Equals(object p){  return Math.Abs(x - ((Point)p).x) < EPS && Math.Abs(y - ((Point)p).y) < EPS; }\n        public override int GetHashCode(){ return x.GetHashCode() ^ y.GetHashCode(); }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double GetDistance(Point p) { return (this - p).Abs; }\n\n        public int CCW(Point b)\n        {\n            if (Cross(b) > EPS) return 1;\n            if (Cross(b) < -EPS) return -1;\n            if (Dot(b) < -EPS) return 2;\n            if (Norm < b.Norm) return -2;\n            return 0;\n        }\n    }\n    struct Segment\n    {\n        public Point p1, p2;\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n        public Point Projection(Point p)\n        {\n            Point b = p2 - p1;\n            double r = b.Dot(p - p1) / b.Norm;\n            return p1 + b * r;\n        }\n        public Point Reflection(Point p)\n        {\n            return p + (Projection(p) - p) * 2;\n        }\n        public double GetD_LP(Point p)\n        {\n            return Math.Abs((p - p1).Cross(p2 - p1) / (p2 - p1).Abs);\n        }\n        public double GetD_SP(Point p)\n        {\n            if ((p - p1).Dot(p2 - p1) < 0) return (p - p1).Abs;\n            if ((p - p2).Dot(p1 - p2) < 0) return (p - p2).Abs;\n            return GetD_LP(p);\n        }\n        public bool Intersect(Segment s)\n        {\n            return (p2 - p1).CCW(s.p1 - p1) * (p2 - p1).CCW(s.p2 - p1) <= 0 &&\n                (s.p2 - s.p1).CCW(p1 - s.p1) * (s.p2 - s.p1).CCW(p2 - s.p1) <= 0;\n        }\n        public double GetDistance(Segment s)\n        {\n            if (this.Intersect(s)) return 0;\n            return Math.Min(Math.Min(GetD_SP(s.p1), GetD_SP(s.p2)), Math.Min(s.GetD_SP(p1), s.GetD_SP(p2)));\n        }\n        public Point GetCrossPoint(Segment s)\n        {\n            Point b = s.p2 - s.p1;\n            double d1 = Math.Abs(b.Cross(p1 - s.p1));\n            double d2 = Math.Abs(b.Cross(p2 - s.p1));\n            double t = d1 / (d1 + d2);\n            return p1 + (p2 - p1) * t;\n        }\n    }\n    struct Circle\n    {\n        public Point c; double r;\n        public Circle(Point c, double r)\n        {\n            this.c = c;\n            this.r = r;\n        }\n        public bool Intersect(Segment l)\n        {\n            return l.GetD_LP(c) <= r;\n        }\n        public KeyValuePair<Point, Point> GetCrossPoints(Segment l)\n        {\n            Point pr = l.Projection(c);\n            Point e = (l.p2 - l.p1) / (l.p2 - l.p1).Abs;\n            double b = Math.Sqrt(r * r - (pr - c).Norm);\n            return new KeyValuePair<Point, Point>(pr + e * b, pr - e * b);\n        }\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\n\nnamespace AOJ\n{\n    using Vector = Point;\n    using Line = Segment;\n    using Polygon = List<Point>;\n\n    class Consts\n    {\n        public static readonly double EPS = 1e-10;\n    }\n    class Point\n    {\n        double x, y;\n        public double X { get { return this.x; } set { this.x = value; } }\n        public double Y { get { return this.y; } set { this.y = value; } }\n        public Point(double x = 0, double y = 0)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        static public Point operator +(Point p1, Point p2) => new Point(p1.x + p2.x, p1.y + p2.y);\n        static public Point operator -(Point p1, Point p2) => new Point(p1.x - p2.x, p1.y - p2.y);\n        static public Point operator *(Point p, double a) => new Point(a * p.x, a * p.y);\n        static public Point operator *(double a, Point p) => p * a;\n        static public Point operator /(Point p, double a) => new Point(p.x / a, p.y / a);\n        static public bool operator <(Point p1, Point p2) => p1.x != p2.x ? p1.x < p2.x : p1.y < p2.y;\n        static public bool operator >(Point p1, Point p2) => p2 < p1;\n\n        static public bool operator ==(Point p1, Point p2) => (p1.x - p2.x) < Consts.EPS && (p1.y - p2.y) < Consts.EPS;\n        static public bool operator !=(Point p1, Point p2) => !(p1 == p2);\n\n        public double abs() => Math.Sqrt(norm());\n        public double norm() => this.x * this.x + this.y * this.y;\n\n        public override bool Equals(object obj)\n        {\n            if ((object)obj == null || this.GetType() != obj.GetType())\n            {\n                return false;\n            }\n            var c = (Point)obj;\n            return this == c;\n        }\n        public override int GetHashCode()\n        {\n            return this.x.GetHashCode() ^ this.y.GetHashCode();\n        }\n    }\n    struct Segment\n    {\n        public Segment(Point p1,Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n        public Point p1, p2;\n    }\n    class Circle\n    {\n        public Point c;\n        public double r;\n        public Circle(Point c, double r)\n        {\n            this.c = c;\n            this.r = r;\n        }\n    }\n\n    class VecCalc\n    {\n        static bool equals(double a, double b) => Math.Abs(a - b) < Consts.EPS;\n        //内積\n        static public double dot(Vector a, Vector b)\n        {\n            return a.X * b.X + a.Y * b.Y;\n        }\n        //外積\n        static public double cross(Vector a, Vector b)\n        {\n            return a.X * b.Y - a.Y * b.X;\n        }\n        //16.2 直行判定\n        static public bool isOrthogonal(Vector a, Vector b)\n        {\n            return equals(dot(a, b), 0.0);\n        }\n        static public bool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n        {\n            return isOrthogonal(a1 - a2, b1 - b2);\n        }\n        static public bool isOrthogonal(Segment s1, Segment s2)\n        {\n            return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n        }\n        //16.2 平行判定\n        static public bool isParallel(Vector a, Vector b)\n        {\n            return equals(cross(a, b), 0.0);\n        }\n        static public bool isParallel(Point a1, Point a2, Point b1, Point b2)\n        {\n            return isParallel(a1 - a2, b1 - b2);\n        }\n        static public bool isParallel(Segment s1, Segment s2)\n        {\n            return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n        }\n        //16.3 射影\n        static public Point project(Segment s, Point p)\n        {\n            Vector b = s.p2 - s.p1;\n            double r = dot(p - s.p1, b) / b.norm();\n            return s.p1 + b * r;\n        }\n        //16.4 反射\n        static public Point reflection(Segment s, Point p)\n        {\n            return 2 * project(s, p) - p;\n            //mid = project(s, p) - p;\n            //return mid + mid - p;\n        }\n        //16.5 距離\n        //2点間の距離\n        static public double getDistance(Point a, Point b)\n        {\n            return (a - b).abs();\n        }\n        //直線lと点pの距離\n        static public double getDistanceLP(Line l,Point p)\n        {\n            return Math.Abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n        }\n        //線分sと点pの距離\n        static public double getDistanceSP(Segment s, Point p)\n        {\n            if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n            if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n            return getDistanceLP(s, p);\n        }\n        static public double getDistance(Segment s1, Segment s2)\n        {\n            if (intersect(s1, s2)) return 0.0;\n            return Math.Min(\n                    Math.Min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n                    Math.Min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n                );\n        }\n        //16.6 反時計回り\n        static public readonly int COUNTER_CLOCKWISE=1;\n        static public readonly int CLOCKWISE = -1;\n        static public readonly int ONLINE_BACK = 2;\n        static public readonly int ONLINE_FRONT = -2;\n        static public readonly int ON_SEGMENT = 0;\n        static public int ccw(Point p0, Point p1, Point p2)\n        {\n            Vector a = p1 - p0;\n            Vector b = p2 - p0;\n            var dot_ = dot(a, b);\n            var cross_ = cross(a, b);\n            if (Consts.EPS < cross_) return COUNTER_CLOCKWISE;\n            if (cross_ < -Consts.EPS) return CLOCKWISE;\n            if (dot_ < -Consts.EPS) return ONLINE_BACK;\n            if (a.norm() < b.norm()) return ONLINE_FRONT;\n            return ON_SEGMENT;\n        }\n        static public int ccw(Segment s, Point p)\n        {\n            return ccw(s.p1, s.p2, p);\n\n        }\n        //16.7 線分の交差判定\n        static public bool intersect(Point p1, Point p2,Point p3,Point p4)\n        {\n            return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n                ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n                );\n        }\n        static public bool intersect(Segment s1, Segment s2)\n        {\n            return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n        }\n        //16.8 線分の交点\n        static public Point getCrossPoint(Segment s1, Segment s2)\n        {\n            Vector b = s2.p2 - s2.p1;\n            double d1 = Math.Abs(cross(b, s1.p1 - s2.p1));\n            double d2 = Math.Abs(cross(b, s1.p2 - s2.p1));\n            double t = d1 / (d1 + d2);\n            return s1.p1 + (s1.p2 - s1.p1) * t;\n        }\n        //16.9 円と直線の交点\n        static public Segment getCrossPoints(Circle c, Line l)\n        {\n            Vector pr = project(l, c.c);\n            System.Diagnostics.Debug.Assert((c.c - pr).abs() <= c.r);\n            Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n            double b = Math.Sqrt(c.r * c.r - (c.c - pr).norm());\n            return new Segment(pr + e * b, pr - e * b);\n        }\n    }\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Trim().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n\n        static void Main(string[] args)\n        {\n            var cr = Sarray();\n            var c = new Circle(new Vector(cr[0], cr[1]), cr[2]);\n            var Q = Sarray()[0];\n            for (var i = 0; i < Q; ++i)\n            {\n                var l = Sarray();\n                var line = new Line() { p1 = new Point(l[0], l[1]), p2 = new Point(l[2], l[3]) };\n                var ans = VecCalc.getCrossPoints(c, line);\n                var ans1 = ans.p1;\n                var ans2 = ans.p2;\n                if (ans1.X < ans2.X)\n                { }\n                else if (ans2.X < ans1.X)\n                {\n                    var tmp = ans1;\n                    ans1 = ans2;\n                    ans2 = tmp;\n                }\n                else if (ans2.Y < ans1.Y)\n                {\n                    var tmp = ans1;\n                    ans1 = ans2;\n                    ans2 = tmp;\n                }\n                WriteLine($\"{ans1.X:F6} {ans1.Y:F6} {ans2.X:F6} {ans2.Y:F6}\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\nstatic decimal EPS = 1e-10m;//小数誤差比較\n\tstatic void Main()\n\t{\n\t\tstring[] input = Console.ReadLine().Split(' ');\n    Vector2 centerPoint = new Vector2(decimal.Parse(input[0]), decimal.Parse(input[1]));\n    decimal circleRadius = decimal.Parse(input[2]);\n\t\tlong q = long.Parse(Console.ReadLine());\n\n    for(long i = 0; i < q; i++)\n    {\n      string[] inputSub = Console.ReadLine().Split(' ');\n      Vector2 beginPoint = new Vector2(decimal.Parse(inputSub[0]), decimal.Parse(inputSub[1]));\n      Vector2 endPoint = new Vector2(decimal.Parse(inputSub[2]), decimal.Parse(inputSub[3]));\n      Vector2[] answers = Vector2.circleLineIntersection(centerPoint, circleRadius, beginPoint, endPoint);//円と直線の交点\n      Vector2 swapMemo;\n      if(answers[0].x>answers[1].x || (Math.Abs(answers[0].x-answers[1].x)<EPS && answers[0].y>answers[1].y))\n      {\n        swapMemo = answers[0];\n        answers[0] = answers[1];\n        answers[1] = swapMemo;\n      }\n      Console.WriteLine(answers[0].x + \" \" + answers[0].y + \" \" + answers[1].x + \" \" + answers[1].y);\n    }\n\t}\n}\n\nclass Vector2//2次元ベクトル\n{\nstatic decimal EPS = 1e-10m;//小数誤差比較\n\n  public Vector2 (decimal X, decimal Y)\n  {\n    this.x = X;\n    this.y = Y;\n  }\n\n  public decimal x {private set; get;}\n  public decimal y {private set; get;}\n\n  public static Vector2 operator + (Vector2 ob1, Vector2 ob2)//ベクトルの基本演算\n  {\n    return new Vector2 (ob1.x + ob2.x, ob1.y + ob2.y);\n  }\n  public static Vector2 operator - (Vector2 ob1, Vector2 ob2)\n  {\n    return new Vector2 (ob1.x - ob2.x, ob1.y - ob2.y);\n  }\n  public static Vector2 operator * (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator * (decimal scalar, Vector2 ob)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator / (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x / scalar, ob.y / scalar);\n  }\n\n  public decimal Length()//ベクトルの長さの2乗\n  {\n    return x * x + y * y;\n  }\n  public static decimal DotProduct(Vector2 ob1, Vector2 ob2)//内積\n  {\n    return ob1.x * ob2.x + ob1.y * ob2.y;\n  }\n  public static decimal CrossProduct(Vector2 ob1, Vector2 ob2)//外積。第2引数が反時計回り側で正。\n  {\n    return ob1.x * ob2.y - ob1.y * ob2.x;\n  }\n\n  public static Vector2 Projection(Vector2 beginPoint, Vector2 endPoint, Vector2 point)//点の射影\n  {\n    Vector2 segment = endPoint - beginPoint;\n    decimal ratio = Vector2.DotProduct(point - beginPoint, segment) / segment.Length();\n    return beginPoint + segment * ratio;//始点にたす\n  }\n\npublic static long WhereVector(Vector2 beginPoint, Vector2 endPoint, Vector2 point)\n  {//ベクトルに対する点の位置\n    Vector2 segment = endPoint - beginPoint;\n    Vector2 aimVec = point - beginPoint;\n    if(Vector2.CrossProduct(segment, aimVec) > EPS)\n      return 1;//反時計回り側\n    else if(Vector2.CrossProduct(segment, aimVec) < -EPS)\n      return 2;//時計回り側\n    else if(Vector2.DotProduct(segment, aimVec) < -1+EPS)\n      return 3;//ベクトル反対向きの側\n    else if(segment.Length() < aimVec.Length())\n      return 4;//ベクトル向きの側\n    else\n      return 5;//ベクトル上\n  }\n\n  public static Vector2 IntersectPoint(Vector2 vecA, Vector2 vecB, \n    Vector2 vecAsub, Vector2 vecBsub)//2線分の交点\n  {\n    Vector2 leftPoint = Vector2.Projection(vecA, vecB, vecAsub);//線分左端点の射影\n    Vector2 rightPoint = Vector2.Projection(vecA, vecB, vecBsub);//線分右端点の射影\n    decimal leftLength = (vecAsub - leftPoint).Length();\n    decimal rightLength = (vecBsub - rightPoint).Length();\n\n    leftLength = (decimal)(Math.Sqrt((double)leftLength));\n    rightLength = (decimal)(Math.Sqrt((double)rightLength));\n    \n    if(leftLength < EPS) return leftPoint;\n    else if(rightLength < EPS) return rightPoint;\n    decimal ratio = leftLength / (leftLength + rightLength);\n    return (leftPoint + ratio * (rightPoint - leftPoint));\n  }\n\n  public static Vector2[] circleLineIntersection(Vector2 centerPoint, decimal circleRadius, \n    Vector2 beginPoint, Vector2 endPoint)//円と線分の交点\n  {\n    Vector2[] answers = new Vector2[2];\n    Vector2 segment = endPoint - beginPoint;\n    Vector2 unitSegment = segment / (decimal)Math.Sqrt((double)segment.Length());\n    Vector2 circleProjection = Projection(beginPoint, endPoint, centerPoint);//交点の中点\n    decimal lineLength = \n      (decimal)Math.Sqrt((double)(circleRadius*circleRadius - (circleProjection-centerPoint).Length()));//端点と中点の距離\n    //Console.WriteLine(unitSegment.x+\" \"+unitSegment.y);\n    answers[0] = circleProjection + (unitSegment * lineLength);\n    answers[1] = circleProjection - (unitSegment * lineLength);\n    return answers;\n  }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Console;\nusing static System.Math;\nusing static MyIO;\nusing static MyUtil;\n\nusing static Geometory;\nusing Vector = Geometory.Point;\nusing Line = Geometory.Segment;\n\npublic class D\n{\n\tpublic static void Main() => (new Solver()).Solve();\n}\n\npublic class Solver\n{\n\tpublic void Solve()\n\t{\n\t\tvar c = new Circle(new Point(GetDouble(), GetDouble()), GetDouble());\n\t\tint Q = GetInt();\n\t\tvar ans = new string[Q];\n\t\tfor(int i = 0; i < Q; i++)\n\t\t\tans[i] = solve(c);\n\n\t\tWriteLine(string.Join(\"\\n\", ans));\n\t}\n\n\tprivate string solve(Circle c)\n\t{\n\t\tvar p1 = new Point(GetDouble(), GetDouble());\n\t\tvar p2 = new Point(GetDouble(), GetDouble());\n\t\tvar l = new Line(p1, p2);\n\t\tvar points = GetCrossPoints(c, l);\n\t\tvar a = points.Item1;\n\t\tvar b = points.Item2;\n\t\tif(a.X > b.X || (Equals(a.X, b.X) && a.Y > b.Y))\n\t\t\tswap(ref a, ref b);\n\n\t\treturn $\"{a.X:F9} {a.Y:F9} {b.X:F9} {b.Y:F9}\";\n\t}\n}\n\npublic static class Geometory\n{\n\tprivate const double EPS = 1e-10;\n\tpublic static bool Equals(double a, double b) => Math.Abs(a - b) < EPS;\n\n\tpublic class Point\n\t{\n\t\tpublic double X;\n\t\tpublic double Y;\t\t\n\t\tpublic Point(double x, double y)\n\t\t{\n\t\t\tX = x;\n\t\t\tY = y;\n\t\t}\n\t\n\t\tpublic static Point operator+(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\t\tpublic static Point operator-(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n\t\tpublic static Point operator*(Point p, double a) => new Point(a * p.X, a * p.Y);\n\t\tpublic static Point operator*(double a, Point p) => new Point(a * p.X, a * p.Y);\n\t\tpublic static Point operator/(Point p, double a) => new Point(p.X / a, p.Y / a);\n\t}\n\n\tpublic class Segment\n\t{\n\t\tpublic Point P1;\n\t\tpublic Point P2;\n\t\tpublic Segment(Point p1, Point p2)\n\t\t{\n\t\t\tP1 = p1;\n\t\t\tP2 = p2;\n\t\t}\n\t}\n\n\tpublic class Circle\n\t{\n\t\tpublic Point C;\n\t\tpublic double R;\n\t\tpublic Circle(Point c, double r)\n\t\t{\n\t\t\tC = c;\n\t\t\tR = r;\n\t\t}\n\t}\n\n\tpublic static double Abs(Vector a) => Math.Sqrt(Norm(a));\n\tpublic static double Norm(Vector a) => a.X * a.X + a.Y * a.Y;\n\tpublic static double Dot(Vector a, Vector b) => a.X * b.X + a.Y * b.Y;\n\tpublic static double Cross(Vector a, Vector b) => a.X * b.Y - a.Y * b.X;\n\n\tpublic static bool IsOrthogonal(Vector a, Vector b) => Equals(Dot(a, b), 0.0);\n\tpublic static bool IsOrthogonal(Point a1, Point a2, Point b1, Point b2) => IsOrthogonal(a1 - a2, b1 - b2);\n\tpublic static bool IsOrthogonal(Segment s1, Segment s2) => Equals(Dot(s1.P2 - s1.P1, s2.P2 - s2.P1), 0.0);\n\tpublic static bool IsParallel(Vector a, Vector b) => Equals(Cross(a, b), 0.0);\n\tpublic static bool IsParallel(Point a1, Point a2, Point b1, Point b2) => IsParallel(a1 - a2, b1 - b2);\n\tpublic static bool IsParallel(Segment s1, Segment s2) => Equals(Cross(s1.P2 - s1.P1, s2.P2 - s2.P1), 0.0);\n\n\tpublic static Point Project(Segment s, Point p)\n\t{\n\t\tVector b = s.P2 - s.P1;\n\t\tdouble r = Dot(p - s.P1, b) / Norm(b);\n\t\treturn s.P1 + b * r;\n\t}\n\tpublic static Point Reflect(Segment s, Point p) => p + (Project(s, p) - p) * 2.0;\n\n\tpublic static double GetDistance(Point a, Point b) => Abs(a - b);\n\tpublic static double GetDistanceLP(Line l, Point p) => Math.Abs(Cross(l.P2 - l.P1, p - l.P1) / Abs(l.P2 - l.P1));\n\tpublic static double GetDistanceSP(Segment s, Point p)\n\t{\n\t\tif(Dot(s.P2 - s.P1, p - s.P1) < 0.0) return Abs(p - s.P1);\n\t\tif(Dot(s.P1 - s.P2, p - s.P2) < 0.0) return Abs(p - s.P2);\n\t\treturn GetDistanceLP(s, p);\n\t}\n\tpublic static double GetDistance(Segment s1, Segment s2)\n\t{\n\t\tif(Intersect(s1, s2)) return 0.0;\n\t\treturn Math.Min(Math.Min(GetDistanceSP(s1, s2.P1), GetDistanceSP(s1, s2.P2)),\n\t\t                Math.Min(GetDistanceSP(s2, s1.P1), GetDistanceSP(s2, s1.P2)));\n\t}\n\n\tpublic const int COUNTER_CLOCKWISE = 1;\n\tpublic const int CLOCKWISE = -1;\n\tpublic const int ONLINE_BACK = 2;\n\tpublic const int ONLINE_FRONT = -2;\n\tpublic const int ON_SEGMENT = 0;\n\tpublic static int Ccw(Point p0, Point p1, Point p2)\n\t{\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif(Cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif(Cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif(Dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif(Norm(a) < Norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\tpublic static bool Intersect(Point p1, Point p2, Point p3, Point p4)\n\t{\n\t\treturn (Ccw(p1, p2, p3) * Ccw(p1, p2, p4) <= 0 && \n\t\t        Ccw(p3, p4, p1) * Ccw(p3, p4, p2) <= 0);\n\t}\n\tpublic static bool Intersect(Segment s1, Segment s2) => Intersect(s1.P1, s1.P2, s2.P1, s2.P2);\n\tpublic static bool Intersect(Circle c, Line l) => GetDistanceLP(l, c.C) - c.R < EPS;\n\n\tpublic static Point GetCrossPoint(Segment s1, Segment s2)\n\t{\n\t\tVector b = s2.P2 - s2.P1;\n\t\tdouble d1 = Math.Abs(Cross(b, s1.P1 - s2.P1));\n\t\tdouble d2 = Math.Abs(Cross(b, s1.P2 - s2.P1));\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.P1 + (s1.P2 - s1.P1) * t;\n\t}\n\tpublic static Tuple<Point, Point> GetCrossPoints(Circle c, Line l)\n\t{\n\t\tif(!Intersect(c, l)) throw new Exception();\n\t\tVector pr = Project(l, c.C);\n\t\tVector e = (l.P2 - l.P1) / Abs(l.P2 - l.P1);\n\t\tdouble b = Math.Sqrt(c.R * c.R - Norm(pr - c.C));\n\t\treturn Tuple.Create(pr + e * b, pr - e * b);\n\t}\n}\n\npublic static class MyIO\n{\n\tprivate static string[] args = null;\n\tprivate static int num = -1;\n\tprivate static int used = -1;\n\n\tprivate static string getArg()\n\t{\n\t\tif(used == num)\n\t\t{\n\t\t\targs = Console.ReadLine().Split(' ');\n\t\t\tnum = args.Length;\n\t\t\tused = 0;\n\t\t}\n\t\treturn args[used++];\n\t}\n\n\tpublic static int GetInt() => int.Parse(getArg());\n\tpublic static long GetLong() => long.Parse(getArg());\n\tpublic static double GetDouble() => double.Parse(getArg());\n\tpublic static decimal GetDecimal() => decimal.Parse(getArg());\n\tpublic static string GetString() => getArg();\n\tpublic static char GetChar() => getArg()[0];\n\tpublic static int[] GetInts(long N) => Enumerable.Range(0, (int)N).Select(_ => GetInt()).ToArray();\n\tpublic static long[] GetLongs(long N) => Enumerable.Range(0, (int)N).Select(_ => GetLong()).ToArray();\n\tpublic static double[] GetDoubles(long N) => Enumerable.Range(0, (int)N).Select(_ => GetDouble()).ToArray();\n\tpublic static decimal[] GetDecimals(long N) => Enumerable.Range(0, (int)N).Select(_ => GetDecimal()).ToArray();\n\tpublic static string[] GetStrings(long N) => Enumerable.Range(0, (int)N).Select(_ => GetString()).ToArray();\n}\n\npublic static class MyUtil\n{\n\tpublic static void chmax<T>(ref T x, T y) where T : IComparable<T>\n\t{\n\t\tif(x.CompareTo(y) < 0)\n\t\t\tx = y;\n\t}\n\n\tpublic static void chmin<T>(ref T x, T y) where T : IComparable<T>\n\t{\n\t\tif(x.CompareTo(y) > 0)\n\t\t\tx = y;\n\t}\n\n\tpublic static void swap<T>(ref T x, ref T y)\n\t{\n\t\tT tmp = x;\n\t\tx = y;\n\t\ty = tmp;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n//using System.Linq;\n//using Vector = CGL.Point;\n//using Line = CGL.Segment;\n//using Polygon = System.Collections.Generic.List<CGL.Point>;\n\nnamespace CGL\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var k = scan;\n            var C = new Circle(new Point(k[0], k[1]), k[2]);\n            var q = scan[0];\n            for (int i = 0; i < q; i++)\n            {\n                var t = scan;\n                var P = new Point[2];\n                for (int j = 0; j < 2; j++)\n                {\n                    P[j] = new Point(t[j * 2], t[j * 2 + 1]);\n                }\n                var s1 = new Segment(P[0], P[1]);\n                var p = C.GetCrossPoints(s1);\n                if(p.Key < p.Value)\n                {\n                    Console.WriteLine(\"{0} {1} {2} {3}\", p.Key.x, p.Key.y, p.Value.x, p.Value.y);                \n                }\n                else\n                {\n                    Console.WriteLine(\"{0} {1} {2} {3}\", p.Value.x, p.Value.y, p.Key.x, p.Key.y);\n                }\n            }\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n    \n    struct Point\n    {\n        static readonly double EPS = 1E-10;\n        public double x, y;\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point a, double k) { return new Point(k * a.x, k * a.y); }\n        public static Point operator /(Point a, double k) { return new Point(a.x / k, a.y / k); }\n        \n        public double Abs { get { return Math.Sqrt(Norm); } }  \n        public double Norm { get { return x * x + y * y; } }\n\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public override bool Equals(object p){  return Math.Abs(x - ((Point)p).x) < EPS && Math.Abs(y - ((Point)p).y) < EPS; }\n        public override int GetHashCode(){ return x.GetHashCode() ^ y.GetHashCode(); }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double GetDistance(Point p) { return (this - p).Abs; }\n\n        public int CCW(Point b)\n        {\n            if (Cross(b) > EPS) return 1;\n            if (Cross(b) < -EPS) return -1;\n            if (Dot(b) < -EPS) return 2;\n            if (Norm < b.Norm) return -2;\n            return 0;\n        }\n    }\n    struct Segment\n    {\n        public Point p1, p2;\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n        public Point Projection(Point p)\n        {\n            Point b = p2 - p1;\n            double r = b.Dot(p - p1) / b.Norm;\n            return p1 + b * r;\n        }\n        public Point Reflection(Point p)\n        {\n            return p + (Projection(p) - p) * 2;\n        }\n        public double GetD_LP(Point p)\n        {\n            return Math.Abs((p - p1).Cross(p2 - p1) / (p2 - p1).Abs);\n        }\n        public double GetD_SP(Point p)\n        {\n            if ((p - p1).Dot(p2 - p1) < 0) return (p - p1).Abs;\n            if ((p - p2).Dot(p1 - p2) < 0) return (p - p2).Abs;\n            return GetD_LP(p);\n        }\n        public bool Intersect(Segment s)\n        {\n            return (p2 - p1).CCW(s.p1 - p1) * (p2 - p1).CCW(s.p2 - p1) <= 0 &&\n                (s.p2 - s.p1).CCW(p1 - s.p1) * (s.p2 - s.p1).CCW(p2 - s.p1) <= 0;\n        }\n        public double GetDistance(Segment s)\n        {\n            if (this.Intersect(s)) return 0;\n            return Math.Min(Math.Min(GetD_SP(s.p1), GetD_SP(s.p2)), Math.Min(s.GetD_SP(p1), s.GetD_SP(p2)));\n        }\n        public Point GetCrossPoint(Segment s)\n        {\n            Point b = s.p2 - s.p1;\n            double d1 = Math.Abs(b.Cross(p1 - s.p1));\n            double d2 = Math.Abs(b.Cross(p2 - s.p1));\n            double t = d1 / (d1 + d2);\n            return p1 + (p2 - p1) * t;\n        }\n    }\n    struct Circle\n    {\n        public Point c; double r;\n        public Circle(Point c, double r)\n        {\n            this.c = c;\n            this.r = r;\n        }\n        public bool Intersect(Segment l)\n        {\n            return l.GetD_LP(c) <= r;\n        }\n        public KeyValuePair<Point, Point> GetCrossPoints(Segment l)\n        {\n            Point pr = l.Projection(c);\n            Point e = (l.p2 - l.p1) / (l.p2 - l.p1).Abs;\n            double b = Math.Sqrt(r * r - (pr - c).Norm);\n            return new KeyValuePair<Point, Point>(pr + e * b, pr - e * b);\n        }\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace CGL_7_D_CrossPointsofaCircleandaLine\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\tint[] inputNum = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\n\t\t\tCircle circle = new Circle (inputNum[0], inputNum[1], inputNum[2]);\n\n\t\t\tint inputCount = int.Parse (Console.ReadLine ());\n\t\t\tStringBuilder output = new StringBuilder (inputCount * 10 * 2);\n\n\t\t\tfor (int lp = 0; lp < inputCount; lp++)\n\t\t\t{\n\t\t\t\tint[] inputNum2 = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\n\t\t\t\tVector2 p1 = new Vector2 (inputNum2[0], inputNum2[1]);\n\t\t\t\tVector2 p2 = new Vector2 (inputNum2[2], inputNum2[3]);\n\n\t\t\t\tVector2[] result = Vector2.CrossPoint (p1, p2, circle).OrderBy (item => item.X).ThenBy (item => item.Y).ToArray ();\n\n\t\t\t\toutput.Append (result[0].X); output.Append (\" \");\n\t\t\t\toutput.Append (result[0].Y); output.Append (\" \");\n\t\t\t\toutput.Append (result[1].X); output.Append (\" \");\n\t\t\t\toutput.Append (result[1].Y); output.AppendLine ();\n\t\t\t}\n\n\t\t\tConsole.Write (output);\n\t\t}\n\t}\n\n\tclass Vector2\n\t{\n\t\tpublic Vector2 ( decimal x, decimal y )\n\t\t{\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t}\n\n\t\tpublic decimal X { private set; get; }\n\t\tpublic decimal Y { private set; get; }\n\n\t\tpublic static Vector2 operator + ( Vector2 ob1, Vector2 ob2 )\n\t\t{\n\t\t\treturn new Vector2 (ob1.X + ob2.X, ob1.Y + ob2.Y);\n\t\t}\n\t\tpublic static Vector2 operator - ( Vector2 ob1, Vector2 ob2 )\n\t\t{\n\t\t\treturn new Vector2 (ob1.X - ob2.X, ob1.Y - ob2.Y);\n\t\t}\n\t\tpublic static Vector2 operator * ( Vector2 ob, decimal scalar )\n\t\t{\n\t\t\treturn new Vector2 (ob.X * scalar, ob.Y * scalar);\n\t\t}\n\t\tpublic static Vector2 operator / ( Vector2 ob, decimal scalar )\n\t\t{\n\t\t\treturn new Vector2 (ob.X / scalar, ob.Y / scalar);\n\t\t}\n\t\tprivate static decimal Sqrt ( decimal number )\n\t\t{\n\t\t\treturn new decimal (Math.Sqrt (decimal.ToDouble (number)));\n\t\t}\n\t\tpublic decimal Length ()\n\t\t{\n\t\t\treturn X * X + Y * Y;\n\t\t}\n\t\tpublic decimal Normalize ()\n\t\t{\n\t\t\tVector2 tmp = new Vector2 (X, Y);\n\t\t\treturn Sqrt (tmp.Length ());\n\t\t}\n\t\tpublic static decimal DotProduct ( Vector2 line1, Vector2 line2 )\n\t\t{\n\t\t\treturn line1.X * line2.X + line1.Y * line2.Y;\n\t\t}\n\t\tpublic static Vector2 Projection ( Vector2 beginPoint, Vector2 endPoint, Vector2 point )\n\t\t{\n\t\t\tVector2 segment = endPoint - beginPoint;\n\t\t\tdecimal ratio = Vector2.DotProduct (point - beginPoint, segment) / segment.Length ();\n\t\t\treturn beginPoint + segment * ratio;\n\t\t}\n\n\t\tpublic static Vector2[] CrossPoint ( Vector2 beginPoint, Vector2 endPoint, Circle circle )\n\t\t{\n\t\t\tVector2 projection = Vector2.Projection (beginPoint, endPoint, circle.Point);\n\t\t\tVector2 normalize = (endPoint - beginPoint) / (endPoint - beginPoint).Normalize ();\n\n\t\t\tdecimal verticalDistance = (projection - circle.Point).Length ();\n\t\t\tdecimal length = Sqrt (circle.Radius * circle.Radius - verticalDistance);\n\n\t\t\treturn new Vector2[] { \n\t\t\t\tprojection + normalize * length, \n\t\t\t\tprojection - normalize * length \n\t\t\t};\n\t\t}\n\t}\n\n\tclass Circle\n\t{\n\t\tpublic Circle ( decimal x, decimal y, decimal radius )\n\t\t{\n\t\t\tthis.Point = new Vector2 (x, y);\n\t\t\tthis.Radius = radius;\n\t\t}\n\n\t\tpublic Vector2 Point { private set; get; }\n\t\tpublic decimal Radius { private set; get; }\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n            Circle c = new Circle(new Point(input[0], input[1]), input[2]);\n\n            int q = int.Parse(Console.ReadLine());\n\n            StringBuilder sb = new StringBuilder();\n            KeyValuePair<Point, Point> temp = new KeyValuePair<Point, Point>();\n            for (int i = 0; i < q; i++)\n            {\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point a = new Point(input[0], input[1]);\n                Point b = new Point(input[2], input[3]);\n                Segment l = new Segment(a, b);\n\n                temp = GetCrossPoints(c, l);\n                if (temp.Key < temp.Value) sb.AppendLine(temp.Key + \" \" + temp.Value);\n                else sb.AppendLine(temp.Value + \" \" + temp.Key);\n            }\n            Console.Write(sb);\n        }\n\n        static KeyValuePair<Point, Point> GetCrossPoints(Circle c, Segment l)\n        {\n            Point pr = Project(l, c.p);\n            Point e = (l.p2 - l.p1) / (l.p2 - l.p1).Abs;\n            double b = Math.Sqrt(c.r * c.r - (pr - c.p).Norm);\n            return new KeyValuePair<Point, Point>(pr + e * b, pr - e * b);\n        }\n\n        static double GetDistanceSS(Segment s1, Segment s2)\n        {\n            if (IsIntersect(s1.p1, s1.p2, s2.p1, s2.p2)) return 0.0;\n            double tempDistS1 = Math.Min(GetDistanceSP(s1, s2.p1), GetDistanceSP(s1, s2.p2));\n            double tempDistS2 = Math.Min(GetDistanceSP(s2, s1.p1), GetDistanceSP(s2, s1.p2));\n            return Math.Min(tempDistS1, tempDistS2);\n        }\n\n        static double GetDistanceSP(Segment s, Point p)\n        {\n            if ((s.p2 - s.p1).Dot(p - s.p1) < 0.0) return (p - s.p1).Abs;\n            if ((s.p1 - s.p2).Dot(p - s.p2) < 0.0) return (p - s.p2).Abs;\n            return GetDistanceLP(s, p);\n        }\n\n        static double GetDistanceLP(Segment l, Point p)\n        {\n            return Math.Abs((l.p2 - l.p1).Cross(p - l.p1) / (l.p2 - l.p1).Abs);\n        }\n\n        static bool IsIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            return CCW(p1, p2, p3) * CCW(p1, p2, p4) <= 0 &&\n                   CCW(p3, p4, p1) * CCW(p3, p4, p2) <= 0;\n        }\n\n        static Point Project(Segment s, Point p)\n        {\n            Point b = s.p2 - s.p1;\n            double r = (p - s.p1).Dot(b) / b.Norm;\n            return s.p1 + b * r;\n        }\n\n        static int CCW(Point p0, Point p1, Point p2)\n        {\n            Point a = p1 - p0, b = p2 - p0;\n\n            if (a.Cross(b) > EPS) return 1;\n            if (a.Cross(b) < -EPS) return -1;\n            if (a.Dot(b) < -EPS) return 2;\n            if (a.Norm < b.Norm) return -2;\n            return 0;\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return x != other.x ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        var P = new Point(Reader.Double(), Reader.Double());\n        double R = Reader.Double();\n        int NQ = Reader.Int();\n\n\n        for (int q = 0; q < NQ; q++)\n        {\n            var A = new Point(Reader.Double(), Reader.Double());\n            var B = new Point(Reader.Double(), Reader.Double());\n            var line = new Line(A, B);\n            var cross = Intersection(P, R, line);\n            if (cross.Length == 1) Console.WriteLine(cross[0] + \" \" + cross[0]);\n            else Console.WriteLine(string.Join(\" \", cross));\n        }\n\n        Console.ReadLine();\n    }\n\n    public Point[] Intersection(Point circleCenter, double r, Line line)\n    {\n        const double EPS = 1e-10;\n        var v = line.B - line.A;\n        var p = line.A + v * (v.Dot(circleCenter - line.A) / v.Dot(v));\n        double d = p.Distance(circleCenter);\n        if (d > r) return new Point[0];\n        if (Math.Abs(d - r) < EPS) return new Point[1] { p };\n        var e = (line.B - line.A) * (1.0 / (line.B - line.A).Norm);\n        var m = Math.Sqrt(r * r - (p - circleCenter).Dot(p - circleCenter));\n        var A = p - e * m;\n        var B = p + e * m;\n        if (A.CompareTo(B) <= 0) return new Point[] { A, B };\n        return new Point[] { B, A };\n    }\n\n    public class Line\n    {\n        public Point A, B;\n        public Point this[int i]\n        {\n            get { if (i == 0) return A; if (i == 1) return B; throw new ArgumentException(); }\n        }\n        public Line(Point a, Point b) { Debug.Assert(a != b); A = a; B = b; }\n        public override string ToString() { return A + \" - \" + B; }\n    }\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-10;\n        public double X, Y;\n        public string Label;\n\n        public Point(double x, double y) { X = x; Y = y; Label = \"\"; }\n        public Point(double x, double y, string s) { X = x; Y = y; Label = s; }\n\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(double d, Point p)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public static Point operator *(Point p, double d) { return d * p; }\n        public double Norm { get { return Math.Sqrt(Add(X * X, Y * Y)); } }\n        public double Distance(Point b) { return (b - this).Norm; }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public override bool Equals(object obj) { return Equals((Point)obj); }\n        public static bool operator ==(Point a, Point b) { return a.Equals(b); }\n        public static bool operator !=(Point a, Point b) { return !a.Equals(b); }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \" \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    private static TextReader reader = Console.In;\n    private static readonly char[] separator = { ' ' };\n    private static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    private static string[] A = new string[0];\n    private static int i;\n    private static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Enu.Range(0, N).Select(i => Int()).ToArray(); }\n    public static int[][] IntTable(int H) { return Enu.Range(0, H).Select(i => IntLine()).ToArray(); }\n    public static string[] StringArray(int N) { return Enu.Range(0, N).Select(i => Next()).ToArray(); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    private static string[] Split(string s) { return s.Split(separator, op); }\n    private static string Next() { CheckNext(); return A[i++]; }\n    private static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace CGL_7_D_CrossPointsofaCircleandaLine\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\tint[] inputNum = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\n\t\t\tCircle circle = new Circle (inputNum[0], inputNum[1], inputNum[2]);\n\n\t\t\tint inputCount = int.Parse (Console.ReadLine ());\n\t\t\tStringBuilder output = new StringBuilder (inputCount * 20 * 2);\n\n\t\t\tfor (int lp = 0; lp < inputCount; lp++)\n\t\t\t{\n\t\t\t\tint[] inputNum2 = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\n\t\t\t\tVector2 p1 = new Vector2 (inputNum2[0], inputNum2[1]);\n\t\t\t\tVector2 p2 = new Vector2 (inputNum2[2], inputNum2[3]);\n\n\t\t\t\tVector2[] result = Vector2.CrossPoint (p1, p2, circle).OrderBy (item => item.X).ThenBy (item => item.Y).ToArray ();\n\n\t\t\t\toutput.Append (result[0].X); output.Append (\" \");\n\t\t\t\toutput.Append (result[0].Y); output.Append (\" \");\n\t\t\t\toutput.Append (result[1].X); output.Append (\" \");\n\t\t\t\toutput.Append (result[1].Y); output.AppendLine ();\n\t\t\t}\n\n\t\t\tConsole.Write (output);\n\t\t}\n\t}\n\n\tclass Vector2\n\t{\n\t\tpublic Vector2 ( decimal x, decimal y )\n\t\t{\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t}\n\n\t\tpublic decimal X { private set; get; }\n\t\tpublic decimal Y { private set; get; }\n\n\t\tpublic static Vector2 operator + ( Vector2 ob1, Vector2 ob2 )\n\t\t{\n\t\t\treturn new Vector2 (ob1.X + ob2.X, ob1.Y + ob2.Y);\n\t\t}\n\t\tpublic static Vector2 operator - ( Vector2 ob1, Vector2 ob2 )\n\t\t{\n\t\t\treturn new Vector2 (ob1.X - ob2.X, ob1.Y - ob2.Y);\n\t\t}\n\t\tpublic static Vector2 operator * ( Vector2 ob, decimal scalar )\n\t\t{\n\t\t\treturn new Vector2 (ob.X * scalar, ob.Y * scalar);\n\t\t}\n\t\tpublic static Vector2 operator / ( Vector2 ob, decimal scalar )\n\t\t{\n\t\t\treturn new Vector2 (ob.X / scalar, ob.Y / scalar);\n\t\t}\n\t\tprivate static decimal Sqrt ( decimal number )\n\t\t{\n\t\t\treturn new decimal (Math.Sqrt (decimal.ToDouble (number)));\n\t\t}\n\t\tpublic decimal Length ()\n\t\t{\n\t\t\treturn X * X + Y * Y;\n\t\t}\n\t\tpublic decimal Normalize ()\n\t\t{\n\t\t\tVector2 tmp = new Vector2 (X, Y);\n\t\t\treturn Sqrt (tmp.Length ());\n\t\t}\n\t\tpublic static decimal DotProduct ( Vector2 line1, Vector2 line2 )\n\t\t{\n\t\t\treturn line1.X * line2.X + line1.Y * line2.Y;\n\t\t}\n\t\tpublic static Vector2 Projection ( Vector2 beginPoint, Vector2 endPoint, Vector2 point )\n\t\t{\n\t\t\tVector2 segment = endPoint - beginPoint;\n\t\t\tdecimal ratio = Vector2.DotProduct (point - beginPoint, segment) / segment.Length ();\n\t\t\treturn beginPoint + segment * ratio;\n\t\t}\n\n\t\tpublic static Vector2[] CrossPoint ( Vector2 beginPoint, Vector2 endPoint, Circle circle )\n\t\t{\n\t\t\tVector2 projection = Vector2.Projection (beginPoint, endPoint, circle.Point);\n\t\t\tVector2 normalize = (endPoint - beginPoint) / (endPoint - beginPoint).Normalize ();\n\n\t\t\tdecimal verticalDistance = (projection - circle.Point).Length ();\n\t\t\tdecimal length = Sqrt (circle.Radius * circle.Radius - verticalDistance);\n\n\t\t\treturn new Vector2[] { \n\t\t\t\tprojection + normalize * length, \n\t\t\t\tprojection - normalize * length \n\t\t\t};\n\t\t}\n\t}\n\n\tclass Circle\n\t{\n\t\tpublic Circle ( decimal x, decimal y, decimal radius )\n\t\t{\n\t\t\tthis.Point = new Vector2 (x, y);\n\t\t\tthis.Radius = radius;\n\t\t}\n\n\t\tpublic Vector2 Point { private set; get; }\n\t\tpublic decimal Radius { private set; get; }\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "// const\nvar COUNTER_CLOCKWISE = 1;\nvar CLOCKWISE = - 1;\nvar ONLINE_BACK = 2;\nvar ONLINE_FRONT =  -2;\nvar ON_SEGMENT = 0;\n\n// Vector2d\nvar Vector2D = class Vector2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nVector2D.prototype.Init = function(x,y){\n\tthis.x = x;\n\tthis.y = y;\n}\n\n/*\n * v: Vector2D\n */\nfunction rotateVector90(v){\n\tvar r = new Vector2D();\n\tr.x = -v.y;\n\tr.y = v.x;\n\treturn r;\n}\n\n/*\n * get degree to radian return radian\n */\nfunction getDegreeToRadian(degree){\n\tvar pi = 3.14159265358979323846;\n\treturn degree * pi / 180;\n}\n\n/*\n * vec:Vector2D return Vector2D\n */\nfunction getRotateVector(vec,degree){\n\tvar radian = getDegreeToRadian(degree);\n\n\tvar sin = Math.sin(radian);\n\tvar cos = Math.cos(radian);\n\n\tvar r = new Vector2D();\n\tr.x = vec.x * cos - vec.y * sin;\n\tr.y = vec.x * sin + vec.y * cos;\n\n\treturn r;\n}\n\nfunction isEqualVectors(a,b){\n\treturn equalFloats(a.x - b.x,0) && equalFloats(a.y - b.y,0);\n}\n\n/**\n * vec:Vector2D\n * \n * return unitVector\n */\nfunction getUnitVector(vec){\n\tvar length = getVectorLength2D(vec);\n\tif(length > 0){\n\t\treturn getDivideVector(vec,length);\n\t}\n\treturn vec;\n}\n\n/**\n * return vector length\n * \n * vec:Vector2D\n */\nfunction getVectorLength2D(vec){\n\treturn Math.sqrt((vec.x * vec.x) + (vec.y * vec.y));\n}\n\nfunction getNorm(vec){\n\treturn vec.x * vec.x + vec.y * vec.y;\n}\n\nfunction getDivideVector(vec2D,length){\n\tvec2D.x = vec2D.x / length;\n\tvec2D.y = vec2D.y / length;\n\treturn vec2D;\n}\n\nfunction equalFloats(a,b){\n\tvar threshold = 1 / 8192;\n\treturn Math.abs(a - b) < threshold;\n}\n\nfunction isParallelVector(vectorA,vectorB){\n\tvar na = rotateVector90(vectorA);\n\treturn equalFloats(0,dotProduct2D(na,vectorB));\n}\n\nfunction isVerticalVector(vectorA,vectorB){\n\treturn equalFloats(0,dotProduct2D(vectorA,vectorB));\n}\n\nfunction subtractVector(vecA,vecB){\n\tvar vec = new Vector2D();\n\tvec.x = vecA.x - vecB.x;\n\tvec.y = vecA.y - vecB.y;\n\treturn vec;\n}\n\nfunction dotProduct2D(vecA,vecB){\n    var dot = vecA.x * vecB.x + vecA.y * vecB.y;\n\treturn vecA.x * vecB.x + vecA.y * vecB.y;\n}\n\n/**\n * 外積\n * \n * @param vecA\n * @param vecB\n * @returns\n */\nfunction getCross(vecA,vecB){\n\treturn vecA.x * vecB.y - vecA.y * vecB.x;\n}\n\n/**\n * line segment\n * \n * point1:Vector2D point2:Vector2D\n */\nvar LineSegment2D = class LineSegment2D {\n\tconstructor(point1,point2){\n\t\tthis.point1 = point1;\n\t\tthis.point2 = point2;\n\t}\n}\n\nLineSegment2D.prototype.Init = function(point1,point2){\n\tthis.point1 = point1;\n\tthis.point2 = point2;\n}\n\nfunction onOneSide(axis,segment){\n\tvar d1 = new Vector2D();\n\td1 = subtractVector(segment.point1,axis.base);\n\n\tvar d2 = new Vector2D();\n\td2 = subtractVector(segment.point2,axis.base);\n\n\tvar n = new Vector2D();\n\tn = rotateVector90(axis.direction);\n\n\t// 同じ方向だということを返す\n\treturn dotProduct2D(n,d1) * dotProduct2D(n,d2) > 0;\n}\n\nfunction overLapping(minA,maxA,minB,maxB){\n\treturn minB <= maxA && minA <= maxB;\n}\n\nfunction isSegmentsCollide(segment1,segment2){\n\t// 線分の方向をチェックするためのベクトル\n\tvar axisA = new Line();\n\tvar axisB = new Line();\n\n\t// 線分1のベクトルに対して、線分2が片側にあるかチェック\n\taxisA.base = segment1.point1;\n\taxisA.direction = subtractVector(segment1.point2,segment1.point1);\n\n\tif(onOneSide(axisA,segment2)){\n\t\treturn false;\n\t}\n\n\t// 同じく\n\taxisB.base = segment2.point1;\n\taxisB.direction = subtractVector(segment2.point2,segment2.point1);\n\n\tif(onOneSide(axisB,segment1)){\n\t\treturn false;\n\t}\n\n\t// 同じベクトルをもつケース\n\tif(isParallelVector(axisA.direction,axisB.direction)){\n\t\tvar rangeA = getProjectSegment(segment1,axisA.direction);\n\t\tvar rangeB = getProjectSegment(segment2,axisA.direction);\n\n\t\t// 重なっているか\n\t\treturn isOverLappingRanges(rangeA,rangeB);\n\t}\n\telse{\n\t\treturn true;\n\t}\n}\n\n/*\n * Line Object\n */\nfunction Line(){\n\t// vector2D\n\tthis.base;\n\t// vector2D\n\tthis.direction\n}\n\nLine.prototype.Init = function(base,direction,color){\n\tthis.base = base;\n\tthis.direction = direction;\n}\n\n/**\n * Range\n */\nvar Range = class Range {\n\tconstructor(min,max){\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t}\n}\n\nfunction getMaxMinRange(range1,range2){\n\tvar range = new Range();\n\trange.min = range1.min < range2.min ? range1.min : range2.min;\n\trange.max = range1.max < range2.max ? range2.max : range1.max;\n\treturn range;\n}\n\nfunction getSortRange(range){\n\tvar sorted = new Range(range.min,range.max);\n\tif(range.min > range.max){\n\t\tsorted.min = range.max;\n\t\tsorted.max = range.min;\n\t}\n\treturn sorted;\n}\n\nfunction getNegateVector(vector){\n\tvector.x = -vector.x;\n\tvector.y = -vector.y;\n\treturn vector;\n}\n\nfunction addVector(vecA,vecB){\n\treturn new Vector2D(vecA.x + vecB.x,vecA.y + vecB.y);\n}\n\n/**\n * segment:segment onto:Vector2D\n * \n * return Range\n */\nfunction getProjectSegment(segment,onto){\n\tvar ontoUnitVec = getUnitVector(onto);\n\n\tvar range = new Range();\n\trange.min = dotProduct2D(ontoUnitVec,segment.point1);\n\trange.max = dotProduct2D(ontoUnitVec,segment.point2);\n\n\trange = getSortRange(range);\n\treturn range;\n}\n\nfunction isOverLappingRanges(range1,range2){\n\treturn overLapping(range1.min,range1.max,range2.min,range2.max);\n}\n\nfunction projectVector(project,onto){\n\tvar d = dotProduct2D(onto,onto);\n\tif(0 < d){\n\t    var dp = dotProduct2D(project,onto);\n\t    return multiplyVector(onto,dp / d);\n\t}\n\treturn onto;\n}\n\n/**\n * point class\n */\nvar Point2D = class Point2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n}\n\nfunction addPoint(point1,point2){\n\treturn new Point2D(point1.x + point2.x,point1.y + point2.y);\n}\n\nfunction subtractPoint(point1,point2){\n\treturn new Point2D(point1.x - point2.x,point1.y - point2.y);\n}\n\nfunction multiplyPoint(point,scalar){\n\treturn new Point2D(point.x * scalar,point.y * scalar);\n}\n\n/**\n * segment : LineSegment2D\n * point : Point\n */\nfunction getProjectPoint(segment,point){\n\tvar vec1 = new Vector2D(segment.point2.x - segment.point1.x,segment.point2.y - segment.point1.y);\n\tvar vec2 = new Vector2D(point.x - segment.point1.x,point.y - segment.point1.y);\n\tvar rate = dotProduct2D(vec2,vec1) / getNorm(vec1);\n\tvar vec3 = multiplyVector(vec1,rate);\n\tvar project = new Point2D(segment.point1.x + vec3.x,segment.point1.y + vec3.y);\n\treturn project; \n}\n\nfunction getReflectionPoint(segment,point){\n\tvar projection = getProjectPoint(segment,point);\n\t// pから射影点までのベクトル\n\tvar vec = subtractPoint(projection,point);\n\t// 2倍したものが射影点になる\n\tvar refrectionPoint = multiplyPoint(vec,2);\n\t// 始点を足す\n\treturn addPoint(refrectionPoint,point);\n}\n\n/**\n * \n * @param segment1\n * @param segment2\n * @returns point\n */\nfunction getCrossPoint(segment1,segment2){\n\t// 基準となる線を決める\n\tvar baseVector = new Vector2D(segment2.point2.x - segment2.point1.x,segment2.point2.y - segment2.point1.y);\n\tvar d1Vec = new Vector2D(segment1.point1.x - segment2.point1.x,segment1.point1.y - segment2.point1.y);\n\tvar d2Vec = new Vector2D(segment1.point2.x - segment2.point1.x,segment1.point2.y - segment2.point1.y);\n\tvar d1 = Math.abs(getCross(baseVector,d1Vec));\n\tvar d2 = Math.abs(getCross(baseVector,d2Vec));\n\tvar t = d1 / (d1 + d2);\n\tvar x = segment1.point1.x + (segment1.point2.x - segment1.point1.x) * t;\n\tvar y = segment1.point1.y + (segment1.point2.y - segment1.point1.y) * t;\n\treturn new Point2D(x,y);\n}\n\nfunction multiplyVector(vec,scalar){\n\tvar temp = new Vector2D();\n\ttemp.x = vec.x * scalar;\n\ttemp.y = vec.y * scalar;\n\treturn temp;\n}\n\nfunction clampOnRange(x,min,max){\n\tif(x < min){\n\t\treturn min;\n\t}else if(x > max){\n\t\treturn max;\n\t}else{\n\t\treturn x;\n\t}\n}\n\n/**\n * 直線と点との距離\n */\nfunction getDistanceLinePoint(line,point){\n\tvar vec1 = new Vector2D(line.point2.x - line.point1.x,line.point2.y - line.point1.y);\n\tvar vec2 = new Vector2D(point.x - line.point1.x,point.y - line.point1.y);\n\treturn Math.abs(getCross(vec1,vec2) / getVectorLength2D(vec1)); \n}\n\n/**\n * 線分と点との距離を求める\n */\nfunction getDistanceSegmentPoint(segment,point){    \n\t// ベクトルp2 - p1とベクトルp - p1がなす角θが90どより大きい場合(-90より小さい場合)\n\t// dは点pと点p1の距離になる\n\tif(dotProduct2D(subtractPoint(segment.point2,segment.point1),subtractPoint(point,segment.point1)) < 0){\n\t\treturn getVectorLength2D(subtractPoint(point,segment.point1));\n\t}\n\t// ベクトルp1 - p2とベクトルp - p2がなす角θが90どより大きい場合(-90より小さい場合)\n\t// dは点pと点p2の距離になる\n\tif(dotProduct2D(subtractPoint(segment.point1,segment.point2),subtractPoint(point,segment.point2)) < 0){\n\t\treturn getVectorLength2D(subtractPoint(point,segment.point2));\n\t}\n\t// それ以外はdは点pと直線p1p2の距離になる\n\treturn getDistanceLinePoint(segment,point);\n}\n\n/**\n * 線分と線分との距離を求める\n */\nfunction getSegmentDistance(segment1,segment2){\n\t// 交差していた場合距離は0になる\n\tif(isSegmentsCollide(segment1,segment2)){\n\t\treturn 0;\n\t}\n\treturn Math.min(Math.min(getDistanceSegmentPoint(segment1,segment2.point1),getDistanceSegmentPoint(segment1,segment2.point2)),\n\t\t\tMath.min(getDistanceSegmentPoint(segment2,segment1.point1),getDistanceSegmentPoint(segment2,segment1.point2)));\n}\n\nfunction ccw(point1,point2,point3){\n    var vec1 = new Vector2D(point2.x - point1.x,point2.y - point1.y);\n    var vec2 = new Vector2D(point3.x - point1.x,point3.y - point1.y);\n    var cross = getCross(vec1,vec2);\n\n    if(cross > Number.EPSILON){\n        return COUNTER_CLOCKWISE;\n    }\n    if(cross < -Number.EPSILON){\n        return CLOCKWISE;\n    }\n    if(dotProduct2D(vec1,vec2) < -Number.EPSILON){\n        return ONLINE_BACK;\n    }\n    if(getVectorLength2D(vec1) < getVectorLength2D(vec2)){\n        return ONLINE_FRONT;\n    }\n    return ON_SEGMENT;\n}\n\n/**\n * アンドリューでconvex hollを返す \n*/\nfunction getConvexHoll(points){\n    if(points.length < 3){\n        return points;\n    }\n    \n    // xを基準に昇順にソート、数値が同じものはyが小さいもの基準にソート \n    points.sort((a, b) => (a.x > b.x) ? 1 : (a.x == b.x) ? ((a.y > b.y) ? 1 : -1) : -1);\n    // xを小さいほうから2つ\n    var u = [];\n    u.push(points[0]);\n    u.push(points[1]);\n    // xを大きい方から2つ\n    var l = [];\n    l.push(points[points.length - 1]);\n    l.push(points[points.length - 2]);\n    \n    // 上部の生成\n    for(var i = 2;i < points.length;++i){\n    \t// 対象が半時計なら削除する\n        for(var j = u.length;j >= 2 && ccw(u[j - 2],u[j - 1],points[i]) == COUNTER_CLOCKWISE;--j){\n            u.pop();\n        }\n        u.push(points[i]);\n    }\n    // 下部の生成\n    for(var i = points.length - 3;i >= 0;--i){\n    \t// 対象が半時計なら削除する\n        for(var j = l.length;j >= 2 && ccw(l[j - 2],l[j - 1],points[i]) == COUNTER_CLOCKWISE;--j){\n            l.pop();;\n        }\n        l.push(points[i]);\n    }\n    // 時計回りに凸包の点の列を生成\n    l.reverse();\n    for(var i = u.length - 2;i >= 1;--i){\n        l.push(u[i]);\n    }\n    return l;\n}\n\nfunction getConvexDiameter(points){\n\t// 対心点(p,q)を取る(y軸で最小・最大のもの)\n    var is = 0;\n    var js = 0;\n    for(var i = 1; i < points.length; i++){\n      if(points[i].y > points[is].y) is = i;\n      if(points[i].y < points[js].y) js = i;\n    }\n    var distance = getNorm(subtractVector(points[is],points[js]));\n    var maxi = is,i = js,maxj = js,j = js;\n    do {\n        // 対心点の中で最長距離のものを探す\n      if(getCross(subtractVector(points[(i + 1) % points.length],points[i]),subtractVector(points[(j + 1) % points.length],points[j])) >= 0){\n        j = (j + 1) % points.length;\n      } else {\n        i = (i + 1) % points.length;\n      }\n      if(getNorm(subtractVector(points[i],points[j])) > distance){\n        distance = getNorm(subtractVector(points[i],points[j]));\n        maxi = i;\n        maxj = j;\n      }\n    }  while (i != is || j != js);\n    return distance;\n}\n\n/**\n * 点で構成される多角形の2d面積を返す\n * \n */\nfunction getArea(points){\n    var area = 0;\n    for(var i = 0;i < points.length;++i){\n        area += getCross(points[i],points[(i + 1) % points.length]);\n    }\n    return area / 2;\n}\n\nfunction getConvexCut(points,point1,point2){\n    // 切り取られた多角形\n    var convex = [];\n    \n\tfor(var i = 0; i < points.length;++i){\n\t\tvar nowPoint = points[i];\n\t\tvar nextPoint = points[(i + 1) % points.length];\n\t\tvar nowPointCcw = ccw(point1,point2,nowPoint);\n\t\tif(nowPointCcw != CLOCKWISE){\n\t\t    convex.push(nowPoint);\n\t\t}\n\t\tif(nowPointCcw * ccw(point1,point2,nextPoint) == CLOCKWISE){\n\t\t    // 交点を求める\n\t\t  var crossPoint = getCrossPointFromPoints(point1,point2,nowPoint,nextPoint);\n\t\t  convex.push(crossPoint);\n\t\t}\n\t}\n\treturn convex;\n}\n\nfunction getPointDistance(point1,point2){\n\tvar x = point1.x - point2.x;\n\tvar y = point1.y - point2.y;\n\treturn Math.sqrt(x * x + y * y);\n}\n\nfunction closestPair(points,n){\n\tif (n == 1)  return Number.MAX_SAFE_INTEGER;\n\tvar d = Number.MAX_SAFE_INTEGER;\n\tvar m = Math.floor(n / 2);\n\td = Math.min(closestPair(points, m),closestPair(points.slice(m),n - m));\n    var mx = points[m].x;\n\tvar arr = [];\n    \n\tfor (var i = m;i >= 0;--i){\n\t    var x = Math.abs(points[i].x - mx);\n\t\tif (x > d){\n\t\t    break;\n\t\t}\n\t\telse{\n\t\t    arr.push(points[i]);\n\t\t}\n\t}\n\tfor (var i = m + 1; i < n; ++i){\n\t\tif (Math.abs(points[i].x - mx) > d){\n\t\t    break;\n\t\t}\t\n\t\telse{\n            arr.push(points[i]);  \n\t\t} \n\t}\n\tarr.sort((a, b) => (a.y > b.y) ? 1 : -1);\n\n\tfor(var i = 0;i < arr.length;++i){\n\t\tfor (var j = i + 1;j < arr.length && Math.abs(arr[j].y - arr[i].y) < d;++j){\n\t\t    var tmp = getPointDistance(arr[i],arr[j]);\n\t\t\tif (tmp < d) d = tmp;\n\t\t}\n\t}\n\treturn d;\n}\n\n/**\n * 2d円を表すクラス\n * \n */\nvar Circle2D = class Circle2D {\n\tconstructor(x,y,r){\n\t\tthis.center = new Point2D(x,y);\n\t\tthis.r = r;\n\t}\n}\n\n/**\n * 円と直線の交点を返す\n * \n */\nfunction getCircleLineCrossPoints(line,circle){\n\tvar d = getDistanceLinePoint(line,circle.center);\n\t// 交点がない場合\n\tif(d > circle.r){\n\t    console.log(\"return\")\n\t\treturn;\n\t}\n\t// 円の中心から直線への射影点\n\tvar pr = getProjectPoint(line,circle.center);\n\t// 交点が一つ\n\tif(equalFloats(d,circle.r)){\n        // 射影点が交点になる\n\t\treturn pr;\n\t}\n\t// 交点が2つ\n\telse{\n\t    // 直線の単位ベクトルを求める\n\t    var unit = getUnitVector(new Vector2D(line.point1.x - line.point2.x,line.point1.y - line.point2.y));\n\t    // 射影点から交点までの長さを求める\n\t    var length = Math.sqrt((circle.r * circle.r) - getNorm(subtractVector(pr,circle.center)));\n\t    var crossPoints = [];\n\t    crossPoints[0] = addPoint(pr,multiplyVector(unit,length));\n\t    crossPoints[1] = subtractVector(pr,multiplyVector(unit,length));\n        return crossPoints;\n\t}\n}\n\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\n//var input = require('fs').readFileSync('input.txt', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\t\n// 1\nvar nums = Arr[0].split(\" \").map(Number);\nvar circle = new Circle2D(nums[0],nums[1],nums[2]);\nArr.shift();\n// 問題\nvar n = Arr[0];\nArr.shift();\n\nfor(var i = 0;i < n;++i){\n    var nums = Arr[i].split(\" \").map(Number);\n    var segment = new LineSegment2D(new Point2D(nums[0],nums[1]),new Point2D(nums[2],nums[3]));\n    var crossPoints = getCircleLineCrossPoints(segment,circle);\n    if(crossPoints.length == 2){\n        // sortが必要\n        crossPoints.sort((a, b) => (a.x > b.x) ? 1 : (a.x == b.x) ? ((a.y > b.y) ? 1 : -1) : -1);\n        console.log(crossPoints[0].x.toFixed(8) + \" \" + crossPoints[0].y.toFixed(8) + \" \" + crossPoints[1].x.toFixed(8) + \" \" + crossPoints[1].y.toFixed(8));\n    }\n    // 交点が1つの場合は繰り返す\n    else{\n        console.log(crossPoints.x.toFixed(8) + \" \" + crossPoints.y.toFixed(8) + \" \" + crossPoints.x.toFixed(8) + \" \" + crossPoints.y.toFixed(8));\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ncx,cy,r=gets.split.map(&:to_f)\ngets.to_i.times{\n\tx1,y1,x2,y2=gets.split.map(&:to_f)\n\tif x1==x2\n\t\t#(x1 - cx)^2 + (y - cy)^2 = r^2\n\t\t#y^2 - 2cyy + cy^2 + (x1 - cx)^2 - r^2 = 0\n\t\t#d=cy**2-(cy**2+(x1-cx)**2-r**2)\n\t\t#y=[cy-Math.sqrt(d),cy+Math.sqrt(d)]\n\t\t#puts [x1,y[0],x1,y[1]]*' '\n\telse\n\t\ta=(y2-y1)/(x2-x1)\n\t\tb=y1-a*x1\n\t\t#(x - cx)^2 + (ax + b-cy)^2 = r^2\n\t\t#x^2 - 2cxx + cx^2 + (ax)^2 + 2a(b-cy)x + (b-cy)^2 = r^2\n\t\t#(a+1)x^2 + (2ab-2acy-2cx)x + cx^2 + (b-cy)^2 - r^2 = 0\n\t\ts=a+1\n\t\tt=2*a*b-2*a*cy-2*cx\n\t\tu=cx**2+(b-cy)**2-r**2\n\t\td=t**2-4*s*u\n\t\tx=[(-t-Math.sqrt(d))/2/s,(-t+Math.sqrt(d))/2/s]\n\t\ty=x.map{|e|a*e+b}\n\t\tputs [x[0],y[0],x[1],y[1]]*' '\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ncx,cy,r=gets.split.map(&:to_f)\ngets.to_i.times{\n\tx1,y1,x2,y2=gets.split.map(&:to_f)\n\tif x1==x2\n\t\t#(x1 - cx)^2 + (y - cy)^2 = r^2\n\t\t#y^2 - 2cyy + cy^2 + (x1 - cx)^2 - r^2 = 0\n\t\td=cy**2-(cy**2+(x1-cx)**2-r**2)\n\t\ty=[cy-Math.sqrt(d),cy+Math.sqrt(d)]\n\t\tputs [x1,y[0],x1,y[1]]*' '\n\telse\n\t\ta=(y2-y1)/(x2-x1)\n\t\tb=y1-a*x1\n\t\t#(x - cx)^2 + (ax + b-cy)^2 = r^2\n\t\t#x^2 - 2cxx + cx^2 + (ax)^2 + 2a(b-cy)x + (b-cy)^2 = r^2\n\t\t#(a+1)x^2 + (2ab-2acy-2cx)x + cx^2 + (b-cy)^2 - r^2 = 0\n\t\ts=a+1\n\t\tt=2*a*b-2*a*cy-2*cx\n\t\tu=cx**2+(b-cy)**2-r**2\n\t\td=t**2-4*s*u\n\t\tx=[(-t-Math.sqrt(d))/2/s,(-t+Math.sqrt(d))/2/s]\n\t\ty=x.map{|e|a*e+b}\n\t\tputs [x[0],y[0],x[1],y[1]]*' '\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ncx,cy,r=gets.split.map(&:to_f)\ngets.to_i.times{\n\tx1,y1,x2,y2=gets.split.map(&:to_f)\n\tif x1==x2\n\t\t#(x1 - cx)^2 + (y - cy)^2 = r^2\n\t\t#y^2 - 2cyy + cy^2 + (x1 - cx)^2 - r^2 = 0\n\t\td=cy**2-(cy**2+(x1-cx)**2-r**2)\n\t\texit if d<0\n\t\ty=[cy-Math.sqrt(d),cy+Math.sqrt(d)]\n\t\tputs [x1,y[0],x1,y[1]]*' '\n\telse\n\t\ta=(y2-y1)/(x2-x1)\n\t\tb=y1-a*x1\n\t\t#(x - cx)^2 + (ax + b-cy)^2 = r^2\n\t\t#x^2 - 2cxx + cx^2 + (ax)^2 + 2a(b-cy)x + (b-cy)^2 = r^2\n\t\t#(a+1)x^2 + (2ab-2acy-2cx)x + cx^2 + (b-cy)^2 - r^2 = 0\n\t\ts=a+1\n\t\tt=2*a*b-2*a*cy-2*cx\n\t\tu=cx**2+(b-cy)**2-r**2\n\t\td=t**2-4*s*u\n\t\tx=[(-t-Math.sqrt(d))/2/s,(-t+Math.sqrt(d))/2/s]\n\t\ty=x.map{|e|a*e+b}\n\t\tputs [x[0],y[0],x[1],y[1]]*' '\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\n\ncx, cy, r = gets.split.map &:to_i\nc = Vector[ cx, cy ]\nq = gets.to_i\nq.times do\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  p0 = Vector[ x1, y1 ]\n  p1 = Vector[ x2, y2 ]\n  p0pr_norm = (c - p0).inner_product(p1 - p0).abs / (p1 - p0).norm\n  p0p1_base = (p1 - p0) / (p1 - p0).norm\n  pr = p0 + p0p1_base * p0pr_norm\n  x = ( r**2 - (c - pr).norm**2 ) ** (1/2.0)\n  i1 = pr - p0p1_base * x\n  i2 = pr + p0p1_base * x\n  puts \"%.7f %.7f %.7f %.7f\" % [ i1[0], i1[1], i2[0], i2[1] ]\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ncx,cy,r=gets.split.map(&:to_f)\ngets.to_i.times{\n\tx1,y1,x2,y2=gets.split.map(&:to_f)\n\tif x1==x2\n\t\t#(x1 - cx)^2 + (y - cy)^2 = r^2\n\t\t#y^2 - 2cyy + cy^2 + (x1 - cx)^2 - r^2 = 0\n\t\td=cy**2-(cy**2+(x1-cx)**2-r**2)\n\t\ty=[cy-Math.sqrt(d),cy+Math.sqrt(d)]\n\t\tputs [x1,y[0],x1,y[1]]*' '\n\telse\n\t\ta=(y2-y1)/(x2-x1)\n\t\tb=y1-a*x1\n\t\t#(x - cx)^2 + (ax + b-cy)^2 = r^2\n\t\t#x^2 - 2cxx + cx^2 + (ax)^2 + 2a(b-cy)x + (b-cy)^2 = r^2\n\t\t#(a^2+1)x^2 + (2ab-2acy-2cx)x + cx^2 + (b-cy)^2 - r^2 = 0\n\t\ts=a**2+1\n\t\tt=2*a*b-2*a*cy-2*cx\n\t\tu=cx**2+(b-cy)**2-r**2\n\t\td=t**2-4*s*u\n\t\tx=[(-t-Math.sqrt(d))/2/s,(-t+Math.sqrt(d))/2/s]\n\t\ty=x.map{|e|a*e+b}\n\t\tputs [x[0],y[0],x[1],y[1]]*' '\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ncx,cy,r=gets.split.map(&:to_f)\ngets.to_i.times{\n\tx1,y1,x2,y2=gets.split.map(&:to_f)\n\tif x1==x2\n\t\t#(x1 - cx)^2 + (y - cy)^2 = r^2\n\t\t#y^2 - 2cyy + cy^2 + (x1 - cx)^2 - r^2 = 0\n\t\td=cy**2-(cy**2+(x1-cx)**2-r**2)\n\t\ty=[cy-Math.sqrt(d),cy+Math.sqrt(d)]\n\t\tputs [x1,y[0],x1,y[1]]*' '\n\telse\n\t\ta=(y2-y1)/(x2-x1)\n\t\tb=y1-a*x1\n\t\t#(x - cx)^2 + (ax + b-cy)^2 = r^2\n\t\t#x^2 - 2cxx + cx^2 + (ax)^2 + 2a(b-cy)x + (b-cy)^2 = r^2\n\t\t#(a+1)x^2 + (2ab-2acy-2cx)x + cx^2 + (b-cy)^2 - r^2 = 0\n\t\ts=a+1\n\t\tt=2*a*b-2*a*cy-2*cx\n\t\tu=cx**2+(b-cy)**2-r**2\n\t\td=t**2-4*s*u\n\t\texit if d<0\n\t\tx=[(-t-Math.sqrt(d))/2/s,(-t+Math.sqrt(d))/2/s]\n\t\ty=x.map{|e|a*e+b}\n\t\tputs [x[0],y[0],x[1],y[1]]*' '\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ncx,cy,r=gets.split.map(&:to_f)\ngets.to_i.times{\n\tx1,y1,x2,y2=gets.split.map(&:to_f)\n\tif x1==x2\n\t\t#(x1 - cx)^2 + (y - cy)^2 = r^2\n\t\t#y^2 - 2cyy + cy^2 + (x1 - cx)^2 - r^2 = 0\n\t\td=cy**2-(cy**2+(x1-cx)**2-r**2)\n\t\ty=[cy-Math.sqrt(d),cy+Math.sqrt(d)]\n\t\tputs [x1,y[0],x1,y[1]]*' '\n\telse\n\t\ta=(y2-y1)/(x2-x1)\n\t\tb=y1-a*x1\n\t\t#(x - cx)^2 + (ax + b-cy)^2 = r^2\n\t\t#x^2 - 2cxx + cx^2 + (ax)^2 + 2a(b-cy)x + (b-cy)^2 = r^2\n\t\t#(a+1)x^2 + (2ab-2acy-2cx)x + cx^2 + (b-cy)^2 - r^2 = 0\n\t\ts=a+1\n\t\tt=2*a*b-2*a*cy-2*cx\n\t\tu=cx**2+(b-cy)**2-r**2\n\t\td=t**2-4*s*u\n\t\td=0 if d<0\n\t\tx=[(-t-Math.sqrt(d))/2/s,(-t+Math.sqrt(d))/2/s]\n\t\ty=x.map{|e|a*e+b}\n\t\tputs [x[0],y[0],x[1],y[1]]*' '\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\n\ncx, cy, r = gets.split.map &:to_i\nc = Vector[ cx, cy ]\nq = gets.to_i\nq.times do\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  p0 = Vector[ x1, y1 ]\n  p1 = Vector[ x2, y2 ]\n  p0pr_norm = (c - p0).inner_product(p1 - p0).abs / (p1 - p0).norm\n  p0p1_base = (p1 - p0) / (p1 - p0).norm\n  pr = p0 + p0p1_base * p0pr_norm\n  x = ( r**2 - (c - pr).norm**2 ) ** (1/2.0)\n  i1 = pr - p0p1_base * x\n  i2 = pr + p0p1_base * x\n  puts \"%.6f %.6f %.6f %.6f\" % [ i1[0], i1[1], i2[0], i2[1] ]\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/cmplx\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n\treturn scanner\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextUint64(scanner *bufio.Scanner) uint64 {\n\ti, _ := strconv.ParseUint(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\tcnt := 0\n\tif os.Getenv(\"MASPY\") == \"ますピ\" {\n\t\tfp, _ = os.Open(os.Getenv(\"BEET_THE_HARMONY_OF_PERFECT\"))\n\t\tcnt = 1\n\t}\n\tif os.Getenv(\"MASPYPY\") == \"ますピッピ\" {\n\t\twfp, _ = os.Create(os.Getenv(\"NGTKANA_IS_GENIUS10\"))\n\t}\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(wfp)\n\tsolve(scanner, writer)\n\tfor i := 0; i < cnt; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n\twriter.Flush()\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tcx := getNextFloat64(scanner)\n\tcy := getNextFloat64(scanner)\n\tr := getNextFloat64(scanner)\n\n\tq := getNextInt(scanner)\n\tfor i := 0; i < q; i++ {\n\t\tx1 := getNextFloat64(scanner)\n\t\ty1 := getNextFloat64(scanner)\n\t\tx2 := getNextFloat64(scanner)\n\t\ty2 := getNextFloat64(scanner)\n\t\ts := complex(x2-x1, y2-y1)\n\t\t_, th := cmplx.Polar(s)\n\t\tv := rotate(complex(cx-x1, cy-y1), -th)\n\t\tl := 0.0\n\t\tif compare(cmplx.Abs(complex(0, imag(v))), r) != 0 {\n\t\t\tl = math.Sqrt(math.Max(0, (r+imag(v))*(r-imag(v))))\n\t\t}\n\t\tv1 := rotate(complex(real(v)+l, 0), th)\n\t\tv2 := rotate(complex(real(v)-l, 0), th)\n\t\tswitch compare(real(v1), real(v2)) {\n\t\tcase 0:\n\t\t\tif compare(imag(v1), imag(v2)) == 1 {\n\t\t\t\tv1, v2 = v2, v1\n\t\t\t}\n\t\tcase 1:\n\t\t\tv1, v2 = v2, v1\n\t\t}\n\t\tfmt.Fprintln(writer, fmt.Sprintf(\"%.8f %.8f %.8f %.8f\", real(v1)+x1, imag(v1)+y1, real(v2)+x1, imag(v2)+y1))\n\t}\n}\nfunc compare(a, b float64) int {\n\teps := 1e-10\n\tif a-b > eps {\n\t\treturn 1\n\t}\n\tif b-a > eps {\n\t\treturn -1\n\t}\n\treturn 0\n}\nfunc rotate(v complex128, theta float64) complex128 {\n\tr, th := cmplx.Polar(v)\n\tth += theta\n\treturn cmplx.Rect(r, th)\n}\nfunc degToRad(deg float64) float64 {\n\treturn deg * math.Pi / 180.0\n}\nfunc radTodeg(rad float64) float64 {\n\treturn rad * 180.0 / math.Pi\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"strings\"\n\t\"bufio\"\n\t\"strconv\"\n\t\"math\"\n\t\"fmt\"\n\t\"os\"\n)\n\n//\nfunc subVector(p1, p2 []float64) []float64 {\n\treturn []float64{\n\t\tp1[0] - p2[0],\n\t\tp1[1] - p2[1],\n\t}\n}\n\n//\nfunc dotVector(p1, p2 []float64) float64 {\n\treturn p1[0]*p2[0] + p1[1]*p2[1]\n}\n\n//\nfunc crossVector(p1, p2 []float64) float64 {\n\treturn p1[0]*p2[1] - p1[1]*p2[0]\n}\n\n//\nfunc absVector(p []float64) float64 {\n\treturn math.Sqrt(p[0]*p[0] + p[1]*p[1])\n}\n\n//\nfunc norrmalize(p []float64) float64 {\n\treturn p[0]*p[0] + p[1]*p[1]\n}\n\n//\n// 1: p1-p2より反時計周り側にp3\n// 2: p1-p2より時計周り側にp3\n// 3: p1-p2直線上、p2の先にp3\n// 4: p1-p2直線上、p1の前にp3\n// 5: p1-p2線分上にp3\nfunc checkClockWise(p1, p2, p3 []float64) int {\n\tp1p2 := subVector(p2, p1)\n\tp1p3 := subVector(p3, p1)\n\tif crossVector(p1p2, p1p3) > 0 {\n\t\treturn 1\n\t} else if crossVector(p1p2, p1p3) < 0 {\n\t\treturn 2\n\t} else if dotVector(p1p2, p1p3) < 0 {\n\t\treturn 4\n\t} else if norrmalize(p1p2) < norrmalize(p1p3) {\n\t\treturn 3\n\t}\n\treturn 5\n}\n\nfunc strSliceToFloat64(strSlice []string) []float64 {\n\tn := len(strSlice)\n\tsliceFloat := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tv, _ := strconv.Atoi(strSlice[i])\n\t\tsliceFloat[i] = float64(v)\n\t}\n\treturn sliceFloat\n}\n\nfunc projection(p1, p2, p []float64) []float64 {\n\t// p - p1\n\tv1 := []float64{\n\t\tp[0] - p1[0],\n\t\tp[1] - p1[1],\n\t}\n\t// p2 - p1\n\tv2 := []float64{\n\t\tp2[0] - p1[0],\n\t\tp2[1] - p1[1],\n\t}\n\n\tdot := v1[0]*v2[0] + v1[1]*v2[1]\n\t// cross := v1[0]*v2[1] - v1[1]*v2[0]\n\tnormal := v2[0]*v2[0] + v2[1]*v2[1]\n\n\ta := dot / normal\n\n\tresult := []float64{\n\t\tp1[0] + v2[0]*a,\n\t\tp1[1] + v2[1]*a,\n\t}\n\treturn result\n}\n\nfunc reflection(p1, p2, p []float64) []float64 {\n\tprj := projection(p1, p2, p)\n\n\t// p to reflection\n\ttoCrossPoint := []float64{\n\t\t2 * (prj[0] - p[0]),\n\t\t2 * (prj[1] - p[1]),\n\t}\n\n\tresult := []float64{\n\t\tp[0] + toCrossPoint[0],\n\t\tp[1] + toCrossPoint[1],\n\t}\n\n\treturn result\n}\n\n//\nfunc distancePoint(p1, p2 []float64) float64 {\n\treturn absVector(subVector(p2, p1))\n}\n\n//\nfunc distanceToStraightLine(p1, p2, p []float64) float64 {\n\tv1 := subVector(p, p1)\n\tv2 := subVector(p2, p1)\n\treturn math.Abs(crossVector(v1, v2)) / absVector(v2)\n}\n\n//\nfunc distanceToLineSegment(p1, p2, p []float64) float64 {\n\tv1 := subVector(p1, p2)\n\tv2 := subVector(p2, p1)\n\n\tif dotVector(subVector(p, p1), v2) <= 0 {\n\t\treturn distancePoint(p1, p)\n\t} else if dotVector(subVector(p, p2), v1) <= 0 {\n\t\treturn distancePoint(p2, p)\n\t}\n\treturn distanceToStraightLine(p1, p2, p)\n}\n\n//\nfunc distanceLineSegment(a1, a2, b1, b2 []float64) float64 {\n\tif isInterSect(a1, a2, b1, b2) {\n\t\treturn 0.0\n\t}\n\tresult := distanceToLineSegment(a1, a2, b1)\n\tresult = math.Min(result, distanceToLineSegment(a1, a2, b2))\n\tresult = math.Min(result, distanceToLineSegment(b1, b2, a1))\n\tresult = math.Min(result, distanceToLineSegment(b1, b2, a2))\n\treturn result\n}\n\n//\nfunc isInterSect(a1, a2, b1, b2 []float64) bool {\n\tc1 := checkClockWise(a1, a2, b1)\n\tc2 := checkClockWise(a1, a2, b2)\n\n\tc3 := checkClockWise(b1, b2, a1)\n\tc4 := checkClockWise(b1, b2, a2)\n\n\tconv := func(v int) int {\n\t\tif v == 2 {\n\t\t\treturn -1\n\t\t} else if v == 5 {\n\t\t\treturn 0\n\t\t} else if v == 4 {\n\t\t\treturn -1\n\t\t}\n\t\treturn v\n\t}\n\n\tc1 = conv(c1)\n\tc2 = conv(c2)\n\tc3 = conv(c3)\n\tc4 = conv(c4)\n\n\tisInterSect := (c1*c2) <= 0 && (c3*c4) <= 0\n\treturn isInterSect\n}\n\n//\nfunc segmentCrossPoint(a1, a2, b1, b2 []float64) []float64 {\n\td1 := math.Abs(crossVector(subVector(a2, a1), subVector(b1, a1))) / absVector(subVector(a2, a1))\n\td2 := math.Abs(crossVector(subVector(a1, a2), subVector(b2, a2))) / absVector(subVector(a1, a2))\n\n\tratio := d1 / (d1 + d2)\n\tv := subVector(b2, b1)\n\tresult := []float64{\n\t\tb1[0] + ratio*v[0],\n\t\tb1[1] + ratio*v[1],\n\t}\n\treturn result\n}\n\n// test\nfunc Test_solve() {\n\tinput := `\n\n\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\n`\n\tinput = strings.Trim(input, \"\\n\")\n\n\tsolve(bufio.NewScanner(strings.NewReader(input)))\n}\n\n// solve\nfunc solve(sc *bufio.Scanner) {\n\tsc.Scan()\n\tcircle := strSliceToFloat64(strings.Split(sc.Text(), \" \"))\n\tcenter := []float64{\n\t\tcircle[0],\n\t\tcircle[1],\n\t}\n\tr := circle[2]\n\n\tsc.Scan()\n\tn, _ := strconv.Atoi(sc.Text())\n\n\tfor i := 0; i < n; i++ {\n\t\tsc.Scan()\n\t\tslice := strSliceToFloat64(strings.Split(sc.Text(), \" \"))\n\n\t\tp1 := []float64{slice[0], slice[1]}\n\t\tp2 := []float64{slice[2], slice[3]}\n\n\t\tprj := projection(p1, p2, center)\n\n\t\td := absVector(subVector(prj, center))\n\t\ta := math.Sqrt(r*r - d*d)\n\n\t\tp1p2 := subVector(p2, p1)\n\t\tabsP1p2 := absVector(p1p2)\n\t\te := []float64{\n\t\t\tp1p2[0] / absP1p2,\n\t\t\tp1p2[1] / absP1p2,\n\t\t}\n\n\t\tresult := make([][]float64, 2)\n\t\tresult[0] = []float64{\n\t\t\tprj[0] + a*e[0],\n\t\t\tprj[1] + a*e[1],\n\t\t}\n\t\tresult[1] = []float64{\n\t\t\tprj[0] - a*e[0],\n\t\t\tprj[1] - a*e[1],\n\t\t}\n\n\t\ti := 1\n\t\tif result[0][0] > result[1][0] {\n\t\t\ti = 0\n\t\t} else if (result[0][0] == result[1][0]) {\n\t\t    if result[0][1] > result[1][1] {\n\t\t        i = 0\n\t\t    }\n\t\t}\n\t\tfmt.Printf(\"%.10f %.10f %.10f %.10f\\n\", result[1-i][0], result[1-i][1], result[i][0], result[i][1])\n\t}\n}\n\n// main\nfunc main() {\n\n\t//Test_solve()\n\tsolve(bufio.NewScanner(os.Stdin))\n}\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\nfrom operator import attrgetter\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, x, y, r):\n        self.centre = x + y * 1j\n        self.radius = r\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    return prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cross_pair = get_cross_point(circle, l)\n        cp1, cp2 = sorted(cross_pair, key=attrgetter('real'))\n        print('{0:.6f} {1:.6f} {2:.6f} {3:.6f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, radius = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx, cy, radius)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = math.sqrt(r*r-(abs(pro-p2)**2))\n  if pro-e*base.real == pro+e*base.real:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.imag)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.imag)\n  else:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.real)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.real)\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.8} {:.8} {:.8} {:.8}\".format(*get_cross_point(p0,p1,p2)))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef intersection_cl(S0, S1, C0, r):\n    x0, y0 = S0; x1, y1 = S1\n    cx, cy = C0\n\n    xd = x1 - x0; yd = y1 - y0\n    X = x0 - cx; Y = y0 - cy\n    A = xd**2 + yd**2\n    B = xd*X + yd*Y\n    C = X**2 + Y**2 - r**2\n    if B**2 < A*C:\n        # ?§£??????\n        return tuple()\n    \"\"\"\n    if B**2 == A*C:\n        # ????????????\n        s = -B / float(A)\n        return tuple((x0 + xd*s, y0 + yd*s))\n    \"\"\"\n    # ??????\n    D = B**2 - A*C\n    s1 = (-B + sqrt(D)) / A\n    s2 = (-B - sqrt(D)) / A\n    return ((x0 + xd*s1, y0 + yd*s1), (x0 + xd*s2, y0 + yd*s2))\n\ncx, cy, r = map(int, input().split())\nq = int(input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(int, input().split())\n\n    p0, p1 = sorted(intersection_cl((x1, y1), (x2, y2), (cx, cy), r))\n    print(\"%.08f %.08f %.08f %.08f\" % (p0 + p1))"
  },
  {
    "language": "Python",
    "code": "def solve_eq(a,b,c):\n    return (-b-(b**2-4*a*c)**0.5)/2*a,(-b+(b**2-4*a*c)**0.5)/2*a\n\ndef ret_line(x1,y1,x2,y2):\n    k = (y1-y2)/(x1-x2)\n    d = y1-k*x1\n    return k,d\n    \nx,y,r = map(float,input().split())\nq = int(input())\nx1,y1,x2,y2 = [],[],[],[]\nfor i in range(q):\n    arr = list(map(float,input().split()))\n    x1.append(arr[0])\n    y1.append(arr[1])\n    x2.append(arr[2])\n    y2.append(arr[3])\n\nfor i in range(q):\n    if x1[i] != x2[i]:\n        k,d = ret_line(x1[i],y1[i],x2[i],y2[i])\n        p1,p2 = solve_eq(1+k**2,2*k*d-2*k*x-2*x,x**2+y**2+d**2-2*y*d-r**2)\n        print(p1,k*p1+d,p2,k*p2+d)\n    if x1[i] == x2[i]:\n        p1,p2 = solve_eq(1,-2*y,y**2+(x1[i]-x)**2-r**2)\n        print(x1[i],p1,x1[i],p2)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, x, y, r):\n        self.centre = x + y * 1j\n        self.radius = r\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    return prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cross_pair = get_cross_point(circle, l)\n        cp1, cp2 = cross_pair\n        print('{0:.6f} {1:.6f} {2:.6f} {3:.6f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, radius = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx, cy, radius)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "import cmath\nimport itertools\nimport math\nimport os\nimport sys\nfrom collections import defaultdict\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nPI = cmath.pi\nTAU = cmath.pi * 2\nEPS = 1e-10\n\n\nclass Point:\n    \"\"\"\n    2次元空間上の点\n    \"\"\"\n\n    # 反時計回り側にある\n    CCW_COUNTER_CLOCKWISE = 1\n    # 時計回り側にある\n    CCW_CLOCKWISE = -1\n    # 線分の後ろにある\n    CCW_ONLINE_BACK = 2\n    # 線分の前にある\n    CCW_ONLINE_FRONT = -2\n    # 線分上にある\n    CCW_ON_SEGMENT = 0\n\n    def __init__(self, c: complex):\n        self.c = c\n\n    @property\n    def x(self):\n        return self.c.real\n\n    @property\n    def y(self):\n        return self.c.imag\n\n    @staticmethod\n    def from_rect(x: float, y: float):\n        return Point(complex(x, y))\n\n    @staticmethod\n    def from_polar(r: float, phi: float):\n        return Point(cmath.rect(r, phi))\n\n    def __add__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c + p.c)\n\n    def __iadd__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c += p.c\n        return self\n\n    def __sub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c - p.c)\n\n    def __isub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c -= p.c\n        return self\n\n    def __mul__(self, f: float):\n        return Point(self.c * f)\n\n    def __imul__(self, f: float):\n        self.c *= f\n        return self\n\n    def __truediv__(self, f: float):\n        return Point(self.c / f)\n\n    def __itruediv__(self, f: float):\n        self.c /= f\n        return self\n\n    def __repr__(self):\n        return \"({}, {})\".format(round(self.x, 10), round(self.y, 10))\n\n    def __neg__(self):\n        return Point(-self.c)\n\n    def __eq__(self, p):\n        return abs(self.c - p.c) < EPS\n\n    def __abs__(self):\n        return abs(self.c)\n\n    @staticmethod\n    def ccw(a, b, c):\n        \"\"\"\n        線分 ab に対する c の位置\n        線分上にあるか判定するだけなら on_segment とかのが速い\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point a:\n        :param Point b:\n        :param Point c:\n        \"\"\"\n        b = b - a\n        c = c - a\n        det = b.det(c)\n        if det > EPS:\n            return Point.CCW_COUNTER_CLOCKWISE\n        if det < -EPS:\n            return Point.CCW_CLOCKWISE\n        if b.dot(c) < -EPS:\n            return Point.CCW_ONLINE_BACK\n        if c.norm() - b.norm() > EPS:\n            return Point.CCW_ONLINE_FRONT\n        return Point.CCW_ON_SEGMENT\n\n    def dot(self, p):\n        \"\"\"\n        内積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.x + self.y * p.y\n\n    def det(self, p):\n        \"\"\"\n        外積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.y - self.y * p.x\n\n    def dist(self, p):\n        \"\"\"\n        距離\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return abs(self.c - p.c)\n\n    def norm(self):\n        \"\"\"\n        原点からの距離\n        :rtype: float\n        \"\"\"\n        return abs(self.c)\n\n    def phase(self):\n        \"\"\"\n        原点からの角度\n        :rtype: float\n        \"\"\"\n        return cmath.phase(self.c)\n\n    def angle(self, p, q):\n        \"\"\"\n        p に向いてる状態から q まで反時計回りに回転するときの角度\n        -pi <= ret <= pi\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return (cmath.phase(q.c - self.c) - cmath.phase(p.c - self.c) + PI) % TAU - PI\n\n    def area(self, p, q):\n        \"\"\"\n        p, q となす三角形の面積\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return abs((p - self).det(q - self) / 2)\n\n    def projection_point(self, p, q, allow_outer=False):\n        \"\"\"\n        線分 pq を通る直線上に垂線をおろしたときの足の座標\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_outer: 答えが線分の間になくても OK\n        :rtype: Point|None\n        \"\"\"\n        diff_q = q - p\n        # 答えの p からの距離\n        r = (self - p).dot(diff_q) / abs(diff_q)\n        # 線分の角度\n        phase = diff_q.phase()\n\n        ret = Point.from_polar(r, phase) + p\n        if allow_outer or (p - ret).dot(q - ret) < EPS:\n            return ret\n        return None\n\n    def reflection_point(self, p, q):\n        \"\"\"\n        直線 pq を挟んで反対にある点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\n        :param Point p:\n        :param Point q:\n        :rtype: Point\n        \"\"\"\n        # 距離\n        r = abs(self - p)\n        # pq と p-self の角度\n        angle = p.angle(q, self)\n        # 直線を挟んで角度を反対にする\n        angle = (q - p).phase() - angle\n        return Point.from_polar(r, angle) + p\n\n    def on_segment(self, p, q, allow_side=True):\n        \"\"\"\n        点が線分 pq の上に乗っているか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        :rtype: bool\n        \"\"\"\n        if not allow_side and (self == p or self == q):\n            return False\n        # 外積がゼロ: 面積がゼロ == 一直線\n        # 内積がマイナス: p - self - q の順に並んでる\n        return abs((p - self).det(q - self)) < EPS and (p - self).dot(q - self) < EPS\n\n\nclass Line:\n    \"\"\"\n    2次元空間上の直線\n    \"\"\"\n\n    def __init__(self, a: float, b: float, c: float):\n        \"\"\"\n        直線 ax + by + c = 0\n        \"\"\"\n        self.a = a\n        self.b = b\n        self.c = c\n\n    @staticmethod\n    def from_gradient(grad: float, intercept: float):\n        \"\"\"\n        直線 y = ax + b\n        :param grad: 傾き\n        :param intercept: 切片\n        :return:\n        \"\"\"\n        return Line(grad, -1, intercept)\n\n    @staticmethod\n    def from_segment(p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        a = p2.y - p1.y\n        b = p1.x - p2.x\n        c = p2.y * (p2.x - p1.x) - p2.x * (p2.y - p1.y)\n        return Line(a, b, c)\n\n    @property\n    def gradient(self):\n        \"\"\"\n        傾き\n        \"\"\"\n        return INF if self.b == 0 else -self.a / self.b\n\n    @property\n    def intercept(self):\n        \"\"\"\n        切片\n        \"\"\"\n        return INF if self.b == 0 else -self.c / self.b\n\n    def is_parallel_to(self, l):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の外積がゼロ\n        return abs(Point.from_rect(self.a, self.b).det(Point.from_rect(l.a, l.b))) < EPS\n\n    def is_orthogonal_to(self, l):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の内積がゼロ\n        return abs(Point.from_rect(self.a, self.b).dot(Point.from_rect(l.a, l.b))) < EPS\n\n    def intersection_point(self, l):\n        \"\"\"\n        交差する点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\n        :param Line l:\n        :rtype: Point|None\n        \"\"\"\n        a1, b1, c1 = self.a, self.b, self.c\n        a2, b2, c2 = l.a, l.b, l.c\n        det = a1 * b2 - a2 * b1\n        if abs(det) < EPS:\n            # 並行\n            return None\n        x = (b1 * c2 - b2 * c1) / det\n        y = (a2 * c1 - a1 * c2) / det\n        return Point.from_rect(x, y)\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        raise NotImplementedError()\n\n    def has_point(self, p):\n        \"\"\"\n        p が直線上に乗っているかどうか\n        :param Point p:\n        \"\"\"\n        return abs(self.a * p.x + self.b * p.y + self.c) < EPS\n\n\nclass Segment:\n    \"\"\"\n    2次元空間上の線分\n    \"\"\"\n\n    def __init__(self, p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        self.p1 = p1\n        self.p2 = p2\n\n    def norm(self):\n        \"\"\"\n        線分の長さ\n        \"\"\"\n        return abs(self.p1 - self.p2)\n\n    def phase(self):\n        \"\"\"\n        p1 を原点としたときの p2 の角度\n        \"\"\"\n        return (self.p2 - self.p1).phase()\n\n    def is_parallel_to(self, s):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Segment s:\n        :return:\n        \"\"\"\n        # 外積がゼロ\n        return abs((self.p1 - self.p2).det(s.p1 - s.p2)) < EPS\n\n    def is_orthogonal_to(self, s):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Segment s:\n        :return:\n        \"\"\"\n        # 内積がゼロ\n        return abs((self.p1 - self.p2).dot(s.p1 - s.p2)) < EPS\n\n    def intersects_with(self, s, allow_side=True):\n        \"\"\"\n        交差するかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\n        :param Segment s:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        if self.is_parallel_to(s):\n            # 並行なら線分の端点がもう片方の線分の上にあるかどうか\n            return (s.p1.on_segment(self.p1, self.p2, allow_side) or\n                    s.p2.on_segment(self.p1, self.p2, allow_side) or\n                    self.p1.on_segment(s.p1, s.p2, allow_side) or\n                    self.p2.on_segment(s.p1, s.p2, allow_side))\n        else:\n            # allow_side ならゼロを許容する\n            det_upper = EPS if allow_side else -EPS\n            ok = True\n            # self の両側に s.p1 と s.p2 があるか\n            ok &= (self.p2 - self.p1).det(s.p1 - self.p1) * (self.p2 - self.p1).det(s.p2 - self.p1) < det_upper\n            # s の両側に self.p1 と self.p2 があるか\n            ok &= (s.p2 - s.p1).det(self.p1 - s.p1) * (s.p2 - s.p1).det(self.p2 - s.p1) < det_upper\n            return ok\n\n    def closest_point(self, p):\n        \"\"\"\n        線分上の、p に最も近い点\n        :param Point p:\n        \"\"\"\n        # p からおろした垂線までの距離\n        d = (p - self.p1).dot(self.p2 - self.p1) / self.norm()\n        # p1 より前\n        if d < EPS:\n            return self.p1\n        # p2 より後\n        if -EPS < d - self.norm():\n            return self.p2\n        # 線分上\n        return Point.from_polar(d, (self.p2 - self.p1).phase()) + self.p1\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        return abs(p - self.closest_point(p))\n\n    def dist_segment(self, s):\n        \"\"\"\n        他の線分との最短距離\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\n        :param Segment s:\n        \"\"\"\n        if self.intersects_with(s):\n            return 0.0\n        return min(\n            self.dist(s.p1),\n            self.dist(s.p2),\n            s.dist(self.p1),\n            s.dist(self.p2),\n        )\n\n    def has_point(self, p, allow_side=True):\n        \"\"\"\n        p が線分上に乗っているかどうか\n        :param Point p:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        return p.on_segment(self.p1, self.p2, allow_side=allow_side)\n\n\nclass Polygon:\n    \"\"\"\n    2次元空間上の多角形\n    \"\"\"\n\n    def __init__(self, points):\n        \"\"\"\n        :param list of Point points:\n        \"\"\"\n        self.points = points\n\n    def iter2(self):\n        \"\"\"\n        隣り合う2点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point)]\n        \"\"\"\n        return zip(self.points, self.points[1:] + self.points[:1])\n\n    def iter3(self):\n        \"\"\"\n        隣り合う3点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point, Point)]\n        \"\"\"\n        return zip(self.points,\n                   self.points[1:] + self.points[:1],\n                   self.points[2:] + self.points[:2])\n\n    def area(self):\n        \"\"\"\n        面積\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=ja\n        \"\"\"\n        # 外積の和 / 2\n        dets = []\n        for p, q in self.iter2():\n            dets.append(p.det(q))\n        return abs(math.fsum(dets)) / 2\n\n    def is_convex(self, allow_straight=False, allow_collapsed=False):\n        \"\"\"\n        凸多角形かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=ja\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :param allow_collapsed: 面積がゼロの場合を許容するか\n        \"\"\"\n        ccw = []\n        for a, b, c in self.iter3():\n            ccw.append(Point.ccw(a, b, c))\n        ccw = set(ccw)\n        if len(ccw) == 1:\n            if ccw == {Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_straight and len(ccw) == 2:\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_collapsed and len(ccw) == 3:\n            return ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_ONLINE_BACK, Point.CCW_ON_SEGMENT}\n        return False\n\n    def has_point_on_edge(self, p):\n        \"\"\"\n        指定した点が辺上にあるか\n        :param Point p:\n        :rtype: bool\n        \"\"\"\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return True\n        return False\n\n    def contains(self, p, allow_on_edge=True):\n        \"\"\"\n        指定した点を含むか\n        Winding Number Algorithm\n        https://www.nttpc.co.jp/technology/number_algorithm.html\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\n        :param Point p:\n        :param bool allow_on_edge: 辺上の点を許容するか\n        \"\"\"\n        angles = []\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return allow_on_edge\n            angles.append(p.angle(a, b))\n        # 一周以上するなら含む\n        return abs(math.fsum(angles)) > EPS\n\n    @staticmethod\n    def convex_hull(points, allow_straight=False):\n        \"\"\"\n        凸包。x が最も小さい点のうち y が最も小さい点から反時計回り。\n        Graham Scan O(N log N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\n        :param list of Point points:\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :rtype: list of Point\n        \"\"\"\n        points = points[:]\n        points.sort(key=lambda p: (p.x, p.y))\n\n        # allow_straight なら 0 を許容する\n        det_lower = -EPS if allow_straight else EPS\n\n        sz = 0\n        #: :type: list of (Point|None)\n        ret = [None] * (len(points) * 2)\n        for p in points:\n            while sz > 1 and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        floor = sz\n        for p in reversed(points[:-1]):\n            while sz > floor and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        ret = ret[:sz - 1]\n\n        if allow_straight and len(ret) > len(points):\n            # allow_straight かつ全部一直線のときに二重にカウントしちゃう\n            ret = points\n        return ret\n\n    @staticmethod\n    def diameter(points):\n        \"\"\"\n        直径\n        凸包構築 O(N log N) + カリパー法 O(N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=ja\n        :param list of Point points:\n        \"\"\"\n        # 反時計回り\n        points = Polygon.convex_hull(points, allow_straight=False)\n        if len(points) == 1:\n            return 0.0\n        if len(points) == 2:\n            return abs(points[0] - points[1])\n\n        # x軸方向に最も遠い点対\n        si = points.index(min(points, key=lambda p: (p.x, p.y)))\n        sj = points.index(max(points, key=lambda p: (p.x, p.y)))\n        n = len(points)\n\n        ret = 0.0\n        # 半周回転\n        i, j = si, sj\n        while i != sj or j != si:\n            ret = max(ret, abs(points[i] - points[j]))\n            ni = (i + 1) % n\n            nj = (j + 1) % n\n            # 2つの辺が並行になる方向にずらす\n            if (points[ni] - points[i]).det(points[nj] - points[j]) > 0:\n                j = nj\n            else:\n                i = ni\n        return ret\n\n    def convex_cut_by_line(self, line_p1, line_p2):\n        \"\"\"\n        凸多角形を直線 line_p1-line_p2 でカットする。\n        凸じゃないといけません\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=ja\n        :param line_p1:\n        :param line_p2:\n        :return: (line_p1-line_p2 の左側の多角形, line_p1-line_p2 の右側の多角形)\n        :rtype: (Polygon|None, Polygon|None)\n        \"\"\"\n        n = len(self.points)\n        line = Line.from_segment(line_p1, line_p2)\n        # 直線と重なる点\n        on_line_points = []\n        for i, p in enumerate(self.points):\n            if line.has_point(p):\n                on_line_points.append(i)\n\n        # 辺が直線上にある\n        has_on_line_edge = False\n        if len(on_line_points) >= 3:\n            has_on_line_edge = True\n        elif len(on_line_points) == 2:\n            # 直線上にある点が隣り合ってる\n            has_on_line_edge = abs(on_line_points[0] - on_line_points[1]) in [1, n - 1]\n        # 辺が直線上にある場合、どっちか片方に全部ある\n        if has_on_line_edge:\n            for p in self.points:\n                ccw = Point.ccw(line_p1, line_p2, p)\n                if ccw == Point.CCW_COUNTER_CLOCKWISE:\n                    return Polygon(self.points[:]), None\n                if ccw == Point.CCW_CLOCKWISE:\n                    return None, Polygon(self.points[:])\n\n        ret_lefts = []\n        ret_rights = []\n        d = line_p2 - line_p1\n        for p, q in self.iter2():\n            det_p = d.det(p - line_p1)\n            det_q = d.det(q - line_p1)\n            if det_p > -EPS:\n                ret_lefts.append(p)\n            if det_p < EPS:\n                ret_rights.append(p)\n            # 外積の符号が違う == 直線の反対側にある場合は交点を追加\n            if det_p * det_q < -EPS:\n                intersection = line.intersection_point(Line.from_segment(p, q))\n                ret_lefts.append(intersection)\n                ret_rights.append(intersection)\n\n        # 点のみの場合を除いて返す\n        l = Polygon(ret_lefts) if len(ret_lefts) > 1 else None\n        r = Polygon(ret_rights) if len(ret_rights) > 1 else None\n        return l, r\n\n\ndef closest_pair(points):\n    \"\"\"\n    最近点対 O(N log N)\n    Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\n    :param list of Point points:\n    :rtype: (float, (Point, Point))\n    :return: (距離, 点対)\n    \"\"\"\n    assert len(points) >= 2\n\n    def _rec(xsorted):\n        \"\"\"\n        :param list of Point xsorted:\n        :rtype: (float, (Point, Point))\n        \"\"\"\n        n = len(xsorted)\n        if n <= 2:\n            return xsorted[0].dist(xsorted[1]), (xsorted[0], xsorted[1])\n        if n <= 3:\n            # 全探索\n            d = INF\n            pair = None\n            for p, q in itertools.combinations(xsorted, r=2):\n                if p.dist(q) < d:\n                    d = p.dist(q)\n                    pair = p, q\n            return d, pair\n\n        # 分割統治\n        # 両側の最近点対\n        ld, lp = _rec(xsorted[:n // 2])\n        rd, rp = _rec(xsorted[n // 2:])\n        if ld <= rd:\n            d = ld\n            ret_pair = lp\n        else:\n            d = rd\n            ret_pair = rp\n\n        mid_x = xsorted[n // 2].x\n        # 中央から d 以内のやつを集める\n        mid_points = []\n        for p in xsorted:\n            # if abs(p.x - mid_x) < d:\n            if abs(p.x - mid_x) - d < -EPS:\n                mid_points.append(p)\n\n        # この中で距離が d 以内のペアがあれば更新\n        mid_points.sort(key=lambda p: p.y)\n        mid_n = len(mid_points)\n        for i in range(mid_n - 1):\n            j = i + 1\n            p = mid_points[i]\n            q = mid_points[j]\n            # while q.y - p.y < d\n            while (q.y - p.y) - d < -EPS:\n                pq_d = p.dist(q)\n                if pq_d < d:\n                    d = pq_d\n                    ret_pair = p, q\n                j += 1\n                if j >= mid_n:\n                    break\n                q = mid_points[j]\n        return d, ret_pair\n\n    return _rec(list(sorted(points, key=lambda p: p.x)))\n\n\ndef closest_pair_randomized(points):\n    \"\"\"\n    最近点対 乱択版 O(N)\n    http://ir5.hatenablog.com/entry/20131221/1387557630\n    グリッドの管理が dict だから定数倍気になる\n    Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\n    :param list of Point points:\n    :rtype: (float, (Point, Point))\n    :return: (距離, 点対)\n    \"\"\"\n    n = len(points)\n    assert n >= 2\n    if n == 2:\n        return points[0].dist(points[1]), (points[0], points[1])\n\n    # 逐次構成法\n    import random\n    points = points[:]\n    random.shuffle(points)\n\n    DELTA_XY = list(itertools.product([-1, 0, 1], repeat=2))\n    grid = defaultdict(list)\n    delta = INF\n    dist = points[0].dist(points[1])\n    ret_pair = points[0], points[1]\n    for i in range(2, n):\n        if delta < EPS:\n            return 0.0, ret_pair\n        # i 番目より前までを含む grid を構築\n        # if dist < delta:\n        if dist - delta < -EPS:\n            delta = dist\n            grid = defaultdict(list)\n            for a in points[:i]:\n                grid[a.x // delta, a.y // delta].append(a)\n        else:\n            p = points[i - 1]\n            grid[p.x // delta, p.y // delta].append(p)\n\n        p = points[i]\n        dist = delta\n        grid_x = p.x // delta\n        grid_y = p.y // delta\n        # 周り 9 箇所だけ調べれば OK\n        for dx, dy in DELTA_XY:\n            for q in grid[grid_x + dx, grid_y + dy]:\n                d = p.dist(q)\n                # if d < dist:\n                if d - dist < -EPS:\n                    dist = d\n                    ret_pair = p, q\n    return min(delta, dist), ret_pair\n\n\nclass Circle:\n    def __init__(self, o, r):\n        \"\"\"\n        :param Point o:\n        :param float r:\n        \"\"\"\n        self.o = o\n        self.r = r\n\n    def __eq__(self, other):\n        return self.o == other.o and abs(self.r - other.r) < EPS\n\n    def ctc(self, c):\n        \"\"\"\n        共通接線 common tangent の数\n        4: 離れてる\n        3: 外接\n        2: 交わってる\n        1: 内接\n        0: 内包\n        inf: 同一\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=ja\n        :param Circle c:\n        :rtype: int\n        \"\"\"\n        if self.o == c.o:\n            return INF if abs(self.r - c.r) < EPS else 0\n        # 円同士の距離\n        d = self.o.dist(c.o) - self.r - c.r\n        if d > EPS:\n            return 4\n        elif d > -EPS:\n            return 3\n        # elif d > -min(self.r, c.r) * 2:\n        elif d + min(self.r, c.r) * 2 > EPS:\n            return 2\n        elif d + min(self.r, c.r) * 2 > -EPS:\n            return 1\n        return 0\n\n    def area(self):\n        \"\"\"\n        面積\n        \"\"\"\n        return self.r ** 2 * PI\n\n    def intersection_point(self, s, allow_outer=False):\n        \"\"\"\n        線分と交差する点のリスト\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=ja\n        :param Segment s:\n        :param allow_outer: 線分の間にない点を含む\n        :rtype: list of Point\n        \"\"\"\n        # 線分との距離\n        projection_point = self.o.projection_point(s.p1, s.p2, allow_outer=True)\n        dist = self.o.dist(projection_point)\n        # if dist > self.r:\n        if dist - self.r > EPS:\n            return []\n        elif dist - self.r > -EPS:\n            if allow_outer or s.has_point(projection_point):\n                return [projection_point]\n            else:\n                return []\n        diff = Point.from_polar(math.sqrt(self.r ** 2 - dist ** 2), s.phase())\n        ret1 = projection_point + diff\n        ret2 = projection_point - diff\n        ret = []\n        if allow_outer or s.has_point(ret1):\n            ret.append(ret1)\n        if allow_outer or s.has_point(ret2):\n            ret.append(ret2)\n        return ret\n\n\nx, y, r = list(map(int, sys.stdin.buffer.readline().split()))\nQ = int(sys.stdin.buffer.readline())\nLINES = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(Q)]\n\n\ndef round_point(p):\n    \"\"\"\n    8桁で四捨五入して、-0を0に変換する\n    :param p:\n    :return:\n    \"\"\"\n    return round(p.x, 8) + 0, round(p.y, 8) + 0\n\n\ncircle = Circle(Point(complex(x, y)), r)\nfor x1, y1, x2, y2 in LINES:\n    ans = circle.intersection_point(Segment(Point(complex(x1, y1)), Point(complex(x2, y2))), allow_outer=True)\n    if len(ans) == 1:\n        x, y = round_point(ans[0])\n        print('{:.8f} {:.8f} {:.8f} {:.8f}'.format(x, y, x, y))\n    elif len(ans) == 2:\n        (x1, y1), (x2, y2) = list(sorted(map(round_point, ans)))\n        print('{:.8f} {:.8f} {:.8f} {:.8f}'.format(x1, y1, x2, y2))\n    else:\n        assert False\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2*b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n\n        if XA < 1e-6: XA = 0\n        if YA < 1e-6: YA = 0\n        if XB < 1e-6: XB = 0\n        if YB < 1e-6: YB = 0\n            \n        print \"%.6f %.6f %.6f %.6f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1 - y2) / (x1 - x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1 - x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        if XA < 1e-6: XA = 0\n        if YA < 1e-6: YA = 0\n        if XB < 1e-6: XB = 0\n        if YB < 1e-6: YB = 0\n        \n        if XA == XB and YA > YB:\n            print \"%.6f %.6f %.6f %.6f\" % (XB, YB, XA, YA)\n        else:\n            print \"%.6f %.6f %.6f %.6f\" % (XA, YA, XB, YB)"
  },
  {
    "language": "Python",
    "code": "import math\n\nEPS = 1e-10\n\ndef equals(a, b):\n    return abs(a - b) < EPS\n\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __add__(self, p):\n        return Point(self.x + p.x, self.y + p.y)\n\n    def __sub__(self, p):\n        return Point(self.x - p.x, self.y - p.y)\n\n    def __mul__(self, a):\n        return Point(self.x * a, self.y * a)\n\n    def __rmul__(self, a):\n        return self * a\n\n    def __truediv__(self, a):\n        return Point(self.x / a, self.y / a)\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        return math.sqrt(self.norm())\n\n    def __lt__(self, p):\n        if self.x != p.x:\n            return self. x < p.x\n        else:\n            return self.y < p.y\n\n    def __eq__(self, p):\n        return equals(self.x, p.x) and equals(self.y, p.y)\n\n\nclass Segment:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n\nclass Circle:\n    def __init__(self, c=Point(), r=0):\n        self.c = c\n        self.r = r\n\n\ndef dot(a, b):\n    return a.x * b.x + a.y * b.y\n\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\n\ndef project(s, p):\n    base = s.p2 - s.p1\n    r = dot(p - s.p1, base) / base.norm()\n    return s.p1 + base * r\n\n\ndef getCrossPoint(c, l):\n    pr = project(l, c.c)\n    e = (l.p2 - l.p1) / (l.p2 - l.p1).abs()\n    base = math.sqrt(c.r * c.r - (pr - c.c).norm())\n    return (pr + e * base, pr - e * base)\n\n\nif __name__ == '__main__':\n    cx, cy, r =  [int(v) for v in input().split()]\n    c = Circle(Point(cx, cy), r)\n    q = int(input())\n    ans = []\n    for i in range(q):\n        x1, y1, x2, y2 = [int(v) for v in input().split()]\n        l = Segment(Point(x1, y1), Point(x2, y2))\n        v1, v2 = getCrossPoint(c, l)\n        if v2 < v1:\n            v1, v2 = v2, v1\n        ans.append([v1.x, v1.y, v2.x, v2.y])\n\n    for v in ans:\n        print('{0[0]:.8f} {0[1]:.8f} {0[2]:.8f} {0[3]:.8f}'.format(v))\n"
  },
  {
    "language": "Python",
    "code": "cx, cy, r = map(int, input().split())\nq = int(input())\n\nfor _ in range(q):\n  x1,y1,x2,y2 = map(int,input().split())\n  dx, dy = x2 - x1, y2 - y1\n  px, py = cx - x1, cy - y1\n  s2 = dx **2 + dy **2\n  dot = dx*px + dy*py\n  crs = dx * py - dy * px\n  t1 = (dot + (s2 * r ** 2 - crs ** 2) **0.5)/s2\n  t2 = (dot -(s2 * r ** 2 -crs ** 2) ** 0.5)/s2\n  if (dx < 0 or (dx == 0 and dy < 0 )) ^ (t1 > t2):\n    t1,t2 = t2,t1\n  print(x1+dx*t1, y1+dy*t1,x1+dx*t2,y1+dy*t2)\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = (r**2 - abs(pro-p2)**2)**0.5\n  if pro-e*base.real == pro+e*base.real:\n    if (pro-e*base).imag < (pro+e*base).imag:\n      ans1=pro-e*base\n      ans2=pro+e*base\n    else:\n      ans1=pro+e*base\n      ans2=pro-e*base\n  elif (pro-e*base).real < (pro+e*base).real:\n    ans1=pro-e*base\n    ans2=pro+e*base\n    # print('a')\n  else:\n    ans2=pro+e*base\n    ans1=pro-e*base\n    # print('i')\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(*get_cross_point(p0,p1,p2)))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nclass Vector2():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector2(self.x+v.x, self.y+v.y)\n\n    def __sub__(self, v):\n        return Vector2(self.x-v.x, self.y-v.y)\n\n    def __mul__(self, v):\n        return Vector2(self.x*v, self.y*v)\n\n    def __truediv__(self, v):\n        return Vector2(self.x/v, self.y/v)\n\n    def __abs__(self):\n        return math.sqrt(float(self.x*self.x+self.y*self.y))\n\n    def __str__(self):\n        return f\"({self.x},{self.y})\"\n\n    def __lt__(self, v):\n        if math.isclose(self.x, v.x):\n            return self.y < v.y\n        return self.x < v.x\n\n    def dot(self, v):\n        return self.x*v.x+self.y*v.y\n\n    def cross(self, v):\n        return self.x*v.y-self.y*v.x\n\n    def norm(self):\n        d = abs(self)\n        return Vector2(self.x/d, self.y/d)\n\n\ndef projection(v1, v2, p):\n    v12 = (v2-v1).norm()\n    v1p = p-v1\n    d = v12.dot(v1p)\n    return v1+v12*d\n\n\ndef distanceLP(v1, v2, p):\n    '''\n    v1 -> v2の直線とpとの距離\n    '''\n    return abs((v2-v1).cross(p-v1))/abs(v2-v1)\n\n\ndef distanceSP(v1, v2, p):\n    '''\n    v1 -> v2の線分とpとの距離\n    '''\n    if (v2-v1).dot(p-v1) < 0.0:\n        return abs(p-v1)\n    if (v1-v2).dot(p-v2) < 0.0:\n        return abs(p-v2)\n    return distanceLP(v1, v2, p)\n\n\ndef ccw(p0, p1, p2):\n    c = (p1-p0).cross(p2-p0)\n    if math.isclose(c, 0.0, abs_tol=1e-10):\n        d = (p1-p0).dot(p2-p0)\n        if d < 0.0:\n            return -1\n        else:\n            d1 = abs(p1-p0)\n            d2 = abs(p2-p0)\n            if d1 < d2:\n                return 1\n            else:\n                return 0\n    elif c < 0.0:\n        return -1\n    else:\n        return 1\n\n\ndef intersect(p1, p2, p3, p4):\n    '''\n    p1p2とp3p4の交差判定\n    '''\n    #t1 = (p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x)\n    #t2 = (p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x)\n    #t3 = (p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x)\n    #t4 = (p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x)\n    # return (t1*t2) <= 0.0 and (t3*t4) <= 0.0\n    c1 = ccw(p1, p2, p3)*ccw(p1, p2, p4)\n    c2 = ccw(p3, p4, p1)*ccw(p3, p4, p2)\n    return c1 <= 0.0 and c2 <= 0.0\n\n\ndef distance(a1, a2, b1, b2):\n    '''\n    線分a1a2とb1b2の距離\n    '''\n    if intersect(a1, a2, b1, b2):\n        return 0.0\n    return min([\n        min([distanceSP(a1, a2, b1), distanceSP(a1, a2, b2)]),\n        min([distanceSP(b1, b2, a1), distanceSP(b1, b2, a2)])\n    ])\n\n\ncx, cy, r = map(int, input().split())\np = Vector2(cx, cy)\nq = int(input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(int, input().split())\n    v1, v2 = Vector2(x1, y1), Vector2(x2, y2)\n    '''\n    円と線分の交点\n    '''\n    pr = projection(v1, v2, p)\n    e = (v2-v1)/abs(v2-v1)\n    base = math.sqrt(r*r-abs(pr-p)**2)\n    a1, a2 = pr+e*base, pr-e*base\n    ans = \"\"\n    for a in sorted([a1, a2]):\n        ans += f\"{a.x:.10f} {a.y:.10f} \"\n    print(ans.strip())\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = (r**2 - abs(pro-p2)**2)**0.5\n  if pro-e*base.real == pro+e*base.real:\n    if (pro-e*base).imag < (pro+e*base).imag:\n      ans1=pro-e*base\n      ans2=pro+e*base\n    else:\n      ans1=pro+e*base\n      ans2=pro-e*base\n  elif (pro-e*base).real < (pro+e*base).real:\n    ans1=pro-e*base\n    ans2=pro+e*base\n  else:\n    ans1=pro+e*base\n    ans2=pro-e*base\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(*get_cross_point(p0,p1,p2)))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\nx, y, r = map(float, raw_input().split())\n\nq = input()\n\nfor loop in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    vx = x2 - x1\n    vy = y2 - y1\n    norm = vx * vx + vy * vy\n    inn = vx * (x - x1) + vy * (y - y1)\n    xc = x1 + vx * inn / norm\n    yc = y1 + vy * inn / norm\n    rem = math.sqrt(max(0, r ** 2 - (xc - x) ** 2 - (yc - y) ** 2))\n    dx = vx / math.sqrt(norm) * rem\n    dy = vy / math.sqrt(norm) * rem\n\n    ans = sorted([(xc + dx, yc + dy), (xc - dx, yc - dy)])\n    print \"%.10f %.10f %.10f %.10f\" % (ans[0][0], ans[0][1], ans[1][0], ans[1][1])\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, x, y, r):\n        self.centre = x + y * 1j\n        self.radius = r\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    p1, p2 = prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n    if p1.real <= p2.real and p1.imag < p2.imag:\n        ans = (p1, p2)\n    else:\n        ans = (p2, p1)\n    return ans\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cp1, cp2 = get_cross_point(circle, l)\n        print('{0:.8f} {1:.8f} {2:.8f} {3:.8f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, radius = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx, cy, radius)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\nfrom typing import List, Tuple\nfrom math import sqrt\nfrom enum import IntEnum\n\nEPS = 1e-10\n\n\ndef float_equal(x: float, y: float) -> bool:\n    return abs(x - y) < EPS\n\n\nclass PointLocation(IntEnum):\n    COUNTER_CLOCKWISE = 1\n    CCW = 1\n    CLOCKWISE = -1\n    CW = -1\n    ONLINE_BACK = 2\n    O_B = 2\n    ONLINE_FRONT = -2\n    O_F = -2\n    ON_SEGMENT = 0\n    O_S = 0\n\n\nPL = PointLocation\n\n\nclass Point:\n\n    def __init__(self, x: float=0.0, y: float=0.0) -> None:\n        self.x = x\n        self.y = y\n\n    def __repr__(self) -> str:\n        return \"Point({}, {})\".format(self.x, self.y)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Point):\n            # print(\"NotImplemented in Point\")\n            return NotImplemented\n        return float_equal(self.x, other.x) and \\\n            float_equal(self.y, other.y)\n\n    def __add__(self, other: 'Point') -> 'Point':\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other: 'Point') -> 'Point':\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, k: float) -> 'Point':\n        return Point(self.x * k, self.y * k)\n\n    def __rmul__(self, k: float) -> 'Point':\n        return self * k\n\n    def __truediv__(self, k: float) -> 'Point':\n        return Point(self.x / k, self.y / k)\n\n    def __lt__(self, other: 'Point') -> bool:\n        return self.y < other.y \\\n            if abs(self.x - other.x) < EPS \\\n            else self.x < other.x\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        return sqrt(self.norm())\n\n    def dot(self, other: 'Point') -> float:\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other: 'Point') -> float:\n        return self.x * other.y - self.y * other.x\n\n    def is_orthogonal(self, other: 'Point') -> bool:\n        return float_equal(self.dot(other), 0.0)\n\n    def is_parallel(self, other: 'Point') -> bool:\n        return float_equal(self.cross(other), 0.0)\n\n    def distance(self, other: 'Point') -> float:\n        return (self - other).abs()\n\n    def in_side_of(self, seg: 'Segment') -> bool:\n        return seg.vector().dot(\n            Segment(seg.p1, self).vector()) >= 0\n\n    def in_width_of(self, seg: 'Segment') -> bool:\n        return \\\n            self.in_side_of(seg) and \\\n            self.in_side_of(seg.reverse())\n\n    def distance_to_line(self, seg: 'Segment') -> float:\n        return \\\n            abs((self - seg.p1).cross(seg.vector())) / \\\n            seg.length()\n\n    def distance_to_segment(self, seg: 'Segment') -> float:\n        if not self.in_side_of(seg):\n            return self.distance(seg.p1)\n        if not self.in_side_of(seg.reverse()):\n            return self.distance(seg.p2)\n        else:\n            return self.distance_to_line(seg)\n\n    def location(self, seg: 'Segment') -> PointLocation:\n        p = self - seg.p1\n        d = seg.vector().cross(p)\n        if d > EPS:\n            return PointLocation.COUNTER_CLOCKWISE\n        if d < -EPS:\n            return PointLocation.CLOCKWISE\n        if seg.vector().dot(p) < 0.0:\n            return PointLocation.ONLINE_BACK\n        if seg.vector().norm() < p.norm():\n            return PointLocation.ONLINE_FRONT\n        return PointLocation.ON_SEGMENT\n\n\nVector = Point\n\n\nclass Segment:\n\n    def __init__(self, p1: Point = None, p2: Point = None) -> None:\n        self.p1: Point = Point() if p1 is None else p1\n        self.p2: Point = Point() if p2 is None else p2\n\n    def __repr__(self) -> str:\n        return \"Segment({}, {})\".format(self.p1, self.p2)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Segment):\n            # print(\"NotImplemented in Segment\")\n            return NotImplemented\n        return self.p1 == other.p1 and self.p2 == other.p2\n\n    def vector(self) -> Vector:\n        return self.p2 - self.p1\n\n    def reverse(self) -> 'Segment':\n        return Segment(self.p2, self.p1)\n\n    def length(self) -> float:\n        return self.p1.distance(self.p2)\n\n    def is_orthogonal(self, other: 'Segment') -> bool:\n        return self.vector().is_orthogonal(other.vector())\n\n    def is_parallel(self, other: 'Segment') -> bool:\n        return self.vector().is_parallel(other.vector())\n\n    def projection(self, p: Point) -> Point:\n        v = self.vector()\n        vp = p - self.p1\n        return v.dot(vp) / v.norm() * v + self.p1\n\n    def reflection(self, p: Point) -> Point:\n        x = self.projection(p)\n        return p + 2 * (x - p)\n\n    def intersects(self, other: 'Segment') -> bool:\n        d0: PointLocation = self.p1.location(other)\n        d1: PointLocation = self.p2.location(other)\n        d2: PointLocation = other.p1.location(self)\n        d3: PointLocation = other.p2.location(self)\n        return d0 * d1 * d2 * d3 == 0 or \\\n            (d0 * d1 == -1 and d2 * d3 == -1)\n\n    def intersection(self, other: 'Segment') -> Point:\n        a = self.vector()\n        b = other.vector()\n        c = self.p1 - other.p1\n        s = b.cross(c) / a.cross(b)\n        return self.p1 + s * a\n\n    def distance_with_segment(self, other: 'Segment') -> float:\n        if not self.is_parallel(other) and \\\n                self.intersects(other):\n            return 0\n        else:\n            return min(\n                self.p1.distance_to_segment(other),\n                self.p2.distance_to_segment(other),\n                other.p1.distance_to_segment(self),\n                other.p2.distance_to_segment(self))\n\n\nLine = Segment\n\n\nclass Circle:\n\n    def __init__(self, c: Point=None, r: float=0.0) -> None:\n        self.c: Point = Point() if c is None else c\n        self.r: float = r\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Circle):\n            return NotImplemented\n        return self.c == other.c and self.r == other.r\n\n    def __repr__(self) -> str:\n        return \"Circle({}, {})\".format(self.c, self.r)\n\n    def cross_point(self, line: Line) -> List[Point]:\n        proj = line.projection(self.c)\n        dist = self.c.distance_to_line(line)\n        tan = sqrt(self.r * self.r - dist * dist)\n        u = line.vector() / line.vector().abs()\n        return sorted([proj - tan * u, proj + tan * u])\n\ndef main() -> None:\n    cx, cy, r = [int(x) for x in input().split()]\n    c = Circle(Point(cx, cy), r)\n    q = int(input())\n\n    for _ in range(q):\n        x0, y0, x1, y1 = [int(x) for x in input().split()]\n        line = Line(Point(x0, y0), Point(x1, y1))\n        left, right = c.cross_point(line)\n        print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(\n            left.x, left.y, right.x, right.y))\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\nfrom operator import attrgetter\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, x, y, r):\n        self.centre = x + y * 1j\n        self.radius = r\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    return prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cross_pair = get_cross_point(circle, l)\n        cp = sorted(cross_pair, key=attrgetter('real'))\n        cp = sorted(cp, key=attrgetter('imag'))\n        cp1, cp2 = cp\n        print('{0:.8f} {1:.8f} {2:.8f} {3:.8f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, radius = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx, cy, radius)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport math\nimport sys\nfrom operator import attrgetter\nfrom collections import namedtuple\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    ans = [prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base]\n\n    ans.sort(key=attrgetter('real', 'imag'))\n    return ans\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(source=p0, target=p1)\n        cp1, cp2 = get_cross_point(circle, l)\n        print('{0:.8f} {1:.8f} {2:.8f} {3:.8f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, r = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    Circle = namedtuple('Circle', ('centre', 'radius'))\n    Segment = namedtuple('Segment', ('source', 'target'))\n\n    circle = Circle(centre=cx + cy * 1j, radius=r)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2*b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n        print \"%.9f %.9f %.9f %.9f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1 - y2) / (x1 - x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1 - x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        if XA == XB and YA > YB:\n            print \"%.9f %.9f %.9f %.9f\" % (XB, YB, XA, YA)\n        else:\n            print \"%.9f %.9f %.9f %.9f\" % (XA, YA, XB, YB)\n    "
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = math.sqrt(r*r-(abs(pro-p2)**2))\n  ans_small=pro-e*base\n  ans_big=pro+e*base\n  return ans_small.real,ans_small.imag,ans_big.real,ans_big.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(*get_cross_point(p0,p1,p2))\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2*b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n\n        if XA <= 1e-6: XA = 0\n        if YA <= 1e-6: YA = 0\n        if XB <= 1e-6: XB = 0\n        if YB <= 1e-6: YB = 0\n            \n        print \"%.6f %.6f %.6f %.6f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1 - y2) / (x1 - x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1 - x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        if XA <= 1e-6: XA = 0\n        if YA <= 1e-6: YA = 0\n        if XB <= 1e-6: XB = 0\n        if YB <= 1e-6: YB = 0\n        \n        if XA == XB and YA > YB:\n            print \"%.6f %.6f %.6f %.6f\" % (XB, YB, XA, YA)\n        else:\n            print \"%.6f %.6f %.6f %.6f\" % (XA, YA, XB, YB)\n    "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def abs2(self):\n        return float(self.x * self.x + self.y * self.y)\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) * (1 / abs(p2 - p1))\n    base = math.sqrt(c.r*c.r - (pr - c.c).abs2())\n    return [pr + e * base, pr - e * base]\n\nif __name__ == '__main__':\n\n    a, b, r = map(int, input().split())\n    c = Circle(Vector2(a, b), r)\n    n = int(input())\n    for _ in range(n):\n        ps = list(map(int, input().split()))\n        l = [Vector2(ps[0], ps[1]), Vector2(ps[2], ps[3])]\n\n        ans = getCrossPoints(c, l)\n        ans = sorted(ans, key=lambda x: (x.x, x.y))\n        print(ans[0].x, ans[0].y, ans[1].x, ans[1].y)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import starmap\nimport math\nreadline = sys.stdin.readline\nEPS = 1e-9\nONLINE_FRONT = -2\nCLOCKWISE = -1\nON_SEGMENT = 0\nCOUNTER_CLOCKWISE = 1\nONLINE_BACK = 2\nclass Circle(object):\n    __slots__ = ('c', 'r')\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\nclass Segment(object):\n    __slots__ = ('fi', 'se')\n    def __init__(self, fi, se):\n        self.fi = fi\n        self.se = se\nLine = Segment\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\ndef norm(base):\n    return abs(base) ** 2\ndef project(s, p2):\n    base = s.fi - s.se\n    r = dot(p2 - s.fi, base) / norm(base)\n    return s.fi + base * r\ndef reflect(s, p):\n    return p + (project(s, p) - p) * 2.0\ndef ccw(p1, p2, p3):\n    a = p2 - p1\n    b = p3 - p1\n    if cross(a, b) > EPS: return 1\n    if cross(a, b) < -EPS: return -1\n    if dot(a, b) < -EPS: return 2\n    if norm(a) < norm(b): return -2\n    return 0\ndef intersect4(p1, p2, p3, p4):\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0)\ndef intersect2(s1, s2):\n    return intersect4(s1.fi, s1.se, s2.fi, s2.se)\ndef getDistance(a, b):  return abs(a - b)\ndef getDistanceLP(l, p):\n    return abs(cross(l.se - l.fi, p - l.fi) / abs(l.se - l.fi))\ndef getDistanceSP(s, p):\n    if dot(s.se - s.fi, p - s.fi) < 0.0: return abs(p - s.fi)\n    if dot(s.fi - s.se, p - s.se) < 0.0: return abs(p - s.se)\n    return getDistanceLP(s, p)\ndef getDistances(s1, s2):\n    if intersect2(s1, s2): return 0.0\n    return min(getDistanceSP(s1, s2.fi), getDistanceSP(s1, s2.se),\n               getDistanceSP(s2, s1.fi), getDistanceSP(s2, s1.se))\ndef getCrossPoint(s1, s2):\n\tbase = s2.se - s2.fi\n\td1 = abs(cross(base, s1.fi - s2.fi))\n\td2 = abs(cross(base, s1.se - s2.fi))\n\tt = d1 / (d1 + d2)\n\treturn s1.fi + (s1.se - s1.fi) * t\ndef getCrossPoints(c, l):\n\tpr = project(l, c.c)\n\te = (l.se - l.fi) / abs(l.se - l.fi)\n\tbase = math.sqrt(c.r * c.r - norm(pr - c.c))\n\treturn Segment(pr + e * base, pr - e * base)\nx, y, r = map(int, readline().split())\nci = Circle(complex(x, y), r)\nn = int(readline())\nfor _ in [0] * n:\n    p0, p1 = starmap(complex, zip(*[map(int, readline().split())] * 2))\n    ppp = getCrossPoints(ci, Line(p0, p1))\n    if ppp.se.real < ppp.fi.real or (ppp.se.real == ppp.fi.real and ppp.se.imag < ppp.fi.imag):\n        ppp.fi, ppp.se = ppp.se, ppp.fi\n    print(*map('{:.10f}'.format, [ppp.fi.real, ppp.fi.imag, ppp.se.real, ppp.se.imag]))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\n\nEPS = 0.0000000001\n\nCOUNTER_CLOCKWISE = 1\nCLOCKWISE = -1\nONLINE_BACK = 2\nONLINE_FRONT = -2\nON_SEGMENT = 0\n                                                                      \nclass Point:\n    \n    global EPS\n    \n    def __init__(self, x = 0, y = 0):\n        self.x = x\n        self.y = y\n        \n        \n    def __add__(a, b):\n        s = a.x + b.x\n        t = a.y + b.y\n        return Point(s, t)\n        \n    def __sub__(a, b):\n        s = a.x - b.x\n        t = a.y - b.y\n        return Point(s, t)\n            \n    def __mul__(self, a):\n        s = a * self.x\n        t = a * self.y\n        return Point(s, t)\n        \n    def __truediv__(self, a):\n        s = self.x / a\n        t = self.y / a\n        return Point(s, t)\n            \n            \n            \n            \n    def norm(self):\n        return self.x * self.x + self.y * self.y\n        \n    def abs(self):\n        return self.norm() ** 0.5\n            \n    \n            \n            \n    def __eq__(self, other):\n        return abs(self.x - other.y) < self.EPS and abs(self.y - other.y) < self.EPS\n            \n            \n            \n    def dot(self, b):\n        return self.x * b.x + self.y * b.y\n        \n    def cross(self, b):\n        return self.x * b.y - self.y * b.x\n    \n    \nclass Segment:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\nclass Circle:\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\ndef project(s, p):\n    base = s.p2 - s.p1\n    hypo = p - s.p1\n    r = hypo.dot(base) / base.norm()\n    return s.p1 + base * r\n\ndef reflecton(s, p):\n    return p + (project(s,p) - p) * 2\n\n\ndef getDistance(a, b):\n    return (a-b).abs()\n\ndef getDistanceLP(l, p):\n    return abs((l.p2-l.p1).cross(p-l.p1)) / ((l.p2-l.p1).abs())\n\ndef getDistanceSP(s, p):\n    if (s.p2 - s.p1).dot(p-s.p1) < 0:\n        return (p-s.p1).abs()\n    elif (s.p1 - s.p2).dot(p-s.p2) < 0:\n        return (p-s.p2).abs()\n    return getDistanceLP(s,p)\n\n\ndef getDistanceSS(s1, s2):\n    if intersectS(s1, s2):\n        return 0\n    return min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n\n\n\ndef ccw(p0, p1, p2):\n    a = p1-p0\n    b = p2-p0\n    \n    if a.cross(b) > 0:\n        return COUNTER_CLOCKWISE\n    elif a.cross(b) <0:\n        return CLOCKWISE\n    elif a.dot(b) < 0:\n        return ONLINE_BACK\n    elif a.abs() < b.abs():\n        return ONLINE_FRONT\n    else:\n        return ON_SEGMENT\n\ndef intersect(p1, p2, p3, p4):\n    return ccw(p1, p2, p3) *ccw(p1, p2, p4) <=0 and ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\ndef intersectS(s1, s2):\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2)\n\n\ndef getCrossPoint(s1, s2):\n    base = s2.p2-s2.p1\n    a = s1.p1-s2.p1\n    b = s1.p2-s2.p1\n    \n    d1 = abs(a.cross(base))\n    d2 = abs(b.cross(base))\n    \n    t = d1 / (d1+d2)\n    return s1.p1 + (s1.p2-s1.p1) * t\n\n\ndef getCrossPointC(c, l):\n    pr = project(l, c.c)\n    e = (l.p2-l.p1) / (l.p2-l.p1).abs()\n    base = (c.r *c.r  - (pr - c.c).norm()) ** 0.5\n    return pr - e * base, pr + e * base\n\ndef printPoint(p1, p2):\n    print(round(p1.x, 8), round(p1.y, 8), round(p2.x, 8), round(p2.y, 8))\n\nnums=list(map(int,input().split()))\ncenter = Point(nums[0], nums[1])\ncircle = Circle(center, nums[2])\nn = int(input())\nfor i in range(n):\n    nums=list(map(int,input().split()))\n    l = Segment(Point(nums[0], nums[1]), Point(nums[2], nums[3]))\n    p1, p2 = getCrossPointC(circle, l)\n    \n    \"\"\"\n    if p1.x < p2.x:\n        print(p1.x, p1.y, p2.x, p2.y)\n    elif p1.x > p2.x:\n        print(p2.x, p2.y, p1.x, p1.y)\n    else:\n        if p1.y < p2.y:\n            print(p1.x, p1.y, p2.x, p2.y)\n        else:\n            print(p2.x, p2.y, p1.x, p1.y)\n    \"\"\"\n    if p1.x < p2.x:\n        printPoint(p1, p2)\n    elif p1.x > p2.x:\n        printPoint(p2, p1)\n    else:\n        if p1.y < p2.y:\n            printPoint(p1, p2)\n        else:\n            printPoint(p2, p1)\n    \n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = (r**2 - abs(pro-p2)**2)**0.5\n  if (pro-e*base).real == (pro+e*base).real:\n    if (pro-e*base).imag < (pro+e*base).imag:\n      ans1=pro-e*base\n      ans2=pro+e*base\n    else:\n      ans1=pro+e*base\n      ans2=pro-e*base\n  elif (pro-e*base).real < (pro+e*base).real:\n    ans1=pro-e*base\n    ans2=pro+e*base\n  else:\n    ans1=pro+e*base\n    ans2=pro-e*base\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(*get_cross_point(p0,p1,p2)))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = (r**2 - abs(pro-p2)**2)**0.5\n  if pro-e*base.real == pro+e*base.real:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.imag)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.imag)\n  elif (pro-e*base).real < (pro+e*base).real:\n    ans1=pro-e*base\n    ans2=pro+e*base\n  else:\n    ans1=pro+e*base\n    ans2=pro-e*base\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(*get_cross_point(p0,p1,p2)))\n"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2*b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n        print \"%.8f %.8f %.8f %.8f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1-y2) / (x1-x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1-x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        print \"%.8f %.8f %.8f %.8f\" % (XA, YA, XB, YB)"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = math.sqrt(r*r-(abs(pro-p2)**2))\n  if pro-e*base.real == pro+e*base.real:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.imag)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.imag)\n  else:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.real)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.real)\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(*get_cross_point(p0,p1,p2)))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, centre, radius):\n        self.centre = complex(centre)\n        self.radius = float(radius)\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    p1, p2 = prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n    if p1.real < p2.real:\n        ans = (p1, p2)\n    elif p1.real == p2.real:\n        if p1.imag < p2.imag:\n            ans = (p1, p2)\n        else:\n            ans = (p2, p1)\n    else:\n        ans = (p2, p1)\n    return ans\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cp1, cp2 = get_cross_point(circle, l)\n        print('{0:.8f} {1:.8f} {2:.8f} {3:.8f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, r = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx + cy * 1j, r)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) * (1 / abs(p2 - p1))\n    base = math.sqrt(c.r**2 - abs(pr - c.c)**2)\n    return [pr + e * base, pr - e * base]\n\n\nif __name__ == '__main__':\n\n    a, b, r = map(int, input().split())\n    c = Circle(Vector2(a, b), r)\n    n = int(input())\n    for _ in range(n):\n        ps = list(map(int, input().split()))\n        l = [Vector2(ps[0], ps[1]), Vector2(ps[2], ps[3])]\n\n        ans = getCrossPoints(c, l)\n        ans = sorted(ans, key=lambda x: (x.x, x.y))\n        print(ans[0].x, ans[0].y, ans[1].x, ans[1].y)\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = math.sqrt(r*r-(abs(pro-p2)**2))\n  if pro-e*base.real == pro+e*base.real:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.imag)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.imag)\n  else:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.real)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.real)\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.10} {:.10} {:.10} {:.10}\".format(*get_cross_point(p0,p1,p2)))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Vector:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n        \n    def __add__(self,other):\n        return Vector(self.x+other.x,self.y+other.y)\n    \n    def __sub__(self,other):\n        return Vector(self.x-other.x,self.y-other.y)\n    \n    def __mul__(self,scalar):\n        return Vector(self.x*scalar,self.y*scalar)\n    def __rmul__(self, scalar):\n        return Vector(self.x*scalar,self.y*scalar)\n    \n   \n    def __repr__(self):\n        return str([self.x,self.y])\n        \n    def norm_2(self):\n        return dot(self,self)\n    \n    def norm(self):\n        return math.sqrt(self.norm_2())\n    \ndef v_sum(v1,v2):\n    return Vector(v1.x+v2.x,v1.y+v2.y) \ndef scalar_multi(k,v):\n    return Vector(k*v.x,k*v.y)\ndef v_diff(v1,v2):\n    return v_sum(v1,scalar_multi(-1,v2))\n    \ndef dot(vector1,vector2):\n    return vector1.x*vector2.x+vector1.y*vector2.y\n\ndef cross(vector1,vector2):\n    return vector1.x*vector2.y-vector1.y*vector2.x\n\ncx,cy,r = map(int,input().split())\nc = Vector(cx,cy)\nq = int(input())\n\nfor i in range(q):\n    x1,y1,x2,y2 = map(int,input().split())\n    p1 = Vector(x1,y1)\n    p2 = Vector(x2,y2)\n    d = p2-p1\n    m = p1+(dot(c-p1,d)/d.norm_2()*d)\n    #h = abs(cross(c-p1,d))/d.norm()\n    l = math.sqrt(r**2-(m-c).norm_2())\n    \n    a = m-(l/d.norm()*d)\n    b = m+(l/d.norm()*d)   \n    \n    if abs(a.x)<10**(-9):\n        a.x = 0\n    if abs(a.y)<10**(-9):\n        a.y = 0\n    if abs(b.x)<10**(-9):\n        b.x = 0\n    if abs(b.y)<10**(-9):\n        b.y = 0\n        \n    if a.x<b.x:\n        print('{} {} {} {}'.format(a.x,a.y,b.x,b.y))\n    elif a.x>b.x:\n        print('{} {} {} {}'.format(b.x,b.y,a.x,a.y))\n    else:\n        if a.y<b.y:\n            print('{} {} {} {}'.format(a.x,a.y,b.x,b.y))\n        else:\n            print('{} {} {} {}'.format(b.x,b.y,a.x,a.y))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def __truediv__(self, scalar):\n        return Vector2(self.x/scalar, self.y/scalar)\n\n    def abs2(self):\n        return float(self.x * self.x + self.y * self.y)\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) / abs(p2 - p1)\n    base = math.sqrt(c.r*c.r - (pr - c.c).abs2())\n    return [pr + e * base, pr - e * base]\n\nif __name__ == '__main__':\n\n    a, b, r = map(int, input().split())\n    c = Circle(Vector2(a, b), r)\n    n = int(input())\n    for _ in range(n):\n        ps = list(map(int, input().split()))\n        l = [Vector2(ps[0], ps[1]), Vector2(ps[2], ps[3])]\n\n        ans = getCrossPoints(c, l)\n        ans = sorted(ans, key=lambda x: (x.x, x.y))\n        print(ans[0].x, ans[0].y, ans[1].x, ans[1].y)\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nEPS = 1e-8\n\n#射影\ndef Projection(point, begin, end):\n\ttmp = (point-begin) / (end-begin)\n\treturn tmp.real * (end-begin) + begin\n\nx, y, r = map(int, input().split())\nc = complex(x, y)\nans = []\nq = int(input())\nfor _ in range(q):\n\tres = []\n\tx, y, z, w = map(int, input().split())\n\tp1, p2 = complex(x, y), complex(z, w)\n\tproj = Projection(c, p1, p2)\n\tfor i in [-1, 1]:\n\t\tres.append(proj + i * sqrt(r**2 - abs(c-proj)**2) * (p2-p1) / abs(p2-p1))\n\tres.sort(key=lambda x: (x.real, x.imag))\n\tans.append((res[0].real, res[0].imag, res[1].real, res[1].imag))\nfor a in ans:\n\tprint(\"{:.10f} {:.10f} {:.10f} {:.10f}\".format(*a))\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nimport math\n\nclass Vector:\n    def __init__(self, x=None, y=None):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, k):\n        return Vector(self.x * k, self.y * k)\n\n    def __truediv__(self, k):\n        return Vector(self.x / k, self.y / k)\n\n    def __gt__(self, other):\n        return self.x > other.x and self.y > other.yb\n\n    def __lt__(self, other):\n        return self.x < other.x and self.y < other.yb\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    # usually cross operation return Vector but it returns scalor\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        return math.sqrt(self.norm())\n\nclass Point(Vector):\n    def __init__(self, *args, **kargs):\n        return super().__init__(*args, **kargs)\n\nclass Segment:\n    def __init__(self, p1=Point(0, 0), p2=Point(1, 1)):\n        self.p1 = p1\n        self.p2 = p2\n\nclass Line(Segment):\n    def __init__(self, *args, **kargs):\n        return super().__init__(*args, **kargs)\n\nclass Circle:\n    def __init__(self, c=Point(0, 0), r=1):\n        self.c = c\n        self.r = r\n\ndef project(s, p):\n    base = s.p2 - s.p1\n    hypo = p - s.p1\n    r = hypo.dot(base) / base.norm()\n    return s.p1 + base * r\n\ndef get_cross_point(c, l):\n    pr = project(l, c.c)\n    e = (l.p1- l.p2) / (l.p2 - l.p1).abs()\n    base = math.sqrt( c.r * c.r - (pr - c.c).norm() )\n    return pr + e * base, pr - e * base\n\ndef read_and_print_results(n, c):\n    for _ in range(n):\n        line = stdin.readline().strip().split()\n        p0 = Vector(int(line[0]), int(line[1]))\n        p1 = Vector(int(line[2]), int(line[3]))\n        l = Line(p0, p1)\n        p2, p3 = get_cross_point(c, l)\n        x1, y1 = min((p2.x, p2.y), (p3.x, p3.y))\n        x2, y2 = max((p2.x, p2.y), (p3.x, p3.y))\n        print(\"{0:0.8f} {1:0.8f} {2:0.8f} {3:0.8f}\".format(x1, y1, x2, y2))\n\nx, y, r = [ int(i) for i in input().split() ]\nc = Circle(Point(x, y), r)\nn = int(input())\nread_and_print_results(n, c)\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2*b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n\n        if XA < 0.000001: XA = 0\n        if YA < 0.000001: YA = 0\n        if XB < 0.000001: XB = 0\n        if YB < 0.000001: YB = 0\n            \n        print \"%.6f %.6f %.6f %.6f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1 - y2) / (x1 - x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1 - x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        if XA < 0.000001: XA = 0\n        if YA < 0.000001: YA = 0\n        if XB < 0.000001: XB = 0\n        if YB < 0.000001: YB = 0\n        \n        if XA == XB and YA > YB:\n            print \"%.6f %.6f %.6f %.6f\" % (XB, YB, XA, YA)\n        else:\n            print \"%.6f %.6f %.6f %.6f\" % (XA, YA, XB, YB)\n    "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def abs2(self):\n        return float(self.x * self.x + self.y * self.y)\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) * (1 / abs(p2 - p1))\n    base = math.sqrt(c.r**2 - (pr - c.c).abs2())\n    return [pr + e * base, pr - e * base]\n\nif __name__ == '__main__':\n\n    a, b, r = map(int, input().split())\n    c = Circle(Vector2(a, b), r)\n    n = int(input())\n    for _ in range(n):\n        ps = list(map(int, input().split()))\n        l = [Vector2(ps[0], ps[1]), Vector2(ps[2], ps[3])]\n\n        ans = getCrossPoints(c, l)\n        ans = sorted(ans, key=lambda x: (x.x, x.y))\n        print(ans[0].x, ans[0].y, ans[1].x, ans[1].y)\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2*b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n\n        if XA < 0.0000001: XA = 0\n        if YA < 0.0000001: YA = 0\n        if XB < 0.0000001: XB = 0\n        if YB < 0.0000001: YB = 0\n            \n        print \"%.8f %.8f %.8f %.8f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1 - y2) / (x1 - x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1 - x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        if XA < 0.0000001: XA = 0\n        if YA < 0.0000001: YA = 0\n        if XB < 0.0000001: XB = 0\n        if YB < 0.0000001: YB = 0\n        \n        if XA == XB and YA > YB:\n            print \"%.9f %.9f %.9f %.9f\" % (XB, YB, XA, YA)\n        else:\n            print \"%.9f %.9f %.9f %.9f\" % (XA, YA, XB, YB)\n    "
  },
  {
    "language": "Python",
    "code": "import math\nEPS = 10**(-9)\ndef is_equal(a,b):\n    return abs(a-b) < EPS\n\ndef norm(v,i=2):\n    ret = 0\n    n = len(v)\n    for j in range(n):\n        ret += abs(v[j])**i\n    return math.pow(ret,1/i)\n\nclass Vector(list):\n    \"\"\"\n    ベクトルクラス\n    対応演算子\n    +  : ベクトル和 \n    -  : ベクトル差\n    *  : スカラー倍、または内積\n    /  : スカラー除法\n    ** : 外積\n    += : ベクトル和\n    -= : ベクトル差\n    *= : スカラー倍\n    /= : スカラー除法\n\n    メソッド\n    self.norm(i) : L{i}ノルムを計算\n    \"\"\"\n    def __add__(self,other):\n        n = len(self)\n        ret = [0]*n\n        for i in range(n):\n            ret[i] = super().__getitem__(i) + other.__getitem__(i)\n        return self.__class__(ret)\n    \n    def __radd__(self,other):\n        n = len(self)\n        ret = [0]*n\n        for i in range(n):\n            ret[i] = other.__getitem__(i) + super().__getitem__(i)\n        return self.__class__(ret)\n    \n    def __iadd__(self, other):\n        n = len(self)\n        for i in range(n):\n            self[i] += other.__getitem__(i)\n        return self\n\n    def __sub__(self,others):\n        n = len(self) \n        ret = [0]*n\n        for i in range(n):\n            ret[i] = super().__getitem__(i) - others.__getitem__(i)\n        return self.__class__(ret)\n\n    def __isub__(self, other):\n        n = len(self)\n        for i in range(n):\n            self[i] -= other.__getitem__(i)\n        return self\n\n    def __rsub__(self,others):\n        n = len(self) \n        ret = [0]*n\n        for i in range(n):\n            ret[i] = others.__getitem__(i) - super().__getitem__(i)\n        return self.__class__(ret)\n    \n    def __mul__(self,other):\n        n = len(self)\n        if isinstance(other,list):\n            ret = 0\n            for i in range(n):\n                ret += super().__getitem__(i)*other.__getitem__(i)\n            return ret\n        else:\n            ret = [0]*n\n            for i in range(n):\n                ret[i] = super().__getitem__(i)*other\n            return self.__class__(ret)\n\n    def __rmul__(self,other):\n        n = len(self)\n        if isinstance(other,list):\n            ret = 0\n            for i in range(n):\n                ret += super().__getitem__(i)*other.__getitem__(i)\n            return ret\n        else:\n            ret = [0]*n\n            for i in range(n):\n                ret[i] = super().__getitem__(i)*other\n            return self.__class__(ret)\n    \n    \n    def __truediv__(self,other):\n        \"\"\"\n        ベクトルのスカラー除法\n        Vector/scalar\n        \"\"\"\n        n = len(self)\n        ret = [0]*n\n        for i in range(n):\n            ret[i] = super().__getitem__(i)/other\n        return self.__class__(ret)\n    \n    def norm(self,i):\n        \"\"\"\n        L{i}ノルム\n        self.norm(i)\n        \"\"\"\n        return norm(self,i)\n    \n    def __pow__(self,other):\n        \"\"\"\n        外積\n        self**other\n        \"\"\"\n        n = len(self)\n        ret = [0]*3\n        x = self[:]\n        y = other[:]\n        if n == 2:\n            x.append(0)\n            y.append(0)\n        if n == 2 or n == 3:\n            for i in range(3):\n                ret[0],ret[1],ret[2] = x[1]*y[2]-x[2]*y[1],x[2]*y[0]-x[0]*y[2],x[0]*y[1]-x[1]*y[0]\n            ret = Vector(ret)\n            if n == 2:\n                return ret\n            else:\n                return ret\n\nclass Segment:\n    \"\"\"\n    線分クラス\n\n    methods\n    length()                 :\n    get_unit_vec()           : \n    projection(vector)       :\n    is_vertical(segment)     :\n    is_horizontal(segment)   :\n    reflection()             :\n    include()                :\n    distance()               :\n    ccw()                    :\n    intersect()              :\n    intersect_point          :\n    \"\"\"\n    def __init__(self,v1,v2):\n        self.v1 = v1\n        self.v2 = v2\n    \n    def length(self):\n        return norm(self.v1-self.v2)\n\n    def get_unit_vec(self):\n        #方向単位ベクトル\n        dist = norm(self.v2-self.v1)\n        if dist != 0:\n            return (self.v2-self.v1)/dist\n        else:\n            return False\n    \n    def projection(self,vector):\n        #射影点(線分を直線と見たときの)\n        unit_vec = self.get_unit_vec()\n        t = unit_vec*(vector-self.v1)\n        return self.v1 + t*unit_vec\n    \n    def is_vertical(self,other):\n        #線分の直交判定\n        return is_equal(0,self.get_unit_vec()*other.get_unit_vec())\n    \n    def is_horizontal(self,other):\n        #線分の平行判定\n        return is_equal(0,self.get_unit_vec()**other.get_unit_vec())\n    \n    def reflection(self,vector):\n        #反射点(線分を直線と見たときの)\n        projection = self.projection(vector)\n        v = projection - vector\n        return projection + vector\n    \n    def include(self,vector):\n        #線分が点を含むか否か\n        proj = self.projection(vector)\n        if not is_equal(norm(proj-vector),0):\n            return False\n        else:\n            n = len(self.v1)\n            f = True\n            for i in range(n):\n                f &= ((self.v1[i] <= vector[i] <= self.v2[i]) or (self.v2[i] <= vector[i] <=self.v1[i]))\n            return f\n    \n    def distance(self,other):\n        #点と線分の距離\n        if isinstance(other,Vector):\n            proj = self.projection(other)\n            if self.include(proj):\n                return norm(proj-other)\n            else:\n                ret = []\n                ret.append(norm(self.v1-other))\n                ret.append(norm(self.v2-other))\n                return min(ret)\n\n    def ccw(self,vector):\n        \"\"\"\n        線分に対して点が反時計回りの位置にある(1)か時計回りの位置にある(-1)か線分上にある(0)か\n        ただし、直線上にはあるが線分上にはない場合は反時計回りの位置にあると判定して1を返す。\n        \"\"\"\n        direction = self.v2 - self.v1\n        v = vector - self.v1\n        if self.include(vector):\n            return 0\n        else:\n            cross = direction**v\n            if cross[2] <= 0:\n                return 1\n            else:\n                return -1\n    \n    def intersect(self,segment):\n        \"\"\"\n        線分の交差判定\n        \"\"\"\n        ccw12 = self.ccw(segment.v1)\n        ccw13 = self.ccw(segment.v2)\n        ccw20 = segment.ccw(self.v1)\n        ccw21 = segment.ccw(self.v2)\n\n        if ccw12*ccw13*ccw20*ccw21 == 0:\n            return True\n        else:\n            if ccw12*ccw13 < 0 and ccw20*ccw21 < 0:\n                return True\n            else:\n                return False\n    \n    def intersect_point(self,segment):\n        \"\"\"\n        線分の交点\n        \"\"\"\n        d1 = norm(self.projection(segment.v1) - segment.v1)\n        d2 = norm(self.projection(segment.v2) - segment.v2)\n        return segment.v1 + (d1/(d1 + d2)) * (segment.v2 - segment.v1)\n\n\nclass Line(Segment):\n    \"\"\"\n    直線クラス\n    \"\"\"\n    #直線上に点が存在するか否か\n    def include(self,vector):\n        proj = self.projection(vector)\n        return is_equal(norm(proj-vector),0)\n    \n    def distance(self,vector):\n        return norm(self.projection(vector) - vector)\n\n\nclass Circle():\n    def __init__(self,vector,r):\n        self.c = vector\n        self.r = r\n    \n    def intersect_point(self,other):\n        if isinstance(other,Line):\n            if other.distance(self.c) > self.r:\n                return False\n            else:\n                d = other.distance(self.c)\n                proj = other.projection(self.c)\n                unit_v = other.get_unit_vec()\n                t = (self.r**2 - d**2)**0.5\n                return proj + t*unit_v, proj - t*unit_v\n\n\ncx,cy,r = map(int,input().split())\ncircle = Circle(Vector([cx,cy]),r)\nq = int(input())\nlines = [0]*q\nfor i in range(q):\n    x1,y1,x2,y2 = map(int,input().split())\n    lines[i] = Line(Vector([x1,y1]),Vector([x2,y2]))\n\nfor i in range(q):\n    ic1,ic2 = circle.intersect_point(lines[i])\n    ics = [ic1,ic2]\n    ics.sort()\n    print(\"{:.7f} {:.7f} {:.7f} {:.7f}\".format(*ics[0],*ics[1]))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\nfrom operator import attrgetter\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, x, y, r):\n        self.centre = x + y * 1j\n        self.radius = r\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    return prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cross_pair = get_cross_point(circle, l)\n        cp1, cp2 = sorted(cross_pair, key=attrgetter('real'))\n        print('{0:.8f} {1:.8f} {2:.8f} {3:.8f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, radius = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx, cy, radius)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\nfrom operator import attrgetter\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, x, y, r):\n        self.centre = x + y * 1j\n        self.radius = r\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    return prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cross_pair = get_cross_point(circle, l)\n        cp1, cp2 = sorted(cross_pair, key=attrgetter('real'))\n        print('{0:.10f} {1:.10f} {2:.10f} {3:.10f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, radius = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx, cy, radius)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "cx, cy, r = map(int, input().split())\nq = int(input())\nfor _ in range(q):\n    x1, y1, x2, y2 = map(int, input().split())\n    dx, dy = x2 - x1, y2 - y1\n    px, py = cx - x1, cy - y1\n    s2 = dx ** 2 + dy ** 2\n    dot = dx * px + dy * py\n    crs = dx * py - dy * px\n    t1 = (dot + (s2 * r ** 2 - crs ** 2) ** 0.5) / s2\n    t2 = (dot - (s2 * r ** 2 - crs ** 2) ** 0.5) / s2\n    if (dx < 0 or (dx == 0 and dy < 0)) ^ (t1 > t2):\n        t1, t2 = t2, t1\n    print(x1 + dx * t1, y1 + dy * t1, x1 + dx * t2, y1 + dy * t2)"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ncx,cy,r = map(int,input().split())\nc = [cx, cy]\nq = int(input())\n\nclass Line:pass\n\ndef dot(a, b):\n    return sum([i * j for i,j in zip(a, b)])\ndef add(a,b):\n    return [a[0] + b[0],a[1] + b[1]]\ndef sub(a, b):\n    return [a[0] - b[0],a[1] - b[1]]\ndef multi(k, a):\n    return [k*a[0],k*a[1]]\ndef cross(a, b):\n    return  a[0] * b[1] - a[1] * b[0]\ndef norm(a):\n    return sqrt(a[0] ** 2 + a[1] ** 2)    \ndef proj(p, l):\n    base = sub(l.p2, l.p1)\n    hypo = sub(p, l.p1)\n    t = dot(hypo,base) / norm(base)\n    return add(l.p1, multi(t/norm(base), base))\n    \nfor i in range(q):\n    x1,y1,x2,y2 = map(int, input().split())\n    l = Line()\n    l.p1 = [x1,y1]\n    l.p2 = [x2,y2]\n    pr = proj(c, l)\n    e = multi(1/norm(sub(l.p2, l.p1)),sub(l.p2, l.p1))\n    e2 = multi(-1, e)\n    base = sqrt(r**2 - norm(sub(pr,c))**2)\n    a = add(pr, multi(base, e))\n    b = add(pr, multi(base, e2))\n    ans = [a,b]\n    ans = sorted(ans, key=lambda x: (x[0],x[1]))\n    print(' '.join([str(i) for o in ans for i in o]))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# CGL_7_D: Circles - Cross Points of a Circle and a line\n\nfrom math import sqrt\n\n\ndef cross_point(circle, p1, p2):\n    x0, y0, r = circle\n    x1, y1 = p1\n    x2, y2 = p2\n\n    p1p2 = norm((x2-x1, y2-y1))\n    op1 = norm((x0-x1, y0-y1))\n    rr = r*r\n    dp = dot((x0-x1, y0-y1), (x2-x1, y2-y1))\n\n    d = dp*dp - p1p2 * (op1 - rr)\n\n    if abs(d) < 1e-10:\n        t = dp / p1p2\n        return [(x1 + t*(x2-x1), y1 + t*(y2-y1))]\n    elif d > 1e-10:\n        t1 = (dp+sqrt(d)) / p1p2\n        t2 = (dp-sqrt(d)) / p1p2\n        return [(x1 + t1*(x2-x1), y1 + t1*(y2-y1)),\n                (x1 + t2*(x2-x1), y1 + t2*(y2-y1))]\n    else:\n        return None\n\n\ndef norm(v):\n    x, y = v\n    return x**2 + y**2\n\n\ndef dot(v1, v2):\n    x1, y1 = v1\n    x2, y2 = v2\n    return x1*x2 + y1*y2\n\n\ndef run():\n    c = [int(i) for i in input().split()]\n    q = int(input())\n\n    for _ in range(q):\n        x1, y1, x2, y2 = [int(i) for i in input().split()]\n        ps = cross_point(c, (x1, y1), (x2, y2))\n\n        if ps is None:\n            raise ValueError('the circle and line do not intersect')\n        if len(ps) == 1:\n            ps *= 2\n\n        p1, p2 = ps\n        if p1 > p2:\n            p1, p2 = p2, p1\n\n        print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(*p1, *p2))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = math.sqrt(r*r-(abs(pro-p2)**2))\n  if pro-e*base.real == pro+e*base.real:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.imag)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.imag)\n  else:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.real)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.real)\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.10} {:.10} {:.10} {:.10}\".format(*get_cross_point(p0,p1,p2)))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = (r**2 - abs(pro-p2)**2)**0.5\n  if pro-e*base.real == pro+e*base.real:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.imag)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.imag)\n  elif (pro-e*base).real < (pro+e*base).real:\n    ans1=pro-e*base\n    ans2=pro+e*base\n  else:\n    ans1=pro+e*base\n    ans2=pro-e*base\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(*get_cross_point(p0,p1,p2)))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n        print \"%.8f %.8f %.8f %.8f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1-y2) / (x1-x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1-x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        print \"%.8f %.8f %.8f %.8f\" % (XA, YA, XB, YB)\n    "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 9)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nINF=float('inf')\n\nclass Geometry:\n\n    EPS = 10 ** -9\n\n    def add(self, a, b):\n        x1, y1 = a\n        x2, y2 = b\n        return (x1+x2, y1+y2)\n\n    def sub(self, a, b):\n        x1, y1 = a\n        x2, y2 = b\n        return (x1-x2, y1-y2)\n\n    def mul(self, a, b):\n        x1, y1 = a\n        if not isinstance(b, tuple):\n            return (x1*b, y1*b)\n        x2, y2 = b \n        return (x1*x2, y1*y2)\n\n    def div(self, a, b):\n        x1, y1 = a\n        if not isinstance(b, tuple):\n            return (x1/b, y1/b)\n        x2, y2 = b\n        return (x1/x2, y1/y2)\n\n    def abs(self, a):\n        from math import hypot\n        x1, y1 = a\n        return hypot(x1, y1)\n\n    def norm(self, a):\n        x, y = a\n        return x**2 + y**2\n\n    def dot(self, a, b):\n        x1, y1 = a\n        x2, y2 = b\n        return x1*x2 + y1*y2\n\n    def cross(self, a, b):\n        x1, y1 = a\n        x2, y2 = b\n        return x1*y2 - y1*x2\n\n    def project(self, seg, p):\n        \"\"\" 線分segに対する点pの射影 \"\"\"\n        p1, p2 = seg\n        base = self.sub(p2, p1)\n        r = self.dot(self.sub(p, p1), base) / self.norm(base)\n        return self.add(p1, self.mul(base, r))\n\n    def reflect(self, seg, p):\n        \"\"\" 線分segを対称軸とした点pの線対称の点 \"\"\"\n        return self.add(p, self.mul(self.sub(self.project(seg, p), p), 2))\n\n    def ccw(self, p0, p1, p2):\n        \"\"\" 線分p0,p1から線分p0,p2への回転方向 \"\"\"\n        a = self.sub(p1, p0)\n        b = self.sub(p2, p0)\n        # 反時計回り\n        if self.cross(a, b) > self.EPS: return 1\n        # 時計回り\n        if self.cross(a, b) < -self.EPS: return -1\n        # 直線上(p2 => p0 => p1)\n        if self.dot(a, b) < -self.EPS: return 2\n        # 直線上(p0 => p1 => p2)\n        if self.norm(a) < self.norm(b): return -2\n        # 直線上(p0 => p2 => p1)\n        return 0\n\n    def intersect(self, seg1, seg2):\n        \"\"\" 線分seg1と線分seg2の交差判定 \"\"\"\n        p1, p2 = seg1\n        p3, p4 = seg2\n        return (\n            self.ccw(p1, p2, p3) * self.ccw(p1, p2, p4) <= 0\n            and self.ccw(p3, p4, p1) * self.ccw(p3, p4, p2) <= 0\n        )\n\n    def get_distance_LP(self, line, p):\n        \"\"\" 直線lineと点pの距離 \"\"\"\n        p1, p2 = line\n        return abs(self.cross(self.sub(p2, p1), self.sub(p, p1)) / self.abs(self.sub(p2, p1)))\n\n    def get_distance_SP(self, seg, p):\n        \"\"\" 線分segと点pの距離 \"\"\"\n        p1, p2 = seg\n        if self.dot(self.sub(p2, p1), self.sub(p, p1)) < 0: return self.abs(self.sub(p, p1))\n        if self.dot(self.sub(p1, p2), self.sub(p, p2)) < 0: return self.abs(self.sub(p, p2))\n        return self.get_distance_LP(seg, p)\n\n    def get_distance_SS(self, seg1, seg2):\n        \"\"\" 線分seg1と線分seg2の距離 \"\"\"\n        p1, p2 = seg1\n        p3, p4 = seg2\n        if self.intersect(seg1, seg2): return 0\n        return min(\n            self.get_distance_SP(seg1, p3), self.get_distance_SP(seg1, p4),\n            self.get_distance_SP(seg2, p1), self.get_distance_SP(seg2, p2),\n        )\n\n    def get_cross_pointSS(self, seg1, seg2):\n        \"\"\" 線分seg1と線分seg2の交点 \"\"\"\n        p1, p2 = seg1\n        p3, p4 = seg2\n        base = self.sub(p4, p3)\n        dist1 = abs(self.cross(base, self.sub(p1, p3)))\n        dist2 = abs(self.cross(base, self.sub(p2, p3)))\n        t = dist1 / (dist1+dist2)\n        return self.add(p1, self.mul(self.sub(p2, p1), t))\n\n    def get_cross_pointCL(self, c, line):\n        \"\"\" 円cと直線lineの交点 \"\"\"\n        from math import sqrt\n        # if not intersect(c, line): return -1\n        x, y, r = c\n        p1, p2 = line\n        pr = self.project(line, (x, y))\n        e = self.div(self.sub(p2, p1), self.abs(self.sub(p2, p1)))\n        base = sqrt(r*r - self.norm(self.sub(pr, (x, y))))\n        return [self.add(pr, self.mul(e, base)), self.sub(pr, self.mul(e, base))]\n\ngm = Geometry()\nx, y, r = MAP()\nc = (x, y, r)\nfor _ in range(INT()):\n    x1, y1, x2, y2 = MAP()\n    seg = ((x1, y1), (x2, y2))\n    res = gm.get_cross_pointCL(c, seg)\n    res.sort()\n    # 2次元タプルをsumの第2引数で1次元にする\n    res = sum(res, ())\n    for i in range(3):\n        print('{:.10f}'.format(res[i]), end=' ')\n    print('{:.10f}'.format(res[-1]))\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom typing import List, Tuple\n\n\ndef project(point: complex, begin: complex, end: complex) -> complex:\n    tmp = (point - begin) / (end - begin)\n    return tmp.real * (end - begin) + begin\n\n\nif __name__ == \"__main__\":\n    x, y, r = map(int, input().split())\n    c = complex(x, y)\n    ans: List[Tuple[float, float, float, float]] = []\n    q = int(input())\n\n    for _ in range(q):\n        res = []\n        x, y, z, w = map(int, input().split())\n        p1, p2 = complex(x, y), complex(z, w)\n        proj = project(c, p1, p2)\n        for i in (-1, 1):\n            res.append(proj + i * sqrt(\n                       r**2 - abs(c - proj)**2) * (p2 - p1) / abs(p2 - p1))\n        res.sort(key=lambda x: (x.real, x.imag))\n        ans.append((res[0].real, res[0].imag, res[1].real, res[1].imag))\n\n    for a in ans:\n        print(\"{:.6f} {:.6f} {:.6f} {:.6f}\".format(*a))\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2*b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n\n        if XA < 0.000001: XA = 0\n        if YA < 0.000001: YA = 0\n        if XB < 0.000001: XB = 0\n        if YB < 0.000001: YB = 0\n            \n        print \"%.8f %.8f %.8f %.8f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1 - y2) / (x1 - x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1 - x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        if XA < 0.000001: XA = 0\n        if YA < 0.000001: YA = 0\n        if XB < 0.000001: XB = 0\n        if YB < 0.000001: YB = 0\n        \n        if XA == XB and YA > YB:\n            print \"%.9f %.9f %.9f %.9f\" % (XB, YB, XA, YA)\n        else:\n            print \"%.9f %.9f %.9f %.9f\" % (XA, YA, XB, YB)\n    "
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, x, y, r):\n        self.centre = x + y * 1j\n        self.radius = r\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    p1, p2 = prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n    if p1.real <= p2.real and p1.imag <= p2.imag:\n        ans = (p1, p2)\n    else:\n        ans = (p2, p1)\n    return ans\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cp1, cp2 = get_cross_point(circle, l)\n        print('{0:.8f} {1:.8f} {2:.8f} {3:.8f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, radius = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx, cy, radius)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nimport math\n\nclass Vector:\n    def __init__(self, x=None, y=None):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, k):\n        return Vector(self.x * k, self.y * k)\n\n    def __truediv__(self, k):\n        return Vector(self.x / k, self.y / k)\n\n    def __gt__(self, other):\n        return self.x > other.x and self.y > other.yb\n\n    def __lt__(self, other):\n        return self.x < other.x and self.y < other.yb\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    # usually cross operation return Vector but it returns scalor\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        return math.sqrt(self.norm())\n\nclass Point(Vector):\n    def __init__(self, *args, **kargs):\n        return super().__init__(*args, **kargs)\n\nclass Segment:\n    def __init__(self, p1=Point(0, 0), p2=Point(1, 1)):\n        self.p1 = p1\n        self.p2 = p2\n\nclass Line(Segment):\n    def __init__(self, *args, **kargs):\n        return super().__init__(*args, **kargs)\n\nclass Circle:\n    def __init__(self, c=Point(0, 0), r=1):\n        self.c = c\n        self.r = r\n\ndef project(s, p):\n    base = s.p2 - s.p1\n    hypo = p - s.p1\n    r = hypo.dot(base) / base.norm()\n    return s.p1 + base * r\n\ndef get_cross_point(c, l):\n    pr = project(l, c.c)\n    e = (l.p1- l.p2) / (l.p2 - l.p1).abs()\n    base = math.sqrt( c.r * c.r - (pr - c.c).norm() )\n    return pr + e * base, pr - e * base\n\ndef read_and_print_results(n, c):\n    for _ in range(n):\n        line = stdin.readline().strip().split()\n        p0 = Vector(int(line[0]), int(line[1]))\n        p1 = Vector(int(line[2]), int(line[3]))\n        l = Line(p0, p1)\n        p2, p3 = get_cross_point(c, l)\n        print(\"{0:0.8f} {1:0.8f} {2:0.8f} {3:0.8f}\".format(p2.x, p2.y, p3.x, p3.y))\n\nx, y, r = [ int(i) for i in input().split() ]\nc = Circle(Point(x, y), r)\nn = int(input())\nread_and_print_results(n, c)\n"
  },
  {
    "language": "Python",
    "code": "def dot(c1, c2):\n    return c1.real * c2.real + c1.imag * c2.imag\n\ndef cross(c1, c2):\n    return c1.real * c2.imag - c1.imag * c2.real\n\ndef project(p1, p2, p3):\n    # p1 and p2 is are points on the line.\n    # return the projection point x of p3 onto the line.\n    base = p2 - p1\n    return p1 + base * dot(p3 - p1, base) / (abs(base) ** 2)\n\ndef print_cross_point(c, r, p1, p2):\n    # c is the center of the circle and r is the radius of the circle.\n    # p1 and p2 are are points on the line.\n    pr = project(p1, p2, c)\n    l = p2 - p1\n    e = l / abs(l)\n    base = (r ** 2 - abs(pr - c) ** 2) ** 0.5\n    c_p1 = pr - e * base\n    c_p2 = pr + e * base\n    print(\"{0:.10f} {1:.10f} {2:.10f} {3:.10f}\".format(c_p1.real, c_p1.imag,\n                                                       c_p2.real, c_p2.imag))\n\n\nimport sys\n\nfile_input = sys.stdin\n\ncx, cy, r = map(int, file_input.readline().split())\nc = cx + cy * 1j\n\nq = file_input.readline()\n\nfor line in file_input:\n    x1, y1, x2, y2 = map(int, line.split())\n    p1 = x1 + y1 * 1j\n    p2 = x2 + y2 * 1j\n    if x1 < x2:\n        print_cross_point(c, r, p1, p2)\n    elif x1 > x2 or y1 > y2:\n        print_cross_point(c, r, p2, p1)\n    else:\n        print_cross_point(c, r, p1, p2)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport sys\nimport math\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, x, y, r):\n        self.centre = x + y * 1j\n        self.radius = r\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    p1, p2 = prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base\n\n    if p1.real < p2.real:\n        ans = (p1, p2)\n    elif p1.real == p2.real:\n        if p1.imag < p2.imag:\n            ans = (p1, p2)\n        else:\n            ans = (p2, p1)\n    else:\n        ans = (p2, p1)\n    return ans\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cp1, cp2 = get_cross_point(circle, l)\n        print('{0:.8f} {1:.8f} {2:.8f} {3:.8f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, radius = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx, cy, radius)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef unit(a):\n    return a / abs(a)\n\n\ndef near_pos_online(p, a, b):\n    unit_a_b = unit(b - a)\n    dist_from_a = dot(unit_a_b, p - a)\n    return a + unit_a_b * dist_from_a\n\n\ndef intersection_of_circle_and_line(center, r, a, b):\n    near = near_pos_online(center, a, b)\n    d = sqrt(r ** 2 - abs(center - near) ** 2) * unit(b - a)\n    return [near + d, near - d]\n\n\nfrom math import sqrt\nfrom operator import attrgetter\ndef main():\n    cx, cy, r = map(int, readline().split())\n    center = complex(cx, cy)\n    q = int(readline())\n    for i in range(q):\n        x1, y1, x2, y2 = map(int, readline().split())\n        a, b = complex(x1, y1), complex(x2, y2)\n        intersection = intersection_of_circle_and_line(center, r, a, b)\n        intersection.sort(key=attrgetter('real', 'imag'))\n        pre, post = intersection\n\n        print(*list(map('{:.6f}'.format, [pre.real, pre.imag, post.real, post.imag])))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = math.sqrt(r*r-(abs(pro-p2)**2))\n  if pro-e*base.real == pro+e*base.real:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.image)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.image)\n  else:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.real)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.real)\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(*get_cross_point(p0,p1,p2))\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n    def __mul__(self, other):\n        return Point(self.x * other, self.y * other)\n    def __truediv__(self, other):\n        return Point(self.x / other, self.y / other)\n    def __repr__(self):\n        return str(round(self.x, 8)) + ' ' + str(round(self.y, 8))\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        else:\n            return self.x < other.x\n\nclass Vector(Point):\n    pass\n\nclass Line:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\nclass Segment(Line):\n    pass\n\nclass Circle:\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\ndef points_to_vector(p1, p2):\n    x = p1.x - p2.x\n    y = p1.y - p2.y\n    return Vector(x, y)\n\ndef vector(p):\n    return Vector(p.x, p.y)\n\ndef dot(v1, v2):\n    return v1.x * v2.x + v1.y * v2.y\n\ndef cross(v1, v2):\n    return v1.x * v2.y - v1.y * v2.x\n\ndef norm(v):\n    return v.x**2 + v.y**2\n\ndef distance(v):\n    return math.sqrt(norm(v))\n\ndef project(s, p):\n    base = points_to_vector(s.p1, s.p2)\n    hypo = points_to_vector(p, s.p1)\n    r = dot(hypo, base) / norm(base)\n    return s.p1 + base * r\n\ndef reflect(s, p):\n    return p + (project(s, p) -p) * 2\n\ndef get_distance(s1, s2):\n    if intersect_s(s1, s2):\n        return 0\n    d1 = get_distance_sp(s1, s2.p1)\n    d2 = get_distance_sp(s1, s2.p2)\n    d3 = get_distance_sp(s2, s1.p1)\n    d4 = get_distance_sp(s2, s1.p2)\n    return min(d1, min(d2, min(d3, d4)))\n\ndef get_distance_pp(p1, p2):\n    return distance(p1 - p2)\n\ndef get_distance_lp(l, p):\n    return abs(cross(l.p2 - l.p1, p - l.p1) / distance(l.p2 - l.p1))\n\ndef get_distance_sp(s, p):\n    if dot(s.p2 - s.p1, p - s.p1) < 0:\n        return distance(p - s.p1)\n    elif dot(s.p1 - s.p2, p - s.p2) < 0:\n        return distance(p - s.p2)\n    else:\n        return get_distance_lp(s, p)\n\ndef ccw(p0, p1, p2):\n    EPS = 1e-10\n    COUNTER_CLOCKWISE = 1\n    CLOCKWISE = -1\n    ONLINE_BACK = 2\n    ONLINE_FRONT = -2\n    ON_SEGMENT = 0\n    v1 = p1 - p0\n    v2 = p2 - p0\n    if cross(v1, v2) > EPS:\n        return COUNTER_CLOCKWISE\n    elif cross(v1, v2) < -EPS:\n        return CLOCKWISE\n    elif dot(v1, v2) < -EPS:\n        return ONLINE_BACK\n    elif norm(v1) < norm(v2):\n        return ONLINE_FRONT\n    else:\n        return ON_SEGMENT\n\ndef intersect_p(p1, p2, p3, p4):\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\ndef intersect_s(s1, s2):\n    return intersect_p(s1.p1, s1.p2, s2.p1, s2.p2)\n\ndef get_cross_point(s1, s2):\n    base = s2.p2 - s2.p1\n    d1 = abs(cross(base, s1.p1 - s2.p1))\n    d2 = abs(cross(base, s1.p2 - s2.p1))\n    t = d1 / (d1 + d2)\n    return s1.p1 + (s1.p2 - s1.p1) * t\n\ndef get_cross_points(c, l):\n    pr = project(l, c.c)\n    e = (l.p2 - l.p1) / distance(l.p2 - l.p1)\n    base = math.sqrt(c.r**2 - norm(pr - c.c))\n    return pr + e * base, pr - e * base\n\nimport sys\n# sys.stdin = open('input.txt')\n\ntemp = list(map(int, input().split()))\nc = Circle(Point(temp[0], temp[1]), temp[2])\nq = int(input())\n\nfor i in range(q):\n    temp = list(map(int, input().split()))\n    points = []\n    for j in range(0, 4, 2):\n        points.append(Point(temp[j], temp[j+1]))\n    l = Line(points[0], points[1])\n    ans = get_cross_points(c, l)\n    print(min(ans), max(ans))\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x1 - x0)**2)\n        print XA, YA, XB, YB\n    else:\n        m = (y1-y2) / (x1-x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1-x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        print XA, YA, XB, YB\n    "
  },
  {
    "language": "Python",
    "code": "cx, cy, r = map(int, input().split())\nq = int(input())\nfor _ in range(q):\n    x1, y1, x2, y2 = map(int, input().split())\n    dx, dy = x2 - x1, y2 - y1\n    px, py = cx - x1, cy - y1\n    s2 = dx ** 2 + dy ** 2\n    dot = dx * px + dy * py\n    crs = dx * py - dy * px\n    t1 = (dot + (s2 * r ** 2 - crs ** 2) ** 0.5) / s2\n    t2 = (dot - (s2 * r ** 2 - crs ** 2) ** 0.5) / s2\n    if (dx < 0) ^ (t1 > t2):\n        t1, t2 = t2, t1\n    print(x1 + dx * t1, y1 + dy * t1, x1 + dx * t2, y1 + dy * t2)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def __truediv__(self, scalar):\n        return Vector2(self.x/scalar, self.y/scalar)\n\n    def abs2(self):\n        return float(self.x * self.x + self.y * self.y)\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) / abs(p2 - p1)\n    base = math.sqrt(c.r*c.r - (pr - c.c).abs2())\n    return [pr + e * base, pr - e * base]\n\nif __name__ == '__main__':\n\n    a, b, r = map(int, input().split())\n    c = Circle(Vector2(a, b), r)\n    n = int(input())\n    res = []\n    for _ in range(n):\n        ps = list(map(int, input().split()))\n        l = [Vector2(ps[0], ps[1]), Vector2(ps[2], ps[3])]\n\n        ans = getCrossPoints(c, l)\n        ans = sorted(ans, key=lambda x: (x.x, x.y))\n        res.append(ans)\n        \n    for ans in res:\n        print(\"{:.8f} {:.8f} {:.8f} {:.8f}\".format(ans[0].x, ans[0].y, ans[1].x, ans[1].y))\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\n\n\"\"\"\nimport sys\nfrom math import sqrt\nfrom sys import stdin\ninput = stdin.readline\n\n\nclass Point(object):\n    epsilon = 1e-10\n\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Point(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Point(self.x / other, self.y / other)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        else:\n            return self.x < other.x\n\n    def __eq__(self, other):\n        from math import fabs\n        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:\n            return True\n        else:\n            return False\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def __abs__(self):\n        return sqrt(self.norm())\n\n    def ccw(self, p0, p1):\n        # ??????2???(p0, p1)?????????????????????????????????????????¢????????????\n        a = Vector(p1 - p0)\n        b = Vector(self - p0)\n        if Vector.cross(a, b) > Point.epsilon:\n            return 1 # 'COUNTER_CLOCKWISE'\n        elif Vector.cross(a, b) < -Point.epsilon:\n            return -1 # 'CLOCKWISE'\n        elif Vector.dot(a, b) < -Point.epsilon:\n            return 2 # 'ONLINE_BACK'\n        elif a.norm() < b.norm():\n            return -2 # 'ONLINE_FRONT'\n        else:\n            return 0 # 'ON_SEGMENT'\n\n    def project(self, s):\n        # ??????(Point)????????????s??????????????????????????????????????§?¨?(?°???±)????±???????\n        base = Vector(s.p2 - s.p1)\n        a = Vector(self - s.p1)\n        r = Vector.dot(a, base)\n        r /= base.norm()\n        return s.p1 + base * r\n\n    def reflect(self, s):\n        # ??????s???????§°?????¨?????????????????¨???????§°??????????????§?¨?(????°?)????±???????\n        proj = self.project(s)\n        return self + (proj - self)*2\n\n    def distance(self, s):\n        # ????????¨??????s????????¢????¨??????????\n        if Vector.dot(s.p2-s.p1, self-s.p1) < 0.0:\n            return abs(self - s.p1)\n        if Vector.dot(s.p1-s.p2, self-s.p2) < 0.0:\n            return abs(self - s.p2)\n        return abs(Vector.cross(s.p2-s.p1, self-s.p1) / abs(s.p2-s.p1))\n\n\nclass Vector(Point):\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        elif isinstance(x, Point):\n            self.x = x.x\n            self.y = x.y\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Vector(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Vector(other / self.x, other / self.y)\n\n    @classmethod\n    def dot(cls, a, b):\n        return a.x * b.x + a.y * b.y\n\n    @classmethod\n    def cross(cls, a, b):\n        return a.x * b.y - a.y * b.x\n\n    @classmethod\n    def is_orthogonal(cls, a, b):\n        return Vector.dot(a, b) == 0.0\n\n    @classmethod\n    def is_parallel(cls, a, b):\n        return Vector.cross(a, b) == 0.0\n\n\nclass Segment(object):\n    def __init__(self, p1=Point(), p2=Point()):\n        if isinstance(p1, Point):\n            self.p1 = p1\n            self.p2 = p2\n        elif isinstance(p1, tuple):\n            self.p1 = Point(p1[0], p1[1])\n            self.p2 = Point(p2[0], p2[1])\n\n    def intersect(self, s):\n        # ????????¨??????????????????????????????????????????????????????\n        ans1 = s.p1.ccw(self.p1, self.p2) * s.p2.ccw(self.p1, self.p2)\n        ans2 = self.p1.ccw(s.p1, s.p2) * self.p2.ccw(s.p1, s.p2)\n        return ans1 <= 0 and ans2 <= 0\n\n    def cross_point(self, s):\n        # ????????¨??????????????????????????????????????§?¨?????±???????\n        base = s.p2 - s.p1\n        d1 = abs(Vector.cross(base, self.p1-s.p1))\n        d2 = abs(Vector.cross(base, self.p2-s.p1))\n        t = d1 / (d1 + d2)\n        return self.p1 + (self.p2 - self.p1) * t\n\n    def distance(self, s):\n        # ????????¨?????????????????????????????¢????±???????\n        if self.intersect(s):\n            return 0.0\n        d1 = s.p1.distance(self)\n        d2 = s.p2.distance(self)\n        d3 = self.p1.distance(s)\n        d4 = self.p2.distance(s)\n        return min(d1, d2, d3, d4)\n\n\n    @classmethod\n    def is_orthogonal(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_orthogonal(a, b)\n\n    @classmethod\n    def is_parallel(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_parallel(a, b)\n\n\nclass Line(Segment):\n    pass\n\n\nclass Cirle(object):\n    def __init__(self, x, y=Point(), r=1.0):\n        if isinstance(x, Point):\n            self.c = x\n            self.r = y\n        elif isinstance(x, tuple):\n            self.c = Point(x[0], x[1])\n            self.r = r\n\n    def cross_point(self, s):\n        pr = self.c.project(s)\n        e = (s.p2 - s.p1) / abs(s.p2 - s.p1)\n        base = sqrt(self.r * self.r - (pr - self.c).norm())\n        return pr + e * base, pr - e * base\n\n\ndef main(args):\n    x, y, r = map(int, input().split())\n    q = int(input())\n    c = Cirle(Point(x, y), r)\n    for _ in range(q):\n        x1, y1, x2, y2 = map(int, input().split())\n        p1 = Point(x1, y1)\n        p2 = Point(x2, y2)\n        s = Segment(p1, p2)\n        ans1, ans2 = c.cross_point(s)\n        if ans1.x < ans2.x:\n            print('{:.8f} {:.8f} {:.8f} {:.8f}'.format(ans1.x, ans1.y, ans2.x, ans2.y))\n        elif ans1.x == ans2.x and ans1.y <= ans2.y:\n            print('{:.8f} {:.8f} {:.8f} {:.8f}'.format(ans1.x, ans1.y, ans2.x, ans2.y))\n        else:\n            print('{:.8f} {:.8f} {:.8f} {:.8f}'.format(ans2.x, ans2.y, ans1.x, ans1.y))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math\n\ndef solve(a,b,c):\n    # square equation ax**2 + 2*b*x + c == 0\n    return (-b - math.sqrt(b**2 - a*c)) / a, (-b + math.sqrt(b**2 - a*c)) / a\n\nx0, y0, r = map(float, raw_input().split())\nq = int(raw_input())\nfor i in range(q):\n    x1, y1, x2, y2 = map(float, raw_input().split())\n    # line: y = mx + n\n    # (x - x0)**2 + (y - y0)**2 == r**2\n    # erase y\n    # cross points A and B\n    \n    if x1 - x2 == 0: # x1 == x2\n        XA = x1\n        XB = x2\n        YA = y0 + math.sqrt(r**2 - (x1 - x0)**2)\n        YB = y0 - math.sqrt(r**2 - (x2 - x0)**2)\n\n        if XA <= 1e-6: XA = 0\n        if YA <= 1e-6: YA = 0\n        if XB <= 1e-6: XB = 0\n        if YB <= 1e-6: YB = 0\n            \n        print \"%.6f %.6f %.6f %.6f\" % (XA, YA, XB, YB)\n    else:\n        m = (y1 - y2) / (x1 - x2)\n        n = (2*x1*y1 - x2*y1 - x1*y2) / (x1 - x2)\n\n        a_solve = m**2 + 1\n        b_solve = m*(n - y0) - x0\n        c_solve = x0**2 + (n - y0)**2 - r**2\n    \n        XA, XB = solve(a_solve, b_solve, c_solve)\n        YA = m * XA + n\n        YB = m * XB + n\n        if XA <= 1e-6: XA = 0\n        if YA <= 1e-6: YA = 0\n        if XB <= 1e-6: XB = 0\n        if YB <= 1e-6: YB = 0\n        \n        if XA == XB and YA > YB:\n            print \"%.6f %.6f %.6f %.6f\" % (XB, YB, XA, YA)\n        else:\n            print \"%.6f %.6f %.6f %.6f\" % (XA, YA, XB, YB)\n    "
  },
  {
    "language": "Python",
    "code": "from functools import singledispatch\nimport math\n\nEPS = 1e-10\n\nCOUNTER_CLOCKWISE = 1\nCLOCKWISE = -1\nONLINE_BACK = 2\nONLINE_FRONT = -2\nON_SEGMENT = 0\n\nclass Segment():\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, point):\n        # + 演算子での挙動を指定\n        return Point(self.x+point.x, self.y+point.y)\n\n    def __sub__(self, point):\n        # - 演算子での挙動を指定\n        return Point(self.x-point.x, self.y-point.y)\n\n    def __mul__(self, a):\n        # * 演算子での挙動を指定\n        return Point(a*self.x, a*self.y)\n\n    def __truediv__(self, a):\n        # / 演算子での挙動を指定\n        return Point(self.x/a, self.y/a)\n\n    def __abs__(self):\n        # abs関数での挙動を指定\n        return math.sqrt(self.norm())\n\n    def norm(self):\n        return self.x**2+self.y**2\n\n    def __eq__(self, point):\n        # == 演算子での挙動を指定\n        return abs(self.x-point.x) < EPS and abs(self.y-point.y) <EPS\n\ndef dot(a, b):\n    return a.x*b.x+a.y*b.y\n\ndef cross(a, b):\n    return a.x*b.y - a.y*b.x\n\ndef isOrthogonal(a, b):\n    return dot(a, b) == 0\n\ndef isParallel(a, b):\n    return cross(a, b) == 0\n\ndef project(s, p):\n    #s: Segment(), p: Point()\n    base = s.p2 - s.p1\n    r = dot(p-s.p1, base)/base.norm()\n    return s.p1+base*r\n\ndef reflect(s, p):\n    return p+(project(s, p)-p)*2\n\n@singledispatch\ndef get_distance(a, b):\n    return abs(a-b)\n\ndef get_distance_lp(l, p):\n    return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1))\n\ndef get_distance_sp(s, p):\n    if dot(s.p2-s.p1, p-s.p1) < 0:\n        return abs(p-s.p1)\n    if dot(s.p1-s.p2, p-s.p2) < 0:\n        return abs(p-s.p2)\n    return get_distance_lp(s, p)\n    \n@get_distance.register(Segment)\ndef _(s1, s2):\n    if intersect(s1, s2):\n        return 0\n    return min([get_distance_sp(s1, s2.p1), get_distance_sp(s1, s2.p2),\n                get_distance_sp(s2, s1.p1), get_distance_sp(s2, s1.p2)])\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > EPS:\n        return COUNTER_CLOCKWISE\n    if cross(a, b) < -EPS:\n        return CLOCKWISE\n    if dot(a, b) < -EPS:\n        return ONLINE_BACK\n    if a.norm() < b.norm():\n        return ONLINE_FRONT\n    return ON_SEGMENT\n\n@singledispatch\ndef intersect(p1, p2, p3, p4):\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0\n            and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0)\n\n@intersect.register(Segment)\ndef _(s1, s2):\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2)\n\ndef get_cross_point(s1, s2):\n    base = s2.p2 - s2.p1\n    d1 = abs(cross(base, s1.p1-s2.p1))\n    d2 = abs(cross(base, s1.p2-s2.p1))\n    t = d1/(d1+d2)\n    return s1.p1 + (s1.p2-s1.p1)*t\n\ndef get_cross_points(c, l):\n    # 以下のコードは、新しいintersect関数を作る必要があり(おそらくpython3.7以上必須)、手間取るので割愛します。\n    # assert(intersect(c, l))\n    pr = project(l, c.c)\n    e = (l.p2 - l.p1)/abs(l.p2-l.p1)\n    base = (c.r**2-(pr-c.c).norm())**0.5\n    return (pr+e*base, pr-e*base)\n    \n\nif __name__ == '__main__':\n    from sys import stdin\n    input = stdin.readline\n\n    cx, cy, r = map(int, input().split())\n    center = Point(cx, cy)\n    c = Circle(center, r)\n\n    q = int(input())\n    for _ in range(q):\n        x1, y1, x2, y2 = map(int, input().split())\n        p1 = Point(x1, y1)\n        p2 = Point(x2, y2)\n        l = Segment(p1, p2)\n        ans1, ans2 = get_cross_points(c, l)\n        for ans in [ans1, ans2]:\n            if round(ans.x, 10) == 0:\n                ans.x = 0\n            if round(ans.y, 10) == 0:\n                ans.y = 0\n        if ans1.x < ans2.x or (ans1.x == ans2.x and ans1.y < ans2.y):\n            \n            print(ans1.x, ans1.y, ans2.x, ans2.y)\n        else:\n            print(ans2.x, ans2.y, ans1.x, ans1.y)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n2 1 1\n2\n0 1 4 1\n3 0 3 3\n\noutput:\n1.00000000 1.00000000 3.00000000 1.00000000\n3.00000000 1.00000000 3.00000000 1.00000000\n\"\"\"\n\nimport math\nimport sys\nfrom operator import attrgetter\n\n\nclass Segment(object):\n    __slots__ = ('source', 'target')\n\n    def __init__(self, source, target):\n        self.source = complex(source)\n        self.target = complex(target)\n\n\nclass Circle(object):\n    __slots__ = ('centre', 'radius')\n\n    def __init__(self, centre, radius):\n        self.centre = complex(centre)\n        self.radius = float(radius)\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef project(s, p):\n    base_vector = s.target - s.source\n    prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n    return s.source + base_vector * prj_ratio\n\n\ndef get_cross_point(c, l):\n    prj_vector = project(l, c.centre)\n    line_unit_vector = (l.target - l.source) / (abs(l.target - l.source))\n    base = math.sqrt(pow(c.radius, 2) - pow(abs(prj_vector - c.centre), 2))\n    ans = [prj_vector + line_unit_vector * base, prj_vector - line_unit_vector * base]\n\n    ans.sort(key=attrgetter('real', 'imag'))\n    return ans\n\n\ndef solve(_lines):\n    for line in _lines:\n        line_axis = tuple(map(int, line))\n        p0, p1 = (x + y * 1j for x, y in zip(line_axis[::2], line_axis[1::2]))\n        l = Segment(p0, p1)\n        cp1, cp2 = get_cross_point(circle, l)\n        print('{0:.8f} {1:.8f} {2:.8f} {3:.8f}'.format(cp1.real, cp1.imag, cp2.real, cp2.imag))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n\n    cx, cy, r = map(int, _input[0].split())\n    q_num = int(_input[1])\n    lines = map(lambda x: x.split(), _input[2:])\n\n    circle = Circle(cx + cy * 1j, r)\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef solve(cx, cy, r, x1, y1, x2, y2):\n    xd = x2 - x1; yd = y2 - y1\n    X = x1 - cx; Y = y1 - cy\n    a = xd**2 + yd**2\n    b = xd * X + yd * Y\n    c = X**2 + Y**2 - r**2\n    D = b**2 - a*c\n    s1 = (-b + sqrt(D)) / a\n    s2 = (-b - sqrt(D)) / a\n    return (x1 + xd*s1, y1 + yd*s1), (x1 + xd*s2, y1 + yd*s2)\ncx, cy, r = map(int, raw_input().split())\nq = input()\nfor i in xrange(q):\n    x1, y1, x2, y2 = map(int, raw_input().split())\n\n    p0, p1 = sorted(solve(cx, cy, r, x1, y1, x2, y2))\n    print \"%.08f %.08f %.08f %.08f\" % (p0 + p1)"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ncx,cy,r = map(int,input().split())\nc = [cx, cy]\nq = int(input())\n\nclass Line:pass\n\ndef dot(a, b):\n    return sum([i * j for i,j in zip(a, b)])\ndef add(a,b):\n    return [a[0] + b[0],a[1] + b[1]]\ndef sub(a, b):\n    return [a[0] - b[0],a[1] - b[1]]\ndef multi(k, a):\n    return [k*a[0],k*a[1]]\ndef cross(a, b):\n    return  a[0] * b[1] - a[1] * b[0]\ndef norm(a):\n    return sqrt(a[0] ** 2 + a[1] ** 2)    \ndef proj(p, l):\n    base = sub(l.p2, l.p1)\n    hypo = sub(p, l.p1)\n    t = dot(hypo,base) / norm(base)\n    return add(l.p1, multi(t/norm(base), base))\n    \nfor i in range(q):\n    x1,y1,x2,y2 = map(int, input().split())\n    l = Line()\n    l.p1 = [x1,y1]\n    l.p2 = [x2,y2]\n    pr = proj(c, l)\n    e = multi(1/norm(sub(l.p2, l.p1)),sub(l.p2, l.p1))\n    e2 = multi(-1, e)\n    base = sqrt(r**2 - norm(sub(pr,c))**2)\n    a = add(pr, multi(base, e))\n    b = add(pr, multi(base, e2))\n    ans = [a,b]\n    ans = sorted(ans, key=lambda x: (x[0],x[1]))\n    print(' '.join([str(round(i,8)) for o in ans for i in o]))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom operator import itemgetter, attrgetter\nfrom itertools import starmap\nimport math\nreadline = sys.stdin.readline\nEPS = 1e-9\nONLINE_FRONT = -2\nCLOCKWISE = -1\nON_SEGMENT = 0\nCOUNTER_CLOCKWISE = 1\nONLINE_BACK = 2\nclass Circle(object):\n    __slots__ = ('c', 'r')\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\nclass Segment(object):\n    __slots__ = ('fi', 'se')\n    def __init__(self, fi, se):\n        self.fi = fi\n        self.se = se\nLine = Segment\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\ndef norm(base):\n    return abs(base) ** 2\ndef project(s, p2):\n    base = s.fi - s.se\n    r = dot(p2 - s.fi, base) / norm(base)\n    return s.fi + base * r\ndef reflect(s, p):\n    return p + (project(s, p) - p) * 2.0\ndef ccw(p1, p2, p3):\n    a = p2 - p1\n    b = p3 - p1\n    if cross(a, b) > EPS: return 1\n    if cross(a, b) < -EPS: return -1\n    if dot(a, b) < -EPS: return 2\n    if norm(a) < norm(b): return -2\n    return 0\ndef intersect4(p1, p2, p3, p4):\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0)\ndef intersect2(s1, s2):\n    return intersect4(s1.fi, s1.se, s2.fi, s2.se)\ndef getDistance(a, b):  return abs(a - b)\ndef getDistanceLP(l, p):\n    return abs(cross(l.se - l.fi, p - l.fi) / abs(l.se - l.fi))\ndef getDistanceSP(s, p):\n    if dot(s.se - s.fi, p - s.fi) < 0.0: return abs(p - s.fi)\n    if dot(s.fi - s.se, p - s.se) < 0.0: return abs(p - s.se)\n    return getDistanceLP(s, p)\ndef getDistances(s1, s2):\n    if intersect2(s1, s2): return 0.0\n    return min(getDistanceSP(s1, s2.fi), getDistanceSP(s1, s2.se),\n               getDistanceSP(s2, s1.fi), getDistanceSP(s2, s1.se))\ndef getCrossPoint(s1, s2):\n\tbase = s2.se - s2.fi\n\td1 = abs(cross(base, s1.fi - s2.fi))\n\td2 = abs(cross(base, s1.se - s2.fi))\n\tt = d1 / (d1 + d2)\n\treturn s1.fi + (s1.se - s1.fi) * t\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    e = (l.se - l.fi) / abs(l.se - l.fi)\n    base = math.sqrt(c.r * c.r - norm(pr - c.c))\n    return Segment(*sorted((pr + e * base, pr - e * base), key=attrgetter('real', 'imag')))\nx, y, r = map(int, readline().split())\nci = Circle(complex(x, y), r)\nn = int(readline())\nfor _ in [0] * n:\n    p0, p1 = starmap(complex, zip(*[map(int, readline().split())] * 2))\n    ppp = getCrossPoints(ci, Line(p0, p1))\n    print(*map('{:.10f}'.format, (ppp.fi.real, ppp.fi.imag, ppp.se.real, ppp.se.imag)))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def __truediv__(self, scalar):\n        return Vector2(self.x/scalar, self.y/scalar)\n\n    def abs2(self):\n        return float(self.x * self.x + self.y * self.y)\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) / abs(p2 - p1))\n    base = math.sqrt(c.r*c.r - (pr - c.c).abs2())\n    return [pr + e * base, pr - e * base]\n\nif __name__ == '__main__':\n\n    a, b, r = map(int, input().split())\n    c = Circle(Vector2(a, b), r)\n    n = int(input())\n    for _ in range(n):\n        ps = list(map(int, input().split()))\n        l = [Vector2(ps[0], ps[1]), Vector2(ps[2], ps[3])]\n\n        ans = getCrossPoints(c, l)\n        ans = sorted(ans, key=lambda x: (x.x, x.y))\n        print(ans[0].x, ans[0].y, ans[1].x, ans[1].y)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve_eq(a,b,c):\n    return (-b-(b**2-4*a*c)**0.5)/(2*a),(-b+(b**2-4*a*c)**0.5)/(2*a)\n\ndef ret_line(x1,y1,x2,y2):\n    k = (y1-y2)/(x1-x2)\n    d = y1-k*x1\n    return k,d\n    \nx,y,r = map(float,input().split())\nq = int(input())\nx1,y1,x2,y2 = [],[],[],[]\nfor i in range(q):\n    arr = list(map(float,input().split()))\n    x1.append(arr[0])\n    y1.append(arr[1])\n    x2.append(arr[2])\n    y2.append(arr[3])\n\nfor i in range(q):\n    if x1[i] != x2[i]:\n        k,d = ret_line(x1[i],y1[i],x2[i],y2[i])\n        p1,p2 = solve_eq(1+k**2,2*k*d-2*k*y-2*x,x**2+y**2+d**2-2*y*d-r**2)\n        print(p1,k*p1+d,p2,k*p2+d)\n    if x1[i] == x2[i]:\n        p1,p2 = solve_eq(1,-2*y,y**2+(x1[i]-x)**2-r**2)\n        print(x1[i],p1,x1[i],p2)"
  },
  {
    "language": "Python",
    "code": "from math import pi, cos, sin, atan2\nEPS = 10**(-9)\n\ndef eq(value1, value2):\n    return abs(value1-value2) <= EPS\n\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.arg = atan2(y, x) # -PI ~ PI\n    \n    def __str__(self):\n        return \"{0:.8f} {1:.8f}\".format(self.x, self.y)\n    \n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, scal):\n        return Point(self.x*scal, self.y*scal)\n    \n    def __truediv__(self, scal):\n        return Point(self.x/scal, self.y/scal)\n    \n    def __eq__(self, other):\n        return eq(self.x, other.x) and eq(self.y, other.y)\n\n    # 原点からの距離\n    def __abs__(self):\n        return (self.x**2+self.y**2)**0.5\n    \n# 原点を中心にrad角だけ回転した点\ndef Rotation(vec: Point, rad):\n    return Point(vec.x*cos(rad)-vec.y*sin(rad), vec.x*sin(rad)+vec.y*cos(rad))\n\n\nclass Circle():\n    def __init__(self, p, r):\n        self.p = p\n        self.r = r\n\n\nclass Line():\n    # 点a, bを通る\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n        self.arg = (a-b).arg % pi\n    \n    def __str__(self):\n        return \"[({0}, {1}) - ({2}, {3})]\".format(self.a.x, self.a.y, self.b.x, self.b.y)\n\n    # pointを通って平行\n    def par(self, point):\n        return Line(point, point+(self.a-self.b))\n\n    # pointを通って垂直\n    def tan(self, point):\n        return Line(point, point + Rotation(self.a-self.b, pi/2))\n\n\nclass Segment(Line):\n    def __init__(self, a, b):\n        super().__init__(a, b)\n\n\n# 符号付き面積\ndef cross(vec1: Point, vec2: Point):\n    return vec1.x*vec2.y - vec1.y*vec2.x\n\n# 内積\ndef dot(vec1: Point, vec2: Point):\n    return vec1.x*vec2.x + vec1.y*vec2.y\n\n# 点a->b->cの回転方向\ndef ccw(a, b, c):\n    if cross(b-a, c-a) > EPS: return +1 # COUNTER_CLOCKWISE\n    if cross(b-a, c-a) < -EPS: return -1 # CLOCKWISE\n    if dot(c-a, b-a) < -EPS: return +2 # c -> a -> b\n    if abs(b-a) < abs(c-a): return -2 # a -> b -> c\n    return 0 # a -> c -> b\n\n\n# pのlへの射影\ndef projection(l, p):\n    t = dot(l.b-l.a, p-l.a) / abs(l.a-l.b)**2\n    return l.a + (l.b-l.a)*t\n\n# pのlによる反射\ndef reflection(l, p):\n    return p + (projection(l, p) - p)*2\n\ndef isPararell(l1, l2):\n    return eq(cross(l1.a-l1.b, l2.a-l2.b), 0)\n\ndef isVertical(l1, l2):\n    return eq(dot(l1.a-l1.b, l2.a-l2.b), 0)\n\n\ndef isIntersect_lp(l, p):\n    return abs(ccw(l.a, l.b, p)) != 1\n\ndef isIntersect_ll(l1, l2):\n    return not isPararell(l1, l2) or isIntersect_lp(l1, l2.a)\n\ndef isIntersect_sp(s, p):\n    return ccw(s.a, s.b, p) == 0\n\ndef isIntersect_ss(s1, s2):\n    return ccw(s1.a, s1.b, s2.a)*ccw(s1.a, s1.b, s2.b) <= 0 and ccw(s2.a, s2.b, s1.a)*ccw(s2.a, s2.b, s1.b) <= 0\n\ndef isIntersect_ls(l, s):\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS\n\ndef isIntersect_cp(c, p):\n    return abs(abs(c.p - p) - c.r) < EPS\n\ndef isIntersect_cl(c, l):\n    return distance_lp(l, c.p) <= c.r + EPS\n\ndef isIntersect_cs(c, s):\n    pass\n\ndef intersect_cc(c1, c2):\n    if c1.r < c2.r:\n        c1, c2 = c2, c1\n    d = abs(c1.p - c2.p)\n    if eq(c1.r + c2.r, d): return 3 # 内接\n    if eq(c1.r - c2.r, d): return 1 # 外接\n    if c1.r + c2.r < d: return 4 # 含まれてる\n    if c1.r - c2.r < d: return 2 # 2交点持つ\n    return 0 # 離れてる\n\n\ndef distance_pp(p1, p2):\n    return abs(p1-p2)\n\ndef distance_lp(l, p):\n    return abs(projection(l,p)-p)\n\ndef distance_ll(l1, l2):\n    return 0 if isIntersect_ll(l1, l2) else distance_lp(l1, l2.a)\n\ndef distance_sp(s, p):\n    r = projection(s, p)\n    if isIntersect_sp(s, r): return abs(r-p)\n    return min(abs(s.a-p), abs(s.b-p))\n\ndef distance_ss(s1, s2):\n    if isIntersect_ss(s1, s2): return 0\n    return min([distance_sp(s1, s2.a), distance_sp(s1, s2.b), distance_sp(s2, s1.a), distance_sp(s2, s1.b)])\n\ndef distance_ls(l, s):\n    if isIntersect_ls(l, s): return 0\n    return min(distance_lp(l, s.a), distance_lp(l, s.b))\n\n\ndef crosspoint_ll(l1, l2):\n    A = cross(l1.b - l1.a, l2.b - l2.a)\n    B = cross(l1.b - l1.a, l1.b - l2.a)\n    if eq(abs(A), 0) and eq(abs(B), 0): return l2.a\n    return l2.a + (l2.b - l2.a) * B / A\n\ndef crosspoint_ss(s1, s2):\n    return crosspoint_ll(s1, s2)\n\ndef crosspoint_lc(l, c):\n    p = projection(l, c.p)\n    if eq(distance_lp(l, c.p), c.r): return [p]\n    e = (l.b - l.a) / abs(l.b-l.a)\n    dis = (c.r**2-abs(p-c.p)**2)**0.5\n    return [p + e*dis, p - e*dis]\n\ndef crosspoint_sc(s, c):\n    pass\n\ndef crosspoint_cc(c1, c2):\n    d = abs(c1.p-c2.p)\n    if not abs(c1.r-c2.r) <= d <= c1.r+c2.r:\n        return []\n    mid_p = (c2.p * (c1.r**2-c2.r**2+d**2) + c1.p * (c2.r**2-c1.r**2+d**2)) / (2*d**2)\n    tanvec = Rotation(c1.p-c2.p, pi/2)\n    return crosspoint_lc(Line(mid_p, mid_p+tanvec), c1)\n\n\n# pからのcの接点\ndef tangent_cp(c, p):\n    return crosspoint_cc(c, Circle(p, (abs(p-c.p)**2 - c.r**2)**0.5))\n\n\n\n\n\nimport sys\ninput = sys.stdin.readline\n\ndef verify_1A():\n    p1x, p1y, p2x, p2y = map(int, input().split())\n    l = Line(Point(p1x, p1y), Point(p2x, p2y))\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for px, py in Query:\n        p = Point(px, py)\n        print(projection(l, p))\n\ndef verify_1B():\n    p1x, p1y, p2x, p2y = map(int, input().split())\n    l = Line(Point(p1x, p1y), Point(p2x, p2y))\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for px, py in Query:\n        p = Point(px, py)\n        print(reflection(l, p))\n\ndef verify_1C():\n    p1x, p1y, p2x, p2y = map(int, input().split())\n    p1 = Point(p1x, p1y); p2 = Point(p2x, p2y)\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for px, py in Query:\n        p = Point(px, py)\n        result = ccw(p1, p2, p)\n        if result == 1:\n            print(\"COUNTER_CLOCKWISE\")\n        elif result == -1:\n            print(\"CLOCKWISE\")\n        elif result == 2:\n            print(\"ONLINE_BACK\")\n        elif result == -2:\n            print(\"ONLINE_FRONT\")\n        else:\n            print(\"ON_SEGMENT\")\n\ndef verify_2A():\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y in Query:\n        l1 = Line(Point(p0x, p0y), Point(p1x, p1y))\n        l2 = Line(Point(p2x, p2y), Point(p3x, p3y))\n        if isPararell(l1, l2):\n            print(2)\n        elif isVertical(l1, l2):\n            print(1)\n        else:\n            print(0)\n\ndef verify_2B():\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y in Query:\n        s1 = Segment(Point(p0x, p0y), Point(p1x, p1y))\n        s2 = Segment(Point(p2x, p2y), Point(p3x, p3y))\n        if isIntersect_ss(s1, s2):\n            print(1)\n        else:\n            print(0)\n\n\ndef verify_2C():\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y in Query:\n        s1 = Segment(Point(p0x, p0y), Point(p1x, p1y))\n        s2 = Segment(Point(p2x, p2y), Point(p3x, p3y))\n        print(crosspoint_ss(s1, s2))  \n\ndef verify_2D():\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y in Query:\n        s1 = Segment(Point(p0x, p0y), Point(p1x, p1y))\n        s2 = Segment(Point(p2x, p2y), Point(p3x, p3y))\n        print(\"{:.8f}\".format(distance_ss(s1, s2)))\n\ndef verify_7A():\n    c1x, c1y, c1r = map(int, input().split())\n    c2x, c2y, c2r = map(int, input().split())\n    print(intersect_cc(Circle(Point(c1x, c1y), c1r), Circle(Point(c2x, c2y), c2r)))\n\ndef verify_7D():\n    cx, cy, cr = map(int, input().split())\n    c = Circle(Point(cx, cy), cr)\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for x1, y1, x2, y2 in Query:\n        Points = crosspoint_lc(Line(Point(x1, y1), Point(x2,y2)), c)\n        if len(Points) == 1:\n            Points.append(Points[-1])\n        Points.sort(key=lambda p: p.y)\n        Points.sort(key=lambda p: p.x)\n        print(*Points)\n\nverify_7D()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import starmap\nimport math\nreadline = sys.stdin.readline\nEPS = 1e-9\nONLINE_FRONT = -2\nCLOCKWISE = -1\nON_SEGMENT = 0\nCOUNTER_CLOCKWISE = 1\nONLINE_BACK = 2\nclass Circle(object):\n    __slots__ = ('c', 'r')\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\nclass Segment(object):\n    __slots__ = ('fi', 'se')\n    def __init__(self, fi, se):\n        self.fi = fi\n        self.se = se\nLine = Segment\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\ndef norm(base):\n    return abs(base) ** 2\ndef project(s, p2):\n    base = s.fi - s.se\n    r = dot(p2 - s.fi, base) / norm(base)\n    return s.fi + base * r\ndef reflect(s, p):\n    return p + (project(s, p) - p) * 2.0\ndef ccw(p1, p2, p3):\n    a = p2 - p1\n    b = p3 - p1\n    if cross(a, b) > EPS: return 1\n    if cross(a, b) < -EPS: return -1\n    if dot(a, b) < -EPS: return 2\n    if norm(a) < norm(b): return -2\n    return 0\ndef intersect4(p1, p2, p3, p4):\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0)\ndef intersect2(s1, s2):\n    return intersect4(s1.fi, s1.se, s2.fi, s2.se)\ndef getDistance(a, b):  return abs(a - b)\ndef getDistanceLP(l, p):\n    return abs(cross(l.se - l.fi, p - l.fi) / abs(l.se - l.fi))\ndef getDistanceSP(s, p):\n    if dot(s.se - s.fi, p - s.fi) < 0.0: return abs(p - s.fi)\n    if dot(s.fi - s.se, p - s.se) < 0.0: return abs(p - s.se)\n    return getDistanceLP(s, p)\ndef getDistances(s1, s2):\n    if intersect2(s1, s2): return 0.0\n    return min(getDistanceSP(s1, s2.fi), getDistanceSP(s1, s2.se),\n               getDistanceSP(s2, s1.fi), getDistanceSP(s2, s1.se))\ndef getCrossPoint(s1, s2):\n\tbase = s2.se - s2.fi\n\td1 = abs(cross(base, s1.fi - s2.fi))\n\td2 = abs(cross(base, s1.se - s2.fi))\n\tt = d1 / (d1 + d2)\n\treturn s1.fi + (s1.se - s1.fi) * t\ndef getCrossPoints(c, l):\n\tpr = project(l, c.c)\n\te = (l.se - l.fi) / abs(l.se - l.fi)\n\tbase = math.sqrt(c.r * c.r - norm(pr - c.c))\n\treturn Segment(pr + e * base, pr - e * base)\nx, y, r = map(int, readline().split())\nci = Circle(complex(x, y), r)\nn = int(readline())\nfor _ in [0] * n:\n    p0, p1 = starmap(complex, zip(*[map(int, readline().split())] * 2))\n    ppp = getCrossPoints(ci, Line(p0, p1))\n    if ppp.se.real < ppp.fi.real or (ppp.se.real == ppp.fi.real and ppp.se.imag < ppp.fi.imag):\n        ppp.fi, ppp.se = ppp.se, ppp.fi\n    print(\"{:.10f} {:.10f} {:.10f} {:.10f}\".format(ppp.fi.real, ppp.fi.imag, ppp.se.real, ppp.se.imag))"
  },
  {
    "language": "Python",
    "code": "import math\ndef dot(a, b):\n  return a.real * b.real + a.imag * b.imag\n\ndef projection(p0,p1,p2):\n  a=p1-p0\n  b=p2-p0\n  pro = a * dot(a, b) / (abs(a) ** 2)\n  t=p0+pro\n  return t\n\ndef get_cross_point(p0,p1,p2):\n  pro=projection(p0,p1,p2)\n  e  =(p1-p0)/abs(p1-p0)\n  base = math.sqrt(r*r-(abs(pro-p2)**2))\n  if pro-e*base.real == pro+e*base.real:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.imag)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.imag)\n  else:\n    ans1=min(pro-e*base,pro+e*base,key=lambda x:x.real)\n    ans2=max(pro-e*base,pro+e*base,key=lambda x:x.real)\n  return ans1.real, ans1.imag,ans2.real,ans2.imag\n\n\ncx, cy, r = map(int, input().split())\np2=complex(cx,cy)\nq = int(input())\nfor _ in range(q):\n  x0,y0,x1,y1=map(int,input().split())\n  p0=complex(x0,y0)\n  p1=complex(x1,y1)\n  print(*get_cross_point(p0,p1,p2))\n\n\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::f64::consts::PI;\n\nconst EPS: f64 = 1e-8;\n\nfn main() {\n    let mut sc = Scanner::new();\n\n    let c = sc.next();\n    let r = sc.next();\n    let c = Circle::new(c, r);\n\n    let q = sc.next();\n    for _ in 0..q {\n        let s = sc.next();\n        let t = sc.next();\n\n        let ps = cross_circle_line(&c, &Line(s, t)).unwrap();\n        let mut ps = vec![ps.0, ps.1];\n        ps.sort_by(|x, y| (x.re, x.im).partial_cmp(&(y.re, y.im)).unwrap());\n\n        println!(\n            \"{:.12} {:.12} {:.12} {:.12}\",\n            ps[0].re, ps[0].im, ps[1].re, ps[1].im,\n        );\n    }\n}\n\n//==========\n\npub type Pt = complex::Complex<f64>;\n\npub fn cross(a: Pt, b: Pt) -> f64 {\n    (a.conj() * b).im\n}\n\npub fn dot(a: Pt, b: Pt) -> f64 {\n    (a.conj() * b).re\n}\n\npub fn normalize(p: Pt) -> Pt {\n    p / p.norm()\n}\n\n/// Positional relationship of 3-points\n#[derive(Debug, PartialEq, Eq, Clone, Copy)]\npub enum CCW {\n    /// a->b->c is counter clockwise\n    CounterClockwise = 1,\n    /// a->b->c is clockwise\n    Clockwise = -1,\n    /// c--a--b\n    OnLineBack = 2,\n    /// a--b--c\n    OnLineFront = -2,\n    /// a--c--b\n    OnSegment = 0,\n}\n\n/// Positional relationship of 3-points\npub fn ccw(a: Pt, b: Pt, c: Pt) -> CCW {\n    let b = b - a;\n    let c = c - a;\n    if cross(b, c) > 0.0 {\n        CCW::CounterClockwise\n    } else if cross(b, c) < 0.0 {\n        CCW::Clockwise\n    } else if dot(b, c) < 0.0 {\n        CCW::OnLineBack\n    } else if b.norm() < c.norm() {\n        CCW::OnLineFront\n    } else {\n        CCW::OnSegment\n    }\n}\n\n/// Signed area of triangle\npub fn triangle_area_signed(a: Pt, b: Pt, c: Pt) -> f64 {\n    cross(b - a, c - a) / 2.0\n}\n\n/// Area of polygon\npub fn polygon_area_signed(p: &[Pt]) -> f64 {\n    let mut ret = 0.0;\n    for r in p[1..].windows(2) {\n        ret += triangle_area_signed(p[0], r[0], r[1]);\n    }\n    ret\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum PolygonContains {\n    On,\n    In,\n    Out,\n}\n\npub fn polygon_contains(poly: &[Pt], p: Pt) -> PolygonContains {\n    let n = poly.len();\n    let mut is_in = false;\n\n    for i in 0..poly.len() {\n        let a = poly[i] - p;\n        let b = poly[(i + 1) % n] - p;\n        let (a, b) = if a.im > b.im { (b, a) } else { (a, b) };\n\n        if a.im <= 0.0 && 0.0 < b.im && cross(a, b) < 0.0 {\n            is_in = !is_in\n        };\n        if cross(a, b) == 0.0 && dot(a, b) <= 0.0 {\n            return PolygonContains::On;\n        }\n    }\n\n    if is_in {\n        PolygonContains::In\n    } else {\n        PolygonContains::Out\n    }\n}\n\npub fn is_convex(p: &[Pt]) -> bool {\n    let n = p.len();\n    for i in 0..n {\n        if ccw(p[i], p[(i + 1) % n], p[(i + 2) % n]) == CCW::Clockwise {\n            return false;\n        }\n    }\n    true\n}\n\npub fn rem_euclid(a: f64, b: f64) -> f64 {\n    let r = a % b;\n    if r < 0.0 {\n        r + b.abs()\n    } else {\n        r\n    }\n}\n\n/// Andrew's monotone chain convex hull algorithm\npub fn convex_hull(p: Vec<Pt>) -> Vec<Pt> {\n    let n = p.len();\n    assert!(n >= 3);\n\n    let mut p = p;\n    p.sort_by(|x, y| (x.re, x.im).partial_cmp(&(y.re, y.im)).unwrap());\n\n    let mut ret = vec![];\n\n    macro_rules! half_hull {\n        ($r:expr) => {\n            for i in $r {\n                while {\n                    let k = ret.len();\n                    k >= 2 && ccw(ret[k - 2], ret[k - 1], p[i]) == CCW::Clockwise\n                } {\n                    ret.pop();\n                }\n                ret.push(p[i]);\n            }\n        };\n    }\n\n    // lower-hull\n    half_hull!(0..n);\n    // upper-hull\n    half_hull!((0..n - 1).rev());\n\n    ret.pop();\n    ret\n}\n\npub struct Line(Pt, Pt);\npub struct LineSegment(Pt, Pt);\n\npub fn projection(l: &Line, p: Pt) -> Pt {\n    let t = dot(p - l.0, l.0 - l.1) / (l.0 - l.1).norm_sqr();\n    l.0 + (l.0 - l.1) * t\n}\n\npub fn intersect_lines(a: &Line, b: &Line) -> bool {\n    cross(a.1 - a.0, b.1 - b.0) > EPS || cross(a.1 - a.0, b.0 - b.1) < EPS\n}\n\npub fn intersect_segment_pt(a: &LineSegment, p: Pt) -> bool {\n    (a.0 - p).norm() + (a.1 - p).norm() - (a.1 - a.0).norm() < EPS\n}\n\npub fn intersect_segments(a: &LineSegment, b: &LineSegment) -> bool {\n    ccw(a.0, a.1, b.0) as i32 * ccw(a.0, a.1, b.1) as i32 <= 0\n        && ccw(b.0, b.1, a.0) as i32 * ccw(b.0, b.1, a.1) as i32 <= 0\n}\n\npub fn distance_segment_pt(a: &LineSegment, p: Pt) -> f64 {\n    let r = projection(&Line(a.0, a.1), p);\n    if intersect_segment_pt(a, r) {\n        (r - p).norm()\n    } else {\n        (a.0 - p).norm().min((a.1 - p).norm())\n    }\n}\n\npub fn distance_segments(a: &LineSegment, b: &LineSegment) -> f64 {\n    if intersect_segments(a, b) {\n        return 0.0;\n    }\n    distance_segment_pt(a, b.0)\n        .min(distance_segment_pt(a, b.1))\n        .min(distance_segment_pt(b, a.0))\n        .min(distance_segment_pt(b, a.1))\n}\n\n#[derive(Debug)]\npub enum CrossLineSegment {\n    None,\n    Many,\n    One(Pt),\n}\n\nimpl CrossLineSegment {\n    pub fn ok(&self) -> Option<Pt> {\n        match self {\n            &CrossLineSegment::One(p) => Some(p.clone()),\n            _ => None,\n        }\n    }\n}\n\npub fn cross_line_segment(a: &LineSegment, b: &LineSegment) -> CrossLineSegment {\n    use CrossLineSegment::*;\n\n    let ccw_a_b0 = ccw(a.0, a.1, b.0);\n    let ccw_a_b1 = ccw(a.0, a.1, b.1);\n\n    let ccw_b_a0 = ccw(b.0, b.1, a.0);\n    let ccw_b_a1 = ccw(b.0, b.1, a.1);\n\n    if ccw_a_b0 as i32 * ccw_a_b1 as i32 == 0 {\n        if ccw_a_b1 == CCW::CounterClockwise || ccw_a_b1 == CCW::Clockwise {\n            return One(b.0);\n        } else if ccw_a_b0 == CCW::CounterClockwise || ccw_a_b0 == CCW::Clockwise {\n            return One(b.1);\n        } else {\n            return Many;\n        }\n    }\n\n    if ccw_b_a0 as i32 * ccw_b_a1 as i32 == 0 {\n        if ccw_b_a1 == CCW::CounterClockwise || ccw_b_a1 == CCW::Clockwise {\n            return One(a.0);\n        } else if ccw_b_a0 == CCW::CounterClockwise || ccw_b_a0 == CCW::Clockwise {\n            return One(a.1);\n        } else {\n            return Many;\n        }\n    }\n\n    if ccw_a_b0 as i32 * ccw_a_b1 as i32 == -4 || ccw_b_a0 as i32 * ccw_b_a1 as i32 == -4 {\n        return Many;\n    }\n    if ccw_a_b0 as i32 * ccw_a_b1 as i32 > 0 || ccw_b_a0 as i32 * ccw_b_a1 as i32 > 0 {\n        return None;\n    }\n\n    assert!(ccw_a_b0 as i32 * ccw_a_b1 as i32 == -1);\n    assert!(ccw_b_a0 as i32 * ccw_b_a1 as i32 == -1);\n\n    // normalize a to [(0, 0), (0, 1)]\n    let b0 = b.0 - a.0;\n    let b1 = b.1 - a.0;\n    let va = a.1 - a.0;\n\n    let b0 = b0 / va;\n    let b1 = b1 / va;\n    let vb = b1 - b0;\n\n    let t = -b0.im / vb.im;\n    assert!(t >= 0.0 && t <= 1.0);\n\n    One(b.0 + (b.1 - b.0) * t)\n}\n\npub struct Circle {\n    pub center: Pt,\n    pub radius: f64,\n}\n\nimpl Circle {\n    fn new(center: Pt, radius: f64) -> Self {\n        Self { center, radius }\n    }\n}\n\n/// Cross point of 2 circles\npub fn cross_circle(a: &Circle, b: &Circle) -> Option<(Pt, Pt)> {\n    let c = (a.center - b.center).norm();\n\n    if c > a.radius + b.radius || c + b.radius < a.radius || c + a.radius < b.radius {\n        return None;\n    }\n\n    let x = (a.radius.powi(2) - b.radius.powi(2) + c.powi(2)) / (2.0 * c);\n    let h = (a.radius.powi(2) - x.powi(2)).sqrt();\n\n    let v = (b.center - a.center) / c;\n    let w = v * Pt::from_polar(&1.0, &(std::f64::consts::PI / 2.0));\n    let c1 = a.center + x * v + h * w;\n    let c2 = a.center + x * v - h * w;\n\n    Some((c1, c2))\n}\n\npub fn cross_circle_line(a: &Circle, l: &Line) -> Option<(Pt, Pt)> {\n    let p = projection(l, a.center);\n    let d = (p - a.center).norm();\n    if d > a.radius {\n        return None;\n    }\n    let e = (a.radius.powi(2) - d.powi(2)).sqrt();\n    let v = normalize(l.0 - l.1);\n    Some((p + e * v, p - e * v))\n}\n\n//==========\n\nmod complex {\n    use std::fmt::Debug;\n    use std::ops::{Add, Div, Mul, Sub};\n\n    #[derive(PartialEq, Eq, Copy, Clone, Hash, Debug, Default)]\n    #[repr(C)]\n    pub struct Complex<T> {\n        /// Real portion of the complex number\n        pub re: T,\n        /// Imaginary portion of the complex number\n        pub im: T,\n    }\n\n    impl<T> Complex<T> {\n        #[inline]\n        pub fn new(re: T, im: T) -> Self {\n            Complex { re, im }\n        }\n    }\n\n    impl Complex<f64> {\n        #[inline]\n        pub fn conj(&self) -> Self {\n            Self::new(self.re.clone(), -self.im.clone())\n        }\n\n        #[inline]\n        pub fn norm(&self) -> f64 {\n            self.re.hypot(self.im)\n        }\n\n        #[inline]\n        pub fn norm_sqr(&self) -> f64 {\n            self.re.clone() * self.re.clone() + self.im.clone() * self.im.clone()\n        }\n\n        #[inline]\n        pub fn arg(&self) -> f64 {\n            self.im.atan2(self.re)\n        }\n\n        #[inline]\n        pub fn from_polar(r: &f64, theta: &f64) -> Complex<f64> {\n            Complex::new(*r * theta.cos(), *r * theta.sin())\n        }\n    }\n\n    impl<T: Add<Output = T>> Add for Complex<T> {\n        type Output = Self;\n        fn add(self, rhs: Self) -> Self::Output {\n            Self::new(self.re + rhs.re, self.im + rhs.im)\n        }\n    }\n\n    impl<T: Sub<Output = T>> Sub for Complex<T> {\n        type Output = Self;\n        fn sub(self, rhs: Self) -> Self::Output {\n            Self::new(self.re - rhs.re, self.im - rhs.im)\n        }\n    }\n\n    impl<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T>> Mul for Complex<T> {\n        type Output = Self;\n        fn mul(self, rhs: Self) -> Self::Output {\n            Self::new(\n                self.re * rhs.re - self.im * rhs.im,\n                self.re * rhs.im + self.im * rhs.re,\n            )\n        }\n    }\n\n    impl<T: Copy + Mul<Output = T>> Mul<T> for Complex<T> {\n        type Output = Self;\n        fn mul(self, rhs: T) -> Self::Output {\n            Self::new(self.re * rhs, self.im * rhs)\n        }\n    }\n\n    // impl<T: Copy + Mul<Output = T>> Mul<Complex<T>> for T {\n    //     type Output = Complex<T>;\n    //     fn mul(self, rhs: Complex<T>) -> Self::Output {\n    //         Self::new(self * rhs.re, self * rhs.im)\n    //     }\n    // }\n\n    impl Mul<Complex<f64>> for f64 {\n        type Output = Complex<f64>;\n        fn mul(self, rhs: Complex<f64>) -> Self::Output {\n            Complex::new(self * rhs.re, self * rhs.im)\n        }\n    }\n\n    impl<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Div<Output = T>> Div\n        for Complex<T>\n    {\n        type Output = Self;\n        fn div(self, rhs: Self) -> Self::Output {\n            let d = rhs.re * rhs.re + rhs.im * rhs.im;\n            Self::new(\n                (self.re * rhs.re + self.im * rhs.im) / d,\n                (self.im * rhs.re - self.re * rhs.im) / d,\n            )\n        }\n    }\n\n    impl<T: Copy + Div<Output = T>> Div<T> for Complex<T> {\n        type Output = Self;\n        fn div(self, rhs: T) -> Self::Output {\n            Self::new(self.re / rhs, self.im / rhs)\n        }\n    }\n}\n\n//==========\n\npub struct Scanner {\n    buf: Vec<char>,\n    cur: usize,\n}\n\nimpl Scanner {\n    pub fn new() -> Scanner {\n        Scanner {\n            buf: vec![],\n            cur: 0,\n        }\n    }\n\n    fn fill(&mut self) {\n        let mut s = String::new();\n        let len = std::io::stdin().read_line(&mut s).unwrap();\n        if len == 0 {\n            panic!(\"unexpected EOF\");\n        }\n        for c in s.chars() {\n            self.buf.push(c);\n        }\n    }\n\n    pub fn next_char(&mut self) -> char {\n        'outer: loop {\n            if self.cur >= self.buf.len() {\n                self.fill();\n            }\n            while self.cur < self.buf.len() {\n                if !self.buf[self.cur].is_whitespace() {\n                    break 'outer;\n                }\n                self.cur += 1;\n            }\n        }\n        let ret = self.buf[self.cur];\n        self.cur += 1;\n        ret\n    }\n\n    pub fn next_word(&mut self) -> String {\n        'outer: loop {\n            if self.cur >= self.buf.len() {\n                self.fill();\n            }\n            while self.cur < self.buf.len() {\n                if !self.buf[self.cur].is_whitespace() {\n                    break 'outer;\n                }\n                self.cur += 1;\n            }\n        }\n\n        let mut s = String::new();\n        while self.cur < self.buf.len() && !self.buf[self.cur].is_whitespace() {\n            s.push(self.buf[self.cur]);\n            self.cur += 1;\n        }\n        s\n    }\n\n    pub fn next<T: Reader>(&mut self) -> T {\n        T::read(self)\n    }\n\n    pub fn next_vec_len<T: Reader>(&mut self) -> Vec<T> {\n        let n: usize = self.next();\n        self.next_vec(n)\n    }\n\n    pub fn next_vec<T: Reader>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.next()).collect()\n    }\n}\n\npub trait Reader {\n    fn read(sc: &mut Scanner) -> Self;\n}\n\nimpl<T: Reader> Reader for complex::Complex<T> {\n    fn read(sc: &mut Scanner) -> Self {\n        Self::new(sc.next(), sc.next())\n    }\n}\n\nimpl Reader for char {\n    fn read(sc: &mut Scanner) -> Self {\n        sc.next_char()\n    }\n}\n\nmacro_rules! impl_for_from_str {\n    ($typ:ty) => {\n        impl Reader for $typ {\n            fn read(sc: &mut Scanner) -> Self {\n                sc.next_word().parse().unwrap()\n            }\n        }\n    };\n}\n\nimpl_for_from_str!(i8);\nimpl_for_from_str!(u8);\nimpl_for_from_str!(i16);\nimpl_for_from_str!(u16);\nimpl_for_from_str!(i32);\nimpl_for_from_str!(u32);\nimpl_for_from_str!(i64);\nimpl_for_from_str!(u64);\n// impl_for_from_str!(i128);\n// impl_for_from_str!(u128);\nimpl_for_from_str!(isize);\nimpl_for_from_str!(usize);\nimpl_for_from_str!(f32);\nimpl_for_from_str!(f64);\nimpl_for_from_str!(String);\n\n"
  }
]