[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nvoid findCircleLineIntersection(double cx, double cy, double r, double x1, double y1, double x2, double y2) {\n    double dx = x2 - x1;\n    double dy = y2 - y1;\n    double A = dx * dx + dy * dy;\n    double B = 2 * (dx * (x1 - cx) + dy * (y1 - cy));\n    double C = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;\n    \n    double discriminant = B * B - 4 * A * C;\n    \n    if (discriminant < 0) {\n        printf(\"No intersection points\\n\");\n    } else if (discriminant == 0) {\n        double t = -B / (2 * A);\n        double x = x1 + t * dx;\n        double y = y1 + t * dy;\n        printf(\"One intersection point: (%.2f, %.2f)\\n\", x, y);\n    } else {\n        double t1 = (-B + sqrt(discriminant)) / (2 * A);\n        double t2 = (-B - sqrt(discriminant)) / (2 * A);\n        \n        double x1_intersect = x1 + t1 * dx;\n        double y1_intersect = y1 + t1 * dy;\n        double x2_intersect = x1 + t2 * dx;\n        double y2_intersect = y1 + t2 * dy;\n        \n        printf(\"Two intersection points: (%.2f, %.2f) and (%.2f, %.2f)\\n\", \n               x1_intersect, y1_intersect, x2_intersect, y2_intersect);\n    }\n}\n\nint main() {\n    double cx = 0, cy = 0;  // Circle center\n    double r = 5;           // Circle radius\n    double x1 = -3, y1 = 0; // Line start point\n    double x2 = 7, y2 = 0;  // Line end point\n    \n    findCircleLineIntersection(cx, cy, r, x1, y1, x2, y2);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:16:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ntypedef struct {\n    Point center;\n    double radius;\n} Circle;\n\ntypedef struct {\n    double a;\n    double b;\n    double c;\n} Line;\n\nvoid solve_quadratic(double a, double b, double c, int *num_roots, double *root1, double *root2) {\n    double discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        *num_roots = 0;\n    } else if (discriminant == 0) {\n        *num_roots = 1;\n        *root1 = -b / (2 * a);\n    } else {\n        *num_roots = 2;\n        *root1 = (-b + sqrt(discriminant)) / (2 * a);\n        *root2 = (-b - sqrt(discriminant)) / (2 * a);\n    }\n}\n\nvoid find_intersection(Circle circle, Line line, Point *points, int *num_points) {\n    double a = line.a;\n    double b = line.b;\n    double c = line.c;\n    double x0 = circle.center.x;\n    double y0 = circle.center.y;\n    double r = circle.radius;\n\n    if (b == 0) {\n        double x = -c / a;\n        double A = 1;\n        double B = -2 * y0;\n        double C = (x - x0) * (x - x0) + y0 * y0 - r * r;\n        double y1, y2;\n        int num_roots;\n        solve_quadratic(A, B, C, &num_roots, &y1, &y2);\n        *num_points = num_roots;\n        if (num_roots == 1) {\n            points[0].x = x;\n            points[0].y = y1;\n        } else if (num_roots == 2) {\n            points[0].x = x;\n            points[0].y = y1;\n            points[1].x = x;\n            points[1].y = y2;\n        }\n    } else {\n        double m = -a / b;\n        double k = -c / b;\n        double A = 1 + m * m;\n        double B = 2 * (m * k - m * y0 - x0);\n        double C = x0 * x0 + (k - y0) * (k - y0) - r * r;\n        double x1, x2;\n        int num_roots;\n        solve_quadratic(A, B, C, &num_roots, &x1, &x2);\n        *num_points = num_roots;\n        if (num_roots == 1) {\n            points[0].x = x1;\n            points[0].y = m * x1 + k;\n        } else if (num_roots == 2) {\n            points[0].x = x1;\n            points[0].y = m * x1 + k;\n            points[1].x = x2;\n            points[1].y = m * x2 + k;\n        }\n    }\n}\n\nint main() {\n    Circle circle;\n    Line line;\n    printf(\"Enter circle center (x y): \");\n    scanf(\"%lf %lf\", &circle.center.x, &circle.center.y);\n    printf(\"Enter circle radius: \");\n    scanf(\"%lf\", &circle.radius);\n    printf(\"Enter line coefficients (a b c for ax + by + c = 0): \");\n    scanf(\"%lf %lf %lf\", &line.a, &line.b, &line.c);\n\n    Point points[2];\n    int num_points;\n    find_intersection(circle, line, points, &num_points);\n\n    if (num_points == 0) {\n        printf(\"No intersection points.\\n\");\n    } else if (num_points == 1) {\n        printf(\"One intersection point: (%.2f, %.2f)\\n\", points[0].x, points[0].y);\n    } else {\n        printf(\"Two intersection points: (%.2f, %.2f) and (%.2f, %.2f)\\n\",\n               points[0].x, points[0].y, points[1].x, points[1].y);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nstruct Line {\n    double a, b, c; // ax + by + c = 0\n};\n\nstruct Circle {\n    Point center;\n    double radius;\n};\n\nvector<Point> findIntersection(const Circle& circle, const Line& line) {\n    vector<Point> intersections;\n    double a = line.a, b = line.b, c = line.c;\n    double x0 = circle.center.x, y0 = circle.center.y;\n    double r = circle.radius;\n\n    double denom = sqrt(a * a + b * b);\n    double dist = (a * x0 + b * y0 + c) / denom;\n\n    if (abs(dist) > r) {\n        return intersections;\n    }\n\n    double xp = (b * (b * x0 - a * y0) - a * c) / (a * a + b * b);\n    double yp = (a * (-b * x0 + a * y0) - b * c) / (a * a + b * b);\n\n    if (abs(dist) == r) {\n        intersections.push_back({xp, yp});\n    } else {\n        double d = sqrt(r * r - dist * dist);\n        double dx = -b * d / denom;\n        double dy = a * d / denom;\n        intersections.push_back({xp + dx, yp + dy});\n        intersections.push_back({xp - dx, yp - dy});\n    }\n\n    return intersections;\n}\n\nint main() {\n    Circle circle;\n    Line line;\n\n    cin >> circle.center.x >> circle.center.y >> circle.radius;\n    cin >> line.a >> line.b >> line.c;\n\n    vector<Point> points = findIntersection(circle, line);\n\n    if (points.empty()) {\n        cout << \"No intersection\" << endl;\n    } else {\n        for (const auto& p : points) {\n            cout.precision(6);\n            cout << fixed << p.x << \" \" << p.y << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class CircleLineIntersection {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        double h = scanner.nextDouble();\n        double k = scanner.nextDouble();\n        double r = scanner.nextDouble();\n        double a = scanner.nextDouble();\n        double b = scanner.nextDouble();\n        double c = scanner.nextDouble();\n        \n        double distance = Math.abs(a * h + b * k + c) / Math.sqrt(a * a + b * b);\n        \n        if (distance > r) {\n            System.out.println(\"No intersection\");\n        } else if (distance == r) {\n            double x = (h * (b * b) - a * (b * k + c)) / (a * a + b * b);\n            double y = (k * (a * a) - b * (a * h + c)) / (a * a + b * b);\n            System.out.printf(\"%.6f %.6f\\n\", x, y);\n        } else {\n            double sqrtPart = Math.sqrt(r * r - distance * distance);\n            double denominator = Math.sqrt(a * a + b * b);\n            double x1 = h - (a * (a * h + b * k + c)) / (a * a + b * b) - (b * sqrtPart) / denominator;\n            double y1 = k - (b * (a * h + b * k + c)) / (a * a + b * b) + (a * sqrtPart) / denominator;\n            double x2 = h - (a * (a * h + b * k + c)) / (a * a + b * b) + (b * sqrtPart) / denominator;\n            double y2 = k - (b * (a * h + b * k + c)) / (a * a + b * b) - (a * sqrtPart) / denominator;\n            \n            System.out.printf(\"%.6f %.6f\\n\", x1, y1);\n            System.out.printf(\"%.6f %.6f\\n\", x2, y2);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:18:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.text.DecimalFormat;\n\npublic class CircleLineIntersection {\n    public static void findIntersectionPoints(double centerX, double centerY, double radius, \n                                              double lineA, double lineB, double lineC) {\n        // Line equation: Ax + By + C = 0\n        // Circle equation: (x - centerX)² + (y - centerY)² = radius²\n\n        // Distance from line to circle center\n        double distance = Math.abs(lineA * centerX + lineB * centerY + lineC) / \n                          Math.sqrt(lineA * lineA + lineB * lineB);\n\n        // No intersection\n        if (distance > radius) {\n            System.out.println(\"No intersection points\");\n            return;\n        }\n\n        // Line direction vector\n        double dx = -lineB;\n        double dy = lineA;\n        double magnitude = Math.sqrt(dx * dx + dy * dy);\n        dx /= magnitude;\n        dy /= magnitude;\n\n        // Closest point on line to circle center\n        double closestX = centerX - (lineA * lineC) / (lineA * lineA + lineB * lineB);\n        double closestY = centerY - (lineB * lineC) / (lineA * lineA + lineB * lineB);\n\n        // If exactly touching\n        if (distance == radius) {\n            DecimalFormat df = new DecimalFormat(\"#.###\");\n            System.out.println(\"One intersection point: (\" + \n                df.format(closestX) + \", \" + df.format(closestY) + \")\");\n            return;\n        }\n\n        // Two intersection points\n        double offset = Math.sqrt(radius * radius - distance * distance);\n        \n        double intersect1X = closestX + offset * dx;\n        double intersect1Y = closestY + offset * dy;\n        double intersect2X = closestX - offset * dx;\n        double intersect2Y = closestY - offset * dy;\n\n        DecimalFormat df = new DecimalFormat(\"#.###\");\n        System.out.println(\"Intersection points:\");\n        System.out.println(\"(\" + df.format(intersect1X) + \", \" + df.format(intersect1Y) + \")\");\n        System.out.println(\"(\" + df.format(intersect2X) + \", \" + df.format(intersect2Y) + \")\");\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        findIntersectionPoints(0, 0, 5, 1, -1, 0);\n    }\n}",
    "timestamp": "2025-08-05 22:18:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nstruct Point {\n    double x, y;\n};\n\nstruct Circle {\n    double centerX, centerY, radius;\n};\n\nstruct Line {\n    double a, b, c;\n};\n\nvoid findIntersectionPoints(const Circle& circle, const Line& line) {\n    double x0 = circle.centerX, y0 = circle.centerY, r = circle.radius;\n    double a = line.a, b = line.b, c = line.c;\n\n    double dist = std::abs(a * x0 + b * y0 + c) / std::sqrt(a * a + b * b);\n\n    if (dist > r) {\n        std::cout << \"No intersection\" << std::endl;\n        return;\n    }\n\n    double x1, y1, x2, y2;\n    double nx = a / std::sqrt(a * a + b * b);\n    double ny = b / std::sqrt(a * a + b * b);\n\n    if (dist == r) {\n        x1 = x0 - dist * nx;\n        y1 = y0 - dist * ny;\n        std::cout << \"One intersection point: (\" \n                  << std::fixed << std::setprecision(2) \n                  << x1 << \", \" << y1 << \")\" << std::endl;\n        return;\n    }\n\n    double d = std::sqrt(r * r - dist * dist);\n    x1 = x0 - dist * nx + d * ny;\n    y1 = y0 - dist * ny - d * nx;\n    x2 = x0 - dist * nx - d * ny;\n    y2 = y0 - dist * ny + d * nx;\n\n    std::cout << \"Two intersection points: (\" \n              << std::fixed << std::setprecision(2) \n              << x1 << \", \" << y1 << \") and (\" \n              << x2 << \", \" << y2 << \")\" << std::endl;\n}\n\nint main() {\n    Circle circle;\n    Line line;\n\n    std::cout << \"Enter circle center coordinates (x y): \";\n    std::cin >> circle.centerX >> circle.centerY;\n    std::cout << \"Enter circle radius: \";\n    std::cin >> circle.radius;\n\n    std::cout << \"Enter line equation (ax + by + c = 0): \";\n    std::cin >> line.a >> line.b >> line.c;\n\n    findIntersectionPoints(circle, line);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef find_intersection_points(circle_center, radius, line_points):\n    # Unpack circle center and line points\n    (h, k) = circle_center\n    (x1, y1), (x2, y2) = line_points\n\n    # Calculate line coefficients\n    A = y2 - y1\n    B = x1 - x2\n    C = x2 * y1 - x1 * y2\n\n    # Calculate coefficients for the quadratic equation\n    a = A ** 2 + B ** 2\n    b = 2 * (A * B * k - A * C - B ** 2 * h)\n    c = B ** 2 * h ** 2 + C ** 2 - 2 * B * C * k + A ** 2 * k ** 2 - radius ** 2 * a\n\n    # Calculate discriminant\n    discriminant = b ** 2 - 4 * a * c\n\n    # If the discriminant is negative, no intersection points\n    if discriminant < 0:\n        return []\n\n    # Calculate the x coordinates of the intersection points\n    def calculate_y(x):\n        return -(A * x + C) / B\n\n    # Solve the quadratic equation for x\n    x_intersect1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    y_intersect1 = calculate_y(x_intersect1)\n    \n    if discriminant == 0:\n        return [(x_intersect1, y_intersect1)]\n\n    x_intersect2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    y_intersect2 = calculate_y(x_intersect2)\n\n    return [(x_intersect1, y_intersect1), (x_intersect2, y_intersect2)]\n\n# Example usage\ncircle_center = (0, 0)\nradius = 5\nline_points = [(0, 0), (5, 5)]\nprint(find_intersection_points(circle_center, radius, line_points))",
    "timestamp": "2025-08-13 09:47:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class CircleLineIntersection {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // Read circle parameters\n        System.out.println(\"Enter circle center coordinates (h, k):\");\n        double h = sc.nextDouble();\n        double k = sc.nextDouble();\n        System.out.println(\"Enter circle radius (r):\");\n        double r = sc.nextDouble();\n        \n        // Read line parameters\n        System.out.println(\"Enter line equation (a*x + b*y + c = 0) coefficients (a, b, c):\");\n        double a = sc.nextDouble();\n        double b = sc.nextDouble();\n        double c = sc.nextDouble();\n\n        // Solve for intersection\n        findIntersection(a, b, c, h, k, r);\n    }\n    \n    private static void findIntersection(double a, double b, double c, double h, double k, double r) {\n        double A = 1 + Math.pow((a / b), 2);\n        double B = -2 * h + (2 * a * (c + a * h + b * k)) / (b * b);\n        double C = h * h + Math.pow(c + a * h + b * k, 2) / (b * b) - r * r;\n\n        double discriminant = B * B - 4 * A * C;\n\n        if (discriminant < 0) {\n            System.out.println(\"No intersection points.\");\n        } else {\n            double sqrtD = Math.sqrt(discriminant);\n            double x1 = (-B + sqrtD) / (2 * A);\n            double y1 = (-a * x1 - c) / b;\n\n            if (discriminant == 0) {\n                System.out.println(\"Intersection Point: (\" + x1 + \", \" + y1 + \")\");\n            } else {\n                double x2 = (-B - sqrtD) / (2 * A);\n                double y2 = (-a * x2 - c) / b;\n                System.out.println(\"Intersection Points: (\" + x1 + \", \" + y1 + \") and (\" + x2 + \", \" + y2 + \")\");\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 09:47:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\nvoid findIntersections(double h, double k, double r, double m, double c) {\n    double a, b, A, B, C, disc, x1, y1, x2, y2;\n\n    // Transform to the standard line form: Ax + By + C = 0\n    A = -m;\n    B = 1;\n    C = -c;\n\n    if (B == 0) { // Vertical Line Case\n        x1 = x2 = -C / A;\n        double temp = r * r - (x1 - h) * (x1 - h);\n        if (temp < 0) {\n            printf(\"No intersection points.\\n\");\n            return;\n        }\n        y1 = k + sqrt(temp);\n        y2 = k - sqrt(temp);\n    } else {\n        a = A * A + B * B;\n        b = 2 * (A * C + A * B * k - h * B * B);\n        C = C * C + 2 * B * C * k + h * h * B * B + k * k * B * B - r * r * B * B;\n\n        disc = b * b - 4 * a * C;\n\n        if (disc < 0) {\n            printf(\"No intersection points.\\n\");\n            return;\n        }\n\n        x1 = (-b + sqrt(disc)) / (2 * a);\n        x2 = (-b - sqrt(disc)) / (2 * a);\n\n        y1 = -(A * x1 + C) / B;\n        y2 = -(A * x2 + C) / B;\n    }\n\n    printf(\"Intersection points are: (%.6f, %.6f) and (%.6f, %.6f)\\n\", x1, y1, x2, y2);\n}\n\nint main() {\n    double h, k, r, m, c;\n    printf(\"Enter circle center (h, k), radius r, line slope m, and y-intercept c:\\n\");\n    scanf(\"%lf %lf %lf %lf %lf\", &h, &k, &r, &m, &c);\n\n    findIntersections(h, k, r, m, c);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:47:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef circle_line_intersection(circle_x, circle_y, circle_radius, line_m, line_b):\n    # Compute intersection points between circle and line\n    A = 1 + line_m**2\n    B = -2 * circle_x + 2 * line_m * (line_b - circle_y)\n    C = circle_x**2 + (line_b - circle_y)**2 - circle_radius**2\n\n    # Calculate discriminant\n    discriminant = B**2 - 4*A*C\n\n    # No intersection\n    if discriminant < 0:\n        return []\n\n    # One or two intersection points\n    x1 = (-B + math.sqrt(discriminant)) / (2*A)\n    x2 = (-B - math.sqrt(discriminant)) / (2*A)\n\n    y1 = line_m * x1 + line_b\n    y2 = line_m * x2 + line_b\n\n    # Return points\n    if discriminant == 0:\n        return [(x1, y1)]\n    else:\n        return [(x1, y1), (x2, y2)]\n\n# Example usage\nresult = circle_line_intersection(0, 0, 5, 1, 0)\nprint(result)",
    "timestamp": "2025-08-13 09:48:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef circle_line_intersection(circle_center, radius, line_point1, line_point2):\n    cx, cy = circle_center\n    x1, y1 = line_point1\n    x2, y2 = line_point2\n\n    # Translate the system to make the circle centered at the origin\n    x1 -= cx\n    y1 -= cy\n    x2 -= cx\n    y2 -= cy\n\n    dx = x2 - x1\n    dy = y2 - y1\n    dr_squared = dx**2 + dy**2\n    D = x1 * y2 - x2 * y1\n\n    discriminant = radius**2 * dr_squared - D**2\n\n    if discriminant < 0:\n        return []\n    elif discriminant == 0:\n        x = (D * dy) / dr_squared\n        y = (-D * dx) / dr_squared\n        return [(x + cx, y + cy)]\n    else:\n        sqrt_discriminant = math.sqrt(discriminant)\n        sign_dy = -1 if dy < 0 else 1\n        x1 = (D * dy + sign_dy * dx * sqrt_discriminant) / dr_squared\n        x2 = (D * dy - sign_dy * dx * sqrt_discriminant) / dr_squared\n        y1 = (-D * dx + abs(dy) * sqrt_discriminant) / dr_squared\n        y2 = (-D * dx - abs(dy) * sqrt_discriminant) / dr_squared\n        return [(x1 + cx, y1 + cy), (x2 + cx, y2 + cy)]\n\n# Example usage:\n# circle_center = (0, 0)\n# radius = 5\n# line_point1 = (-6, 0)\n# line_point2 = (6, 0)\n# print(circle_line_intersection(circle_center, radius, line_point1, line_point2))",
    "timestamp": "2025-08-13 09:48:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nstruct Point {\n    double x, y;\n};\n\nstd::vector<Point> circleLineIntersection(double cx, double cy, double r, double m, double c) {\n    std::vector<Point> points;\n    double A = 1 + m * m;\n    double B = 2 * m * (c - cy) - 2 * cx;\n    double C = cx * cx + (c - cy) * (c - cy) - r * r;\n\n    double discriminant = B * B - 4 * A * C;\n    \n    if (discriminant < 0) {\n        return points; // No intersection\n    }\n\n    double sqrtDiscriminant = sqrt(discriminant);\n\n    double x1 = (-B + sqrtDiscriminant) / (2 * A);\n    double y1 = m * x1 + c;\n    points.push_back({x1, y1});\n    \n    if (discriminant > 0) {\n        double x2 = (-B - sqrtDiscriminant) / (2 * A);\n        double y2 = m * x2 + c;\n        points.push_back({x2, y2});\n    }\n    \n    return points;\n}\n\nint main() {\n    double cx, cy, r, m, c;\n    std::cout << \"Enter circle center (cx, cy), radius (r): \";\n    std::cin >> cx >> cy >> r;\n    std::cout << \"Enter line slope (m) and y-intercept (c): \";\n    std::cin >> m >> c;\n\n    std::vector<Point> intersectionPoints = circleLineIntersection(cx, cy, r, m, c);\n    \n    if (intersectionPoints.empty()) {\n        std::cout << \"No intersection points.\\n\";\n    } else {\n        for (const auto& point : intersectionPoints) {\n            std::cout << \"Intersection Point: (\" << point.x << \", \" << point.y << \")\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:54:50"
  }
]