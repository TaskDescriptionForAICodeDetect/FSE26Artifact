[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 924844033\n#define MAX_N 100005\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* graph[MAX_N];\nint parent[MAX_N];\nint depth[MAX_N];\nint subtree_size[MAX_N];\n\nvoid add_edge(int u, int v) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = graph[u];\n    graph[u] = newNode;\n}\n\nvoid dfs1(int node, int par, int d) {\n    parent[node] = par;\n    depth[node] = d;\n    subtree_size[node] = 1;\n\n    for (Node* child = graph[node]; child != NULL; child = child->next) {\n        if (child->vertex != par) {\n            dfs1(child->vertex, node, d + 1);\n            subtree_size[node] += subtree_size[child->vertex];\n        }\n    }\n}\n\nint lowest_common_ancestor(int u, int v) {\n    while (depth[u] > depth[v]) {\n        u = parent[u];\n    }\n    while (depth[v] > depth[u]) {\n        v = parent[v];\n    }\n    while (u != v) {\n        u = parent[u];\n        v = parent[v];\n    }\n    return u;\n}\n\nint compute_f(int* vertices, int k) {\n    int lca = vertices[0];\n    for (int i = 1; i < k; i++) {\n        lca = lowest_common_ancestor(lca, vertices[i]);\n    }\n    return subtree_size[lca];\n}\n\nlong long solve(int n, int k) {\n    long long total_sum = 0;\n    int* vertices = (int*)malloc(k * sizeof(int));\n\n    for (int mask = 1; mask < (1 << n); mask++) {\n        if (__builtin_popcount(mask) == k) {\n            int idx = 0;\n            for (int j = 0; j < n; j++) {\n                if (mask & (1 << j)) {\n                    vertices[idx++] = j + 1;\n                }\n            }\n            total_sum += compute_f(vertices, k);\n        }\n    }\n\n    free(vertices);\n    return total_sum % MOD;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n\n    dfs1(1, 0, 0);\n\n    long long result = 0;\n    for (int k = 1; k <= n; k++) {\n        result += solve(n, k);\n    }\n\n    printf(\"%lld\\n\", result % MOD);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 924844033\n#define MAXN 2005\n\ntypedef long long ll;\n\nint N;\nint adj[MAXN][MAXN];\nint size[MAXN];\nll dp[MAXN][MAXN][3];\nll temp[MAXN][3];\nll fact[MAXN];\nll inv_fact[MAXN];\nll res[MAXN];\nll ans;\n\nll pow_mod(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid precompute_factorials() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n    inv_fact[MAXN-1] = pow_mod(fact[MAXN-1], MOD-2);\n    for (int i = MAXN-2; i >= 0; i--) {\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;\n    }\n}\n\nll comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nvoid dfs(int u, int parent) {\n    size[u] = 1;\n    dp[u][0][0] = 1;\n    dp[u][1][1] = 1;\n    for (int i = 0; i < size[u]; i++) {\n        int v = adj[u][i];\n        if (v == parent) continue;\n        dfs(v, u);\n        memset(temp, 0, sizeof(temp));\n        for (int j = 0; j <= size[u]; j++) {\n            for (int k = 0; k <= size[v]; k++) {\n                if (j + k > N) continue;\n                temp[j + k][0] = (temp[j + k][0] + dp[u][j][0] * (dp[v][k][0] + dp[v][k][2])) % MOD;\n                temp[j + k][1] = (temp[j + k][1] + dp[u][j][1] * (dp[v][k][0] + dp[v][k][2])) % MOD;\n                temp[j + k][2] = (temp[j + k][2] + dp[u][j][1] * dp[v][k][1] + dp[u][j][2] * (dp[v][k][0] + dp[v][k][2])) % MOD;\n            }\n        }\n        size[u] += size[v];\n        for (int j = 0; j <= size[u]; j++) {\n            for (int t = 0; t < 3; t++) {\n                dp[u][j][t] = temp[j][t];\n            }\n        }\n    }\n}\n\nint main() {\n    precompute_factorials();\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N-1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        adj[a][size[a]++] = b;\n        adj[b][size[b]++] = a;\n    }\n    memset(size, 0, sizeof(size));\n    dfs(1, -1);\n    for (int k = 1; k <= N; k++) {\n        res[k] = (dp[1][k][0] + dp[1][k][2]) % MOD;\n    }\n    ans = 0;\n    for (int k = 1; k <= N; k++) {\n        ll term = 0;\n        for (int i = k; i <= N; i++) {\n            ll c = comb(i, k);\n            if ((i - k) % 2 == 0) {\n                term = (term + c * res[i]) % MOD;\n            } else {\n                term = (term - c * res[i] + MOD) % MOD;\n            }\n        }\n        ans = (ans + term * fact[k]) % MOD;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 924844033;\nconst int MAXN = 2005;\n\nvector<int> adj[MAXN];\nint size[MAXN];\nlong long dp[MAXN][MAXN][3];\nlong long temp[MAXN][3];\nint N;\n\nvoid dfs(int u, int parent) {\n    size[u] = 1;\n    dp[u][0][0] = 1;\n    dp[u][1][1] = 1;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        dfs(v, u);\n        for (int i = 0; i <= size[u] + size[v]; ++i) {\n            temp[i][0] = temp[i][1] = temp[i][2] = 0;\n        }\n        for (int i = 0; i <= size[u]; ++i) {\n            for (int j = 0; j <= size[v]; ++j) {\n                temp[i + j][0] = (temp[i + j][0] + dp[u][i][0] * (dp[v][j][0] + dp[v][j][2])) % MOD;\n                temp[i + j][1] = (temp[i + j][1] + dp[u][i][1] * (dp[v][j][0] + dp[v][j][2])) % MOD;\n                temp[i + j][2] = (temp[i + j][2] + dp[u][i][1] * dp[v][j][1]) % MOD;\n                temp[i + j][2] = (temp[i + j][2] + dp[u][i][2] * (dp[v][j][0] + dp[v][j][2])) % MOD;\n            }\n        }\n        size[u] += size[v];\n        for (int i = 0; i <= size[u]; ++i) {\n            dp[u][i][0] = temp[i][0];\n            dp[u][i][1] = temp[i][1];\n            dp[u][i][2] = temp[i][2];\n        }\n    }\n}\n\nlong long fact[MAXN], inv_fact[MAXN];\n\nlong long pow_mod(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    inv_fact[MAXN - 1] = pow_mod(fact[MAXN - 1], MOD - 2);\n    for (int i = MAXN - 2; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    precompute();\n    cin >> N;\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    dfs(1, -1);\n    vector<long long> g(N + 1);\n    for (int k = 1; k <= N; ++k) {\n        for (int i = 1; i <= N; ++i) {\n            g[k] = (g[k] + (dp[i][k][0] + dp[i][k][2]) * comb(N, k)) % MOD;\n        }\n    }\n    long long ans = 0;\n    for (int k = 1; k <= N; ++k) {\n        long long term = k * comb(N, k) % MOD;\n        term = (term - g[k] + MOD) % MOD;\n        ans = (ans + term) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 924844033;\n    static int N;\n    static List<Integer>[] tree;\n    static int[] size;\n    static long[] factorial, invFactorial;\n    static long[][] dp;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            tree[a].add(b);\n            tree[b].add(a);\n        }\n\n        size = new int[N + 1];\n        dp = new long[N + 1][N + 1];\n        dfs(1, -1);\n\n        factorial = new long[N + 1];\n        invFactorial = new long[N + 1];\n        factorial[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            factorial[i] = factorial[i - 1] * i % MOD;\n        }\n        invFactorial[N] = modInverse(factorial[N], MOD);\n        for (int i = N - 1; i >= 0; i--) {\n            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;\n        }\n\n        long[] ans = new long[N + 1];\n        for (int k = 1; k <= N; k++) {\n            ans[k] = comb(N, k) * N % MOD;\n        }\n\n        for (int i = 1; i <= N; i++) {\n            for (int k = 1; k <= N; k++) {\n                long c = comb(size[i], k);\n                ans[k] = (ans[k] - c + MOD) % MOD;\n            }\n        }\n\n        long total = 0;\n        for (int k = 1; k <= N; k++) {\n            total = (total + ans[k] * factorial[k] % MOD * factorial[N - k] % MOD) % MOD;\n        }\n        total = total * invFactorial[N] % MOD;\n        System.out.println(total);\n    }\n\n    static void dfs(int u, int parent) {\n        size[u] = 1;\n        dp[u][1] = 1;\n        for (int v : tree[u]) {\n            if (v == parent) continue;\n            dfs(v, u);\n            int prevSize = size[u];\n            size[u] += size[v];\n            long[] temp = new long[size[u] + 1];\n            for (int i = 1; i <= prevSize; i++) {\n                for (int j = 0; j <= size[v]; j++) {\n                    temp[i + j] = (temp[i + j] + dp[u][i] * dp[v][j] % MOD) % MOD;\n                }\n            }\n            System.arraycopy(temp, 1, dp[u], 1, size[u]);\n        }\n    }\n\n    static long comb(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return factorial[n] * invFactorial[k] % MOD * invFactorial[n - k] % MOD;\n    }\n\n    static long modInverse(long a, int mod) {\n        return pow(a, mod - 2, mod);\n    }\n\n    static long pow(long a, long b, int mod) {\n        long res = 1;\n        a %= mod;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % mod;\n            }\n            a = a * a % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:36:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TreeVertexCover {\n    static final int MOD = 924844033;\n    static List<List<Integer>> graph;\n    static int N;\n\n    static int[] subtreeSize;\n    static int[] depth;\n    static int[] parent;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        N = Integer.parseInt(st.nextToken());\n        graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n        \n        subtreeSize = new int[N + 1];\n        depth = new int[N + 1];\n        parent = new int[N + 1];\n        \n        dfs(1, 0, 0);\n        \n        long totalSum = 0;\n        for (int k = 1; k <= N; k++) {\n            totalSum = (totalSum + solve(k)) % MOD;\n        }\n        \n        System.out.println(totalSum);\n    }\n    \n    static void dfs(int node, int par, int d) {\n        parent[node] = par;\n        depth[node] = d;\n        subtreeSize[node] = 1;\n        \n        for (int child : graph.get(node)) {\n            if (child != par) {\n                dfs(child, node, d + 1);\n                subtreeSize[node] += subtreeSize[child];\n            }\n        }\n    }\n    \n    static long solve(int k) {\n        return combination(N, k, k);\n    }\n    \n    static long combination(int n, int k, int originalK) {\n        if (k == 0) return 0;\n        if (k == 1) return n;\n        \n        long result = 0;\n        for (int root = 1; root <= n; root++) {\n            List<Integer> vertices = new ArrayList<>();\n            result = (result + findMinimumSubtree(root, k, vertices)) % MOD;\n        }\n        \n        return result;\n    }\n    \n    static long findMinimumSubtree(int root, int k, List<Integer> chosenVertices) {\n        if (k == 0) return 0;\n        if (chosenVertices.size() == k) {\n            int lca = findLCA(chosenVertices);\n            return subtreeSize[lca];\n        }\n        \n        long minSubtree = Long.MAX_VALUE;\n        for (int i = root; i <= N; i++) {\n            chosenVertices.add(i);\n            minSubtree = Math.min(minSubtree, findMinimumSubtree(i + 1, k, chosenVertices));\n            chosenVertices.remove(chosenVertices.size() - 1);\n        }\n        \n        return minSubtree;\n    }\n    \n    static int findLCA(List<Integer> vertices) {\n        if (vertices.size() == 1) return vertices.get(0);\n        \n        int lca = vertices.get(0);\n        for (int i = 1; i < vertices.size(); i++) {\n            lca = findLCAHelper(lca, vertices.get(i));\n        }\n        \n        return lca;\n    }\n    \n    static int findLCAHelper(int u, int v) {\n        if (depth[u] < depth[v]) {\n            int temp = u;\n            u = v;\n            v = temp;\n        }\n        \n        while (depth[u] > depth[v]) {\n            u = parent[u];\n        }\n        \n        while (u != v) {\n            u = parent[u];\n            v = parent[v];\n        }\n        \n        return u;\n    }\n}",
    "timestamp": "2025-08-05 23:36:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5005;\nconst int MOD = 924844033;\n\nvector<int> graph[MAXN];\nint subtree_size[MAXN];\nlong long ans = 0;\n\nvoid dfs_size(int node, int parent) {\n    subtree_size[node] = 1;\n    for (int child : graph[node]) {\n        if (child != parent) {\n            dfs_size(child, node);\n            subtree_size[node] += subtree_size[child];\n        }\n    }\n}\n\nint find_centroid(int node, int parent, int total_size) {\n    for (int child : graph[node]) {\n        if (child != parent && subtree_size[child] > total_size / 2) {\n            return find_centroid(child, node, total_size);\n        }\n    }\n    return node;\n}\n\nvoid solve_subsets(int total_size) {\n    int centroid = find_centroid(1, 0, total_size);\n    dfs_size(centroid, 0);\n\n    vector<int> subset_sizes;\n    for (int child : graph[centroid]) {\n        subset_sizes.push_back(subtree_size[child]);\n    }\n    subset_sizes.push_back(total_size - subtree_size[centroid]);\n\n    int K = subset_sizes.size();\n    vector<vector<int>> dp(K + 1, vector<int>(total_size + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 0; i < K; i++) {\n        for (int j = 0; j <= total_size; j++) {\n            if (dp[i][j]) {\n                dp[i+1][j+subset_sizes[i]] += dp[i][j];\n                dp[i+1][j+subset_sizes[i]] %= MOD;\n                dp[i][j] += dp[i][j];\n                dp[i][j] %= MOD;\n            }\n        }\n    }\n\n    for (int k = 1; k <= total_size; k++) {\n        long long total = 0;\n        for (int i = 1; i <= K; i++) {\n            total += 1LL * dp[i][k] * k % MOD;\n            total %= MOD;\n        }\n        ans += total;\n        ans %= MOD;\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 1; i < N; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    dfs_size(1, 0);\n    solve_subsets(N);\n\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, edges):\n    import itertools\n    import collections\n\n    MOD = 924844033\n\n    # Create adjacency list\n    tree = collections.defaultdict(list)\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    # DFS to compute subtree sizes\n    def dfs(node, parent):\n        size[node] = 1\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node)\n                size[node] += size[neighbor]\n\n    size = [0] * (N + 1)\n    dfs(1, -1)\n\n    # Compute f(S) for all subsets of size K\n    def sum_of_min_subtree_sizes(N, size):\n        total_sum = 0\n        for subset_size in range(1, N + 1):\n            combinations = itertools.combinations(range(1, N + 1), subset_size)\n            subset_sum = 0\n            for subset in combinations:\n                min_subtree_size = size[subset[0]]\n                for vertex in subset:\n                    min_subtree_size = min(min_subtree_size, size[vertex])\n                subset_sum += min_subtree_size\n            total_sum += subset_sum\n        return total_sum\n\n    # Calculate the sum modulo MOD\n    result = sum_of_min_subtree_sizes(N, size) % MOD\n    return result\n\n# Example usage:\nN = 5\nedges = [(1, 2), (1, 3), (3, 4), (3, 5)]\nprint(solve(N, edges))",
    "timestamp": "2025-08-13 16:11:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeWays {\n    static final int MOD = 924844033;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        List<List<Integer>> tree = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            tree.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            tree.get(u).add(v);\n            tree.get(v).add(u);\n        }\n        \n        long totalSum = 0;\n        for (int k = 1; k <= n; k++) {\n            totalSum = (totalSum + calculateSumForK(tree, n, k)) % MOD;\n        }\n\n        System.out.println(totalSum);\n    }\n\n    static long calculateSumForK(List<List<Integer>> tree, int n, int k) {\n        long sum = 0;\n        \n        int[] size = new int[n + 1];\n        boolean[] visited = new boolean[n + 1];\n        \n        for (int root = 1; root <= n; root++) {\n            Arrays.fill(visited, false);\n            dfs(root, -1, tree, size, visited);\n\n            long[][] dp = new long[n + 1][k + 1];\n            dp[root][0] = 1;\n            \n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(root);\n            visited[root] = true;\n\n            while (!queue.isEmpty()) {\n                int node = queue.poll();\n                \n                for (int neighbor : tree.get(node)) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        queue.add(neighbor);\n\n                        for (int i = k; i >= 0; i--) {\n                            dp[node][i] = (dp[node][i] * dp[neighbor][0]) % MOD;\n                            if (i > 0) {\n                                dp[node][i] = (dp[node][i] + (dp[node][i - 1] * dp[neighbor][1]) % MOD) % MOD;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            for (int i = 0; i <= k; i++) {\n                sum = (sum + dp[root][i]) % MOD;\n            }\n        }\n        \n        return sum;\n    }\n\n    static int dfs(int node, int parent, List<List<Integer>> tree, int[] size, boolean[] visited) {\n        size[node] = 1;\n        \n        for (int neighbor : tree.get(node)) {\n            if (neighbor != parent && !visited[neighbor]) {\n                visited[neighbor] = true;\n                size[node] += dfs(neighbor, node, tree, size, visited);\n            }\n        }\n        \n        return size[node];\n    }\n}",
    "timestamp": "2025-08-13 16:11:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 924844033\n#define MAXN 5001\n\ntypedef struct {\n    int to, next;\n} Edge;\n\nEdge edges[MAXN * 2];\nint head[MAXN], totalEdges;\nint size[MAXN], parent[MAXN];\nlong long dp[MAXN][MAXN], comb[MAXN][MAXN];\nlong long result;\n\nvoid addEdge(int u, int v) {\n    edges[totalEdges].to = v;\n    edges[totalEdges].next = head[u];\n    head[u] = totalEdges++;\n}\n\nvoid dfs(int node, int par) {\n    parent[node] = par;\n    size[node] = 1;\n    dp[node][1] = 1;\n\n    for(int i = head[node]; i != -1; i = edges[i].next) {\n        int to = edges[i].to;\n        if(to == par) continue;\n        dfs(to, node);\n\n        for(int j = size[node]; j >= 0; --j) {\n            for(int k = 1; k <= size[to]; ++k) {\n                dp[node][j + k] = (dp[node][j + k] + dp[node][j] * dp[to][k] % MOD * comb[j + k][k] % MOD) % MOD;\n            }\n        }\n\n        size[node] += size[to];\n    }\n}\n\nvoid initComb() {\n    for(int i = 0; i < MAXN; ++i) {\n        comb[i][0] = comb[i][i] = 1;\n        for(int j = 1; j < i; ++j)\n            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    memset(head, -1, sizeof(head));\n    \n    for(int i = 0; i < n - 1; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n        addEdge(v, u);\n    }\n\n    initComb();\n    dfs(1, 0);\n\n    result = 0;\n    for(int k = 1; k <= n; ++k) {\n        result = (result + dp[1][k]) % MOD;\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 16:11:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 924844033;\n\nvector<vector<int>> tree;\nvector<vector<int>> dp;\nvector<int> subsize;\n\nvoid dfs(int node, int parent) {\n    subsize[node] = 1;\n    for (int neighbor : tree[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node);\n            subsize[node] += subsize[neighbor];\n        }\n    }\n}\n\nvoid solve(int node, int parent) {\n    dp[node][0] = 1;\n    dp[node][subsize[node]] = 1;\n    \n    for (int neighbor : tree[node]) {\n        if (neighbor != parent) {\n            solve(neighbor, node);\n            \n            vector<int> new_dp(dp[node].size(), 0);\n            for (int i = 0; i <= subsize[node]; ++i) {\n                for (int j = 0; j <= subsize[neighbor]; ++j) {\n                    new_dp[i + j] = (new_dp[i + j] + 1LL * dp[node][i] * dp[neighbor][j] % MOD) % MOD;\n                }\n            }\n            dp[node] = new_dp;\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    tree.resize(N + 1);\n    dp.resize(N + 1, vector<int>(N + 1, 0));\n    subsize.resize(N + 1, 0);\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    \n    dfs(1, -1);\n    solve(1, -1);\n    \n    vector<long long> factorial(N + 1, 1);\n    for (int i = 2; i <= N; ++i) {\n        factorial[i] = factorial[i - 1] * i % MOD;\n    }\n    \n    long long answer = 0;\n    for (int k = 1; k <= N; ++k) {\n        long long sum_k = 0;\n        for (int v = 1; v <= N; ++v) {\n            sum_k = (sum_k + dp[v][k]) % MOD;\n        }\n        answer = (answer + sum_k * factorial[k] % MOD) % MOD;\n    }\n    \n    cout << answer << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 16:11:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Dict\nimport sys\nsys.setrecursionlimit(10**6)\n\nclass Solution:\n    def solve(self, N: int, edges: List[List[int]], K: int) -> int:\n        MOD = 924844033\n        graph = [[] for _ in range(N+1)]\n        \n        # Build adjacency list\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # LCA preprocessing\n        depth = [0] * (N+1)\n        parent = [0] * (N+1)\n        subtree_size = [1] * (N+1)\n        \n        def dfs(node: int, par: int, d: int) -> int:\n            parent[node] = par\n            depth[node] = d\n            \n            for child in graph[node]:\n                if child != par:\n                    subtree_size[node] += dfs(child, node, d+1)\n            \n            return subtree_size[node]\n        \n        dfs(1, 0, 0)\n        \n        # LCA function\n        def lca(u: int, v: int) -> int:\n            while depth[u] > depth[v]:\n                u = parent[u]\n            while depth[v] > depth[u]:\n                v = parent[v]\n            \n            while u != v:\n                u = parent[u]\n                v = parent[v]\n            \n            return u\n        \n        # Calculate f(S) for set of vertices\n        def calculate_f(vertices: List[int]) -> int:\n            if len(vertices) == 1:\n                return 1\n            \n            # Find LCA of all vertices\n            root = vertices[0]\n            for v in vertices[1:]:\n                root = lca(root, v)\n            \n            return subtree_size[root]\n        \n        # Generate combinations and calculate total\n        total = 0\n        \n        def generate_combinations(current: List[int], start: int):\n            nonlocal total\n            \n            if len(current) == K:\n                total = (total + calculate_f(current)) % MOD\n                return\n            \n            for i in range(start, N+1):\n                current.append(i)\n                generate_combinations(current, i+1)\n                current.pop()\n        \n        generate_combinations([], 1)\n        \n        return total\n\ndef main():\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        u, v = map(int, input().split())\n        edges.append([u, v])\n    \n    solution = Solution()\n    \n    # Solve for maximum K value\n    result = solution.solve(N, edges, N)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 16:11:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 924844033\n\ndef solve():\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    fact = [1]*(N+1)\n    inv_fact = [1]*(N+1)\n    for i in range(1, N+1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[N] = pow(fact[N], MOD-2, MOD)\n    for i in range(N-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # We'll compute the frequency array cnt where cnt[k] is the number of S with |S|=k and f(S)=m\n    # Then the answer is sum_{k=1..N} sum_{m=1..N} m * cnt[k][m] * C(N, k)\n    # But cnt is hard to compute directly. Instead, we can find for each edge (u, parent[u]), the number of S that require this edge.\n    # The total f(S) is N (each S includes at least the root) minus the number of edges not in the subtree for S.\n    # So f(S) = N - (number of edges not in the minimal subtree containing S)\n    # So sum_S f(S) = N * (2^N - 1) - sum_{edge e} (number of S such that e is not in the minimal subtree of S)\n    \n    # The minimal subtree of S is the union of the paths between all pairs in S. So an edge e=(u, parent[u]) is not in the minimal subtree of S iff all nodes in S are in the subtree of u or all are not in the subtree of u.\n    # Let the size of the subtree of u be sz. Then the number of S with K elements that are all in or all not in the subtree is C(sz, K) + C(N-sz, K).\n    \n    parent = [0]*(N+1)\n    sz = [0]*(N+1)\n    stack = [(1, None, False)]\n    edges = []\n    while stack:\n        u, p, visited = stack.pop()\n        if not visited:\n            parent[u] = p\n            stack.append((u, p, True))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u, False))\n        else:\n            sz[u] = 1\n            for v in adj[u]:\n                if v != p:\n                    sz[u] += sz[v]\n                    edges.append((u, v))\n    \n    freq = [0]*(N+2)\n    for u, v in edges:\n        s = min(sz[u], sz[v])\n        for k in range(0, N+1):\n            term = (fact[s] * inv_fact[k] % MOD) * inv_fact[s - k] % MOD if k <= s else 0\n            term += (fact[N - s] * inv_fact[k] % MOD) * inv_fact[N - s - k] % MOD if k <= N - s else 0\n            term %= MOD\n            freq[k] = (freq[k] + term) % MOD\n    \n    total = 0\n    for k in range(1, N+1):\n        C = (fact[N] * inv_fact[k] % MOD) * inv_fact[N - k] % MOD\n        term = (N * C - freq[k]) % MOD\n        total = (total + term) % MOD\n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 16:13:28"
  }
]