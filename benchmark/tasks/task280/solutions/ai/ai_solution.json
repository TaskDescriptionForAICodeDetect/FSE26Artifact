[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint minSwaps(char* bits, int* runLengths, int runCount) {\n    int n = strlen(bits);\n    int swaps = 0;\n    int currentRun = 0;\n    char currentBit = runLengths[0] > 0 ? '1' : '0';\n    int remaining = runLengths[0] > 0 ? runLengths[0] : -runLengths[0];\n    \n    for (int i = 0; i < n; ) {\n        if (remaining == 0) {\n            currentRun++;\n            if (currentRun >= runCount) break;\n            currentBit = runLengths[currentRun] > 0 ? '1' : '0';\n            remaining = runLengths[currentRun] > 0 ? runLengths[currentRun] : -runLengths[currentRun];\n        }\n        \n        if (bits[i] == currentBit) {\n            remaining--;\n            i++;\n        } else {\n            int j = i;\n            while (j < n && bits[j] != currentBit) {\n                j++;\n            }\n            if (j == n) break;\n            swaps += j - i;\n            char temp = bits[j];\n            for (int k = j; k > i; k--) {\n                bits[k] = bits[k - 1];\n            }\n            bits[i] = temp;\n            remaining--;\n            i++;\n        }\n    }\n    \n    return swaps;\n}\n\nint main() {\n    char bits[1001];\n    int runCount;\n    scanf(\"%s\", bits);\n    scanf(\"%d\", &runCount);\n    int runLengths[runCount];\n    for (int i = 0; i < runCount; i++) {\n        scanf(\"%d\", &runLengths[i]);\n    }\n    \n    printf(\"%d\\n\", minSwaps(bits, runLengths, runCount));\n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    \n    vector<int> runs;\n    char current = s[0];\n    int count = 1;\n    for (int i = 1; i < n; ++i) {\n        if (s[i] == current) {\n            ++count;\n        } else {\n            runs.push_back(count);\n            current = s[i];\n            count = 1;\n        }\n    }\n    runs.push_back(count);\n    \n    int m;\n    cin >> m;\n    vector<int> target(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> target[i];\n    }\n    \n    if (runs.size() != target.size()) {\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    int swaps = 0;\n    int pos = 0;\n    for (int i = 0; i < m; ++i) {\n        if (runs[i] != target[i]) {\n            if (i == m - 1) {\n                cout << -1 << endl;\n                return 0;\n            }\n            int diff = target[i] - runs[i];\n            runs[i] += diff;\n            runs[i + 1] -= diff;\n            swaps += abs(diff);\n        }\n        pos += runs[i];\n    }\n    \n    cout << swaps << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BitStringReorder {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String bitString = scanner.next();\n        int n = bitString.length();\n        int m = scanner.nextInt();\n        int[] runs = new int[m];\n        for (int i = 0; i < m; i++) {\n            runs[i] = scanner.nextInt();\n        }\n        \n        char[] target = constructTarget(bitString, runs);\n        int swaps = minSwaps(bitString.toCharArray(), target);\n        System.out.println(swaps);\n    }\n    \n    private static char[] constructTarget(String bitString, int[] runs) {\n        int count0 = 0, count1 = 0;\n        for (char c : bitString.toCharArray()) {\n            if (c == '0') count0++;\n            else count1++;\n        }\n        \n        char[] target = new char[bitString.length()];\n        int index = 0;\n        char current = '1';\n        for (int run : runs) {\n            if (current == '1' && count1 == 0) current = '0';\n            else if (current == '0' && count0 == 0) current = '1';\n            \n            for (int i = 0; i < run; i++) {\n                target[index++] = current;\n                if (current == '0') count0--;\n                else count1--;\n            }\n            current = (current == '0') ? '1' : '0';\n        }\n        return target;\n    }\n    \n    private static int minSwaps(char[] source, char[] target) {\n        int swaps = 0;\n        int n = source.length;\n        for (int i = 0; i < n; i++) {\n            if (source[i] != target[i]) {\n                int j = i + 1;\n                while (j < n && source[j] != target[i]) {\n                    j++;\n                }\n                if (j == n) return -1; // should not happen for valid input\n                while (j > i) {\n                    char temp = source[j];\n                    source[j] = source[j - 1];\n                    source[j - 1] = temp;\n                    swaps++;\n                    j--;\n                }\n            }\n        }\n        return swaps;\n    }\n}",
    "timestamp": "2025-08-05 20:55:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BitStringReorder {\n    public static int minimumSwaps(String s, int[] runLengths) {\n        int n = s.length();\n        int swaps = 0;\n        int currentPos = 0;\n        \n        for (int runLength : runLengths) {\n            char currentBit = (runLength % 2 == 0) ? '0' : '1';\n            int requiredCount = runLength;\n            \n            while (requiredCount > 0) {\n                while (currentPos < n && s.charAt(currentPos) != currentBit) {\n                    currentPos++;\n                }\n                \n                if (currentPos >= n) break;\n                \n                int k = currentPos;\n                while (k > 0 && s.charAt(k-1) != currentBit) {\n                    swap(s, k-1, k);\n                    swaps++;\n                    k--;\n                }\n                \n                currentPos++;\n                requiredCount--;\n            }\n        }\n        \n        return swaps;\n    }\n    \n    private static void swap(String s, int i, int j) {\n        char[] chars = s.toCharArray();\n        char temp = chars[i];\n        chars[i] = chars[j];\n        chars[j] = temp;\n        s = new String(chars);\n    }\n    \n    public static void main(String[] args) {\n        String s = \"10101\";\n        int[] runLengths = {2, 3};\n        System.out.println(minimumSwaps(s, runLengths));\n    }\n}",
    "timestamp": "2025-08-05 20:55:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 1000\n\nint calculate_swaps(char *s, int *run_lengths, int run_count) {\n    int len = strlen(s);\n    int swaps = 0;\n    int current_run = 0;\n    int current_length = 0;\n    int target_index = 0;\n\n    for (int i = 0; i < len; i++) {\n        if (current_length == 0 || s[i] == (current_run ? '1' : '0')) {\n            current_length++;\n        } else {\n            if (current_length != run_lengths[target_index]) {\n                return -1;\n            }\n            current_run = !current_run;\n            current_length = 1;\n            target_index++;\n        }\n    }\n\n    if (current_length != run_lengths[target_index]) {\n        return -1;\n    }\n\n    char *temp = strdup(s);\n    for (int i = 0; i < len - 1; i++) {\n        for (int j = 0; j < len - i - 1; j++) {\n            if (temp[j] != temp[j+1]) {\n                char t = temp[j];\n                temp[j] = temp[j+1];\n                temp[j+1] = t;\n                swaps++;\n            }\n        }\n    }\n\n    free(temp);\n    return swaps;\n}\n\nint main() {\n    char s[MAX_LEN];\n    int run_lengths[MAX_LEN];\n    int run_count;\n\n    scanf(\"%s\", s);\n    scanf(\"%d\", &run_count);\n\n    for (int i = 0; i < run_count; i++) {\n        scanf(\"%d\", &run_lengths[i]);\n    }\n\n    int result = calculate_swaps(s, run_lengths, run_count);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <climits>\n\nclass BitStringReorder {\npublic:\n    int minimumSwaps(std::string bits, std::vector<int> runLengths) {\n        int n = bits.length();\n        std::vector<int> currentRuns = calculateRunLengths(bits);\n        \n        if (currentRuns.size() != runLengths.size()) {\n            return -1;\n        }\n        \n        int totalSwaps = 0;\n        for (int startPos = 0; startPos < n; startPos += 2) {\n            if (startPos + 1 >= n) break;\n            \n            if (bits[startPos] != bits[startPos+1]) {\n                int minSwaps = findMinSwaps(bits, startPos);\n                if (minSwaps == INT_MAX) return -1;\n                totalSwaps += minSwaps;\n            }\n        }\n        \n        return totalSwaps;\n    }\n    \nprivate:\n    std::vector<int> calculateRunLengths(const std::string& s) {\n        std::vector<int> runs;\n        int count = 1;\n        \n        for (int i = 1; i < s.length(); i++) {\n            if (s[i] == s[i-1]) {\n                count++;\n            } else {\n                runs.push_back(count);\n                count = 1;\n            }\n        }\n        runs.push_back(count);\n        \n        return runs;\n    }\n    \n    int findMinSwaps(std::string& bits, int startPos) {\n        int n = bits.length();\n        int minSwaps = INT_MAX;\n        \n        for (int j = startPos + 2; j < n; j += 2) {\n            if (bits[j] == bits[startPos+1] && bits[j-1] == bits[startPos]) {\n                int currentSwaps = swapBetween(bits, startPos, j);\n                minSwaps = std::min(minSwaps, currentSwaps);\n            }\n        }\n        \n        return minSwaps;\n    }\n    \n    int swapBetween(std::string& bits, int start, int end) {\n        int swaps = 0;\n        \n        for (int i = end; i > start + 1; i--) {\n            std::swap(bits[i], bits[i-1]);\n            swaps++;\n        }\n        \n        return swaps;\n    }\n};",
    "timestamp": "2025-08-05 20:56:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_swaps_to_rlc(bit_string, rlc):\n    def count_swaps(start, end, target):\n        count = 0\n        zeros, ones = target\n        target = '0' * zeros + '1' * ones\n        for i in range(len(target)):\n            if bit_string[start + i] != target[i]:\n                count += 1\n        return count // 2\n    \n    n = len(bit_string)\n    swaps = 0\n    start = 0\n    \n    for length in rlc:\n        end = start + length\n        zeros = bit_string[start:end].count('0')\n        ones = length - zeros\n        target = [zeros, ones] if bit_string[start] == '0' else [ones, zeros]\n        swaps += count_swaps(start, end, target)\n        start = end\n        \n    return swaps\n\n# Example usage\nbit_string = \"110010101111\"\nrlc = [3, 2, 1, 2, 4]\nprint(min_swaps_to_rlc(bit_string, rlc))  # Output: number of swaps required",
    "timestamp": "2025-08-13 04:03:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BitStringReorder {\n    public static int minSwaps(String initial, List<Integer> runLengthCode) {\n        List<Integer> initialRunLengths = new ArrayList<>();\n        int n = initial.length();\n        char currentChar = initial.charAt(0);\n        int count = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (initial.charAt(i) == currentChar) {\n                count++;\n            } else {\n                initialRunLengths.add(count);\n                count = 1;\n                currentChar = initial.charAt(i);\n            }\n        }\n        initialRunLengths.add(count);\n\n        int swapCount = 0;\n\n        List<Integer> targetRunLengths = new ArrayList<>(runLengthCode);\n        int m = Math.min(initialRunLengths.size(), targetRunLengths.size());\n\n        for (int i = 0; i < m; i++) {\n            swapCount += Math.abs(initialRunLengths.get(i) - targetRunLengths.get(i));\n        }\n\n        for (int i = m; i < initialRunLengths.size(); i++) {\n            swapCount += initialRunLengths.get(i);\n        }\n        \n        for (int i = m; i < targetRunLengths.size(); i++) {\n            swapCount += targetRunLengths.get(i);\n        }\n\n        return swapCount / 2;\n    }\n\n    public static void main(String[] args) {\n        String initial = \"11001100\";\n        List<Integer> runLengthCode = List.of(2, 2, 2, 2);\n        System.out.println(minSwaps(initial, runLengthCode));\n    }\n}",
    "timestamp": "2025-08-13 04:04:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint calculate_swaps(char *bitString, int *runLength, int runLengthSize) {\n    int n = strlen(bitString);\n    int swaps = 0;\n    int currentIndex = 0;\n\n    for (int i = 0; i < runLengthSize; i++) {\n        int targetBit = (i % 2 == 0) ? '0' : '1';\n        int count = runLength[i];\n\n        for (int j = currentIndex; j < currentIndex + count; j++) {\n            if (bitString[j] == targetBit) continue;\n\n            // Find the first occurrence of the targetBit in the remaining string\n            int swapIndex = j;\n            while (swapIndex < n && bitString[swapIndex] != targetBit) {\n                swapIndex++;\n            }\n\n            // Swap adjacent pairs to bring the targetBit to its correct position\n            while (swapIndex > j) {\n                // Swap the adjacent pairs\n                char temp = bitString[swapIndex];\n                bitString[swapIndex] = bitString[swapIndex - 1];\n                bitString[swapIndex - 1] = temp;\n                swapIndex--;\n                swaps++;\n            }\n        }\n        \n        currentIndex += count;\n    }\n\n    return swaps;\n}\n\nint main() {\n    char bitString[] = \"1100110001\";\n    int runLength[] = {2, 2, 3, 1, 1};\n    int runLengthSize = 5;\n\n    int result = calculate_swaps(bitString, runLength, runLengthSize);\n    printf(\"Minimum number of swaps: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:04:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_swaps_to_match_run_length(s, target_run_lengths):\n    def count_run_lengths(bits):\n        runs = []\n        current_run = 1\n        for i in range(1, len(bits)):\n            if bits[i] == bits[i-1]:\n                current_run += 1\n            else:\n                runs.append(current_run)\n                current_run = 1\n        runs.append(current_run)\n        return runs\n\n    def adjacent_swap(s, i):\n        s_list = list(s)\n        s_list[i], s_list[i+1] = s_list[i+1], s_list[i]\n        return ''.join(s_list)\n\n    def solve(s):\n        current_runs = count_run_lengths(s)\n        if current_runs == target_run_lengths:\n            return 0\n        \n        min_swaps = float('inf')\n        for swap_count in range(len(s) - 1):\n            for i in range(len(s) - 1):\n                s = adjacent_swap(s, i)\n                current_runs = count_run_lengths(s)\n                \n                if current_runs == target_run_lengths:\n                    min_swaps = min(min_swaps, swap_count + 1)\n                    break\n        \n        return min_swaps if min_swaps != float('inf') else -1\n\n    return solve(s)",
    "timestamp": "2025-08-13 04:04:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_swaps_to_run_length(initial_bits, run_lengths):\n    target = []\n    current_bit = '1' if initial_bits[0] == '0' else '0'  # Start with the opposite to trigger the first flip\n    for length in run_lengths:\n        current_bit = '1' if current_bit == '0' else '0'\n        target.extend([current_bit] * length)\n    \n    # Now compute the minimal swaps to transform initial_bits into target\n    # We'll use inversion count method for adjacent swaps\n    # Map the positions of 1s in initial and target\n    initial_ones = [i for i, bit in enumerate(initial_bits) if bit == '1']\n    target_ones = [i for i, bit in enumerate(target) if bit == '1']\n    \n    # The number of swaps is the sum of absolute differences between corresponding positions\n    swaps = sum(abs(a - b) for a, b in zip(initial_ones, target_ones))\n    return swaps\n\n# Example usage:\n# initial_bits = \"0010111\"\n# run_lengths = [3, 1, 2, 1]\n# print(min_swaps_to_run_length(initial_bits, run_lengths))",
    "timestamp": "2025-08-13 04:04:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint calculateMinSwaps(const std::string& bitString, const std::vector<int>& runLength) {\n    // Create a vector of positions from run-length encoding\n    std::vector<int> position;\n    char currentChar = bitString[0];\n    int count = 0;\n\n    for (char bit : bitString) {\n        if (bit == currentChar) {\n            count++;\n        } else {\n            position.push_back(count);\n            currentChar = bit;\n            count = 1;\n        }\n    }\n    position.push_back(count);\n\n    // Calculate the minimum swaps required\n    int minSwaps = 0;\n\n    // Iterate through the run lengths\n    int i = 0, j = 0;\n    int remaining = 0;\n    while (i < position.size() && j < runLength.size()) {\n        if (position[i] + remaining == runLength[j]) {\n            i++;\n            j++;\n            remaining = 0;\n        } else if (position[i] + remaining > runLength[j]) {\n            position[i] += remaining - runLength[j];\n            remaining = 0;\n            j++;\n        } else {\n            remaining += position[i];\n            i++;\n            minSwaps += std::abs(position[i - 1] - runLength[j]);\n        }\n    }\n\n    return minSwaps;\n}\n\nint main() {\n    std::string bitString;\n    std::cin >> bitString;\n\n    int n;\n    std::cin >> n;\n    std::vector<int> runLength(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> runLength[i];\n    }\n\n    int result = calculateMinSwaps(bitString, runLength);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:16:53"
  }
]