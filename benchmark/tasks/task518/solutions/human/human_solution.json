[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\n\nint main() {\n  ll n,m;\n  cin >> n >> m;\n  vector<P> v[n];\n  for(int i=0; i<m; i++) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    x--,y--;\n    v[x].push_back(P(y,z));\n    v[y].push_back(P(x,z));\n  }\n  ll v0,A,B,C;\n  cin >> v0 >> A >> B >> C;\n  ll d[n][50];\n  for(int i=0; i<n; i++)for(int j=0; j<C; j++) d[i][j]=1LL<<59;\n  d[0][v0]=0;\n  priority_queue<PP,vector<PP>,greater<PP> > que;\n  que.push(PP(0,P(0,v0)));\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    ll x=p.second.first,t=p.second.second,c=p.first;\n    if(d[x][t]<c) continue;\n    for(int i=0; i<v[x].size(); i++) {\n      ll y=v[x][i].first,cc=v[x][i].second;\n      ll s=(A*t+B)%C;\n      if(d[y][s]<=d[x][t]+cc*t) continue;\n      d[y][s]=d[x][t]+cc*t;\n      que.push(PP(d[y][s],P(y,s)));\n    }\n  }\n  for(int i=0; i<n-1; i++)for(int j=0; j<C; j++)d[i][j]=1LL<<59;\n  for(int i=0; i<C; i++) que.push(PP(d[n-1][i],P(n-1,i)));\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    ll x=p.second.first,t=p.second.second,c=p.first;\n    if(d[x][t]<c) continue;\n    for(int i=0; i<v[x].size(); i++) {\n      ll y=v[x][i].first,cc=v[x][i].second;\n      ll s=(A*t+B)%C;\n      if(d[y][s]<=d[x][t]+cc*t) continue;\n      d[y][s]=d[x][t]+cc*t;\n      que.push(PP(d[y][s],P(y,s)));\n    }\n  }\n  ll ans=1LL<<59;\n  for(int i=0; i<C; i++) ans=min(ans,d[0][i]);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1LL<<59)\n\nstruct eg{\n    int a,b,c;\n};\n\n#define int ll\n\n#define MAX_V 500\n#define MAX_B 50\n\nstruct edge{pii to;int cost;};\n\nvoid dijkstra(pii s, vector<vector<int>> &d, vector<edge> G[MAX_V][MAX_B]){\n    priority_queue< pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>> > que;\n    rep(i,MAX_V)rep(j,MAX_B)d[i][j]=INF;\n    d[s.first][s.second]=0;\n    que.push(make_pair(0,s));\n    \n    while(que.size()){\n        pair<int,pii> p=que.top();\n        que.pop();\n        \n        int v=p.second.first;\n        int b=p.second.second;\n        if(d[v][b]<p.first)continue;\n        \n        rep(i,G[v][b].size()){\n            edge e=G[v][b][i];\n            if(d[e.to.first][e.to.second]>d[v][b]+e.cost){\n                d[e.to.first][e.to.second]=d[v][b]+e.cost;\n                que.push(make_pair(d[e.to.first][e.to.second],e.to));\n            }\n        }\n    }\n}\n\n\nsigned main(){\n    int v,e;\n    cin>>v>>e;\n    vector<pii> gr[MAX_V];\n    rep(i,e){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--,b--;\n        gr[a].pb(pii(b,c));\n        gr[b].pb(pii(a,c));\n    }\n    \n    int v0;\n    cin>>v0;\n    int a,b,c;\n    cin>>a>>b>>c;\n    \n    vector<edge> G[MAX_V][MAX_B];\n    rep(i,v){\n        rep(vid,c){\n            int vi = (a*vid+b)%c;\n            for(auto e:gr[i]){\n                G[i][vid].pb(edge{pii(e.first,vi),e.second*vid});\n            }\n        }\n    }\n    \n    vector<vector<int>> d1(MAX_V,vector<int>(MAX_B));\n    dijkstra(pii(0,v0),d1, G);\n\n    int ans = INF;\n    rep(i,c){\n        vector<vector<int>> d2(MAX_V,vector<int>(MAX_B));\n        dijkstra(pii(v-1,i),d2,G);\n        int t = INF;\n        rep(j,c){\n            t = min(t,d1[v-1][i] + d2[0][j]);\n        }\n        ans = min(ans, t);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n\n\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,int> piii;\n    vector<vector<long long>>d(n,vector<long long>(100,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<long long>>_d(n,vector<long long>(100,LLONG_MAX/10));\n    rep(i,c+1)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,c+1)if(d[n-1][i]!=LLONG_MAX/10)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    long long ans=LLONG_MAX/10;\n    rep(i,100)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\n\nstruct Edge { int dst; ll w; };\nstruct Data {\n  int cur,v; ll w;\n  bool operator < ( const Data &e ) const {\n    if( w != e.w ) return w > e.w;\n    if( v != e.v ) return v > e.v;\n    return cur > e.cur;\n  }\n};\n\n#define MAX_V 510\n\nint V,E;\nll v0,a,b,c;\nll mini[MAX_V][51][2];\nvector<Edge> G[MAX_V];\n\nll cost1;\nll adhoc = LLINF;\nvoid dijkstra(int sp,int v0) {\n  rep(i,V) rep(j,c) mini[i][j][sp==(V-1)] = LLINF;\n  priority_queue<Data> Q;\n  Q.push((Data){sp,v0,0});\n  mini[sp][v0][sp==(V-1)] = 0;\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      int nv = ( a * data.v + b ) % c;\n      ll nw = data.w + e.w * data.v;\n    \n      if( nw < mini[e.dst][nv][sp==(V-1)] ) {\n        mini[e.dst][nv][sp==(V-1)] = nw;\n        Q.push((Data){e.dst,nv,nw});\n      }\n    }\n  }\n}\n\nvoid compute() {\n  dijkstra(0,v0);\n  ll ans = LLINF;\n  rep(i,c) {\n    if( mini[V-1][i][0] != LLINF ) {\n      ll cost = mini[V-1][i][0];\n      if( cost >= ans ) break;\n      cost1 = cost;\n      dijkstra(V-1,i);\n      ll tmp = LLINF;\n      rep(j,c) tmp = min(tmp,mini[0][j][1]);\n      if( tmp == LLINF ) continue;\n      ans = min(ans,cost+tmp);\n      adhoc = ans;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  rep(i,E) {\n    int x,y,t;\n    cin >> x >> y >> t;\n    --x,--y;\n    G[x].push_back((Edge){y,t});\n    G[y].push_back((Edge){x,t});\n  } \n  cin >> v0 >> a >> b >> c;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\ntypedef tuple< int64, int, int, bool > Pi;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nstruct edge\n{\n  int to, cost;\n};\n\nint64 v[500][51][2];\nint N, M, V, A, B, C;\nvector< edge > g[500];\n\nint main()\n{\n\n\n  cin >> N >> M;\n  rep(i, M) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    g[x].push_back((edge) {y, t});\n    g[y].push_back((edge) {x, t});\n  }\n  cin >> V;\n  cin >> A >> B >> C;\n\n  fill_n(**v, 500 * 51 * 2, INF);\n  v[0][V][0] = 0;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, 0, V, false);\n\n  while(!que.empty()) {\n    int64 cost;\n    int now, vv;\n    bool flag;\n    tie(cost, now, vv, flag) = que.top();\n    que.pop();\n\n    if(flag && now == 0) {\n      cout << cost << endl;\n      return (0);\n    }\n\n    for(auto &e : g[now]) {\n\n      int64 nxtcost = cost + 1LL * vv * e.cost;\n      int nxtvv = (A * vv + B) % C;\n      bool nxtfg = flag | (e.to == N - 1);\n\n      if(nxtcost < v[e.to][nxtvv][nxtfg]) {\n        v[e.to][nxtvv][nxtfg] = nxtcost;\n        que.emplace(nxtcost, e.to, nxtvv, nxtfg);\n      }\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef tuple<ll,ll,ll,ll> tp;\ntypedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef ll Def;\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tDef to,cost;\n\t};\n\tvector<vector<edge> >G;\n\tDef n,L;\n//\tvvi d;//distance\n\tDef d[510][50][2];\n\tDIJ(Def size,Def l=0){\n\t\tn=size;\n\t\tL=l;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(Def a,Def b,Def c){\n\t\tedge e={b,c},ee={a,c};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(Def a,Def b,Def c,Def D){\n//\t\td=vvi(n,vi(L+1,inf));\n\t\trep(i,510)rep(j,50)rep(k,2)d[i][j][k]=INF;\n\t\td[0][D][0]=0;\n//\t\td[s][L]=0;//now oktime ->time\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,0,D,0));//time now v_0 n-1????????£??????\n\t\twhile(!q.empty()){\n\t\t\tDef cost,pos,v,t;\n\t\t\ttie(cost,pos,v,t)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[pos][v][t])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tDef to=e.to;\n\t\t\t\tDef ncost=cost+e.cost*v;\n\t\t\t\tDef nv=(a*v+b)%c;\n\t\t\t\tDef nt=t||(to==n-1);\n\t\t\t\tif(ncost<d[to][nv][nt]){\n\t\t\t\t\td[to][nv][nt]=ncost;\n\t\t\t\t\tq.push(tp(-ncost,to,nv,nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll out=INF;\n\t\trep(i,50)out=min(out,d[0][i][1]);\n\t\tcout<<out<<endl;\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tDIJ dij(n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tdij.add_edge(a,b,c);\n\t}\n\tint a,b,c,d;\n\tcin>>d>>a>>b>>c;\n\tdij.dij(a,b,c,d);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n\n\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<long,long> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,long long> piii;\n    vector<vector<long long>>d(n,vector<long long>(51,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<long long>>_d(n,vector<long long>(51,LLONG_MAX/10));\n    rep(i,51)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,51)if(d[n-1][i]!=LLONG_MAX/10)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    long long ans=LLONG_MAX/10;\n    rep(i,51)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n#define int2(x, y) int x, y; scanf(\"%lld %lld\", &x, &y);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nint a, b, c, n;\nint dp[501][50], g[501][501];\n\nsigned main()\n{\n    int m;\n    cin >> n >> m;\n    fill(g[0], g[501], INF);\n    //memset(g, INF, sizeof(g));\n    rep(i, m) {\n        int s, t, u;\n        cin >> s >> t >> u;\n        g[s][t] = u;\n        g[t][s] = u;\n    }\n    Int(v);\n    cin >> a >> b >> c;\n    queue< pair<int, i_i > > q;\n    q.push(mp(0, mp(1, v)));\n    fill(dp[0], dp[501], INF);\n    //memset(dp, INF, sizeof(dp));\n    dp[1][v] = 0;\n    while (!q.empty()) {\n        pair<int, i_i > tmp = q.front(); q.pop();\n        int val = tmp.first, pos = tmp.second.first, \n            ver = tmp.second.second;\n        if (val > dp[pos][ver]) {\n            continue;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (g[pos][i] != INF) {\n                int nval = val + ver * g[pos][i];\n                int nver = (ver * a + b) % c;\n                if (nval < dp[i][nver]) {\n                    dp[i][nver] = nval;\n                    q.push(mp(nval, mp(i, nver)));\n                }\n            }\n        }\n    }\n\n    //Rep(i, n+1) { rep(j, c) { cout << dp[i][j] << \" \"; } cout << endl;}\n    \n    for (int i = 0; i < c; i++) {\n        if (dp[n][i] != INF) {\n            q.push(mp(dp[n][i], mp(n, i)));\n        }\n    }\n\n    //memset(dp, INF, sizeof(dp));\n    fill(dp[0], dp[501], INF);\n    while (!q.empty()) {\n        pair<int, i_i > tmp = q.front(); q.pop();\n        int val = tmp.first, pos = tmp.second.first, \n            ver = tmp.second.second;\n        if (val > dp[pos][ver]) {\n            continue;\n        } else {\n            dp[pos][ver] = val;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (g[pos][i] != INF) {\n                int nval = val + ver * g[pos][i];\n                int nver = (ver * a + b) % c;\n                if (nval < dp[i][nver]) {\n                    dp[i][nver] = nval;\n                    q.push(mp(nval, mp(i, nver)));\n                }\n            }\n        }\n    }\n    int ans = INF;\n    rep(i, c) {\n        ans = min(ans, dp[1][i]);\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(500,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<=now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<=now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(500,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<=now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long> >d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nint d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second.second;\n\t\tint t=now.second.first;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second][i].first;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][nt][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2819.cc: Country in Distortion\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 500;\nconst int MAX_C = 50;\nconst long long LINF = 1LL << 61;\n\n/* typedef */\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nstruct Stat {\n  ll d;\n  int i, v;\n  Stat() {}\n  Stat(ll _d, int _i, int _v): d(_d), i(_i), v(_v) {}\n\n  bool operator<(const Stat &s) const { return d > s.d; }\n};\n\n/* global variables */\n\nvpii nbrs[MAX_N];\nll ds0[MAX_N][MAX_C], ds1[MAX_N][MAX_C];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n\n  for (int i = 0; i < m; i++) {\n    int x, y, t;\n    scanf(\"%d%d%d\", &x, &y, &t);\n    x--, y--;\n    nbrs[x].push_back(pii(y, t));\n    nbrs[y].push_back(pii(x, t));\n  }\n\n  int v0, a, b, c;\n  scanf(\"%d%d%d%d\", &v0, &a, &b, &c);\n\n  for (int i = 0; i < n; i++) {\n    fill(ds0[i], ds0[i] + c, LINF);\n    fill(ds1[i], ds1[i] + c, LINF);\n  }\n\n  int gl = n - 1;\n  ds0[0][v0] = 0;\n  priority_queue<Stat> q;\n  q.push(Stat(0, 0, v0));\n\n  while (! q.empty()) {\n    Stat u = q.top(); q.pop();\n    if (u.d != ds0[u.i][u.v]) continue;\n    if (u.i == gl) continue;\n\n    int vv = ((ll)a * u.v + b) % c;\n    vpii &nbru = nbrs[u.i];\n    for (vpii::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int &vi = vit->first;\n      ll vd = u.d + (ll)u.v * vit->second;\n      if (ds0[vi][vv] > vd) {\n\tds0[vi][vv] = vd;\n\tq.push(Stat(vd, vi, vv));\n      }\n    }\n  }\n  //for (int j = 0; j < c; j++) printf(\"%lld \", ds0[gl][j]); putchar('\\n');\n\n  for (int j = 0; j < c; j++)\n    if (ds0[gl][j] < LINF) {\n      ds1[gl][j] = ds0[gl][j];\n      q.push(Stat(ds0[gl][j], gl, j));\n    }\n\n  ll mind = LINF;\n  while (! q.empty()) {\n    Stat u = q.top(); q.pop();\n    if (u.d != ds1[u.i][u.v]) continue;\n    if (u.i == 0) {\n      mind = u.d;\n      break;\n    }\n\n    int vv = ((ll)a * u.v + b) % c;\n    vpii &nbru = nbrs[u.i];\n    for (vpii::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int &vi = vit->first;\n      ll vd = u.d + (ll)u.v * vit->second;\n      if (ds1[vi][vv] > vd) {\n\tds1[vi][vv] = vd;\n\tq.push(Stat(vd, vi, vv));\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", mind);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tnot_visited,\n\tvisited,\n};\n\nstruct Info{\n\tInfo(int arg_node_id,ll arg_sum_dist,ll arg_v,Type arg_type){\n\t\tnode_id = arg_node_id;\n\t\tsum_dist = arg_sum_dist;\n\t\tv = arg_v;\n\t\ttype = arg_type;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t};\n\tint node_id;\n\tll sum_dist,v;\n\tType type;\n};\n\nstruct Data{\n\tData(int arg_to,ll arg_time){\n\t\tto = arg_to;\n\t\ttime = arg_time;\n\t}\n\tint to;\n\tll time;\n};\n\nint N,M;\nll A,B,C;\nll min_dist[2][500][50];\n\nll calc_V(ll pre_v){\n\treturn (A*pre_v+B)%C;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tvector<Data> V[N];\n\n\tint from,to;\n\tll time;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %lld\",&from,&to,&time);\n\t\tfrom--;\n\t\tto--;\n\t\tV[from].push_back(Data(to,time));\n\t\tV[to].push_back(Data(from,time));\n\t}\n\n\tll first_v;\n\tscanf(\"%lld\",&first_v);\n\tscanf(\"%lld %lld %lld\",&A,&B,&C);\n\n\tfor(int a = 0; a < 2; a++){\n\t\tfor(int b = 0; b < N; b++){\n\t\t\tfor(int c = 0; c < 50; c++)min_dist[a][b][c] = 999999999999999;\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tmin_dist[not_visited][0][first_v] = 0;\n\tQ.push(Info(0,0,first_v,not_visited));\n\n\tll ans = 999999999999999;\n\tint next_node;\n\tll next_v;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == 0 && Q.top().type == visited){\n\t\t\tans = min(ans,Q.top().sum_dist);\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_dist > min_dist[Q.top().type][Q.top().node_id][Q.top().v]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tnext_v = calc_V(Q.top().v);\n\n\t\t\tfor(int i = 0; i < V[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = V[Q.top().node_id][i].to;\n\n\t\t\t\tif(next_node != N-1){\n\t\t\t\t\tif(min_dist[Q.top().type][next_node][next_v] > Q.top().sum_dist+Q.top().v*V[Q.top().node_id][i].time){\n\t\t\t\t\t\tmin_dist[Q.top().type][next_node][next_v] = Q.top().sum_dist+Q.top().v*V[Q.top().node_id][i].time;\n\t\t\t\t\t\tQ.push(Info(next_node,min_dist[Q.top().type][next_node][next_v],next_v,Q.top().type));\n\t\t\t\t\t}\n\t\t\t\t}else{ //next_node == N-1\n\t\t\t\t\tif(min_dist[visited][next_node][next_v] > Q.top().sum_dist+Q.top().v*V[Q.top().node_id][i].time){\n\t\t\t\t\t\tmin_dist[visited][next_node][next_v] = Q.top().sum_dist+Q.top().v*V[Q.top().node_id][i].time;\n\t\t\t\t\t\tQ.push(Info(next_node,min_dist[visited][next_node][next_v],next_v,visited));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nint d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second.second;\n\t\tint t=now.second.first;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second][i].first;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nlong long d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second.second;\n\t\tint t=now.second.first\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second].first;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define int long long\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,int> piii;\n    vector<vector<int>>d(n,vector<int>(100,LLONG_MAX));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<int>>_d(n,vector<int>(101,LLONG_MAX));\n    rep(i,c+1)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,c+1)if(d[n-1][i]!=LLONG_MAX)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=LLONG_MAX;\n    rep(i,100)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long ll;\nconst ll INFLL = 1e18;\n\nstruct Edge {\n    int to; ll t;\n    Edge(int _to, ll _t) : to(_to), t(_t) {}\n};\n\nstruct State {\n    int id, v; ll d;\n    State(int _id, int _v, ll _d) : id(_id), v(_v), d(_d) {}\n    bool operator < (const State &b) const {return d < b.d;}\n    bool operator > (const State &b) const {return d > b.d;}\n};\n\ntypedef pair<int, int> PII;\n\nvector<vector<Edge>> G;\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n\n    G.resize(N);\n\n    rep(i, M) {\n        int X, Y, T;\n        cin >> X >> Y >> T;\n        X--, Y--;\n        G[X].push_back(Edge(Y, T));\n        G[Y].push_back(Edge(X, T));\n    }\n\n    int V0, A, B, C;\n    cin >> V0 >> A >> B >> C;\n\n    priority_queue<State, vector<State>, greater<State>> Q, Q2;\n    map<PII, ll> d, d2;\n\n    {\n        d[PII(0, V0)] = 0LL;\n        Q.push({0, V0, 0LL});\n\n        while (Q.size()) {\n            State s = Q.top(); Q.pop();\n            // cerr << \"(id, v) = (\" << s.id << \", \" << s.v << \")\" << endl;\n            if (s.id == N-1) {\n                Q2.push(s);\n                d2[PII(s.id, s.v)] = s.d;\n            }\n\n            if (d.count(PII(s.id, s.v)) && d[PII(s.id, s.v)] < s.d) continue;\n            for (auto e : G[s.id]) {\n                ll ncost = s.d + s.v * e.t;\n                int nv = (A * s.v + B) % C;\n\n                if (!d.count(PII(e.to, nv)) || d[PII(e.to, nv)] > ncost) {\n                    d[PII(e.to, nv)] = ncost;\n                    Q.push(State(e.to, nv, ncost));\n                }\n            }\n        }\n    }\n\n    // cerr << \"-------------------\" << endl;\n\n    ll ans = INFLL;\n    {\n        while (Q2.size()) {\n            State s = Q2.top(); Q2.pop();\n            // cerr << \"(id, v) = (\" << s.id << \", \" << s.v << \")\" << endl;\n\n            if (s.id == 0) {\n                ans = s.d;\n                break;\n            }\n\n            if (d2.count(PII(s.id, s.v)) && d2[PII(s.id, s.v)] < s.d) continue;\n            for (auto e : G[s.id]) {\n                ll ncost = s.d + s.v * e.t;\n                int nv = (A * s.v + B) % C;\n\n                if (!d2.count(PII(e.to, nv)) || d2[PII(e.to, nv)] > ncost) {\n                    d2[PII(e.to, nv)] = ncost;\n                    Q2.push(State(e.to, nv, ncost));\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint v,a,b,c;\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[111][1111];\nint dp[111][1111];\nvoid add_edge(int time,int from,int to,int cost){\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n  G[time][to].push_back(edge(time,from,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c*2;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i]);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i]);\n      ve=(a*ve+b)%c;\n    }\n  }\n  for(int j=0;j<c*2;j++) add_edge2(j,n-1,n+n-1,0);\n  \n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=1LL<<50LL;\n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  dp[0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int t=p.time,u=p.pos,d=p.dist;\n    //cout<<t<<\" \"<<u<<\" \"<<d<<endl;\n    if(u==n){\n      ans=d;\n      break;\n    }\n    if(dp[t][u]<d) continue;\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(dp[nt][nu]<0||d+nc<dp[nt][nu]){\n\tdp[nt][nu]=d+nc;\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[55][1111];\nint dp[55][1111];\nvoid add_edge(int time,int from,int to,int cost,int c){\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  int v,a,b,c;\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i],c);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i],c);\n      ve=(a*ve+b)%c;\n    }\n  }\n\n  for(int j=0;j<c;j++) add_edge2(j,n-1,n+n-1,0);\n  \n  //memset(dp,-1,sizeof(dp));\n  int INF=1LL<<60LL;\n  for(int i=0;i<c;i++)\n    for(int j=0;j<n*2;j++)\n      dp[i][j]=INF;\n  \n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int d=p.dist,t=p.time,u=p.pos;\n    assert(0<=t&&t<c);\n    //cout<<d<<\" \"<<t<<\" \"<<u<<endl;\n    if(u==n){\n      cout<<d<<endl;\n      return 0;\n    }\n    if(dp[t][u]<=d) continue;\n    dp[t][u]=d;\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(d+nc<dp[nt][nu]){\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  assert(0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\n\nstruct Edge { int dst; ll w; };\nstruct Data {\n  int cur,v; ll w;\n  bool operator < ( const Data &e ) const {\n    if( w != e.w ) return w > e.w;\n    if( v != e.v ) return v > e.v;\n    return cur > e.cur;\n  }\n};\n\n#define MAX_V 510\n\nint V,E;\nll v0,a,b,c;\nll mini[MAX_V][51][2];\nvector<Edge> G[MAX_V];\n\nll cost1;\nll adhoc = LLINF;\nvoid dijkstra(int sp,int v0) {\n  rep(i,V) rep(j,c) mini[i][j][sp==(V-1)] = LLINF;\n  priority_queue<Data> Q;\n  Q.push((Data){sp,v0,0});\n  mini[sp][v0][sp==(V-1)] = 0;\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      int nv = ( a * data.v + b ) % c;\n      ll nw = data.w + e.w * data.v;\n\n      if( nw < mini[e.dst][nv][sp==(V-1)] ) {\n        mini[e.dst][nv][sp==(V-1)] = nw;\n        Q.push((Data){e.dst,nv,nw});\n      }\n    }\n  }\n}\n\nvoid compute() {\n  dijkstra(0,v0);\n  ll ans = LLINF;\n  rep(i,c) {\n    if( mini[V-1][i][0] != LLINF ) {\n      ll cost = mini[V-1][i][0];\n      if( cost >= ans ) continue;\n      cost1 = cost;\n      dijkstra(V-1,i);\n      ll tmp = LLINF;\n      rep(j,c) tmp = min(tmp,mini[0][j][1]);\n      if( tmp == LLINF ) continue;\n      ans = min(ans,cost+tmp);\n      adhoc = ans;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  rep(i,E) {\n    int x,y,t;\n    cin >> x >> y >> t;\n    --x,--y;\n    G[x].push_back((Edge){y,t});\n    G[y].push_back((Edge){x,t});\n  } \n  cin >> v0 >> a >> b >> c;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define rep(i,n) for (int i = 0; i < (n); ++i)\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nconst ll INF=1LL<<60;\nconst int inf=1<<30;\nconst int mod=1e9+7;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;cin >> n >> m;\n    vector<vector<pair<int,ll>>> g(n);\n    for(int i=0;i<m;i++){\n        int x,y,t;cin >> x >> y >> t;\n        x--,y--;\n        g[x].push_back({y,t});\n        g[y].push_back({x,t});\n    }\n    priority_queue<pair<ll,pair<ll,ll>>,vector<pair<ll,pair<ll,ll>>>,greater<pair<ll,pair<ll,ll>>>> pq;\n    int v0;cin >> v0;\n    int a,b,c;cin >> a >> b >> c;\n    vector<vector<ll>> d(n,vector<ll>(c,INF));\n    d[0][v0]=0;\n    pq.push({0,{v0,0}});\n    while(!pq.empty()){\n        ll u=pq.top().first,v=pq.top().second.first,w=pq.top().second.second;\n        pq.pop();\n        if(u>d[w][v]){\n            continue;\n        }\n        for(auto e:g[w]){\n            ll x=e.first,y=e.second;\n            if(chmin(d[x][(a*v+b)%c],d[w][v]+y*v)){\n                pq.push({d[x][(a*v+b)%c],{(a*v+b)%c,x}});\n            }\n        }\n    }\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<c;j++){\n            d[i][j]=INF;\n        }\n    }\n    for(int i=0;i<c;i++){\n        pq.push({d[n-1][i],{i,n-1}});\n    }\n    while(!pq.empty()){\n        ll u=pq.top().first,v=pq.top().second.first,w=pq.top().second.second;\n        pq.pop();\n        if(u>d[w][v]){\n            continue;\n        }\n        for(auto e:g[w]){\n            ll x=e.first,y=e.second;\n            if(chmin(d[x][(a*v+b)%c],d[w][v]+y*v)){\n                pq.push({d[x][(a*v+b)%c],{(a*v+b)%c,x}});\n            }\n        }\n    }\n    ll ans=INF;\n    for(int i=0;i<c;i++){\n        chmin(ans,d[0][i]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<uint> divisor(uint x){ vector<uint> ans; for(uint i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\nstruct WeightedEdge{\n    ll to, cost;\n    WeightedEdge(){}\n    WeightedEdge(ll to, ll cost): to(to), cost(cost){}\n    operator ll() const { return to; }\n};\nstruct WeightedGraph{\n    using E = WeightedEdge;\n    vector<vector<E>> g;\n    WeightedGraph(){}\n    WeightedGraph(ll n): g(n){}\n    vector<E>& operator[](ll at){ return g[at]; }\n    operator vector<vector<E>>&(){ return g; }\n    auto begin() const { return g.cbegin(); }\n    auto end() const { return g.cend(); }\n    ll size() const { return g.size(); }\n    void resize(ll n){ g.resize(n); }\n    const vector<E>& operator[](ll at) const { return g[at]; }\n    operator const vector<vector<E>>&() const { return g; }\n    void add_edge(ll a, ll b, ll cost){\n        g[a].emplace_back(b, cost);\n        g[b].emplace_back(a, cost);\n    }\n    void add_directed_edge(ll from, ll to, ll cost){\n        g[from].emplace_back(to, cost);\n    }\n    template<ll start_index = 1, bool directed = false> void input_graph(ll m){\n        while(m--){\n            ll a, b, c;\n            scanf(\"%lld%lld%lld\", &a, &b, &c);\n            a -= start_index;\n            b -= start_index;\n            g[a].emplace_back(b, c);\n            if(!directed) g[b].emplace_back(a, c);\n        }\n    }\n    template<ll start_index = 1> void input_tree(ll n){ input_graph<start_index>(n - 1); }\n};\nll n, a, b, c, v;\ntemplate<class Graph> ll Dijkstra(const Graph& g){\n    using tuplis=array<ll,4>;\n    ll cost[500][50][2];\n    bool used[500][50][2]={};\n    memset(cost, 0x33, sizeof(cost));\n    pq<tuplis> q;\n    cost[0][v][0] = 0;\n    q.push({0, 0, v, 0});\n    while(q.size()){\n        ll at=q.top()[1],v=q.top()[2],f=q.top()[3];\n        q.pop();\n        if(used[at][v][f])continue;\n        used[at][v][f] = 1;\n        each(at2, g[at]){\n            ll v2=(v*a+b)%c;\n            ll f2=f||at2==n-1;\n            if(chmin(cost[at2][v2][f2],cost[at][v][f]+at2.cost*v))q.push({cost[at2][v2][f2],at2,v2,f2});\n        }\n    }\n    ll ans=LINF;\n    rep(50)chmin(ans,cost[0][i][1]);\n    return ans;\n}\nsigned main(){\n    in(n);\n    LL(m);\n    WeightedGraph g(n);\n    g.input_graph(m);\n    in(v,a,b,c);\n    out(Dijkstra(g));\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P>PP;\nint n,m,x,y,t,d[51][501][2],v0,a,b,c;\nvector<P>G[501];\nint dijkstra(){\n    priority_queue<PP,vector<PP>,greater<PP> >q;\n    r(i,51)r(j,501)r(k,2)d[i][j][k]=1e17;\n    q.push(PP(P(0,v0),P(0,0)));\n    while(!q.empty()){\n        PP p=q.top();q.pop();\n        if(d[p.f.s][p.s.f][p.s.s]<p.f.f)continue;\n        if(!p.s.f&&p.s.s)return p.f.f;\n        if(p.s.f==n-1&&!p.s.s)if(d[p.f.s][p.s.f][1]<p.f.f){\n            q.push(PP(P(p.f.f,p.f.s),P(p.s.f,1)));\n            d[p.f.s][p.s.f][p.s.s]=p.f.f;\n        }\n        r(i,G[p.s.f].size()){\n            int v=(a*p.f.s+b)%c;\n            int cost=p.f.f+p.f.s*G[p.f.s][i].s;\n            int to=G[p.f.s][i].f;\n            if(d[v][to][p.s.s]>cost){\n                d[v][to][p.s.s]=cost;\n                q.push(PP(P(cost,v),P(to,p.s.s)));\n            }\n        }    }\n}\nmain(){\n    cin>>n>>m;\n    r(i,m){\n        cin>>x>>y>>t;\n        x--;y--;\n        G[x].push_back(P(y,t));\n        G[y].push_back(P(x,t));\n    }\n    cin>>v0>>a>>b>>c;\n    cout<<dijkstra()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef long long ll;\nstruct edge{int to;ll cost;};\nvector<edge> G[60000];\nll dp[60000];\npriority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> qu;//dp[],2*(n-1)*c+v\n\nint a,b,c;\nint nextv(int v){ return (a*v+b)%c;}\n\nint main(void){\n\tint n,m,v0;\n\tcin>>n>>m;\n\tvector<int> x(m),y(m);\n\tvector<ll> t(m); \n\trep(i,m){\n\t\tcin>>x[i]>>y[i]>>t[i];\n\t\t--x[i];\n\t\t--y[i];\n\t}\n\tcin>>v0>>a>>b>>c;\n\trep(i,m)rep(v,c){\n\t\tG[x[i]*c+v].push_back({y[i]*c+nextv(v),t[i]*v});\n\t\tG[y[i]*c+v].push_back({x[i]*c+nextv(v),t[i]*v});\t\n\t\tG[((n-1)*2-x[i])*c+v].push_back({((n-1)*2-y[i])*c+nextv(v),t[i]*v});\n\t\tG[((n-1)*2-y[i])*c+v].push_back({((n-1)*2-x[i])*c+nextv(v),t[i]*v});\n\t}\n\trep(i,60000)dp[i]=LLONG_MAX;\n\tdp[v0]=0;\n\tqu.push({0,v0});\n\twhile(qu.size()){\n\t\tpair<ll,int> u = qu.top();\n\t\tqu.pop();\n\t\tif(u.second/c==2*(n-1)){\n\t\t\tcout<<dp[u.second]<<endl;\n\t\t\treturn 0;\t\t\t\n\t\t}\n\t\tif(dp[u.second] < u.first)continue;\n\t\tfor(auto e:G[u.second]){\n\t\t\tif(dp[e.to] > dp[u.second] + e.cost){\n\t\t\t\tdp[e.to] = dp[u.second] + e.cost;\n\t\t\t\tqu.push({dp[e.to],e.to});\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t// ll res = LLONG_MAX;\n\t// rep(i,c){\n\t// \tres = min(res,dp[2*(n-1)*c+i]);\n\t// }\n\t// cout<<res<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P>PP;\nint n,m,x,y,t,d[51][501][2],v0,a,b,c;\nvector<P>G[501];\nint dijkstra(){\n    priority_queue<PP,vector<PP>,greater<PP> >q;\n    r(i,51)r(j,501)r(k,2)d[i][j][k]=1e17;\n    q.push(PP(P(0,v0),P(0,0)));\n    while(!q.empty()){\n        PP p=q.top();q.pop();\n        if(d[p.f.s][p.s.f][p.s.s]<p.f.f)continue;\n        if(!p.s.f&&p.s.s)return p.f.f;\n        if(p.s.f==n-1&&!p.s.s)if(d[p.f.s][p.s.f][1]>p.f.f){\n            q.push(PP(P(p.f.f,p.f.s),P(p.s.f,1)));\n            d[p.f.s][p.s.f][1]=p.f.f;\n        }\n        r(i,G[p.s.f].size()){\n            int v=(a*p.f.s+b)%c;\n            int cost=p.f.f+p.f.s*G[p.s.f][i].s;\n            int to=G[p.s.f][i].f;\n            if(d[v][to][p.s.s]>cost){\n                d[v][to][p.s.s]=cost;\n                q.push(PP(P(cost,v),P(to,p.s.s)));\n            }\n        }    \n    }\n}\nmain(){\n    cin>>n>>m;\n    r(i,m){\n        cin>>x>>y>>t;\n        x--;y--;\n        G[x].push_back(P(y,t));\n        G[y].push_back(P(x,t));\n    }\n    cin>>v0>>a>>b>>c;\n    cout<<dijkstra()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 501\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nll const INF = 1LL<<55;\nll n,m;\nvector<P> G[N];\nll v0,a,b,C;\nll v[5010];\n\nint nv(ll v){return (v*a+b)%C;}\n\nll dijkstra(ll start,ll goal,ll c){\n  ll D[500][100];\n  for(ll i=0;i<500;i++)\n    for(ll j=0;j<100;j++) D[i][j] = INF;\n\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(start,c)));\n  D[start][c] = 0;\n  ll res = INF;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    ll cost = t.first; \n    ll pos = t.second.first;\n    ll v = t.second.second;\n    if(D[pos][v]<cost) continue;\n    if(pos==goal&&goal == 0)return cost; \n    if(pos==goal&&goal == n-1){\n      res=min(res,cost+dijkstra(n-1,0,v));\n      continue;\n    }\n\n    for(ll i=0;i<(ll)G[pos].size();i++){\n      ll npos = G[pos][i].first;\n      ll ncost= cost+v*G[pos][i].second;\n      ll nV = nv(v); \n     if(D[npos][nV]<=ncost)continue;\n      Q.push(PP(ncost,P(npos,nV)));\n      D[npos][nV] = ncost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(ll i=0,x,y,t;i<m;i++){\n    cin>>x>>y>>t;\n    x--,y--;\n    G[x].push_back(P(y,t));\n    G[y].push_back(P(x,t));\n  }\n\n  int v0;\n  cin>>v0>>a>>b>>C;\n  cout<<dijkstra(0,n-1,v0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N,M;\nint A, B, C;\nstruct edge {\n  int to;\n  ll t;\n  edge(){\n\n  }\n  edge(int to,ll t):to(to),t(t){}\n};\nstruct state{\n  int id,v,f;\n  ll c;\n  state(){\n\n  }\n  state(int id,int v,int f,ll c):id(id),v(v),f(f),c(c){}\n  bool operator<(const state &st) const {\n    return c > st.c;\n  }\n};\n\nll H[555][55][2];\nconst ll INF = (ll)(1<<29)*(ll)(1<<29);\nvector<edge> G[555];\n\nll dijk(int v0){\n  priority_queue<state> q;\n  fill( H[0][0], H[553][51], INF );\n  q.push( state(0,v0,0,0) );\n  H[0][v0][0] = 0LL;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( H[p.id][p.v][p.f] < p.c ) continue;\n    for( edge e : G[p.id] ){\n      int nv = (A * p.v + B)%C;\n\n      int nf = p.f; if( e.to == N-1 ) nf = 1;\n      ll nc = (ll)p.v * e.t + p.c;\n      if( H[e.to][nv][nf] > nc ){\n        H[e.to][nv][nf] = nc;\n        q.push( state( e.to, nv, nf, nc ) );\n      }\n    }\n  }\n  ll res = INF;\n  for(int i=0;i<=C;i++)\n    res = min( res, H[0][i][1] );\n  return res;\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int x,y; ll t;\n    cin >> x >> y >> t; --x; --y;\n    G[x].emplace_back( y, t );\n    G[y].emplace_back( x, t );\n  }\n  int v0; cin >> v0;\n  cin >> A >> B >> C;\n  cout << dijk(v0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint v,a,b,c;\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[55][1111];\nint dp[55][1111];\nvoid add_edge(int time,int from,int to,int cost){\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n  G[time][to].push_back(edge(time,from,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i]);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i]);\n      ve=(a*ve+b)%c;\n    }\n  }\n  for(int j=0;j<c;j++) add_edge2(j,n-1,n+n-1,0);\n  \n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=1LL<<50LL;\n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  dp[0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int t=p.time,u=p.pos,d=p.dist;\n    assert(0<=t&&t<c);\n    //cout<<t<<\" \"<<u<<\" \"<<d<<endl;\n    if(u==n){\n      ans=d;\n      break;\n    }\n    if(dp[t][u]<d) continue;\n    assert(dp[t][u]==d);\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(dp[nt][nu]<0||d+nc<dp[nt][nu]){\n\tdp[nt][nu]=d+nc;\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  assert(ans>=0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n\n\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<long,long> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,long long> piii;\n    vector<vector<long long>>d(n,vector<long long>(60,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<long long>>_d(n,vector<long long>(60,LLONG_MAX/10));\n    rep(i,c+1)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,c+1)if(d[n-1][i]!=LLONG_MAX/10)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    long long ans=LLONG_MAX/10;\n    rep(i,100)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,v0;\nint a,b,c;\nvector<P> G[501];\nll dp[501][51][2];\n\nstruct data{\n\tint v,f;\n\tll c,sp;\n\tdata(){}\n\tdata(int vv,ll ss,ll cc,int ff){\n\t\tv=vv;\n\t\tsp=ss;\n\t\tc=cc;\n\t\tf=ff;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn c>d.c;\n\t}\n};\n\nll dijkstra(){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tque.push(data(1,v0,0,0));\n\tdp[1][v0][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.sp][q.f]<q.c)continue;\n\t\tif(q.v==n)q.f=1;\n\t\tif(q.v==1 && q.f==1)return q.c;\n\t\tfor(int i=0;i<G[q.v].size();i++){\n\t\t\tint nv=(a*q.sp+b)%c;\n\t\t\tif(dp[G[q.v][i].first][nv][q.f]>q.c+q.sp*G[q.v][i].second){\n\t\t\t\tdp[G[q.v][i].first][nv][q.f]=q.c+q.sp*G[q.v][i].second;\n\t\t\t\tque.push(data(G[q.v][i].first,nv,dp[G[q.v][i].first][nv][q.f],q.f));\n\t\t\t}\n\t\t\tif(dp[G[q.v][i].first][nv][q.f]==-1){\n\t\t\t\tdp[G[q.v][i].first][nv][q.f]=q.c+q.sp*G[q.v][i].second;\n\t\t\t\tque.push(data(G[q.v][i].first,nv,dp[G[q.v][i].first][nv][q.f],q.f));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\",&f,&t,&c);\n\t\tG[f].push_back(P(t,c));\n\t\tG[t].push_back(P(f,c));\n\t}\n\tscanf(\"%d\",&v0);\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tprintf(\"%lld\\n\",dijkstra());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 501\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nll const INF = 1LL<<60;\nll n,m;\nvector<P> G[N];\nll v0,a,b,C;\nll v[50100];\n\nll nC;\nll dijkstra(ll start,ll goal,ll c){\n  ll D[500][5001];\n  for(ll i=0;i<500;i++)\n    for(ll j=0;j<5001;j++) D[i][j] = INF;\n\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(start,c)));\n  D[start][c] = 0;\n  ll res = INF;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    ll cost = t.first; \n    ll pos = t.second.first;\n    ll cnt = t.second.second;\n    if(D[pos][cnt]<cost) continue;\n    if(pos==goal&&goal == 0)return cost; \n    if(pos==goal&&goal == n-1){\n      res=min(res,cost+dijkstra(n-1,0,cnt));\n      continue;\n    }\n    for(ll i=0;i<(ll)G[pos].size();i++){\n      ll npos = G[pos][i].first;\n      ll ncost= cost+v[cnt]*G[pos][i].second;\n      ll ncnt = (cnt+1)%nC;\n      if(D[npos][ncnt]<=ncost)continue;\n      Q.push(PP(ncost,P(npos,ncnt)));\n      D[npos][ncnt] = ncost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(ll i=0,x,y,t;i<m;i++){\n    cin>>x>>y>>t;\n    x--,y--;\n    G[x].push_back(P(y,t));\n    G[y].push_back(P(x,t));\n  }\n  cin>>v[0]>>a>>b>>C;\n  set<ll> S;\n  S.insert(v[0]);\n  for(ll i=1;;i++){\n    v[i] = (a*v[i-1]+b)%C;\n    if(S.count(v[i]))break;\n    S.insert(v[i]);\n  }\n  nC=S.size();\n  cout<<dijkstra(0,n-1,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tnot_visited,\n\tvisited,\n};\n\nstruct Info{\n\tInfo(int arg_node_id,ll arg_sum_dist,ll arg_v,Type arg_type){\n\t\tnode_id = arg_node_id;\n\t\tsum_dist = arg_sum_dist;\n\t\tv = arg_v;\n\t\ttype = arg_type;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t};\n\tint node_id;\n\tll sum_dist,v;\n\tType type;\n};\n\nstruct Data{\n\tData(int arg_to,ll arg_time){\n\t\tto = arg_to;\n\t\ttime = arg_time;\n\t}\n\tint to;\n\tll time;\n};\n\nint N,M;\nll A,B,C;\nll min_dist[2][500][50];\n\nll calc_V(ll pre_v){\n\treturn (A*pre_v+B)%C;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tvector<Data> V[N];\n\n\tint from,to;\n\tll time;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %lld\",&from,&to,&time);\n\t\tfrom--;\n\t\tto--;\n\t\tV[from].push_back(Data(to,time));\n\t\tV[to].push_back(Data(from,time));\n\t}\n\n\tll first_v;\n\tscanf(\"%lld\",&first_v);\n\tscanf(\"%lld %lld %lld\",&A,&B,&C);\n\n\tfor(int a = 0; a < 2; a++){\n\t\tfor(int b = 0; b < N; b++){\n\t\t\tfor(int c = 0; c < 50; c++)min_dist[a][b][c] = 999999999999999;\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tmin_dist[not_visited][0][first_v] = 0;\n\tQ.push(Info(0,0,first_v,not_visited));\n\n\tll ans = 999999999999999;\n\tint next_node;\n\tll next_v;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == 0 && Q.top().type == visited){\n\t\t\tans = min(ans,Q.top().sum_dist);\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_dist > min_dist[Q.top().type][Q.top().node_id][Q.top().v] || Q.top().sum_dist >= ans){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tnext_v = calc_V(Q.top().v);\n\n\t\t\tfor(int i = 0; i < V[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = V[Q.top().node_id][i].to;\n\n\t\t\t\tif(next_node != N-1){\n\t\t\t\t\tif(min_dist[Q.top().type][next_node][next_v] > Q.top().sum_dist+Q.top().v*V[Q.top().node_id][i].time){\n\t\t\t\t\t\tmin_dist[Q.top().type][next_node][next_v] = Q.top().sum_dist+Q.top().v*V[Q.top().node_id][i].time;\n\t\t\t\t\t\tQ.push(Info(next_node,min_dist[Q.top().type][next_node][next_v],next_v,Q.top().type));\n\t\t\t\t\t}\n\t\t\t\t}else{ //next_node == N-1\n\t\t\t\t\tif(min_dist[visited][next_node][next_v] > Q.top().sum_dist+Q.top().v*V[Q.top().node_id][i].time){\n\t\t\t\t\t\tmin_dist[visited][next_node][next_v] = Q.top().sum_dist+Q.top().v*V[Q.top().node_id][i].time;\n\t\t\t\t\t\tQ.push(Info(next_node,min_dist[visited][next_node][next_v],next_v,visited));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//int N,M,K,L,R,H,W;\nlong long int N,M,K,L,R,H,W;\n\nconstexpr long long int MOD=1000000007;\n//constexpr  int MOD=1000000007;\n//constexpr int MOD=998244353;\n//constexpr long long int MOD=998244353;\n\nconstexpr long double EPS=1e-8;\n\nstruct Edge{\n\tint to;\n\tlong long int cost;\n\tEdge(const int tt,const long long int cc){\n\t\tto=tt,cost=cc;\n\t\treturn;\n\t}\t\n};\n\nstruct Node{\n\tint node,nx,goal;\n\tNode(const int no,const int nnx,const int go){\n\t\tnode=no,nx=nnx,goal=go;\n\t\treturn;\n\t}\n\tbool operator<(const Node&n)const{\n\t\treturn node<n.node;\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tcin>>N>>M;\n\tvector<vector<Edge>>edge(N);\n\tfor(int i=0;i<M;i++){\n\t\tcin>>L>>R>>K;\n\t\tL--;\n\t\tR--;\n\t\tedge[L].push_back(Edge(R,K));\n\t\tedge[R].push_back(Edge(L,K));\n\t}\n\tvector<int>v(50*500+1);\n\tcin>>v[0];\n\tint a,b,c;\n\tcin>>a>>b>>c;\n\tvector<vector<vector<long long int>>>dp(N,vector<vector<long long int>>(50,vector<long long int>(2,MOD*MOD)));\n\tdp[0][v[0]][0]=0;\n\tpriority_queue<pair<long long int ,Node>,vector<pair<long long int ,Node>>,greater<pair<long long int ,Node>>>PQ;\n\tPQ.push({0,Node(0,v[0],0)});\n\twhile(!PQ.empty()){\n\t\tlong long int co=PQ.top().first;\n\t\tauto box=PQ.top().second;\n\t\t//cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n\t\t//cout<<co<<\" \"<<box.node<<\" \"<<box.nx<<\" \"<<box.goal<<endl;\n\t\tPQ.pop();\n\t\tint nx=box.nx*a+b;\n\t\tnx%=c;\n\t\t//cout<<\"nx \"<<nx<<endl;\n\t\tfor(auto i:edge[box.node]){\n\t\t\t//cout<<\"edge \"<<i.to<<\" \"<<i.cost<<endl;\n\t\t\tif(dp[i.to][nx][box.goal]>co+box.nx*i.cost){\n\t\t\t\tdp[i.to][nx][box.goal]=co+box.nx*i.cost;\n\t\t\t\tPQ.push({dp[i.to][nx][box.goal],Node(i.to,nx,box.goal)});\n\t\t\t}\n\t\t\tif(i.to==N-1){\n\t\t\t\t//cout<<\"goal\"<<endl;\n\t\t\t\t//cout<<dp[i.to][nx][1]<<\" \"<<co+box.nx*i.cost<<endl;\n\t\t\t\tif(dp[i.to][nx][1]>co+box.nx*i.cost){\n\t\t\t\t\tdp[i.to][nx][1]=co+box.nx*i.cost;\n\t\t\t\t\tPQ.push({dp[i.to][nx][1],Node(i.to,nx,1)});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans=MOD*MOD;\n\tfor(int i=0;i<50;i++){\n\t\tans=min(ans,dp[0][i][1]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nstruct Edge {\n    ll to, cost;\n    Edge(ll t, ll c) : to(t), cost(c) {}\n};\nstruct Elem {\n    ll dist, speed, cur;\n    Elem(ll a, ll b, ll c) : dist(a), speed(b), cur(c) {}\n};\nbool operator>(const Elem& a, const Elem& b) {\n    return a.dist != b.dist ? a.dist > b.dist : a.speed > b.speed;\n}\n\ntypedef vector< vector<Edge> > Graph;\nll const INF = 1LL << 60;\n\nint main() {\n    ll dist[510][60][2];\n    ll ans = INF;\n    for(int i=0; i<510; i++)\n        for(int j=0; j<60; j++)\n            for(int k=0; k<2; k++)\n                dist[i][j][k] = INF;\n\n    int n, m; cin >> n >> m;\n    Graph G(n);\n    for(int i=0; i<m; i++) {\n        ll a, b, t; cin >> a >> b >> t;\n        a--; b--;\n        G[a].push_back(Edge(b,t));\n        G[b].push_back(Edge(a,t));\n    }\n    ll v, a, b, c;\n    cin >> v >> a >> b >> c;\n    priority_queue< Elem, vector<Elem>, greater<Elem> > q;\n\n    ll cur = 0, speed = v;\n    dist[0][v][0] = 0;\n    q.push(Elem(0, speed, cur));\n    while(!q.empty()) {\n        Elem temp = q.top(); q.pop();\n        cur = temp.cur, speed = temp.speed;\n        ll nsp = (a * speed + b) % c;\n        for(size_t i=0; i<G[cur].size(); i++) {\n            Edge e = G[cur][i];\n            ll d1 = dist[cur][speed][0] + e.cost * speed;\n            ll d2 = dist[cur][speed][1] + e.cost * speed;\n            // home to university\n            if(dist[e.to][nsp][0] > d1) {\n                dist[e.to][nsp][0] = d1;\n                if(e.to == n-1) dist[e.to][nsp][1] = dist[e.to][nsp][0];\n                q.push(Elem(d1, nsp, e.to));\n            }\n            // university to home\n            if(dist[e.to][nsp][1] > d2) {\n                dist[e.to][nsp][1] = d2;\n                q.push(Elem(d2, nsp, e.to));\n            }\n        }\n    }\n\n    for(int i=0; i<c; i++) ans = min(ans, dist[0][i][1]);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define int long long\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,int> piii;\n    vector<vector<int>>d(n,vector<int>(100,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    bool visit=true;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n            if(next.first==n-1&&visit){\n                visit=false;\n                //cout<<d[next.first][_v]<<endl;\n                while(!que.empty())que.pop();\n                vector<vector<int>>_d(n,vector<int>(100,LLONG_MAX/10));\n                _d[n-1]=d[n-1];\n                d=_d;\n                que.push(piii(pii(d[n-1][_v],n-1),_v));\n                continue;\n            }\n        }\n    }\n    int ans=LLONG_MAX;\n    rep(i,c+1)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\ninline size_t hashCombine(size_t seed, const T& v) {\n    return seed ^ (hash<T>()(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2));\n}\n\nnamespace std {\ntemplate <typename T, typename S>\nclass hash<pair<T, S>> {\n public:\n    size_t operator()(const pair<T, S>& p) const {\n        size_t seed = 0;\n        seed = hashCombine(seed, p.first);\n        seed = hashCombine(seed, p.second);\n        return seed;\n    }\n};\ntemplate <typename... Ts>\nclass hash<tuple<Ts...>> {\n public:\n    size_t operator()(const tuple<Ts...>& t) const { return impl<0>(t); }\n\n private:\n    template <size_t Index>\n    typename enable_if<Index == tuple_size<tuple<Ts...>>::value, size_t>::type\n    impl(const tuple<Ts...>&) const {\n        return 0;\n    }\n    template <size_t Index>\n    typename enable_if<Index != tuple_size<tuple<Ts...>>::value, size_t>::type\n    impl(const tuple<Ts...>& t) const {\n        return hashCombine(impl<Index + 1>(t), get<Index>(t));\n    }\n};\n}\n\nint n, m;\nint a, b, c;\nint v0;\nstruct Edge {\n    int to, t;\n    Edge(int to = 0, int t = 0) : to(to), t(t) {}\n};\nint update(int v) { return (a * v + b) % c; }\nvector<Edge> G[502];\nusing State = tuple<int, int, int>;\nunordered_map<State, ll> dp;\npriority_queue<pair<ll, State>> que;\n\nint main() {\n    cin >> n >> m;\n    rep(i, m) {\n        int x, y, t;\n        cin >> x >> y >> t;\n        G[x].push_back(Edge(y, t));\n        G[y].push_back(Edge(x, t));\n    }\n    cin >> v0;\n    cin >> a >> b >> c;\n    auto initState = State(1, v0, 0);\n    dp[initState] = 0;\n    que.push(make_pair(0, initState));\n\n    while (que.size()) {\n        auto p = que.top();\n        que.pop();\n        auto nowCost = p.first;\n        auto nowState = p.second;\n        auto v = get<0>(nowState);\n        auto v1 = get<1>(nowState);\n        auto s = get<2>(nowState);\n        auto v2 = update(v1);\n        // if (dp[nowState] < -nowCost) continue;\n        // printf(\"%d %d %d %d\\n\", v, v1, s, dp[nowState]);\n\n        if (s == 0 && v == n) s = 1;\n        rep(i, G[v].size()) {\n            auto e = G[v][i];\n            ll cost = 1LL * e.t * v1;\n            auto nextState = State(e.to, v2, s);\n            if (dp.count(nextState) == 0 ||\n                dp[nowState] + cost < dp[nextState]) {\n                assert(!(dp[nowState] < -nowCost));\n                dp[nextState] = dp[nowState] + cost;\n                que.push(make_pair(-dp[nextState], nextState));\n            }\n        }\n    }\n\n    ll ans = INF;\n    rep(i, 50) {\n        auto s = State(1, i, 1);\n        if (dp.count(s)) ans = min(ans, dp[s]);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\ninline size_t hashCombine(size_t seed, const T& v) {\n    return seed ^ (hash<T>()(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2));\n}\n\nnamespace std {\ntemplate <typename T, typename S>\nclass hash<pair<T, S>> {\n public:\n    size_t operator()(const pair<T, S>& p) const {\n        size_t seed = 0;\n        seed = hashCombine(seed, p.first);\n        seed = hashCombine(seed, p.second);\n        return seed;\n    }\n};\ntemplate <typename... Ts>\nclass hash<tuple<Ts...>> {\n public:\n    size_t operator()(const tuple<Ts...>& t) const { return impl<0>(t); }\n\n private:\n    template <size_t Index>\n    typename enable_if<Index == tuple_size<tuple<Ts...>>::value, size_t>::type\n    impl(const tuple<Ts...>&) const {\n        return 0;\n    }\n    template <size_t Index>\n    typename enable_if<Index != tuple_size<tuple<Ts...>>::value, size_t>::type\n    impl(const tuple<Ts...>& t) const {\n        return hashCombine(impl<Index + 1>(t), get<Index>(t));\n    }\n};\n}\n\nint n, m;\nint a, b, c;\nint v0;\nstruct Edge {\n    int to, t;\n    Edge(int to = 0, int t = 0) : to(to), t(t) {}\n};\nint update(int v) { return (a * v + b) % c; }\nvector<Edge> G[502];\nusing State = tuple<int, int, int>;\nunordered_map<State, ll> dp;\npriority_queue<pair<ll, State>> que;\n\nint main() {\n    cin >> n >> m;\n    rep(i, m) {\n        int x, y, t;\n        cin >> x >> y >> t;\n        G[x].push_back(Edge(y, t));\n        G[y].push_back(Edge(x, t));\n    }\n    cin >> v0;\n    cin >> a >> b >> c;\n    auto initState = State(1, v0, 0);\n    dp[initState] = 0;\n    que.push(make_pair(0, initState));\n\n    while (que.size()) {\n        auto p = que.top();\n        que.pop();\n        auto nowCost = p.first;\n        auto nowState = p.second;\n        auto v = get<0>(nowState);\n        auto v1 = get<1>(nowState);\n        auto s = get<2>(nowState);\n        auto v2 = update(v1);\n        if (dp[nowState] < -nowCost) continue;\n        // printf(\"%d %d %d %d\\n\", v, v1, s, dp[nowState]);\n\n        if (s == 0 && v == n) s = 1;\n        rep(i, G[v].size()) {\n            auto e = G[v][i];\n            ll cost = 1LL * e.t * v1;\n            auto nextState = State(e.to, v2, s);\n            if (dp.count(nextState) == 0 ||\n                dp[nowState] + cost < dp[nextState]) {\n                dp[nextState] = dp[nowState] + cost;\n                que.push(make_pair(-dp[nextState], nextState));\n            }\n        }\n    }\n\n    ll ans = INF;\n    rep(i, 50) {\n        auto s = State(1, i, 1);\n        if (dp.count(s)) ans = min(ans, dp[s]);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 501\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nll const INF = 1LL<<60;\nll n,m;\nvector<P> G[N];\nll v0,a,b,C;\nll v[50100];\n\nll nC;\nll dijkstra(ll start,ll goal,ll c){\n  ll D[500][10001];\n  for(ll i=0;i<500;i++)\n    for(ll j=0;j<10001;j++) D[i][j] = INF;\n\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(start,c)));\n  D[start][c] = 0;\n  ll res = INF;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    ll cost = t.first; \n    ll pos = t.second.first;\n    ll cnt = t.second.second;\n    if(D[pos][cnt]<cost) continue;\n    if(pos==goal&&goal == 0)return cost; \n    if(pos==goal&&goal == n-1){\n      res=min(res,cost+dijkstra(n-1,0,cnt));\n      continue;\n    }\n    for(ll i=0;i<(ll)G[pos].size();i++){\n      ll npos = G[pos][i].first;\n      ll ncost= cost+v[cnt]*G[pos][i].second;\n      ll ncnt = (cnt+1)%nC;\n      if(D[npos][ncnt]<=ncost)continue;\n      Q.push(PP(ncost,P(npos,ncnt)));\n      D[npos][ncnt] = ncost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(ll i=0,x,y,t;i<m;i++){\n    cin>>x>>y>>t;\n    x--,y--;\n    G[x].push_back(P(y,t));\n    G[y].push_back(P(x,t));\n  }\n  cin>>v[0]>>a>>b>>C;\n  set<ll> S;\n  S.insert(v[0]);\n  for(ll i=1;;i++){\n    v[i] = (a*v[i-1]+b)%C;\n    if(S.count(v[i]))break;\n    S.insert(v[i]);\n  }\n  nC=S.size();\n  cout<<dijkstra(0,n-1,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef long long ll;\nstruct Trio{\n\tint to,v;\n\tll cost;\n\tbool operator<(const Trio& right)const{\n\t\treturn (cost > right.cost);\n\t}\n};\npriority_queue<Trio,vector<Trio>> qu;\n\nint a,b,c;\nint nextv(int v){ return (a*v+b)%c;}\n\nint main(void){\n\tint n,m,v0;\n\tcin>>n>>m;\n\tvector<int> x(m),y(m);\n\tvector<ll> t(m);\n\trep(i,m) cin>>x[i]>>y[i]>>t[i];\n\tcin>>v0>>a>>b>>c;\n\tvector<Trio> G[(n+1)*2][c];\n\tll dp[(n+1)*2][c];\n\trep(i,m)rep(v,c){\n\t\tG[x[i]][v].push_back({y[i],nextv(v),t[i]*v});\n\t\tG[y[i]][v].push_back({x[i],nextv(v),t[i]*v});\n\t\tG[n+x[i]][v].push_back({n+y[i],nextv(v),t[i]*v});\n\t\tG[n+y[i]][v].push_back({n+x[i],nextv(v),t[i]*v});\n\t}\n\trep(v,c) G[n][v].push_back({n*2,v,0});\n\n\trep(i,(n+1)*2)rep(v,c) dp[i][v]=LLONG_MAX;\n\tdp[1][v0]=0;\n\tqu.push({1,v0,0});\n\twhile(qu.size()){\n\t\tTrio u=qu.top(); qu.pop();\n\t\tif(u.to==n+1){\n\t\t\tcout<<dp[u.to][u.v]<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[u.to][u.v] < u.cost)continue;\n\t\tfor(auto e:G[u.to][u.v]){\n\t\t\tif(dp[e.to][e.v] > dp[u.to][u.v] + e.cost){\n\t\t\t\tdp[e.to][e.v] = dp[u.to][u.v] + e.cost;\n\t\t\t\tqu.push({e.to,e.v,dp[e.to][e.v]});\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\n\nstruct Edge { int dst; ll w; };\nstruct Data {\n  int cur,v; ll w;\n  bool operator < ( const Data &e ) const {\n    if( w != e.w ) return w > e.w;\n    if( v != e.v ) return v > e.v;\n    return cur > e.cur;\n  }\n};\n\n#define MAX_V 510\n\nint V,E;\nll v0,a,b,c;\nll mini[MAX_V][51][2];\nvector<Edge> G[MAX_V];\n\nll cost1;\nll adhoc = LLINF;\nvoid dijkstra(int sp,int v0) {\n  rep(i,V) rep(j,c) mini[i][j][sp==(V-1)] = LLINF;\n  priority_queue<Data> Q;\n  Q.push((Data){sp,v0,0});\n  mini[sp][v0][sp==(V-1)] = 0;\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      int nv = ( a * data.v + b ) % c;\n      ll nw = data.w + e.w * data.v;\n\n      if( nw < mini[e.dst][nv][sp==(V-1)] ) {\n        mini[e.dst][nv][sp==(V-1)] = nw;\n        Q.push((Data){e.dst,nv,nw});\n      }\n    }\n  }\n}\n\nvoid compute() {\n  dijkstra(0,v0);\n  ll ans = LLINF;\n  rep(i,c) {\n    if( mini[V-1][i][0] != LLINF ) {\n      ll cost = mini[V-1][i][0];\n\n      cost1 = cost;\n      dijkstra(V-1,i);\n      ll tmp = LLINF;\n      rep(j,c) tmp = min(tmp,mini[0][j][1]);\n      if( tmp == LLINF ) continue;\n      ans = min(ans,cost+tmp);\n      adhoc = ans;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  rep(i,E) {\n    int x,y,t;\n    cin >> x >> y >> t;\n    --x,--y;\n    G[x].push_back((Edge){y,t});\n    G[y].push_back((Edge){x,t});\n  } \n  cin >> v0 >> a >> b >> c;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\ntypedef long long ll;\nstruct edge{int to;ll cost;};\ntypedef pair<ll,int> P;\n#define dist first\n#define idx second\npriority_queue<P,vector<P>,greater<P>> qu;\n\nint a,b,c;\nint nextv(int v){ return (a*v+b)%c;}\n\nint main(void){\n\tint n,m,v0;\n\tcin>>n>>m;\n\tvector<int> x(m),y(m);\n\tvector<ll> t(m);\n\trep(i,m) cin>>x[i]>>y[i]>>t[i];\n\tcin>>v0>>a>>b>>c;\n\tvector<edge> G[(n+1)*2*c];\n\tll dp[(n+1)*2*c];\n\trep(i,m)rep(v,c){\n\t\tG[x[i]*c+v].push_back({y[i]*c+nextv(v),t[i]*v});\n\t\tG[y[i]*c+v].push_back({x[i]*c+nextv(v),t[i]*v});\n\t\tG[(n+x[i])*c+v].push_back({(n+y[i])*c+nextv(v),t[i]*v});\n\t\tG[(n+y[i])*c+v].push_back({(n+x[i])*c+nextv(v),t[i]*v});\n\t}\n\trep(v,c) G[n*c+v].push_back({n*2*c+v,0});\n\n\trep1(i,n*2)rep(v,c) dp[i*c+v]=LLONG_MAX;\n\tdp[c+v0]=0;\n\tqu.push({0,c+v0});\n\twhile(qu.size()){\n\t\tP u=qu.top(); qu.pop();\n\t\tif(u.idx/c==n+1){\n\t\t\tcout<<dp[u.idx]<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[u.idx] < u.dist)continue;\n\t\tfor(auto e:G[u.idx]){\n\t\t\tif(dp[e.to] > dp[u.idx] + e.cost){\n\t\t\t\tdp[e.to] = dp[u.idx] + e.cost;\n\t\t\t\tqu.push({dp[e.to],e.to});\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\n#define int long long\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nlong long d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second.second;\n\t\tint t=now.second.first\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second].first;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline void chmin(T &l,T r){l=min(l,r);}\ntemplate <typename T>inline void chmax(T &l,T r){l=max(l,r);}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\n\nint x[10123];\nint y[10123];\nLL t[10123];\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nint main(){\n\n    int n,m;\n    cin>>n>>m;\n    VV g(n+1);\n    REP(i,m){\n        cin>>x[i]>>y[i]>>t[i];\n        g[x[i]].pb(i);\n        g[y[i]].pb(i);\n    }\n    int v0,a,b,c;\n    cin>>v0;\n\n    cin>>a>>b>>c;\n    using T=tuple<LL,int,int,int>;\n    priority_queue<T> que;\n    const LL INF=1e12;\n    vector<VV> D(n+1,VV(c,V(2,INF)));\n    que.push(T(0,1,v0,0));\n    D[1][v0][0]=0;\n    while(que.size()){\n        LL cost;int u,v,vis;\n        \n        tie(cost,u,v,vis)=que.top();que.pop();\n        cost=-cost;\n        //       cout<<u<<v<<vis<<cost<<endl;\n        if(D[u][v][vis]<cost)continue;\n        int nv=(v*a+b)%c;\n        for(auto &e:g[u]){\n            int nu=u^x[e]^y[e];\n            int nvis=vis;\n            LL ncost=cost+t[e]*v;\n            if(nu==n)nvis=1;\n            if(D[nu][nv][nvis]>ncost){\n                D[nu][nv][nvis]=ncost;\n                que.push(T(-ncost,nu,nv,nvis));\n            }\n        }\n        \n    }\n    LL res=INF;\n    REP(i,c)chmin(res,D[1][i][1]);\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nint d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second.second;\n\t\tint t=now.second.first\n        long long _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tlong long nt=t|edge[now.first.second].first;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nstruct Elem {\n    int cur, vel, f; ll cost;\n    Elem(int cu, int v, int f_, ll co) : cur(cu), vel(v), f(f_), cost(co) {}\n    bool operator<(const Elem &e) const {\n        return cost > e.cost;\n    }\n};\n\nll dist[510][55][2];\nint main() {\n    int N, M; scanf(\"%d%d\", &N, &M);\n    vector< vector< pair<ll, ll> > > G(N);\n    for(int i=0; i<M; i++) {\n        int u, v, t; scanf(\"%d%d%d\", &u, &v, &t);\n        u--; v--;\n        G[u].emplace_back(v, t);\n        G[v].emplace_back(u, t);\n    }\n\n    int v0; scanf(\"%d\", &v0);\n    int A, B, C; scanf(\"%d%d%d\", &A, &B, &C);\n    fill(dist[0][0], dist[N][0], LONGINF);\n    dist[0][v0][0] = 0;\n    priority_queue<Elem> que;\n    que.emplace(0, v0, 0, 0);\n    while(que.size()) {\n        Elem elem = que.top(); que.pop();\n        int cur = elem.cur, v = elem.vel, f = elem.f;\n        ll cost = elem.cost;\n        if(dist[cur][v][f] < cost) continue;\n        for(auto e : G[cur]) {\n            ll to, t; tie(to, t) = e;\n            ll n_cost = cost + v * t;\n            ll n_v = (A*v + B) % C;\n            ll n_f = f | (to == N-1);\n            if(dist[to][n_v][n_f] > n_cost) {\n                dist[to][n_v][n_f] = n_cost;\n                que.emplace(to, n_v, n_f, n_cost);\n            }\n        }\n    }\n\n    ll ans = LONGINF;\n    for(int i=0; i<C; i++) chmin(ans, dist[0][i][1]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX / 2\n#define MP make_pair\n#define PB push_back\n#define pb push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T> &st){ os << \"[\"; for(auto a : st) cout << a << \",\"; os << \"]\"; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N,M;\nll a,b,c;\nll v0;\n\nusing P = pair<ll,pair<ll,ll>>;\nP makeP(ll a,ll b,ll c){\n    return make_pair(a,make_pair(b,c));\n}\n\n\nstruct edge{\n    ll to,t;\n    edge(){}\n    edge(ll a,ll b): to(a),t(b){}\n};\nvector<edge> G[500];\n\n\nvector<vector<ll>> dijkstra(ll s,ll t,ll sv){\n    vector<vector<ll>> d(N,vector<ll>(c,LINF));\n    d[s][sv] = 0;\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,s,sv));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        ll len = p.first;\n        ll node = p.second.first;\n        ll v = p.second.second;\n\n//        cerr <<\"pop : \" << len << \" \" << node << \" \" << v << endl;\n\n        if(d[node][v] < len) continue; \n\n        for(ll i=0;i<G[node].size();i++){\n            edge e = G[node][i];\n            ll nnode = e.to;\n            ll t = e.t;\n            ll nv = (a*v+b) % c;\n            ll nlen = t * v + len;\n\n            if(nlen < d[nnode][nv]){\n                d[nnode][nv] = nlen;\n                que.push(makeP(nlen,nnode,nv));\n//                cerr << \"push : \" << nlen << \" \" << nnode << \" \" << nv << endl;\n            }\n        }\n    }\n\n    return d;\n}\n\nint main(){\n    cin >> N >> M;\n    rep(i,M){\n        ll xx,yy,tt;\n        cin >> xx >> yy >> tt;\n        xx--;\n        yy--;\n        G[xx].push_back(edge(yy,tt));        \n        G[yy].push_back(edge(xx,tt));\n    }\n    cin >> v0;\n    cin >> a >> b >> c;\n\n\n    vector<vector<ll>> d = dijkstra(0,N-1,v0);\n\n\n    //for(ll i=0;i<N;i++){\n    //    cout << d[i] << endl;\n    //}\n\n    ll ans = LINF;\n    for(ll i=0;i<c;i++){\n        // i is v0\n        if(d[N-1][i]==LINF) continue;\n        auto d2 = dijkstra(N-1,0,i);\n        for(ll j=0;j<c;j++){\n            if(d2[0][j]==LINF) continue;\n            ans = min(ans,d[N-1][i]+d2[0][j]);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 501\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nll const INF = LLONG_MAX/2;\nll n,m;\nvector<P> G[N];\nll v0,a,b,C;\nll v[5010];\n\n\nll dijkstra(ll start,ll goal,ll c){\n  ll D[500][1001];\n  for(ll i=0;i<500;i++)\n    for(ll j=0;j<1001;j++) D[i][j] = INF;\n\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(start,c)));\n  D[start][c] = 0;\n  ll res = INF;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    ll cost = t.first; \n    ll pos = t.second.first;\n    ll cnt = t.second.second;\n    if(D[pos][cnt]<cost) continue;\n    if(pos==goal&&goal == 0)return cost; \n    if(pos==goal&&goal == n-1){\n      res=min(res,cost+dijkstra(n-1,0,cnt));\n      continue;\n    }\n    for(ll i=0;i<(ll)G[pos].size();i++){\n      ll npos = G[pos][i].first;\n      ll ncost = cost+v[cnt]*G[pos][i].second;\n      ll ncnt = (cnt+1)%C;\n      if(D[npos][ncnt]<=ncost)continue;\n      Q.push(PP(ncost,P(npos,ncnt)));\n      D[npos][ncnt] = ncost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(ll i=0,x,y,t;i<m;i++){\n    cin>>x>>y>>t;\n    x--,y--;\n    G[x].push_back(P(y,t));\n    G[y].push_back(P(x,t));\n  }\n  cin>>v[0]>>a>>b>>C;\n  for(ll i=1;i<100;i++)v[i] = (a*v[i-1]+b)%C;\n  cout<<dijkstra(0,n-1,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1000000000000000\nusing namespace std;\nstruct edge{long long  to,cost;\n  edge(long long t,long long c):to(t),cost(c){}\n};\ntypedef pair<int ,int>P;\n\nint V;\nvector<edge>G[60000];\nlong long lx[5000];\nlong long ly[5000];\nlong long lt[5000];\nlong long int  a,b,c;\nlong long v;\nlong long co;\nvoid dk(long long ,long long*);\nint ch(long long ,long long);\nint main(){\n  V=60000;\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int x,y,t;\n    cin >> x >> y >> t;\n    lx[i]=x;\n    ly[i]=y;\n    lt[i]=t;\n  }\n  cin >> v;\n  cin >> a >> b >> c;\n  int VV = 30000;\n  //dk\n  for(int i=0;i<m;i++){\n    for(int j=0;j<c;j++){\n      //cout << ch(lx[i],j)<<endl;\n      G[ch(lx[i],j)].push_back(edge(ch(ly[i],(a*j+b)%c),j*lt[i]));\n      G[ch(ly[i],j)].push_back(edge(ch(lx[i],(a*j+b)%c),j*lt[i]));      \n      G[VV+ch(lx[i],j)].push_back(edge(VV+ch(ly[i],(a*j+b)%c),j*lt[i]));\n      G[VV+ch(ly[i],j)].push_back(edge(VV+ch(lx[i],(a*j+b)%c),j*lt[i]));      \n    }\n  }\n  for(int i=0;i<c;++i)\n    G[ch(n,i)].push_back(edge(VV+ch(n,i),0));      \n    \n  //cout << 1<<endl;\n  long long ans=INF;\n  long long sd[V];\n  dk(ch(1,v),sd);\n\n  for(int i=0;i<c;i++){\n    ans = min(ans, sd[VV+ch(1,i)]);\n  }\n  //cout << 3<<endl;\n  \n  cout << ans << endl;\n  return 0;\n}\nvoid dk(long long s,long long* d){\n  priority_queue<P,vector<P>,greater<P> >que;\n  fill(d,d+V,INF);\n  d[s]=0;\n  que.push(P(0,s));\n\n  while(!que.empty()){\n    P p = que.top();que.pop();\n    int v = p.second;\n    if(d[v]<p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost){\n\td[e.to]=d[v]+e.cost;\n\tque.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\nint ch(long long A,long long B){\n  return A*c+B;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef long long ll;\nstruct Trio{\n\tint to,v;\n\tll cost;\n\tbool operator<(const Trio& right)const{\n\t\treturn (cost > right.cost);\n\t}\n};\n\nint main(void){\n\tint n,m,v0,a,b,c;\n\tcin>>n>>m;\n\tvector<int> x(m),y(m);\n\tvector<ll> t(m);\n\trep(i,m) cin>>x[i]>>y[i]>>t[i];\n\tcin>>v0>>a>>b>>c;\n\tvector<Trio> G[(n+1)*2][c];\n\tll dp[(n+1)*2][c];\n\trep(i,m)rep(v,c){\n\t\tint nextv=(a*v+b)%c;\n\t\tll cost=t[i]*v;\n\t\tG[x[i]][v].push_back({y[i],nextv,cost});\n\t\tG[y[i]][v].push_back({x[i],nextv,cost});\n\t\tG[n+x[i]][v].push_back({n+y[i],nextv,cost});\n\t\tG[n+y[i]][v].push_back({n+x[i],nextv,cost});\n\t}\n\trep(v,c) G[n][v].push_back({n*2,v,0});\n\n\trep(i,(n+1)*2)rep(v,c) dp[i][v]=LLONG_MAX;\n\tdp[1][v0]=0;\n\tpriority_queue<Trio,vector<Trio>> qu;\n\tqu.push({1,v0,0});\n\twhile(qu.size()){\n\t\tTrio u=qu.top(); qu.pop();\n\t\tif(u.to==n+1){\n\t\t\tcout<<dp[u.to][u.v]<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[u.to][u.v] < u.cost)continue;\n\t\tfor(auto e:G[u.to][u.v]){\n\t\t\tif(dp[e.to][e.v] > dp[u.to][u.v] + e.cost){\n\t\t\t\tdp[e.to][e.v] = dp[u.to][u.v] + e.cost;\n\t\t\t\tqu.push({e.to,e.v,dp[e.to][e.v]});\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\ntypedef long long ll;\nstruct edge{int to;ll cost;};\n\nvector<edge> G[60000];\nll dp[60000];\npriority_queue<pair<ll,int>> qu;//dp,v\n\nint a,b,c;\n\nint nextv(int v){\n\treturn (a*v+b)%c;\n}\n\nint main(void){\n\tint n,m,v0;\n\tcin>>n>>m;\n\tvector<int> x(m),y(m);\n\tvector<ll> t(m); \n\trep(i,m){\n\t\tcin>>x[i]>>y[i]>>t[i];\n\t\t--x[i];\n\t\t--y[i];\n\t}\n\tcin>>v0>>a>>b>>c;\n\trep(i,m)rep(v,c){\n\t\tG[x[i]*c+v].push_back({y[i]*c+nextv(v),t[i]*v});\n\t\tG[y[i]*c+v].push_back({x[i]*c+nextv(v),t[i]*v});\n\t\tG[((n-1)*2-x[i])*c+v].push_back({((n-1)*2-y[i])*c+nextv(v),t[i]*v});\n\t\tG[((n-1)*2-y[i])*c+v].push_back({((n-1)*2-x[i])*c+nextv(v),t[i]*v});\n\t}\n\trep(i,60000)dp[i]=LLONG_MAX;\n\tdp[v0]=0;\n\tqu.push({0,v0});\n\twhile(qu.size()){\n\t\tpair<ll,int> u = qu.top();\n\t\tqu.pop();\n\t\tif(dp[u.second] < u.first)continue;\n\t\tfor(auto e:G[u.second]){\n\t\t\tif(dp[e.to] > dp[u.second] + e.cost){\n\t\t\t\tdp[e.to] = dp[u.second] + e.cost;\n\t\t\t\tqu.push({dp[e.to],e.to});\n\t\t\t}\n\t\t}\n\t}\n\tll res = LLONG_MAX;\n\trep(i,c){\n\t\tres = min(res,dp[2*(n-1)*c+i]);\n\t}\n\tcout<<res<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int ll\n#define N 501\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\nll const INF = 1LL<<55;\nint n,m;\nvector<P> G[N];\nint v0,a,b,C;\nll v[5010];\n\n\nint dijkstra(int start,int goal,int c){\n  ll D[500][1001];\n  for(int i=0;i<500;i++)\n    for(int j=0;j<1001;j++) D[i][j] = INF;\n\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(start,c)));\n  D[start][c] = 0;\n  ll res = INF;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    ll cost = t.first; \n    int pos = t.second.first;\n    int cnt = t.second.second;\n    if(D[pos][cnt]<cost) continue;\n    if(pos==goal&&goal == 0)return cost; \n    if(pos==goal&&goal == n-1){\n      res=min(res,cost+dijkstra(n-1,0,cnt));\n      continue;\n    }\n    for(int i=0;i<(int)G[pos].size();i++){\n      int npos = G[pos][i].first;\n      ll ncost = cost+v[cnt]*G[pos][i].second;\n      int ncnt = (cnt+1)%C;\n      if(ncnt>2*m||D[npos][ncnt]<=ncost)continue;\n      Q.push(PP(ncost,P(npos,ncnt)));\n      D[npos][ncnt] = ncost;\n    }\n  }\n  return res;\n}\n\nmain(){\n  cin>>n>>m;\n  for(int i=0,x,y,t;i<m;i++){\n    cin>>x>>y>>t;\n    x--,y--;\n    G[x].push_back(P(y,t));\n    G[y].push_back(P(x,t));\n  }\n  cin>>v[0]>>a>>b>>C;\n  for(int i=1;i<100;i++)v[i] = (a*v[i-1]+b)%C;\n  cout<<dijkstra(0,n-1,0)<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define int long long\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,int> piii;\n    vector<vector<int>>d(n,vector<int>(100,LLONG_MAX));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    bool visit=true;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<int>>_d(n,vector<int>(51,LLONG_MAX));\n    rep(i,c+1)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,c+1)if(d[n-1][i]!=LLONG_MAX)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=LLONG_MAX;\n    rep(i,100)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define INF (1e18)\n#define C 55\n#define N 505\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint n, m, d[C][N][2], v0, a, b, c;\n\nvector<P> G[N];\n\npriority_queue<P2,vector<P2>,greater<P2> > q;\n\nint dijkstra(){\n\n  for(int i=0;i<C;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<2;k++) d[i][j][k]=INF;\n  \n  d[v0][0][0]=0;\n\n  q.push(P2(P(0,v0),P(0,0)));\n\n  while(!q.empty()){\n    \n    P2 t=q.top(); q.pop();\n\n    int cost=t.first.first;\n\n    int v=t.first.second;\n\n    int node=t.second.first;\n\n    int idx=t.second.second;\n\n    if(d[v][node][idx]<cost) continue;\n\n    if(idx&&node==0) return cost;\n    \n    if(!idx&&node==n-1){\n\n      if(d[v][node][1]>cost){\n\t\n\td[v][node][1]=cost;\n\n\tq.push(P2(P(cost,v),P(node,1)));\n\t\n      }\n      \n    }\n    \n    for(int i=0;i<G[node].size();i++){\n\n      int nnode=G[node][i].first;\n\n      int nv=(a*v+b)%c;\n      \n      int ncost=cost+v*G[node][i].second;\n      \n      if(d[nv][nnode][idx]>ncost){\n\t\n\td[nv][nnode][idx]=ncost;\n\n\tq.push(P2(P(ncost,nv),P(nnode,idx)));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nmain(){\n  \n  cin>>n>>m;\n\n  for(int i=0;i<m;i++){\n\n    int x, y, t;\n\n    cin>>x>>y>>t;\n\n    x--, y--;\n    \n    G[x].push_back(P(y, t));\n\n    G[y].push_back(P(x, t));\n    \n  }\n\n  cin>>v0;\n\n  cin>>a>>b>>c;\n  \n  cout<<dijkstra()<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nint d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second.second;\n\t\tint t=now.second.first;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second].first;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<lli, lli> pll;\nconst lli inf = 1e18;\n\nstruct info{\n    int p;\n    lli v;\n    lli d;\n    info(int p, lli v, lli d):p(p),v(v),d(d){}\n    info(){}\n    bool operator <(const info &a) const{\n        return d > a.d;\n    }\n};\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<pll>> adj(n);\n    for(int i=0; i<m; i++){\n        lli x,y,t;\n        cin >> x >> y >> t;\n        x--; y--;\n        adj[x].emplace_back(y, t);\n        adj[y].emplace_back(x, t);\n    }\n    lli v_init,a,b,c;\n    cin >> v_init >> a >> b >> c;\n\n    priority_queue<info> wait;\n    wait.push(info(0, v_init, 0));\n    vector<vector<lli>> mincost(n, vector<lli>(c, inf));\n    mincost[0][v_init] = 0;\n    while(!wait.empty()){\n        int p = wait.top().p;\n        lli v = wait.top().v;\n        lli d = wait.top().d;\n        wait.pop();\n        if(d > mincost[p][v]) continue;\n        for(auto next: adj[p]){\n            int np = next.first;\n            lli t = next.second;\n            lli nd = d + v*t;\n            lli nv = (a*v +b) %c;\n            if(nd < mincost[np][nv]){\n                mincost[np][nv] = nd;\n                wait.push(info(np, nv, nd));\n            }\n        }\n    }\n\n    lli ans = inf;\n    for(int i=0; i<c; i++){\n        wait.push(info(n-1, i, 0));\n        vector<vector<lli>> mincost_back(n, vector<lli>(c, inf));\n        mincost_back[n-1][i] = 0;\n        while(!wait.empty()){\n            int p = wait.top().p;\n            lli v = wait.top().v;\n            lli d = wait.top().d;\n            wait.pop();\n            if(d > mincost_back[p][v]) continue;\n            for(auto next: adj[p]){\n                int np = next.first;\n                lli t = next.second;\n                lli nd = d + v*t;\n                lli nv = (a*v +b) %c;\n                if(nd < mincost_back[np][nv]){\n                    mincost_back[np][nv] = nd;\n                    wait.push(info(np, nv, nd));\n                }\n            }\n        }\n        ans = min(ans, mincost[n-1][i] + *min_element(mincost_back[0].begin(), mincost_back[0].end()));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\n#define int long long\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nlong long d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second.second;\n\t\tint t=now.second.first\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second].first;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    vector<vector<long long>>d(n,vector<long long>(51,INF));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(n,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e15;\n\nstruct Edge{\n  LL to, cost;\n\n  Edge(LL t, LL c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\n\nvoid Dijkstra(const Graph& edges, vector<LL>& d, int s){\n  using Type = PLL;\n  priority_queue<Type, vector<Type>, greater<Type> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tType pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(unsigned int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint idx(int u, int v, int flag){\n  return (u * 500 + v) * 2 + flag;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n\n  VL xs(M), ys(M), ts(M);\n  REP(i,M){\n\tcin >> xs[i] >> ys[i] >> ts[i];\n\t--xs[i];\n\t--ys[i];\n  }\n\n  LL V, A, B, C;\n  cin >> V >> A >> B >> C;\n\t\n  Graph G(500*50*2);\n  REP(i,M){\n\tREP(k,C){\n\t  G[idx(xs[i], k, 0)].EB(idx(ys[i], (A*k+B)%C, 0), k*ts[i]);\n\t  G[idx(ys[i], k, 0)].EB(idx(xs[i], (A*k+B)%C, 0), k*ts[i]);\n\t  G[idx(xs[i], k, 1)].EB(idx(ys[i], (A*k+B)%C, 1), k*ts[i]);\n\t  G[idx(ys[i], k, 1)].EB(idx(xs[i], (A*k+B)%C, 1), k*ts[i]);\n\t}\n  }\n  REP(k,C)\n\tG[idx(N-1, k, 0)].EB(idx(N-1, k, 1), 0);\n\n  VL d(500*50*2);\n  Dijkstra(G, d, idx(0, V, 0));\n\n  LL ans = INF;\n  REP(k,C)\n\tmini(ans, d[idx(0, k, 1)]);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint v,a,b,c;\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[55][1111];\nint dp[55][1111];\nvoid add_edge(int time,int from,int to,int cost){\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i]);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i]);\n      ve=(a*ve+b)%c;\n    }\n  }\n\n  for(int j=0;j<c;j++) add_edge2(j,n-1,n+n-1,0);\n  \n  //memset(dp,-1,sizeof(dp));\n  int INF=1LL<<60LL;\n  for(int i=0;i<c;i++)\n    for(int j=0;j<n*2;j++)\n      dp[i][j]=INF;\n  \n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  dp[0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int d=p.dist,t=p.time,u=p.pos;\n    assert(0<=t&&t<c);\n    //cout<<d<<\" \"<<t<<\" \"<<u<<endl;\n    if(u==n){\n      cout<<d<<endl;\n      return 0;\n    }\n    if(dp[t][u]<d) continue;\n    assert(dp[t][u]==d);\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(d+nc<dp[nt][nu]){\n\tdp[nt][nu]=d+nc;\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  assert(0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<iostream>\n#include<vector>\n#include<queue>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nint d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii>que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n\t\tnow.first.first*=-1;\n        int v=now.second.second;\n\t\tint t=now.second.first;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second][i].first==n-1;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(-d[next.first][nt][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<=now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<=now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct edge {\n\tint from;\n\tint to;\n\tlong long int cost;\n};\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint nowv;\n\tbool comen;\n};\nclass Compare {\npublic:\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\t//aa?????????????????¶\n\nint v0, A, B, C;\nlong long int solve(const vector<vector<edge>>&edges,const int start,const int goal) {\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tvector<vector<vector<long long int>>>memo(edges.size(), vector<vector<long long int>>(C,vector<long long int>(2,1e18)));\n\tmemo[0][v0][0] = 0;\n\tque.push(aa{ start,0,v0,false });\n\twhile (!que.empty()) {\n\t\tauto atop(que.top());\n\t\tque.pop();\n\t\tconst int now = atop.now;\n\t\tconst long long int nowtime = atop.time;\n\t\tconst int nowv = atop.nowv;\n\t\tconst int nowcomen = atop.comen;\n\t\tif (now == goal&&nowcomen)return nowtime;\n\t\tfor (auto e : edges[atop.now]) {\n\t\t\tconst int next = e.to;\n\t\t\tconst long long  int nexttime = nowtime + e.cost*nowv;\n\t\t\tconst int nextv = (A*nowv + B) % C;\n\t\t\tconst bool nextcomen = nowcomen | (next == edges.size() - 1);\n\t\t\tif (nexttime < memo[next][nextv][nextcomen]) {\n\t\t\t\tque.push(aa{ next,nexttime,nextv,nextcomen });\n\t\t\t\tmemo[next][nextv][nextcomen] = nexttime;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<edge>>edges(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y, t; cin >> x >> y >> t;\n\t\tif (x > y)swap(x, y);\n\t\tx--; y--;\n\t\tedges[x].push_back(edge{ x,y,t });\n\t\tedges[y].push_back(edge{ y,x,t });\n\t}\n\tcin >> v0 >> A >> B >> C;\n\tlong long int ans(solve(edges, 0, 0));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nint d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii> >que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second.second;\n\t\tint t=now.second.first\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second].first;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef tuple<ll,ll,ll,ll> tp;\ntypedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef ll Def;\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tDef to,cost;\n\t};\n\tvector<vector<edge> >G;\n\tDef n,L;\n//\tvvi d;//distance\n\tDef d[510][50][2];\n\tDIJ(Def size,Def l=0){\n\t\tn=size;\n\t\tL=l;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(Def a,Def b,Def c){\n\t\tedge e={b,c},ee={a,c};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(Def a,Def b,Def c,Def D){\n//\t\td=vvi(n,vi(L+1,inf));\n\t\trep(i,510)rep(j,50)rep(k,2)d[i][j][k]=INF;\n\t\td[0][D][0]=0;\n//\t\td[s][L]=0;//now oktime ->time\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,0,D,0));//time now v_0 n-1????????£??????\n\t\twhile(!q.empty()){\n\t\t\tDef cost,pos,v,t;\n\t\t\ttie(cost,pos,v,t)=q.top();\n\t\t\tq.pop();\n\t\t\tif(cost>d[pos][v][t])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tDef to=e.to;\n\t\t\t\tDef ncost=cost+e.cost*v;\n\t\t\t\tDef nv=(a*v+b)%c;\n\t\t\t\tDef nt=t||(to==n-1);\n\t\t\t\tif(ncost<d[to][nv][nt]){\n\t\t\t\t\td[to][nv][nt]=ncost;\n\t\t\t\t\tq.push(tp(ncost,to,nv,nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll out=INF;\n\t\trep(i,50)out=min(out,d[0][i][1]);\n\t\tcout<<out<<endl;\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tDIJ dij(n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tdij.add_edge(a,b,c);\n\t}\n\tint a,b,c,d;\n\tcin>>d>>a>>b>>c;\n\tdij.dij(a,b,c,d);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\n\nstruct Edge { int dst; ll w; };\nstruct Data {\n  int cur,v; ll w;\n  bool operator < ( const Data &e ) const {\n    if( w != e.w ) return w > e.w;\n    if( v != e.v ) return v > e.v;\n    return cur > e.cur;\n  }\n};\n\n#define MAX_V 510\n\nint V,E;\nll v0,a,b,c;\nll mini[MAX_V][51][2];\nvector<Edge> G[MAX_V];\n\nvoid dijkstra(int sp,int v0) {\n  rep(i,V) rep(j,c) mini[i][j][sp==(V-1)] = LLINF;\n  priority_queue<Data> Q;\n  Q.push((Data){sp,v0,0});\n  mini[sp][v0][sp==(V-1)] = 0;\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      int nv = ( a * data.v + b ) % c;\n      ll nw = data.w + e.w * data.v;\n      if( nw < mini[e.dst][nv][sp==(V-1)] ) {\n        mini[e.dst][nv][sp==(V-1)] = nw;\n        Q.push((Data){e.dst,nv,nw});\n      }\n    }\n  }\n}\n\nvoid compute() {\n  dijkstra(0,v0);\n  ll ans = LLINF;\n  rep(i,c) {\n    if( mini[V-1][i][0] != LLINF ) {\n      ll cost = mini[V-1][i][0];\n      dijkstra(V-1,i);\n      ll tmp = LLINF;\n      rep(j,c) tmp = min(tmp,mini[0][j][1]);\n      ans = min(ans,cost+tmp);\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  rep(i,E) {\n    int x,y,t;\n    cin >> x >> y >> t;\n    --x,--y;\n    G[x].push_back((Edge){y,t});\n    G[y].push_back((Edge){x,t});\n  } \n  cin >> v0 >> a >> b >> c;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll N,M,A,B,C;\nll inf = 1e18;\nstruct state{\n    ll node,dist,velocity;\n    bool go;\n    bool operator<(const state& r)const{\n        return dist>r.dist;\n    }\n};\n\nstruct edge{\n    int to,dist;\n};\n\nll next_v(ll v){\n    return (A*v+B)%C;\n}\n\nll dp[510][51][2] = {};\n\nint main() {\n    vector<vector<edge>> v(510);\n    cin >> N >> M;\n    for(int i=0;i<M;i++){\n        int x,y,t;\n        cin >> x >> y >> t;\n        v[x].push_back({y,t});\n        v[y].push_back({x,t});\n    }\n    ll v0;\n    cin >> v0;\n    cin >> A >> B >> C;\n    for(int i=1;i<=N;i++) for(int j=0;j<C;j++){\n        dp[i][j][0] = inf;\n        dp[i][j][1] = inf;\n    }\n    dp[1][v0][0] = 0;\n    priority_queue<state> Q;\n    Q.push({1,0,v0,0});\n    while(!Q.empty()){\n        state now = Q.top(); Q.pop();\n        if(dp[now.node][now.velocity][now.go]<now.dist) continue;\n        for(auto x:v[now.node]){\n            state ne = now;\n            ne.velocity = next_v(now.velocity);\n            ll d = x.dist*now.velocity;\n            ne.node = x.to;\n            if(now.node==N) ne.go = true;\n            if(dp[x.to][ne.velocity][ne.go]>now.dist+d){\n                dp[x.to][ne.velocity][ne.go] = now.dist+d;\n                ne.dist = now.dist+d;\n                Q.push(ne);\n            }\n        }\n    }\n    ll ans = inf;\n    for(int i=0;i<C;i++) ans = min(ans,dp[1][i][1]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e17)\n#define N 505\n#define C 51\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\nvector<P> G[N];\nll n,m,x,y,t,v0,a,b,c;\nll d[C][N],cp[C][N];\npriority_queue<P1,vector<P1>,greater<P1> > q;\n\nll dijkstra(int s,int g,int v){\n  for(int i=0;i<c;i++)\n    for(int j=0;j<n;j++)d[i][j]=INF;\n  q.push(P1(0,P(v,s)));\n  d[v][s]=0;\n  while(!q.empty()){\n    P1 temp=q.top(); q.pop();\n    ll cost=temp.first;\n    ll V=temp.second.first;\n    ll node=temp.second.second;\n    if(d[V][node]<cost)continue;\n    for(int i=0;i<G[node].size();i++){\n      ll ncost=cost+G[node][i].second*V;\n      ll nnode=G[node][i].first;\n      ll nV=(a*V+b)%c;\n      if(d[nV][nnode]>ncost){\n\td[nV][nnode]=ncost;\n\tq.push(P1(ncost,P(nV,nnode)));\n      }\n    }\n  }\n  ll res=INF;\n  for(int i=0;i<c;i++)\n    res=min(res,d[i][g]);\n  return res;\n}\n\nvoid solve(){\n  dijkstra(0,n-1,v0);\n  for(int i=0;i<c;i++)\n    for(int j=0;j<n;j++)cp[i][j]=d[i][j];\n\n  ll ans=INF;\n  for(int i=0;i<c;i++){\n    if(cp[i][n-1]==INF)continue;\n    ans=min(ans,cp[i][n-1]+dijkstra(n-1,0,i));\n  }\n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>x>>y>>t;\n    G[x-1].push_back(P(y-1,t));\n    G[y-1].push_back(P(x-1,t));\n  }\n  cin>>v0>>a>>b>>c;\n  \n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing usize = std::size_t;\nusing u32 = std::uint32_t;\nusing u64 = std::uint64_t;\n\ntemplate <class T> void chmin(T &a, const T &b) {\n  if (b < a)\n    a = b;\n}\n\nstruct edge {\n  usize to;\n  u64 cost;\n\n  bool operator<(const edge &r) const { return r.cost < cost; }\n};\n\nstatic constexpr u64 inf = std::numeric_limits<u64>::max();\n\nstd::vector<u64> dijkstra(const std::vector<std::vector<edge>> &g,\n                          const usize s) {\n  const usize n = g.size();\n  std::vector<u64> dist(n, inf);\n\n  dist[s] = 0;\n  std::priority_queue<edge> que;\n  que.push({s, 0});\n\n  while (!que.empty()) {\n    const usize v = que.top().to;\n    const usize c = que.top().cost;\n    que.pop();\n    if (dist[v] < c) {\n      continue;\n    }\n    for (const auto &e : g[v]) {\n      if (dist[e.to] > c + e.cost) {\n        dist[e.to] = c + e.cost;\n        que.push({e.to, dist[e.to]});\n      }\n    }\n  }\n\n  return dist;\n}\n\nint main() {\n\n  usize n, m;\n  std::cin >> n >> m;\n\n  struct e_tp {\n    usize x, y;\n    u64 t;\n  };\n\n  std::vector<e_tp> es(m);\n  for (auto &e : es) {\n    std::cin >> e.x >> e.y >> e.t;\n    e.x -= 1;\n    e.y -= 1;\n  }\n\n  usize v0;\n  std::cin >> v0;\n\n  usize a, b, c;\n  std::cin >> a >> b >> c;\n\n  const auto idx = [&](const usize r, const usize ve, const usize i) {\n    return (r * c + ve) * n + i;\n  };\n\n  std::vector<std::vector<edge>> g(2 * c * n);\n\n  const auto span = [&](const usize x, const usize y, const u64 t) {\n    for (const auto r : {0, 1}) {\n      for (usize i = 0; i != c; ++i) {\n        g[idx(r, i, x)].push_back({idx(r, (a * i + b) % c, y), t * i});\n      }\n    }\n  };\n\n  for (const auto &e : es) {\n    span(e.x, e.y, e.t);\n    span(e.y, e.x, e.t);\n  }\n\n  for (usize i = 0; i != c; ++i) {\n    g[idx(0, i, n - 1)].push_back({idx(1, i, n - 1), 0});\n  }\n\n  u64 ans = inf;\n  const auto dist = dijkstra(g, idx(0, v0, 0));\n\n  for (usize i = 0; i != c; ++i) {\n    chmin(ans, dist[idx(1, i, 0)]);\n  }\n\n  std::cout << ans << std::endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\ntypedef long long ll;\n\nstruct Edge{\n\tint to;\n\tll cost;\n};\n\nll dist[510][51];\n\n\n\nvector<Edge> es[510];\n\nint main(){\n\tint n, m;\n\tcin >> n>> m;\n\t//cout<<\" \"<<n<<\" \"<<m<<endl;\n\tfor(int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tll t;\n\t\tcin >> x >> y >> t;\n\t\tx--;\n\t\ty--;\n\t\tes[x].push_back({y, t});\n\t\tes[y].push_back({x, t});\n\t\t//cout<<\"  \"<<i<<endl;\n\t}\n\tfor(int i = 0; i < 510; i++) for(int j = 0; j < 51; j++) dist[i][j] = 1e18;\n\tint v, a, b, c;\n\tcin >> v >> a >> b>> c;\n\ttypedef pair<ll, pair<int, int> > P; // dist, v, idx\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push({0LL, {v, 0}});\n\tdist[0][v] = 0;\n\tP p;\n\tauto dijkstra = [&]{\n\t\twhile(!q.empty()) {\n\t\t\tp = q.top();\n\t\t\tq.pop();\n\t\t\tll cost = p.fi;\n\t\t\tv = p.se.fi;\n\t\t\tint now = p.se.se;\n\t\t\tif(dist[now][v] < cost) continue;\n\t\t\tfor(auto& e : es[now]) {\n\t\t\t\tint to = e.to;\n\t\t\t\tint nxt_v = (a*v+b)%c;\n\t\t\t\tll newCost = cost + e.cost*v;\n\t\t\t\tif(newCost < dist[to][nxt_v]) {\n\t\t\t\t\tdist[to][nxt_v] = newCost;\n\t\t\t\t\tq.push({newCost, {nxt_v, to}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tdijkstra();\n\tfor(int i = 0; i < n-1; i++) for(v = 0; v < c; v++) dist[i][v] = 1e18;\n\tfor(v = 0; v < c; v++) if(dist[n-1][v] != 1e18) q.push({dist[n-1][v], {v, n-1}});\n\tdijkstra();\n\tll ans = 1e18;\n\tfor(int i = 0; i < c; i++) ans = min(ans, dist[0][i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n??\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n????????int n,m;?? cin>>n>>m;\n????????vector<vector<pii>>edge(n,vector<pii>());\n????????rep(i,m){\n????????????????int a,b,c; cin>>a>>b>>c;\n????????????????--a,--b;\n????????????????edge[a].push_back(pii(b,c));\n????????????????edge[b].push_back(pii(a,c));\n????????}\n????????int v0,a,b,c; cin>>v0>>a>>b>>c;\n????????priority_queue<piii,vector<piii>,greater<piii>>que;\n????????d[0][v0]=0;\n????????que.push(piii(pii(0,0),v0));\n????????while(!que.empty()){\n????????????????piii now=que.top(); que.pop();\n????????????????int v=now.second;\n????????????????int _v=(v*a+b)%c;\n????????????????if(d[now.first.second][v]<now.first.first)continue;\n????????????????for(int i=0; i<edge[now.first.second].size();i++){\n????????????????????????pii next=edge[now.first.second][i];\n????????????????????????if(d[next.first][_v]<=now.first.first+next.second*v)continue;\n????????????????????????d[next.first][_v]=now.first.first+next.second*v;\n????????????????????????que.push(piii(pii(d[next.first][_v],next.first),_v));\n????????????????}\n????????}\n????????int ans=INF;\n????????rep(i,51)if(d[n-1][i]!=INF){\n????????????????vector<vector<long long>>_d(501,vector<long long>(51,INF));\n????????????????_d[n-1][i]=d[n-1][i];\n????????????????que.push(piii(pii(d[n-1][i],n-1),i));\n????????????????while(!que.empty()){\n????????????????????????piii now=que.top(); que.pop();\n????????????????????????int v=now.second;\n????????????????????????int _v=(v*a+b)%c;\n????????????????????????if(_d[now.first.second][v]<now.first.first)continue;\n????????????????????????for(int i=0; i<edge[now.first.second].size();i++){\n????????????????????????????????pii next=edge[now.first.second][i];\n????????????????????????????????if(_d[next.first][_v]<=now.first.first+next.second*v)continue;\n????????????????????????????????_d[next.first][_v]=now.first.first+next.second*v;\n????????????????????????????????que.push(piii(pii(_d[next.first][_v],next.first),_v));\n????????????????????????}\n????????????????}\n????????????????rep(i,51)ans=min(ans,_d[0][i]);\n????????}\n????????cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF 1145141919810893364\n//#define INF 810114514\n#define PI 3.141592653589\ntypedef long long ll;\ntypedef pair<ll,ll> PP;\n//#define int ll\n#define setdouble setprecision\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define OREP(i,n) for(int i=1;i<=(n);++i)\n#define RREP(i,n) for(int i=(n)-1;i>=0;--i)\n#define GOODBYE do { cout << \"0\" << endl; return 0; } while (false)\n#define MM <<\" \"<<\n#define Endl endl\n#define debug false\n#define debug2 false\n\nclass Dijkstra{\n    /*\n    Copyright (c) 2020 0214sh7\n    https://github.com/0214sh7/library/\n    */\n    private:\n    typedef std::pair<long long,int> P;\n    std::vector<std::vector<P>> G;\n    int V;\n    std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n    \n    public:\n    void init(std::vector<std::pair<std::pair<int,int>,long long>> edge){\n        //頂点数を決定する\n        V=0;\n        for(int i=0;i<edge.size();i++){\n            V=std::max(V,edge[i].first.first+1);\n            V=std::max(V,edge[i].first.second+1);\n        }\n        \n        //辺集合を扱いやすい形式に変換する\n        G.resize(V);\n        for(int i=0;i<edge.size();i++){\n            int from=edge[i].first.first,to=edge[i].first.second;\n            long long cost=edge[i].second;\n            G[from].push_back({cost,to});\n        }\n    }\n    \n    std::vector<long long> solve(int s){\n        std::vector<long long> d;\n        //INFで初期化する\n        for(int i=0;i<V;i++){\n            d.push_back(INF);\n        }\n        d[s]=0;\n        que.push({0,s});\n        //queは{cost,to}をコストが小さい順に出す\n        while(!que.empty()){\n            P p = que.top();\n            que.pop();\n            int v=p.second;\n            if(d[v]<p.first)continue;\n            for(int i=0;i<G[v].size();i++){\n                P e = G[v][i];\n                if(d[e.second]>d[v]+e.first){\n                    d[e.second] = d[v]+e.first;\n                    que.push({d[e.second],e.second});\n                }\n            }\n        }\n        return d;\n    }\n    \n    //init:{ {int,int},longlong}のvectorを渡すことで有向グラフを構築する\n    //solve:始点を渡すとinitで構築したグラフでダイクストラをし、コストのvectorを返す\n};\n\n\nsigned main(void){\n    \n    int N,M;\n    long long x;\n    vector<int> X,Y;\n    vector<long long>T;\n    int v0,A,B,C;\n    \n    cin >> N >> M;\n    REP(i,M){\n        cin >> x;x--;X.push_back(x);\n        cin >> x;x--;Y.push_back(x);\n        cin >> x;T.push_back(x);\n    }\n    cin >> v0 >> A >> B >> C;\n    \n    //行きの処理上の頂点番号 = 実際の頂点番号*50 + 速度\n    //帰りの処理上の頂点番号 = (N+実際の頂点番号)*50 + 速度\n    \n    std::vector<std::pair<std::pair<int,int>,long long>> edge;\n    std::pair<std::pair<int,int>,long long> h;\n    \n    //行き\n    REP(i,M){\n        REP(v,C){\n            h.first.first = X[i]*50 + v;\n            h.first.second = Y[i]*50 + (A*v+B)%C;\n            h.second = T[i]*v;\n            edge.push_back(h);\n            \n            h.first.first = Y[i]*50 + v;\n            h.first.second = X[i]*50 + (A*v+B)%C;\n            h.second = T[i]*v;\n            edge.push_back(h);\n        }\n    }\n    //帰り\n    REP(i,M){\n        REP(v,C){\n            h.first.first = (N+X[i])*50 + v;\n            h.first.second = (N+Y[i])*50 + (A*v+B)%C;\n            h.second = T[i]*v;\n            edge.push_back(h);\n            \n            h.first.first = (N+Y[i])*50 + v;\n            h.first.second = (N+X[i])*50 + (A*v+B)%C;\n            h.second = T[i]*v;\n            edge.push_back(h);\n        }\n    }\n    //行きのNと帰りのNを連結しておく\n    REP(v,C){\n        h.first.first = (N-1)*50 + v;\n        h.first.second = (N+N-1)*50 + v;\n        h.second = 0;\n        edge.push_back(h);\n    }\n    \n    Dijkstra dijkstra;\n    dijkstra.init(edge);\n    \n    vector<long long> D = dijkstra.solve(0*50+v0);\n    \n    \n    long long Ans=INF;\n    REP(v,C){\n        Ans = min(Ans,D[(N+0)*50+v]);\n    }\n    cout << Ans << endl;\n    \n    #if debug\n    int s[9]={3,8,1,0,5,7,6,2,4};\n    REP(i,C){\n        REP(j,N){\n            cout << D[(0+j)*50+s[i]] << \" \";\n        }cout << \"   \";\n        RREP(j,N){\n            cout << D[(N+j)*50+s[i]] << \" \";\n        }cout << endl;\n        \n    }cout << endl;\n    #endif\n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cost;\n};\nvector< vector<Edge> > G;\n\nstruct Node {\n    ll v, speed;\n    bool f;\n    ll cost;\n};\nbool operator>(const Node& n1, const Node& n2) {\n    return n1.cost > n2.cost;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    G.resize(n);\n    REP(i, m) {\n        ll x, y, t; cin >> x >> y >> t; --x, --y;\n        G[x].pb({y, t});\n        G[y].pb({x, t});\n    }\n    ll v0; cin >> v0;\n    ll A, B, C; cin >> A >> B >> C;\n    vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(C, vector<ll>(2, linf)));\n    dist[0][v0][0] = 0;\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    Q.push({0, v0, false, 0});\n    while ( !Q.empty() ) {\n        Node node = Q.top(); Q.pop();\n        ll v = node.v;\n        ll speed = node.speed;\n        bool f = node.f;\n        ll cost = node.cost;\n        if (cost > dist[v][speed][f]) continue;\n        EACH(e, G[v]) {\n            ll nd = cost + speed * e.cost;\n            ll ns = (A * speed + B) % C;\n            bool nf = f || e.to == n-1;\n            if (nd < dist[e.to][ns][nf]) {\n                dist[e.to][ns][nf] = nd;\n                Q.push({e.to, ns, nf, nd});\n            }\n        }\n    }\n    ll ans = linf;\n    REP(i, C) {\n        ans = min(ans, dist[0][i][1]);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rrep(i,n) for(int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for(int i=(a)-1;i>=b;--i)\n#define range(i,a,b,c) for(int i=a;\\\n                    c>0?i<b:\\\n                    i>b;\\\n                    i+=c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define int long long\n#ifdef _MSC_VER\nconst bool test = false;\n#else \nconst bool test = false;\n#endif\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real& r) { return (r > eps) - (r < -eps); }\nint sgn(const Real& a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep) {\n\tvector<string> v;\n\tstringstream ss(str);\n\tstring buffer;\n\twhile (getline(ss, buffer, sep)) {\n\t\tv.push_back(buffer);\n\t}\n\treturn v;\n}\n\ntemplate<class InputIterator>\nint sum(InputIterator begin, InputIterator end) {\n\treturn accumulate(begin, end, 0ll);\n}\n\nstring reverse_str(string s) {\n\treverse(all(s));\n\treturn s;\n}\n\nstruct Vertex {\n\tint id, weight, v, dist, flag;\n\tVertex(int id, int weight, int v, int dist, int flag) : \n\t\tid(id), weight(weight), v(v), dist(dist), flag(flag) {  }\n\tbool operator > (const Vertex& r) const { return dist > r.dist; }\n};\n\nusing Graph = vector<vector<Vertex>>;\n\nusing Weight = int;\n\nint n, m;\nint v0;\nint a, b, c;\nvector<Vertex> g[MAX];\nint d[505][55][2];\n\nint dijkstra(int start) {\n\trep(i, n) rep(j, c) rep(k, 2) {\n\t\td[i][j][k] = INFL;\n\t}\n\td[0][0][0] = 0;\n\tpriority_queue<Vertex, vector<Vertex>, greater<Vertex>> q;\n\tfor (q.push(Vertex(start, 0, v0, 0, false)); !q.empty(); ) {\n\t\tVertex p = q.top(); q.pop();\n\t\tfor (auto next_p : g[p.id]) {\n\t\t\tnext_p.v = (a * p.v + b) % c;\n\t\t\tnext_p.dist = p.dist + p.v * next_p.weight;\n\t\t\tnext_p.flag = (p.flag || next_p.id == n - 1);\n\t\t\tif (d[next_p.id][next_p.v][next_p.flag] > next_p.dist) {\n\t\t\t\td[next_p.id][next_p.v][next_p.flag] = next_p.dist;\n\t\t\t\tq.push(next_p);\n\t\t\t}\n\t\t}\n\t}\n\tint min_cost = INFL;\n\trep(j, c) chmin(min_cost, d[0][j][1]);\n\treturn min_cost;\n}\n\nvoid solve() {\n\tcin >> n >> m;\n\trep(i, m) {\n\t\tint x, y, t;\n\t\tcin >> x >> y >> t;\n\t\tx--;\n\t\ty--;\n\t\tg[x].push_back(Vertex(y, t, 0, 0, false));\n\t\tg[y].push_back(Vertex(x, t, 0, 0, false));\n\t}\n\tcin >> v0;\n\tcin >> a >> b >> c;\n\tcout << dijkstra(0) << endl;\n}\n\nsigned main() {\n\tsrand(time(NULL));\n\tint T = (int)1e15;\n\tsolve();\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\tchar s[MAX];\n\t\tif (scanf(\"%s\", s) == EOF) break;\n\t\tint n = strlen(s);\n\t\tfor (int i = n - 1; i > -1; i--) {\n\t\t\tungetc(s[i], stdin);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing P = pair<ll,int>;\n\nconst int V = 50000;\nconst ll INF = LLONG_MAX/3;\nstruct edge{int to; ll cost;};\n\nvector<edge> G[V];\nll d[V];\n\nint main()\n{\n    int n,m;\n    scanf(\" %d %d\", &n, &m);\n    vector<int> x(m),y(m);\n    vector<ll> t(m);\n    rep(i,m)\n    {\n        scanf(\" %d %d %lld\", &x[i], &y[i], &t[i]);\n        --x[i];\n        --y[i];\n    }\n    int v0,a,b,c;\n    scanf(\" %d %d %d %d\", &v0, &a, &b, &c);\n\n    rep(v,c)\n    {\n        int nv = (a*v+b)%c;\n        rep(i,m)\n        {\n            G[c*x[i]+v].pb({c*y[i]+nv,t[i]*v});\n            G[c*y[i]+v].pb({c*x[i]+nv,t[i]*v});\n            int A = c*n;\n            G[A+c*x[i]+v].pb({A+c*y[i]+nv,t[i]*v});\n            G[A+c*y[i]+v].pb({A+c*x[i]+nv,t[i]*v});\n        }\n    }\n\n    rep(i,c)\n    {\n        int u = c*(n-1)+i, v = n*c+u;\n        G[u].pb({v,0});\n        G[v].pb({u,0});\n    }\n\n    // dijkstra\n    fill(d,d+V,INF);\n    d[v0]=0;\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(P(0,v0));\n    while(!que.empty())\n    {\n        P p = que.top();\n        que.pop();\n\n        int v = p.se;\n        if(p.fi>d[v]) continue;\n\n        for(const auto &e:G[v])\n        {\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to] = d[v]+e.cost;\n                que.push(P(d[e.to],e.to));\n            }\n        }\n    }\n\n    ll ans = INF;\n    rep(i,c) ans = min(ans,d[n*c+i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\n// using Graph = vector<vector<int>>;\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\nusing Graph = vector<vector<edge>>;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, int c) {\n    G[x].emplace_back(y, c);\n    G[y].emplace_back(x, c);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    Graph G(n);\n    rep(i, m) {\n        int x, y, t;\n        cin >> x >> y >> t;\n        x--; y--;\n        addEdge(G, x, y, t);\n    }\n\n    int v0;\n    cin >> v0;\n    int a, b, c;\n    cin >> a >> b >> c;\n\n    // dijkstra\n\n    using Vertex = tuple<int, int, int>; // {i, j, k}\n    using State = pair<int, Vertex>;\n    priority_queue<State, vector<State>, greater<State>> pq; // cost, vertex\n    vvvi d(n, vvi(c + 1, vi(2, inf)));\n    d[0][v0][0] = 0;\n    pq.push(State(0, make_tuple(0, v0, 0)));\n\n    while (!pq.empty()) {\n        int cost;\n        Vertex vertex;\n        tie(cost, vertex) = pq.top(); pq.pop();\n        int i, j, k;\n        tie(i, j, k) = vertex;\n        if (d[i][j][k] < cost) continue;\n        for (const auto& e : G[i]) {\n            int ni = e.to;\n            int nj = (a * j + b) % c;\n            int nk = k ? 1 : (i == n - 1);\n            int edge_cost = e.cost * j;\n            if (d[ni][nj][nk] > cost + edge_cost) {\n                d[ni][nj][nk] = cost + edge_cost;\n                pq.push(State(d[ni][nj][nk], Vertex(ni, nj, nk)));\n            }\n        }\n    }\n\n    int ans = inf;\n    rep(j, c + 1) {\n        ans = min(ans, d[0][j][1]);\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint n, m;\nint a, b, c;\nint v0;\nstruct Edge {\n    int to, t;\n    Edge(int to = 0, int t = 0) : to(to), t(t) {}\n};\nint update(int v) { return (a * v + b) % c; }\nvector<Edge> G[502];\nusing State = tuple<int, int, int>;\nmap<State, ll> dp;\npriority_queue<pair<ll, State>> que;\n\nint main() {\n    cin >> n >> m;\n    rep(i, m) {\n        int x, y, t;\n        cin >> x >> y >> t;\n        G[x].push_back(Edge(y, t));\n        G[y].push_back(Edge(x, t));\n    }\n    cin >> v0;\n    cin >> a >> b >> c;\n    auto initState = State(1, v0, 0);\n    dp[initState] = 0;\n    que.push(make_pair(0, initState));\n\n    while (que.size()) {\n        auto p = que.top();\n        que.pop();\n        auto nowCost = p.first;\n        auto nowState = p.second;\n        auto v = get<0>(nowState);\n        auto v1 = get<1>(nowState);\n        auto s = get<2>(nowState);\n        auto v2 = update(v1);\n        // printf(\"%d %d %d %d\\n\", v, v1, s, dp[nowState]);\n\n        if (s == 0 && v == n) s = 1;\n        rep(i, G[v].size()) {\n            auto e = G[v][i];\n            ll cost = 1LL * e.t * v1;\n            auto nextState = State(e.to, v2, s);\n            if (dp.count(nextState) == 0 ||\n                dp[nowState] + cost < dp[nextState]) {\n                dp[nextState] = dp[nowState] + cost;\n                que.push(make_pair(-dp[nextState], nextState));\n            }\n        }\n    }\n\n    ll ans = INF;\n    rep(i, 50) {\n        auto s = State(1, i, 1);\n        if (dp.count(s)) ans = min(ans, dp[s]);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll, pll> tll;\nconst ll INF = 1e18;\n\nstruct State{\n  ll dis, u, v, flag;\n  State(ll a, ll b, ll c, ll d):dis(a), u(b), v(c), flag(d) {}\n  bool operator<(const State &a) const {\n    return dis > a.dis;\n  }\n};\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n  vector< vector<pll> > g(n);\n  for(int i=0;i<m;i++){\n    int x,y,t;\n    cin >> x >> y >> t; x--; y--;\n    g[x].emplace_back( make_pair(t,y) );\n    g[y].emplace_back( make_pair(t,x) );\n  }\n  ll v,a,b,c;\n  cin >> v >> a >> b >> c;\n\n  vector< vector< vector<ll> > > d(n, vector< vector<ll> >(c, vector<ll>(2,INF)));\n  assert(v<c);\n  d[0][v][0] = 0;\n  priority_queue<State> q;\n  q.emplace( State(0,0,v,0) );\n\n  while(not q.empty()){\n    State state = q.top(); q.pop();\n    ll dis = state.dis, u = state.u, v = state.v, flag = state.flag;\n    if(d[u][v][flag] < dis) continue;\n\n    ll nv = (a*v + b) % c;\n    for(auto e : g[u]){\n      ll ndis = dis + v*e.first, nu = e.second, nflag = (nu==n-1) ? 1 : flag;\n      if(d[nu][nv][flag] > ndis){\n        d[nu][nv][flag] = ndis;\n        q.emplace( State(ndis, nu, nv, nflag) );\n      }\n    }\n  }\n\n  ll ans = INF;\n  for(int i=0;i<c;i++) ans = min(ans, d[0][i][1]);\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define int long long\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,int> piii;\n    vector<vector<int>>d(n,vector<int>(100,LLONG_MAX));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    bool visit=true;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n            if(next.first==n-1&&visit){\n                visit=false;\n                //cout<<d[next.first][_v]<<endl;\n                while(!que.empty())que.pop();\n                vector<vector<int>>_d(n,vector<int>(100,LLONG_MAX));\n                _d[n-1]=d[n-1];\n                d=_d;\n                que.push(piii(pii(d[n-1][_v],n-1),_v));\n                continue;\n            }\n        }\n    }\n    int ans=LLONG_MAX;\n    rep(i,c+1)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[2][111][555];\nstruct st{\n  int f,dist,time,pos;\n  st(){}\n  st(int f,int dist,int time,int pos):f(f),dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  int v,a,b,c;\n  cin>>v>>a>>b>>c;\n  \n  //memset(dp,-1,sizeof(dp));\n  int INF=1LL<<60LL;\n  for(int i=0;i<c;i++)\n    for(int j=0;j<n;j++)\n      dp[0][i][j]=dp[1][i][j]=INF;\n\n  int e[n][n];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      e[i][j]=INF;\n  for(int i=0;i<m;i++)\n    e[x[i]-1][y[i]-1]=e[y[i]-1][x[i]-1]=t[i];\n\n  vector<int> ve;\n  map<int,int> mv;\n  ve.push_back(v);\n  int w=0;\n  while(!mv.count(ve[w])){\n    mv[ve[w]]=w;\n    ve.push_back((a*ve[w]+b)%c);\n    w++;\n  }\n  \n  int r=w-mv[ve[w]];\n  \n\n  priority_queue<st> q;\n  q.push(st(0,0,0,0));\n  dp[0][0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int f=p.f,d=p.dist,t=p.time,u=p.pos;\n    assert(0<=t&&t<c);\n    assert(d>=0);\n    //cout<<d<<\" \"<<t<<\" \"<<u<<endl;\n    if(f&&u==0){\n      cout<<d<<endl;\n      return 0;\n    }\n    if(dp[f][t][u]<d) continue;\n    assert(dp[f][t][u]==d);\n    if(u==n-1&&!f){\n      if(d<dp[1][t][u]){\n\tdp[1][t][u]=d;\n\tq.push(st(1,d,t,u));\n      }\n    }\n    \n    for(int i=0;i<n;i++){\n      if(e[u][i]==INF) continue;\n      int nt=t+1;\n      if(nt>=w) nt-=r;\n      int nc=e[u][i]*ve[t];\n      if(d+nc<dp[f][nt][i]){\n\tdp[f][nt][i]=d+nc;\n\tq.push(st(f,d+nc,nt,i));\n      }\n    }\n    \n  }\n  assert(0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nstruct Edge {\n    ll to, cost;\n    Edge(ll t, ll c) : to(t), cost(c) {}\n};\nstruct Elem {\n    ll dist, speed, cur;\n    Elem(ll a, ll b, ll c) : dist(a), speed(b), cur(c) {}\n};\nbool operator>(const Elem& a, const Elem& b) {\n    return a.dist != b.dist ? a.dist > b.dist : a.speed > b.speed;\n}\n\ntypedef vector< vector<Edge> > Graph;\nll const INF = 1LL << 60;\n\nint main() {\n    ll dist[510][60][2];\n    ll ans = INF;\n    for(int i=0; i<510; i++)\n        for(int j=0; j<60; j++)\n            for(int k=0; k<2; k++)\n                dist[i][j][k] = INF;\n\n    int n, m; cin >> n >> m;\n    Graph G(n);\n    for(int i=0; i<m; i++) {\n        ll a, b, t; cin >> a >> b >> t;\n        a--; b--;\n        G[a].push_back(Edge(b,t));\n        G[b].push_back(Edge(a,t));\n    }\n    ll v, a, b, c;\n    cin >> v >> a >> b >> c;\n    priority_queue< Elem, vector<Elem>, greater<Elem> > q;\n\n    ll cur = 0, speed = v;\n    dist[0][v][0] = 0;\n    q.push(Elem(0, speed, cur));\n    while(!q.empty()) {\n        Elem temp = q.top(); q.pop();\n        cur = temp.cur, speed = temp.speed;\n        ll nsp = (a * speed + b) % c;\n        for(size_t i=0; i<G[cur].size(); i++) {\n            Edge e = G[cur][i];\n            ll d1 = dist[cur][speed][0] + e.cost * speed;\n            ll d2 = dist[cur][speed][1] + e.cost * speed;\n            // home to university\n            if(dist[e.to][nsp][0] > d1) {\n                dist[e.to][nsp][0] = d1;\n                if(e.to == n-1) dist[e.to][nsp][1] = dist[e.to][nsp][0];\n                q.push(Elem(d1, nsp, e.to));\n            }\n            // university to home\n            if(dist[e.to][nsp][1] > d2) {\n                dist[e.to][nsp][1] = d2;\n                q.push(Elem(d2, nsp, e.to));\n            }\n        }\n    }\n\n    for(int i=0; i<c; i++) ans = min(ans, dist[0][i][1]);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n\n\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<long,long> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,long long> piii;\n    vector<vector<long long>>d(n,vector<long long>(100,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<long long>>_d(n,vector<long long>(100,LLONG_MAX/10));\n    rep(i,c+1)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,c+1)if(d[n-1][i]!=LLONG_MAX/10)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    long long ans=LLONG_MAX/10;\n    rep(i,100)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<iostream>\n#include<vector>\n#include<queue>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> piii;\n//vector<vector<long long> >d(501,vector<long long>(51,INF));\nint d[501][2][51];\nsigned main(){\n\trep(i,501)rep(j,2)rep(k,51)d[i][j][k]=INF;\n    int n,m;  cin>>n>>m;\n    vector<vector<pii> >edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii>que;\n    d[0][0][v0]=0;\n    que.push(piii(pii(0,0),{0,v0}));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n\t\tnow.first.first*=-1;\n        int v=now.second.second;\n\t\tint t=now.second.first;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][t][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n\t\t\tint nt=t|edge[now.first.second][i].first==n-1;\n            pii next=edge[now.first.second][i];\n            if(d[next.first][nt][_v]<=now.first.first+next.second*v)continue;\n            d[next.first][nt][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(-d[next.first][nt][_v],next.first),{nt,_v}));\n        }\n    }\n    int ans=INF;\n\trep(i,51)ans=min(ans,d[0][1][i]);\n/*    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long> >_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\t*/\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\n\nint main() {\n  ll n,m;\n  cin >> n >> m;\n  vector<P> v[n];\n  for(int i=0; i<m; i++) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    x--,y--;\n    v[x].push_back(P(y,z));\n    v[y].push_back(P(x,z));\n  }\n  ll v0,A,B,C;\n  cin >> v0 >> A >> B >> C;\n  ll d[n][50];\n  for(int i=0; i<n; i++)for(int j=0; j<C; j++) d[i][j]=1LL<<59;\n  d[0][v0]=0;\n  priority_queue<PP,vector<PP>,greater<PP> > que;\n  que.push(PP(0,P(0,v0)));\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    ll x=p.second.first,t=p.second.second,c=p.first;\n    if(d[x][t]<c) continue;\n    for(int i=0; i<v[x].size(); i++) {\n      ll y=v[x][i].first,cc=v[x][i].second;\n      ll s=(A*t+B)%C;\n      if(d[y][s]<=d[x][t]+cc*t) continue;\n      d[y][s]=d[x][t]+cc*t;\n      que.push(PP(d[y][s],P(y,s)));\n    }\n  }\n  for(int i=0; i<n-1; i++)for(int j=0; j<C; j++)d[i][j]=1LL<<59;\n  for(int i=0; i<C; i++) que.push(PP(d[n-1][i],P(n-1,i)));\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    ll x=p.second.first,t=p.second.second,c=p.first;\n    if(d[x][t]<c) continue;\n    for(int i=0; i<v[x].size(); i++) {\n      ll y=v[x][i].first,cc=v[x][i].second;\n      ll s=(A*t+B)%C;\n      if(d[y][s]<=d[x][t]+cc*t) continue;\n      d[y][s]=d[x][t]+cc*t;\n      que.push(PP(d[y][s],P(y,s)));\n    }\n  }\n  ll ans=1LL<<59;\n  for(int i=0; i<C; i++) ans=min(ans,d[0][i]);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(500,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<=now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<=now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\nLogin\n \nRegister/Setting\nJapanese   English\nFor beginners    HOME-\nNotes\n#2517448 Solution for 2819: Country in Distortion by yebityon\nSource Code Status Test Cases     Policy: public     Reviewed: 28    \n00.13 sec    3776 KB    57 lines     1943 bytes    2017-09-01 14:24\n?\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint v,a,b,c;\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[55][1111];\nint dp[55][1111];\nvoid add_edge(int time,int from,int to,int cost){\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n  G[time][to].push_back(edge(time,from,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i]);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i]);\n      ve=(a*ve+b)%c;\n    }\n  }\n  for(int j=0;j<c;j++) add_edge2(j,n-1,n+n-1,0);\n  \n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=1LL<<60LL;\n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  dp[0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int t=p.time,u=p.pos,d=p.dist;\n    assert(0<=t&&t<c);\n    //cout<<t<<\" \"<<u<<\" \"<<d<<endl;\n    if(u==n){\n      ans=d;\n      break;\n    }\n    if(dp[t][u]<d) continue;\n    assert(dp[t][u]==d);\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(u>=n&&nu<n) continue;\n      if(dp[nt][nu]<0||d+nc<dp[nt][nu]){\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  assert(ans>=0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n,m;\nvector<pii> g[525];\nint v0,a,b,c;\n\nll dist[525*50];\nll dist2[50][525*50];\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  REP(i,m){\n    int x,y,t;\n    scanf(\"%d%d%d\",&x,&y,&t);\n    --x;--y;\n    g[x].push_back(pii(y,t));\n    g[y].push_back(pii(x,t));\n  }\n  scanf(\"%d%d%d%d\",&v0,&a,&b,&c);\n  priority_queue<pll> Q;\n  REP(i,n*50)dist[i] = 1e18;\n  dist[0*50 + v0] = 0;\n  Q.push(pll(-0, 0*50+v0));\n  while(!Q.empty()){\n    pll P = Q.top(); Q.pop();\n    int pos = P.second;\n    if(-P.first != dist[pos])continue;\n    int p = pos/50;\n    int v = pos%50;\n    int nv = (a*v+b)%c;\n    for(pii P : g[p]){\n      int to = P.first;\n      int tt = P.second;\n      ll ndist = dist[pos] + (ll)tt*v;\n      if(ndist < dist[to*50 + nv]){\n        dist[to*50+nv] = ndist;\n        Q.push(pll(-ndist, to*50 + nv));\n      }\n    }\n  }\n\n  REP(v1,50){\n    REP(i,n*50)dist2[v1][i] = 1e18;\n    dist2[v1][(n-1)*50+v1] = 0;\n    Q.push(pll(-0, (n-1)*50+v1));\n    while(!Q.empty()){\n      pll P = Q.top(); Q.pop();\n      int pos = P.second;\n      if(-P.first != dist2[v1][pos])continue;\n      int p = pos/50;\n      int v = pos%50;\n      int nv = (a*v+b)%c;\n      for(pii P : g[p]){\n        int to = P.first;\n        int tt = P.second;\n        ll ndist = dist2[v1][pos] + (ll)tt*v;\n        if(ndist < dist2[v1][to*50 + nv]){\n          dist2[v1][to*50+nv] = ndist;\n          Q.push(pll(-ndist, to*50 + nv));\n        }\n      }\n    }\n  }\n\n  ll ans = 1e18;\n  REP(i,c)REP(j,c){\n    CHMIN(ans, dist[(n-1)*50+i] + dist2[i][0+j]);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int N,M;\n  cin>>N>>M;\n  vector<vector<pair<int,int64_t>>> G(N*2-1);\n  for(int i=0;i<M;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--,b--;\n    G.at(a).push_back(make_pair(b,c));\n    G.at(b).push_back(make_pair(a,c));\n    G.at((2*N-2)-a).push_back(make_pair((2*N-2)-b,c));\n    G.at((2*N-2)-b).push_back(make_pair((2*N-2)-a,c));\n  }\n  int v,a,b,c;\n  cin>>v>>a>>b>>c;\n  vector<int> p(c);\n  for(int i=0;i<c;i++){\n    p.at(i)=(a*i+b)%c;\n  }\n  vector<int64_t> r((2*N-1)*c,1000000000000000000);\n  priority_queue<pair<int64_t,int>,vector<pair<int64_t,int>>,greater<pair<int64_t,int>>> pq;\n  pq.push(make_pair(0,v));\n  r.at(v)=0;\n  while(!pq.empty()){\n    int64_t x,y;\n    tie(x,y)=pq.top();\n    pq.pop();\n    int64_t k=y/c,l=y%c;\n    if(r.at(y)<x){\n      continue;\n    }\n    else if(k==2*N-2){\n      cout<<x<<endl;\n      break;\n    }\n    else{\n      for(auto Q:G.at(k)){\n        if(r.at(Q.first*c+p.at(l))>x+l*Q.second){\n          r.at(Q.first*c+p.at(l))=x+l*Q.second;\n          pq.push(make_pair(x+l*Q.second,Q.first*c+p.at(l)));\n        }\n      }\n    }\n  }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 501\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\nll const INF = 1LL<<55;\nint n,m;\nvector<P> G[N];\nint v0,a,b,C;\nll v[5010];\n\n\nll dijkstra(int start,int goal,int c){\n  ll D[500][1001];\n  for(int i=0;i<500;i++)\n    for(int j=0;j<1001;j++) D[i][j] = INF;\n\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(start,c)));\n  D[start][c] = 0;\n  ll res = INF;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    ll cost = t.first; \n    int pos = t.second.first;\n    int cnt = t.second.second;\n    if(D[pos][cnt]<cost) continue;\n    if(pos==goal&&goal == 0)return cost; \n    if(pos==goal&&goal == n-1){\n      res=min(res,cost+dijkstra(n-1,0,cnt));\n      continue;\n    }\n    for(int i=0;i<(int)G[pos].size();i++){\n      int npos = G[pos][i].first;\n      ll ncost = cost+v[cnt]*G[pos][i].second;\n      int ncnt = (cnt+1)%C;\n      if(D[npos][ncnt]<=ncost)continue;\n      Q.push(PP(ncost,P(npos,ncnt)));\n      D[npos][ncnt] = ncost;\n    }\n  }\n  return res;\n}\n\nmain(){\n  cin>>n>>m;\n  for(int i=0,x,y,t;i<m;i++){\n    cin>>x>>y>>t;\n    x--,y--;\n    G[x].push_back(P(y,t));\n    G[y].push_back(P(x,t));\n  }\n  cin>>v[0]>>a>>b>>C;\n  for(int i=1;i<100;i++)v[i] = (a*v[i-1]+b)%C;\n  cout<<dijkstra(0,n-1,0)<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\n\nstruct Edge { int dst; ll w; };\nstruct Data {\n  int cur,v; ll w;\n  bool operator < ( const Data &e ) const {\n    if( w != e.w ) return w > e.w;\n    if( v != e.v ) return v > e.v;\n    return cur > e.cur;\n  }\n};\n\n#define MAX_V 510\n\nint V,E;\nll v0,a,b,c;\nll mini[MAX_V][51][2];\nvector<Edge> G[MAX_V];\n\nll cost1;\nll adhoc = LLINF;\nvoid dijkstra(int sp,int v0) {\n  rep(i,V) rep(j,c) mini[i][j][sp==(V-1)] = LLINF;\n  priority_queue<Data> Q;\n  Q.push((Data){sp,v0,0});\n  mini[sp][v0][sp==(V-1)] = 0;\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.w + cost1 >= adhoc ) return;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      int nv = ( a * data.v + b ) % c;\n      ll nw = data.w + e.w * data.v;\n      if( adhoc != LLINF && cost1 + nw >= adhoc ) continue;\n      if( nw < mini[e.dst][nv][sp==(V-1)] ) {\n        mini[e.dst][nv][sp==(V-1)] = nw;\n        Q.push((Data){e.dst,nv,nw});\n      }\n    }\n  }\n}\n\nvoid compute() {\n  dijkstra(0,v0);\n  ll ans = LLINF;\n  rep(i,c) {\n    if( mini[V-1][i][0] != LLINF ) {\n      ll cost = mini[V-1][i][0];\n      if( cost >= ans ) continue;\n      cost1 = cost;\n      dijkstra(V-1,i);\n      ll tmp = LLINF;\n      rep(j,c) tmp = min(tmp,mini[0][j][1]);\n      if( tmp == LLINF ) continue;\n      ans = min(ans,cost+tmp);\n      adhoc = ans;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  rep(i,E) {\n    int x,y,t;\n    cin >> x >> y >> t;\n    --x,--y;\n    G[x].push_back((Edge){y,t});\n    G[y].push_back((Edge){x,t});\n  } \n  cin >> v0 >> a >> b >> c;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n\n\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<long,long> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,long long> piii;\n    vector<vector<long long>>d(n,vector<long long>(51,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<long long>>_d(n,vector<long long>(51,LLONG_MAX/10));\n    rep(i,c+1)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,c+1)if(d[n-1][i]!=LLONG_MAX/10)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    long long ans=LLONG_MAX/10;\n    rep(i,51)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint v,a,b,c;\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[55][1111];\nint dp[55][1111];\nvoid add_edge(int time,int from,int to,int cost){\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n  G[time][to].push_back(edge(time,from,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i]);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i]);\n      ve=(a*ve+b)%c;\n    }\n  }\n  for(int i=0;i<c;i++) add_edge2(i,n-1,n+n-1,0);\n  \n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=1LL<<50LL;\n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  dp[0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int t=p.time,u=p.pos,d=p.dist;\n    //cout<<t<<\" \"<<u<<\" \"<<d<<endl;\n    if(u==n){\n      ans=d;\n      break;\n    }\n    if(dp[t][u]<d) continue;\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(dp[nt][nu]<0||d+nc<dp[nt][nu]){\n\tdp[nt][nu]=d+nc;\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e15;\n\nstruct Edge{\n  LL to, cost;\n\n  Edge(LL t, LL c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\n\nvoid Dijkstra(const Graph& edges, vector<LL>& d, int s){\n  using Type = PLL;\n  priority_queue<Type, vector<Type>, greater<Type> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tType pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(unsigned int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint idx(int u, int v, int flag){\n  return (u * 50 + v) * 2 + flag;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n\n  VL xs(M), ys(M), ts(M);\n  REP(i,M){\n\tcin >> xs[i] >> ys[i] >> ts[i];\n\t--xs[i];\n\t--ys[i];\n  }\n\n  LL V, A, B, C;\n  cin >> V >> A >> B >> C;\n\t\n  Graph G(500*50*2);\n  REP(i,M){\n\tREP(k,C){\n\t  G[idx(xs[i], k, 0)].EB(idx(ys[i], (A*k+B)%C, 0), k*ts[i]);\n\t  G[idx(ys[i], k, 0)].EB(idx(xs[i], (A*k+B)%C, 0), k*ts[i]);\n\t  G[idx(xs[i], k, 1)].EB(idx(ys[i], (A*k+B)%C, 1), k*ts[i]);\n\t  G[idx(ys[i], k, 1)].EB(idx(xs[i], (A*k+B)%C, 1), k*ts[i]);\n\t}\n  }\n  REP(k,C)\n\tG[idx(N-1, k, 0)].EB(idx(N-1, k, 1), 0);\n\n  VL d(500*50*2);\n  Dijkstra(G, d, idx(0, V, 0));\n\n  LL ans = INF;\n  REP(k,C)\n\tmini(ans, d[idx(0, k, 1)]);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[55][1111];\nint dp[55][1111];\nvoid add_edge(int time,int from,int to,int cost,int c){\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  int v,a,b,c;\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i],c);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i],c);\n      ve=(a*ve+b)%c;\n    }\n  }\n\n  for(int j=0;j<c;j++) add_edge2(j,n-1,n+n-1,0);\n  \n  //memset(dp,-1,sizeof(dp));\n  int INF=1LL<<60LL;\n  for(int i=0;i<c;i++)\n    for(int j=0;j<n*2;j++)\n      dp[i][j]=INF;\n  \n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  dp[0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int d=p.dist,t=p.time,u=p.pos;\n    assert(0<=t&&t<c);\n    //cout<<d<<\" \"<<t<<\" \"<<u<<endl;\n    if(u==n){\n      cout<<d<<endl;\n      return 0;\n    }\n    if(dp[t][u]<d) continue;\n    assert(dp[t][u]==d);\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(d+nc<dp[nt][nu]){\n\tdp[nt][nu]=d+nc;\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  assert(0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 510\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int INF = 1LL<<55;\nint n;\nvector<P> G[N];\nint A,B,C;\n\nint dijkstra(int start,int goal,int v0,int flg = 1){\n  vector<vector<int> > D(n,vector<int>(C,INF));\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  D[start][v0] = 0;\n  Q.push(PP(0,P(start,v0)));\n\n  int res = INF;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int v = t.second.second;\n    //cout<<flg<<\" \" <<pos<<\" \"<<cost<<\" \"<<v<<endl;\n    if(D[pos][v] < cost) continue;\n    \n    if(pos == goal){\n      if(flg == 1) res = min(res, cost + dijkstra(goal,start,v,0));\n      if(flg == 0) return cost;\n    }\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost + v * G[pos][i].second;\n      int nv = (A*v+B)%C;\n      if(D[npos][nv]<=ncost) continue;\n      Q.push(PP(ncost,P(npos,nv)));\n      D[npos][nv] = ncost;\n    }\n  }\n  return res;\n}\n\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n\n  for(int i=0;i<m;i++){\n    int a,b,t;\n    cin>>a>>b>>t;a--,b--;\n    G[a].push_back(P(b,t));\n    G[b].push_back(P(a,t));\n  }\n  int v0;\n  cin>>v0;\n  cin>>A>>B>>C;\n  cout<<dijkstra(0,n-1,v0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[55][1111];\nint dp[55][1111];\nvoid add_edge(int time,int from,int to,int cost,int c){\n  assert(cost>=0);\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  int v,a,b,c;\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i],c);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i],c);\n      ve=(a*ve+b)%c;\n    }\n  }\n\n  for(int j=0;j<c;j++) add_edge2(j,n-1,n+n-1,0);\n  \n  //memset(dp,-1,sizeof(dp));\n  int INF=1LL<<60LL;\n  for(int i=0;i<c;i++)\n    for(int j=0;j<n*2;j++)\n      dp[i][j]=INF;\n  \n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  dp[0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int d=p.dist,t=p.time,u=p.pos;\n    assert(0<=t&&t<c);\n    assert(d>=0);\n    //cout<<d<<\" \"<<t<<\" \"<<u<<endl;\n    if(u==n){\n      cout<<d<<endl;\n      return 0;\n    }\n    if(dp[t][u]<d) continue;\n    assert(dp[t][u]==d);\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(d+nc<dp[nt][nu]){\n\tdp[nt][nu]=d+nc;\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  assert(0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n??\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n????????int n,m;?? cin>>n>>m;\n????????vector<vector<pii>>edge(n,vector<pii>());\n????????rep(i,m){\n????????????????int a,b,c; cin>>a>>b>>c;\n????????????????--a,--b;\n????????????????edge[a].push_back(pii(b,c));\n????????????????edge[b].push_back(pii(a,c));\n????????}\n????????int v0,a,b,c; cin>>v0>>a>>b>>c;\n????????priority_queue<piii,vector<piii>,greater<piii>>que;\n????????d[0][v0]=0;\n????????que.push(piii(pii(0,0),v0));\n????????while(!que.empty()){\n????????????????piii now=que.top(); que.pop();\n????????????????int v=now.second;\n????????????????int _v=(v*a+b)%c;\n????????????????if(d[now.first.second][v]<now.first.first)continue;\n????????????????for(int i=0; i<edge[now.first.second].size();i++){\n????????????????????????pii next=edge[now.first.second][i];\n????????????????????????if(d[next.first][_v]<now.first.first+next.second*v)continue;\n????????????????????????d[next.first][_v]=now.first.first+next.second*v;\n????????????????????????que.push(piii(pii(d[next.first][_v],next.first),_v));\n????????????????}\n????????}\n????????int ans=INF;\n????????rep(i,51)if(d[n-1][i]!=INF){\n????????????????vector<vector<long long>>_d(501,vector<long long>(51,INF));\n????????????????_d[n-1][i]=d[n-1][i];\n????????????????que.push(piii(pii(d[n-1][i],n-1),i));\n????????????????while(!que.empty()){\n????????????????????????piii now=que.top(); que.pop();\n????????????????????????int v=now.second;\n????????????????????????int _v=(v*a+b)%c;\n????????????????????????if(_d[now.first.second][v]<now.first.first)continue;\n????????????????????????for(int i=0; i<edge[now.first.second].size();i++){\n????????????????????????????????pii next=edge[now.first.second][i];\n????????????????????????????????if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n????????????????????????????????_d[next.first][_v]=now.first.first+next.second*v;\n????????????????????????????????que.push(piii(pii(_d[next.first][_v],next.first),_v));\n????????????????????????}\n????????????????}\n????????????????rep(i,51)ans=min(ans,_d[0][i]);\n????????}\n????????cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n//#include <tuple>\n//#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m);\n\tVEC_ROW(int, m, x, y, t);\n\tVAR(int, v0, a, b, c);\n\n\tstruct Edge {\n\t\tint to, cost;\n\t\tEdge() {}\n\t\tEdge(int to, int cost) : to(to), cost(cost) {}\n\t\tbool operator<(const Edge& r) const {\n\t\t\treturn cost < r.cost;\n\t\t}\n\t};\n\tstd::vector<std::vector<Edge>> g(n+n);\n\t// ????????????\n\tREP(i, m) {\n\t\t--x[i]; --y[i];\n\t\tg[x[i]].emplace_back(y[i], t[i]);\n\t\tg[y[i]].emplace_back(x[i], t[i]);\n\t\tint xx = x[i] + n;\n\t\tint yy = y[i] + n;\n\t\tif (xx == n - 1 + n) xx = n - 1;\n\t\tif (yy == n - 1 + n) yy = n - 1;\n\t\tg[xx].emplace_back(yy, t[i]);\n\t\tg[yy].emplace_back(xx, t[i]);\n\t}\n\t//\n\tstd::map<PAIR, int> dist;\n\tstd::function<void(PAIR)> Dijkstra = [&](PAIR s) {\n\t\tusing P = std::pair<int, PAIR>;\n\t\tstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\t\tdist.clear();\n\t\tdist[s] = 0;\n\t\tpq.push(P(0, s));\n\t\twhile (!pq.empty()) {\n\t\t\tP p = pq.top(); pq.pop();\n\t\t\tPAIR v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < g[v.first].size(); ++i) {\n\t\t\t\tEdge e = g[v.first][i];\n\t\t\t\tint vne = (a*v.second + b) % c;\n\t\t\t\tPAIR to = PAIR(e.to, vne);\n\t\t\t\tif (dist.find(to) == dist.end()) dist[to] = INFLL;\n\t\t\t\tint cost = v.second*e.cost;\n\t\t\t\tif (dist[to] > dist[v] + cost) {\n\t\t\t\t\tdist[to] = dist[v] + cost;\n\t\t\t\t\tpq.push(P(dist[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tDijkstra(PAIR(0, v0));\n\tint ans = INFLL;\n\tREP(i, c) {\n\t\tif (dist.find(PAIR(n, i)) == dist.end()) continue;\n\t\tCHMIN(ans, dist[PAIR(n, i)]);\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(500,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<=now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define int long long\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,int> piii;\n    vector<vector<int>>d(n,vector<int>(100,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<int>>_d(n,vector<int>(101,LLONG_MAX/10));\n    rep(i,c+1)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,c+1)if(d[n-1][i]!=LLONG_MAX/10)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=LLONG_MAX/10;\n    rep(i,100)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define int long long\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,int> piii;\n    vector<vector<int>>d(n,vector<int>(50,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    bool visit=true;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n            if(next.first==n-1&&visit){\n                visit=false;\n                //cout<<d[next.first][_v]<<endl;\n                while(!que.empty())que.pop();\n                vector<vector<int>>_d(n,vector<int>(50,LLONG_MAX));\n                _d[n-1]=d[n-1];\n                d=_d;\n                que.push(piii(pii(d[n-1][_v],n-1),_v));\n                continue;\n            }\n        }\n    }\n    int ans=LLONG_MAX;\n    rep(i,c+1)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll dist[2][50][500][50];\n\nstruct S {\n\tint rev, sv, pos, v;\n\tll d;\n\n\tbool operator <(const S& x) const {\n\t\treturn d > x.d;\n\t}\n};\n\nll rec(S s) {\n\treturn dist[s.rev][s.sv][s.pos][s.v];\n}\n\nvoid save(S s) {\n\tdist[s.rev][s.sv][s.pos][s.v] = s.d;\n}\n\nstruct edge {\n\tint to;\n\tll t;\n};\n\nvector<edge> G[500];\n\nint n, m, a, b, c, v0;\n\nvoid dijkstra(int rev, int spos, int sv) {\n\tS s = { rev, sv, spos, sv, 0 };\n\tsave(s);\n\tpriority_queue<S> q;\n\tq.push(s);\n\twhile(q.size()) {\n\t\ts = q.top();\n\t\tq.pop();\n\t\tll d = rec(s);\n\t\tif(d < s.d) continue;\n\t\t//cout << d << endl;\n\t\tfor(auto e : G[s.pos]) {\n\t\t\tS ns = { rev, sv, e.to, (a * s.v + b) % c, d + e.t * s.v };\n\t\t\tif(rec(ns) > ns.d) {\n\t\t\t\tsave(ns);\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\n\tfor(int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tll t;\n\t\tcin >> x >> y >> t;\n\t\tx--, y--;\n\t\tG[x].push_back({ y, t });\n\t\tG[y].push_back({ x, t });\n\t}\n\tcin >> v0 >> a >> b >> c;\n\n\tconst ll INF = 1LL << 60;\n\tfill((ll*)begin(dist), (ll*)end(dist), INF);\n\n\tdijkstra(0, 0, v0);\n\tfor(int sv = 0; sv < 50; sv++) {\n\t\tdijkstra(1, n - 1, sv);\n\t}\n\n\tll ans = INF;\n\tfor(int v1 = 0; v1 < 50; v1++) {\n\t\tfor(int v2 = 0; v2 < 50; v2++) {\n\t\t\tS s1 = { 0, v0, n - 1,v1 };\n\t\t\tS s2 = { 1, v1, 0,v2 };\n\t\t\tans = min(ans, rec(s1) + rec(s2));\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(500,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n//#include <tuple>\n//#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m);\n\tVEC_ROW(int, m, x, y, t);\n\tVAR(int, v0, a, b, c);\n\n\tstruct Edge {\n\t\tint to, cost;\n\t\tEdge() {}\n\t\tEdge(int to, int cost) : to(to), cost(cost) {}\n\t\tbool operator<(const Edge& r) const {\n\t\t\treturn cost < r.cost;\n\t\t}\n\t};\n\tstd::vector<std::vector<Edge>> g(n);\n\t// ????????????\n\tREP(i, m) {\n\t\t--x[i]; --y[i];\n\t\tg[x[i]].emplace_back(y[i], t[i]);\n\t\tg[y[i]].emplace_back(x[i], t[i]);\n\t}\n\t//\n\tstd::map<PAIR, int> dist;\n\tstd::function<void(PAIR)> Dijkstra = [&](PAIR s) {\n\t\tusing P = std::pair<int, PAIR>;\n\t\tstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\t\tdist.clear();\n\t\tdist[s] = 0;\n\t\tpq.push(P(0, s));\n\t\twhile (!pq.empty()) {\n\t\t\tP p = pq.top(); pq.pop();\n\t\t\tPAIR v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < g[v.first].size(); ++i) {\n\t\t\t\tEdge e = g[v.first][i];\n\t\t\t\tint vne = (a*v.second + b) % c;\n\t\t\t\tPAIR to = PAIR(e.to, vne);\n\t\t\t\tif (dist.find(to) == dist.end()) dist[to] = INFLL;\n\t\t\t\tint cost = v.second*e.cost;\n\t\t\t\tif (dist[to] > dist[v] + cost) {\n\t\t\t\t\tdist[to] = dist[v] + cost;\n\t\t\t\t\tpq.push(P(dist[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tDijkstra(PAIR(0, v0));\n\tstd::vector<int> diN(c, INFLL);\n\tREP(i, c) {\n\t\tif (dist.find(PAIR(n - 1, i)) == dist.end()) continue;\n\t\tdiN[i] = dist[PAIR(n - 1, i)];\n\t}\n\tint ans = INFLL;\n\tREP(i, c) {\n\t\tif (diN[i] == INFLL) continue;\n\t\tDijkstra(PAIR(n - 1, i));\n\t\tREP(j, c) {\n\t\t\tif (dist.find(PAIR(0, j)) == dist.end()) continue;\n\t\t\tCHMIN(ans, diN[i] + dist[PAIR(0, j)]);\n\t\t}\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,v0;\nint a,b,c;\nvector<P> G[501];\nll dp[501][51][2];\n\nstruct data{\n\tint v,f;\n\tll c,sp;\n\tdata(){}\n\tdata(int vv,ll ss,ll cc,int ff){\n\t\tv=vv;\n\t\tsp=ss;\n\t\tc=cc;\n\t\tf=ff;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn c>d.c;\n\t}\n};\n\nll dijkstra(){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tque.push(data(1,v0,0,0));\n\tdp[1][v0][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.sp][q.f]<q.c)continue;\n\t\tif(q.v==n)q.f=1;\n\t\tif(q.v==1 && q.f==1)return q.c;\n\t\tfor(int i=0;i<G[q.v].size();i++){\n\t\t\tint nv=(a*q.sp+b)%c;\n\t\t\tif(dp[G[q.v][i].first][nv][q.f]>q.c+q.sp*G[q.v][i].second){\n\t\t\t\tdp[G[q.v][i].first][nv][q.f]=q.c+q.sp*G[q.v][i].second;\n\t\t\t\tque.push(data(G[q.v][i].first,nv,dp[G[q.v][i].first][nv][q.f],q.f));\n\t\t\t}\n\t\t\tif(dp[G[q.v][i].first][nv][q.f]==-1){\n\t\t\t\tdp[G[q.v][i].first][nv][q.f]=q.c+q.sp*G[q.v][i].second;\n\t\t\t\tque.push(data(G[q.v][i].first,nv,dp[G[q.v][i].first][nv][q.f],q.f));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\",&f,&t,&c);\n\t\tG[f].push_back(P(t,c));\n\t\tG[t].push_back(P(f,c));\n\t}\n\tscanf(\"%d\",&v0);\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tprintf(\"%lld\\n\",dijkstra());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\ntypedef long long ll;\nstruct edge{int to;ll cost;};\n\nvector<edge> G[60000];\nll dp[60000];\npriority_queue<pair<ll,int>> qu;//dp,v\n\nint a,b,c;\n\nint nextv(int v){\n\treturn (a*v+b)%c;\n}\n\nint main(void){\n\tint n,m,v0;\n\tcin>>n>>m;\n\tvector<int> x(m),y(m);\n\tvector<ll> t(m); \n\trep(i,m){\n\t\tcin>>x[i]>>y[i]>>t[i];\n\t\t--x[i];\n\t\t--y[i];\n\t}\n\tcin>>v0>>a>>b>>c;\n\trep(i,m)rep(v,c){\n\t\tG[x[i]*c+v].push_back({y[i]*c+nextv(v),t[i]*v});\n\t\tif(y[i]!=n-1)G[y[i]*c+v].push_back({x[i]*c+nextv(v),t[i]*v});\n\t\t\n\t\tif(y[i]!=n-1)G[((n-1)*2-x[i])*c+v].push_back({((n-1)*2-y[i])*c+nextv(v),t[i]*v});\n\t\tG[((n-1)*2-y[i])*c+v].push_back({((n-1)*2-x[i])*c+nextv(v),t[i]*v});\n\t}\n\trep(i,60000)dp[i]=LLONG_MAX;\n\tdp[v0]=0;\n\tqu.push({0,v0});\n\twhile(qu.size()){\n\t\tpair<ll,int> u = qu.top();\n\t\tqu.pop();\n\t\tif(dp[u.second] < u.first)continue;\n\t\tfor(auto e:G[u.second]){\n\t\t\tif(dp[e.to] > dp[u.second] + e.cost){\n\t\t\t\tdp[e.to] = dp[u.second] + e.cost;\n\t\t\t\tqu.push({dp[e.to],e.to});\n\t\t\t}\n\t\t}\n\t}\n\tll res = LLONG_MAX;\n\trep(i,c){\n\t\tres = min(res,dp[2*(n-1)*c+i]);\n\t}\n\tcout<<res<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 5001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n\n#define rep(i,n) for(ll i=0;i<(n);++i)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\nusing Graph = vector<vector<int>>;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\n#define int long long\n\nsigned main(){\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<lint>> g(n, vector<lint> (n,INF));\n\n    rep(i,m){\n        int x, y, t; cin >> x >> y >> t;\n        x--; y--;\n\n        g[x][y] = t;\n        g[y][x] = t;\n    }\n\n    //(距離, { {今いる頂点, 速さ} , 状態})\n\n    // using Q = pair<ll, pair<pair<ll, ll>, ll> >;\n    using Q = tuple<ll, ll, ll, ll>;\n    priority_queue<Q ,vector<Q>,greater<Q>> que;\n\n    ll dp[505][51][2];\n    rep(i,505)rep(j,51)rep(k,2) dp[i][j][k] = INF;\n\n    lint v0; cin >> v0;\n    int a, b, c; cin >> a >> b >> c;\n    // que.push (Q(0, {{0,v0}, 0}));\n    que.push(Q(0LL, 0LL, v0, 0LL));\n\n    dp[0][v0][0] = 0;\n    //Dijkstra\n    while(!que.empty()){\n        //まずはヒープの先頭の要素をとる\n        auto e = que.top(); que.pop();\n\n        //それぞれのパラメータを取得\n        // ll dist = e.first;\n        // ll v = e.second.first.first;\n        // ll velo = e.second.first.second;\n        // ll state = e.second.second;\n        \n        //auto [dist, v, velo, state] = e; // c++17\n        ll dist, v, velo, state;\n        tie(dist, v, velo, state) = e;\n\n\n        if (v == n - 1 and state == 0) {\n          if (dp[v][velo][1] > dist) {\n            dp[v][velo][1] = dist;\n            que.push(Q(dist, v, velo, 1));\n          }\n        }\n\n        // cout << \"dist = \" << dist << \" , node = \" << v + 1 << \" , velo = \" << velo << \" state = \" << state << endl;\n\n        //次に行く頂点の距離が最小じゃなかったら論の外\n        if(dist > dp[v][velo][state]) continue;\n\n\n        for(int j = 0; j < n; j++){\n\n            if(g[v][j] == INF) continue;\n\n            ll nvelo = (a * velo + b) % c;\n            ll cost = g[v][j] * velo;\n\n            if(dist + cost < dp[j][nvelo][state]){\n              dp[j][nvelo][state] = dist + cost;\n              que.push(Q(dist + cost, j, nvelo , state));\n\n            }\n        }\n    }\n\n    ll ans = INF;\n\n    rep(i,51){\n        ans = min(ans,dp[0][i][1]);\n    }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint v,a,b,c;\nstruct edge{\n  int time,to,cost;\n  edge(){}\n  edge(int time,int to,int cost):time(time),to(to),cost(cost){}\n};\nvector<edge> G[55][1111];\nint dp[55][1111];\nvoid add_edge(int time,int from,int to,int cost){\n  G[time][from].push_back(edge((time+1)%c,to,cost));\n  G[time][to].push_back(edge((time+1)%c,from,cost));\n}\nvoid add_edge2(int time,int from,int to,int cost){\n  G[time][from].push_back(edge(time,to,cost));\n  G[time][to].push_back(edge(time,from,cost));\n}\nstruct st{\n  int dist,time,pos;\n  st(){}\n  st(int dist,int time,int pos):dist(dist),time(time),pos(pos){}\n  bool operator<(const st& a) const{\n    return dist>a.dist;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int x[m],y[m],t[m];\n  for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i];\n  cin>>v>>a>>b>>c;\n  \n  for(int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    //cout<<i<<\":\"<<endl;\n    int ve=v;\n    for(int j=0;j<c;j++){\n      //cout<<ve<<endl;\n      add_edge(j,x[i],y[i],ve*t[i]);\n      add_edge(j,x[i]+n,y[i]+n,ve*t[i]);\n      ve=(a*ve+b)%c;\n    }\n  }\n  for(int j=0;j<c;j++) add_edge2(j,n-1,n+n-1,0);\n  \n  \n  memset(dp,-1,sizeof(dp));\n  \n  priority_queue<st> q;\n  q.push(st(0,0,0));\n  dp[0][0]=0;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    int t=p.time,u=p.pos,d=p.dist;\n    assert(0<=t&&t<c);\n    //cout<<t<<\" \"<<u<<\" \"<<d<<endl;\n    if(u==n){\n      cout<<d<<endl;\n      return 0;\n    }\n    if(dp[t][u]<d) continue;\n    assert(dp[t][u]==d);\n    for(int i=0;i<(int)G[t][u].size();i++){\n      int nt=G[t][u][i].time,nu=G[t][u][i].to,nc=G[t][u][i].cost;\n      if(dp[nt][nu]<0||d+nc<dp[nt][nu]){\n\tdp[nt][nu]=d+nc;\n\tq.push(st(d+nc,nt,nu));\n      }\n    }\n  }\n  assert(0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 501\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nll const INF = 1LL<<60;\nll n,m;\nvector<P> G[N];\nll v0,a,b,C;\nll v[5010];\n\nll nC;\nll dijkstra(ll start,ll goal,ll c){\n  ll D[500][1001];\n  for(ll i=0;i<500;i++)\n    for(ll j=0;j<1001;j++) D[i][j] = INF;\n\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(start,c)));\n  D[start][c] = 0;\n  ll res = INF;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    ll cost = t.first; \n    ll pos = t.second.first;\n    ll cnt = t.second.second;\n    if(D[pos][cnt]<cost) continue;\n    if(pos==goal&&goal == 0)return cost; \n    if(pos==goal&&goal == n-1){\n      res=min(res,cost+dijkstra(n-1,0,cnt));\n      continue;\n    }\n    for(ll i=0;i<(ll)G[pos].size();i++){\n      ll npos = G[pos][i].first;\n      ll ncost= cost+v[cnt]*G[pos][i].second;\n      ll ncnt = (cnt+1)%nC;\n      if(D[npos][ncnt]<=ncost)continue;\n      Q.push(PP(ncost,P(npos,ncnt)));\n      D[npos][ncnt] = ncost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(ll i=0,x,y,t;i<m;i++){\n    cin>>x>>y>>t;\n    x--,y--;\n    G[x].push_back(P(y,t));\n    G[y].push_back(P(x,t));\n  }\n  cin>>v[0]>>a>>b>>C;\n  set<ll> S;\n  S.insert(v[0]);\n  for(ll i=1;;i++){\n    v[i] = (a*v[i-1]+b)%C;\n    if(S.count(v[i]))break;\n    S.insert(v[i]);\n  }\n  nC=S.size();\n  cout<<dijkstra(0,n-1,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\ntypedef long long ll;\nstruct edge{int to;ll cost;};\n\nvector<edge> G[60000];\nll dp[60000];\npriority_queue<pair<ll,int>> qu;//dp,v\n\nint a,b,c;\n\nint nextv(int v){\n\treturn (a*v+b)%c;\n}\n\nint main(void){\n\tint n,m,v0;\n\tcin>>n>>m;\n\tvector<int> x(m),y(m);\n\tvector<ll> t(m); \n\trep(i,m){\n\t\tcin>>x[i]>>y[i]>>t[i];\n\t\t--x[i];\n\t\t--y[i];\n\t}\n\tcin>>v0>>a>>b>>c;\n\trep(i,m)rep(v,c){\n\t\tG[x[i]*c+v].push_back({y[i]*c+nextv(v),t[i]*v});\n\t\tG[y[i]*c+v].push_back({x[i]*c+nextv(v),t[i]*v});\n\t\tif(y[i]==n-1)continue;\n\t\tG[((n-1)*2-x[i])*c+v].push_back({((n-1)*2-y[i])*c+nextv(v),t[i]*v});\n\t\tG[((n-1)*2-y[i])*c+v].push_back({((n-1)*2-x[i])*c+nextv(v),t[i]*v});\n\t}\n\trep(i,60000)dp[i]=LLONG_MAX;\n\tdp[v0]=0;\n\tqu.push({0,v0});\n\twhile(qu.size()){\n\t\tpair<ll,int> u = qu.top();\n\t\tqu.pop();\n\t\tif(dp[u.second] < u.first)continue;\n\t\tfor(auto e:G[u.second]){\n\t\t\tif(dp[e.to] > dp[u.second] + e.cost){\n\t\t\t\tdp[e.to] = dp[u.second] + e.cost;\n\t\t\t\tqu.push({dp[e.to],e.to});\n\t\t\t}\n\t\t}\n\t}\n\tll res = LLONG_MAX;\n\trep(i,c){\n\t\tres = min(res,dp[2*(n-1)*c+i]);\n\t}\n\tcout<<res<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600123456789\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n\n  vector<long> x(m),y(m),t(m);\n  rep(i,m) cin>>x[i]>>y[i]>>t[i];\n  rep(i,m) x[i]--, y[i]--;\n\n  long v0,a,b,c;\n  cin>>v0>>a>>b>>c;\n\n  vector<vector<pair<long, int>>> vec(2*n*c, vector<pair<long,int>>());\n  rep(i,m) rep(j,c){\n    long cost = j*t[i];\n    long nj = (j*a+b)%c;\n    vec[x[i]*c+j].pb(mp(cost, y[i]*c+nj));\n    vec[y[i]*c+j].pb(mp(cost, x[i]*c+nj));\n\n    x[i] += n;\n    if(y[i]!=n-1) y[i]+=n;\n    vec[x[i]*c+j].pb(mp(cost, y[i]*c+nj));\n    vec[y[i]*c+j].pb(mp(cost, x[i]*c+nj));\n    x[i] -= n;\n    if(y[i]!=n-1) y[i]-=n;\n  }\n\n  vector<long> d(2*n*c, INF);\n  d[v0] = 0;\n  priority_queue<pair<long, int>, vector<pair<long,int>>, greater<pair<long,int>>> pq;\n  pq.push(mp(0,v0));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    long dd = p.fi, idx = p.se;\n    if(dd > d[idx]) continue;\n    for(auto pp : vec[idx]){\n      long nd = dd + pp.first;\n      int ni = pp.second;\n      if(nd < d[ni]){\n        pq.push(mp(nd, ni));\n        d[ni] = nd;\n      }\n    }\n  }\n\n  long ans = INF;\n  rep(i,c) ans = min(ans, d[n*c+i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1000000000000000\nusing namespace std;\nstruct edge{long long  to,cost;\n  edge(long long t,long long c):to(t),cost(c){}\n};\ntypedef pair<int ,int>P;\n\nint V;\nvector<edge>G[30000];\nlong long lx[5000];\nlong long ly[5000];\nlong long lt[5000];\nlong long int  a,b,c;\nlong long v;\nlong long co;\nvoid dk(long long ,long long*);\nint ch(long long ,long long);\nint main(){\n  V=30000;\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int x,y,t;\n    cin >> x >> y >> t;\n    lx[i]=x;\n    ly[i]=y;\n    lt[i]=t;\n  }\n  cin >> v;\n  cin >> a >> b >> c;\n  //dk\n  for(int i=0;i<m;i++){\n    for(int j=0;j<c;j++){\n      //cout << ch(lx[i],j)<<endl;\n      G[ch(lx[i],j)].push_back(edge(ch(ly[i],(a*j+b)%c),j*lt[i]));\n      G[ch(ly[i],j)].push_back(edge(ch(lx[i],(a*j+b)%c),j*lt[i]));      \n    }\n  }\n  //cout << 1<<endl;\n  long long ans=INF;\n  long long sd[V];\n  dk(ch(1,v),sd);\n  //cout << 2<<endl;\n  for(int i=0;i<c;i++){\n    long long SD[V];\n    // cout<<i<<endl;\n    dk(ch(n,i),SD);\n    //cout << i << endl;\n    for(int j=0;j<c;j++){\n      //cout << j << endl;\n      ans=min(ans,sd[ch(n,i)]+SD[ch(1,j)]);\n    }\n  }\n  //cout << 3<<endl;\n  \n  cout << ans << endl;\n  return 0;\n}\nvoid dk(long long s,long long* d){\n  priority_queue<P,vector<P>,greater<P> >que;\n  fill(d,d+V,INF);\n  d[s]=0;\n  que.push(P(0,s));\n\n  while(!que.empty()){\n    P p = que.top();que.pop();\n    int v = p.second;\n    if(d[v]<p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost){\n\td[e.to]=d[v]+e.cost;\n\tque.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\nint ch(long long A,long long B){\n  return A*c+B;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,long long> piii;\nvector<vector<long long>>d(501,vector<long long>(51,INF));\nsigned main(){\n    int n,m;  cin>>n>>m;\n    vector<vector<pii>>edge(500,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<=now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=INF){\n        vector<vector<long long>>_d(501,vector<long long>(51,INF));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rrep(i,n) for(int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for(int i=(a)-1;i>=b;--i)\n#define range(i,a,b,c) for(int i=a;\\\n                    c>0?i<b:\\\n                    i>b;\\\n                    i+=c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define int long long\n#ifdef _MSC_VER\nconst bool test = false;\n#else \nconst bool test = false;\n#endif\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real& r) { return (r > eps) - (r < -eps); }\nint sgn(const Real& a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep) {\n\tvector<string> v;\n\tstringstream ss(str);\n\tstring buffer;\n\twhile (getline(ss, buffer, sep)) {\n\t\tv.push_back(buffer);\n\t}\n\treturn v;\n}\n\ntemplate<class InputIterator>\nint sum(InputIterator begin, InputIterator end) {\n\treturn accumulate(begin, end, 0ll);\n}\n\nstring reverse_str(string s) {\n\treverse(all(s));\n\treturn s;\n}\n\nstruct Vertex {\n\tint id, weight, v, dist, flag;\n\tVertex(int id, int weight, int v, int dist, int flag) : \n\t\tid(id), weight(weight), v(v), dist(dist), flag(flag) {  }\n\tbool operator < (const Vertex& r) const { return dist < r.dist; }\n};\n\nusing Graph = vector<vector<Vertex>>;\n\nusing Weight = int;\n\nint n, m;\nint v0;\nint a, b, c;\nvector<Vertex> g[MAX];\nint d[505][55][2];\n\nint dijkstra(int start) {\n\trep(i, n) rep(j, c) rep(k, 2) {\n\t\td[i][j][k] = INFL;\n\t}\n\td[0][0][0] = 0;\n\tpriority_queue<Vertex> q;\n\tfor (q.push(Vertex(start, 0, v0, 0, false)); !q.empty(); ) {\n\t\tVertex p = q.top(); q.pop();\n\t\tfor (auto next_p : g[p.id]) {\n\t\t\tnext_p.v = (a * p.v + b) % c;\n\t\t\tnext_p.dist = p.dist + p.v * next_p.weight;\n\t\t\tnext_p.flag = (p.flag || next_p.id == n - 1);\n\t\t\tif (d[next_p.id][next_p.v][next_p.flag] > next_p.dist) {\n\t\t\t\td[next_p.id][next_p.v][next_p.flag] = next_p.dist;\n\t\t\t\tq.push(next_p);\n\t\t\t}\n\t\t}\n\t}\n\tint min_cost = INFL;\n\trep(j, c) chmin(min_cost, d[0][j][1]);\n\treturn min_cost;\n}\n\nvoid solve() {\n\tcin >> n >> m;\n\trep(i, m) {\n\t\tint x, y, t;\n\t\tcin >> x >> y >> t;\n\t\tx--;\n\t\ty--;\n\t\tg[x].push_back(Vertex(y, t, 0, 0, false));\n\t\tg[y].push_back(Vertex(x, t, 0, 0, false));\n\t}\n\tcin >> v0;\n\tcin >> a >> b >> c;\n\tcout << dijkstra(0) << endl;\n}\n\nsigned main() {\n\tsrand(time(NULL));\n\tint T = (int)1e15;\n\tsolve();\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\tchar s[MAX];\n\t\tif (scanf(\"%s\", s) == EOF) break;\n\t\tint n = strlen(s);\n\t\tfor (int i = n - 1; i > -1; i--) {\n\t\t\tungetc(s[i], stdin);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <map>\n#include <math.h>\n#include <string.h>\n#include <iomanip>\n#include <numeric>\n#include <cstdlib>\n#include <cstdint>\n#include <cmath>\n#include <functional>\n#include <limits>\n#include <cassert>\n#include <bitset>\n\nusing namespace std;\n\n/* template */\n\nusing ll = long long;\n\nvoid debug_out() { std::cout << std::endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cout << H << \" \";\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cout << \"debug: \"; debug_out(__VA_ARGS__)\n#else\n#define debug(...) \n#endif\n\n#define rep(i, a, n) for (int i = (int)(a); i < (int)(n); i++)\n#define rrep(i, a, n) for (int i = ((int)(n-1)); i >= (int)(a); i--)\n#define Rep(i, a, n) for (long long i = (long long)(a); i< (long long)(n); i++)\n#define RRep(i, a, n) for (long long i = ((long long)(n-1ll)); i>=(long long)(a); i--)\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n\n/* xxpoxx's definition */\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(a) (a).begin(), (a).end()\nusing vl = vector<ll>;\nstring abc = \"abcdefghijklmnopqrstuvwxyz\";\nstring ABC = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (std::size_t i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n\nstruct Edge{\n    int to;\n    ll weight;\n    Edge(int t, ll w) : to(t), weight(w){ }\n};\n\nstruct edge{\n    int from;\n    int to;\n    ll weight;\n    edge(int f,int t,ll w) : from(f), to(t), weight(w){ }\n};\n\n\nusing Graph = vector<vector<Edge>>;\nusing graph = vector<vector<int>>;\nusing edges = vector<edge>;\n\ntemplate <class T>\ninline bool chmin(T &a, T b){\n    if (a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T>\ninline bool chmax(T &a, T b){\n    if (a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T>\nT lcm(T a, T b){\n    return (a*b)/gcd(a,b);\n}\n\nconstexpr ll LNF = 1LL<<60;\n\nconstexpr int INF = 1e9+7;\n\nconst double PI=3.14159265358979323846;\n\n\nvector<int> dx = {-1,0,1,0,-1,1,-1,1};\nvector<int> dy = {0,-1,0,1,1,-1,-1,1};\n\n/* template */\n\nvector<ll> dijkstra(int s,int n,Graph g){\n    typedef pair<ll,ll> P;\n    vector<ll> d(n,LNF);\n    priority_queue<P,vector<P>,greater<P>> que;\n    d[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v]<p.first) continue;\n        rep(i,0,g[v].size()){\n            Edge e = g[v][i];\n            if(d[e.to]>d[v]+e.weight){\n                d[e.to] = d[v] + e.weight;\n                que.push(P(d[e.to],e.to));\n            }\n        }\n    }\n    return d;\n}\n\nint main(){\n\n    int n,m; cin >> n >> m;\n    vector<vector<ll>> p(m,vector<ll>(3));\n    rep(i,0,m){\n        cin >> p[i][0] >> p[i][1] >> p[i][2];\n        p[i][0]--;\n        p[i][1]--;\n    }\n    int v0; cin >> v0;\n    int a,b,c; cin >> a >> b >> c;\n    Graph g(n*c);\n    rep(i,0,m){\n        int x = p[i][0];\n        int y = p[i][1];\n        ll t = p[i][2];\n        rep(v,0,c){\n            g[x*c+v].emplace_back(Edge(y*c+(a*v+b)%c,v*t));\n            g[y*c+v].emplace_back(Edge(x*c+(a*v+b)%c,v*t));\n        }\n    }\n    vector<ll> d = dijkstra(v0,n*c,g);\n    ll ans = LNF;\n    rep(i,0,c){\n        vector<ll> e = dijkstra((n-1)*c+i,n*c,g);\n        rep(j,0,c){\n            chmin(ans,d[(n-1)*c+i]+e[j]);\n        }\n    }\n    cout << ans << endl;\n    /*\n    ll N,S,P,C;\n    cin >>N;\n    vector<ll> r(N),score(N),Sr(N),Pr(N),Cr(N);\n    for(ll i=0;i<N;i++) cin >>r[i];\n    vector<pair<ll,ll>> s(N), p(N), c(N);\n    for(ll i=0;i<N;i++){\n        ll a1,a2,a3;\n        cin >>a1>>a2>>a3;\n        s[i]=make_pair(a1,i);\n        p[i]=make_pair(a2,i);\n        c[i]=make_pair(a3,i);\n    }\n    S=s[0].first; P=p[0].first; C=c[0].first;\n    sort(s.begin(),s.end());\n    sort(p.begin(),p.end());\n    sort(c.begin(),c.end());\n    reverse(s.begin(),s.end());\n    reverse(p.begin(),p.end());\n    reverse(c.begin(),c.end());\n    //スマイルの初期点計算\n    ll douritsu=0;\n    ll rank=0;\n    for(ll i=0;i<N;i++){\n        score[s[i].second]+=r[rank];\n        Sr[s[i].second]=rank;\n        if(i!=N-1){\n            if(s[i].first==s[i+1].first) douritsu++;\n            else{\n                rank+=douritsu+1;\n                douritsu=0;\n            }\n        }\n    }\n    //ぴゅあの初期点計算\n    douritsu=0;\n    rank=0;\n    for(ll i=0;i<N;i++){\n        score[p[i].second]+=r[rank];\n        Pr[p[i].second]=rank;\n        if(i!=N-1){\n            if(p[i].first==p[i+1].first) {\n                douritsu++;\n            }else{\n                rank+=douritsu+1;\n                douritsu=0;\n            }\n        }\n    }\n    //くーるの初期点計算\n    douritsu=0;\n    rank=0;\n    for(ll i=0;i<N;i++){\n        score[c[i].second]+=r[rank];\n        Cr[c[i].second]=rank;\n        if(i!=N-1){\n            if(c[i].first==c[i+1].first) {\n                douritsu++;\n            }else{\n                rank+=douritsu+1;\n                douritsu=0;\n            }\n        }\n    }\n    vector<ll> score2 = score;\n    ll ans=LNF;\n    //for(ll j=1; j<N; j++) cout << score[j] << endl;\n    // すまいるを値変えるとき\n    for(ll i=S+1;i<=100;i++){\n        for(ll j=0;j<N;j++){\n            if(s[j].second==0) continue;\n            if(s[j].first>i) continue;\n            else if(s[j].first==i) score2[0]+=r[j]-r[Sr[0]];\n            else if(s[j].first>=s[0].first) score2[j]+=r[Sr[j]]-r[Sr[j]+1];\n        }\n        ll rank=N;\n        for(ll j=1; j<N; j++) {\n            if(score2[j]<=score2[0]) rank--;\n        }\n        cout << i << \" \" << rank << endl;\n        if(rank<=8) ans=min(ans,i-S);\n    }\n    cout << ans;\n    */\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\ninline size_t hashCombine(size_t seed, const T& v) {\n    return seed ^ (hash<T>()(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2));\n}\n\nnamespace std {\ntemplate <typename T, typename S>\nclass hash<pair<T, S>> {\n public:\n    size_t operator()(const pair<T, S>& p) const {\n        size_t seed = 0;\n        seed = hashCombine(seed, p.first);\n        seed = hashCombine(seed, p.second);\n        return seed;\n    }\n};\ntemplate <typename... Ts>\nclass hash<tuple<Ts...>> {\n public:\n    size_t operator()(const tuple<Ts...>& t) const { return impl<0>(t); }\n\n private:\n    template <size_t Index>\n    typename enable_if<Index == tuple_size<tuple<Ts...>>::value, size_t>::type\n    impl(const tuple<Ts...>&) const {\n        return 0;\n    }\n    template <size_t Index>\n    typename enable_if<Index != tuple_size<tuple<Ts...>>::value, size_t>::type\n    impl(const tuple<Ts...>& t) const {\n        return hashCombine(impl<Index + 1>(t), get<Index>(t));\n    }\n};\n}\n\nint n, m;\nint a, b, c;\nint v0;\nstruct Edge {\n    int to, t;\n    Edge(int to = 0, int t = 0) : to(to), t(t) {}\n};\nint update(int v) { return (a * v + b) % c; }\nvector<Edge> G[502];\nusing State = tuple<int, int, int>;\nunordered_map<State, ll> dp;\npriority_queue<pair<ll, State>> que;\n\nint main() {\n    cin >> n >> m;\n    rep(i, m) {\n        int x, y, t;\n        cin >> x >> y >> t;\n        G[x].push_back(Edge(y, t));\n        G[y].push_back(Edge(x, t));\n    }\n    cin >> v0;\n    cin >> a >> b >> c;\n    auto initState = State(1, v0, 0);\n    dp[initState] = 0;\n    que.push(make_pair(0, initState));\n\n    while (que.size()) {\n        auto p = que.top();\n        que.pop();\n        auto nowCost = p.first;\n        auto nowState = p.second;\n        auto v = get<0>(nowState);\n        auto v1 = get<1>(nowState);\n        auto s = get<2>(nowState);\n        auto v2 = update(v1);\n        // printf(\"%d %d %d %d\\n\", v, v1, s, dp[nowState]);\n\n        if (s == 0 && v == n) s = 1;\n        rep(i, G[v].size()) {\n            auto e = G[v][i];\n            ll cost = 1LL * e.t * v1;\n            auto nextState = State(e.to, v2, s);\n            if (dp.count(nextState) == 0 ||\n                dp[nowState] + cost < dp[nextState]) {\n                dp[nextState] = dp[nowState] + cost;\n                que.push(make_pair(-dp[nextState], nextState));\n            }\n        }\n    }\n\n    ll ans = INF;\n    rep(i, 50) {\n        auto s = State(1, i, 1);\n        if (dp.count(s)) ans = min(ans, dp[s]);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n \ntypedef tuple< int64, int, int, bool > Pi;\n \n#define rep(i, n) for(int i = 0; i < n; i++)\n \nstruct edge\n{\n  int to, cost;\n};\n \nint64 v[500][51][2];\nint N, M, V, A, B, C;\nvector< edge > g[500];\n \nint main()\n{\n \n \n  cin >> N >> M;\n  rep(i, M) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    g[x].push_back((edge) {y, t});\n    g[y].push_back((edge) {x, t});\n  }\n  cin >> V;\n  cin >> A >> B >> C;\n \n  fill_n(**v, 500 * 51 * 2, INF);\n  v[0][V][0] = 0;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, 0, V, false);\n \n  while(!que.empty()) {\n    int64 cost;\n    int now, vv;\n    bool flag;\n    tie(cost, now, vv, flag) = que.top();\n    que.pop();\n \n    if(flag && now == 0) {\n      cout << cost << endl;\n      return (0);\n    }\n \n    for(auto &e : g[now]) {\n \n      int64 nxtcost = cost + 1LL * vv * e.cost;\n      int nxtvv = (A * vv + B) % C;\n      bool nxtfg = flag | (e.to == N - 1);\n \n      if(nxtcost < v[e.to][nxtvv][nxtfg]) {\n        v[e.to][nxtvv][nxtfg] = nxtcost;\n        que.emplace(nxtcost, e.to, nxtvv, nxtfg);\n      }\n \n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N, M;\nint X[5010], Y[5010];\nll T[5010];\nint v0, a, b, c;\n\ntypedef tuple<ll, int, int> tup;\nconst int MAX_N = 510;\nvector<pair<int, ll> > G[MAX_N];\nvector<vector<ll>> dijkstra(int start, int fv){\n\t//dist[i][j] := start->i?????§????§??????§, ?????????j????????????????§?????????¢????????????????°????\n\tvector<vector<ll>> dist(MAX_N, vector<ll>(55, INFF));\n\tdist[start][fv] = 0;\n\tpriority_queue<tup, vector<tup >, greater<tup > >  que;\n\t\n\tque.push(make_tuple(0, fv, start));\n\twhile(!que.empty()){\n\t\tll cost; int v, i;\n\t\ttie(cost, v, i) = que.top(); que.pop();\n\t\t// printf(\"%lld %d %d\\n\", cost, v, i);\n\t\tif(dist[i][v] < cost) continue;\n\t\tint nv = (a * v + b);\n\t\tnv %= c;\n\t\t// printf(\"%lld %d %d nv %d\\n\", cost, v, i, nv);\n\t\tfor (auto tmp : G[i]){\n\t\t\tint j = tmp.first; ll time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[j][nv] > dist[i][v] + time * v){//i->j\n\t\t\t\tdist[j][nv] = dist[i][v] + time * v;\n\t\t\t\tque.push(make_tuple(dist[j][nv], nv, j));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nint main(void){\n\tscanf(\"%d %d\", &N, &M);\n\trep(i, M) scanf(\"%d %d %lld\", &X[i], &Y[i], &T[i]);\n\trep(i, M) X[i]--, Y[i]--;\n\trep(i, M){\n\t\tG[X[i]].pb(mp(Y[i], T[i]));\n\t\tG[Y[i]].pb(mp(X[i], T[i]));\n\t}\n\tscanf(\"%d\", &v0);\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\tauto dis = dijkstra(0,v0);\n\tll ans = INFF;\n\trep(j, 52){\n\t\tif(dis[N - 1][j] == INFF) continue;\n\t\t// printf(\"%lld\\n\", dis[N - 1][j]);\n\t\tauto tm = dijkstra(N - 1, j);\n\t\trep(k, 52) chmin(ans, dis[N - 1][j] + tm[0][k]);\n\t\t// printf(\"ans %lld\\n\", ans);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 100000010010000;\n\nstruct node{\n    long long cost;\n    long long v;\n    bool isarrive;\n    int n;\n};\n\nbool operator<(const node& a, const node& b) { return a.cost < b.cost; }\nbool operator>(const node& a, const node& b) { return a.cost > b.cost; }\n\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<vector<pair<int, int> > > adjlist(n);\n    \n    for(int i = 0; i < m; i++){\n        int x, y, t; cin >> x >> y >> t;\n        x--;\n        y--;\n        adjlist[x].push_back({t, y});\n        adjlist[y].push_back({t, x});\n\n    }\n\n    long long v; cin >> v;\n    long long a, b, c; cin >> a >> b >> c;\n    vector<vector<vector<long long> > > result(c, vector<vector<long long> > (2, vector<long long> (n, INF)));\n    priority_queue<node> wait;\n    node _node;\n    _node.n = 0;\n    _node.cost = 0;\n    _node.isarrive = 0;\n    _node.v = v;\n    result[v][0][0] = 0;\n    wait.push(_node);\n\n    while(!wait.empty()){\n\n        int now_n = wait.top().n;\n        long long now_cost = -wait.top().cost;\n        long long now_v = wait.top().v;\n        bool now_isarrive = wait.top().isarrive;        \n        wait.pop();\n        //cout << now_n << \" \" << now_cost << \" \" << now_v << \" \" << now_isarrive << endl;\n        if(result[now_v][now_isarrive][now_n] < now_cost) continue;\n    \n    \n        //隣接している頂点をすべて舐める\n        for(int i = 0; i < adjlist[now_n].size(); i++){\n            int next_n = adjlist[now_n][i].second;\n            long long next_v = (a * now_v + b) % c;            \n            long long next_cost = now_cost + adjlist[now_n][i].first * now_v;\n            bool next_isarrive = (now_isarrive || (next_n == n - 1));\n\n            if(result[next_v][next_isarrive][next_n] > next_cost){\n                result[next_v][next_isarrive][next_n] = next_cost;\n                node next_node;\n                next_node.cost = -next_cost;\n                next_node.n = next_n;\n                next_node.v = next_v;\n                next_node.isarrive = next_isarrive;\n                wait.push(next_node);\n            } \n        }\n    }\n\n    long long ans = INF;\n    for(int i = 0; i < c; i++){\n        ans = min(ans, result[i][1][0]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P>PP;\nint n,m,x,y,t,d[51][501][2],v0,a,b,c;\nvector<P>G[501];\nint dijkstra(){\n    priority_queue<PP,vector<PP>,greater<PP> >q;\n    r(i,51)r(j,501)r(k,2)d[i][j][k]=1e18;\n    q.push(PP(P(0,v0),P(0,0)));\n    while(!q.empty()){\n        PP p=q.top();q.pop();\n        if(d[p.f.s][p.s.f][p.s.s]<p.f.f)continue;\n        if(!p.s.f&&p.s.s)return p.f.f;\n        if(p.s.f==n-1&&!p.s.s){\n            q.push(PP(P(p.f.f,p.f.s),P(p.s.f,1)));\n            d[p.f.s][p.s.f][p.s.s]=p.f.f;\n        }\n        r(i,G[p.s.f].size()){\n            int v=(a*p.f.s+b)%c;\n            int cost=p.f.f+p.f.s*G[p.f.s][i].s;\n            int to=G[p.f.s][i].f;\n            if(d[v][to][p.s.s]>cost){\n                d[v][to][p.s.s]=cost;\n                q.push(PP(P(cost,v),P(to,p.s.s)));\n            }\n        }\n    }\n}\nmain(){\n    cin>>n>>m;\n    r(i,m){\n        cin>>x>>y>>t;\n        x--;y--;\n        G[x].push_back(P(y,t));\n        G[y].push_back(P(x,t));\n    }\n    cin>>v0>>a>>b>>c;\n    cout<<dijkstra()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n\n\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<long,long> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,long long> piii;\n    vector<vector<long long>>d(n,vector<long long>(51,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<long long>>_d(n,vector<long long>(51,LLONG_MAX/10));\n    rep(i,c+1)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,c+1)if(d[n-1][i]!=LLONG_MAX/10)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    long long ans=LLONG_MAX/10;\n    rep(i,51)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600123456789\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n\n  vector<long> x(m),y(m),t(m);\n  rep(i,m) cin>>x[i]>>y[i]>>t[i];\n  rep(i,m) x[i]--, y[i]--;\n\n  long v0,a,b,c;\n  cin>>v0>>a>>b>>c;\n\n  vector<vector<pair<long, int>>> vec(2*n*c, vector<pair<long,int>>());\n  rep(i,m) rep(j,c){\n    long cost = j*t[i];\n    long nj = (j*a+b)%c;\n    vec[x[i]*c+j].pb(mp(cost, y[i]*c+nj));\n    vec[y[i]*c+j].pb(mp(cost, x[i]*c+nj));\n\n    x[i] += n;\n    if(y[i]!=n-1) y[i]+=n;\n    vec[x[i]*c+j].pb(mp(cost, y[i]*c+nj));\n    vec[y[i]*c+j].pb(mp(cost, x[i]*c+nj));\n    x[i] -= n;\n    if(y[i]!=n-1) y[i]-=n;\n  }\n\n  vector<long> d(2*n*c, INF);\n  d[v0] = 0;\n  priority_queue<pair<long, int>, vector<pair<long,int>>, greater<pair<long,int>>> pq;\n  pq.push(mp(0,v0));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    long dd = p.fi, idx = p.se;\n    if(dd > d[idx]) continue;\n    for(auto pp : vec[idx]){\n      long nd = dd + pp.first;\n      int ni = pp.second;\n      if(nd < d[ni]){\n        pq.push(mp(nd, ni));\n        d[ni] = nd;\n      }\n    }\n  }\n\n  long ans = INF;\n  rep(i,c) ans = min(ans, d[n*c+i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(n);++i)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\nusing Graph = vector<vector<int>>;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nconst ll INF = 1002003004005006007;\n\nint main(){\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<ll>> g(n, vector<ll> (n,INF));\n\n    rep(i,m){\n        int x, y, t; cin >> x >> y >> t;\n        x--; y--;\n\n        g[x][y] = t;\n        g[y][x] = t;\n    }\n\n    //{距離, 今いる頂点, 速さ, 状態}\n    using Q = tuple<ll, ll, ll, ll>;\n    priority_queue<Q ,vector<Q>,greater<Q>> que;\n\n    ll dp[505][55][2];\n    rep(i,505)rep(j,55)rep(k,2) dp[i][j][k] = INF;\n\n    ll v0; cin >> v0;\n    int a, b, c; cin >> a >> b >> c;\n    \n    //初期push\n    que.push(Q(0LL, 0LL, v0, 0LL));\n\n    dp[0][v0][0] = 0;\n    //Dijkstra\n    while(!que.empty()){\n\n        //まずはヒープの先頭の要素をとる\n        auto e = que.top(); que.pop();\n\n        //それぞれのパラメータを取得\n\n        //auto [dist, v, velo, state] = e; // c++17\n        ll dist, v, velo, state;\n        tie(dist, v, velo, state) = e;\n\n        //状態の遷移\n        if (v == n - 1 and state == 0) {\n            if (dp[v][velo][1] > dist) {\n                dp[v][velo][1] = dist;\n                que.push(Q(dist, v, velo, 1));\n            }\n        }\n\n        // cout << \"dist = \" << dist << \" , node = \" << v + 1 << \" , velo = \" << velo << \" state = \" << state << endl;\n\n        //次に行く頂点の距離が最小じゃなかったら論の外\n        if(dist > dp[v][velo][state]) continue;\n\n\n        for(int j = 0; j < n; j++){\n\n            if(g[v][j] == INF) continue;\n\n            //costをちゃんと計算しておく\n            ll nvelo = (a * velo + b) % c;\n            ll cost = g[v][j] * velo;\n\n            //遷移\n            if(dist + cost < dp[j][nvelo][state]){\n                dp[j][nvelo][state] = dist + cost;\n                que.push(Q(dist + cost, j, nvelo , state));\n            }\n\n        }\n    }\n\n    ll ans = INF;\n\n    rep(i,51){\n      ans = min(ans,dp[0][i][1]);\n    }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N,M;\nint A, B, C;\nstruct edge {\n  int to;\n  ll t;\n  edge(){\n\n  }\n  edge(int to,ll t):to(to),t(t){}\n};\nstruct state{\n  int id,v,f;\n  ll c;\n  state(){\n\n  }\n  state(int id,int v,int f,ll c):id(id),v(v),f(f),c(c){}\n  bool operator<(const state &st) const {\n    return c > st.c;\n  }\n};\n\nll H[555][55][2];\nconst ll INF = (ll)(1<<29)*(ll)(1<<29);\nvector<edge> G[555];\n\nll dijk(int v0){\n  priority_queue<state> q;\n  fill( H[0][0], H[553][51], INF );\n  q.push( state(0,v0,0,0) );\n  H[0][v0][0] = 0LL;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( H[p.id][p.v][p.f] < p.c ) continue;\n    for( edge e : G[p.id] ){\n      int nv = (A * p.v + B)%C;\n\n      int nf = p.f; if( e.to == N-1 ) nf = 1;\n      ll nc = (ll)p.v * e.t + p.c;\n      if( H[e.to][nv][nf] > nc ){\n        H[e.to][nv][nf] = nc;\n        q.push( state( e.to, nv, nf, nc ) );\n      }\n    }\n  }\n  ll res = INF;\n  for(int i=0;i<=C;i++)\n    res = min( res, H[0][i][1] );\n  return res;\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int x,y; ll t;\n    cin >> x >> y >> t; --x; --y;\n    G[x].emplace_back( y, t );\n    G[y].emplace_back( x, t );\n  }\n  int v0; cin >> v0;\n  cin >> A >> B >> C;\n  cout << dijk(v0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define int long long\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,int> piii;\n    vector<vector<int>>d(n,vector<int>(100,LLONG_MAX));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    bool visit=true;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n            if(next.first==n-1&&visit){\n                visit=false;\n                //cout<<d[next.first][_v]<<endl;\n                while(!que.empty())que.pop();\n                vector<vector<int>>_d(n,vector<int>(100,LLONG_MAX));\n                _d[n-1]=d[n-1];\n                d=_d;\n                que.push(piii(pii(d[n-1][_v],n-1),_v));\n                continue;\n            }\n        }\n    }\n    int ans=LLONG_MAX;\n    rep(i,100)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1LL<<59)\n \nstruct eg{\n    int a,b,c;\n};\n \n#define int ll\n \n#define MAX_V 500\n#define MAX_B 50\n \nstruct edge{pii to;int cost;};\n \nvoid dijkstra(pii s, vector<vector<int>> &d, vector<edge> G[MAX_V][MAX_B]){\n    priority_queue< pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>> > que;\n    rep(i,MAX_V)rep(j,MAX_B)d[i][j]=INF;\n    d[s.first][s.second]=0;\n    que.push(make_pair(0,s));\n     \n    while(que.size()){\n        pair<int,pii> p=que.top();\n        que.pop();\n         \n        int v=p.second.first;\n        int b=p.second.second;\n        if(d[v][b]<p.first)continue;\n         \n        rep(i,G[v][b].size()){\n            edge e=G[v][b][i];\n            if(d[e.to.first][e.to.second]>d[v][b]+e.cost){\n                d[e.to.first][e.to.second]=d[v][b]+e.cost;\n                que.push(make_pair(d[e.to.first][e.to.second],e.to));\n            }\n        }\n    }\n}\n \n \nsigned main(){\n    int v,e;\n    cin>>v>>e;\n    vector<pii> gr[MAX_V];\n    rep(i,e){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--,b--;\n        gr[a].pb(pii(b,c));\n        gr[b].pb(pii(a,c));\n    }\n     \n    int v0;\n    cin>>v0;\n    int a,b,c;\n    cin>>a>>b>>c;\n     \n    vector<edge> G[MAX_V][MAX_B];\n    rep(i,v){\n        rep(vid,c){\n            int vi = (a*vid+b)%c;\n            for(auto e:gr[i]){\n                G[i][vid].pb(edge{pii(e.first,vi),e.second*vid});\n            }\n        }\n    }\n     \n    vector<vector<int>> d1(MAX_V,vector<int>(MAX_B));\n    dijkstra(pii(0,v0),d1, G);\n \n    int ans = INF;\n    rep(i,c){\n        vector<vector<int>> d2(MAX_V,vector<int>(MAX_B));\n        dijkstra(pii(v-1,i),d2,G);\n        int t = INF;\n        rep(j,c){\n            t = min(t,d1[v-1][i] + d2[0][j]);\n        }\n        ans = min(ans, t);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e15;\n\nstruct Edge{\n  LL to, cost;\n\n  Edge(LL t, LL c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\n\nvoid Dijkstra(const Graph& edges, vector<LL>& d, int s){\n  using Type = PLL;\n  priority_queue<Type, vector<Type>, greater<Type> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tType pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(unsigned int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint idx(int u, int v, int flag){\n  return (u * 50 + v) * 2 + flag;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n\n  VL xs(M), ys(M), ts(M);\n  REP(i,M){\n\tcin >> xs[i] >> ys[i] >> ts[i];\n\t--xs[i];\n\t--ys[i];\n  }\n\n  LL V, A, B, C;\n  cin >> V >> A >> B >> C;\n\t\n  Graph G(500*50*2);\n  REP(i,M){\n\tREP(k,C){\n\t  G[idx(xs[i], k, 0)].EB(idx(ys[i], (A*k+B)%C, 0), k*ts[i]);\n\t  G[idx(ys[i], k, 0)].EB(idx(xs[i], (A*k+B)%C, 0), k*ts[i]);\n\t  G[idx(xs[i], k, 1)].EB(idx(ys[i], (A*k+B)%C, 1), k*ts[i]);\n\t  G[idx(ys[i], k, 1)].EB(idx(xs[i], (A*k+B)%C, 1), k*ts[i]);\n\t}\n  }\n  REP(k,C)\n\tG[idx(N-1, k, 0)].EB(idx(N-1, k, 1), 0);\n\n  VL d(500*50*2);\n  Dijkstra(G, d, idx(0, V, 0));\n\n  LL ans = INF;\n  REP(k,C)\n\tmini(ans, d[idx(0, k, 1)]);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n\n\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<long long,long long> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,long long> piii;\n    vector<vector<long long>>d(n,vector<long long>(51,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<long long>>_d(n,vector<long long>(51,LLONG_MAX/10));\n    rep(i,51)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,51)if(d[n-1][i]!=LLONG_MAX/10)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    long long ans=LLONG_MAX/10;\n    rep(i,51)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\nint INF=MAX*MAX;\nsigned main(){\n    int n,m;  cin>>n>>m;\n    typedef pair<int,int> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,long long> piii;\n    vector<vector<long long>>d(n,vector<long long>(51,LLONG_MAX/10));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    int ans=INF;\n    rep(i,51)if(d[n-1][i]!=LLONG_MAX/10){\n        vector<vector<long long>>_d(n,vector<long long>(51,LLONG_MAX/10));\n        _d[n-1][i]=d[n-1][i];\n        que.push(piii(pii(d[n-1][i],n-1),i));\n        while(!que.empty()){\n            piii now=que.top(); que.pop();\n            int v=now.second;\n            int _v=(v*a+b)%c;\n            if(_d[now.first.second][v]<now.first.first)continue;\n            for(int i=0; i<edge[now.first.second].size();i++){\n                pii next=edge[now.first.second][i];\n                if(_d[next.first][_v]<now.first.first+next.second*v)continue;\n                _d[next.first][_v]=now.first.first+next.second*v;\n                que.push(piii(pii(_d[next.first][_v],next.first),_v));\n            }\n        }\n        rep(i,51)ans=min(ans,_d[0][i]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\n#define MAX 1e9\n\nsigned main(){\n    int INF=MAX*MAX;\n    int n,m;  cin>>n>>m;\n    typedef pair<long,long> pii;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,m){\n        int a,b,c; cin>>a>>b>>c;\n        --a,--b;\n        edge[a].push_back(pii(b,c));\n        edge[b].push_back(pii(a,c));\n    }\n    int v0,a,b,c; cin>>v0>>a>>b>>c;\n    typedef pair<pii,long long> piii;\n    vector<vector<long long>>d(n,vector<long long>(51,INF));\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    d[0][v0]=0;\n    que.push(piii(pii(0,0),v0));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    vector<vector<long long>>_d(n,vector<long long>(51,INF));\n    rep(i,51)_d[n-1][i]=d[n-1][i];\n    d=_d;\n    rep(i,51)if(d[n-1][i]!=INF)que.push(piii(pii(d[n-1][i],n-1),i));\n    while(!que.empty()){\n        piii now=que.top(); que.pop();\n        int v=now.second;\n        int _v=(v*a+b)%c;\n        if(d[now.first.second][v]<now.first.first)continue;\n        for(int i=0; i<edge[now.first.second].size();i++){\n            pii next=edge[now.first.second][i];\n            if(d[next.first][_v]<now.first.first+next.second*v)continue;\n            d[next.first][_v]=now.first.first+next.second*v;\n            que.push(piii(pii(d[next.first][_v],next.first),_v));\n        }\n    }\n    long long ans=INF;\n    rep(i,51)ans=min(ans,d[0][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\n\nstruct Edge { int dst; ll w; };\nstruct Data {\n  int cur,v; ll w;\n  bool operator < ( const Data &e ) const {\n    if( w != e.w ) return w > e.w;\n    if( v != e.v ) return v > e.v;\n    return cur > e.cur;\n  }\n};\n\n#define MAX_V 510\n\nint V,E;\nll v0,a,b,c;\nll mini[MAX_V][51][2];\nvector<Edge> G[MAX_V];\n\nll cost1;\nll adhoc = LLINF;\nvoid dijkstra(int sp,int v0) {\n  rep(i,V) rep(j,c) mini[i][j][sp==(V-1)] = LLINF;\n  priority_queue<Data> Q;\n  Q.push((Data){sp,v0,0});\n  mini[sp][v0][sp==(V-1)] = 0;\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      int nv = ( a * data.v + b ) % c;\n      ll nw = data.w + e.w * data.v;\n      if( adhoc != LLINF && cost1 + nw >= adhoc ) continue;\n      if( nw < mini[e.dst][nv][sp==(V-1)] ) {\n        mini[e.dst][nv][sp==(V-1)] = nw;\n        Q.push((Data){e.dst,nv,nw});\n      }\n    }\n  }\n}\n\nvoid compute() {\n  dijkstra(0,v0);\n  ll ans = LLINF;\n  rep(i,c) {\n    if( mini[V-1][i][0] != LLINF ) {\n      ll cost = mini[V-1][i][0];\n      if( cost >= ans ) break;\n      cost1 = cost;\n      dijkstra(V-1,i);\n      ll tmp = LLINF;\n      rep(j,c) tmp = min(tmp,mini[0][j][1]);\n      if( tmp == LLINF ) continue;\n      ans = min(ans,cost+tmp);\n      adhoc = ans;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  rep(i,E) {\n    int x,y,t;\n    cin >> x >> y >> t;\n    --x,--y;\n    G[x].push_back((Edge){y,t});\n    G[y].push_back((Edge){x,t});\n  } \n  cin >> v0 >> a >> b >> c;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define INF ((1LL<<62)-(1LL<<31))\n#define min(p,q)((p)<(q)?(p):(q))\n\n#define VCNT (500*50*2)\n#define ECNT (5000*50*2*2)\nint a,b,c;\nint n,m;\nint x[5010],y[5010],t[5010];\nint v;\n\ntypedef struct edge{ll s,g,c;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[ECNT+10];//適宜変える(ecnt)\n//\tint inv[200010];//逆辺のindex(ecnt)\n\tint id[VCNT+10];//適宜変える(vcnt)\n}G;\nG g;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\n//int csort(const void*a,const void*b){ll p=(*(E*)a).c,q=(*(E*)b).c;return p<q?-1:p>q?1:0;}\n//void makeinvedge();\nvoid readgraph(){\n\t//適宜変える\n\n\tint ecnt=0;\n\trep(i,0,m){\n\t\trep(k,0,c){\n\t\t\trep(f,0,2){\n\t\t\t\tg.e[ecnt].s=(x[i]*c+k)*2+f;\n\t\t\t\tg.e[ecnt].g=(y[i]*c+(a*k+b)%c)*2+(f||y[i]==n-1);\n\t\t\t\tg.e[ecnt].c=t[i]*k;\n\t\t\t\tecnt++;\n\t\t\t\tg.e[ecnt].s=(y[i]*c+k)*2+f;\n\t\t\t\tg.e[ecnt].g=(x[i]*c+(a*k+b)%c)*2+(f||x[i]==n-1);\n\t\t\t\tg.e[ecnt].c=t[i]*k;\n\t\t\t\tecnt++;\n\t\t\t}\n\t\t}\n\t}\n\tg.vcnt=n*c*2;\n\tg.ecnt=ecnt;\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n//\tqsort(g.e,g.ecnt,sizeof(E),csort);\n//\tmakeinvedge();\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\n\n//プラキュー（二分ヒープ）（優先度変更ありバージョン）\nll heapN,heap[VCNT+10],heapinv[VCNT+10];\nint PQhikaku(int i,int j);//jの方が優先度が高いならtrueを返す\nvoid PQchange(int n);\nvoid heap_utod(int n){\n\tif(2*n>heapN)return;\n\tint rflag=(2*n+1<=heapN)&&(PQhikaku(2*n,2*n+1));\n\tif(PQhikaku(n,2*n+rflag)){\n\t\tll temp=heap[2*n+rflag];\n\t\theap[2*n+rflag]=heap[n];\n\t\theap[n]=temp;\n\t\theapinv[heap[n]]=n;\n\t\theapinv[heap[2*n+rflag]]=2*n+rflag;\t\n\t\theap_utod(2*n+rflag);\n\t}\n}\nvoid heap_dtou(int n){\n\tif(n==1||PQhikaku(n,n/2))return;\n\tll temp=heap[n];\n\theap[n]=heap[n/2];\n\theap[n/2]=temp;\n\theapinv[heap[n]]=n;\n\theapinv[heap[n/2]]=n/2;\n\theap_dtou(n/2);\n}\nll PQpop(){\n\tll rr=heap[1];\n\theapinv[heap[1]]=0;\n\theap[1]=heap[heapN--];\n\theapinv[heap[1]]=1;\n\theap_utod(1);\n\treturn rr;\n}\nvoid PQpush(ll n){\n\theap[++heapN]=n;\n\theapinv[heap[heapN]]=heapN;\n\theap_dtou(heapN);\n}\n\n//早い方のダイクストラ\n//グラフと始点を引いて各点への最短距離・最短経路を返す\n//プラキューが必要\n//O((E+V)logV)\nll daikusutorappp[VCNT+10];\nvoid daikusutora2(ll s){\n\trep(i,0,g.vcnt)daikusutorappp[i]=i==s?0:INF;\n\trep(i,0,g.vcnt)PQpush(i);\n\twhile(heapN){\n\t\tll mv=PQpop();\n\t\tfor(ll t=g.id[mv];t<g.ecnt&&g.e[t].s==mv;t++){\n\t\t\tif(daikusutorappp[g.e[t].g]>daikusutorappp[mv]+g.e[t].c){\n\t\t\t\tdaikusutorappp[g.e[t].g]=daikusutorappp[mv]+g.e[t].c;\n\t\t\t\t//daikusutorappp[n+g.e[t].g]=mv;//最短経路がいる場合はこれ\n\t\t\t\tPQchange(g.e[t].g);\n\t\t\t}\n\t\t}\n\t}\n}\nint PQhikaku(int i,int j){return daikusutorappp[heap[i]]>daikusutorappp[heap[j]];}\nvoid PQchange(int n){if(heapinv[n])heap_dtou(heapinv[n]);}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m){\n\t\tscanf(\"%d%d%d\",x+i,y+i,t+i);\n\t\tx[i]--,y[i]--;\n\t}\n\tscanf(\"%d%d%d%d\",&v,&a,&b,&c);\n\treadgraph();\n\n\tdaikusutora2((0*c+v)*2+0);\n\tll ans=INF;\n\trep(i,0,c)ans=min(ans,daikusutorappp[(0*c+i)*2+1]);\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long CO[510][50][2];\nlong long R=1,C=1,H[1000010],N[1000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\nvoid hin(long long a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint main(){\n  int n,m,i,mi,f,a,b,c,nf;\n  int ta[510],to[10010],co[10010],nt[10010];\n  int id[100010],V[100010],F[100010],u[510][50][2]={};\n  long long ans=1e18,v,nv;\n  for(i=0;i<510*50;i++)CO[i/50][i%50][0]=CO[i/50][i%50][1]=1e18;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    nt[i  ]=ta[to[i+m]=a];\n    nt[i+m]=ta[to[i  ]=b];\n    co[ta[b]=i+m]=co[ta[a]=i]=c;\n  }\n  /*for(i=1;i<=n;i++){printf(\"%d:\",i);int j;\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n    }//*/\n  scanf(\"%lld %d %d %d\",&v,&a,&b,&c);\n  CO[1][v][0]=0;\n  mi=1;\n  f=0;\n  while(u[mi][v][f]-1){//printf(\"%lld %d %lld %d\\n\",CO[mi][v][f],mi,v,f);\n    u[mi][v][f]=1;\n    nv=(a*v+b)%c;\n    for(i=ta[mi];i+1;i=nt[i]){\n      nf=to[i]==n?1:f;\n      if(CO[to[i]][nv][nf]>CO[mi][v][f]+co[i]*v){\n\tid[R]=to[i];\n\tV[R]=nv;\n\tF[R]=nf;\n\thin(CO[to[i]][nv][nf]=CO[mi][v][f]+co[i]*v);\n      }\n    }\n    while(u[mi][v][f]&&C-1){\n      i=hout();\n      mi=id[i];\n      v=V[i];\n      f=F[i];\n    }\n  }\n  for(i=0;i<50;i++){\n    if(ans>CO[1][i][1])ans=CO[1][i][1];\n    //printf(\"%lld\\n\",CO[1][i][1]);\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long CO[510][50][2];\nlong long R=1,C=1,H[1000010],N[1000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\nvoid hin(long long a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint main(){\n  int n,m,i,mi,f,a,b,c,nf,v,nv;\n  int ta[510],to[10010],nt[10010];\n  int id[100010],V[100010],F[100010],u[510][50][2]={};\n  long long ans=1e18,co[10010];\n  for(i=0;i<510*50;i++)CO[i/50][i%50][0]=CO[i/50][i%50][1]=1e18;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    nt[i  ]=ta[to[i+m]=a];\n    nt[i+m]=ta[to[i  ]=b];\n    co[ta[b]=i+m]=co[ta[a]=i]=c;\n  }\n  /*for(i=1;i<=n;i++){printf(\"%d:\",i);int j;\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n    }//*/\n  scanf(\"%d %d %d %d\",&v,&a,&b,&c);\n  CO[1][v][0]=0;\n  mi=1;\n  f=0;\n  while(u[mi][v][f]-1){//printf(\"%lld %d %lld %d\\n\",CO[mi][v][f],mi,v,f);\n    u[mi][v][f]=1;\n    nv=(a*v+b)%c;\n    for(i=ta[mi];i+1;i=nt[i]){\n      nf=to[i]==n?1:f;\n      if(CO[to[i]][nv][nf]>CO[mi][v][f]+co[i]*v){\n\tid[R]=to[i];\n\tV[R]=nv;\n\tF[R]=nf;\n\thin(CO[to[i]][nv][nf]=CO[mi][v][f]+co[i]*v);\n      }\n    }\n    while(u[mi][v][f]&&C-1){\n      i=hout();\n      mi=id[i];\n      v=V[i];\n      f=F[i];\n    }\n  }\n  for(i=0;i<50;i++){\n    if(ans>CO[1][i][1])ans=CO[1][i][1];\n    //printf(\"%lld\\n\",CO[1][i][1]);\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long CO[510][50][2];\nlong long R=1,C=1,H[1000010],N[1000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\nvoid hin(long long a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint id[1000010],V[1000010],F[10000010],u[510][50][2]={};\nint main(){\n  int n,m,i,mi,f,a,b,c,nf,v,nv;\n  int ta[510],to[10010],nt[10010];\n  long long ans=1e18,co[10010];\n  for(i=0;i<510*50;i++)CO[i/50][i%50][0]=CO[i/50][i%50][1]=1e18;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    nt[i  ]=ta[to[i+m]=a];\n    nt[i+m]=ta[to[i  ]=b];\n    co[ta[b]=i+m]=co[ta[a]=i]=c;\n  }\n  /*for(i=1;i<=n;i++){printf(\"%d:\",i);int j;\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n    }//*/\n  scanf(\"%d %d %d %d\",&v,&a,&b,&c);\n  CO[1][v][0]=0;\n  mi=1;\n  f=0;\n  while(u[mi][v][f]-1){//printf(\"%lld %d %lld %d\\n\",CO[mi][v][f],mi,v,f);\n    u[mi][v][f]=1;\n    nv=(a*v+b)%c;\n    for(i=ta[mi];i+1;i=nt[i]){\n      nf=to[i]==n?1:f;\n      if(CO[to[i]][nv][nf]>CO[mi][v][f]+co[i]*v){\n\tid[R]=to[i];\n\tV[R]=nv;\n\tF[R]=nf;\n\thin(CO[to[i]][nv][nf]=CO[mi][v][f]+co[i]*v);\n      }\n    }\n    while(u[mi][v][f]&&C-1){\n      i=hout();\n      mi=id[i];\n      v=V[i];\n      f=F[i];\n    }\n  }\n  for(i=0;i<50;i++){\n    if(ans>CO[1][i][1])ans=CO[1][i][1];\n    //printf(\"%lld\\n\",CO[1][i][1]);\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2819 Country in Distortion\n// 2019.4.6 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n//// 高速入力\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n//\twhile (isspace(c)) c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n\n//// 優先度付きキュー（ダイクストラ法のため）\n#define MAX 500000\ntypedef struct { int n; long long s; char v, f; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].s < que[i].s) min = l; else min = i;\n\tif (r < qsize && que[r].s < que[min].s) min = r;\n\tif (min != i) {\n\t\tqt = que[i]; que[i] = que[min]; que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int n, int v, long long s, int f)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].n = n, que[i].v = v, que[i].s = s, que[i].f = f;\n\twhile (i > 0 && que[min = PARENT(i)].s > que[i].s) {\n\t\tqt = que[i]; que[i] = que[min]; que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n\n//// 本問題関連\nint N;\nint hi[505], to[505][505], tm[505][505];\nchar vis[505][50][2];\nint v0, a, b, c;\n\nlong long dijkstra(int start, int goal)\n{\n\tint i, n, v, f, nx, nv;\n\tlong long s;\n\n\tenq(start, v0, 0, 0);\n\twhile (qsize) {\n\t\tn = que[0].n, v = que[0].v, s = que[0].s, f = que[0].f, deq();\n\n\t\tif (n == goal) f = 1;\n\t\telse if (n == start) { if (f == 1) return s; }\n\n\t\tif (vis[n][v][f]) continue;\n\t\tvis[n][v][f] = 1;\n\n\t\tnv = (a*v + b) % c;\n\t\tfor (i = 0; i < hi[n]; i++) {\n\t\t\tnx = to[n][i];\n\t\t\tif (!vis[nx][nv][f]) enq(nx, nv, s + (long long)v * tm[n][i], f);\n\t\t}\n\t}\n\treturn -1LL;\n}\n\nint main()\n{\n\tint k, M, x, y, t;\n\n\tN = in(), M = in();\n\twhile (M--) {\n\t\tx = in() - 1, y = in() - 1, t = in();\n\t\tk = hi[x]++, to[x][k] = y, tm[x][k] = t;\n\t\tk = hi[y]++, to[y][k] = x, tm[y][k] = t;\n\t}\n\tv0 = in();\n\ta = in(), b = in(), c = in();\n\tprintf(\"%lld\\n\", dijkstra(0, N - 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n  class Edge {\n\n    final int to, cost;\n\n    Edge(int to, int cost) {\n      this.to = to;\n      this.cost = cost;\n    }\n  }\n\n  class State implements Comparable<State> {\n\n    final int v, vi;\n    long dist;\n    final boolean after;\n\n    State(int v, long dist, int vi, boolean after) {\n      this.v = v;\n      this.dist = dist;\n      this.vi = vi;\n      this.after = after;\n    }\n\n    @Override\n    public int compareTo(State o) {\n      return Long.signum(this.dist - o.dist);\n    }\n  }\n\n  long INF = Long.MAX_VALUE / 100;\n  ArrayList<Edge>[] graph;\n\n  @SuppressWarnings(\"unchecked\")\n  private void solve(FastScanner in, PrintWriter out) {\n    int N = in.nextInt();\n    int M = in.nextInt();\n    graph = new ArrayList[N];\n    for (int i = 0; i < N; i++) {\n      graph[i] = new ArrayList<>();\n    }\n\n    for (int i = 0; i < M; i++) {\n      int x = in.nextInt() - 1;\n      int y = in.nextInt() - 1;\n      int t = in.nextInt();\n      graph[x].add(new Edge(y, t));\n      graph[y].add(new Edge(x, t));\n    }\n\n    int v0 = in.nextInt();\n    int a = in.nextInt();\n    int b = in.nextInt();\n    int c = in.nextInt();\n\n    PriorityQueue<State> queue = new PriorityQueue<>();\n    long[][][] dist = new long[N][51][2];\n    for (long[][] d : dist) {\n      for (long[] s : d) {\n        Arrays.fill(s, INF);\n      }\n    }\n\n    dist[0][v0][0] = 0;\n    queue.add(new State(0, 0, v0, false));\n    while (!queue.isEmpty()) {\n      State state = queue.poll();\n\n      if (state.v == 0 && state.after) {\n        out.println(state.dist);\n        return;\n      }\n\n      int v = state.v;\n      long d = state.dist;\n      int vi = state.vi;\n      boolean after = state.after;\n      if (v == N - 1) {\n        after = true;\n      }\n      int f = after ? 1 : 0;\n\n      for (Edge edge : graph[v]) {\n        long addDist = (long) vi * edge.cost;\n        int vj = (a * vi + b) % c;\n        if (dist[edge.to][vj][f] > d + addDist) {\n          dist[edge.to][vj][f] = d + addDist;\n          queue.add(new State(edge.to, dist[edge.to][vj][f], vj, after));\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(new FastScanner(), out);\n    out.close();\n  }\n\n  private static class FastScanner {javascript:void(0)\n\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) {\n        return buffer[ptr++];\n      } else {\n        return -1;\n      }\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n        ptr++;\n      }\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = next();\n      }\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) {\n        array[i] = next().toCharArray();\n      }\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n  class Edge {\n\n    final int to, cost;\n\n    Edge(int to, int cost) {\n      this.to = to;\n      this.cost = cost;\n    }\n  }\n\n  class State implements Comparable<State> {\n\n    final int v, vi;\n    long dist;\n    final boolean after;\n\n    State(int v, long dist, int vi, boolean after) {\n      this.v = v;\n      this.dist = dist;\n      this.vi = vi;\n      this.after = after;\n    }\n\n    @Override\n    public int compareTo(State o) {\n      return Long.signum(this.dist - o.dist);\n    }\n  }\n\n  long INF = Long.MAX_VALUE / 100;\n  ArrayList<Edge>[] graph;\n\n  @SuppressWarnings(\"unchecked\")\n  private void solve(FastScanner in, PrintWriter out) {\n    int N = in.nextInt();\n    int M = in.nextInt();\n    graph = new ArrayList[N];\n    for (int i = 0; i < N; i++) {\n      graph[i] = new ArrayList<>();\n    }\n\n    for (int i = 0; i < M; i++) {\n      int x = in.nextInt() - 1;\n      int y = in.nextInt() - 1;\n      int t = in.nextInt();\n      graph[x].add(new Edge(y, t));\n      graph[y].add(new Edge(x, t));\n    }\n\n    int v0 = in.nextInt();\n    int a = in.nextInt();\n    int b = in.nextInt();\n    int c = in.nextInt();\n\n    PriorityQueue<State> queue = new PriorityQueue<>();\n    long[][][] dist = new long[N][51][2];\n    for (long[][] d : dist) {\n      for (long[] s : d) {\n        Arrays.fill(s, INF);\n      }\n    }\n\n    dist[0][v0][0] = 0;\n    queue.add(new State(0, 0, v0, false));\n    while (!queue.isEmpty()) {\n      State state = queue.poll();\n\n      if (state.v == 0 && state.after) {\n        out.println(state.dist);\n        return;\n      }\n\n      int v = state.v;\n      long d = state.dist;\n      int vi = state.vi;\n      boolean after = state.after;\n      if (v == N - 1) {\n        after = true;\n      }\n      int f = after ? 1 : 0;\n\n      for (Edge edge : graph[v]) {\n        long addDist = (long) vi * edge.cost;\n        int vj = (a * vi + b) % c;\n        if (dist[edge.to][vj][f] > d + addDist) {\n          dist[edge.to][vj][f] = d + addDist;\n          queue.add(new State(edge.to, dist[edge.to][vj][f], vj, after));\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(new FastScanner(), out);\n    out.close();\n  }\n\n  private static class FastScanner {\n\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) {\n        return buffer[ptr++];\n      } else {\n        return -1;\n      }\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n        ptr++;\n      }\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = next();\n      }\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) {\n        array[i] = next().toCharArray();\n      }\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n  class Edge {\n\n    final int to, cost;\n\n    Edge(int to, int cost) {\n      this.to = to;\n      this.cost = cost;\n    }\n  }\n\n  class State implements Comparable<State> {\n\n    final int v, vi;\n    long dist;\n    final boolean after;\n\n    State(int v, long dist, int vi, boolean after) {\n      this.v = v;\n      this.dist = dist;\n      this.vi = vi;\n      this.after = after;\n    }\n\n    @Override\n    public int compareTo(State o) {\n      return Long.signum(this.dist - o.dist);\n    }\n  }\n\n  long INF = Long.MAX_VALUE / 100;\n  ArrayList<Edge>[] graph;\n\n  private void solve(FastScanner in, PrintWriter out) {\n    int N = in.nextInt();\n    int M = in.nextInt();\n    graph = new ArrayList[N];\n    for (int i = 0; i < N; i++) {\n      graph[i] = new ArrayList<>();\n    }\n\n    for (int i = 0; i < M; i++) {\n      int x = in.nextInt() - 1;\n      int y = in.nextInt() - 1;\n      int t = in.nextInt();\n      graph[x].add(new Edge(y, t));\n      graph[y].add(new Edge(x, t));\n    }\n\n    int v0 = in.nextInt();\n    int a = in.nextInt();\n    int b = in.nextInt();\n    int c = in.nextInt();\n\n    PriorityQueue<State> queue = new PriorityQueue<>();\n    long[][][] dist = new long[N][51][2];\n    for (long[][] d : dist) {\n      for (long[] s : d) {\n        Arrays.fill(s, INF);\n      }\n    }\n\n    dist[0][v0][0] = 0;\n    queue.add(new State(0, 0, v0, false));\n    while (!queue.isEmpty()) {\n      State state = queue.poll();\n\n      if (state.v == 0 && state.after) {\n        out.println(state.dist);\n        return;\n      }\n\n      int v = state.v;\n      long d = state.dist;\n      int vi = state.vi;\n      boolean after = state.after;\n      if (v == N - 1) {\n        after = true;\n      }\n      int f = after ? 1 : 0;\n\n      for (Edge edge : graph[v]) {\n        long addDist = (long) vi * edge.cost;\n        int vj = (a * vi + b) % c;\n        if (dist[edge.to][vj][f] > d + addDist) {\n          dist[edge.to][vj][f] = d + addDist;\n          queue.add(new State(edge.to, dist[edge.to][vj][f], vj, after));\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(new FastScanner(), out);\n    out.close();\n  }\n\n  private static class FastScanner {\n\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) {\n        return buffer[ptr++];\n      } else {\n        return -1;\n      }\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n        ptr++;\n      }\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = next();\n      }\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) {\n        array[i] = next().toCharArray();\n      }\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n  class Edge {\n\n    final int to, cost;\n\n    Edge(int to, int cost) {\n      this.to = to;\n      this.cost = cost;\n    }\n  }\n\n  class State implements Comparable<State> {\n\n    final int v, vi;\n    long dist;\n    final boolean after;\n\n    State(int v, long dist, int vi, boolean after) {\n      this.v = v;\n      this.dist = dist;\n      this.vi = vi;\n      this.after = after;\n    }\n\n    @Override\n    public int compareTo(State o) {\n      return Long.signum(this.dist - o.dist);\n    }\n  }\n\n  long INF = Long.MAX_VALUE / 100;\n  ArrayList<Edge>[] graph;\n\n  @SuppressWarnings(\"unchecked\")\n  private void solve(FastScanner in, PrintWriter out) {\n    int N = in.nextInt();\n    int M = in.nextInt();\n    graph = new ArrayList[N];\n    for (int i = 0; i < N; i++) {\n      graph[i] = new ArrayList<>();\n    }\n\n    for (int i = 0; i < M; i++) {\n      int x = in.nextInt() - 1;\n      int y = in.nextInt() - 1;\n      int t = in.nextInt();\n      graph[x].add(new Edge(y, t));\n      graph[y].add(new Edge(x, t));\n    }\n\n    int v0 = in.nextInt();\n    int a = in.nextInt();\n    int b = in.nextInt();\n    int c = in.nextInt();\n\n    PriorityQueue<State> queue = new PriorityQueue<>();\n    long[][][] dist = new long[N][51][2];\n    for (long[][] d : dist) {\n      for (long[] s : d) {\n        Arrays.fill(s, INF);\n      }\n    }\n\n    dist[0][v0][0] = 0;\n    queue.add(new State(0, 0, v0, false));\n    while (!queue.isEmpty()) {\n      State state = queue.poll();\n\n      if (state.v == 0 && state.after) {\n        out.println(state.dist);\n        return;\n      }\n\n      int v = state.v;\n      long d = state.dist;\n      int vi = state.vi;\n      boolean after = state.after;\n      if (v == N - 1) {\n        after = true;\n      }\n      int f = after ? 1 : 0;\n\n      for (Edge edge : graph[v]) {\n        long addDist = (long) vi * edge.cost;\n        int vj = (a * vi + b) % c;\n        if (dist[edge.to][vj][f] > d + addDist) {\n          dist[edge.to][vj][f] = d + addDist;\n          queue.add(new State(edge.to, dist[edge.to][vj][f], vj, after));\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(new FastScanner(), out);\n    out.close();\n  }\n\n  private static class FastScanner {\n\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) {\n        return buffer[ptr++];\n      } else {\n        return -1;\n      }\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n        ptr++;\n      }\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = next();\n      }\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) {\n        array[i] = next().toCharArray();\n      }\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class D {\n\n  class Edge {\n\n    final int to, cost;\n\n    Edge(int to, int cost) {\n      this.to = to;\n      this.cost = cost;\n    }\n  }\n\n  class State implements Comparable<State> {\n\n    final int v, vi;\n    long dist;\n    final boolean after;\n\n    State(int v, long dist, int vi, boolean after) {\n      this.v = v;\n      this.dist = dist;\n      this.vi = vi;\n      this.after = after;\n    }\n\n    @Override\n    public int compareTo(State o) {\n      return Long.signum(this.dist - o.dist);\n    }\n  }\n\n  long INF = Long.MAX_VALUE / 100;\n  ArrayList<Edge>[] graph;\n\n  @SuppressWarnings(\"unchecked\")\n  private void solve(FastScanner in, PrintWriter out) {\n    int N = in.nextInt();\n    int M = in.nextInt();\n    graph = new ArrayList[N];\n    for (int i = 0; i < N; i++) {\n      graph[i] = new ArrayList<>();\n    }\n\n    for (int i = 0; i < M; i++) {\n      int x = in.nextInt() - 1;\n      int y = in.nextInt() - 1;\n      int t = in.nextInt();\n      graph[x].add(new Edge(y, t));\n      graph[y].add(new Edge(x, t));\n    }\n\n    int v0 = in.nextInt();\n    int a = in.nextInt();\n    int b = in.nextInt();\n    int c = in.nextInt();\n\n    PriorityQueue<State> queue = new PriorityQueue<>();\n    long[][][] dist = new long[N][51][2];\n    for (long[][] d : dist) {\n      for (long[] s : d) {\n        Arrays.fill(s, INF);\n      }\n    }\n\n    dist[0][v0][0] = 0;\n    queue.add(new State(0, 0, v0, false));\n    while (!queue.isEmpty()) {\n      State state = queue.poll();\n\n      if (state.v == 0 && state.after) {\n        out.println(state.dist);\n        return;\n      }\n\n      int v = state.v;\n      long d = state.dist;\n      int vi = state.vi;\n      boolean after = state.after;\n      if (v == N - 1) {\n        after = true;\n      }\n      int f = after ? 1 : 0;\n\n      for (Edge edge : graph[v]) {\n        long addDist = (long) vi * edge.cost;\n        int vj = (a * vi + b) % c;\n        if (dist[edge.to][vj][f] > d + addDist) {\n          dist[edge.to][vj][f] = d + addDist;\n          queue.add(new State(edge.to, dist[edge.to][vj][f], vj, after));\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    new D().solve(new FastScanner(), out);\n    out.close();\n  }\n\n  private static class FastScanner {\n\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) {\n        return buffer[ptr++];\n      } else {\n        return -1;\n      }\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n        ptr++;\n      }\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = next();\n      }\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) {\n        array[i] = next().toCharArray();\n      }\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef main():\n  n, m = map(int, input().split())\n  edges = [[] for _ in range(n)]\n  for _ in range(m):\n    x, y, t = map(int, input().split())\n    x -= 1\n    y -= 1\n    edges[x].append((y, t))\n    edges[y].append((x, t))\n  \n  v0 = int(input())\n  a, b, c = map(int, input().split())\n  v_next = {}\n  v = v0\n  while True:\n    if v not in v_next:\n      v_next[v] = (v * a + b) % c\n      v = (v * a + b) % c\n    else:break\n\n  dic = {}\n  dic[(v0, 0)] = 0\n  que = []\n  heappush(que, (0, 0, v0))\n  while que:\n    score, node, v = heappop(que)\n    new_v = v_next[v]\n    for to, t in edges[node]:\n      new_score = score + v * t\n      if (new_v, to) not in dic or dic[(new_v, to)] > new_score:\n        dic[(new_v, to)] = new_score\n        heappush(que, (new_score, to, new_v))\n  \n  dic2 = {}\n  que = []\n  for v in range(c):\n    if (v, n - 1) in dic:\n      dic2[(v, n - 1)] = dic[(v, n - 1)]\n      heappush(que, (dic[(v, n - 1)], n - 1, v))\n  \n  while que:\n    score, node, v = heappop(que)\n    if node == 0:\n      print(score)\n      break\n    new_v = v_next[v]\n    for to, t in edges[node]:\n      new_score = score + v * t\n      if (new_v, to) not in dic2 or dic2[(new_v, to)] > new_score:\n        dic2[(new_v, to)] = new_score\n        heappush(que, (new_score, to, new_v))\nmain() \n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\ninf = float('inf')\n\nn,m = map(int,input().split())\npathT = [{} for _ in range(n)]\nfor i in range(m):\n    x,y,t = map(int,input().split())\n    x -= 1\n    y -= 1\n    pathT[x][y] = t\n    pathT[y][x] = t\n\nimport heapq \ndef Dijkstra(edge,start):\n    d = [[float('inf'),float('inf')] for _ in range(len(edge))]\n    d[start][0] = 0\n    pq = [(0,start,0)]\n    heapq.heapify(pq)\n    while pq:\n        dist,p,flag = heapq.heappop(pq)\n        toflag = flag or (p%n == n-1)\n        if dist > d[p][flag]:continue\n        for to,cost in edge[p].items():\n            if d[to][toflag] <= dist + cost:continue\n            d[to][toflag] = dist + cost\n            heapq.heappush(pq, (d[to][toflag], to, toflag))\n    return d\n\nv0 = int(input())\na,b,c = map(int,input().split())\nV = [v0]\nv = v0\nVs = set()\nwhile True:\n    v = (a*v + b)%c\n    if v in Vs:\n        loop = V.index(v)\n        break\n    # print(v)\n    V.append(v)\n    Vs.add(v)\np = len(V)\n\npath = [{} for _ in range(p*n)]\nfor now,nxtD in enumerate(pathT):\n    for i,v in enumerate(V):\n        for nxt,t in nxtD.items():\n            if i+1 != p:\n                path[i*n + now][(i+1)*n + nxt] = t*v\n            else:\n                path[i*n + now][loop*n + nxt] = t*v\n\nd = Dijkstra(path,0)\nans = float('inf')\nfor i in range(p):\n    ans = min(ans, d[i*n][1])\n    # d2 = Dijkstra(path,i*n + n-1)\n    # # res = float('inf')\n    # for j in range(p):\n    #     # res = min(res, d2[j*n])\n    #     ans = min(ans, d[i*n + n-1] + d2[j*n])\nprint(ans)\n\n"
  }
]