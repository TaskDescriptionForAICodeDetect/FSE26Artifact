[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_VERTICES 1005\n#define INF 1e9\n\ntypedef struct {\n    int to, time;\n} Edge;\n\ntypedef struct {\n    int vertex, total_time;\n    double speed;\n} State;\n\nEdge graph[MAX_VERTICES][MAX_VERTICES];\nint edge_count[MAX_VERTICES];\nint n, m, k;\ndouble a, b, c;\n\nint compare(const void* a, const void* b) {\n    State* x = (State*)a;\n    State* y = (State*)b;\n    return x->total_time > y->total_time ? 1 : -1;\n}\n\ndouble dijkstra(int start, int end, double initial_speed) {\n    State states[MAX_VERTICES];\n    int visited[MAX_VERTICES];\n    double min_distance[MAX_VERTICES];\n\n    for (int i = 1; i <= n; i++) {\n        min_distance[i] = INF;\n        visited[i] = 0;\n    }\n\n    states[0].vertex = start;\n    states[0].total_time = 0;\n    states[0].speed = initial_speed;\n\n    qsort(states, 1, sizeof(State), compare);\n\n    while (states[0].vertex != end) {\n        int current = states[0].vertex;\n        double current_speed = states[0].speed;\n        int current_time = states[0].total_time;\n\n        visited[current] = 1;\n\n        for (int i = 0; i < edge_count[current]; i++) {\n            int next = graph[current][i].to;\n            int edge_time = graph[current][i].time;\n            double new_speed = a * current_speed + b * edge_time + c;\n            double perceived_distance = edge_time / new_speed;\n\n            if (!visited[next] && current_time + edge_time < min_distance[next]) {\n                min_distance[next] = current_time + edge_time;\n                states[0].vertex = next;\n                states[0].total_time = current_time + edge_time;\n                states[0].speed = new_speed;\n                qsort(states, 1, sizeof(State), compare);\n            }\n        }\n    }\n\n    return min_distance[end];\n}\n\nint main() {\n    scanf(\"%d %d %d %lf %lf %lf\", &n, &m, &k, &a, &b, &c);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, time;\n        scanf(\"%d %d %d\", &u, &v, &time);\n        graph[u][edge_count[u]++] = (Edge){v, time};\n    }\n\n    double initial_speed = k;\n    double forward_time = dijkstra(1, n, initial_speed);\n    double return_time = dijkstra(n, 1, initial_speed);\n\n    printf(\"%.6lf\\n\", forward_time + return_time);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 2000\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nEdge edges[MAX_M];\nint n, m;\ndouble k[MAX_N];\ndouble dist[MAX_N][2];\n\nvoid bellman_ford(int start, int direction) {\n    for (int i = 1; i <= n; i++) {\n        dist[i][direction] = 1e18;\n    }\n    dist[start][direction] = 0.0;\n\n    for (int i = 1; i <= n - 1; i++) {\n        for (int j = 0; j < m; j++) {\n            int u = edges[j].u;\n            int v = edges[j].v;\n            int w = edges[j].w;\n            if (direction == 1) {\n                u = edges[j].v;\n                v = edges[j].u;\n            }\n            if (dist[u][direction] + (double)w / k[u] < dist[v][direction]) {\n                dist[v][direction] = dist[u][direction] + (double)w / k[u];\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lf\", &k[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n\n    bellman_ford(1, 0);\n    bellman_ford(n, 1);\n\n    double min_distance = dist[n][0] + dist[1][1];\n    printf(\"%.8lf\\n\", min_distance);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:00:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, pll> plll;\n\nconst ll INF = LLONG_MAX;\n\nstruct Edge {\n    ll to, time, a, b;\n};\n\nvector<vector<Edge>> adj;\nvector<vector<ll>> dist_forward, dist_backward;\n\nvoid dijkstra(ll start, vector<vector<ll>>& dist, ll n) {\n    dist.assign(n + 1, vector<ll>(1001, INF));\n    priority_queue<plll, vector<plll>, greater<plll>> pq;\n    dist[start][1000] = 0;\n    pq.push({0, {start, 1000}});\n\n    while (!pq.empty()) {\n        ll current_dist = pq.top().first;\n        ll u = pq.top().second.first;\n        ll speed = pq.top().second.second;\n        pq.pop();\n\n        if (current_dist > dist[u][speed]) continue;\n\n        for (const Edge& e : adj[u]) {\n            ll new_speed = (e.a * speed + e.b) % 1000;\n            if (new_speed <= 0) continue;\n            ll new_dist = current_dist + (e.time * 1000) / new_speed;\n            if (new_dist < dist[e.to][new_speed]) {\n                dist[e.to][new_speed] = new_dist;\n                pq.push({new_dist, {e.to, new_speed}});\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    ll n, m;\n    cin >> n >> m;\n    adj.resize(n + 1);\n\n    for (ll i = 0; i < m; ++i) {\n        ll u, v, time, a, b;\n        cin >> u >> v >> time >> a >> b;\n        adj[u].push_back({v, time, a, b});\n    }\n\n    dijkstra(1, dist_forward, n);\n    dijkstra(n, dist_backward, n);\n\n    ll min_total = INF;\n    for (ll speed = 1; speed <= 1000; ++speed) {\n        if (dist_forward[n][speed] != INF && dist_backward[1][speed] != INF) {\n            min_total = min(min_total, dist_forward[n][speed] + dist_backward[1][speed]);\n        }\n    }\n\n    if (min_total == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << min_total << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int to;\n    double time;\n    double a, b;\n\n    Edge(int to, double time, double a, double b) {\n        this.to = to;\n        this.time = time;\n        this.a = a;\n        this.b = b;\n    }\n}\n\npublic class DistortionCountry {\n    static final double INF = 1e18;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            double time = sc.nextDouble();\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            graph.get(u).add(new Edge(v, time, a, b));\n            graph.get(v).add(new Edge(u, time, a, b));\n        }\n\n        double[][] distTo = new double[n + 1][n + 1];\n        for (double[] row : distTo) {\n            Arrays.fill(row, INF);\n        }\n        distTo[1][1] = 0.0;\n        PriorityQueue<double[]> pq = new PriorityQueue<>(Comparator.comparingDouble(a -> a[2]));\n        pq.offer(new double[]{1, 1, 0.0});\n\n        while (!pq.isEmpty()) {\n            double[] curr = pq.poll();\n            int u = (int) curr[0];\n            int v = (int) curr[1];\n            double dist = curr[2];\n            if (dist > distTo[u][v]) continue;\n\n            for (Edge e1 : graph.get(u)) {\n                for (Edge e2 : graph.get(v)) {\n                    int nextU = e1.to;\n                    int nextV = e2.to;\n                    double newDist = dist + e1.time * e1.a + e2.time * e2.b;\n                    if (newDist < distTo[nextU][nextV]) {\n                        distTo[nextU][nextV] = newDist;\n                        pq.offer(new double[]{nextU, nextV, newDist});\n                    }\n                }\n            }\n        }\n\n        double minDist = INF;\n        for (int i = 1; i <= n; i++) {\n            minDist = Math.min(minDist, distTo[i][i]);\n        }\n\n        if (minDist >= INF) {\n            System.out.println(-1);\n        } else {\n            System.out.printf(\"%.6f\\n\", minDist);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:01:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CountryOfDistortion {\n    static final long INF = Long.MAX_VALUE / 2;\n    static int n, m;\n    static List<List<Edge>> graph;\n\n    static class Edge {\n        int to;\n        long time;\n        long speedChange;\n\n        Edge(int to, long time, long speedChange) {\n            this.to = to;\n            this.time = time;\n            this.speedChange = speedChange;\n        }\n    }\n\n    static long dijkstra(long initialSpeed) {\n        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[1], b[1]));\n        long[][] dist = new long[n + 1][2];\n        \n        for (int i = 0; i <= n; i++) {\n            dist[i][0] = dist[i][1] = INF;\n        }\n        \n        dist[1][0] = 0;\n        pq.offer(new long[]{1, 0, initialSpeed, 0});\n        \n        while (!pq.isEmpty()) {\n            long[] curr = pq.poll();\n            int node = (int)curr[0];\n            long time = curr[1];\n            long speed = curr[2];\n            int stage = (int)curr[3];\n            \n            if (time > dist[node][stage]) continue;\n            \n            if (node == n && stage == 0) {\n                dist[node][1] = time;\n                pq.offer(new long[]{node, time, speed, 1});\n            }\n            \n            if (node == 1 && stage == 1) {\n                return time;\n            }\n            \n            for (Edge edge : graph.get(node)) {\n                long newTime = time + edge.time / speed;\n                long newSpeed = speed + edge.speedChange;\n                \n                if (newTime < dist[edge.to][stage]) {\n                    dist[edge.to][stage] = newTime;\n                    pq.offer(new long[]{edge.to, newTime, newSpeed, stage});\n                }\n            }\n        }\n        \n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        long initialSpeed = sc.nextLong();\n        \n        graph = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            long time = sc.nextLong();\n            long speedChange = sc.nextLong();\n            graph.get(u).add(new Edge(v, time, speedChange));\n        }\n        \n        long result = dijkstra(initialSpeed);\n        System.out.println(result);\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:01:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nconst long long INF = 1e18;\n\nstruct Edge {\n    int to, time;\n};\n\nstruct State {\n    int vertex, speed;\n    long long dist;\n    \n    bool operator>(const State& other) const {\n        return dist > other.dist;\n    }\n};\n\nvector<Edge> graph[MAXN];\nint n, m, a, b, c;\nlong long dist[MAXN][105];\n\nlong long dijkstra() {\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= 100; j++) {\n            dist[i][j] = INF;\n        }\n    }\n    \n    priority_queue<State, vector<State>, greater<State>> pq;\n    pq.push({1, 1, 0});\n    dist[1][1] = 0;\n    \n    while (!pq.empty()) {\n        State curr = pq.top();\n        pq.pop();\n        \n        if (curr.dist > dist[curr.vertex][curr.speed]) continue;\n        \n        if (curr.vertex == n) continue;\n        \n        for (auto& edge : graph[curr.vertex]) {\n            int newSpeed = (a * curr.speed + b) % c + 1;\n            long long newDist = curr.dist + (long long)edge.time * curr.speed;\n            \n            if (newDist < dist[edge.to][newSpeed]) {\n                dist[edge.to][newSpeed] = newDist;\n                pq.push({edge.to, newSpeed, newDist});\n            }\n        }\n    }\n    \n    long long minDist = INF;\n    for (int speed = 1; speed <= 100; speed++) {\n        minDist = min(minDist, dist[n][speed]);\n    }\n    \n    return minDist;\n}\n\nlong long backwardDijkstra(long long initialDist) {\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= 100; j++) {\n            dist[i][j] = INF;\n        }\n    }\n    \n    priority_queue<State, vector<State>, greater<State>> pq;\n    \n    for (int speed = 1; speed <= 100; speed++) {\n        pq.push({n, speed, initialDist});\n        dist[n][speed] = initialDist;\n    }\n    \n    while (!pq.empty()) {\n        State curr = pq.top();\n        pq.pop();\n        \n        if (curr.dist > dist[curr.vertex][curr.speed]) continue;\n        \n        if (curr.vertex == 1) continue;\n        \n        for (auto& edge : graph[curr.vertex]) {\n            int newSpeed = (a * curr.speed + b) % c + 1;\n            long long newDist = curr.dist + (long long)edge.time * curr.speed;\n            \n            if (newDist < dist[edge.to][newSpeed]) {\n                dist[edge.to][newSpeed] = newDist;\n                pq.push({edge.to, newSpeed, newDist});\n            }\n        }\n    }\n    \n    long long minDist = INF;\n    for (int speed = 1; speed <= 100; speed++) {\n        minDist = min(minDist, dist[1][speed]);\n    }\n    \n    return minDist;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    cin >> n >> m >> a >> b >> c;\n    \n    for (int i = 0; i < m; i++) {\n        int u, v, t;\n        cin >> u >> v >> t;\n        graph[u].push_back({v, t});\n    }\n    \n    long long firstLeg = dijkstra();\n    long long secondLeg = backwardDijkstra(firstLeg);\n    \n    cout << firstLeg + secondLeg << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef dijkstra(graph, n, start, initial_speed, multiplier, increment):\n    distances = {vertex: float('inf') for vertex in range(1, n+1)}\n    distances[start] = 0\n    priority_queue = [(0, start, initial_speed)]\n\n    while priority_queue:\n        current_distance, current_vertex, current_speed = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_vertex]:\n            continue\n        \n        for neighbor, weight in graph[current_vertex]:\n            speed_change = multiplier * current_speed + increment\n            distance = weight / speed_change\n            total_distance = current_distance + distance\n\n            if total_distance < distances[neighbor]:\n                distances[neighbor] = total_distance\n                heapq.heappush(priority_queue, (total_distance, neighbor, speed_change))\n    \n    return distances\n\ndef find_min_perceived_distance(n, edges, initial_speed, multiplier, increment):\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v, time in edges:\n        graph[u].append((v, time))\n    \n    to_n = dijkstra(graph, n, 1, initial_speed, multiplier, increment)\n    back_to_1 = dijkstra(graph, n, n, to_n[n] * multiplier + increment, multiplier, increment)\n\n    return to_n[n] + back_to_1[1]\n\n# Example input:\n# n: number of vertices\n# m: number of edges\n# edges: list of tuples (u, v, time_cost)\n# initial_speed: initial perceived speed\n# multiplier: change in speed multiplier\n# increment: change in speed increment\n\nn = 4\nm = 4\nedges = [(1, 2, 5), (2, 3, 10), (3, 4, 10), (4, 1, 5)]\ninitial_speed = 1\nmultiplier = 1.5\nincrement = 1\n\n# Calculate the min perceived distance\nresult = find_min_perceived_distance(n, edges, initial_speed, multiplier, increment)\nprint(result)",
    "timestamp": "2025-08-13 08:28:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass DistortionCountry {\n    static class Edge {\n        int to;\n        long time;\n\n        Edge(int to, long time) {\n            this.to = to;\n            this.time = time;\n        }\n    }\n\n    static class State {\n        int node;\n        long dist;\n\n        State(int node, long dist) {\n            this.node = node;\n            this.dist = dist;\n        }\n    }\n\n    public static long dijkstra(int start, int n, List<Edge>[] graph, long initialSpeed) {\n        PriorityQueue<State> queue = new PriorityQueue<>(Comparator.comparingLong(a -> a.dist));\n        long[] minDist = new long[n + 1];\n        Arrays.fill(minDist, Long.MAX_VALUE);\n        queue.add(new State(start, 0));\n        minDist[start] = 0;\n\n        while (!queue.isEmpty()) {\n            State currState = queue.poll();\n            int node = currState.node;\n            long currDist = currState.dist;\n\n            if (currDist > minDist[node]) continue;\n\n            for (Edge edge : graph[node]) {\n                long nextDist = currDist + edge.time * initialSpeed;\n                if (nextDist < minDist[edge.to]) {\n                    minDist[edge.to] = nextDist;\n                    queue.add(new State(edge.to, nextDist));\n                }\n            }\n        }\n        return minDist[n];\n    }\n\n    public static long findMinimumPerceivedDistance(int n, int m, long initialSpeed, List<Edge>[] graph) {\n        long distanceToN = dijkstra(1, n, graph, initialSpeed);\n        long distanceTo1 = dijkstra(n, n, graph, initialSpeed);\n        return distanceToN + distanceTo1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        long initialSpeed = scanner.nextLong();\n\n        List<Edge>[] graph = new List[n + 1];\n        for (int i = 0; i <= n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            long time = scanner.nextLong();\n            graph[u].add(new Edge(v, time));\n        }\n\n        System.out.println(findMinimumPerceivedDistance(n, m, initialSpeed, graph));\n    }\n}",
    "timestamp": "2025-08-13 08:29:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAXN 100\n#define MAXM 10000\n#define INF INT_MAX\n\ntypedef struct {\n    int u, v, t;\n} Edge;\n\nEdge edges[MAXM];\nint dist_to_n[MAXN], dist_to_1[MAXN];\nint n, m, speed_start;\ndouble speed_factor, speed_increment;\n\nvoid dijkstra(int start, int *dist, int (*graph)[MAXN]) {\n    int visited[MAXN] = {0};\n    dist[start] = 0;\n    for (int i = 0; i < n; i++) {\n        int u = -1;\n        for (int j = 0; j < n; j++) {\n            if (!visited[j] && (u == -1 || dist[j] < dist[u])) {\n                u = j;\n            }\n        }\n        visited[u] = 1;\n        for (int v = 0; v < n; v++) {\n            if (graph[u][v] != INF && dist[u] + graph[u][v] < dist[v]) {\n                dist[v] = dist[u] + graph[u][v];\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d %lf %lf\", &n, &m, &speed_start, &speed_factor, &speed_increment);\n    \n    int graph_to_n[MAXN][MAXN], graph_to_1[MAXN][MAXN];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            graph_to_n[i][j] = graph_to_1[i][j] = INF;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].t);\n        edges[i].u--;\n        edges[i].v--;\n        graph_to_n[edges[i].u][edges[i].v] = edges[i].t;\n        graph_to_1[edges[i].v][edges[i].u] = edges[i].t;\n    }\n\n    for (int i = 0; i < n; i++) {\n        dist_to_n[i] = dist_to_1[i] = INF;\n    }\n\n    dijkstra(0, dist_to_n, graph_to_n);\n    dijkstra(n - 1, dist_to_1, graph_to_1);\n\n    double current_speed = speed_start;\n    double total_distance = 0.0;\n\n    for (int i = 1; i < n; i++) {\n        double perceived_time = dist_to_n[i] / current_speed;\n        total_distance += perceived_time * current_speed;\n        current_speed = current_speed * speed_factor + speed_increment;\n    }\n\n    for (int i = n - 2; i >= 0; i--) {\n        double perceived_time = dist_to_1[i] / current_speed;\n        total_distance += perceived_time * current_speed;\n        current_speed = current_speed * speed_factor + speed_increment;\n    }\n\n    printf(\"%.2f\\n\", total_distance);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:29:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\nfrom collections import defaultdict\nimport math\n\ndef solve_distortion_problem(n, m, edges, initial_speed):\n    graph = defaultdict(list)\n    for u, v, t, a, b in edges:\n        graph[u].append((v, t, a, b))\n    \n    def dijkstra(start, end, is_return_trip):\n        distances = [[math.inf] * 101 for _ in range(n + 1)]\n        distances[start][initial_speed] = 0\n        pq = [(0, start, initial_speed)]\n        \n        while pq:\n            dist, node, speed = heappop(pq)\n            \n            if node == end:\n                return dist\n            \n            if dist > distances[node][speed]:\n                continue\n            \n            for neighbor, time, a, b in graph[node]:\n                new_speed = min(100, max(1, speed * a + b))\n                new_dist = dist + time / speed\n                \n                if new_dist < distances[neighbor][new_speed]:\n                    distances[neighbor][new_speed] = new_dist\n                    heappush(pq, (new_dist, neighbor, new_speed))\n        \n        return math.inf\n    \n    trip_out = dijkstra(1, n, False)\n    trip_back = dijkstra(n, 1, True)\n    \n    return trip_out + trip_back if trip_out != math.inf and trip_back != math.inf else -1\n\ndef main():\n    n, m, initial_speed = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v, t, a, b = map(int, input().split())\n        edges.append((u, v, t, a, b))\n    \n    result = solve_distortion_problem(n, m, edges, initial_speed)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:29:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n+1)]\n    rev_adj = [[] for _ in range(n+1)]\n    \n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        t = int(data[idx])\n        idx += 1\n        a = float(data[idx])\n        idx += 1\n        b = float(data[idx])\n        idx += 1\n        adj[u].append((v, t, a, b))\n        rev_adj[v].append((u, t, a, b))\n    \n    def dijkstra(start, adj):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        heap = []\n        heapq.heappush(heap, (0.0, start))\n        \n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > dist[u]:\n                continue\n            for (v, t, a, b) in adj[u]:\n                new_dist = current_dist + t / (a * current_dist + b) if (a * current_dist + b) != 0 else float('inf')\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heapq.heappush(heap, (dist[v], v))\n        return dist\n    \n    dist1 = dijkstra(1, adj)\n    distn = dijkstra(n, rev_adj)\n    \n    min_total = float('inf')\n    for u in range(1, n+1):\n        if dist1[u] != float('inf') and distn[u] != float('inf'):\n            total = dist1[u] + distn[u]\n            if total < min_total:\n                min_total = total\n    \n    print(\"{0:.8f}\".format(min_total))\n\nsolve()",
    "timestamp": "2025-08-13 08:29:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int time;\n};\n\nstruct State {\n    int vertex;\n    int perceived_speed;\n    long long perceived_distance;\n    bool operator>(const State& other) const {\n        return perceived_distance > other.perceived_distance;\n    }\n};\n\nlong long find_min_perceived_distance(int n, int m, const vector<vector<Edge>>& graph, vector<int>& speed_changes) {\n    const long long INF = numeric_limits<long long>::max();\n    vector<vector<long long>> dist(n + 1, vector<long long>(101, INF));\n    priority_queue<State, vector<State>, greater<State>> pq;\n    \n    pq.push({1, speed_changes[0], 0});\n    dist[1][speed_changes[0]] = 0;\n    \n    while (!pq.empty()) {\n        State cur = pq.top();\n        pq.pop();\n\n        if (cur.perceived_distance > dist[cur.vertex][cur.perceived_speed]) {\n            continue;\n        }\n\n        for (const Edge& edge : graph[cur.vertex]) {\n            int new_speed = min(100, cur.perceived_speed + speed_changes[edge.to]);\n            long long new_distance = cur.perceived_distance + edge.time / cur.perceived_speed;\n\n            if (new_distance < dist[edge.to][new_speed]) {\n                dist[edge.to][new_speed] = new_distance;\n                pq.push({edge.to, new_speed, new_distance});\n            }\n        }\n    }\n\n    long long min_perceived_distance = INF;\n    for (int speed = 1; speed <= 100; ++speed) {\n        min_perceived_distance = min(min_perceived_distance, dist[n][speed]);\n    }\n\n    return min_perceived_distance + dist[1][1];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<Edge>> graph(n + 1);\n    vector<int> speed_changes(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> speed_changes[i];\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int u, v, t;\n        cin >> u >> v >> t;\n        graph[u].push_back({v, t});\n    }\n\n    long long result = find_min_perceived_distance(n, m, graph, speed_changes);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:46:09"
  }
]