[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n  x_size = 0; y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n  x_size = x_max + 1;\n  y_size = y_max + 1;\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  loop(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  loop(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_size, x_i) {\n    loop(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        loop_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    loop(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\n\nint N, R, w, h;\nint R_2[10001][10001];\nstd::vector<int> X1, X2, Y1, Y2, X, Y;\n\nint compress(std::vector<int>& v1, std::vector<int>& v2, std::vector<int>& v, int w){\n    REP(i, N){\n        FOR(j, -1, 2){\n            int s = v1[i] + j, t = v2[i] + j;\n            if(0 <= s && s <= 10000){\n                v.push_back(s);\n            }\n            if(0 <= t && t <= 10000){\n                v.push_back(t);\n            }\n        }\n    }\n\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end()); \n    \n    REP(i, N){\n        v1[i] = std::lower_bound(v.begin(), v.end(), v1[i]) - v.begin();\n        v2[i] = std::lower_bound(v.begin(), v.end(), v2[i]) - v.begin();\n    }\n    \n    return v.size();\n}\n\nint solve_S(){\n    int res = 0;\n    REP(i, h){\n        REP(j, w){\n            if(R_2[j][i] > 0){\n                int dX = std::abs(X[j] - X[j+1]), dY = std::abs(Y[i] - Y[i+1]);\n                res += dX * dY;\n            }\n        }\n    }\n\n    return res;\n}\n\nint solve_L(){\n    int res = 0;\n    FOR(i, -1, h+1){\n        FOR(j, -1, w+1){\n            if((i == -1 || j == -1 || i == h || j == w) || R_2[j][i] == 0){\n                REP(k, 4){\n                    int x = j + dx[k], y = i + dy[k];\n                    if(0 <= x && x < w && 0 <= y && y < h && R_2[x][y] > 0){\n                        if(dx[k] != 0){\n                            res += std::abs(Y[y] - Y[y+1]);\n                        }else{\n                            res += std::abs(X[x] - X[x+1]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> N >> R, N){\n        X1.clear();\n        X2.clear();\n        Y1.clear();\n        Y2.clear();\n        X.clear();\n        Y.clear();\n\n        REP(i, N){\n            int x1, y1, x2, y2;\n            std::cin >> x1 >> y1 >> x2 >> y2;\n\n            X1.push_back(x1);\n            X2.push_back(x2);\n            Y1.push_back(y1);\n            Y2.push_back(y2);\n        }\n\n        w = compress(X1, X2, X, N);\n        h = compress(Y1, Y2, Y, N);\n\n        REP(i, h){\n            REP(j, w){\n                R_2[j][i] = 0;\n            }\n        }\n\n        REP(i, N){\n            R_2[X1[i]][Y1[i]]++;\n            R_2[X1[i]][Y2[i]]--;\n            R_2[X2[i]][Y1[i]]--;\n            R_2[X2[i]][Y2[i]]++;\n        }\n\n        // X\n        REP(i, h){\n            FOR(j, 1, w){\n                R_2[j][i] += R_2[j-1][i];\n            }\n        }\n\n        // Y\n        REP(i, h){\n            FOR(j, 1, w){\n                R_2[i][j] += R_2[i][j-1];\n            }\n        }\n\n        // std::cout << w << \",\" << h << std::endl;\n        // REP(i, 10){\n        //     REP(j, 10){\n        //         printf(\"%d, \", R_2[j][i]);\n        //     }\n        //     puts(\"\");\n        // }\n\n        if(R == 1){\n            std::cout << solve_S() << std::endl;\n        }else{\n            std::cout << solve_S() << std::endl;\n            std::cout << solve_L() << std::endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q && n){\n\t\tvector< pair<int,int> > tr[10001] , tc[10001];\n\t\t\n\t\tint mm[100][100]={0};\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1 , y1 , x2 , y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tfor(int i = y1 ; i < y2 ; i++)\n\t\t\t\tfor(int j = x1 ; j < x2 ; j++)\n\t\t\t\t\tmm[i][j] = 1;\n\t\t\tfor(int i = y1 ; i < y2 ; i++) tr[i].push_back(make_pair(x1,x2));\n\t\t\tif(q==2) for(int i = x1 ; i < x2 ; i++) tc[i].push_back(make_pair(y1,y2));\n\t\t}\n\t\tint area = 0 , perimeter = 0;\n\t\t// merge\n\t\tfor(int i = 0 ; i < 10001 ; i++){\n\t\t\tif(tr[i].size() == 0) continue;\n\t\t\tsort(tr[i].begin(),tr[i].end());\n\t\t\tint s = tr[i][0].first , e = tr[i][0].second;\n\t\t\tfor(int j = 1 ; j < tr[i].size() ; j++){\n\t\t\t\tint S = tr[i][j].first , E = tr[i][j].second;\n\t\t\t\tif(S <= e){\n\t\t\t\t\te = max(E,e);\n\t\t\t\t}else{\n\t\t\t\t\tarea += e-s;\n\t\t\t\t\tperimeter += 2;\n\t\t\t\t\ts = S;\n\t\t\t\t\te = E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperimeter += 2;\n\t\t\tarea += e-s;\n\t\t}\n\t\t\n\t\tif(q == 2){\n\t\t\tfor(int i = 0 ; i < 10001 ; i++){\n\t\t\t\tif(tc[i].size() == 0) continue;\n\t\t\t\tsort(tc[i].begin(),tc[i].end());\n\t\t\t\tint s = tc[i][0].first , e = tc[i][0].second;\n\t\t\t\tfor(int j = 1 ; j < tc[i].size() ; j++){\n\t\t\t\t\tint S = tc[i][j].first , E = tc[i][j].second;\n\t\t\t\t\tif(S <= e){\n\t\t\t\t\t\te = E;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//cerr << s << \"|\" << e << endl;\n\t\t\t\t\t\tperimeter += 2;\n\t\t\t\t\t\t//c[i].push_back( make_pair(s,e) );\n\t\t\t\t\t\ts = S;\n\t\t\t\t\t\te = E;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cerr << s << \"|\" << e << endl;\n\t\t\t\tperimeter += 2;\n\t\t\t\t//c[i].push_back( make_pair(s,e) );\n\t\t\t}\n\t\t}\n\t\tif(q == 1){\n\t\t\tcout << area << endl;\n\t\t}else{\n\t\t\tcout << area << endl;\n\t\t\tcout << perimeter << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\n\n\nint x[N];\nvector<st> inx[N];\n//int y[N];\n//vector<st> iny[N];\n\n/*\n29\n29\n80\n45\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *X,vector<st> *IN){\n  vector<int> xd;\n  //static int xd[N];\n  int p=0;\n  rep(i,n){\n    xd.pb(x1[i]);\n    xd.pb(x2[i]);\n    //xd[p++]=x1[i];\n    //xd[p++]=x2[i];\n  }\n  sort(ALL(xd));\n  //sort(xd,xd+p);\n  xd.erase(unique(ALL(xd)),xd.end());\n  //p=unique(xd,xd+p)-xd;\n  rep(i,xd.size())X[px++]=xd[i],IN[i].clear();\n  //rep(i,p)X[px++]=xd[i],IN[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    //int j=lower_bound(xd,xd+p,x1[i])-xd;\n    while(j < px && x[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\ntypedef pair<int, int> Range;\ntypedef vector<Range> Ranges;\n\nstruct Rect{\n  int ldx, ldy;\n  int rux, ruy;\n\n  Rect(){}\n  Rect(int ldxx, int ldyy,\n       int ruxx, int ruyy) :\n    ldx(ldxx), ldy(ldyy),\n    rux(ruxx), ruy(ruyy) {}\n};\n\nbool operator < (const Rect &lhs, const Rect &rhs){\n  if(lhs.ldx != rhs.ldx) return lhs.ldx < rhs.ldx;\n  if(lhs.rux != rhs.rux) return lhs.rux < rhs.rux;\n  if(lhs.ldy != rhs.ldy) return lhs.ldy < rhs.ldy;\n  return lhs.ruy < rhs.ruy;\n}\n\ntypedef vector<Rect> Rects;\n\nvoid addRange(Ranges &dst, Range rng){\n  int idx = lower_bound(dst.begin(), dst.end(), rng) - dst.begin();\n\n  bool f1 = false;\n  bool f2 = false;\n\n  /*\n  printf(\"before: \"); REP(i,dst.size()) printf(\"(%d %d) \", dst[i].first, dst[i].second); puts(\"\");\n  */\n\n  if(idx != 0){\n    if(rng.first <= dst[idx - 1].second){\n      dst[idx - 1].second = max(dst[idx - 1].second, rng.second);\n      f1 = true;\n    }\n  }\n\n  int idx2 = idx;\n  while(idx2 != (int)dst.size() && dst[idx2].second <= rng.second) idx2++;\n\n  if(idx2 != (int)dst.size()){\n    if(dst[idx2].first <= rng.second){\n      dst[idx2].first  = rng.first;\n      dst[idx2].second = max(dst[idx2].second, rng.second);\n      f2 = true;\n    }\n  }\n\n  if(f1 && f2){\n    dst[idx - 1].second = dst[idx2].second;\n    dst.erase(dst.begin() + idx2);\n    if(idx < idx2)\n      dst.erase(dst.begin() + idx, dst.begin() + idx2);\n  }else{\n    if(idx < idx2)\n      dst.erase(dst.begin() + idx, dst.begin() + idx2);\n\n    if(!f1 && !f2)\n      dst.insert(dst.begin() + idx, rng);\n  }\n  /*\n  printf(\"add (%d %d):\\n\", rng.first, rng.second);\n  printf(\"after: \"); REP(i,dst.size()) printf(\"(%d %d) \", dst[i].first, dst[i].second); puts(\"\");\n  */\n}\n\nint rangeLength(const Ranges &rngs){\n  int ret = 0;\n  FOR(it, rngs){\n    ret += it->second - it->first;\n  }\n  return ret;\n}\n\n// from sorted rects\ntemplate<typename Use>\nRanges createRanges(const Rects &rects, const Use &use){\n  Ranges ret;\n  FOR(it, use){\n    const Rect &r = rects[*it];\n    addRange(ret, Range(r.ldy, r.ruy));\n  }\n  return ret;\n}\n\ninline void getrng(const Ranges &rngs, int &sx, int &ex, int n){\n  sx = n == (int)rngs.size() ? INT_MAX : rngs[n].first;\n  ex = n == (int)rngs.size() ? INT_MAX : rngs[n].second;\n}\n\nint diffRange(const Ranges &r1, const Ranges &r2){\n  int p1 = 0;\n  int p2 = 0;\n  int ret = 0;\n\n  int sx1, ex1, sx2, ex2;\n  getrng(r1, sx1, ex1, p1);\n  getrng(r2, sx2, ex2, p2);\n\n  while(p1 != (int)r1.size() || p2 != (int)r2.size()){\n    // printf(\" (%d %d) (%d %d) : %d\\n\", sx1, ex1, sx2, ex2, ret);\n    if(ex1 <= sx2){\n      ret += ex1 - sx1;\n      getrng(r1, sx1, ex1, ++p1);\n    }else if(ex2 <= sx1){\n      ret += ex2 - sx2;\n      getrng(r2, sx2, ex2, ++p2);\n    }else{\n      if(ex1 < ex2){\n        ret += abs(sx2 - sx1);\n        sx2 = ex1;\n        getrng(r1, sx1, ex1, ++p1);\n      }else{\n        ret += abs(sx1 - sx2);\n        sx1 = ex2;\n        getrng(r2, sx2, ex2, ++p2);\n      }\n    }\n  }\n\n  return ret;\n}\n\nenum Event{\n  ADD = 0,\n  DEL = 1\n};\n\n// must be sorted\npair<int, int> calc(const Rects &rects){\n  const int n = rects.size();\n  vector<pair<int, pair<int, int> > > events(2 * n);\n\n  int minx = INT_MAX;\n  int maxx = 0;\n\n  REP(i,n){\n    events[2 * i].first = rects[i].ldx;\n    events[2 * i].second.first  = i;\n    events[2 * i].second.second = ADD;\n    minx = min(minx, rects[i].ldx);\n\n    events[2 * i + 1].first = rects[i].rux;\n    events[2 * i + 1].second.first  = i;\n    events[2 * i + 1].second.second = DEL;\n    maxx = max(maxx, rects[i].rux);\n  }\n\n  sort(events.begin(), events.end());\n\n  int ptr = 0;\n\n  int men = 0;\n  int shu = 0;\n  Ranges rngs;\n  int len = 0;\n  int px  = 0;\n  set<int> use;\n\n  while(ptr != 2 * n){\n    int xx = events[ptr].first;\n\n    // update ans\n    men += len * (xx - px);\n    shu += 2 * rngs.size() * (xx - px);\n\n    // update others\n    px = xx;\n\n    while(ptr != 2 * n && events[ptr].first == xx){\n      int id = events[ptr].second.first;\n      int tp = events[ptr].second.second;\n\n      if(tp == ADD) use.insert(id);\n      else use.erase(id);\n\n      ptr++;\n    }\n\n    Ranges rtmp = createRanges(rects, use);\n    // printf(\" diffRange = %d\\n\", diffRange(rtmp, rngs));\n    shu += diffRange(rtmp, rngs);\n    rngs.swap(rtmp);\n    len = rangeLength(rngs);\n\n    /*\n    printf(\"x = %d: (%d, %d) len = %d\\n\", px, men, shu, len);\n    REP(i,rngs.size()){\n      printf(\" [%d, %d]\\n\", rngs[i].first, rngs[i].second);\n    }\n    */\n  }\n\n  return make_pair(men, shu);\n}\n\nint main(){\n  while(true){\n    const int n = getInt();\n    const int r = getInt();\n\n    if(n + r == 0) break;\n\n    Rects rects(n);\n\n    REP(i,n){\n      rects[i].ldx = getInt();\n      rects[i].ldy = getInt();\n      rects[i].rux = getInt();\n      rects[i].ruy = getInt();\n    }\n\n    sort(rects.begin(), rects.end());\n    const pair<int, int> ret = calc(rects);\n\n    printf(\"%d\\n\", ret.first);\n    if(r == 2)\n      printf(\"%d\\n\", ret.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nusing namespace std;\nint x_size, y_size;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<int, vector<tuple<int, int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n  x_size = 0; y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n  x_size = x_max + 1;\n  y_size = y_max + 1;\n\n  if (sheets.count(x1) == 0) {\n    sheets[x1] = {{y1, x2, y2}};\n  } else {\n    sheets[x1].push_back({y1, x2, y2});\n  }\n}\nvector<tuple<int, int, int>>& find_end_points(int x, int y) {\n  return sheets[x];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  loop(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  loop(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_size, x_i) {\n    // update right_area_end_point\n    auto& points = find_end_points(x_i, 0);\n\n    // per point operation\n    for (auto&& point : points) {\n      int y_i = get<0>(point), x = get<1>(point), y = get<2>(point);\n\n      loop_from_to(y_i, y - 1, p_i) {\n        assign_if_larger(right_area_end_point[p_i], x);\n      }\n    }\n\n    loop(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\nvector<T> coner;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(cin >> n >> r, n | r){\n\tmemset(imos, 0, sizeof(imos));\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 10400;\n\tright_side = top = 1;\n\tconer.clear();\n\tfor(int i = 0;i < n;i++){\n\t    cin >> ax >> ay >> bx >> by;\n\n\t    \n\t    coner.push_back(T(P(++ax, ++ay), 1));\n\t    coner.push_back(T(P(++bx, ++by), 1));\n\t    coner.push_back(T(P(bx, ay), -1));\n\t    coner.push_back(T(P(ax, by), -1));\n\t}\n\tconer.push_back(T(P(INF, INF), 0));\n\tsort(coner.begin(), coner.end());\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(coner[p].first == P(i, j)){\n\t\t    imos[i % 3][j] += coner[p++].second;\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tcout << area << endl;\n\tif(r == 2)cout << round << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main(){\n\nint map[103][103]={};\n\nint H1,W1,H2,W2;\nint n,m;\nwhile(1){\nscanf(\"%d %d\",&n,&m);\nif(n==0&&m==0)break;\nfor(int iii=0;iii<n;iii++){\nscanf(\"%d %d %d %d\",&W1,&H1,&W2,&H2);\nfor(int i=H1+1;i<H2+1;i++)\nfor(int j=W1+1;j<W2+1;j++)\nmap[i][j]=1;\n}\n\nint c=0;\nfor(int i=1;i<101;i++)\nfor(int j=1;j<101;j++)\nif(map[i][j]==1)c++;\n\nint cc=0;\n\nfor(int i=1;i<101;i++)\nfor(int j=1;j<101;j++)\n{\nif(map[i][j]==1){\nif(map[i+1][j]==0)cc++;\nif(map[i-1][j]==0)cc++;\nif(map[i][j+1]==0)cc++;\nif(map[i][j-1]==0)cc++;\n\n\n}\n}\n\n\nprintf(\"%d\\n\",c);\nif(m==2)printf(\"%d\\n\",cc);\n\nfor(int i=1;i<101;i++)\nfor(int j=1;j<101;j++)\n\tmap[i][j]=0;\n\n}\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct Event {\n  int t;\n  int x1,x2,y;\n  bool operator<(const Event &b) const {\n    return y < b.y;\n  }\n} event[200000];\n\nint table[100005];\nbool flag[2][100005];\n\nint main() {\n  int n,r;\n  while(cin>>n>>r,n||r) {\n    int W = 0;\n    int H = 0;\n    REP(i,n) {\n      int x,y,p,q;\n      cin>>x>>y>>p>>q;\n      x++;y++;p++;q++;\n      W = max(W,p);\n      H = max(H,q);\n      event[i*2]   = (Event){+1,x,p,y};\n      event[i*2+1] = (Event){-1,x,p,q};\n    }\n    sort(event,event+2*n);\n    memset(table,0,sizeof(table));\n    int id = 0;\n    int a = 0;\n    int b = 0;\n    bool *cur = flag[0];\n    bool *pre = flag[1];\n    for (int y=1; y<=H+1; ++y) {\n      for (;id<2*n&&event[id].y==y;++id)\n        for (int x=event[id].x1; x<event[id].x2; ++x)\n          table[x] += event[id].t;\n      for (int i=1; i<W; ++i) cur[i] = !!table[i];\n      for (int i=1; i<=W; ++i) {\n        a += cur[i];\n        if (cur[i-1] ^ cur[i]) b++;\n        if (pre[i] ^ cur[i]) b++;\n      }\n      swap(cur,pre);\n    }\n    cout << a << endl;\n    if (r == 2) cout << b << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include <tuple>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nshort map[10001];\nshort state_before[10001];\nshort map_before[10001];\n\nstd::vector< tuple< int,int,int> > points;\n\n\n\nvoid read_points(int tate){\n    memcpy(map_before,map,sizeof map);\n    memset(map,0,sizeof(map));    \n    for(int i=0;i<points.size();i++){\n        auto tmp=points.at(i);\n        if(get<0>(tmp)==tate){\n            map[get<1>(tmp)]+=get<2>(tmp);\n            //printf(\"%d,%d,%d\\n\",get<0>(tmp),get<1>(tmp),get<2>(tmp));\n        }\n    }\n}\nint main(){\n    \n    int n,r;\n    \n    int S=0;\n    int L=0;\n\n  \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n        \n        points.clear();\n        int x1,y1,x2,y2;\n        int max_x=0,min_x=10000,max_y=0,min_y=10000;\n        for(int i=0;i<n;i++){\n            cin>>x1>>y1>>x2>>y2;\n            tuple<int,int,int> tl=make_tuple(y1,x1,1);\n            tuple<int,int,int> tr=make_tuple(y1,x2,-1);\n            tuple<int,int,int> bl=make_tuple(y2,x1,-1);\n            tuple<int,int,int> br=make_tuple(y2,x2,1);\n            points.push_back(tl);\n            points.push_back(tr);\n            points.push_back(bl);\n            points.push_back(br);\n            if(max_x<x2)max_x=x2;\n            if(max_y<y2)max_y=y2;\n            if(min_x>x1)min_x=x1;\n            if(min_y>y1)min_y=y1;\n            \n        }\n        \n        \n        S=0;\n        L=0;\n        for(int h=min_y;h<=max_y;h++){\n            \n            read_points(h);\n            int yoko_state=0;\n            for(int w=min_x;w<=max_x;w++){\n                \n                \n                yoko_state+=map[w];\n                map[w]=yoko_state;\n                if(h!=0){\n                    map[w]+=state_before[w];\n                }\n                state_before[w]=map[w];\n                //printf(\"%2d \",map[w]);\n                if(map[w]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(map[w-1]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(map_before[w]==0)L+=2;\n                }\n                \n                \n            }\n            //cout<<endl;\n            \n        }\n\n\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint map[10003][10003];\n\nint main(void){\n\twhile(1){\n\t\tint n,r,ans=0,ans2=0;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tmap[x1+2][y1+1]-=1;\n\t\t\tmap[x2+2][y1+1]+=1;\n\t\t\tmap[x1+2][y2+1]+=1;\n\t\t\tmap[x2+2][y2+1]-=1;\n\t\t}\n\t\tfor(int i=0;i<=10001;i++){\n\t\t\tfor(int j=1;j<=10001;j++){\n\t\t\t\tmap[j][i]=map[j][i]+map[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=10001;i++){\n\t\t\tfor(int j=10001;j>=0;j--){\n\t\t\t\tmap[i][j]=map[i][j]+map[i][j+1];\n\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=0;i<=10001;i++){\n\t\t\t\tfor(int j=0;j<=10001;j++){\n\t\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\t\tif(map[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint main()\n{\nint n,m;\nwhile(1)\n{\n\tvector<P>y[10005];\n\tvector<P>z[10005];\n\tscanf(\"%d %d\",&n,&m); if(!n) return 0;\n\tint lim=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tfor(int j=b;j<d;j++)\n\t\t{\n\t\t\ty[j].pb(mp(a,c));\n\t\t}\n\t\tlim=max(lim,d-1);\n\t}\n\tfor(int i=0;i<10005;i++) sort(y[i].begin(),y[i].end());\n\tint ret=0,ret2=0;\n\tint prev=INF;\n\tvector<P>prev2(0);\n\tfor(int i=0;i<=lim;i++)\n\t{\n\t\tif(y[i].empty()) continue;\n\t\tint beg=y[i][0].first;\n\t\tint en=y[i][0].second;\n\t\ty[i].pb(mp(INF,INF));\n\t\tfor(int j=1;j<y[i].size();j++)\n\t\t{\n\n\t\t\tif(en<y[i][j].first)\n\t\t\t{//cout << beg << \" \" << en << endl;\n\n\t\t\t\tz[i].pb(mp(beg,en));\n\t\t\t\tret+=(en-beg); ret2+=2; //cout << 2 << \"HB\" <<endl;\n\t\t\t\tif(i==lim) ret2+=(en-beg);\n\t\t\t\tif(prev!=i-1)\n\t\t\t\t{\n\t\t\t\t\tret2+=(en-beg); //cout << en-beg << \"HB\" <<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret2+=(en-beg);\n\t\t\t\t\tfor(int cur=0;cur<prev2.size();cur++)\n\t\t\t\t\t{\n//cout << prev2[cur].first << \" \" << prev2[cur].second << endl;\n\t\t\t\t\t\tret2-=(max(0,min(en,prev2[cur].second)-max(beg,prev2[cur].first))*2);\n//cout << -(max(0,min(en,prev2[cur].second)-max(beg,prev2[cur].first))*2) << \"HB\" <<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbeg=y[i][j].first;\n\t\t\t\ten=y[i][j].second;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(y[i][j].second<=en)\n\t\t\t\t{\n\t\t\t\t\ten=max(en,y[i][j].second);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ten=max(en,y[i][j].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int cur=0;cur<prev2.size();cur++)\n\t\t{//if(i==lim) cout << (prev2[cur].second-prev2[cur].first) << \"HB\" <<endl;\n\t\t\tret2+=(prev2[cur].second-prev2[cur].first);\n\n\t\t}\n//printf(\"%d\\n\",ret2);\n\t\ty[i].clear();\n\t\tprev=i;\n\t\tprev2=z[i]; z[i].clear();\n\t}\n\tprintf(\"%d\\n\",ret);\n\tif(m==2) printf(\"%d\\n\",ret2);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tg[x1][y1]+=1;\n\t\t\tg[x2][y1]-=1;\n\t\t\tg[x1][y2]-=1;\n\t\t\tg[x2][y2]+=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> >in;\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<P>vx[10001],vy[10001];\n\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n      in.clear();\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\n//const long long int INF_=1<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint min_x,min_y,max_x,max_y;\n\ninline void Imos(vector<vector<short> > &plane){\n\tREP(y,0,plane[0].size()){\n\t\tREP(x,1,plane.size()){\n\t\t\tplane[x][y]+=plane[x-1][y];\n\t\t}\n\t}\n\tREP(x,0,plane.size()){\n\t\tfor(int y=plane[0].size()-2; y>=0; --y){\n\t\t\tplane[x][y]+=plane[x][y+1];\n\t\t}\n\t}\n}\n\ninline int CalcSize(vector<vector<short> > &plane){\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(plane[x][y]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(vector<vector<short> > &plane,vector<vector<bool> > &has_done,int x,int y,int W,int H){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[x][y]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[nx][ny]){\n\t\t\t\tif(plane[nx][ny]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[nx][ny]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t\t//cout << result << ' ' << p.F_ << ' ' << p.S_ << endl;\n\t}\n\treturn result;\n}\n\ninline int CalcLength(vector<vector<short> > &plane){\n\tvector<vector<bool> > has_done(plane.size(),vector<bool>(plane[0].size()));\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(!has_done[x][y]&&plane[x][y]>0){\n\t\t\t\tresult+=BFS(plane,has_done,x,y,plane.size(),plane[0].size());\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tX[j].push_back(x);\n\t\t\t\tY[j].push_back(y);\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\tvector<vector<short> > plane(max_x+4-min_x,vector<short>(max_y+4-min_y));\n\t\tREP(i,0,N){\n\t\t\tplane[X[0][i]+1-min_x][Y[1][i]+1-min_y]+=1;\n\t\t\tplane[X[1][i]+2-min_x][Y[0][i]-min_y]+=1;\n\t\t\tplane[X[0][i]+1-min_x][Y[0][i]-min_y]+=-1;\n\t\t\tplane[X[1][i]+2-min_x][Y[1][i]+1-min_y]+=-1;\n\t\t}\n\t\tImos(plane);\n\t\t/*\n\t\tfor(int y=plane[0].size()-1; y>=0; --y){\n\t\t\tREP(x,0,plane.size()){\n\t\t\t\tcout << plane[x][y] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << CalcSize(plane) << endl;\n\t\tif(R==2) cout << CalcLength(plane) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 100\nint mem[MAXN+5][MAXN+5]={{0}};\nint main(void){\n  int n=0;\n  int r=0;\n  const int muki[8]={0,1,0,-1,1,0,-1,0};\n  scanf(\"%d%d\",&n,&r);\n  while(n!=0){\n    memset(mem,0,sizeof(mem));\n    int i,a,b,c,d;\n    for(i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n      a++;b++;c++;d++;\n      mem[a][b]+=1;\n      mem[c][d]+=1;\n      mem[a][d]+=-1;\n      mem[c][b]+=-1;\n      }\n    int j=0;\n    for(i=0;i<MAXN+1;i++){\n      for(j=1;j<MAXN+1;j++){\n\tmem[i][j]+=mem[i][j-1];\n      }\n    }\n    for(j=0;j<MAXN+1;j++){\n      for(i=1;i<MAXN+1;i++){\n\tmem[i][j]+=mem[i-1][j];\n      }\n    }\n    int ansa=0;\n    int ansb=0;\n    for(i=1;i<MAXN+1;i++){\n      for(j=1;j<MAXN+1;j++){\n\tif(mem[i][j]>0){\n\t  ansa+=1;\n\t  //printf(\"%d%d\\n\",i,j);\n\t  for(a=0;a<4;a++){\n\t    b=i+muki[a];c=j+muki[a+4];\n\t    if(mem[b][c]==0){\n\t      ansb++;\n\t    }\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ansa);\n    if(r==2){printf(\"%d\\n\",ansb);}\n    scanf(\"%d%d\",&n,&r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        //bool *map;\n        bool** map;\n        map=new bool*[10001];\n        for(int w=0;w<=10000;w++){\n            map[w] = new bool[10001];\n        }\n        //bool map[10001][10001];\n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            for(int w=x1;w<x2;w++){\n                for(int h=y1;h<y2;h++){\n                    map[w][h]=true;\n                }\n            }\n        }\n        int S=0;\n        int L=0;\n        bool old=false;\n        for(int w=0;w<=10000;w++){\n            old=false;\n            for(int h=0;h<=10000;h++){\n                if(map[w][h]){S++;}\n                if(old!=map[w][h]){L++;}\n                old=map[w][h];\n            }\n            if(old==true){L++;}\n        }\n        for(int h=0;h<=10000;h++){\n            old=false;\n           for(int w=0;w<=10000;w++){\n                if(old!=map[w][h]){L++;}\n                old=map[w][h];\n            }\n            if(old==true){L++;}\n        }\n        \n        cout<<S<<endl;\n        if(r==2){\n            std::cout << L << std::endl;\n        }\n\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, r;\n        cin >> n >> r;\n        if(n == 0)\n            return 0;\n\n        int sy = INT_MAX;\n        int sx = INT_MAX;\n        int gy = INT_MIN;\n        int gx = INT_MIN;\n        vector<int> x1(n), y1(n), x2(n), y2(n);\n        for(int i=0; i<n; ++i){\n            cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n            sy = min(sy, y1[i]);\n            sx = min(sx, x1[i]);\n            gy = max(gy, y2[i]);\n            gx = max(gx, x2[i]);\n        }\n\n        int ret1 = 0;\n        int ret2 = 0;\n        for(int a=0; a<11; ++a){\n            for(int b=0; b<11; ++b){\n                int yMin = a * 1000 - 1;\n                int yMax = (a+1) * 1000 - 1;\n                int xMin = b * 1000 - 1;\n                int xMax = (b+1) * 1000 - 1;\n\n                if(gy < yMin || gx < xMin || sy > yMax || sx > yMax)\n                    continue;\n\n                vector<vector<int> > s(1001, vector<int>(1001, 0));\n                for(int i=0; i<n; ++i){\n                    if(y2[i] < yMin || x2[i] < xMin || y1[i] > yMax || x1[i] > xMax)\n                        continue;\n\n                    ++ s[max(yMin, y1[i])-yMin][max(xMin, x1[i])-xMin];\n                    if(x2[i] <= xMax)\n                        -- s[max(yMin, y1[i])-yMin][x2[i]-xMin];\n                    if(y2[i] <= yMax)\n                        -- s[y2[i]-yMin][max(xMin, x1[i])-xMin];\n                    if(y2[i] <= yMax && x2[i] <= xMax)\n                        ++ s[y2[i]-yMin][x2[i]-xMin];\n                }\n\n                for(int i=0; i<1001; ++i){\n                    for(int j=0; j<1000; ++j){\n                        s[i][j+1] += s[i][j];\n                    }\n                }\n                for(int i=0; i<1001; ++i){\n                    for(int j=0; j<1000; ++j){\n                        s[j+1][i] += s[j][i];\n                    }\n                }\n\n                for(int i=0; i<1000; ++i){\n                    for(int j=0; j<1000; ++j){\n                        if(s[i][j] > 0)\n                            ++ ret1;\n                        if((s[i][j] > 0) ^ (s[i+1][j] > 0))\n                            ++ ret2;\n                        if((s[i][j] > 0) ^ (s[i][j+1] > 0))\n                            ++ ret2;\n                    }\n                }\n            }\n        }\n\n        cout << ret1 << endl;\n        if(r == 2)\n            cout << ret2 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[4000][4000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int n, r;\n  while (cin >> n >> r, n | r) {\n    vector<int> x1(n), y1(n), x2(n), y2(n);\n    for (int i = 0; i < n; ++i) {\n      cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n      ++x1[i]; ++y1[i]; ++x2[i]; ++y2[i];\n    }\n    int W = *max_element(ALL(x2)) + 1;\n    int H = *max_element(ALL(y2)) + 1;\n\n    vector<vector<bool>> field(H, vector<bool>(W, false));\n    for (int i = 0; i < n; ++i)\n      for (int y = y1[i]; y < y2[i]; ++y)\n        fill(begin(field[y]) + x1[i], begin(field[y]) + x2[i], true);\n\n    if (r == 1) {\n      int ans = 0;\n      for (int y = 0; y < H; ++y)\n        ans += count(ALL(field[y]), true);\n      cout << ans << endl;\n    } else {\n      int ansS = 0, ansL = 0;\n      for (int y = 1; y < H; ++y) {\n        for (int x = 1; x < W; ++x) {\n          int b = field[y][x];\n          ansS += b;\n          ansL += (field[y][x-1] ^ b) + (field[y-1][x] ^ b);\n        }\n      }\n      cout << ansS << endl << ansL << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[11111];\nvector<P> xx[11111];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 11111; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tx[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n      /*\n      cout << \"x = \" << i << endl;\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tcout << \"( \" << xx[i][j].F << \" , \" << xx[i][j].S << \" )\" << endl;\n      }\n      cout << endl;\n      //*/\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint max(int* arr) {\n  int max = arr[0];\n  cout << \"sizeof: \" << sizeof(arr)/sizeof(arr[0]) << endl;\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (max < arr[i]) max = arr[i];\n  }\n  return max;\n}\n\nint min(int* arr) {\n  int min = arr[0];\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (min > arr[i]) min = arr[i];\n  }\n  return min;\n}\n\nint main(int argc, char const* argv[])\n{\n  ifstream ifs(\"input.txt\");\n  int count, type;\n  int *x1, *y1, *x2, *y2;\n  int left, bottom, right, top;\n  while (ifs >> count >> type) {\n    cout << \"count: \" << count << endl;\n    x1 = new int[count];\n    y1 = new int[count];\n    x2 = new int[count];\n    y2 = new int[count];\n    \n    // input\n    for (int i = 0; i < count; i++) {\n      ifs >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n\n    // field\n    left = min(x1);\n    bottom = min(y1);\n    right = max(x2);\n    top = max(y2);\n\n    cout << \"left:\"   << left   << endl;\n    cout << \"bottom:\" << bottom << endl;\n    cout << \"right:\"  << right  << endl;\n    cout << \"top:\"    << top    << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    int x[10000][2],y[10000][2];\n    vector<int> vx(2),vy(2);\n    vx[0]=vy[0]=-1;\n    vx[1]=vy[1]=10001;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<2;j++){\n\tcin>>x[i][j]>>y[i][j];\n\tvx.push_back(x[i][j]);\n\tvy.push_back(y[i][j]);\n      }\n    }\n    sort(vx.begin(),vx.end());\n    vx.erase(unique(vx.begin(),vx.end()),vx.end());\n    sort(vy.begin(),vy.end());\n    vy.erase(unique(vy.begin(),vy.end()),vy.end());\n    vector<vector<bool> > v(vy.size()-1,vector<bool>(vx.size()-1));\n    for(int i=0;i<n;i++){\n      for(int j=lower_bound(vy.begin(),vy.end(),y[i][0])-vy.begin();j<lower_bound(vy.begin(),vy.end(),y[i][1])-vy.begin();j++){\n\tfor(int k=lower_bound(vx.begin(),vx.end(),x[i][0])-vx.begin();k<lower_bound(vx.begin(),vx.end(),x[i][1])-vx.begin();k++){\n\t  v[j][k]=true;\n\t}\n      }\n    }\n    int a=0;\n    for(int i=0;i<v.size();i++){\n      for(int j=0;j<v[i].size();j++){\n\tif(v[i][j]){\n\t  a+=(vy[i+1]-vy[i])*(vx[j+1]-vx[j]);\n\t}\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j+1<v[i].size();j++){\n\t  if(v[i][j]^v[i][j+1]){\n\t    l+=vy[i+1]-vy[i];\n\t  }\n\t}\n      }\n      for(int i=0;i<v[0].size();i++){\n\tfor(int j=0;j+1<v.size();j++){\n\t  if(v[j][i]^v[j+1][i]){\n\t    l+=vx[i+1]-vx[i];\n\t  }\n\t}\n      }\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint max(int* arr) {\n  int max = arr[0];\n  cout << \"sizeof: \" << sizeof(arr)/sizeof(arr[0]) << endl;\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (max < arr[i]) max = arr[i];\n  }\n  return max;\n}\n\nint min(int* arr) {\n  int min = arr[0];\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (min > arr[i]) min = arr[i];\n  }\n  return min;\n}\n\nint main(int argc, char const* argv[])\n{\n  ifstream ifs(\"input.txt\");\n  int count, type;\n  int *x1, *y1, *x2, *y2;\n  int left, bottom, right, top;\n  while (ifs >> count >> type) {\n    cout << \"count: \" << count << endl;\n    x1 = new int[count];\n    y1 = new int[count];\n    x2 = new int[count];\n    y2 = new int[count];\n    \n    // input\n    for (int i = 0; i < count; i++) {\n      ifs >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n\n    // field\n    left = min(x1);\n    bottom = min(y1);\n    right = max(x2);\n    top = max(y2);\n\n    cout << \"left:\"   << left   << endl;\n    cout << \"bottom:\" << bottom << endl;\n    cout << \"right:\"  << right  << endl;\n    cout << \"top:\"    << top    << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint a[10010][10010];\n\nint main() {\n  while (true) {\n    int n, r;\n    cin >> n >> r;\n    if (n == 0 && r == 0) break;\n    memset(a, 0, sizeof(a));\n    rep (i, n) {\n      int x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      ++x1, ++y1, ++x2, ++y2;\n      ++a[x1][y1];\n      --a[x1][y2];\n      --a[x2][y1];\n      ++a[x2][y2];\n    }\n    rep (i, 10005) rep (j, 10005) a[i][j + 1] += a[i][j];\n    rep (i, 10005) rep (j, 10005) a[i + 1][j] += a[i][j];\n    int res = 0;\n    rep (i, 10005) rep (j, 10005) if (a[i][j]) ++res;\n    cout << res << endl;\n    if (r == 2) {\n      res = 0;\n      int dx[] = {1, 0, -1, 0};\n      int dy[] = {0, 1, 0, -1};\n      rep (i, 10005) rep (j, 10005) if (a[i + 1][j + 1]) rep (k, 4) if (!a[i + dy[k] + 1][j + dx[k] + 1]) ++res;\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        int** map;\n        map=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            map[w] = new int[10001];\n        }\n        \n        int** imos;\n        imos=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            imos[w] = new int[10001];\n        }\n        \n        int max=0;\n       \n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n            if(x2>max)max=x2;\n            if(y2>max)max=y2;\n        }\n\n        int S=0;\n        int L=0;\n        for(int h=0;h<=10000;h++){\n            int state=0;\n           for(int w=0;w<=10000;w++){\n               int res=0;\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n\n        cout<<S<<endl;\n        if(r==2)cout<<L<<endl;\n        \n        for(int w=0;w<=10000;w++){\n            delete map[w];\n        }\n        \n        for(int w=0;w<=10000;w++){\n            delete imos[w] ;\n        }\n        delete imos;\n        delete map;\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint main()\n{\nint n,m;\nwhile(1)\n{\n\tvector<P>y[10005];\n\tvector<P>z[10005];\n\tscanf(\"%d %d\",&n,&m); if(!n) return 0;\n\tint lim=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tfor(int j=b;j<d;j++)\n\t\t{\n\t\t\ty[j].pb(mp(a,c));\n\t\t}\n\t\tlim=max(lim,d-1);\n\t}\n\tfor(int i=0;i<10005;i++) sort(y[i].begin(),y[i].end());\n\tint ret=0,ret2=0;\n\tint prev=INF;\n\tvector<P>prev2(0);\n\tfor(int i=0;i<=lim;i++)\n\t{\n\t\tif(y[i].empty()) continue;\n\t\tint beg=y[i][0].first;\n\t\tint en=y[i][0].second;\n\t\ty[i].pb(mp(INF,INF));\n\t\tfor(int j=1;j<y[i].size();j++)\n\t\t{\n\n\t\t\tif(en<y[i][j].first)\n\t\t\t{//cout << beg << \" \" << en << endl;\n\n\t\t\t\tz[i].pb(mp(beg,en));\n\t\t\t\tret+=(en-beg); ret2+=2; //cout << 2 << \"HB\" <<endl;\n\t\t\t\tif(i==lim) ret2+=(en-beg);\n\t\t\t\tif(prev!=i-1)\n\t\t\t\t{\n\t\t\t\t\tret2+=(en-beg); //cout << en-beg << \"HB\" <<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret2+=(en-beg);\n\t\t\t\t\tfor(int cur=0;cur<prev2.size();cur++)\n\t\t\t\t\t{\n//cout << prev2[cur].first << \" \" << prev2[cur].second << endl;\n\t\t\t\t\t\tret2-=(max(0,min(en,prev2[cur].second)-max(beg,prev2[cur].first))*2);\n//cout << -(max(0,min(en,prev2[cur].second)-max(beg,prev2[cur].first))*2) << \"HB\" <<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbeg=y[i][j].first;\n\t\t\t\ten=y[i][j].second;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(y[i][j].second<=en)\n\t\t\t\t{\n\t\t\t\t\ten=max(en,y[i][j].second);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ten=max(en,y[i][j].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int cur=0;cur<prev2.size();cur++)\n\t\t{//if(i==lim) cout << (prev2[cur].second-prev2[cur].first) << \"HB\" <<endl;\n\t\t\tret2+=(prev2[cur].second-prev2[cur].first);\n\n\t\t}\n//printf(\"%d\\n\",ret2);\n\t\ty[i].pop_back();\n\t\tprev=i;\n\t\tprev2=z[i];\n\t}\n\tprintf(\"%d\\n\",ret);\n\tif(m==2) printf(\"%d\\n\",ret2);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <tuple>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nusing namespace std;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<int, vector<tuple<int, int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n\n  auto t = make_tuple(y1, x2, y2);\n  if (sheets.count(x1) == 0) {\n    sheets[x1] = {t};\n  } else {\n    sheets[x1].push_back(t);\n  }\n}\n\nvector<tuple<int, int, int>>& find_end_points(int x, int y) {\n  return sheets[x];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_max + 1];\n  loop(y_max + 1, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_max + 1];\n  is_area[1] = new bool[y_max + 1];\n  loop(y_max + 1, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_max + 1, x_i) {\n    // update right_area_end_point\n    auto& points = find_end_points(x_i, 0);\n\n    // per point operation\n    for (auto&& point : points) {\n      int y_i = get<0>(point), x = get<1>(point), y = get<2>(point);\n\n      loop_from_to(y_i, y - 1, p_i) {\n        assign_if_larger(right_area_end_point[p_i], x);\n      }\n    }\n\n    loop(y_max + 1, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define INF 2000000000\n#define LLINF 4000000000000000000\n#define SIZE 10002\n\nint mm[SIZE][SIZE];\nint mo[5] = {0,1,0,-1,0};\nvoid calc(int n,int r){\n    int x_1,x_2,y_1,y_2,minx=0,maxx=SIZE-1,miny=0,maxy=SIZE-1;\n    int ansV,ansL;\n    \n    memset(mm,0,sizeof(mm));\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d%d\",&x_1,&y_1,&x_2,&y_2);\n        \n        x_1++;\n        y_1++;\n        x_2++;\n        y_2++;\n        \n        mm[x_1][y_1]++;\n        mm[x_2][y_1]--;\n        mm[x_1][y_2]--;\n        mm[x_2][y_2]++;\n        \n        minx = min(minx,x_1);\n        miny = min(miny,y_1);\n        maxx = max(maxx,x_2);\n        maxy = max(maxy,y_2);\n    }\n    \n    for(int i=miny;i<=maxy;i++){\n        for(int j=minx+1;j<=maxx;j++){\n            mm[j][i]+=mm[j-1][i];\n        }\n    }\n    \n    for(int i=miny;i<=maxy;i++){\n        for(int j=minx+1;j<=maxx;j++){\n            mm[i][j]+=mm[i][j-1];\n        }\n    }\n    \n    for(int i=miny;i<maxy;i++){\n        for(int j=minx;j<maxx;j++){\n            if(mm[i][j]>0){\n                ansV++;\n                \n                for(int k=0;k<4;k++){\n                    if(mm[i+mo[k]][j+mo[k+1]]==0){\n                        ansL++;\n                    }\n                }\n                \n            }\n        }\n    }\n    \n    printf(\"%d\\n\",ansV);\n    \n    if(r==2)\n        printf(\"%d\\n\",ansL);\n    \n    return;\n}\n\nint main(){\n    int n,r;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&r);\n        if(n==0) break;\n        calc(n,r);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tmemset(g,0,sizeof(g));\n\t\tint mx = 10001,Mx = 1,my = 10001,My = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\ta++;b++;c++;d++;\n\t\t\tg[a][b]++; g[a][d]--;\n\t\t\tg[c][b]--; g[c][d]++;\n\t\t\tmx = min(mx,a);\n\t\t\tMx = max(Mx,c);\n\t\t\tmy = min(my,b);\n\t\t\tMy = max(My,d);\n\t\t}\n\t\t\n\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\tint t = 0;\n\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tg[i][j] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s = 0;\n\t\tfor(int j = my; j <= My; j++){\n\t\t\tint t = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tif(g[i][j] = t)s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t\t\n\t\tif(r==2){\n\t\t\tint l = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\t\tif(g[i][j]){\n\t\t\t\t\t\tl += !g[i-1][j]+!g[i+1][j]+!g[i][j-1]+!g[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nshort fie[3800][3800];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint datax[10001][10001];\nint main() {\n        int N, R;\n        while( cin >> N >> R, N || R ) {\n                memset( datax, 0, sizeof( datax ) );\n                int mx = 10001,Mx = 1, my = 10001, My = 1;\n                for( size_t i = 0; i < N; i++ ) {\n                        int x1, x2, y1, y2;\n                        cin >> x1 >> y1 >> x2 >> y2;\n                        datax[x1][y1]++;\n                        datax[x2][y2]++;\n                        datax[x1][y2]--;\n                        datax[x2][y1]--;\n                        mx = min(mx, x1);\n                        Mx = max(Mx, x2);\n                        my = min(my, y1);\n                        My = max(My, y2);\n                }\n\n                for( size_t i = mx; i <= Mx; i++ ) {\n                        for( size_t j = my; j <= My; j++ ) {\n                                datax[i + 1][j] += datax[i][j];\n                        }\n                }\n                for( size_t j = my; j <= My; j++ ) {\n                        for( size_t i = mx; i <= Mx; i++ ) {\n                                datax[i][j + 1] += datax[i][j];\n                        }\n                }\n                long long int ans = 0;\n\n                for( size_t i = mx; i <= Mx; i++ ) {\n                        for( size_t j = my; j <= My; j++ ) {\n                                if( datax[i][j] ) {\n                                        ans++;\n                                        //cout << i << \" \" << j << \" \" << datax[i][j] << endl;\n                                }\n                        }\n                }\n                cout << ans << endl;\n                ans = 0;\n                if( R == 2 ) {\n                        for( size_t i = mx; i <= Mx; i++ ) {\n                                if( datax[i][0] != 0 ) {\n                                        ans++;\n                                }\n                        }\n                        for( size_t i = my; i <= My; i++ ) {\n                                if( datax[0][i] != 0 ) {\n                                        ans++;\n                                }\n                        }\n                        for( size_t i = mx; i <= Mx; i++ ) {\n                                for( size_t j = my; j <= My; j++ ) {\n                                        if( datax[i][j] * datax[i][j + 1] == 0 && datax[i][j] != datax[i][j + 1] ) {\n                                                ans++;\n                                        }\n                                        if( datax[i][j] * datax[i + 1][j] == 0 && datax[i][j] != datax[i + 1][j] ) {\n                                                ans++;\n                                        }\n                                }\n                        }\n                        cout << ans << endl;\n                }\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (beg != a.beg)return beg < a.beg;\n  return end < a.end;\n}\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,req[j]){\n\tif (y1[i] <= IN[j][k].beg && IN[j][k].end <= y2[i]){\n\t  isin=true;\n\t  IN[j][k].beg=y1[i];\n\t  IN[j][k].end=y2[i];\n\t  break;\n\t}\n      }\n      if (!isin)IN[j].pb((st){y1[i],y2[i]});\n      j++;\n    }\n  }\n\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      //cout << nowl <<\" \"<< nowh <<\" \" << l<<\" \" << h << endl;\n      if (nowl > h){\n\tlen+=2*width;\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << h << endl;\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<list>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nshort map[10001][10001];\n\nint main(){\n    \n    int n,r;\n    \n        int S=0;\n        int L=0;\n        int state;\n  \n\n    \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        memset(map,0,sizeof(map));\n\n        \n        int x_min=10001,x_max=0,y_min=10001,y_max=0;\n       \n        int x1,y1,x2,y2;\n        for(int i=0;i<n;i++){\n            \n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n            if(x_min>x1)x_min=x1;\n            if(y_min>y1)y_min=y1;\n            if(x_max<x2)x_max=x2;\n            if(y_max<y2)y_max=y2;\n            \n        }\n\n        S=0;\n        L=0;\n        \n        for(int h=y_min;h<=y_max;h++){\n            state=0;\n            for(int w=x_min;w<=x_max;w++){\n                state+=map[w][h];\n                map[w][h]=state;\n            }\n        }\n        for(int w=x_min;w<=x_max;w++){\n            state=0;\n            for(int h=y_min;h<=y_max;h++){\n                state+=map[w][h];\n                map[w][h]=state;\n                if(map[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(map[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(map[w][h-1]==0)L+=2;\n               }\n            }\n        }\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nstruct R{\n\tR(){}\n\tR(int a, int b, int c, int d): a(a), b(b), c(c), d(d){}\n\n\tint a, b, c, d;\n};\n\nint n, r;\nvector<R> v;\n\nR rect_intersect(const R& x, const R& y){\n\treturn R(max(x.a, y.a), max(x.b, y.b), min(x.c, y.c), min(x.d, y.d));\n}\n\nbool rect_empty(const R& x){\n\treturn x.a >= x.c || x.b >= x.d;\n}\n\nbool rect_cmp(const R& x, const R& y){\n\treturn x.a == y.a && x.b == y.b && x.c == y.c && x.d == y.d;\n}\n\nint rect_area(const R& x){\n\treturn (x.c - x.a) * (x.d - x.b);\n}\n\nint area(const vector<R>& v, const R& x){\n\trep(i, v.size()){\n\t\tif(rect_cmp(v[i], x)){\n\t\t\treturn rect_area(x);\n\t\t}\n\t}\n\n\tint p = (x.a + x.c) / 2;\n\tint q = (x.b + x.d) / 2;\n\n\tR y[4] = {\n\t\tR(x.a, x.b, p, q),\n\t\tR(x.a, q, p, x.d),\n\t\tR(p, x.b, x.c, q),\n\t\tR(p, q, x.c, x.d)\n\t};\n\tvector<R> a[4];\n\trep(i, v.size()){\n\t\trep(j, 4){\n\t\t\tR t = rect_intersect(v[i], y[j]);\n\t\t\tif(!rect_empty(t)){\n\t\t\t\ta[j].push_back(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint r = 0;\n\trep(j, 4){\n\t\tif(!a[j].empty()){\n\t\t\tr += area(a[j], y[j]);\n\t\t}\n\t}\n\n\treturn r;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\", &n, &r);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\trep(i, n){\n\t\t\tR p;\n\t\t\tscanf(\"%d%d%d%d\", &p.a, &p.b, &p.c, &p.d);\n\t\t\tv.push_back(p);\n\t\t}\n\n\t\tprintf(\"%d\\n\", area(v, R(0, 0, 10000, 10000)));\n\t\tv.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\nvector<T> coner;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(cin >> n >> r, n | r){\n\tfill(imos[0], imos[0] + 10500, 0);\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 10500;\n\tright_side = top = 1;\n\tconer.clear();\n\tfor(int i = 0;i < n;i++){\n\t    cin >> ax >> ay >> bx >> by;\n\t    left_side = min(left_side, ++ax);\n\t    right_side = max(right_side, ++bx);\n\t    bottom = min(bottom, ++ay);\n\t    top = max(top, ++by);\n\t    \n\t    coner.push_back(T(P(ax, ay), 1));\n\t    coner.push_back(T(P(ax, by), -1));\n\t    coner.push_back(T(P(bx, ay), -1));\n\t    coner.push_back(T(P(bx, by), 1));\n\t}\n\tconer.push_back(T(P(INF, INF), 0));\n\tsort(coner.begin(), coner.end());\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(coner[p].first == P(i, j)){\n\t\t    imos[i % 3][j] += coner[p++].second;\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tcout << area << endl;\n\tif(r == 2)cout << round << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nbool isexist[N];\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  rep(i,N)isexist[i]=false;\n  \n  rep(i,n){\n    isexist[x1[i]]=true;\n    isexist[x2[i]]=true;\n  }\n  rep(i,N)if (isexist[i])x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid compress(vector<int> &v){\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\ninline int index(const vector<int> &v, int x){\n\treturn lower_bound(v.begin(), v.end(), x) - v.begin();\n}\n\nint main(){\n\tint n, r;\n\twhile(scanf(\"%d%d\", &n, &r), n){\n\t\tvector<int> x1(n), y1(n), x2(n), y2(n);\n\t\tvector<int> xs(2), ys(2);\n\t\txs.reserve(2 * n + 2);\n\t\tys.reserve(2 * n + 2);\n\t\txs[0] = ys[0] = -100000;\n\t\txs[1] = ys[1] = 100000;\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &x1[i], &y1[i], &x2[i], &y2[i]);\n\t\t\txs.push_back(x1[i]);\n\t\t\txs.push_back(x2[i]);\n\t\t\tys.push_back(y1[i]);\n\t\t\tys.push_back(y2[i]);\n\t\t}\n\n\t\tcompress(xs);\n\t\tcompress(ys);\n\n\t\tvector<vector<int> > incs(xs.size()), decs = incs;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tint xi1 = index(xs, x1[i]);\n\t\t\tint xi2 = index(xs, x2[i]);\n\t\t\tint yi1 = index(ys, y1[i]);\n\t\t\tint yi2 = index(ys, y2[i]);\n\n\t\t\tincs[xi1].push_back(yi1);\n\t\t\tdecs[xi2].push_back(yi1);\n\t\t\tdecs[xi1].push_back(yi2);\n\t\t\tincs[xi2].push_back(yi2);\n\t\t}\n\n\t\tint area = 0, len = 0;\n\n\t\tvector<int> prev(ys.size()), now = prev, next = prev;\n\t\tfor(int i = 0; i + 1 < xs.size(); ++i){\n\t\t\tfill(next.begin(), next.end(), 0);\n\t\t\tfor(int j = 0; j < incs[i+1].size(); ++j){\n\t\t\t\t++next[incs[i+1][j]];\n\t\t\t}\n\t\t\tfor(int j = 0; j < decs[i+1].size(); ++j){\n\t\t\t\t--next[decs[i+1][j]];\n\t\t\t}\n\t\t\tfor(int j = 1; j < next.size(); ++j){\n\t\t\t\tnext[j] += next[j-1];\n\t\t\t}\n\t\t\tfor(int j = 0; j < next.size(); ++j){\n\t\t\t\tnext[j] += now[j];\n\t\t\t}\n\n\t\t\tfor(int j = 1; j + 1 < ys.size(); ++j){\n\t\t\t\tif(now[j] == 0) continue;\n\t\t\t\t\n\t\t\t\tint dx = xs[i+1] - xs[i];\n\t\t\t\tint dy = ys[j+1] - ys[j];\n\t\t\t\tarea += dx * dy;\n\t\t\t\t\n\t\t\t\tif(prev[j] == 0) len += dy;\n\t\t\t\tif(next[j] == 0) len += dy;\n\t\t\t\tif(now[j-1] == 0) len += dx;\n\t\t\t\tif(now[j+1] == 0) len += dx;\n\t\t\t}\n\t\t\t\n\t\t\tprev.swap(now);\n\t\t\tnow.swap(next);\n\t\t}\n\n\t\tprintf(\"%d\\n\", area);\n\t\tif(r == 2) printf(\"%d\\n\", len);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint max(int* arr) {\n  int max = arr[0];\n  cout << \"sizeof: \" << sizeof(arr)/sizeof(arr[0]) << endl;\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (max < arr[i]) max = arr[i];\n  }\n  return max;\n}\n\nint min(int* arr) {\n  int min = arr[0];\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (min > arr[i]) min = arr[i];\n  }\n  return min;\n}\n\nint main(int argc, char const* argv[])\n{\n  ifstream ifs(\"input.txt\");\n  int count, type;\n  int *x1, *y1, *x2, *y2;\n  int left, bottom, right, top;\n  while (ifs >> count >> type) {\n    cout << \"count: \" << count << endl;\n    x1 = new int[count];\n    y1 = new int[count];\n    x2 = new int[count];\n    y2 = new int[count];\n    \n    // input\n    for (int i = 0; i < count; i++) {\n      ifs >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n\n    // field\n    left = min(x1);\n    bottom = min(y1);\n    right = max(x2);\n    top = max(y2);\n\n    cout << \"left:\"   << left   << endl;\n    cout << \"bottom:\" << bottom << endl;\n    cout << \"right:\"  << right  << endl;\n    cout << \"top:\"    << top    << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint  isexist[N]={0};\nint testcase=0;\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nstatic vector<pair<P,P> >in;\nstatic vector<P>vx[10001],vy[10001];\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    for(int i=0;i<10001;i++){\n      vx[i].clear();\n      vy[i].clear();\n    }\n\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint  sheets[3][10007], tmp[10007];\n\n\n\nint main(){\n  while(1){\n    int n, r;\n    int x1, y1, x2, y2, mx = 0, my = 0, menseki = 0, gaishuu = 0;\n    vector<pair<int, int> > points;\n    map<pair<int ,int> , int> nums;\n    scanf(\"%d%d\", &n, &r);\n    memset(sheets, 0, sizeof(sheets));\n    if(n == 0 && r == 0)return 0;\n    for(int i = 0;i < n;i++){\n      scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n      x1++,y1++,x2++,y2++;\n      points.push_back(make_pair(x1, y1));\n      points.push_back(make_pair(x1, y2));\n      points.push_back(make_pair(x2, y1));\n      points.push_back(make_pair(x2, y2));\n      if(nums.count(make_pair(x1, y1)) == 0)nums[make_pair(x1, y1)] = 0;\n      if(nums.count(make_pair(x2, y1)) == 0)nums[make_pair(x2, y1)] = 0;\n      if(nums.count(make_pair(x1, y2)) == 0)nums[make_pair(x1, y2)] = 0;\n      if(nums.count(make_pair(x2, y2)) == 0)nums[make_pair(x2, y2)] = 0;\n      nums[make_pair(x1, y1)]++;\n      nums[make_pair(x2, y2)]++;\n      nums[make_pair(x1, y2)]--;\n      nums[make_pair(x2, y1)]--;\n      mx = max(mx, x1);\n      mx = max(mx, x2);\n      my = max(my, y1);\n      my = max(my, y2);\n    }\n    sort(points.begin(), points.end(), greater< pair<int, int> >());\n    memset(tmp, 0, sizeof(tmp));\n    for(int i = 1;i <= mx ; i++){\n      for(int j = 1;j <= my + 1; j++){\n\tif(points.back().first == i && points.back().second == j){\n\t  tmp[j] += nums[points.back()];\n\t  pair<int, int> tmpr = points.back();\n\t  while(points.back() == tmpr)points.pop_back();\n\t}\n\tsheets[i % 3][j] = sheets[i % 3][j - 1] + tmp[j];\n\tif(sheets[i % 3][j] > 0)menseki++;\n\tif(r == 2){\n\t  if(sheets[i % 3][j] > 0 ){\n\t    if(sheets[(i - 1) % 3][j] == 0)gaishuu++;\n\t    if(sheets[i % 3][j - 1] == 0)gaishuu++;\n\t  }\n\t  if(sheets[i % 3][j] == 0 ){\n\t    if(sheets[(i - 1) % 3][j] > 0)gaishuu++;\n\t    if(sheets[i % 3][j - 1] > 0)gaishuu++;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", menseki);\n    if(r == 2){\n      printf(\"%d\\n\", gaishuu);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nint n, r;\nint sum[2][10010];\nbool a[10010][10010];\nvector<pair<int, pi> > q;\n\nint main(){\n\twhile(cin >> n >> r, n){\n\t\tmemset(a, 0, sizeof(a));\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tq.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint x, y, X, Y;\n\t\t\tcin >> x >> y >> X >> Y;\n\t\t\tq.pb(mp(y, mp(x, 1)));\n\t\t\tq.pb(mp(y, mp(X, -1)));\n\t\t\tq.pb(mp(Y, mp(x, -1)));\n\t\t\tq.pb(mp(Y, mp(X, 1)));\n\t\t}\n\t\tsort(all(q));\n\t\tint cur = 0, next = 1, ii = 0;\n\t\tint area = 0, per = 0;\n\t\t\n\t\trep(i, 10005){\n\t\t\tfor(; ii < q.size() && q[ii].first == i; ii++){\n\t\t\t\tsum[cur][q[ii].second.first] += q[ii].second.second;\n\t\t\t}\n\t\t\trep(j, 10005) sum[next][j] = sum[cur][j];\n\t\t\trep(j, 10005){\n\t\t\t\tsum[cur][j + 1] += sum[cur][j];\n\t\t\t\ta[i + 1][j + 1] = sum[cur][j] > 0;\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\trep(i, 10005) rep(j, 10005){\n\t\t\tif(a[i][j]) area++;\n\t\t\trep(d, 2){\n\t\t\t\tconst int dy[] = {1, 0}, dx[] = {0, 1};\n\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\tif(a[i][j] != a[ny][nx]) per++;\n\t\t\t}\n\t\t}\n\t\tcout << area << endl;\n\t\tif(r == 2) cout << per << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[10002];\nvector<P> xx[10002];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 10002; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tbool f = true;\n\tfor(int k = 0; k < (int)x[j].size(); k++){\n\t  if(x[j][k].F <= y2 && x[j][k].S >= y1){\n\t    x[j][k].F = min(x[j][k].F,y1);\n\t    x[j][k].S = max(x[j][k].S,y2);\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\tif(f) x[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\t//int data[10003][10003];\n\tint N, R;\n\twhile( cin >> N >> R, N || R ) {\n\t\tvector<vector<int>>data(10003,vector<int>(10003));\n\t\t//memset( data, 0, sizeof( data ) );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tdata[x1][y1]++;\n\t\t\tdata[x2][y2]++;\n\t\t\tdata[x1][y2]--;\n\t\t\tdata[x2][y1]--;\n\t\t}\n\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\n\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 30000;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\nint y[N];\nvector<st> iny[N];\n\n/*\n29\n29\n80\n45\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *X,vector<st> *IN){\n  vector<int> xd;\n  rep(i,n){\n    xd.pb(x1[i]);\n    xd.pb(x2[i]);\n  }\n  sort(ALL(xd));\n  xd.erase(unique(ALL(xd)),xd.end());\n  rep(i,xd.size())X[px++]=xd[i],IN[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    while(j < px && x[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    continue;\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      makedata(n,y1,y2,x1,x2,py,y,iny);\n      pair<int,int> ansy= solve(py,iny,y);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n\n    // update right_area_end_point\n    repeat_with_index(y_size, y_i) {\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    // for (auto&& points : sheets) {\n    //   cout << \"A: \";\n    //   cout << points.first.first << \" \" << points.first.second << endl;\n    //   for (auto&& p : points.second) {\n    //     cout << \"B: \";\n    //     cout << p.first << \" \" << p.second << endl;\n    //   }\n    // }\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Tag {\n    int a;\n    int b1, b2;\n    bool start;\n\n    Tag() : a(0), b1(0), b2(0), start(false) {}\n    Tag(int aa, int bb1, int bb2, bool s) : a(aa), b1(bb1), b2(bb2), start(s) {}\n};\n\nbool cmp(const Tag &t1, const Tag &t2) {\n    if(t1.a != t2.a) return t1.a < t2.a;\n    return !t1.start;\n}\n\nint main() {\n    while(true) {\n        int N, R;\n        cin >> N >> R;\n        if(!N && !R) break;\n\n        vector<Tag> xtag, ytag;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            xtag.push_back(Tag(x1, y1, y2, true));\n            xtag.push_back(Tag(x2, y1, y2, false));\n            ytag.push_back(Tag(y1, x1, x2, true));\n            ytag.push_back(Tag(y2, x1, x2, false));\n        }\n        sort(xtag.begin(), xtag.end(), cmp);\n        stable_sort(ytag.begin(), ytag.end(), cmp);\n\n        int max_y = ytag[ytag.size()-1].a;\n        int area = 0;\n        int len = 0;\n        int prev_y = -1;\n        int prev_area = 0;\n        int prev_len = 0;\n        for(int j = 0; j < ytag.size(); ++j) {\n            if(prev_y == ytag[j].a) continue;\n            area += prev_area * (ytag[j].a-prev_y);\n            len += prev_len * (ytag[j].a-prev_y);\n            prev_y = ytag[j].a;\n            prev_area = 0;\n            prev_len = 0;\n\n            int depth = 0;\n            int startx = 0;\n            int prevx = -1;\n            for(int i = 0; i < xtag.size(); ++i) {\n                if(xtag[i].b1 <= prev_y && prev_y < xtag[i].b2) {\n                    if(xtag[i].start) {\n                        if(depth == 0) {\n                            if(xtag[i].a != prevx) ++prev_len;\n                            else --prev_len;\n                            startx = xtag[i].a;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            prev_area += xtag[i].a-startx;\n                            prevx = xtag[i].a;\n                            ++prev_len;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << area << endl;\n        if(R == 1) continue;\n\n        prev_len = 0;\n        int prev_x = -1;\n        for(int j = 0; j < xtag.size(); ++j) {\n            if(prev_x == xtag[j].a) continue;\n            len += prev_len * (xtag[j].a-prev_x);\n            prev_x = xtag[j].a;\n            prev_len = 0;\n\n            int depth = 0;\n            int prevy = -1;\n            for(int i = 0; i < ytag.size(); ++i) {\n                if(ytag[i].b1 <= prev_x && prev_x < ytag[i].b2) {\n                    if(ytag[i].start) {\n                        if(depth == 0) {\n                            if(ytag[i].a != prevy) ++prev_len;\n                            else --prev_len;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            ++prev_len;\n                        }\n                    }\n                }\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <tuple>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nusing namespace std;\nint x_size, y_size;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<int, vector<tuple<int, int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n  x_size = 0; y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n  x_size = x_max + 1;\n  y_size = y_max + 1;\n\n  auto t = make_tuple(y1, x2, y2);\n  if (sheets.count(x1) == 0) {\n    sheets[x1] = {t};\n  } else {\n    sheets[x1].push_back(t);\n  }\n}\nvector<tuple<int, int, int>>& find_end_points(int x, int y) {\n  return sheets[x];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  loop(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  loop(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_size, x_i) {\n    // update right_area_end_point\n    auto& points = find_end_points(x_i, 0);\n\n    // per point operation\n    for (auto&& point : points) {\n      int y_i = get<0>(point), x = get<1>(point), y = get<2>(point);\n\n      loop_from_to(y_i, y - 1, p_i) {\n        assign_if_larger(right_area_end_point[p_i], x);\n      }\n    }\n\n    loop(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Tag {\n    int a;\n    int b1, b2;\n    bool start;\n\n    Tag() : a(0), b1(0), b2(0), start(false) {}\n    Tag(int aa, int bb1, int bb2, bool s) : a(aa), b1(bb1), b2(bb2), start(s) {}\n};\n\nbool cmp(const Tag &t1, const Tag &t2) {\n    if(t1.a != t2.a) return t1.a < t2.a;\n    return !t1.start;\n}\n\nint main() {\n    while(true) {\n        int N, R;\n        cin >> N >> R;\n        if(!N && !R) break;\n\n        vector<Tag> xtag, ytag;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            xtag.push_back(Tag(x1, y1, y2, true));\n            xtag.push_back(Tag(x2, y1, y2, false));\n            ytag.push_back(Tag(y1, x1, x2, true));\n            ytag.push_back(Tag(y2, x1, x2, false));\n        }\n        sort(xtag.begin(), xtag.end(), cmp);\n        sort(ytag.begin(), ytag.end(), cmp);\n\n        int max_y = ytag[ytag.size()-1].a;\n        int area = 0;\n        int len = 0;\n        for(int y = 0; y < max_y; ++y) {\n            int depth = 0;\n            int startx = 0;\n            int prevx = -1;\n            for(int i = 0; i < xtag.size(); ++i) {\n                if(xtag[i].b1 <= y && y < xtag[i].b2) {\n                    if(xtag[i].start) {\n                        if(depth == 0) {\n                            if(xtag[i].a != prevx) ++len;\n                            else --len;\n                            startx = xtag[i].a;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            area += xtag[i].a-startx;\n                            prevx = xtag[i].a;\n                            ++len;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << area << endl;\n        if(R == 1) continue;\n\n        int max_x = xtag[xtag.size()-1].a;\n        for(int x = 0; x < max_x; ++x) {\n            int depth = 0;\n            int prevy = -1;\n            for(int i = 0; i < ytag.size(); ++i) {\n                if(ytag[i].b1 <= x && x < ytag[i].b2) {\n                    if(ytag[i].start) {\n                        if(depth == 0) {\n                            if(prevy != ytag[i].a) ++len;\n                            else --len;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            ++len;\n                            prevy = ytag[i].a;\n                        }\n                    }\n                }\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  rep(i,n){\n    xd[px++]=x1[i];\n    xd[px++]=x2[i];\n  }\n  sort(xd,xd+px);\n  px=unique(xd,xd+px)-xd;\n  rep(i,px)IN[i].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    continue;\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        int** map;\n        map=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            map[w] = new int[10001];\n        }\n        \n        int** imos;\n        imos=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            imos[w] = new int[10001];\n        }\n        \n        int max=0;\n       \n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n            if(x2>max)max=x2;\n            if(y2>max)max=y2;\n        }\n\n        int S=0;\n        int L=0;\n        for(int h=0;h<=10000;h++){\n            int state=0;\n           for(int w=0;w<=10000;w++){\n               int res=0;\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n\n        cout<<S<<endl;\n        if(r==2)cout<<L<<endl;\n \n\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<list>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define S second\n#define F first\nstruct Rect{\n  int x1,y1,x2,y2;\n  Rect(){}\n  Rect(int x1,int y1,int x2,int y2) : x1(x1),y1(y1),x2(x2),y2(y2) {}\n  bool operator < (const Rect& oth)const{\n    if(y2 == oth.y2){\n      return y1 < oth.y1;\n    }\n    return y2 < oth.y2;\n  }\n};\nstruct Act{\n  int up,down;\n  Act(){}\n  Act(int up,int down) : up(up),down(down) {}\n};\nint N,R;\nRect S[10002];\nvector<Act> A[10002];\nint main(){\n  while(1){\n    scanf(\"%d %d\",&N,&R);\n    if(!N && !R) break;\n    int minx=100000,maxx=0;\n    for(int i=0;i<N;i++){\n      scanf(\"%d %d %d %d\",&S[i].x1,&S[i].y1,&S[i].x2,&S[i].y2);\n      minx = min(S[i].x1,minx); maxx = max(S[i].x2,maxx);\n    }\n    sort(S,S+N);\n    for(int i=N-1;i>-1;i--){\n      //      printf(\"%d %d %d %d\\n\",S[i].x1,S[i].y1,S[i].x2,S[i].y2);\n      for(int x = S[i].x1; x < S[i].x2; x++){\n\tif(A[x].empty()){\n\t  A[x].push_back(Act(S[i].y2,S[i].y1));\n\t} else {\n\t  int dw = A[x].back().down;\n\t  if(dw-1 > S[i].y2){\n\t    A[x].push_back(Act(S[i].y2,S[i].y1));\n\t  } else if ( dw > S[i].y1 )\n\t    A[x].back().down = S[i].y1;\n\t}\n      }\n    }\n    int res1=0;\n    int res2=0;\n    int sump=0;\n    for(int i=0;i<(int)A[minx].size();i++){\n      res1 += (A[minx][i].up - A[minx][i].down);\n      res2 += (A[minx][i].up - A[minx][i].down);\n    }\n    sump = res2;\n    res2 += (int)A[minx].size() * 2;\n    for(int i=minx+1; i<=maxx; i++){\n      int l=0;\n      int sumk=0;\n      int sumn=0;\n      //      printf(\"%d %d\\n\",res1,res2);\n      for(int j=0;j<(int)A[i].size();j++){\n\tres1 += (A[i][j].up - A[i][j].down);\n\tsumn += (A[i][j].up - A[i][j].down);\n\tbool f=false;\n\tdo{\n\t  f=false;\n\t  if(A[i-1][l].up == A[i][j].up){\n\t    if(A[i-1][l].down >= A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    }else{\n\t      sumk += (A[i][j].up - A[i][j].down);\n\t    }\n\t  } else if(A[i-1][l].up >= A[i][j].up && A[i][j].up >= A[i-1][l].down){\n\t    if(A[i-1][l].down == A[i][j].down){\n\t      sumk += (A[i][j].up-A[i][j].down);\n\t      f=true;\n\t    }else if(A[i-1][l].up >= A[i][j].down && A[i][j].down >= A[i-1][l].down){\n\t      sumk += (A[i][j].up - A[i][j].down);\n\t    } else{\n\t      sumk += (A[i][j].up - A[i-1][l].down);\n\t      f=true;\n\t    }\n\t  } else if(A[i][j].up >= A[i-1][l].up && A[i-1][l].up >= A[i][j].down){\n\t    if(A[i-1][l].down == A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    }else if(A[i][j].up >= A[i-1][l].down && A[i-1][l].down >= A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    } else {\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t    }\n\t  } else if(A[i-1][l].down > A[i][j].up) f=true;\n\t  if(f) l++;\n\t} while(f && l < (int)A[i-1].size());\n      }\n      res2 += (sump - sumk);\n      res2 += (sumn - sumk);\n      res2 += (int)A[i].size()*2;\n      sump = sumn;\n    }\n    printf(\"%d\\n\",res1);\n    if(R==2) printf(\"%d\\n\",res2);\n\n    for(int i=minx; i<=maxx; i++) A[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint min_x,min_y,max_x,max_y,W,H;\nunsigned char plane[10001][10001];\n\ninline void Imos(){\n\tREP(y,0,H){\n\t\tREP(x,1,W){\n\t\t\tplane[x][y]+=plane[x-1][y];\n\t\t}\n\t}\n\tREP(x,0,W){\n\t\tfor(int y=H-2; y>=0; --y){\n\t\t\tplane[x][y]+=plane[x][y+1];\n\t\t}\n\t}\n}\n\ninline int CalcSize(/*vector<vector<unsigned char> > &plane*/){\n\tint result=0;\n\tREP(x,0,W){\n\t\tREP(y,0,H){\n\t\t\tif(plane[x][y]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(vector<vector<bool> > &has_done,int x,int y){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[x][y]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[nx][ny]){\n\t\t\t\tif(plane[nx][ny]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[nx][ny]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int CalcLength(int n,vector<int> &X,vector<int> &Y){\n\tvector<vector<bool> > has_done(W,vector<bool>(H));\n\tint result=0;\n\t/*\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(!has_done[x][y]&&plane[x][y]>0){\n\t\t\t\tresult+=BFS(plane,has_done,x,y,plane.size(),plane[0].size());\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tREP(i,0,n){\n\t\tif(!has_done[X[i]][Y[i]]&&plane[X[i]][Y[i]]>0) result+=BFS(has_done,X[i],Y[i]);\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tmemset(plane,0,sizeof(plane));\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,2){\n\t\t\tX[i].resize(N);\n\t\t\tY[i].resize(N);\n\t\t}\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tX[j][i]=x;\n\t\t\t\tY[j][i]=y;\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\t//vector<vector<unsigned char> > plane(max_x+4-min_x,vector<unsigned char>(max_y+4-min_y));\n\t\tW=max_x+4-min_x;\n\t\tH=max_y+4-min_y;\n\t\tREP(i,0,N){\n\t\t\tplane[X[0][i]+1-min_x][Y[1][i]+1-min_y]+=1;\n\t\t\tplane[X[1][i]+2-min_x][Y[0][i]-min_y]+=1;\n\t\t\tplane[X[0][i]+1-min_x][Y[0][i]-min_y]+=-1;\n\t\t\tplane[X[1][i]+2-min_x][Y[1][i]+1-min_y]+=-1;\n\t\t}\n\t\tImos();\n\t\tcout << CalcSize() << endl;\n\t\tif(R==2) cout << CalcLength(N,X[0],Y[0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  vector<int>v[10002];\n\n  while(cin >> n >> r,n|r){\n    for(int i=0;i<10002;i++)v[i].clear();\n\n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      for(int j=x1;j<x2;j++){\n        for(int k=y1;k<y2;k++){\n\t  if(!binary_search(v[j].begin(),v[j].end(),k)){\n\t    v[j].push_back(k);\n\t    sort(v[j].begin(),v[j].end());\n\t  }\n\t}\n      }\n    }\n    \n    int S=0;\n    for(int i=0;i<10001;i++)S+=v[i].size();\n\n    cout << S << endl;\n    if(r==2){\n      int L=v[0].size();\n\n      for(int i=0;i<10001;i++){\n\tif(v[i].size()>0)L+=2;\n        for(int j=0;j<v[i].size();j++){\n\t  if(j<v[i].size()-1 && v[i][j+1]!=v[i][j]+1)L+=2;\n          if(i>0 && !binary_search(v[i-1].begin(),v[i-1].end(),v[i][j]))L++;\n\t  if(!binary_search(v[i+1].begin(),v[i+1].end(),v[i][j]))L++;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nvector<T> vec;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        scanf(\"%d %d\",&n,&r);\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        vec.pb(T(P(INF,INF),INF));\n        SORT(vec);\n        int index=0;\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n  x_size = 0; y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n  x_size = x_max + 1;\n  y_size = y_max + 1;\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  loop(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  loop(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_size, x_i) {\n    loop(y_size, y_i) {\n      // update right_area_end_point\n      auto&& points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        loop_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    loop(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\ntypedef pair<int, int> Range;\ntypedef vector<Range> Ranges;\n\nstruct Rect{\n  int ldx, ldy;\n  int rux, ruy;\n\n  Rect(){}\n  Rect(int ldxx, int ldyy,\n       int ruxx, int ruyy) :\n    ldx(ldxx), ldy(ldyy),\n    rux(ruxx), ruy(ruyy) {}\n};\n\nbool operator < (const Rect &lhs, const Rect &rhs){\n  if(lhs.ldx != rhs.ldx) return lhs.ldx < rhs.ldx;\n  if(lhs.rux != rhs.rux) return lhs.rux < rhs.rux;\n  if(lhs.ldy != rhs.ldy) return lhs.ldy < rhs.ldy;\n  return lhs.ruy < rhs.ruy;\n}\n\ntypedef vector<Rect> Rects;\n\nvoid addRange(Ranges &dst, Range rng){\n  int idx = lower_bound(dst.begin(), dst.end(), rng) - dst.begin();\n\n  bool f1 = false;\n  bool f2 = false;\n\n  if(idx != 0){\n    if(rng.first <= dst[idx - 1].second){\n      dst[idx - 1].second = max(dst[idx - 1].second, rng.second);\n      f1 = true;\n    }\n  }\n\n  if(idx != (int)dst.size()){\n    if(dst[idx].first <= rng.second){\n      dst[idx].first  = rng.first;\n      dst[idx].second = max(dst[idx].second, rng.second);\n      f2 = true;\n    }\n  }\n\n  if(f1 && f2){\n    dst[idx - 1].second = dst[idx].second;\n    dst.erase(dst.begin() + idx);\n  }else if(!f1 && !f2){\n    dst.insert(dst.begin() + idx, rng);\n  }\n}\n\nint rangeLength(const Ranges &rngs){\n  int ret = 0;\n  FOR(it, rngs){\n    ret += it->second - it->first;\n  }\n  return ret;\n}\n\n// from sorted rects\ntemplate<typename Use>\nRanges createRanges(const Rects &rects, const Use &use){\n  Ranges ret;\n  FOR(it, use){\n    const Rect &r = rects[*it];\n    addRange(ret, Range(r.ldy, r.ruy));\n  }\n  return ret;\n}\n\ninline void getrng(const Ranges &rngs, int &sx, int &ex, int n){\n  sx = n == (int)rngs.size() ? INT_MAX : rngs[n].first;\n  ex = n == (int)rngs.size() ? INT_MAX : rngs[n].second;\n}\n\nint diffRange(const Ranges &r1, const Ranges &r2){\n  int p1 = 0;\n  int p2 = 0;\n  int ret = 0;\n\n  int sx1, ex1, sx2, ex2;\n  getrng(r1, sx1, ex1, p1);\n  getrng(r2, sx2, ex2, p2);\n\n  while(p1 != (int)r1.size() || p2 != (int)r2.size()){\n    // printf(\" (%d %d) (%d %d) : %d\\n\", sx1, ex1, sx2, ex2, ret);\n    if(ex1 <= sx2){\n      ret += ex1 - sx1;\n      getrng(r1, sx1, ex1, ++p1);\n    }else if(ex2 <= sx1){\n      ret += ex2 - sx2;\n      getrng(r2, sx2, ex2, ++p2);\n    }else{\n      if(ex1 < ex2){\n        ret += abs(sx2 - sx1);\n        sx2 = ex1;\n        getrng(r1, sx1, ex1, ++p1);\n      }else{\n        ret += abs(sx1 - sx2);\n        sx1 = ex2;\n        getrng(r2, sx2, ex2, ++p2);\n      }\n    }\n  }\n\n  return ret;\n}\n\nenum Event{\n  ADD = 0,\n  DEL = 1\n};\n\n// must be sorted\npair<int, int> calc(const Rects &rects){\n  const int n = rects.size();\n  vector<pair<int, pair<int, int> > > events(2 * n);\n\n  int minx = INT_MAX;\n  int maxx = 0;\n\n  REP(i,n){\n    events[2 * i].first = rects[i].ldx;\n    events[2 * i].second.first  = i;\n    events[2 * i].second.second = ADD;\n    minx = min(minx, rects[i].ldx);\n\n    events[2 * i + 1].first = rects[i].rux;\n    events[2 * i + 1].second.first  = i;\n    events[2 * i + 1].second.second = DEL;\n    maxx = max(maxx, rects[i].rux);\n  }\n\n  sort(events.begin(), events.end());\n\n  int ptr = 0;\n\n  int men = 0;\n  int shu = 0;\n  Ranges rngs;\n  int len = 0;\n  int px  = 0;\n  set<int> use;\n\n  while(ptr != 2 * n){\n    int xx = events[ptr].first;\n\n    // update ans\n    men += len * (xx - px);\n    shu += 2 * rngs.size() * (xx - px);\n\n    // update others\n    px = xx;\n\n    while(ptr != 2 * n && events[ptr].first == xx){\n      int id = events[ptr].second.first;\n      int tp = events[ptr].second.second;\n\n      if(tp == ADD) use.insert(id);\n      else use.erase(id);\n\n      ptr++;\n    }\n\n    Ranges rtmp = createRanges(rects, use);\n    // printf(\" diffRange = %d\\n\", diffRange(rtmp, rngs));\n    shu += diffRange(rtmp, rngs);\n    rngs.swap(rtmp);\n    len = rangeLength(rngs);\n\n    /*\n    printf(\"x = %d: (%d, %d) len = %d\\n\", px, men, shu, len);\n    REP(i,rngs.size()){\n      printf(\" [%d, %d]\\n\", rngs[i].first, rngs[i].second);\n    }\n    */\n  }\n\n  return make_pair(men, shu);\n}\n\nint main(){\n  while(true){\n    const int n = getInt();\n    const int r = getInt();\n\n    if(n + r == 0) break;\n\n    Rects rects(n);\n\n    REP(i,n){\n      rects[i].ldx = getInt();\n      rects[i].ldy = getInt();\n      rects[i].rux = getInt();\n      rects[i].ruy = getInt();\n    }\n\n    sort(rects.begin(), rects.end());\n    const pair<int, int> ret = calc(rects);\n\n    printf(\"%d\\n\", ret.first);\n    if(r == 2)\n      printf(\"%d\\n\", ret.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nshort x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,short *xd,vector<st> *IN){\n  rep(i,n){\n    xd[px++]=x1[i];\n    xd[px++]=x2[i];\n  }\n  sort(xd,xd+px);\n  px=unique(xd,xd+px)-xd;\n  rep(i,px)IN[i].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,short *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nstatic pair<P,P> in[10000];\n\nint main(void){\n\n  int n,r;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    static vector<P> v[10001];\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&in[i].F.F,&in[i].S.F,&in[i].F.S,&in[i].S.S);\n    }\n\n    sort(in,in+n,cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      sort(in,in+n,cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n\nint area;\nint length;\n\nRECT calc[10000];\nRECT before[10000];\nRECT grid[10000];\nint bsize;\n\nbool comp(const RECT& rLeft, const RECT& rRight){\n    return (rLeft.sx < rRight.sx);\n}\n\nbool ycomp(const RECT& rLeft, const RECT& rRight){\n    return (rLeft.sy < rRight.sy);\n}\n\nvoid mergeArea(int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n    \n    if (n == 0){\n        return;\n    }\n    \n    sort(grid, grid + n, comp);\n    \n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n    \n    *sq = num;\n}\n\nvoid mergeLength(int n)\n{\n    vector<int> total;\n    int i;\n    int res;\n    \n    for (i = 0; i < n; i++){\n        total.push_back(calc[i].sx);\n        total.push_back(calc[i].ex);\n    }\n    for (i = 0; i < bsize; i++){\n        total.push_back(before[i].sx);\n        total.push_back(before[i].ex);\n    }\n    \n    sort(total.begin(), total.end());\n    res = 0;\n    for (i = 0; i < total.size(); i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n\nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    int num;\n    int i, j;\n    int sq;\n    int miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        miny = 1000000;\n        maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n            miny = min(miny, p[i].sy);\n            maxy = max(maxy, p[i].ey);\n        }\n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        sort(p, p + n, ycomp);\n        area = length = 0;\n        for (i = miny; i <= maxy; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n                else if (p[j].sy > i){\n                    break;\n                }\n            }\n            mergeArea(num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", length);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint n;\nint min_x1, max_x2, min_y1, max_y2;\nint x1[10000], x2[10000], y1[10000], y2[10000];\nint tiles[10002][10002];\n\nvoid pre_process() {\n    int i;\n\n    for (i=0;i<n;i++) {\n        tiles[y1[i]][x1[i]]++;\n        tiles[y1[i]][x2[i]]--;\n        tiles[y2[i]][x2[i]]++;\n        tiles[y2[i]][x1[i]]--;\n    }\n\n    for (i=min_y1;i<max_y2+1;i++) {\n        int j;\n        for (j=min_x1+1;j<max_x2+1;j++) {\n            tiles[i][j] += tiles[i][j-1];\n        }\n    }\n\n\n    for (i=min_y1+1;i<max_y2+1;i++) {\n        int j;\n        for (j=min_x1;j<max_x2+1;j++) {\n            tiles[i][j] += tiles[i-1][j];\n        }\n    }\n\n    return;\n}\n\nint surface() {\n    int i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2;i++) {\n        int j;\n        for (j=min_x1;j<max_x2;j++) {\n            if (tiles[i][j] > 0) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint perimeter() {\n    int i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2+2;i++) {\n        int j;\n        for (j=min_x1;j<max_x2+2;j++) {\n            int add = tiles[i][j] + tiles[i-1][j];\n\n            if (add > 0 && (tiles[i][j] == 0 || tiles[i-1][j] == 0)) {\n                sum++;\n            }\n\n            add = tiles[i][j] + tiles[i][j-1];\n\n            if (add > 0 && (tiles[i][j] == 0 || tiles[i][j-1] == 0)) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while (1) {\n        int i;\n        int r;\n\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r ==0) return 0;\n\n        min_x1 = 10000;\n        min_y1 = 10000;\n        max_x2 = 0;\n        max_y2 = 0;\n        for (i=0;i<n;i++) {\n            scanf(\"%d %d %d %d\", &x1[i], &y1[i], &x2[i], &y2[i]);\n            x1[i]++;\n            x2[i]++;\n            y1[i]++;\n            y2[i]++;\n            if (min_x1 > x1[i]) min_x1 = x1[i];\n            if (max_x2 < x2[i]) max_x2 = x2[i];\n            if (min_y1 > y1[i]) min_y1 = y1[i];\n            if (max_y2 < y2[i]) max_y2 = y2[i];\n        }\n\n        memset(tiles, 0, 10000 * 10000);\n        pre_process();\n\n        printf(\"%d\\n\", surface());\n\n        if (r == 2) {\n            printf(\"%d\\n\", perimeter());\n        }        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\tvector<vector<int>>data( 10002, vector<int>( 10002 ) );\n\twhile( cin >> N >> R, N || R ) {\n\t\tdata = vector<vector<int>>( 10002, vector<int>( 10002 ) );\n\t\tint xmax = 0, ymax = 0;\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\txmax = max( xmax, x2 );\n\t\t\tymax = max( ymax, y2 );\n\t\t\tdata[x1][y1]++;\n\t\t\tdata[x2][y2]++;\n\t\t\tdata[x1][y2]--;\n\t\t\tdata[x2][y1]--;\n\t\t}\n\t\txmax++;\n\t\tymax++;\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < xmax; j++ ) {\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < max( xmax, ymax ); i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\tvector<vector<int>>data( 10002, vector<int>( 10002 ) );\n\twhile( cin >> N >> R, N || R ) {\n\t\tint xmax = 0, ymax = 0;\n\t\tvector<pair<pair<int, int>, pair<int, int>>>input( N );\n\t\tset<int>xs, ys;\n\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tinput[i] = make_pair( make_pair( x1, y1 ), make_pair( x2, y2 ) );\n\t\t\t/*\n\t\t\tdata[x1][y1]++;\n\t\t\tdata[x2][y2]++;\n\t\t\tdata[x1][y2]--;\n\t\t\tdata[x2][y1]--;\n\t\t\t*/\n\t\t\txs.insert( x1 );\n\t\t\tys.insert( y1 );\n\t\t\txs.insert( x2 );\n\t\t\tys.insert( y2 );\n\t\t}\n\t\tfor( auto x : xs ) {\n\t\t\tcout << x << \" \";\n\t\t}\n\t\tcout << endl;\n\t\tmap<int, int>x_x;\n\t\tmap<int, int>y_y;\n\t\tvector<int>x_x_x;\n\t\tvector<int>y_y_y;\n\t\tfor( auto xx : xs ) {\n\t\t\tx_x[xx] = x_x_x.size();\n\t\t\tx_x_x.push_back( xx );\n\t\t}\n\t\tfor( auto yy : ys ) {\n\t\t\ty_y[yy] = y_y_y.size();\n\t\t\ty_y_y.push_back( yy );\n\t\t}\n\t\txmax = xs.size() + 1;\n\t\tymax = ys.size() + 1;\n\t\tdata = vector<vector<int>>( xmax + 1, vector<int>( ymax + 1 ) );\n\t\tfor( size_t i = 0; i < input.size(); i++ ) {\n\t\t\tdata[x_x[input[i].first.first]][y_y[input[i].first.second]]++;\n\t\t\tdata[x_x[input[i].second.first]][y_y[input[i].second.second]]++;\n\t\t\tdata[x_x[input[i].second.first]][y_y[input[i].first.second]]--;\n\t\t\tdata[x_x[input[i].first.first]][y_y[input[i].second.second]]--;\n\t\t}\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans += (x_x_x[i + 1] - x_x_x[i])*(y_y_y[j + 1] - y_y_y[j]);\n\t\t\t\t\t//ans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans += y_y_y[i + 1] - y_y_y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans += y_y_y[j + 1] - y_y_y[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; i++)\n\nint n, r;\nint m[10010][10010];\nint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &r),n||r){\n\t\trep(i,10010) rep(j,10010) m[i][j] = 0;\n\t\trep(i,n){\n\t\t\tint x1, x2, y1, y2;\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\tx1++; y1++; //x2++; y2++;\n\t\t\tm[x1][y1]++; m[x2+1][y1]--; m[x1][y2+1]--; m[x2+1][y2+1]++;\n\t\t}\n\t\trep(i,10010) for(int j = 1; j < 10010; j++){\n\t\t\tm[i][j] += m[i][j-1];\n\t\t}\n\t\trep(i,10010) for(int j = 1; j < 10010; j++){\n\t\t\tm[j][i] += m[j-1][i];\n\t\t}\n\t\tint s = 0;\n\t\trep(i,10010) rep(j,10010) if(m[i][j] > 0) s++;\n\t\tprintf(\"%d\\n\", s);\n\t\tif(r == 1) continue;\n\t\ts = 0;\n\t\trep(i,10010) rep(j,10010){\n\t\t\tif(m[i][j] == 0) continue;\n\t\t\trep(k,4){\n\t\t\t\tif(m[i+dx[k]][j+dy[k]] == 0) s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nshort x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[4000][4000];\nvector<short> vx;\nvector<short> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\t//for(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]);\n\t\t\tvx.push_back(x2[i]);\n\t\t\tvy.push_back(y1[i]);\n\t\t\tvy.push_back(y2[i]);\n\t\t//}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nint n, r;\nint sum[2][10010];\nbool a[2][10010];\nvector<pair<int, pi> > q;\n\nint main(){\n\twhile(cin >> n >> r, n){\n\t\tmemset(a, 0, sizeof(a));\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tq.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint x, y, X, Y;\n\t\t\tcin >> x >> y >> X >> Y;\n\t\t\tq.pb(mp(y, mp(x, 1)));\n\t\t\tq.pb(mp(y, mp(X, -1)));\n\t\t\tq.pb(mp(Y, mp(x, -1)));\n\t\t\tq.pb(mp(Y, mp(X, 1)));\n\t\t}\n\t\tsort(all(q));\n\t\tint cur = 0, next = 1, ii = 0;\n\t\tint area = 0, per = 0;\n\t\t\n\t\trep(i, 10005){\n\t\t\tmemset(a[cur], 0, sizeof(a[cur]));\n\t\t\t\n\t\t\tfor(; ii < q.size() && q[ii].first == i; ii++){\n\t\t\t\tsum[cur][q[ii].second.first] += q[ii].second.second;\n\t\t\t}\n\t\t\trep(j, 10005) sum[next][j] = sum[cur][j];\n\t\t\trep(j, 10005){\n\t\t\t\tsum[cur][j + 1] += sum[cur][j];\n\t\t\t\ta[cur][j + 1] = sum[cur][j] > 0;\n\t\t\t}\n\t\t\trep(j, 10005){\n\t\t\t\tif(a[cur][j]) area++;\n\t\t\t\trep(d, 2){\n\t\t\t\t\tint ny = d ? cur : next, nx = d ? j + 1 : j;\n\t\t\t\t\tif(a[cur][j] != a[ny][nx]) per++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\tcout << area << endl;\n\t\tif(r == 2) cout << per << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> >in;\nvector<P> v[10001];\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    for(int i=0;i<10001;i++)v[i].clear();\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    stable_sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      stable_sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<in.size();i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    // repeat_with_index(y_size, y_i) {\n    //   // update right_area_end_point\n    //   auto points = find_end_points(x_i, y_i);\n\n    //   // per point operation\n    //   for (auto&& point : points) {\n    //     int x = point.first, y = point.second;\n\n    //     repete_from_to(y_i, y - 1, p_i) {\n    //       assign_if_larger(right_area_end_point[p_i], x);\n    //     }\n    //   }\n    // }\n\n    // repeat_with_index(y_size, y_i) {\n\n    //   // included in some sheets\n    //   if (right_area_end_point[y_i] > x_i) {\n    //     area += 1;\n    //     is_area[x_i % 2][y_i] = true;\n    //   } else {\n    //     is_area[x_i % 2][y_i] = false;\n    //   }\n\n    //   // line check\n    //   if (type == 2) {\n    //     // left line exists\n    //     if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n    //     // bottom line exists\n    //     if (\n    //         (y_i == 0 && is_area[x_i % 2][y_i]) ||\n    //         (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n    //         )\n    //       lines += 1;\n    //   }\n    // }\n\n    // delete is_area[0];\n    // delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint main(){\n    int N, R;\n    while(cin >> N >> R && R){\n        static short tiles[10001][10001] = {};\n        for(int y = 0; y <= 10000; y++){\n            for(int x = 0; x <= 10000; x++){\n                tiles[y][x] = 0;\n            }\n        }\n        int X1 = INF, X2 = -INF, Y1 = INF, Y2 = -INF;\n        for(int i = 0; i < N; i++){\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            X1 = min(X1, x1); X2 = max(X2, x2);\n            Y1 = min(Y1, y1); Y2 = max(Y2, y2);\n            tiles[y1][x1]++;\n            tiles[y1][x2]--;\n            tiles[y2][x1]--;\n            tiles[y2][x2]++;\n        }\n        for(int y = Y1; y <= Y2; y++){\n            for(int x = X1 + 1; x <= X2; x++){\n                tiles[y][x] += tiles[y][x - 1];\n            }\n        }\n        for(int y = Y1 + 1; y <= Y2; y++){\n            for(int x = X1; x <= X2; x++){\n                tiles[y][x] += tiles[y - 1][x];\n            }\n        }\n        int ans = 0;\n        for(int y = Y1; y <= Y2; y++){\n            for(int x = X1; x <= X2; x++){\n                ans += (tiles[y][x] > 0 ? 1 : 0);\n            }\n        }\n        cout << ans << endl;\n        if(R == 2) cout << -1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "int g[10005][10005];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tg[x1][y1]-=1;\n\t\t\tg[x2][y1]+=1;\n\t\t\tg[x1][y2]+=1;\n\t\t\tg[x2][y2]-=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int size = 10003;\nshort field[10003][10003];\n\nint main(){\n    while(1){\n        int n,r;\n        cin >> n >> r;\n        if(r==0) break;\n\n        memset(field, 0, sizeof(field));\n        for(int i=0; i<n; i++){\n            int xs,ys,xt,yt;\n            cin >> xs >> ys >> xt >> yt;\n            xs++; ys++; xt++; yt++;\n            field[xs][ys]++;\n            field[xs][yt]--;\n            field[xt][ys]--;\n            field[xt][yt]++;\n        }\n        for(int i=0; i<size; i++){\n            for(int j=0; j<size -1; j++){\n                field[i][j+1] += field[i][j];\n            }\n        }\n        for(int j=0; j<size; j++){\n            for(int i=0; i<size -1; i++){\n                field[i+1][j] += field[i][j];\n            }\n        }\n\n        int area = 0;\n        int outlen = 0;\n        for(int i=1; i<size-1; i++){\n            for(int j=1; j<size-1; j++){\n                if(field[i][j] > 0){\n                    area++;\n                    if(field[i+1][j] == 0) outlen++;\n                    if(field[i][j+1] == 0) outlen++;\n                    if(field[i-1][j] == 0) outlen++;\n                    if(field[i][j-1] == 0) outlen++;\n                }\n            }\n        }\n        cout << area << endl;\n        if(r==2){\n            cout << outlen << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint dp[4001], p[4001];\n\ntypedef pair<int, pair<int, int> > Event;\n\nint main() {\n  for (;;) {\n    int n, r;\n    cin >> n >> r;\n    if (!(n || r)) return 0;\n    map<int, vector<Event> > events;\n    int mx = 0, c = 0, area = 0, circumference = 0;\n    for (int i = 0; i < n; i++) {\n      int sx, sy, ex, ey;\n      cin >> sx >> sy >> ex >> ey;\n      events[sy].push_back(make_pair(1, make_pair(sx, ex)));\n      events[ey].push_back(make_pair(-1, make_pair(sx, ex)));\n      mx = max(mx, ex);\n    }\n    fill(dp, dp+mx+1, 0);\n    fill(p, p+mx+1, 0);\n    for (map<int, vector<Event> >::iterator v = events.begin();\n         v != events.end(); ++v) {\n      int count = 0, a = 0, b = 0;\n      for (int i = 0; i < mx; i++) {\n        if (dp[i]) {\n          count++;\n          if (dp[i+1]) a++;\n          if (p[i]) b++;\n        }\n        p[i] = dp[i];\n      }\n      circumference += ((v->first - c) * (count - a) + count - b) * 2;\n      area += (v->first - c) * count;\n      c = v->first;\n      for (vector<Event>::iterator e = v->second.begin();\n           e != v->second.end(); ++e)\n        for (int i = e->second.first; i < e->second.second; i++)\n          dp[i] += e->first;\n    }\n    /*\n    fill(dp, dp+mx, 0);\n    for (map<int, vector<Event> >::iterator v = events.begin();\n         v != events.end(); ++v) {\n      int count = 0;\n      for (int i = 0; i < mx; i++) if (dp[i]) count++;\n      area += (v->first - c) * count;\n      c = v->first;\n      for (vector<Event>::iterator e = v->second.begin();\n           e != v->second.end(); ++e)\n        for (int i = e->second.first; i < e->second.second; i++)\n          dp[i] += e->first;\n      for (int i = 0; i < mx; i++)\n        cout << dp[i] << ' ';\n      cout << endl;\n    }\n    */\n    cout << area << endl;\n    if (r == 2)\n      cout << circumference << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint  sheets[3][10007], tmp[10007];\n\n\n\nint main(){\n  while(1){\n    int n, r;\n    int x1, y1, x2, y2, mx = 0, my = 0, menseki = 0, gaishuu = 0;\n    vector<pair<int, int> > points;\n    map<pair<int ,int> , int> nums;\n    scanf(\"%d%d\", &n, &r);\n    memset(sheets, 0, sizeof(sheets));\n    if(n == 0 && r == 0)return 0;\n    for(int i = 0;i < n;i++){\n      scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n      x1++,y1++,x2++,y2++;\n      points.push_back(make_pair(x1, y1));\n      points.push_back(make_pair(x1, y2));\n      points.push_back(make_pair(x2, y1));\n      points.push_back(make_pair(x2, y2));\n      if(nums.count(make_pair(x1, y1)) == 0)nums[make_pair(x1, y1)] = 0;\n      if(nums.count(make_pair(x2, y1)) == 0)nums[make_pair(x2, y1)] = 0;\n      if(nums.count(make_pair(x1, y2)) == 0)nums[make_pair(x1, y2)] = 0;\n      if(nums.count(make_pair(x2, y2)) == 0)nums[make_pair(x2, y2)] = 0;\n      nums[make_pair(x1, y1)]++;\n      nums[make_pair(x2, y2)]++;\n      nums[make_pair(x1, y2)]--;\n      nums[make_pair(x2, y1)]--;\n      mx = max(mx, x1);\n      mx = max(mx, x2);\n      my = max(my, y1);\n      my = max(my, y2);\n    }\n    sort(points.begin(), points.end(), greater< pair<int, int> >());\n    memset(tmp, 0, sizeof(tmp));\n    for(int i = 1;i <= mx ; i++){\n      for(int j = 1;j <= my + 1; j++){\n\tif(points.back().first == i && points.back().second == j){\n\t  tmp[j] += nums[points.back()];\n\t  pair<int, int> tmpr = points.back();\n\t  while(points.back() == tmpr)points.pop_back();\n\t}\n\tsheets[i % 3][j] = sheets[i % 3][j - 1] + tmp[j];\n\tif(sheets[i % 3][j] > 0)menseki++;\n\tif(r == 2){\n\t  if(sheets[i % 3][j] > 0 ){\n\t    if(sheets[(i - 1) % 3][j] == 0)gaishuu++;\n\t    if(sheets[i % 3][j - 1] == 0)gaishuu++;\n\t  }\n\t  if(sheets[i % 3][j] == 0 ){\n\t    if(sheets[(i - 1) % 3][j] > 0)gaishuu++;\n\t    if(sheets[i % 3][j - 1] > 0)gaishuu++;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", menseki);\n    if(r == 2){\n      printf(\"%d\\n\", gaishuu);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        int** map;\n        map=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            map[w] = new int[10001];\n        }\n        \n        int** imos;\n        imos=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            imos[w] = new int[10001];\n        }\n       \n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n        }\n\n        int S=0;\n        int L=0;\n        for(int h=0;h<=10000;h++){\n            int state=0;\n           for(int w=0;w<=10000;w++){\n               int res=0;\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n\n        cout<<S<<endl;\n        if(r==2)cout<<L<<endl;\n \n\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\n\nstruct block{\n\tint x1,x2,y,f;\n};\n\nblock b[20002];\nint fie[10002][2];\n\nbool comp(const block &b1,const block &b2){\n\treturn b1.y<b2.y;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(b,0,sizeof(b));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint y1,y2;\n\t\t\tscanf(\"%d%d%d%d\",&b[i*2].x1,&y1,&b[i*2].x2,&y2);\n\t\t\tb[i*2].x2--;\n\t\t\tb[i*2+1].x1=b[i*2].x1;\n\t\t\tb[i*2+1].x2=b[i*2].x2;\n\t\t\tb[i*2].y=y1;\n\t\t\tb[i*2+1].y=y2;\n\t\t\tb[i*2].f=1;\n\t\t\tb[i*2+1].f=-1;\n\t\t}\n\t\tsort(b,b+n*2,comp);\n\t\tint ny=0;\n\t\tint now=0,prev=1;\n\t\tint res=0,res2=0;\n\t\tfor(int i=0;i<n*2;i++){\n\t\t\tif(ny!=b[i].y){\n\t\t\t\tswap(now,prev);\n\t\t\t\tint cnt=0;\n\t\t\t\tint cnt2=0,bt=0,cnt3=0;\n\t\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\t\tif(fie[j][now]>0 && fie[j][prev]==0)cnt3++;\n\t\t\t\t\tif(fie[j][now]==0 && fie[j][prev]>0)cnt3++;\n\t\t\t\t\tfie[j][now]=fie[j][prev];\n\t\t\t\t\tif(fie[j][now]>0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(bt==0)cnt2++,bt=1;\n\t\t\t\t\t}else bt=0;\n\t\t\t\t}\n\t\t\t\tres+=cnt*(b[i].y-ny);\n\t\t\t\tres2+=cnt2*2*(b[i].y-ny)+cnt3;\n\t\t\t}\n\t\t\tny=b[i].y;\n\t\t\tfor(int j=b[i].x1;j<=b[i].x2;j++)fie[j][now]+=b[i].f;\n\t\t\t//printf(\"%d\\n\",res2);\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\tif(r==2){\n\t\t\tswap(now,prev);\n\t\t\tint cnt3=0;\n\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\tif(fie[j][now]>0 && fie[j][prev]==0)cnt3++;\n\t\t\t\tif(fie[j][now]==0 && fie[j][prev]>0)cnt3++;\n\t\t\t\tfie[j][now]=fie[j][prev];\n\t\t\t}\n\t\t\tres2+=cnt3;\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int a;\n    int b1, b2;\n    bool start;\n\n    Tag() : a(0), b1(0), b2(0), start(false) {}\n    Tag(int aa, int bb1, int bb2, bool s) : a(aa), b1(bb1), b2(bb2), start(s) {}\n};\n\nbool cmp(const Tag &t1, const Tag &t2) {\n    if(t1.a != t2.a) return t1.a < t2.a;\n    return !t1.start;\n}\n\nint main() {\n    while(true) {\n        int N, R;\n        cin >> N >> R;\n        if(!N && !R) break;\n\n        vector<Tag> xtag, ytag;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            xtag.push_back(Tag(x1, y1, y2, true));\n            xtag.push_back(Tag(x2, y1, y2, false));\n            ytag.push_back(Tag(y1, x1, x2, true));\n            ytag.push_back(Tag(y2, x1, x2, false));\n        }\n        sort(xtag.begin(), xtag.end(), cmp);\n        sort(ytag.begin(), ytag.end(), cmp);\n\n        int max_y = ytag[ytag.size()-1].a;\n        int area = 0;\n        int len = 0;\n        for(int y = 0; y < max_y; ++y) {\n            int depth = 0;\n            int startx = 0;\n            int prevx = -1;\n            for(int i = 0; i < xtag.size(); ++i) {\n                if(xtag[i].b1 <= y && y < xtag[i].b2) {\n                    if(xtag[i].start) {\n                        if(depth == 0) {\n                            if(xtag[i].a != prevx) ++len;\n                            else --len;\n                            startx = xtag[i].a;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            area += xtag[i].a-startx;\n                            prevx = xtag[i].a;\n                            ++len;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << area << endl;\n        if(R == 1) continue;\n\n        int max_x = xtag[xtag.size()-1].a;\n        for(int x = 0; x < max_x; ++x) {\n            int depth = 0;\n            int prevy = -1;\n            for(int i = 0; i < ytag.size(); ++i) {\n                if(ytag[i].b1 <= x && x < ytag[i].b2) {\n                    if(ytag[i].start) {\n                        if(depth == 0) {\n                            if(prevy != ytag[i].a) ++len;\n                            else --len;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            ++len;\n                            prevy = ytag[i].a;\n                        }\n                    }\n                }\n            }\n        }\n        cout << len << endl;\n        return 0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[2][10000];\npair<pair<int,int>,pair<int,int> >event[20000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\tint xm=0;\n\tint ym=0;\n\tfor(int i=0;i<a;i++){\n\t\tint p,q,r,s;\n\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tevent[i*2]=make_pair(make_pair(p,1),make_pair(q,s));\n\t\tevent[i*2+1]=make_pair(make_pair(r,-1),make_pair(q,s));\n\t\txm=max(xm,r);\n\t\tym=max(ym,s);\n\t}\n\tstd::sort(event,event+a*2);\n\t\n\tfor(int i=0;i<2;i++)\n\t\tfor(int j=0;j<ym;j++)\n\t\t\tdp[i][j]=0;\n\tint S=0;\n\tint D=0;\n\tint at=0;\n\tfor(int i=0;i<=xm;i++){\n\t\tint u=i&1;\n\t\tfor(int j=0;j<ym;j++)dp[u][j]=dp[!u][j];\n\t\tfor(;at<2*a&&event[at].first.first==i;at++){\n\t\t\tfor(int j=event[at].second.first;j<event[at].second.second;j++)dp[u][j]+=event[at].first.second;\n\t\t}\n\t\tfor(int j=0;j<ym;j++)if(dp[u][j])S++;\n\t\tfor(int j=0;j<ym;j++)if((dp[u][j]||dp[!u][j])&&!(dp[u][j]&&dp[!u][j]))D++;\n\t\tfor(int j=0;j<ym-1;j++)if((dp[u][j]||dp[u][j+1])&&!(dp[u][j]&&dp[u][j+1]))D++;\n\t\tif(dp[u][0])D++;\n\t\tif(dp[u][ym-1])D++;\n\t}\n\tprintf(\"%d\\n\",S);\n\tif(b==2)printf(\"%d\\n\",D);\n}}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    int x[10000][2],y[10000][2];\n    vector<int> vx(2),vy(2);\n    vx[0]=vy[0]=-1;\n    vx[1]=vy[1]=10001;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<2;j++){\n\tcin>>x[i][j]>>y[i][j];\n\tvx.push_back(x[i][j]);\n\tvy.push_back(y[i][j]);\n      }\n    }\n    sort(vx.begin(),vx.end());\n    vx.erase(unique(vx.begin(),vx.end()),vx.end());\n    sort(vy.begin(),vy.end());\n    vy.erase(unique(vy.begin(),vy.end()),vy.end());\n    vector<vector<char> > v(vy.size()-1,vector<char>(vx.size()-1));\n    for(int i=0;i<n;i++){\n      int jl=lower_bound(vy.begin(),vy.end(),y[i][1])-vy.begin();\n      for(int j=lower_bound(vy.begin(),vy.end(),y[i][0])-vy.begin();j<jl;j++){\n\tint kl=lower_bound(vx.begin(),vx.end(),x[i][1])-vx.begin();\n\tfor(int k=lower_bound(vx.begin(),vx.end(),x[i][0])-vx.begin();k<kl;k++){\n\t  v[j][k]=true;\n\t}\n      }\n    }\n    int a=0;\n    for(int i=0;i<v.size();i++){\n      for(int j=0;j<v[i].size();j++){\n\tif(v[i][j]){\n\t  a+=(vy[i+1]-vy[i])*(vx[j+1]-vx[j]);\n\t}\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j+1<v[i].size();j++){\n\t  if(v[i][j]^v[i][j+1]){\n\t    l+=vy[i+1]-vy[i];\n\t  }\n\t}\n      }\n      for(int i=0;i<v[0].size();i++){\n\tfor(int j=0;j+1<v.size();j++){\n\t  if(v[j][i]^v[j+1][i]){\n\t    l+=vx[i+1]-vx[i];\n\t  }\n\t}\n      }\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int a;\n    int b1, b2;\n    bool start;\n\n    Tag() {}\n    Tag(int aa, int bb1, int bb2, bool s) : a(aa), b1(bb1), b2(bb2), start(s) {}\n};\n\nbool cmp(const Tag &t1, const Tag &t2) {\n    if(t1.a != t2.a) return t1.a < t2.a;\n    return !t1.start;\n}\n\nint main() {\n    while(true) {\n        int N, R;\n        cin >> N >> R;\n        if(!N && !R) break;\n\n        vector<Tag> xtag, ytag;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            xtag.push_back(Tag(x1, y1, y2, true));\n            xtag.push_back(Tag(x2, y1, y2, false));\n            ytag.push_back(Tag(y1, x1, x2, true));\n            ytag.push_back(Tag(y2, x1, x2, false));\n        }\n        sort(xtag.begin(), xtag.end(), cmp);\n        sort(ytag.begin(), ytag.end(), cmp);\n\n        int max_y = ytag.back().a;\n        int area = 0;\n        int len = 0;\n        for(int y = 0; y < max_y; ++y) {\n            int depth = 0;\n            int startx = 0;\n            int prevx = -1;\n            for(int i = 0; i < xtag.size(); ++i) {\n                if(xtag[i].b1 <= y && y < xtag[i].b2) {\n                    if(xtag[i].start) {\n                        if(depth == 0) {\n                            if(xtag[i].a != prevx) ++len;\n                            else --len;\n                            startx = xtag[i].a;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            area += xtag[i].a-startx;\n                            ++len;\n                            prevx = xtag[i].a;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << area << endl;\n        if(R == 1) continue;\n\n        int max_x = xtag.back().a;\n        for(int x = 0; x < max_x; ++x) {\n            int depth = 0;\n            int prevy = -1;\n            for(int i = 0; i < ytag.size(); ++i) {\n                if(ytag[i].b1 <= x && x < ytag[i].b2) {\n                    if(ytag[i].start) {\n                        if(depth == 0) {\n                            if(prevy != ytag[i].a) ++len;\n                            else --len;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            ++len;\n                            prevy = ytag[i].a;\n                        }\n                    }\n                }\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n\nint area;\nint length;\n\nRECT calc[10000];\nRECT before[10000];\nRECT grid[10000];\nint bsize;\n\nbool comp(const RECT& rLeft, const RECT& rRight){\n    return (rLeft.sx < rRight.sx);\n}\n\nvoid mergeArea(int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n    \n    if (n == 0){\n        return;\n    }\n    \n    sort(grid, grid + n, comp);\n    \n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n    \n    *sq = num;\n}\n\nvoid mergeLength(int n)\n{\n    vector<int> total;\n    int i;\n    int res;\n    \n    for (i = 0; i < n; i++){\n        total.push_back(calc[i].sx);\n        total.push_back(calc[i].ex);\n    }\n    for (i = 0; i < bsize; i++){\n        total.push_back(before[i].sx);\n        total.push_back(before[i].ex);\n    }\n    \n    sort(total.begin(), total.end());\n    res = 0;\n    for (i = 0; i < total.size(); i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n\nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    int num;\n    int i, j;\n    int sq;\n    int miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        miny = 1000000;\n        maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n            miny = min(miny, p[i].sy);\n            maxy = max(maxy, p[i].ey);\n        }\n        if (query == 1){\n            continue;\n        }\n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        area = length = 0;\n        for (i = miny; i <= maxy; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n            }\n            mergeArea(num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        printf(\"%d\\n\", area);\n        if (query == 1){\n            continue;\n        }\n        printf(\"%d\\n\", length);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint map[10003][10003];\n\nint main(void){\n\twhile(1){\n\t\tint n,r,ans=0,ans2=0,minx=0,miny=0,maxx=10001,maxy=10001;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tminx=max(x1+1,minx);\n\t\t\tminy=max(y1+1,miny);\n\t\t\tmaxx=min(x2+1,maxx);\n\t\t\tmaxy=min(y2+1,maxy);\n\t\t\tmap[x1+1][y1+1]-=1;\n\t\t\tmap[x2+1][y1+1]+=1;\n\t\t\tmap[x1+1][y2+1]+=1;\n\t\t\tmap[x2+1][y2+1]-=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tmap[j][i]=map[j][i]+map[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tmap[i][j]=map[i][j]+map[i][j+1];\n\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\t\tif(map[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1000000000\n#define fi first\n#define sec second\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nmap<P,int> *m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m=new map<P,int>();\n        scanf(\"%d %d\",&n,&r);\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            (*m)[P(a,b)]++;\n            (*m)[P(a,d)]--;\n            (*m)[P(c,b)]--;\n            (*m)[P(c,d)]++;\n        }\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m->find(P(i,j));\n                if(it!=m->end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n        delete m;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tmemset(g,0,sizeof(g));\n\t\tint mx = 10001,Mx = 1,my = 10001,My = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\ta++;b++;c++;d++;\n\t\t\tg[a][b]++; g[a][d]--;\n\t\t\tg[c][b]--; g[c][d]++;\n\t\t\tmx = min(mx,a);\n\t\t\tMx = max(Mx,c);\n\t\t\tmy = min(my,b);\n\t\t\tMy = max(My,d);\n\t\t}\n\t\t\n\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\tint t = 0;\n\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tg[i][j] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s = 0;\n\t\tfor(int j = my; j <= My; j++){\n\t\t\tint t = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tif(g[i][j] = t)s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t\t\n\t\tif(r==2){\n\t\t\tint l = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\t\tif(g[i][j]){\n\t\t\t\t\t\tl += !g[i-1][j]+!g[i+1][j]+!g[i][j-1]+!g[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[4000][3900];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\t//for(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]);\n\t\t\tvx.push_back(x2[i]);\n\t\t\tvy.push_back(y1[i]);\n\t\t\tvy.push_back(y2[i]);\n\t\t//}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\n//const long long int INF_=1<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint min_x,min_y,max_x,max_y;\n\ninline void Imos(map<P,short> &plane){\n\tREP(y,0,max_y+4-min_y){\n\t\tREP(x,1,max_x+4-min_x){\n\t\t\tplane[MP(x,y)]+=plane[MP(x-1,y)];\n\t\t}\n\t}\n\tREP(x,0,max_x+4-min_x){\n\t\tfor(int y=max_y+4-min_y; y>=0; --y){\n\t\t\tplane[MP(x,y)]+=plane[MP(x,y+1)];\n\t\t}\n\t}\n}\n\ninline int CalcSize(map<P,short> &plane){\n\tint result=0;\n\tREP(x,0,max_x+4-min_x){\n\t\tREP(y,0,max_y+4-min_y){\n\t\t\tif(plane[MP(x,y)]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(map<P,short> &plane,map<P,bool> &has_done,int x,int y,int W,int H){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[MP(x,y)]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[MP(nx,ny)]){\n\t\t\t\tif(plane[MP(nx,ny)]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[MP(nx,ny)]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t\t//cout << result << ' ' << p.F_ << ' ' << p.S_ << endl;\n\t}\n\treturn result;\n}\n\ninline int CalcLength(map<P,short> &plane,vector<int> &X,vector<int> &Y){\n\tmap<P,bool> has_done;\n\tint result=0;\n\tREP(i,0,X.size()){\n\t\tif(!has_done[MP(X[i],Y[i])]&&plane[MP(X[i],Y[i])]>0){\n\t\t\tresult+=BFS(plane,has_done,X[i],Y[i],max_x+4-min_x,max_y+4-min_y);\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tX[j].push_back(x);\n\t\t\t\tY[j].push_back(y);\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\t//vector<vector<short> > plane(max_x+4-min_x,vector<short>(max_y+4-min_y));\n\t\tmap<P,short> plane;\n\t\tREP(i,0,N){\n\t\t\tplane[MP(X[0][i]+1-min_x,Y[1][i]+1-min_y)]+=1;\n\t\t\tplane[MP(X[1][i]+2-min_x,Y[0][i]-min_y)]+=1;\n\t\t\tplane[MP(X[0][i]+1-min_x,Y[0][i]-min_y)]+=-1;\n\t\t\tplane[MP(X[1][i]+2-min_x,Y[1][i]+1-min_y)]+=-1;\n\t\t}\n\t\tImos(plane);\n\t\t/*\n\t\tfor(int y=plane[0].size()-1; y>=0; --y){\n\t\t\tREP(x,0,plane.size()){\n\t\t\t\tcout << plane[x][y] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << CalcSize(plane) << endl;\n\t\tif(R==2) cout << CalcLength(plane,X[0],Y[0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define INIT(a) memset(a,0,sizeof(a))\nusing namespace std;\n\nint main(){\n  int n,r;\n  int x1[10010],y1[10010],x2[10010],y2[10010];\n  int imos[10010];\n\n  while(cin >> n >> r,n){\n    for(int i=0;i<n;i++)cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\n    int area = 0;\n    for(int i=0;i<=10000;i++){\n      INIT(imos);\n      for(int j=0;j<n;j++){\n\tif(x1[j]<=i && i<x2[j]){\n\t  imos[y1[j]]++; imos[y2[j]]--;\n\t}\n      }\n      for(int i=0;i<10000;i++)imos[i+1] += imos[i];\n      for(int i=0;i<=10000;i++){\n\tif(imos[i])area++;\n      }\n    }\n\n    cout << area << endl;\n\n    if(r==2){\n      int len = 0;\n      for(int t=0;t<2;t++){\n\tfor(int i=0;i<=10000;i++){\n\t  INIT(imos);\n\t  for(int j=0;j<n;j++){\n\t    if(x1[j]<=i && i<x2[j]){\n\t      imos[y1[j]]++; imos[y2[j]]--;\n\t    }\n\t  }\n\t  for(int i=0;i<10000;i++)imos[i+1] += imos[i];\n\t  for(int i=0;i<=10000;i++){\n\t    if(imos[i]){\n\t      if(i==0 || imos[i-1]==0)len++;\n\t      if(i==10000 || imos[i+1]==0)len++;\n\t    }\n\t  }\n\t}\n\tfor(int i=0;i<n;i++){\n\t  swap(x1[i],y1[i]);\n\t  swap(x2[i],y2[i]);\n\t}\n      }\n      cout << len << endl;\n    }\n  }\n}\n      \n  "
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 10000;\n\nstruct Sheet {int left, bottom, right, top;};\nbool operator<(const Sheet& lhs, const Sheet& rhs) {\n    if(lhs.bottom != rhs.bottom) return lhs.bottom < rhs.bottom;\n    return lhs.top < rhs.top;\n}\n\nstruct Range {\n    int bottom, top;\n    Range(const int bottom, const int top) :bottom(bottom), top(top) {}\n};\n\nint main() {\n    int n, r;\n    while(cin >> n >> r, n | r) {\n        vector<vector<Range>> list(MAX + 1);\n        vector<Sheet> sheet(n);\n        for(auto& s: sheet) cin >> s.left >> s.bottom >> s.right >> s.top;\n\n        sort(sheet.begin(), sheet.end());\n        for(auto s: sheet) for(int x = s.left; x < s.right; ++x) {\n            for(int i = 0; i < list[x].size(); ++i) {\n                if(list[x][i].top < s.bottom) continue;\n                list[x][i].top = max(list[x][i].top, s.top);\n                while(i + 1 < list[x].size() && list[x][i].top >= list[x][i + 1].bottom) {\n                    list[x][i].top = max(list[x][i].top, list[x][i + 1].top);\n                    list[x].erase(list[x].begin() + i + 1);\n                }\n                break;\n            }\n            if(list[x].empty() || list[x].back().top < s.bottom) list[x].emplace_back(s.bottom, s.top);\n        }\n\n        int area = 0, circumference = 0;\n        int length, touch_left = 0, touch_right;\n        for(int x = 0; x < list.size(); ++x) {\n            if(list[x].empty()) continue;\n            length = touch_right = 0;\n            for(const auto& l: list[x]) {\n                length += l.top - l.bottom;\n                for(const auto& l2: list[x + 1]) {\n                    if(l.top < l2.bottom || l2.top < l.bottom) continue;\n                    touch_right += min(l.top, l2.top) - max(l.bottom, l2.bottom);\n                }\n            }\n            area += length;\n            circumference += list[x].size() * 2;\n            circumference += 2 * length - touch_left - touch_right;\n            touch_left = touch_right;\n        }\n\n        cout << area << endl;\n        if(r == 2) cout << circumference << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAX 10000\n//int 4byte\n//データ構造 R（左下，右上）,(LorR，左端ｘ座標，Rx)\n//参考：蟻231 233\n//ｘ毎のmin maxを記録\n//vectorに入れてソート\n\nusing namespace std;\n\nint main(){\n    while(1){\n        vector< vector<int> > square(MAX+1, vector<int>(MAX+1));\n        int mode, num, area = 0, len = 0 ,count, countL, countR;\n        int x, y, xx, yy;\n        int MAX_X = 0, MAX_Y = 0;\n        cin >> num >> mode;\n        if(num == 0 && mode == 0)break;\n        \n        for (int i = 0; i<num; i++){\n            cin >> x >> y >> xx >> yy;\n            for(int dx=x;dx<xx;dx++){\n                square[dx][y] += 1;\n                square[dx][yy] += -1;\n            }\n        }\n        for(int dx=0;dx<MAX+1;dx++){\n            count = 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[dx][dy];\n                if(count > 0) area++;\n            }\n        }\n        cout << area <<endl;\n        \n        \n        if(mode == 2){\n            //左端\n            count = 0;\n            countR= 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[0][dy];\n                countR+= square[1][dy];\n                if(count > 0) len++;\n                if(count > 0 && count == square[0][dy])len++;\n                if(count > 0 && countR < 1)len++;\n                if(count == 0 && square[0][dy] < 0)len++;\n            }\n            //中\n            for(int dx=1;dx<MAX;dx++){\n                countL= 0;\n                count = 0;\n                countR= 0;\n                for(int dy=0;dy<MAX+1;dy++){\n                    countL+= square[dx-1][dy];\n                    count += square[dx][dy];\n                    countR+= square[dx+1][dy];\n                    if(count > 0 && countL < 1)len++;\n                    if(count > 0 && countR < 1)len++;\n                    if(count > 0 && count == square[dx][dy])len++;\n                    if(count == 0 && square[dx][dy] < 0)len++;\n                }\n            }\n            //右端\n            count = 0;\n            countL= 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[MAX][dy];\n                countL+= square[MAX-1][dy];\n                if(count > 0) len++;\n                if(count > 0 && count == square[MAX][dy])len++;\n                if(count > 0 && countL < 1)len++;\n                if(count == 0 && square[MAX][dy] < 0)len++;\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nclass Compression {\npublic:\n    Compression(const std::vector<int>& list) {\n        value_ = list;\n        std::sort(value_.begin(), value_.end());\n        value_.erase(std::unique(value_.begin(), value_.end()), value_.end());\n        for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n    }\n    int size() const {return value_.size();}\n    int index(const int v) const {return index_.at(v);}\n    int operator[](const int i) const {return value_.at(i);}\nprivate:\n    std::map<int, int> index_;\n    std::vector<int> value_;\n};\n\nstruct Square {int left, top, right, bottom;};\n\nint main() {\n    int n, r;\n    while(cin >> n >> r, n | r) {\n        vector<int> tx = {0}, ty = {0};\n        vector<Square> sheet(n);\n        for(auto& s: sheet) {\n            cin >> s.left >> s.top >> s.right >> s.bottom;\n            tx.push_back(++s.left);\n            tx.push_back(++s.right);\n            ty.push_back(++s.top);\n            ty.push_back(++s.bottom);\n        }\n        Compression x(tx), y(ty);\n\n        vector<vector<int>> dp(y.size(), vector<int>(x.size(), 0));\n        for(const auto& s: sheet) {\n            ++dp[y.index(s.top)][x.index(s.left)];\n            --dp[y.index(s.top)][x.index(s.right)];\n            --dp[y.index(s.bottom)][x.index(s.left)];\n            ++dp[y.index(s.bottom)][x.index(s.right)];\n        }\n\n        for(int i = 0; i < y.size(); ++i) for(int j = 1; j < x.size(); ++j) dp[i][j] += dp[i][j - 1];\n        for(int j = 0; j < x.size(); ++j) for(int i = 1; i < y.size(); ++i) dp[i][j] += dp[i - 1][j];\n\n        int area = 0, circumference = 0;\n        for(int i = 1; i < y.size() - 1; ++i) for(int j = 1; j < x.size() - 1; ++j) {\n            if(!dp[i][j]) continue;\n            area += (y[i + 1] - y[i]) * (x[j + 1] - x[j]);\n            if(!dp[i - 1][j]) circumference += (x[j + 1] - x[j]);\n            if(!dp[i + 1][j]) circumference += (x[j + 1] - x[j]);\n            if(!dp[i][j - 1]) circumference += (y[i + 1] - y[i]);\n            if(!dp[i][j + 1]) circumference += (y[i + 1] - y[i]);\n        }\n        cout << area << endl;\n        if(r) cout << circumference << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint fie[2000][2000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n\n      // update right_area_end_point\n      // auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      // for (auto&& point : points) {\n      //   int x = point.first, y = point.second;\n\n      //   repete_from_to(y_i, y - 1, p_i) {\n      //     assign_if_larger(right_area_end_point[p_i], x);\n      //   }\n      // }\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      // if (type == 2) {\n      //   // left line exists\n      //   if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n      //   // bottom line exists\n      //   if (\n      //       (y_i == 0 && is_area[x_i % 2][y_i]) ||\n      //       (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n      //       )\n      //     lines += 1;\n      // }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n  \n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    \n    vector<pair<P,P> > in;\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n    \n    sort(in.begin(),in.end(),cmp_y);\n    \n    int S=0,L=0;\n    vector<P>v;\n    for(int i=0;i+1<10001;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n      }\n      \n      if(v.size()!=0){\n\tsort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n    \n    \n    if(r==2){\n      \n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i+1<10001;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\n\t}\n\tif(v.size()!=0){\n\t  sort(v.begin(),v.end());\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdio.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(), (v).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint n,h,w;\nint fld[100][100];\nint l[1001],r[1001],t[1001],b[1001];\nvector<int> v[1001],ans;\nbool used[1001];\n\nvoid visit(int u) {\n\tif(used[u]==false) {\n\t\tused[u]=true;\n\t\tREP(i,v[u].size()) visit(v[u][i]);\n\t\tans.pb(u);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>n>>w>>h;\n\tREP(i,h) REP(j,w) cin>>fld[i][j];\n\n\tREP(i,n) l[i]=w,t[i]=h;\n\n\tREP(i,h) {\n\t\tREP(j,w) {\n\t\t\tint c=fld[i][j]-1;\n\t\t\tl[c]=min(l[c],j);\n\t\t\tt[c]=min(t[c],i);\n\t\t\tr[c]=max(r[c],j);\n\t\t\tb[c]=max(b[c],i);\n\t\t}\n\t}\n\tREP(i,n) {\n\t\tREP(j,n) used[j]=false;\n\t\tused[i]=true;\n\t\tFOR(j,l[i],r[i]+1) {\n\t\t\tFOR(k,t[i],b[i]+1) {\n\t\t\t\tint c=fld[i][j]-1;\n\t\t\t\tif(used[c]) continue;\n\t\t\t\tv[i].pb(c);\n\t\t\t\tused[c]=true;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i,n) used[i]=false;\n\tREP(i,n) visit(i);\n\treverse(ALL(ans));\n\tREP(i,n) cout<<ans[i]+1<<' ';\n\tcout<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; i++)\n\nint n, r;\nshort m[10010][10010];\nint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &r),n||r){\n\t\trep(i,10010) rep(j,10010) m[i][j] = 0;\n\t\trep(i,n){\n\t\t\tint x1, x2, y1, y2;\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\tx1++; y1++;\n\t\t\tm[x1][y1]++; m[x2+1][y1]--; m[x1][y2+1]--; m[x2+1][y2+1]++;\n\t\t}\n\t\trep(i,10010) for(int j = 1; j < 10010; j++){\n\t\t\tm[i][j] += m[i][j-1];\n\t\t}\n\t\trep(i,10010) for(int j = 1; j < 10010; j++){\n\t\t\tm[j][i] += m[j-1][i];\n\t\t}\n\t\tint s = 0;\n\t\trep(i,10010) rep(j,10010) if(m[i][j] > 0) s++;\n\t\tprintf(\"%d\\n\", s);\n\t\tif(r == 1) continue;\n\t\ts = 0;\n\t\trep(i,10010) rep(j,10010){\n\t\t\tif(m[i][j] == 0) continue;\n\t\t\trep(k,4){\n\t\t\t\tif(m[i+dx[k]][j+dy[k]] == 0) s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[10002];\nvector<P> xx[10002];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 10002; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tbool f = true;\n\tfor(int k = 0; k < (int)x[j].size(); k++){\n\t  if(x[j][k].F <= y2 && x[j][k].S >= y1){\n\t    x[j][k].F = min(x[j][k].F,y1);\n\t    x[j][k].S = max(x[i][k].S,y2);\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\tif(f) x[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n      //x[i].clear();\n      /*\n      cout << \"x = \" << i << endl;\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tcout << \"( \" << xx[i][j].F << \" , \" << xx[i][j].S << \" )\" << endl;\n      }\n      cout << endl;\n      //*/\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    vector<P> v[10001];\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n      \n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[10002];\nvector<P> xx[10002];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 10002; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tx[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n      //x[i].clear();\n      /*\n      cout << \"x = \" << i << endl;\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tcout << \"( \" << xx[i][j].F << \" , \" << xx[i][j].S << \" )\" << endl;\n      }\n      cout << endl;\n      //*/\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,short *x1,short *x2,short *y1,short *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  rep(i,n){\n    xd[px++]=x1[i];\n    xd[px++]=x2[i];\n  }\n  sort(xd,xd+px);\n  px=unique(xd,xd+px)-xd;\n  rep(i,px)IN[i].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static short x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    int mnx=INF,mny=INF,mxx=0,mxy=0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n      mnx=min(mnx,x1);\n      mny=min(mny,y1);\n      mxx=max(mxx,x2);\n      mxy=max(mxy,y2);\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    vector<P>v;\n    for(int i=mny;i<mxy;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n\tif(i<in[j].S.F)break;\n      }\n     \n      if(v.size()!=0){\n\tsort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    printf(\"%d\\n\",S);\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end(),cmp_x);\n\n      for(int i=mnx;i<mxx;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\n\t  if(i<in[j].F.F)break;\n\t}\n\tif(v.size()!=0){\n\t  sort(v.begin(),v.end());\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      printf(\"%d\\n\",L);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\nvector<pair<P,P> > in;\nvector<P> v[10001];\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    in.clear();\n    for(int i=0;i<10001;i++)v[i].clear();\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n      \n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b, b=B, e=E, L+=2;\n      }\n      S+=e-b, L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B, e=E, L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint map[103][103]={};\nint main(){\n\n\n\nint H1,W1,H2,W2;\nint n,m;\nwhile(1){\nscanf(\"%d %d\",&n,&m);\nif(n==0&&m==0)break;\nfor(int iii=0;iii<n;iii++){\nscanf(\"%d %d %d %d\",&W1,&H1,&W2,&H2);\nfor(int i=H1+1;i<H2+1;i++)\nfor(int j=W1+1;j<W2+1;j++)\nmap[i][j]=1;\n}\n\nint c=0;\nfor(int i=1;i<101;i++)\nfor(int j=1;j<101;j++)\nif(map[i][j]==1)c++;\n\nint cc=0;\n\nfor(int i=1;i<101;i++)\nfor(int j=1;j<101;j++)\n{\nif(map[i][j]==1){\nif(map[i+1][j]==0)cc++;\nif(map[i-1][j]==0)cc++;\nif(map[i][j+1]==0)cc++;\nif(map[i][j-1]==0)cc++;\n\n\n}\n}\n\n\nprintf(\"%d\\n\",c);\nif(m==2)printf(\"%d\\n\",cc);\n\nfor(int i=1;i<101;i++)\nfor(int j=1;j<101;j++)\n\tmap[i][j]=0;\n\n}\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint v[10002][10002];\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n\n\n  while(cin >> n >> r,n|r){\n    int mx=0,my=0;\n\n    for(int i=0;i<10002;i++)\n      for(int j=0;j<10002;j++)\n\tv[i][j]=0;\n\n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      mx=max(mx,x2);\n      my=max(my,y2);\n\n      for(int j=x1+1;j<=x2;j++)\n        for(int k=y1+1;k<=y2;k++)\n\t  v[j][k]=1;\n    }\n    \n    int S=0;\n    for(int i=1;i<10001;i++)\n      for(int j=1;j<10001;j++)\n\tif(v[i][j])S++;\n\n    cout << S << endl;\n\n    if(r==2){\n      int L=0,fg=0;\n      for(int i=1;i<10001;i++){\n\tfor(int j=1;j<10001;j++){\n\t  if(mx<i && my<j){\n\t    fg=1;\n\t    break;\n\t  } \n\t  if(v[i][j]==1){\n\t    if(v[i-1][j]==0)L++;\n\t    if(v[i+1][j]==0)L++;\n\t    if(v[i][j-1]==0)L++;\n\t    if(v[i][j+1]==0)L++;\n\t  }\n\t}\n\tif(fg)break;\n      }\n      cout << L << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint max(int* arr) {\n  int max = arr[0];\n  cout << \"sizeof: \" << sizeof(arr)/sizeof(arr[0]) << endl;\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (max < arr[i]) max = arr[i];\n  }\n  return max;\n}\n\nint min(int* arr) {\n  int min = arr[0];\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (min > arr[i]) min = arr[i];\n  }\n  return min;\n}\n\nint main(int argc, char const* argv[])\n{\n  ifstream ifs(\"input.txt\");\n  int count, type;\n  int *x1, *y1, *x2, *y2;\n  int left, bottom, right, top;\n  while (ifs >> count >> type) {\n    cout << \"count: \" << count << endl;\n    x1 = new int[count];\n    y1 = new int[count];\n    x2 = new int[count];\n    y2 = new int[count];\n    \n    // input\n    for (int i = 0; i < count; i++) {\n      ifs >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n\n    // field\n    left = min(x1);\n    bottom = min(y1);\n    right = max(x2);\n    top = max(y2);\n\n    cout << \"left:\"   << left   << endl;\n    cout << \"bottom:\" << bottom << endl;\n    cout << \"right:\"  << right  << endl;\n    cout << \"top:\"    << top    << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint min_x,min_y,max_x,max_y;\n\ninline void Imos(vector<vector<short> > &plane){\n\tREP(y,0,plane[0].size()){\n\t\tREP(x,1,plane.size()){\n\t\t\tplane[x][y]+=plane[x-1][y];\n\t\t}\n\t}\n\tREP(x,0,plane.size()){\n\t\tfor(int y=plane[0].size()-2; y>=0; --y){\n\t\t\tplane[x][y]+=plane[x][y+1];\n\t\t}\n\t}\n}\n\ninline int CalcSize(vector<vector<short> > &plane){\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(plane[x][y]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(vector<vector<short> > &plane,vector<vector<bool> > &has_done,int x,int y,int W,int H){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[x][y]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[nx][ny]){\n\t\t\t\tif(plane[nx][ny]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[nx][ny]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int CalcLength(vector<vector<short> > &plane,int n,vector<int> &X,vector<int> &Y){\n\tvector<vector<bool> > has_done(plane.size(),vector<bool>(plane[0].size()));\n\tint result=0;\n\t/*\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(!has_done[x][y]&&plane[x][y]>0){\n\t\t\t\tresult+=BFS(plane,has_done,x,y,plane.size(),plane[0].size());\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tREP(i,0,n){\n\t\tif(!has_done[X[i]][Y[i]]&&plane[X[i]][Y[i]]>0) result+=BFS(plane,has_done,X[i],Y[i],plane.size(),plane[0].size());\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tX[j].push_back(x);\n\t\t\t\tY[j].push_back(y);\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\tvector<vector<short> > plane(max_x+4-min_x,vector<short>(max_y+4-min_y));\n\t\tREP(i,0,N){\n\t\t\tplane[X[0][i]+1-min_x][Y[1][i]+1-min_y]+=1;\n\t\t\tplane[X[1][i]+2-min_x][Y[0][i]-min_y]+=1;\n\t\t\tplane[X[0][i]+1-min_x][Y[0][i]-min_y]+=-1;\n\t\t\tplane[X[1][i]+2-min_x][Y[1][i]+1-min_y]+=-1;\n\t\t}\n\t\tImos(plane);\n\t\tcout << CalcSize(plane) << endl;\n\t\tif(R==2) cout << CalcLength(plane,N,X[0],Y[0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; i++)\n\nint n, r;\nint x1[10000],y1[10000],x2[10000],y2[10000];\nint dp[2][10010];\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &r),n||r){\n\t\tint ans = 0, ans2 = 0;\n\t\trep(i,2) rep(j,10010) dp[i][j] = 0;\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d%d%d\", &x1[i], &y1[i], &x2[i], &y2[i]);\n\t\t\tx1[i]++; y1[i]++;\n\t\t}\n\t\tfor(int u = 1; u < 10010; u++){\n\t\t\tfor(int v = 0; v < n; v++){\n\t\t\t\tif(y1[v] == u){\n\t\t\t\t\tdp[1][x1[v]]++;\n\t\t\t\t\tdp[1][x2[v]+1]--;\n\t\t\t\t}\n\t\t\t\tif(y2[v]+1 == u){\n\t\t\t\t\tdp[1][x1[v]]--;\n\t\t\t\t\tdp[1][x2[v]+1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int v = 1; v < 10010; v++) dp[1][v] += dp[1][v-1];\n\t\t\tfor(int v = 0; v < 10010; v++) dp[1][v] += dp[0][v];\n\t\t\tfor(int v = 0; v < 10010; v++) if(dp[1][v] > 0) ans++;\n\t\t\tif(r == 2){\n\t\t\t\tfor(int v = 1; v < 10009; v++){\n\t\t\t\t\tif(dp[1][v] == 0) continue;\n\t\t\t\t\tans2 += (dp[0][v] == 0)+(dp[1][v-1]==0)+(dp[1][v+1]==0);\n\t\t\t\t}\n\t\t\t\tfor(int v = 0; v < 10010; v++){\n\t\t\t\t\tif(dp[0][v] == 0) continue;\n\t\t\t\t\tans2 += (dp[1][v] == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int v = 0; v < 10010; v++){\n\t\t\t\tdp[0][v] = dp[1][v];\n\t\t\t\tdp[1][v] = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\tif(r == 2) printf(\"%d\\n\", ans2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    int x[10000][2],y[10000][2];\n    vector<int> vx(2),vy(2);\n    vx[0]=vy[0]=-1;\n    vx[1]=vy[1]=10001;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<2;j++){\n\tcin>>x[i][j]>>y[i][j];\n\tvx.push_back(x[i][j]);\n\tvy.push_back(y[i][j]);\n      }\n    }\n    sort(vx.begin(),vx.end());\n    vx.erase(unique(vx.begin(),vx.end()),vx.end());\n    sort(vy.begin(),vy.end());\n    vy.erase(unique(vy.begin(),vy.end()),vy.end());\n    vector<vector<bool> > v(vy.size()-1,vector<bool>(vx.size()-1));\n    for(int i=0;i<n;i++){\n      int jl=lower_bound(vy.begin(),vy.end(),y[i][1])-vy.begin();\n      int kl=lower_bound(vx.begin(),vx.end(),x[i][1])-vx.begin();\n      for(int j=lower_bound(vy.begin(),vy.end(),y[i][0])-vy.begin();j<jl;j++){\n\tfor(int k=lower_bound(vx.begin(),vx.end(),x[i][0])-vx.begin();k<kl;k++){\n\t  v[j][k]=true;\n\t}\n      }\n    }\n    int a=0;\n    for(int i=0;i<v.size();i++){\n      for(int j=0;j<v[i].size();j++){\n\tif(v[i][j]){\n\t  a+=(vy[i+1]-vy[i])*(vx[j+1]-vx[j]);\n\t}\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j+1<v[i].size();j++){\n\t  if(v[i][j]^v[i][j+1]){\n\t    l+=vy[i+1]-vy[i];\n\t  }\n\t}\n      }\n      for(int i=0;i<v[0].size();i++){\n\tfor(int j=0;j+1<v.size();j++){\n\t  if(v[j][i]^v[j+1][i]){\n\t    l+=vx[i+1]-vx[i];\n\t  }\n\t}\n      }\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n\n    // update right_area_end_point\n    repeat_with_index(y_size, y_i) {\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    // for (auto&& points : sheets) {\n    //   cout << \"A: \";\n    //   cout << points.first.first << \" \" << points.first.second << endl;\n    //   for (auto&& p : points.second) {\n    //     cout << \"B: \";\n    //     cout << p.first << \" \" << p.second << endl;\n    //   }\n    // }\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[4000][3000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tmemset(g,0,sizeof(g));\n\t\tint mx = 10001,Mx = 1,my = 10001,My = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\ta++;b++;c++;d++;\n\t\t\tg[a][b]++; g[a][d]--;\n\t\t\tg[c][b]--; g[c][d]++;\n\t\t\tmx = min(mx,a);\n\t\t\tMx = max(Mx,c);\n\t\t\tmy = min(my,b);\n\t\t\tMy = max(My,d);\n\t\t}\n\t\t\n\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\tint t = 0;\n\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tg[i][j] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s = 0;\n\t\tfor(int j = my; j <= My; j++){\n\t\t\tint t = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tif(g[i][j] = t)s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t\t\n\t\tif(r==2){\n\t\t\tint l = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\t\tif(g[i][j]){\n\t\t\t\t\t\tl += !g[i-1][j]+!g[i+1][j]+!g[i][j-1]+!g[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nvoid sl(int p[][4],int Mx,int My,int n,int r){\n  int f[Mx][My];\n  int i,j,k;\n  int s,l;\n  s = l = 0;\n  for(i=0;i<Mx;i++){\n    for(j=0;j<My;j++){\n      f[i][j] = 0;\n    }\n  }\n  for(k=0;k<n;k++){\n    for(i=p[k][0];i<p[k][2];i++){\n      for(j=p[k][1];j<p[k][3];j++){\n        if(f[i][j]==0){\n          s++;\n        }\n        f[i][j] = 1;\n      }\n    }\n  } \n  printf(\"%d\\n\",s);\n  if(r==2){\n    for(i=0;i<Mx-1;i++){\n      l+=(f[i][0]+f[i][Mx-1]);\n      for(j=0;j<My-1;j++){\n        l+=(f[i][j]^f[i][j+1]);\n      }\n    }\n    for(j=0;j<My-1;j++){\n      l+=(f[0][j]+f[My-1][j]);\n      for(i=0;i<Mx-1;i++){\n        l+=(f[i+1][j]^f[i][j]);\n      }\n    }\n    printf(\"%d\\n\",l);\n  }\n}\nint main(){\n  int n,r;\n  int i,j,k;\n  int Mx,My;\n  scanf(\"%d %d\",&n,&r);\n  int p[n][4];\n  while(n!=0&&r!=0){\n    Mx = My = 100;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&p[k][0],&p[k][1],&p[k][2],&p[k][3]);\n      if(p[k][2]>Mx){\n        Mx = p[k][2];\n      }\n      if(p[k][3]>My){\n        My = p[k][3];\n      }      \n    }\n    sl(p,Mx,My,n,r);\n    scanf(\"%d %d\",&n,&r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Tag {\n    int a;\n    int b1, b2;\n    bool start;\n\n    Tag() : a(0), b1(0), b2(0), start(false) {}\n    Tag(int aa, int bb1, int bb2, bool s) : a(aa), b1(bb1), b2(bb2), start(s) {}\n};\n\nbool cmp(const Tag &t1, const Tag &t2) {\n    if(t1.a != t2.a) return t1.a < t2.a;\n    return !t1.start;\n}\n\nint main() {\n    while(true) {\n        int N, R;\n        cin >> N >> R;\n        if(!N && !R) break;\n\n        vector<Tag> xtag, ytag;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            xtag.push_back(Tag(x1, y1, y2, true));\n            xtag.push_back(Tag(x2, y1, y2, false));\n            ytag.push_back(Tag(y1, x1, x2, true));\n            ytag.push_back(Tag(y2, x1, x2, false));\n        }\n        sort(xtag.begin(), xtag.end(), cmp);\n        stable_sort(ytag.begin(), ytag.end(), cmp);\n\n        int max_y = ytag[ytag.size()-1].a;\n        int area = 0;\n        int len = 0;\n        for(int y = 0; y < max_y; ++y) {\n            int depth = 0;\n            int startx = 0;\n            int prevx = -1;\n            for(int i = 0; i < xtag.size(); ++i) {\n                if(xtag[i].b1 <= y && y < xtag[i].b2) {\n                    if(xtag[i].start) {\n                        if(depth == 0) {\n                            if(xtag[i].a != prevx) ++len;\n                            else --len;\n                            startx = xtag[i].a;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            area += xtag[i].a-startx;\n                            prevx = xtag[i].a;\n                            ++len;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << area << endl;\n        if(R == 1) continue;\n\n        int max_x = xtag[xtag.size()-1].a;\n        for(int x = 0; x < max_x; ++x) {\n            int depth = 0;\n            int prevy = -1;\n            for(int i = 0; i < ytag.size(); ++i) {\n                if(ytag[i].b1 <= x && x < ytag[i].b2) {\n                    if(ytag[i].start) {\n                        if(depth == 0) {\n                            if(prevy != ytag[i].a) ++len;\n                            else --len;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            ++len;\n                            prevy = ytag[i].a;\n                        }\n                    }\n                }\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    // repeat_with_index(y_size, y_i) {\n\n    //   // included in some sheets\n    //   if (right_area_end_point[y_i] > x_i) {\n    //     area += 1;\n    //     is_area[x_i % 2][y_i] = true;\n    //   } else {\n    //     is_area[x_i % 2][y_i] = false;\n    //   }\n\n    //   // line check\n    //   if (type == 2) {\n    //     // left line exists\n    //     if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n    //     // bottom line exists\n    //     if (\n    //         (y_i == 0 && is_area[x_i % 2][y_i]) ||\n    //         (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n    //         )\n    //       lines += 1;\n    //   }\n    // }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct node {\n\tdouble x, r;\n};\n\nvector< vector<node> > emp, vx, vy;\n\nnode make_node(double x, double r) {\n\tnode v;\n\tv.x = x, v.r = r;\n\treturn v;\n}\n\ndouble abs(double n) {\n\treturn n < 0 ? -n : n;\n}\n\nvoid make_area(vector< vector<node> > &v, int n, int a, int b) {\n\tdouble x = (a + b) / 2.0, r = b - x;\n\tfor (int i = 0; i < v[n].size(); ++i) {\n\t\tnode nd = v[n][i];\n\t\tif (abs(x - nd.x) <= abs(r + nd.r)) {\n\t\t\tv[n][i].x = (min(x - r, nd.x - nd.r) + max(x + r, nd.x + nd.r)) / 2.0;\n\t\t\tv[n][i].r = max(x + r, nd.x + nd.r) - v[n][i].x;\n\t\t\treturn;\n\t\t}\n\t}\n\tv[n].push_back( make_node(x, r) );\n}\n\nint main() {\n\tint n, r;\n\n\temp.resize(10001);\n\n\twhile (cin >> n >> r, n || r) {\n\t\tvx = vy = emp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\t\tfor (int y = y1; y < y2; ++y)\n\t\t\t\tmake_area(vx, y, x1, x2);\n\n\t\t\tfor (int x = x1; x < x2; ++x)\n\t\t\t\tmake_area(vy, x, y1, y2);\n\t\t}\n\n\t\tint S = 0, l = 0;\n\t\tfor (int i = 0; i < 10001; ++i) {\n\t\t\tfor (int x = 0; x < vx[i].size(); ++x)\n\t\t\t\tS += (int)(2 * vx[i][x].r);\n\n\t\t\tl += 2 * (vx[i].size() + vy[i].size());\n\t\t}\n\n\t\tcout << S << endl;\n\t\tif (r == 2) cout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\nint p[10010][10010]={0};\nwhile(1)\n{\nint n;\ncin >> n;\nbreak;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\t//vector<vector<int>>data;\n\tvector<pair<pair<int, int>, pair<int, int>>>input;\n\tmap<int, int>x_x, y_y;\n\tunordered_map<int, unordered_map<int, int>>datax;\n\tvector<int>x_x_x, y_y_y;\n\twhile( cin >> N >> R, N || R ) {\n\t\tint xmax = 0, ymax = 0;\n\t\tset<int>xs, ys;\n\t\tinput.resize( N );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tinput[i] = make_pair( make_pair( x1, y1 ), make_pair( x2, y2 ) );\n\t\t\txs.insert( x1 );\n\t\t\tys.insert( y1 );\n\t\t\txs.insert( x2 );\n\t\t\tys.insert( y2 );\n\t\t}\n\t\tx_x.clear();\n\t\ty_y.clear();\n\n\t\tx_x_x.clear();\n\t\ty_y_y.clear();\n\t\tfor( auto xx : xs ) {\n\t\t\tx_x[xx] = x_x_x.size();\n\t\t\tx_x_x.emplace_back( xx );\n\t\t}\n\t\tfor( auto yy : ys ) {\n\t\t\ty_y[yy] = y_y_y.size();\n\t\t\ty_y_y.emplace_back( yy );\n\t\t}\n\t\txmax = xs.size() + 1;\n\t\tymax = ys.size() + 1;\n\t\t//data = vector<vector<int>>( xmax + 1, vector<int>( ymax + 1 ) );\n\t\tdatax.clear();\n\t\tfor( size_t i = 0; i < input.size(); i++ ) {\n\t\t\tdatax[x_x[input[i].first.first]][y_y[input[i].first.second]]++;\n\t\t\tdatax[x_x[input[i].second.first]][y_y[input[i].second.second]]++;\n\t\t\tdatax[x_x[input[i].second.first]][y_y[input[i].first.second]]--;\n\t\t\tdatax[x_x[input[i].first.first]][y_y[input[i].second.second]]--;\n\t\t}\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\tcout << data[i][j];\n\t\t}\n\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdatax[i + 1][j] += datax[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tdatax[i][j + 1] += datax[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\tcout << data[i][j];\n\t\t}\n\t\tcout << endl;\n\t\t}*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( datax[i][j] ) {\n\t\t\t\t\tans += (x_x_x[i + 1] - x_x_x[i])*(y_y_y[j + 1] - y_y_y[j]);\n\t\t\t\t\t//ans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tif( datax[i][0] != 0 ) {\n\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tif( datax[0][i] != 0 ) {\n\t\t\t\t\tans += y_y_y[i + 1] - y_y_y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( datax[i][j] * datax[i][j + 1] == 0 && datax[i][j] != datax[i][j + 1] ) {\n\t\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t\t}\n\t\t\t\t\tif( datax[i][j] * datax[i + 1][j] == 0 && datax[i][j] != datax[i + 1][j] ) {\n\t\t\t\t\t\tans += y_y_y[j + 1] - y_y_y[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\tvector<vector<int>>data;\n\tvector<pair<pair<int, int>, pair<int, int>>>input;\n\tmap<int, int>x_x, y_y;\n\tvector<int>x_x_x, y_y_y;\n\twhile( cin >> N >> R, N || R ) {\n\t\tint xmax = 0, ymax = 0;\n\t\tset<int>xs, ys;\n\t\tinput.resize( N );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tinput[i] = make_pair( make_pair( x1, y1 ), make_pair( x2, y2 ) );\n\t\t\txs.insert( x1 );\n\t\t\tys.insert( y1 );\n\t\t\txs.insert( x2 );\n\t\t\tys.insert( y2 );\n\t\t}\n\t\tx_x.clear();\n\t\ty_y.clear();\n\n\t\tx_x_x.clear();\n\t\ty_y_y.clear();\n\t\tfor( auto xx : xs ) {\n\t\t\tx_x[xx] = x_x_x.size();\n\t\t\tx_x_x.emplace_back( xx );\n\t\t}\n\t\tfor( auto yy : ys ) {\n\t\t\ty_y[yy] = y_y_y.size();\n\t\t\ty_y_y.emplace_back( yy );\n\t\t}\n\t\txmax = xs.size() + 1;\n\t\tymax = ys.size() + 1;\n\t\tdata = vector<vector<int>>( xmax + 1, vector<int>( ymax + 1 ) );\n\t\tfor( size_t i = 0; i < input.size(); i++ ) {\n\t\t\tdata[x_x[input[i].first.first]][y_y[input[i].first.second]]++;\n\t\t\tdata[x_x[input[i].second.first]][y_y[input[i].second.second]]++;\n\t\t\tdata[x_x[input[i].second.first]][y_y[input[i].first.second]]--;\n\t\t\tdata[x_x[input[i].first.first]][y_y[input[i].second.second]]--;\n\t\t}\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans += (x_x_x[i + 1] - x_x_x[i])*(y_y_y[j + 1] - y_y_y[j]);\n\t\t\t\t\t//ans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans += y_y_y[i + 1] - y_y_y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans += y_y_y[j + 1] - y_y_y[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  rep(i,n){\n    xd[px++]=x1[i];\n    xd[px++]=x2[i];\n  }\n  sort(xd,xd+px);\n  px=unique(xd,xd+px)-xd;\n  rep(i,px)IN[i].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  //static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    int x1[n],x2[n],y1[n],y2[n];\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nbool m[10000][10000];\nint s;\nvoid addrec(int x1,int y1,int x2,int y2){\n\tfor(int x=x1;x<x2;x++){\n\t\tfor(int y=y1;y<y2;y++){\n\t\t\tif(!m[x][y]){\n\t\t\t\tm[x][y]=true;\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile(1){\n\t\tint n,r;\n\t\tcin >> n >> r;\n\t\tif(n==0){return 0;}\n\t\tfor(int x=0;x<10000;x++){\n\t\t\tfor(int y=0;y<10000;y++){\n\t\t\t\tm[x][y]=false;\n\t\t\t}\n\t\t}\n\t\ts=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\taddrec(x1,y1,x2,y2);\n\t\t}\n\t\tcout << s << endl;\n\t\tif(r==2){\n\t\t\tint l=0;\n\t\t\tfor(int x=0;x<10000;x++){\n\t\t\t\tfor(int y=0;y<9999;y++){\n\t\t\t\t\tif(m[x][y] xor m[x][y+1]){\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=0;x<9999;x++){\n\t\t\t\tfor(int y=0;y<10000;y++){\n\t\t\t\t\tif(m[x][y] xor m[x+1][y]){\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\tif(m[i][0]){l++;}\n\t\t\t\tif(m[i][9999]){l++;}\n\t\t\t\tif(m[0][i]){l++;}\n\t\t\t\tif(m[9999][i]){l++;}\n\t\t\t}\n\t\t\tcout << l << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint coor[10001][10001];\nint dx[4]={0,1,-1,0};\nint dy[4]={1,0,0,-1};\nvoid myclear()\n{\n\tfor(int i=0;i<10001;i++)\n\t{\n\t\tfor(int j=0;j<10001;j++)\n\t\t{\n\t\t\tcoor[i][j]=0;\n\t\t}\n\t}\n\treturn ;\n}\nvoid init(int ax,int ay,int bx,int by)\n{\n\tfor(int i=ax;i<bx;i++)\n\t{\n\t\tfor(int j=ay;j<by;j++)\n\t\t{\n\t\t\tcoor[i][j]++;\n\t\t}\n\t}\n\treturn ;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmyclear();\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tint minx=INF,miny=INF,maxx=-1,maxy=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint ax,ay,bx,by;\n\t\t\tcin >>ax>>ay>>bx>>by;\n\t\t\tminx=min(minx,min(ax,bx));\n\t\t\tmaxx=max(maxx,max(ax,bx));\n\t\t\tminy=min(miny,min(ay,by));\n\t\t\tmaxy=max(maxy,max(ay,by));\n\t\t\tinit(ax,ay,bx,by);\n\t\t}\n\t\tll count1=0;\n\t\tll count2=0;\n\t\tif(m==1)\n\t\t{\n\t\t\tfor(int i=minx;i<maxx;i++)\n\t\t\t{\n\t\t\t\tfor(int j=miny;j<maxy;j++)\n\t\t\t\t{\n\t\t\t\t\tif(coor[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tcount1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << count1 << endl;\n\t\t}\n\t\tif(m==2)\n\t\t{\n\t\t\tfor(int i=minx;i<maxx;i++)\n\t\t\t{\n\t\t\t\tfor(int j=miny;j<maxy;j++)\n\t\t\t\t{\n\t\t\t\t\tif(coor[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tcount1++;\n\t\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(i+dx[k]<0||j+dy[k]<0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!(coor[i+dx[k]][j+dy[k]]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << count1 << endl;\n\t\t\tcout << count2 << endl;\n\t\t}\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct range\n{\n  int a;\n  int z;\n  struct range *next;\n} range;\n\n\nrange *rangenew(int r1, int r2, range *nx)\n{\n  range *rng;\n  rng = (range *)malloc(sizeof(range));\n  rng->a = r1;\n  rng->z = r2;\n  rng->next = nx;\n  return rng;\n}\n\nrange *insert(range *line, int r1, int r2)\n{\n  range *rng;\n  int z2;\n  if(line == NULL){\n    return rangenew(r1, r2, NULL);\n  }\n  if(line->z < r1){\n    line->next = insert(line->next, r1, r2);\n    return line;\n  }\n  if(r2 < line->a){\n    return rangenew(r1, r2, line);\n  }\n  line->a = (r1 < line->a ? r1 : line->a);\n  z2 = line->z;\n  rng = line->next;\n  while(rng != NULL && rng->a <= r2) {\n    z2 = rng->z;\n    free(rng);\n    rng = rng->next;\n  }\n  line->z = (r2 > z2 ? r2 : z2);\n  line->next = rng;\n  return line;\n}\n\nvoid linefree(range *line)\n{\n  if(line){\n    free(line);\n    linefree(line->next);\n  }\n}\n\n/*\nvoid putrange(range *list)\n{\n  if(list == NULL){\n    printf(\"\\n\");\n  }else{\n    printf(\"[%d, %d] -> \", list->a, list->z);\n    putrange(list->next);\n  }\n}\n*/\n\nint counts(range *line)\n{\n  return line ? counts(line->next)+(line->z-line->a) : 0;\n}\n\nint count(range *line)\n{\n  return line ? count(line->next)+1 : 0;\n}\n \nint main()\n{\n  int n, t;\n  range *sheetx[10000]; // x~x+1??§?????¨?????\\??£?????????y?????????\n  range *sheety[10000];\n  int i;\n  int x, y;\n  int x1, y1, x2, y2;\n  int s, l;\n  \n  while(scanf(\"%d %d\", &n, &t)!=EOF){\n    s = l = 0;\n    for(i=0; i<10000; i++){\n      sheetx[i] = sheety[i] = NULL;\n    }\n    for(i=0; i<n; i++){\n      scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n      for(x=x1; x<x2; x++){\n        sheetx[x] = insert(sheetx[x], y1, y2);\n      }\n      for(y=y1; y<y2; y++){\n        sheety[y] = insert(sheety[y], x1, x2);\n      }\n    }\n  \n    for(i=0; i<10000; i++){\n      s += counts(sheetx[i]);\n    }\n    printf(\"%d\\n\", s);\n    if(t == 2){\n      for(i=0; i<10000; i++){\n        l += count(sheetx[i]);\n        l += count(sheety[i]);\n      }\n      printf(\"%d\\n\", l*2);\n    }\n    for(i=0; i<10000; i++){\n      linefree(sheetx[i]);\n      linefree(sheety[i]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n, q, mx1, my1, mx2, my2, x1[10000], y1[10000], x2[10000], y2[10000], imos[10001];\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &q);\n\n\t\tif (n == 0 && q == 0) break;\n\n\t\tmx1 = 10001;\n\t\tmy1 = 10001;\n\t\tmx2 = -1;\n\t\tmy2 = -1;\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x1[i]); mx1 = min(mx1, x1[i]);\n\t\t\tscanf(\"%d\", &y1[i]); my1 = min(my1, y1[i]);\n\t\t\tscanf(\"%d\", &x2[i]); mx2 = max(mx2, x2[i]);\n\t\t\tscanf(\"%d\", &y2[i]); my2 = max(my2, y2[i]);\n\t\t}\n\n\t\tint ret1 = 0;\n\t\tint ret2 = 0;\n\n\t\tfor (int i = my1; i < my2; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (y1[j] <= i && i < y2[j])\n\t\t\t\t{\n\t\t\t\t\timos[x1[j]]++;\n\t\t\t\t\timos[x2[j]]--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\n\t\t\tfor (int j = mx1; j <= mx2; j++)\n\t\t\t{\n\t\t\t\tif ((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n\n\t\t\t\tsum += imos[j]; imos[j] = 0;\n\n\t\t\t\tif(sum > 0) ret1++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = mx1; i < mx2; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (x1[j] <= i && i < x2[j])\n\t\t\t\t{\n\t\t\t\t\timos[y1[j]]++;\n\t\t\t\t\timos[y2[j]]--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\n\t\t\tfor (int j = my1; j <= my2; j++)\n\t\t\t{\n\t\t\t\tif ((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n\n\t\t\t\tsum += imos[j]; imos[j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret1);\n\n\t\tif (q == 2)\n\t\t{\n\t\t\tprintf(\"%d\\n\", ret2);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define SIZE 10003\nint i,x,y;\nint x_1,y_1,x_2,y_2;\nint n,r;\nint l,v;\nbool data[SIZE][SIZE];\nint main(){\n\twhile(cin>>n>>r){\n\t\tif(n==0 && r==0){break;}\n\t\tfor(x=0;x<SIZE;x++){\n\t\t\tfor(y=0;y<SIZE;y++){\n\t\t\t\tdata[x][y]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>x_1>>y_1>>x_2>>y_2;\n\t\t\tfor(x=x_1;x<x_2;x++){\n\t\t\t\tfor(y=y_1;y<y_2;y++){\n\t\t\t\t\tdata[x][y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tl=0,v=0;\n\t\tfor(x=0;x<SIZE;x++){\n\t\t\tfor(y=0;y<SIZE;y++){\n\t\t\t\tv+=data[x][y];\n\t\t\t\tif(data[x][y]==1){\n\t\t\t\t\tif(data[x+1][y]==0){\n\t\t\t\t\t\tl+=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(data[x][y+1]==0){\n\t\t\t\t\t\tl+=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(x>=0 && data[x-1][y]==0){\n\t\t\t\t\t\tl+=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(y>=0 && data[x][y-1]==0){\n\t\t\t\t\t\tl+=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(r==1){\n\t\t\tcout<<v<<endl;\n\t\t}else{\n\t\t\tcout<<v<<endl;\n\t\t\tcout<<l<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint main()\n{\nint n,r;\nwhile(1)\n{\ncin >> n >> r;\nint m[10010][10010];\nmemset(m,0,sizeof(m));\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        //bool *map;\n        short** map;\n        map=new short*[10001];\n        for(int w=0;w<=10000;w++){\n            map[w] = new short[10001];\n        }\n        \n        short** imos;\n        imos=new short*[10001];\n        for(int w=0;w<=10000;w++){\n            imos[w] = new short[10001];\n        }\n       \n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n        }\n        for(int h=0;h<=10;h++){\n           for(int w=0;w<=10;w++){\n                //printf(\"%2d \",map[w][h]);\n           }\n           //cout<<endl;\n        }\n        //cout<<endl;\n        int S=0;\n        int L=0;\n        for(int h=0;h<=10;h++){\n            int state=0;\n           for(int w=0;w<=10;w++){\n               int res=0;\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n               //if(w==0){S++;}\n           }\n        }\n\n        for(int h=0;h<=10;h++){\n            for(int w=0;w<=10;w++){\n               //printf(\"%2d \",imos[w][h]);\n           }\n           //cout<<endl;\n        }     \n        cout<<S<<endl;\n        cout<<L<<endl;\n        \n        /*\n        int S=0;\n        int L=0;\n        bool old=false;\n        for(int w=0;w<=10000;w++){\n            old=false;\n            for(int h=0;h<=10000;h++){\n                if(map[w][h]){S++;}\n                if(old!=map[w][h]){L++;}\n                old=map[w][h];\n            }\n            if(old==true){L++;}\n        }\n        for(int h=0;h<=10000;h++){\n            old=false;\n           for(int w=0;w<=10000;w++){\n                if(old!=map[w][h]){L++;}\n                old=map[w][h];\n            }\n            if(old==true){L++;}\n        }\n        \n        cout<<S<<endl;\n        if(r==2){\n            std::cout << L << std::endl;\n        }\n        */\n\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  bool operator<(const st&)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (height != a.height)return height < a.height;\n  return out > a.out;\n}\n\n\nint x[N];\nvector<st> inx[N];\n\n//int y[N];\n//vector<st> iny[N];\n\n/*\n29\n29\n80\n45\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *X,vector<st> *IN){\n  //vector<int> xd;\n  static int xd[N];\n  int p=0;\n  rep(i,n){\n    //xd.pb(x1[i]);\n    //xd.pb(x2[i]);\n    xd[p++]=x1[i];\n    xd[p++]=x2[i];\n  }\n  //sort(ALL(xd));\n  sort(xd,xd+p);\n  //xd.erase(unique(ALL(xd)),xd.end());\n  p=unique(xd,xd+p)-xd;\n  //rep(i,xd.size())X[px++]=xd[i],IN[i].clear();\n  rep(i,p)X[px++]=xd[i],IN[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    //int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    int j=lower_bound(xd,xd+p,x1[i])-xd;\n    while(j < px && x[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint n, r, mx, Mx, my, My, res, a, b, c, d, i, j;\nint mp[10003][10003];\nint main() {\n    while (scanf(\"%d%d\",&n,&r)) {\n        if (!n&&!r) break;\n        mx=10003; Mx=0; my=10003; My=0;\n        for (i=0; i<10003; i++) for (j=0; j<10003; j++) mp[i][j]=0;\n        for (i=0; i<n; i++) {\n            scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            a++; b++; c++; d++;\n            mp[a][b]++; mp[c][d]++;\n            mp[a][d]--; mp[c][b]--;\n            mx=min(mx,a);\n            Mx=max(Mx,c+1);\n            my=min(my,b);\n            My=max(My,d+1);\n        }\n        for (i=mx; i<Mx; i++) {\n            for (j=my; j<My; j++) mp[i][j]+=mp[i][j-1];\n        }\n        for (i=my; i<My; i++) {\n            for (j=mx; j<Mx; j++) mp[j][i]+=mp[j-1][i];\n        }\n        res=0;\n        for (i=mx; i<Mx; i++) for (j=my; j<My; j++) if (mp[i][j]!=0) res++;\n        printf(\"%d\\n\",res);\n        if (r==2) {\n            res=0;\n            for (i=mx; i<Mx; i++) for (j=my; j<My; j++) {\n                if (mp[i][j]) res+=!mp[i-1][j]+!mp[i][j-1]+!mp[i+1][j]+!mp[i][j+1];\n            }\n            printf(\"%d\\n\",res);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n\nint area;\nint length;\n\nRECT calc[10000];\nRECT before[10000];\nRECT grid[10000];\nint bsize;\n\nbool comp(const RECT& rLeft, const RECT& rRight){\n    return (rLeft.sx < rRight.sx);\n}\n\nvoid mergeArea(int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n    \n    if (n == 0){\n        return;\n    }\n    \n    sort(grid, grid + n, comp);\n    \n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n    \n    *sq = num;\n}\n\nvoid mergeLength(int n)\n{\n    vector<int> total;\n    int i;\n    int res;\n    \n    for (i = 0; i < n; i++){\n        total.push_back(calc[i].sx);\n        total.push_back(calc[i].ex);\n    }\n    for (i = 0; i < bsize; i++){\n        total.push_back(before[i].sx);\n        total.push_back(before[i].ex);\n    }\n    \n    sort(total.begin(), total.end());\n    res = 0;\n    for (i = 0; i < total.size(); i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n\nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    int num;\n    int i, j;\n    int sq;\n    int miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        miny = 1000000;\n        maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n            miny = min(miny, p[i].sy);\n            maxy = max(maxy, p[i].ey);\n        }\n        if (query == 1){\n            continue;\n        }\n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        area = length = 0;\n        for (i = miny; i <= maxy; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n            }\n            mergeArea(num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        printf(\"%d\\n\", area);\n        printf(\"%d\\n%d\\n\", area, length);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, r;\n        cin >> n >> r;\n        if(n == 0)\n            return 0;\n\n        int sy = INT_MAX;\n        int sx = INT_MAX;\n        int gy = INT_MIN;\n        int gx = INT_MIN;\n        vector<int> x1(n), y1(n), x2(n), y2(n);\n        for(int i=0; i<n; ++i){\n            cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n            sy = min(sy, y1[i]);\n            sx = min(sx, x1[i]);\n            gy = max(gy, y2[i]);\n            gx = max(gx, x2[i]);\n        }\n\n        int ret1 = 0;\n        int ret2 = 0;\n        for(int a=0; a<11; ++a){\n            int yMin = a * 1000 - 1;\n            int yMax = (a+1) * 1000;\n            for(int b=0; b<11; ++b){\n                int xMin = b * 1000 - 1;\n                int xMax = (b+1) * 1000;\n\n                if(gy < yMin || gx < xMin || sy > yMax || sx > yMax)\n                    continue;\n\n                vector<vector<int> > s(1001, vector<int>(1001, 0));\n                for(int i=0; i<n; ++i){\n                    if(y2[i] < yMin || x1[i] < xMin || y1[i] > yMax || x1[i] > xMax)\n                        continue;\n\n                    ++ s[max(yMin, y1[i])-yMin][max(xMin, x1[i])-xMin];\n                    if(x2[i] <= xMax)\n                        -- s[max(yMin, y1[i])-yMin][x2[i]-xMin];\n                    if(y2[i] <= yMax)\n                        -- s[y2[i]-yMin][max(xMin, x1[i])-xMin];\n                    if(y2[i] <= yMax && x2[i] <= xMax)\n                        ++ s[y2[i]-yMin][x2[i]-xMin];\n                }\n\n                for(int i=0; i<1001; ++i){\n                    for(int j=0; j<1000; ++j){\n                        s[i][j+1] += s[i][j];\n                    }\n                }\n                for(int i=0; i<1001; ++i){\n                    for(int j=0; j<1000; ++j){\n                        s[j+1][i] += s[j][i];\n                    }\n                }\n\n                for(int i=0; i<1000; ++i){\n                    for(int j=0; j<1000; ++j){\n                        if(s[i][j] > 0)\n                            ++ ret1;\n                        if((s[i][j] > 0) ^ (s[i+1][j] > 0))\n                            ++ ret2;\n                        if((s[i][j] > 0) ^ (s[i][j+1] > 0))\n                            ++ ret2;\n                    }\n                }\n            }\n        }\n\n        cout << ret1 << endl;\n        if(r == 2)\n            cout << ret2 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509>\n?????????============================================================\n?????¢???????????¢??????????????????????????????????????????.???????????????????????§????????????????????¨????????¢????????¨???????±???????????????°?????????????????????.\n?????????, ?????¢?????§?¨??????¢??¨??????????????¨???, ??????????????????????¬?????????¶ (1), (2) ????????????????????¨??????.\n(1) ???????????????????????¢??? 4 ????????? x, y ??§?¨??????¨??? 0 ??\\??? 10000 ??\\????????´??°??§??????,\n    ????????¢???????????? x ???, ????????? y ??????????????§??????.\n(2) ?????????????????°????????? 10000 ?????\\?????§??????.\n??\\???????????? ??? 1 ?????????????????¢????????° n ??¨??????????¨?????????¨?????´??° r ???????????§????????£?????????????????????.\n2 ????????\\??????????????????, ?????????????????????????????§?¨? (x1, y1) ??¨??????????????§?¨? (x2, y2) ?????§?¨???????\nx1, y1, x2, y2 ????????§????????§????????£??????????????????.\n\n???????????? r = 1 ?????¨??? 1 ???????????¢??????, r = 2 ?????¨??? 1 ???????????¢???, 2 ???????????¨???????????????????????????.\n??????????????´??????????????????????????\\???????????¨.\n\n=================================================================\n??\\???=============================================================\n??\\???????????°????????????????????????????????????n, r ?????¨?????? 0 ?????¨?????\\????????????????????????????????????????????°??? 10 ????¶?????????????\n================================================================\n??????=============================================================\n???????????????????????¨???, r = 1 ?????¨??? 1 ???????????¢??????, r = 2 ?????¨??? 1 ???????????¢???, 2 ???????????¨???????????????????????????.\n================================================================\n?§£??¬=============================================================\n\n================================================================\n*/\n\nclass CC {\npublic:\n\tll N;\n\tvector<ll> xs; // ????????¨:xs[x1 or x2????????????] := ????????§?¨?\n\n\tCC(ll N) :N(N) {}\n\t// x1, x2?????§?¨???§??????, ??§?¨???§???????????????????????????\n\tint compress(vector<ll>& x1, vector<ll>& x2, ll MIN_W = -1e10, ll MAX_W = 1e10) {\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\t/* ??´???????????£??????d????¶???????????????? */\n\t\t\tfor (int d = -1; d <= 1; d++) {\n\t\t\t\tll tx1 = x1[i], tx2 = x2[i];\n\t\t\t\tif (MIN_W <= tx1 && tx1 <= MAX_W) xs.push_back(tx1);\n\t\t\t\tif (MIN_W <= tx2 && tx2 <= MAX_W) xs.push_back(tx2);\n\t\t\t}\n\t\t}\n\n\t\tsort(xs.begin(), xs.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tx1[i] = find(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\t\tx2[i] = find(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t\t}\n\n\t\treturn (int)xs.size(); // xs.size????????§??§???6*N\n\t}\n\tvoid clear() {\n\t\txs.clear();\n\t}\n\tvoid set(int v) {\n\t\tN = v;\n\t}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, r;\n\tvector<ll> x1, y1, x2, y2;\n\tCC CCx(0), CCy(0);\n\twhile (cin >> N >> r, N | r) {\n\t\tx1.clear(); y1.clear(); x2.clear(); y2.clear();\n\t\tx1.resize(N); y1.resize(N); x2.resize(N); y2.resize(N);\n\t\tfor (int i = 0; i < N;i++) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\t\tCCx.clear(); CCx.set(N);\n\t\tCCy.clear(); CCy.set(N);\n\t\tll W = CCx.compress(x1, x2);\n\t\tll H = CCy.compress(y1, y2);\n\n\t\t/* imos????????¨???????????§?¨??????¢????¨???????*/\n\t\tvector<vector<int>> imos(H + 2, vector<int>(W + 2, 0)); // ??¢????¨????\n\t\tvector<vector<int>> Sum(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\timos[y1[i]][x1[i]]++;\n\t\t\timos[y1[i]][x2[i]]--;\n\t\t\timos[y2[i]][x1[i]]--;\n\t\t\timos[y2[i]][x2[i]]++;\n\t\t}\n\t\tll ans = 0;\n\t\tll circuit = 0;\n\t\tfor (int y = 0; y < H;y++) {\n\t\t\tfor (int x = 0; x < W;x++) {\n\t\t\t\tSum[y + 1][x + 1] = Sum[y + 1][x] + Sum[y][x + 1] - Sum[y][x] + imos[y][x];\n\t\t\t\tif (Sum[y + 1][x + 1] > 0) {\n\t\t\t\t\tans += (CCy.xs[y + 1] - CCy.xs[y])*(CCx.xs[x + 1] - CCx.xs[x]);\n\t\t\t\t\tcircuit += (CCy.xs[y + 1] - CCy.xs[y]) + (CCx.xs[x + 1] - CCx.xs[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tif (r == 1) continue;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\n#define INF 2000000000\n#define LLINF 4000000000000000000\n#define SIZE 10004\n\nint mm[SIZE][SIZE];\nint mo[5] = {0,1,0,-1,0};\n\nvoid calc(int n,int r){\n    int x_1,x_2,y_1,y_2,minx=SIZE-1,maxx=0,miny=SIZE-1,maxy=0;\n    int ansV=0,ansL=0;\n    \n    memset(mm,0,sizeof(mm));\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d%d\",&x_1,&y_1,&x_2,&y_2);\n        \n        x_1++;\n        y_1++;\n        x_2++;\n        y_2++;\n        \n        mm[x_1][y_1]++;\n        mm[x_2][y_1]--;\n        mm[x_1][y_2]--;\n        mm[x_2][y_2]++;\n        \n        minx = min(minx,x_1);\n        miny = min(miny,y_1);\n        maxx = max(maxx,x_2);\n        maxy = max(maxy,y_2);\n    }\n    \n    for(int i=miny;i<=maxy;i++){\n        for(int j=minx+1;j<=maxx;j++){\n            mm[j][i]+=mm[j-1][i];\n        }\n    }\n    \n    for(int i=minx;i<=maxx;i++){\n        for(int j=miny+1;j<=maxy;j++){\n            mm[i][j]+=mm[i][j-1];\n        }\n    }\n    \n    for(int i=minx;i<maxx;i++){\n        for(int j=miny;j<maxy;j++){\n            if(mm[i][j]>0){\n                ansV++;\n                \n                for(int k=0;k<4;k++){\n                    if(mm[i+mo[k]][j+mo[k+1]]==0){\n                        ansL++;\n                    }\n                }\n                \n            }\n        }\n    }\n    \n    printf(\"%d\\n\",ansV);\n    \n    if(r==2)\n        printf(\"%d\\n\",ansL);\n    \n    return;\n}\n\nint main(){\n    int n,r;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&r);\n        if(n==0) break;\n        calc(n,r);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<int, vector<tuple<int, int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n  x_size = 0; y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n  x_size = x_max + 1;\n  y_size = y_max + 1;\n\n  if (sheets.count(x1) == 0) {\n    sheets[x1] = {{y1, x2, y2}};\n  } else {\n    sheets[x1].push_back({y1, x2, y2});\n  }\n}\nvector<tuple<int, int, int>>& find_end_points(int x, int y) {\n  return sheets[x];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  loop(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  loop(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_size, x_i) {\n    // update right_area_end_point\n    auto& points = find_end_points(x_i, 0);\n\n    // per point operation\n    for (auto&& point : points) {\n      int y_i = get<0>(point), x = get<1>(point), y = get<2>(point);\n\n      loop_from_to(y_i, y - 1, p_i) {\n        assign_if_larger(right_area_end_point[p_i], x);\n      }\n    }\n\n    loop(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (beg != a.beg)return beg < a.beg;\n  return end < a.end;\n}\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nst *inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,st *IN[N]){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,free(IN[px++]);\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n\n  rep(i,px)req[i]=0;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      //IN[j].pb((st){y1[i],y2[i]});\n      req[j]++;\n      j++;\n    }\n  }\n\n  rep(i,px){\n    IN[i]=(st*)malloc(sizeof(st)*req[i]);\n    req[i]=0;\n  }\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      //IN[j].pb((st){y1[i],y2[i]});\n      IN[j][req[j]++]=(st){y1[i],y2[i]};\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,st *in[N],int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (req[i] == 0)continue;\n    sort(in[i],in[i]+req[i]);\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,req[i]){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      //cout << nowl <<\" \"<< nowh <<\" \" << l<<\" \" << h << endl;\n      if (nowl > h){\n\tlen+=2*width;\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << h << endl;\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    //rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    int mnx=INF,mny=INF,mxx=0,mxy=0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n      mnx=min(mnx,x1);\n      mny=min(mny,y1);\n      mxx=max(mxx,x2);\n      mxy=max(mxy,y2);\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    vector<P>v;\n    for(int i=mny;i<mxy;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n\tif(i<in[j].S.F)break;\n      }\n     \n      if(v.size()!=0){\n\tsort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end(),cmp_x);\n\n      for(int i=mnx;i<mxx;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\n\t  if(i<in[j].F.F)break;\n\t}\n\tif(v.size()!=0){\n\t  sort(v.begin(),v.end());\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nstruct Rect{\n\tint x1,x2,y1,y2;\n};\n\nclass Compare{\n\tpublic:\n\tbool operator()(const Rect &rect1,const Rect &rect2){\n\t\treturn rect1.x1<rect2.x1;\n\t}\n};\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<vector<P> > &range,vector<Rect> &rects){\n\tint result=0;\n\tint index=0;\n\tREP(x,0,10010){\n\t\twhile(index<rects.size()&&rects[index].x1<=x){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x].begin(),range[x].end());\n\t\tint y=0;\n\t\tREP(i,0,range[x].size()){\n\t\t\tif(range[x][i].S_>y) result+=range[x][i].S_-max(y,range[x][i].F_);\n\t\t\ty=max(y,range[x][i].S_);\n\t\t}\n\t\t//range[x].clear();\n\t\tvector<P>().swap(range[x]);\n\t}\n\treturn result;\n}\n\nint Count(vector<vector<P> > &range,vector<vector<bool> > &flag,int x){\n\tint index=0,y=0,result=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t}\n\t\t++index;\n\t}\n\treturn result;\n}\n\nint CalcLength(vector<vector<P> > &range,vector<Rect> &rects){\n\tint result=0,index=0;\n\tvector<vector<bool> > flag(3,vector<bool>(10010));\n\tREP(x,1,10009){\n\t\twhile(index<rects.size()&&rects[index].x1<=x+1){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x+1].begin(),range[x+1].end());\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,range[x+1].size()){\n\t\t\tif(range[x+1][i].S_>y) fill_n(flag[(x+1)%3].begin()+max(y,range[x+1][i].F_),range[x+1][i].S_-max(y,range[x+1][i].F_),true);\n\t\t\ty=max(range[x+1][i].S_,y);\n\t\t}\n\t\tresult+=Count(range,flag,x);\n\t\tif(x-2>=0){\n\t\t\t//range[x-2].clear();\n\t\t\tvector<P>().swap(range[x-2]);\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tvector<vector<P> > range(10010);\n\t\tvector<Rect> rects(N);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\trects[i].x1=x1+4;\n\t\t\trects[i].y1=y1+4;\n\t\t\trects[i].x2=x2+4;\n\t\t\trects[i].y2=y2+4;\n\t\t}\n\t\tsort(rects.begin(),rects.end(),Compare());\n\t\tcout << CalcSize(range,rects) << endl;\n\t\tif(R==2) cout << CalcLength(range,rects) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct node {\n\tdouble x, r;\n};\n\nvector< vector<node> > emp, vx, vy;\n\nnode make_node(double x, double r) {\n\tnode v;\n\tv.x = x, v.r = r;\n\treturn v;\n}\n\ndouble abs(double n) {\n\treturn n < 0 ? -n : n;\n}\n\nvoid make_area(vector< vector<node> > &v, int n, int a, int b) {\n\tdouble x = (a + b) / 2.0, r = b - x;\n\tfor (int i = 0; i < v[n].size(); ++i) {\n\t\tnode nd = v[n][i];\n\t\tif (abs(x - nd.x) <= abs(r + nd.r)) {\n\t\t\tv[n][i].x = (min(x - r, nd.x - nd.r) + max(x + r, nd.x + nd.r)) / 2.0;\n\t\t\tv[n][i].r = max(x + r, nd.x + nd.r) - v[n][i].x;\n\t\t\treturn;\n\t\t}\n\t}\n\tv[n].push_back( make_node(x, r) );\n}\n\nint main() {\n\tint n, r;\n\n\temp.resize(10002);\n\n\twhile (cin >> n >> r, n || r) {\n\t\tvx = vy = emp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\t\tfor (int y = y1; y < y2; ++y)\n\t\t\t\tmake_area(vx, y, x1, x2);\n\n\t\t\tfor (int x = x1; x < x2; ++x)\n\t\t\t\tmake_area(vy, x, y1, y2);\n\t\t}\n\n\t\tint S = 0, l = 0;\n\t\tfor (int i = 0; i < 10002; ++i) {\n\t\t\tfor (int x = 0; x < vx[i].size(); ++x)\n\t\t\t\tS += (int)(2 * vx[i][x].r);\n\n\t\t\tl += 2 * (vx[i].size() + vy[i].size());\n\t\t}\n\n\t\tcout << S << endl;\n\t\tif (r == 2) cout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\tvector<vector<int>>data;\n\twhile( cin >> N >> R, N || R ) {\n\t\tint xmax = 0, ymax = 0;\n\t\tvector<pair<pair<int, int>, pair<int, int>>>input( N );\n\t\tset<int>xs, ys;\n\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tinput[i] = make_pair( make_pair( x1, y1 ), make_pair( x2, y2 ) );\n\t\t\t/*\n\t\t\tdata[x1][y1]++;\n\t\t\tdata[x2][y2]++;\n\t\t\tdata[x1][y2]--;\n\t\t\tdata[x2][y1]--;\n\t\t\t*/\n\t\t\txs.insert( x1 );\n\t\t\tys.insert( y1 );\n\t\t\txs.insert( x2 );\n\t\t\tys.insert( y2 );\n\t\t}\n\t\tfor( auto x : xs ) {\n\t\t\tcout << x << \" \";\n\t\t}\n\t\tcout << endl;\n\t\tmap<int, int>x_x;\n\t\tmap<int, int>y_y;\n\t\tvector<int>x_x_x;\n\t\tvector<int>y_y_y;\n\t\tfor( auto xx : xs ) {\n\t\t\tx_x[xx] = x_x_x.size();\n\t\t\tx_x_x.push_back( xx );\n\t\t}\n\t\tfor( auto yy : ys ) {\n\t\t\ty_y[yy] = y_y_y.size();\n\t\t\ty_y_y.push_back( yy );\n\t\t}\n\t\txmax = xs.size() + 1;\n\t\tymax = ys.size() + 1;\n\t\tdata = vector<vector<int>>( xmax + 1, vector<int>( ymax + 1 ) );\n\t\tfor( size_t i = 0; i < input.size(); i++ ) {\n\t\t\tdata[x_x[input[i].first.first]][y_y[input[i].first.second]]++;\n\t\t\tdata[x_x[input[i].second.first]][y_y[input[i].second.second]]++;\n\t\t\tdata[x_x[input[i].second.first]][y_y[input[i].first.second]]--;\n\t\t\tdata[x_x[input[i].first.first]][y_y[input[i].second.second]]--;\n\t\t}\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans += (x_x_x[i + 1] - x_x_x[i])*(y_y_y[j + 1] - y_y_y[j]);\n\t\t\t\t\t//ans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans += y_y_y[i + 1] - y_y_y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans += y_y_y[j + 1] - y_y_y[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define L 10000\n\nunsigned short m[L+3][L+3];\n\nint main() {\n\tint N, kind;\n\twhile ( cin >> N >> kind, N || kind ) {\n\t\tfill(&m[0][0], &m[0][0]+(L+3)*(L+3), 0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n//\t\t\t++x2, ++y2;\n\t\t\t++m[y1+1][x1+1], --m[y2+1][x1+1];\n\t\t\t--m[y1+1][x2+1], ++m[y2+1][x2+1];\n\t\t}\n\t\tfor (int y = 1; y <= L+1; ++y) for (int x = 1; x <= L+1; ++x) {\n\t\t\tm[y+1][x] += m[y][x];\n\t\t}\n\t\tfor (int y = 1; y <= L+1; ++y) for (int x = 1; x <= L+1; ++x) {\n\t\t\tm[y][x+1] += m[y][x];\n\t\t}\n\n\t\tint S = 0;\n\t\tint l = 0;\n\t\tfor (int y = 1; y <= L+1; ++y) for (int x = 1; x <= L+1; ++x) {\n\t\t\tif (m[y][x]) {\n\t\t\t\tif (!m[y-1][x]) ++l;\n\t\t\t\tif (!m[y][x-1]) ++l;\n\t\t\t\tif (!m[y+1][x]) ++l;\n\t\t\t\tif (!m[y][x+1]) ++l;\n\t\t\t\t++S;\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t\tif (kind == 2) cout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n, t, ax[10000], ay[10000], bx[10000], by[10000], J[3][10004];\npair<int, int> solve(int row) {\n\tfor (int i = 0; i < 3; i++) { for (int j = 0; j < 10004; j++)J[i][j] = 0; }\n\tfor (int i = 0; i < 3; i++) {\n\t\tint Plus = i - 1 + row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (ax[j] <= Plus && Plus < bx[j]) { J[i][ay[j]]++; J[i][by[j]]--; }\n\t\t}\n\t\tfor (int j = 1; j < 10004; j++)J[i][j] += J[i][j - 1];\n\t\tfor (int j = 1; j < 10004; j++) { if (J[i][j] >= 1)J[i][j] = 1; }\n\t}\n\tint sum1 = 0; for (int i = 0; i < 10004; i++)sum1 += J[1][i];\n\tint sum2 = 0;\n\tfor (int i = 0; i < 10004; i++) { if (i >= 1 && J[1][i] + J[1][i - 1] == 1) { sum2++; } if (i < 10003 && J[1][i] + J[1][i + 1] == 1) { sum2++; } }\n\tfor (int i = 0; i < 10004; i++) { if (J[0][i] + J[1][i] == 1)sum2++; if (J[1][i] + J[2][i] == 1)sum2++; }\n\treturn make_pair(sum1, sum2);\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> t; if (n == 0 && t == 0)break;\n\t\tfor (int i = 0; i < n; i++) { cin >> ax[i] >> ay[i] >> bx[i] >> by[i]; ax[i]++; ay[i]++; bx[i]++; by[i]++; }\n\t\tint s1 = 0, s2 = 0; for (int i = 0; i <= 10003; i++) { pair<int, int>F = solve(i); s1 += F.first; s2 += F.second; }\n\t\tif (t == 1)cout << s1 << endl;\n\t\tif (t == 2)cout << s1 << endl << s2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n, t, ax[10000], ay[10000], bx[10000], by[10000], J[3][10004];\npair<int, int> solve(int row) {\n\tfor (int i = 0; i < 3; i++) { for (int j = 0; j < 10004; j++)J[i][j] = 0; }\n\tfor (int i = 0; i < 3; i++) {\n\t\tint Plus = i - 1 + row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (ax[j] <= Plus && Plus < bx[j]) { J[i][ay[j]]++; J[i][by[j]]--; }\n\t\t}\n\t\tfor (int j = 1; j < 10004; j++)J[i][j] += J[i][j - 1];\n\t\tfor (int j = 1; j < 10004; j++) { if (J[i][j] >= 1)J[i][j] = 1; }\n\t}\n\tint sum1 = 0; for (int i = 0; i < 10004; i++)sum1 += J[1][i];\n\tint sum2 = 0;\n\tfor (int i = 0; i < 10004; i++) { if (i >= 1 && J[1][i] + J[1][i - 1] == 1) { sum2++; } if (i < 10003 && J[1][i] + J[1][i + 1] == 1) { sum2++; } }\n\tfor (int i = 0; i < 10004; i++) { if (J[0][i] + J[1][i] == 1)sum2++; if (J[1][i] + J[2][i] == 1)sum2++; }\n\treturn make_pair(sum1, sum2);\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> t; if (n == 0 && t == 0)break;\n\t\tfor (int i = 0; i < n; i++) { cin >> ax[i] >> ay[i] >> bx[i] >> by[i]; ax[i]++; ay[i]++; bx[i]++; by[i]++; }\n\t\tint s1 = 0, s2 = 0; for (int i = 0; i <= 10003; i++) { pair<int, int>F = solve(i); s1 += F.first; s2 += F.second; }\n\t\tif (t == 1)cout << s1 << endl;\n\t\tif (t == 2)cout << s1 << endl << s2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; i++)\n\nint n, r;\nint m[10010][10010];\nint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &r),n||r){\n\t\trep(i,10010) rep(j,10010) m[i][j] = 0;\n\t\trep(i,n){\n\t\t\tint x1, x2, y1, y2;\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\tx1++; y1++;\n\t\t\tm[x1][y1]++; m[x2+1][y1]--; m[x1][y2+1]--; m[x2+1][y2+1]++;\n\t\t}\n\t\trep(i,10010) for(int j = 1; j < 10010; j++){\n\t\t\tm[i][j] += m[i][j-1];\n\t\t}\n\t\trep(i,10010) for(int j = 1; j < 10010; j++){\n\t\t\tm[j][i] += m[j-1][i];\n\t\t}\n\t\tint s = 0;\n\t\trep(i,10010) rep(j,10010) if(m[i][j] > 0) s++;\n\t\tprintf(\"%d\\n\", s);\n\t\tif(r == 1) continue;\n\t\ts = 0;\n\t\trep(i,10010) rep(j,10010){\n\t\t\tif(m[i][j] == 0) continue;\n\t\t\trep(k,4){\n\t\t\t\tif(0<=i+dx[k]&&i+dx[k]<10010&&0<=j+dy[k]&&j+dy[k]<10010&&m[i+dx[k]][j+dy[k]] == 0) s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 30000;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\n//int y[N];\n//vector<st> iny[N];\n\n/*\n29\n29\n80\n45\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *X,vector<st> *IN){\n  vector<int> xd;\n  rep(i,n){\n    xd.pb(x1[i]);\n    xd.pb(x2[i]);\n  }\n  sort(ALL(xd));\n  xd.erase(unique(ALL(xd)),xd.end());\n  rep(i,xd.size())X[px++]=xd[i],IN[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    while(j < px && x[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n  x_size = 0; y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n  x_size = x_max + 1;\n  y_size = y_max + 1;\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  loop(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  loop(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_size, x_i) {\n    loop(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        loop_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    loop(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (beg != a.beg)return beg < a.beg;\n  return end < a.end;\n}\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n\n  rep(i,px)req[i]=0;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      //IN[j].pb((st){y1[i],y2[i]});\n      req[j]++;\n      j++;\n    }\n  }\n\n  rep(i,px)IN[i]=vector<st>(req[i]),req[i]=0;\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      //IN[j].pb((st){y1[i],y2[i]});\n      IN[j][req[j]++]=(st){y1[i],y2[i]};\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      //cout << nowl <<\" \"<< nowh <<\" \" << l<<\" \" << h << endl;\n      if (nowl > h){\n\tlen+=2*width;\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << h << endl;\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint compress(vector<int> &v){\n  vector<int> x;\n  for(int i=0;i<v.size();i++){\n    x.push_back(v[i]);\n  }\n  v.erase(v.begin(),v.end());\n  sort(x.begin(),x.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  for(int i=0;i<x.size();i++){\n    v.push_back(x[i]);\n  }\n  return v.size();\n}\n\nint solve(){\n  int n,r,x1[10000],x2[10000],y1[10000],y2[10000];\n  vector<int> x,y;\n  scanf(\"%d %d\",&n,&r);\n  if(n==0&&r==0) return 1;\n  for(int i=0;i<n;i++){\n    scanf(\"%d %d %d %d\",x1+i,y1+i,x2+i,y2+i);\n    x.push_back(x1[i]);\n    x.push_back(x2[i]);\n    y.push_back(y1[i]);\n    y.push_back(y2[i]);\n  }\n  int size_x = compress(x);\n  int size_y = compress(y);\n  int cnt[size_x][size_y];\n  fill(cnt[0],cnt[0]+size_x*size_y,0);\n  for(int i=0;i<n;i++){\n    int index_x1,index_x2,index_y1,index_y2;\n    index_x1 = lower_bound(x.begin(),x.end(),x1[i])-x.begin();\n    index_x2 = lower_bound(x.begin(),x.end(),x2[i])-x.begin();\n    index_y1 = lower_bound(y.begin(),y.end(),y1[i])-y.begin();\n    index_y2 = lower_bound(y.begin(),y.end(),y2[i])-y.begin();\n    cnt[index_x1][index_y1]++;\n    cnt[index_x2][index_y1]--;\n    cnt[index_x1][index_y2]--;\n    cnt[index_x2][index_y2]++;\n  }\n  for(int i=0;i<size_x;i++){\n    for(int j=0;j<size_y;j++){\n      cnt[i][j+1] += cnt[i][j];\n    }\n  }\n  for(int i=0;i<size_y;i++){\n    for(int j=0;j<size_x;j++){\n      cnt[j+1][i] += cnt[j][i];\n    }\n  }\n  int s = 0;\n  int l = 0;\n  for(int i=0;i<size_x-1;i++){\n    for(int j=0;j<size_y-1;j++){\n      if(cnt[i][j]>0){\n        s += (x[i+1]-x[i])*(y[j+1]-y[j]);\n        int di[] = {0,0,1,-1};\n        int dj[] = {1,-1,0,0};\n        for(int k=0;k<4;k++){\n          int ni = i+di[k];\n          int nj = j+dj[k];\n          if(ni>=0&&nj>=0&&ni<size_x-1&&nj<size_y-1&&cnt[ni][nj]>0) continue;\n          if(di[k]==0) l += x[i+1]-x[i];\n          else if(dj[k]==0) l += y[j+1]-y[j];\n        }\n      }\n    }\n  }\n  if(r==1) printf(\"%d\\n\",s);\n  else if(r==2) printf(\"%d\\n%d\\n\",s,l);\n  return 0;\n}\n\nint main(){\n  while(true){\n    if(solve()) return 0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 30000;\n\nclass st{\npublic:\n  short height;\n  int out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nshort x[N];\nvector<st> inx[N];\n\nshort y[N];\nvector<st> iny[N];\n\n/*\n29\n29\n\n80\n\n45\n\n\n\n*/\n\nvoid makedata(int n,short *x1,short *x2,short *y1,short *y2,\n\t      int &px,int &py){\n  vector<short> xd,yd;\n  rep(i,n){\n    xd.pb(x1[i]);\n    xd.pb(x2[i]);\n    yd.pb(y1[i]);\n    yd.pb(y2[i]);\n  }\n  sort(ALL(xd));\n  sort(ALL(yd));\n  xd.erase(unique(ALL(xd)),xd.end());\n  yd.erase(unique(ALL(yd)),yd.end());\n  rep(i,xd.size())x[px++]=xd[i],inx[i].clear();\n  rep(i,yd.size())y[py++]=yd[i],iny[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    while(j < px && x[j] < x2[i]){\n      inx[j].pb((st){y1[i],1});\n      inx[j].pb((st){y2[i],-1});\n      j++;\n    }\n    j = lower_bound(ALL(yd),y1[i])-yd.begin();\n    while(j < py && y[j] < y2[i]){\n      iny[j].pb((st){x1[i],1});\n      iny[j].pb((st){x2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,short *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static short x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,py);\n    pair<int,int> ansx=solve(px,inx,x);\n    cout << ansx.first << endl;\n    if (q == 2){\n      pair<int,int> ansy= solve(py,iny,y);\n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\tvector<vector<int>>data;\n\twhile( cin >> N >> R, N || R ) {\n\t\tint xmax = 0, ymax = 0;\n\t\tvector<pair<pair<int, int>, pair<int, int>>>input( N );\n\t\tset<int>xs, ys;\n\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tinput[i] = make_pair( make_pair( x1, y1 ), make_pair( x2, y2 ) );\n\t\t\txs.insert( x1 );\n\t\t\tys.insert( y1 );\n\t\t\txs.insert( x2 );\n\t\t\tys.insert( y2 );\n\t\t}\n\t\tmap<int, int>x_x;\n\t\tmap<int, int>y_y;\n\t\tvector<int>x_x_x;\n\t\tvector<int>y_y_y;\n\t\tfor( auto xx : xs ) {\n\t\t\tx_x[xx] = x_x_x.size();\n\t\t\tx_x_x.emplace_back( xx );\n\t\t}\n\t\tfor( auto yy : ys ) {\n\t\t\ty_y[yy] = y_y_y.size();\n\t\t\ty_y_y.emplace_back( yy );\n\t\t}\n\t\txmax = xs.size() + 1;\n\t\tymax = ys.size() + 1;\n\t\tdata = vector<vector<int>>( xmax + 1, vector<int>( ymax + 1 ) );\n\t\tfor( size_t i = 0; i < input.size(); i++ ) {\n\t\t\tdata[x_x[input[i].first.first]][y_y[input[i].first.second]]++;\n\t\t\tdata[x_x[input[i].second.first]][y_y[input[i].second.second]]++;\n\t\t\tdata[x_x[input[i].second.first]][y_y[input[i].first.second]]--;\n\t\t\tdata[x_x[input[i].first.first]][y_y[input[i].second.second]]--;\n\t\t}\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans += (x_x_x[i + 1] - x_x_x[i])*(y_y_y[j + 1] - y_y_y[j]);\n\t\t\t\t\t//ans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans += y_y_y[i + 1] - y_y_y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans += y_y_y[j + 1] - y_y_y[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      // for (auto&& point : points) {\n      //   int x = point.first, y = point.second;\n\n      //   repete_from_to(y_i, y - 1, p_i) {\n      //     assign_if_larger(right_area_end_point[p_i], x);\n      //   }\n      // }\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define mp make_pair\nvector<P>vec[10005];\nint num[10005];\nint back[10005];\nint rank[10005];\nint par[10005];\nint main()\n{\n  int n,m;\n  while(1)\n    {\n      scanf(\"%d %d\",&n,&m);\n      for(int i=0;i<=10000;i++)\n\t{\n\t  vec[i].resize(0);\n\t}\n      if(!n && !m) break;\n      int maxi=0;\n      for(int w=0;w<n;w++)\n\t{\n\t  int a,b,c,d;\n\t  scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t  maxi=max(maxi,c-1);\n\t  for(int i=a;i<c;i++)\n\t    {\n\t      vec[i].pb(mp(b,d-b));\n\t    }\n\t}\n      int ans1=0,ans2=0;\n      memset(back,0,sizeof(back));\n      for(int i=0;i<=10000;i++)\n\t    {\n\t      if(vec[i].size()>0)\n\t\t{\n\t\t  memset(num,0,sizeof(num));\n\t\t  for(int j=0;j<vec[i].size();j++)\n\t\t    {\n\t\t      num[vec[i][j].first]=max(num[vec[i][j].first],vec[i][j].second);\n\t\t    }\n\t\t  for(int j=0;j<=10000;j++)\n\t\t    {\n\t\t      if(j!=0)\n\t\t\t{\n\t\t\t  num[j]=max(num[j],num[j-1]-1);\n\t\t\t}\n\t\t      if(i==maxi && num[j]!=0) ans2++;\n\t\t    }\n\t\t  for(int j=0;j<=10000;j++)\n\t\t    {\n\t\t      if(num[j]!=0)\n\t\t\t{\n\t\t\t  ans1++;\n\t\t\t  if(i==0)\n\t\t\t    {\n\t\t\t      ans2++;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      if(back[j]==0) ans2++;\n\t\t\t    }\n\t\t\t  if(j==0)\n\t\t\t    {\n\t\t\t      ans2++;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      if(!num[j-1])\n\t\t\t\t{\n\t\t\t\t  ans2++;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  if(j==10000)\n\t\t\t    {\n\t\t\t      ans2++;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      if(!num[j+1])\n\t\t\t\t{\n\t\t\t\t  ans2++;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  if(i!=0 && back[j]!=0)\n\t\t\t    {\n\t\t\t      ans2++;\n\t\t\t    }\n\t\t\t}\n\t\t      back[j]=num[j];\n\t\t    }    \n\t\t    }\n\t    }\n      printf(\"%d\\n\",ans1);\n      if(m==2)\n\t{\n\t  printf(\"%d\\n\",ans2);\n\t}\n    }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\ntypedef pair<pii,int> ppii;\n\nint N,R;\nbitset<10001*100001> field;\nvector<ppii> rangeSet[10010];\nint line[10010];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nconst int INF=1000000000;\nint main(){\n  fast_stream();\n  while(cin>>N>>R&&(N|R)){\n    int miny,minx,maxy,maxx;\n    miny=minx=INF;\n    maxx=maxy=-INF;\n    for(int i=0;i<10001;i++)rangeSet[i].clear();\n    field.reset();\n    memset(line,0,sizeof(line));\n    for(int i=0;i<N;i++){\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2;\n      rangeSet[y1].push_back(make_pair(pii(x1,x2),1));\n      rangeSet[y2].push_back(make_pair(pii(x1,x2),-1));\n      maxy=max(y2+1,maxy);\n      maxx=max(x2,maxx);\n      miny=min(y1,miny);\n      minx=min(x1,minx);\n    }\n    int S=0;\n    for(int y=miny;y<maxy;y++){\n      for(int i=0;i<(int)rangeSet[y].size();i++){\n\tint sx=rangeSet[y][i].first.first;\n\tint ex=rangeSet[y][i].first.second;\n\tint a=rangeSet[y][i].second;\n\tfor(int j=sx;j<ex;j++)line[j]+=a;\n      }\n      for(int x=minx;x<maxx;x++)\n\tif(line[x]>0){\n\t  S++;\n\t  field[y*10001+x]=1;\n\t}\n    }\n    //int S=field.count();\n    int E=0;\n    for(int i=miny;i<maxy;i++){\n      for(int j=minx;j<maxx;j++){\n\tif(field[i*10001+j]==0)continue;\n\tfor(int k=0;k<4;k++){\n\t  int ny=i+dy[k];\n\t  int nx=j+dx[k];\n\t  if(ny>=0&&nx>=0&&ny<=10000&&nx<=10000){\n\t    if(field[ny*10001+nx]==0){\n\t      E++;\n\t    }\n\t  }\n\t  else{\n\t    E++;\n\t  }\n\t}\n      }\n    }\n    cout<<S<<endl;\n    if(R==2)cout<<E<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n, r, mx, Mx, my, My, res, a, b, c, d, i, j;\nint mp[10003][10003];\nint main() {\n    while (scanf(\"%d%d\",&n,&r)) {\n        if (!n&&!r) break;\n        memset(mp,0,sizeof(mp));\n        mx=10003; Mx=0; my=10003; My=0;\n        for (i=0; i<n; i++) {\n            scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            a++; b++; c++; d++;\n            mp[a][b]++; mp[c][d]++;\n            mp[a][d]--; mp[c][b]--;\n            mx=min(mx,a);\n            Mx=max(Mx,c+1);\n            my=min(my,b);\n            My=max(My,d+1);\n        }\n        for (i=mx; i<Mx; i++) {\n            for (j=my; j<My; j++) mp[i][j]+=mp[i][j-1];\n        }\n        res=0;\n        for (i=my; i<My; i++) {\n            for (j=mx; j<Mx; j++) {\n                mp[j][i]+=mp[j-1][i];\n                if (mp[j][i]!=0) res++;\n            }\n        }\n        printf(\"%d\\n\",res);\n        if (r==2) {\n            res=0;\n            for (i=mx; i<Mx; i++) for (j=my; j<My; j++) {\n                if (mp[i][j]) res+=!mp[i-1][j]+!mp[i][j-1]+!mp[i+1][j]+!mp[i][j+1];\n            }\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 30000;\n\nclass st{\npublic:\n  int height;\n  int out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\nint y[N];\nvector<st> iny[N];\n\n/*\n29\n29\n\n80\n\n45\n\n\n\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int &py){\n  vector<int> xd,yd;\n  rep(i,n){\n    xd.pb(x1[i]);\n    xd.pb(x2[i]);\n    yd.pb(y1[i]);\n    yd.pb(y2[i]);\n  }\n  sort(ALL(xd));\n  sort(ALL(yd));\n  xd.erase(unique(ALL(xd)),xd.end());\n  yd.erase(unique(ALL(yd)),yd.end());\n  rep(i,xd.size())x[px++]=xd[i],inx[i].clear();\n  rep(i,yd.size())y[py++]=yd[i],iny[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    while(j < px && x[j] < x2[i]){\n      inx[j].pb((st){y1[i],1});\n      inx[j].pb((st){y2[i],-1});\n      j++;\n    }\n    j = lower_bound(ALL(yd),y1[i])-yd.begin();\n    while(j < py && y[j] < y2[i]){\n      iny[j].pb((st){x1[i],1});\n      iny[j].pb((st){x2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,py);\n    pair<int,int> ansx=solve(px,inx,x);\n    pair<int,int> ansy= solve(py,iny,y);\n    cout << ansx.first << endl;\n    if (q == 2)cout << ansx.second+ansy.second << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 30000;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\n//int y[N];\n//vector<st> iny[N];\n\n/*\n29\n29\n80\n45\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *X,vector<st> *IN){\n  //vector<int> xd;\n  static int xd[N];\n  int p=0;\n  rep(i,n){\n    //xd.pb(x1[i]);\n    //xd.pb(x2[i]);\n    xd[p++]=x1[i];\n    xd[p++]=x2[i];\n  }\n  //sort(ALL(xd));\n  sort(xd,xd+p);\n  //xd.erase(unique(ALL(xd)),xd.end());\n  p=unique(xd,xd+p)-xd;\n  //rep(i,xd.size())X[px++]=xd[i],IN[i].clear();\n  rep(i,p)X[px++]=xd[i],IN[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    //int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    int j=lower_bound(xd,xd+p,x1[i])-xd;\n    while(j < px && x[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint map[10003][10003];\n\nint main(){\n\twhile(1){\n\t\tint n,r,ans=0,ans2=0,minx=10001,miny=10001,maxx=0,maxy=0;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tmap[x1][y1]-=1;\n\t\t\tmap[x2][y1]+=1;\n\t\t\tmap[x1][y2]+=1;\n\t\t\tmap[x2][y2]-=1;\n\t\t}\n\t\tmx++,my++;\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tt+=map[j][i];\n\t\t\t\tmap[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tt+=map[i][j];\n\t\t\t\tmap[i][j]=t;\n\t\t\t\tif(map[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\t\tif(map[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int a;\n    int b1, b2;\n    bool start;\n\n    Tag() : a(0), b1(0), b2(0), start(false) {}\n    Tag(int aa, int bb1, int bb2, bool s) : a(aa), b1(bb1), b2(bb2), start(s) {}\n};\n\nbool cmp(const Tag &t1, const Tag &t2) {\n    if(t1.a != t2.a) return t1.a < t2.a;\n    return !t1.start;\n}\n\nint main() {\n    while(true) {\n        int N, R;\n        cin >> N >> R;\n        if(!N && !R) break;\n\n        vector<Tag> xtag, ytag;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            xtag.push_back(Tag(x1, y1, y2, true));\n            xtag.push_back(Tag(x2, y1, y2, false));\n            ytag.push_back(Tag(y1, x1, x2, true));\n            ytag.push_back(Tag(y2, x1, x2, false));\n        }\n        sort(xtag.begin(), xtag.end(), cmp);\n        sort(ytag.begin(), ytag.end(), cmp);\n\n        int max_y = ytag[ytag.size()-1].a;\n        int area = 0;\n        int len = 0;\n        for(int y = 0; y < max_y; ++y) {\n            int depth = 0;\n            int startx = 0;\n            int prevx = -1;\n            for(int i = 0; i < xtag.size(); ++i) {\n                if(xtag[i].b1 <= y && y < xtag[i].b2) {\n                    if(xtag[i].start) {\n                        if(depth == 0) {\n                            if(xtag[i].a != prevx) ++len;\n                            else --len;\n                            startx = xtag[i].a;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            area += xtag[i].a-startx;\n                            prevx = xtag[i].a;\n                            ++len;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << area << endl;\n        if(R == 1) continue;\n\n        int max_x = xtag[xtag.size()-1].a;\n        for(int x = 0; x < max_x; ++x) {\n            int depth = 0;\n            int prevy = -1;\n            for(int i = 0; i < ytag.size(); ++i) {\n                if(ytag[i].b1 <= x && x < ytag[i].b2) {\n                    if(ytag[i].start) {\n                        if(depth == 0) {\n                            if(prevy != ytag[i].a) ++len;\n                            else --len;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            ++len;\n                            prevy = ytag[i].a;\n                        }\n                    }\n                }\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint cnt[10005][10005];\n\nint compress(vector<int> &v){\n  vector<int> x;\n  for(int i=0;i<v.size();i++){\n    x.push_back(v[i]);\n  }\n  v.erase(v.begin(),v.end());\n  sort(x.begin(),x.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  for(int i=0;i<x.size();i++){\n    v.push_back(x[i]);\n  }\n  return v.size();\n}\n\nint solve(){\n  int n,r,x1[10000],x2[10000],y1[10000],y2[10000];\n  vector<int> x,y;\n  scanf(\"%d %d\",&n,&r);\n  if(n==0&&r==0) return 1;\n  for(int i=0;i<n;i++){\n    scanf(\"%d %d %d %d\",x1+i,y1+i,x2+i,y2+i);\n    x.push_back(x1[i]);\n    x.push_back(x2[i]);\n    y.push_back(y1[i]);\n    y.push_back(y2[i]);\n  }\n  int size_x = compress(x);\n  int size_y = compress(y);\n  for(int i=0;i<size_x;i++) for(int j=0;j<size_y;j++) cnt[i][j] = 0;\n  for(int i=0;i<n;i++){\n    int index_x1,index_x2,index_y1,index_y2;\n    index_x1 = lower_bound(x.begin(),x.end(),x1[i])-x.begin();\n    index_x2 = lower_bound(x.begin(),x.end(),x2[i])-x.begin();\n    index_y1 = lower_bound(y.begin(),y.end(),y1[i])-y.begin();\n    index_y2 = lower_bound(y.begin(),y.end(),y2[i])-y.begin();\n    cnt[index_x1][index_y1]++;\n    cnt[index_x2][index_y1]--;\n    cnt[index_x1][index_y2]--;\n    cnt[index_x2][index_y2]++;\n  }\n  for(int i=0;i<size_x;i++){\n    for(int j=0;j<size_y;j++){\n      cnt[i][j+1] += cnt[i][j];\n    }\n  }\n  for(int i=0;i<size_y;i++){\n    for(int j=0;j<size_x;j++){\n      cnt[j+1][i] += cnt[j][i];\n    }\n  }\n  int s = 0;\n  int l = 0;\n  for(int i=0;i<size_x-1;i++){\n    for(int j=0;j<size_y-1;j++){\n      if(cnt[i][j]>0){\n        s += (x[i+1]-x[i])*(y[j+1]-y[j]);\n        int di[] = {0,0,1,-1};\n        int dj[] = {1,-1,0,0};\n        for(int k=0;k<4;k++){\n          int ni = i+di[k];\n          int nj = j+dj[k];\n          if(ni>=0&&nj>=0&&ni<size_x-1&&nj<size_y-1&&cnt[ni][nj]>0) continue;\n          if(di[k]==0) l += x[i+1]-x[i];\n          else if(dj[k]==0) l += y[j+1]-y[j];\n        }\n      }\n    }\n  }\n  if(r==1) printf(\"%d\\n\",s);\n  else if(r==2) printf(\"%d\\n%d\\n\",s,l);\n  return 0;\n}\n\nint main(){\n  while(true){\n    if(solve()) return 0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nstruct Rect{\n\tshort x1,x2,y1,y2;\n};\n\nclass Compare{\n\tpublic:\n\tbool operator()(const Rect &rect1,const Rect &rect2){\n\t\treturn rect1.x1<rect2.x1;\n\t}\n};\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<P> range[],vector<Rect> &rects){\n\tint result=0;\n\tint index=0;\n\tREP(x,0,1001){\n\t\twhile(index<rects.size()&&rects[index].x1<=x){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x].begin(),range[x].end());\n\t\tint y=0;\n\t\tREP(i,0,range[x].size()){\n\t\t\tif(range[x][i].S_>y) result+=range[x][i].S_-max(y,range[x][i].F_);\n\t\t\ty=max(y,range[x][i].S_);\n\t\t}\n\t\tvector<P>().swap(range[x]);\n\t}\n\treturn result;\n}\n\nint Count(vector<P> range[],array<array<bool,1001>,3> &flag,int x){\n\tint index=0,y=0,result=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t}\n\t\t++index;\n\t}\n\treturn result;\n}\n\nint CalcLength(vector<P> range[],vector<Rect> &rects){\n\tint result=0,index=0;\n\t//array<array<bool> > flag(3,array<bool>(1001));\n\tarray<array<bool,1001>,3> flag;\n\tREP(x,1,10009){\n\t\twhile(index<rects.size()&&rects[index].x1<=x+1){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x+1].begin(),range[x+1].end());\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,range[x+1].size()){\n\t\t\tif(range[x+1][i].S_>y) fill_n(flag[(x+1)%3].begin()+max(y,range[x+1][i].F_),range[x+1][i].S_-max(y,range[x+1][i].F_),true);\n\t\t\ty=max(range[x+1][i].S_,y);\n\t\t}\n\t\tresult+=Count(range,flag,x);\n\t\tif(x-2>=0) vector<P>().swap(range[x-2]);\n\t}\n\treturn result;\n}\n\nint main(){\n\t//std::ios::sync_with_stdio(false);\n\t//std::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\t//array<vector<P>,1001> range;\n\t\tvector<P> range[1001];\n\t\tvector<Rect> rects(N);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\trects[i].x1=x1+4;\n\t\t\trects[i].y1=y1+4;\n\t\t\trects[i].x2=x2+4;\n\t\t\trects[i].y2=y2+4;\n\t\t}\n\t\tsort(rects.begin(),rects.end(),Compare());\n\t\tcout << CalcSize(range,rects) << endl;\n\t\tif(R==2) cout << CalcLength(range,rects) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n#define MAX 10003\n\nint main(){\n\tint n, r;\n\twhile(scanf(\"%d%d\", &n, &r), n){\n\t\tvector<vector<pair<int,int> > > ev(MAX);\n\t\tint x1, x2, y1, y2;\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\tev[x1+1].push_back(make_pair(y1+1, 1));\n\t\t\tev[x1+1].push_back(make_pair(y2+1, -1));\n\t\t\tev[x2+1].push_back(make_pair(y1+1, -1));\n\t\t\tev[x2+1].push_back(make_pair(y2+1, 1));\n\t\t}\n\n\t\tint area = 0, len = 0;\n\n\t\tvector<int> prev(MAX), now = prev, next = prev;\n\t\tfor(int i = 0; i + 1 < MAX; ++i){\n\t\t\tfill(next.begin(), next.end(), 0);\n\t\t\tfor(int j = 0; j < ev[i+1].size(); ++j){\n\t\t\t\tnext[ev[i+1][j].first] += ev[i+1][j].second;\n\t\t\t}\n\t\t\tfor(int j = 1; j < MAX; ++j){\n\t\t\t\tnext[j] += next[j-1];\n\t\t\t}\n\t\t\tfor(int j = 0; j < MAX; ++j){\n\t\t\t\tnext[j] += now[j];\n\t\t\t}\n\n\t\t\tfor(int j = 1; j + 1 < MAX; ++j){\n\t\t\t\tif(now[j] == 0) continue;\n\t\t\t\t++area;\n\t\t\t\t\n\t\t\t\tif(prev[j] == 0) ++len;\n\t\t\t\tif(next[j] == 0) ++len;\n\t\t\t\tif(now[j-1] == 0) ++len;\n\t\t\t\tif(now[j+1] == 0) ++len;\n\t\t\t}\n\t\t\t\n\t\t\tprev.swap(now);\n\t\t\tnow.swap(next);\n\t\t}\n\n\t\tprintf(\"%d\\n\", area);\n\t\tif(r == 2) printf(\"%d\\n\", len);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\nvector<T> coner;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(cin >> n >> r, n | r){\n\tfor(int i = 0;i < 3;i++)\n\t    fill(imos[i], imos[i] + 10500, 0);\n\t\t\n\t\t\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 10500;\n\tright_side = top = 1;\n\tconer.clear();\n\tfor(int i = 0;i < n;i++){\n\t    cin >> ax >> ay >> bx >> by;\n\t    left_side = min(left_side, ++ax);\n\t    right_side = max(right_side, ++bx);\n\t    bottom = min(bottom, ++ay);\n\t    top = max(top, ++by);\n\t    \n\t    coner.push_back(T(P(ax, ay), 1));\n\t    coner.push_back(T(P(ax, by), -1));\n\t    coner.push_back(T(P(bx, ay), -1));\n\t    coner.push_back(T(P(bx, by), 1));\n\t}\n\tconer.push_back(T(P(INF, INF), 0));\n\tsort(coner.begin(), coner.end());\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(coner[p].first == P(i, j)){\n\t\t    imos[i % 3][j] += coner[p++].second;\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tcout << area << endl;\n\tif(r == 2)cout << round << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X1[10010], X2[10010], Y1[10010], Y2[10010];\nint n, r, p[3][10010];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> r; if (n == 0 && r == 0)break;\n\t\tint maxx = 0, maxy = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\t\t\tif (X2[i] > maxx)maxx = X2[i];\n\t\t\tif (Y2[i] > maxy)maxy = Y2[i];\n\t\t}\n\t\tint cnt1 = 0, cnt2 = 0;\n\t\tfor (int i = 0; i < maxx + 10; i++) {\n\t\t\tfor (int j = 0; j < 30030; j++)p[j / 10010][j % 10010] = 0;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tint G = i + j, H = j + 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (X1[k] <= G && G < X2[k]) {\n\t\t\t\t\t\tp[H][Y1[k]]++; p[H][Y2[k]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 1; k < 10010; k++)p[j][k] += p[j][k - 1];\n\t\t\t}\n\t\t\tfor (int j = 0; j < maxy + 10; j++) {\n\t\t\t\tif (p[1][j] >= 1)cnt1++;\n\t\t\t\tif (i == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\tif (p[1][j] == 0 && p[2][j] >= 1)cnt2++;\n\t\t\t\tif (p[1][j] >= 1 && p[2][j] == 0)cnt2++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < maxy + 10; j++) {\n\t\t\t\tif (j == 0 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j == 10009 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j >= 1 && j <= 10008) {\n\t\t\t\t\tif (p[1][j] >= 1 && p[1][j + 1] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j] == 0 && p[1][j + 1] >= 1)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 1)cout << cnt1 << endl;\n\t\tif (r == 2)cout << cnt1 << endl << cnt2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    vector<vector<pair<int,int> > >v;\n    for(int i=0;i<n;i++){\n      int x,y,xx,yy;\n      cin>>x>>y>>xx>>yy;\n      if(v.size()<yy){\n\tv.resize(yy);\n      }\n      for(int j=y;j<yy;j++){\n\tv[j].push_back(make_pair(x,xx));\n      }\n    }\n    for(int i=0;i<v.size();i++){\n      sort(v[i].begin(),v[i].end());\n      for(int j=0;j<v[i].size();j++){\n\tint m=v[i][j].second;\n\tint k;\n\tfor(k=j+1;k<v[i].size()&&v[i][k].first<=m;k++){\n\t  m=max(m,v[i][k].second);\n\t}\n\tv[i][j].second=m;\n\tv[i].erase(v[i].begin()+j+1,v[i].begin()+k);\n      }\n    }\n    int a=0;\n    for(int i=0;i<v.size();i++){\n      for(int j=0;j<v[i].size();j++){\n\ta+=v[i][j].second-v[i][j].first;\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      bool b[2][10000]={};\n      for(int i=0;i<v.size();i++){\n\tl+=v[i].size()*2;\n\tfill(b[i&1],b[(i&1)+1],false);\n\tfor(int j=0;j<v[i].size();j++){\n\t  for(int k=v[i][j].first;k<v[i][j].second;k++){\n\t    b[i&1][k]=true;\n\t  }\n\t}\n\tfor(int j=0;j<10000;j++){\n\t  l+=b[i&1][j]^b[!(i&1)][j];\n\t}\n      }\n      l+=count(b[v.size()-1&1],b[(v.size()-1&1)+1],true);\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    int x[10000][2],y[10000][2];\n    vector<int> vx(2),vy(2);\n    vx[0]=vy[0]=-1;\n    vx[1]=vy[1]=10001;\n    multimap<int,int> m[10000];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<2;j++){\n\tcin>>x[i][j]>>y[i][j];\n\tvx.push_back(x[i][j]);\n\tvy.push_back(y[i][j]);\n      }\n      for(int j=y[i][0];j<y[i][1];j++){\n\tm[j].insert(make_pair(x[i][0],x[i][1]));\n      }\n      //      cout<<x[i][0]<<' '<<x[i][1]<<endl;\n    }\n    for(int i=0;i<10000;i++){\n      for(multimap<int,int>::iterator it=m[i].begin();it!=m[i].end();){\n\tmultimap<int,int>::iterator it2=it;\n\tit2++;\n\tif(it2!=m[i].end()&&it2->first<=it->second){\n\t  //\t  cout<<it->first<<' '<<it->second<<' '<<it2->first<<' '<<it2->second<<endl;\n\t  it->second=max(it->second,it2->second);\n\t  m[i].erase(it2);\n\t}else{\n\t  it++;\n\t}\n      }\n    }\n    sort(vx.begin(),vx.end());\n    vx.erase(unique(vx.begin(),vx.end()),vx.end());\n    sort(vy.begin(),vy.end());\n    vy.erase(unique(vy.begin(),vy.end()),vy.end());\n    vector<vector<bool> > v(vy.size()-1,vector<bool>(vx.size()-1));\n    for(int i=0;i<n;i++){\n      int jl=lower_bound(vy.begin(),vy.end(),y[i][1])-vy.begin();\n      int kl=lower_bound(vx.begin(),vx.end(),x[i][1])-vx.begin();\n      for(int j=lower_bound(vy.begin(),vy.end(),y[i][0])-vy.begin();j<jl;j++){\n\tint jj=vy[j];\n\tfor(multimap<int,int>::iterator it=m[jj].begin();it!=m[jj].end();it++){\n\t  for(int k=lower_bound(vx.begin(),vx.end(),it->first)-vx.begin();k<lower_bound(vx.begin(),vx.end(),it->second)-vx.begin();k++){\n\t    v[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    int a=0;\n    for(int i=0;i<v.size();i++){\n      for(int j=0;j<v[i].size();j++){\n\tif(v[i][j]){\n\t  a+=(vy[i+1]-vy[i])*(vx[j+1]-vx[j]);\n\t}\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j+1<v[i].size();j++){\n\t  if(v[i][j]^v[i][j+1]){\n\t    l+=vy[i+1]-vy[i];\n\t  }\n\t}\n      }\n      for(int i=0;i<v[0].size();i++){\n\tfor(int j=0;j+1<v.size();j++){\n\t  if(v[j][i]^v[j+1][i]){\n\t    l+=vx[i+1]-vx[i];\n\t  }\n\t}\n      }\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nshort min_x1, max_x2, min_y1, max_y2;\nvector<pair<pair<short, short>, short> > *variation;\nint surface_sum;\nint perimeter_sum;\nvector<pair<pair<short, short>, short> >::iterator save_variation;\n\nbool Comp(const pair<pair<short, short>, short>& a, const pair<pair<short, short>, short>& b) {\n    pair<short, short> axy = a.first;\n    pair<short, short> bxy = b.first;\n\n    if (axy.second == bxy.second) {\n        return axy.first < bxy.first;\n    } else {\n        return axy.second < bxy.second;\n    }\n\n    return false;\n}\n\nvoid sort_vector() {\n    sort(variation->begin(), variation->end(), Comp);\n    return ;\n}\n\nshort variation_return(short x, short y) {\n    short sum = 0;\n\n    if (save_variation == variation->end()) return 0;\n\n    while ((save_variation->first.second < y) || ((save_variation->first.second == y) && (save_variation->first.first < x))) {\n        save_variation++;\n        if (save_variation == variation->end()) return 0;\n    }\n\n    while (save_variation->first.first == x && save_variation->first.second == y) {\n        sum += save_variation->second;\n        save_variation++;\n        if (save_variation == variation->end()) return sum;\n    }\n\n    return sum;\n}\n\nvoid surface(short calc[2][10002], int j) {\n    if (calc[1][j] > 0) surface_sum++;\n\n    return ;\n}\n\nvoid perimeter(short calc[2][10002], int j) {\n    if (calc[1][j] + calc[1][j-1] > 0 && (calc[1][j] == 0 || calc[1][j-1] == 0)) perimeter_sum++;\n\n    if (calc[1][j] + calc[0][j] > 0 && (calc[1][j] == 0 || calc[0][j] == 0)) perimeter_sum++;\n\n    return ;\n}\n\nvoid process() {\n    short i;\n    short calc[2][10002];\n    \n    for (i=0;i<2;i++) {\n        int j;\n        for (j=0;j<10002;j++) {\n            calc[i][j] = 0;\n        }\n    }\n\n    for (i=min_y1-1;i<max_y2+1;i++) {\n        int j;\n        \n        for (j=min_x1-1;j<max_x2+1;j++) {\n            short x = variation_return(j, i);\n            calc[1][j] = x;\n\n            calc[1][j] += calc[1][j-1];\n            calc[1][j] += calc[0][j];\n            calc[1][j] -= calc[0][j-1];\n            surface(calc, j);\n            perimeter(calc, j);\n\n\n            if (j > min_x1 + 1) {\n                calc[0][j-3] = calc[1][j-3];\n            }\n        }\n\n        calc[0][max_x2-2] = calc[1][max_x2-2];\n        calc[0][max_x2-1] = calc[1][max_x2-1];\n        calc[0][max_x2] = calc[1][max_x2];\n\n    }\n    return;\n}\n\nint main() {\n    while (1) {\n        short i;\n        int r;\n        short x1, x2, y1, y2;\n\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r ==0) return 0;\n\n        variation = new vector<pair<pair<short, short>, short> >();\n\n        min_x1 = 10000;\n        min_y1 = 10000;\n        max_x2 = 0;\n        max_y2 = 0;\n        for (i=0;i<n;i++) {\n            scanf(\"%hd %hd %hd %hd\", &x1, &y1, &x2, &y2);\n            x1++;\n            x2++;\n            y1++;\n            y2++;\n            if (min_x1 > x1) min_x1 = x1;\n            if (max_x2 < x2) max_x2 = x2;\n            if (min_y1 > y1) min_y1 = y1;\n            if (max_y2 < y2) max_y2 = y2;\n            variation->push_back(make_pair(make_pair(x1, y1), 1));\n            variation->push_back(make_pair(make_pair(x1, y2), -1));\n            variation->push_back(make_pair(make_pair(x2, y1), -1));\n            variation->push_back(make_pair(make_pair(x2, y2), 1));\n        }\n        surface_sum = 0;\n        perimeter_sum = 0;\n\n        sort_vector();\n\n        save_variation = variation->begin();\n\n        process();\n\n        printf(\"%d\\n\", surface_sum);\n\n        if (r == 2) {\n            printf(\"%d\\n\", perimeter_sum);\n        }        \n        \n        delete variation;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509>\n?????????============================================================\n?????¢???????????¢??????????????????????????????????????????.???????????????????????§????????????????????¨????????¢????????¨???????±???????????????°?????????????????????.\n?????????, ?????¢?????§?¨??????¢??¨??????????????¨???, ??????????????????????¬?????????¶ (1), (2) ????????????????????¨??????.\n(1) ???????????????????????¢??? 4 ????????? x, y ??§?¨??????¨??? 0 ??\\??? 10000 ??\\????????´??°??§??????,\n    ????????¢???????????? x ???, ????????? y ??????????????§??????.\n(2) ?????????????????°????????? 10000 ?????\\?????§??????.\n??\\???????????? ??? 1 ?????????????????¢????????° n ??¨??????????¨?????????¨?????´??° r ???????????§????????£?????????????????????.\n2 ????????\\??????????????????, ?????????????????????????????§?¨? (x1, y1) ??¨??????????????§?¨? (x2, y2) ?????§?¨???????\nx1, y1, x2, y2 ????????§????????§????????£??????????????????.\n\n???????????? r = 1 ?????¨??? 1 ???????????¢??????, r = 2 ?????¨??? 1 ???????????¢???, 2 ???????????¨???????????????????????????.\n??????????????´??????????????????????????\\???????????¨.\n\n=================================================================\n\n?§£??¬=============================================================\n\n================================================================\n*/\n\nint m[2][10010];\nvector<pll> ps[10010];\nint maxh, maxw;\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, r;\n\twhile (cin >> N >> r, N | r) {\n\t\tmaxh = -1, maxw = -1;\n\t\tmemset(m, 0, sizeof(m));\n\t\tfor (int i = 0; i < 10010;i++) ps[i].clear();\n\t\tfor (int i = 0;i < N;i++) {\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tx1++; y1++; x2++; y2++;\n\t\t\tps[y1].push_back({ x1,1 });\n\t\t\tps[y1].push_back({ x2,-1 });\n\t\t\tps[y2].push_back({ x1,-1 });\n\t\t\tps[y2].push_back({ x2,1 });\n\t\t\tmaxh = max(maxh, y2);\n\t\t\tmaxw = max(maxw, x2);\n\t\t}\n\n\t\tint Area = 0, Length = 0;\n\t\tint cur = 0, next = 1;\n\t\tfor (int i = 0; i <= maxh + 1;i++) {\n\t\t\tmemset(m[next], 0, sizeof(m[next]));\n\t\t\tfor (auto p : ps[i]) {\n\t\t\t\tm[next][p.first] += p.second; // ?´??????????????????¶???\n\t\t\t}\n\t\t\tfor (int j = 0; j <= maxw;j++) {\n\t\t\t\tm[next][j + 1] += m[next][j]; // ?´??????? ?¨?????????????\n\t\t\t\tm[next][j] += m[cur][j]; // ?´??????? ???????????????\n\t\t\t}\n\t\t\tfor (int j = 0; j <= maxw;j++) {\n\t\t\t\tif (m[next][j] > 0) Area++;\n\t\t\t\tif ((m[cur][j] > 0) != (m[next][j] > 0)) Length++;\n\t\t\t\tif ((m[next][j] > 0) != (m[next][j + 1] > 0)) Length++;\n\t\t\t}\n\t\t\tcur = !cur;\n\t\t\tnext = !next;\n\t\t}\n\t\tcout << Area << endl;\n\t\tif (r == 2) cout << Length << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n    int n, r;\n    while (cin >> n >> r, n != 0 && r != 0) {\n        int board[10000] = {0};\n        int x1, y1, x2, y2;\n        int square = 0;\n        int l = 0;\n        for (int i = 0; i < n; ++i) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            for (int x = x1; x < x2; ++x) {\n                for (int y = y1; y < y2; ++y) {\n                    if ((board[y] >> x & 1) == 0) {\n                        square++;\n                        l += 4;\n                        if (x - 1 >= 0 && (board[y] >> (x - 1) & 1) == 1) l-=2;\n                        if (y - 1 >= 0 && (board[y-1] >> x & 1) == 1) l-=2;\n                        if (x + 1 <= 10000 && (board[y] >> (x + 1) & 1) == 1) l-=2;\n                        if (y + 1 <= 10000 && (board[y+1] >> x & 1) == 1) l-=2;\n                    }\n                    board[y] |= 1 << x;\n                }\n            }\n        }\n        cout << square << endl;\n        if (r == 2) cout << l << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint a[2][10010];\nvector<pair<pair<int, int>, int> > v;\n\nint main() {\n  while (true) {\n    int n, r;\n    cin >> n >> r;\n    if (n == 0 && r == 0) break;\n    memset(a, 0, sizeof(a));\n    v.clear();\n    rep (i, n) {\n      int x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      ++x1, ++y1, ++x2, ++y2;\n      v.push_back(make_pair(make_pair(y1, x1), -1));\n      v.push_back(make_pair(make_pair(y1, x2), 1));\n      v.push_back(make_pair(make_pair(y2, x1), 1));\n      v.push_back(make_pair(make_pair(y2, x2), -1));\n    }\n    sort(v.begin(), v.end());\n    int res1 = 0, res2 = 0;\n    int t = 0;\n    rep (i, 10010) {\n      rep (j, 10010) a[1][j] = 0;\n      for (; t < (int)v.size(); ++t) {\n\tif (v[t].first.first != i) break;\n\ta[1][v[t].first.second] -= v[t].second;\n      }\n      rep (j, 10009) a[1][j + 1] += a[1][j];\n      rep (j, 10010) a[1][j] += a[0][j];\n      rep (j, 10010) if (a[1][j]) ++res1;\n      if (r == 2) rep (j, 10009) if (j > 0) {\n\t  if (!a[0][j] != !a[1][j]) ++res2;\n\t  if (!a[1][j] != !a[1][j - 1]) ++res2;\n\t}\n      rep (j, 10010) a[0][j] = a[1][j];\n    }\n    cout << res1 << endl;\n    if (r == 2) cout << res2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct R {\n\tint x1,x2,add;\n\tR(int _x1,int _x2,int _add) {x1=_x1,x2=_x2,add=_add;}\n};\nvector<R> V[10001];\nint field[2][10000];\nint X1,X2,Y1,Y2;\nint main() {\n\tint n,r;\n\twhile(scanf(\"%d %d\",&n,&r),n) {\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i=0;i<=10000;i++) V[i].clear();\n\t\tX1=10000,Y1=10000,X2=0,Y2=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\t\tV[y1].push_back(R(x1,x2,1));\n\t\t\tV[y2].push_back(R(x1,x2,-1));\n\t\t\tX1=min(x1,X1); Y1=min(y1,Y1);\n\t\t\tX2=max(x2,X2); Y2=max(y2,Y2);\n\t\t}\n\t\tint Y=1;\n\t\tint S=0,L=0;\n\t\tfor(int y=Y1;y<=Y2;y++,Y=!Y) {\n\t\t\tfor(int x=X1;x<X2;x++) field[Y][x]=field[!Y][x];\n\t\t\tfor(int i=0;i<V[y].size();i++)\n\t\t\t\tfor(int x=V[y][i].x1;x<V[y][i].x2;x++) field[Y][x]+=V[y][i].add;\n\t\t\tfor(int x=X1;x<X2;x++) {\n\t\t\t\tif(0<field[Y][x]) {\n\t\t\t\t\tS++;\n\t\t\t\t\tif(x==0||field[Y][x-1]==0) L++;\n\t\t\t\t\tif(x==9999||field[Y][x+1]==0) L++;\n\t\t\t\t}\n\t\t\t\tif((field[Y][x]==0&&0<field[!Y][x])||(0<field[Y][x]&&field[!Y][x]==0)) L++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",S);\n\t\tif(r==2) printf(\"%d\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n\nint s[11111][11111];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,r;\n\t\tscanf(\"%d %d\",&n,&r);\n\t\tif(n == 0 && r == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < 11111; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < 11111; ii++)\n\t\t\t{\n\t\t\t\ts[i][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\t\ts[x1][y1]++;\n\t\t\ts[x2][y2]++;\n\t\t\ts[x1][y2]--;\n\t\t\ts[x2][y1]--;\n\t\t}\n\t\tfor(int i = 0; i < 11111; i++)\n\t\t{\n\t\t\tint now = 0;\n\t\t\tfor(int ii = 0; ii < 11111; ii++)\n\t\t\t{\n\t\t\t\tnow += s[i][ii];\n\t\t\t\ts[i][ii] = now;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 11111; i++)\n\t\t{\n\t\t\tint now = 0;\n\t\t\tfor(int ii = 0; ii < 11111; ii++)\n\t\t\t{\n\t\t\t\tnow += s[ii][i];\n\t\t\t\ts[ii][i] = now;\n\t\t\t}\n\t\t}\n\t\tint all = 0;\n\t\tfor(int i = 0; i < 11111; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < 11111; ii++)\n\t\t\t{\n\t\t\t\tif(s[i][ii] > 0)\n\t\t\t\t{\n\t\t\t\t\tall++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",all);\n\t\tall = 0;\n\t\tif(r == 2)\n\t\t{\n\t\t\tfor(int i = 0; i < 11110; i++)\n\t\t\t{\n\t\t\t\tfor(int ii = 0; ii < 11110; ii++)\n\t\t\t\t{\n\t\t\t\t\tif(s[i][ii] != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(s[i - 1][ii] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ii != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(s[i][ii - 1] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s[i + 1][ii] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s[i][ii + 1] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",all);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nint n, r;\npair<pint,pint> inp[2][10100]; // x座標の範囲, y座標の範囲\npair<pint,pint> inp2[10100]; // y座標の範囲, x座標の範囲\n\nint pre[2][10100], ri[2][10100];\nint syui[2][10100];\nint area[2][10100];\n\nint main() {\n    while (cin >> n >> r) {\n        if (n == 0) break;\n        for (int i = 0; i < n; ++i) {\n            cin >> inp[0][i].first.first >> inp[0][i].second.first >> inp[0][i].first.second >> inp[0][i].second.second;\n            inp[1][i].first.first = inp[0][i].second.first;\n            inp[1][i].first.second = inp[0][i].second.second;\n            inp[1][i].second.first = inp[0][i].first.first;\n            inp[1][i].second.second = inp[0][i].first.second;\n        }\n        sort(inp[0], inp[0]+n); sort(inp[1], inp[1]+n);\n        \n        memset(pre, -1, sizeof(pre));\n        memset(ri, -1, sizeof(ri));\n        memset(syui, 0, sizeof(syui));\n        memset(area, 0, sizeof(area));\n        \n        for (int it = 0; it < 2; ++it) {\n            for (int i = 0; i < n; ++i) {\n                int xl = inp[it][i].first.first, xr = inp[it][i].first.second;\n                for (int y = inp[it][i].second.first; y < inp[it][i].second.second; ++y) {\n                    if (ri[it][y] < xl) {\n                        syui[it][y] += 2;\n                        area[it][y] += xr - xl;\n                    }\n                    else {\n                        if (xr > ri[it][y])\n                            area[it][y] += xr - ri[it][y];\n                    }\n                \n                    pre[it][y] = xl;\n                    ri[it][y] = max(ri[it][y], xr);\n                }\n            }\n        }\n        \n        int tot_area = 0, tot_syui = 0;\n        for (int i = 0; i <= 10000; ++i) {\n            tot_area += area[0][i];\n            tot_syui += syui[0][i] + syui[1][i];\n        }\n        \n        if (r == 1) cout << tot_area << endl;\n        if (r == 2) cout << tot_area << endl << tot_syui << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, r;\n        cin >> n >> r;\n        if(n == 0)\n            return 0;\n\n        int sy = INT_MAX;\n        int sx = INT_MAX;\n        int gy = INT_MIN;\n        int gx = INT_MIN;\n        vector<int> x1(n), y1(n), x2(n), y2(n);\n        for(int i=0; i<n; ++i){\n            cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n            sy = min(sy, y1[i]);\n            sx = min(sx, x1[i]);\n            gy = max(gy, y2[i]);\n            gx = max(gx, x2[i]);\n        }\n\n        int ret1 = 0;\n        int ret2 = 0;\n        for(int a=0; a<11; ++a){\n            for(int b=0; b<11; ++b){\n                int yMin = a * 1000 - 1;\n                int yMax = (a+1) * 1000;\n                int xMin = b * 1000 - 1;\n                int xMax = (b+1) * 1000;\n\n                if(gy < yMin || gx < xMin || sy > yMax || sx > yMax)\n                    continue;\n\n                vector<vector<int> > s(1001, vector<int>(1001, 0));\n                for(int i=0; i<n; ++i){\n                    if(y2[i] < yMin || x2[i] < xMin || y1[i] > yMax || x1[i] > xMax)\n                        continue;\n\n                    ++ s[max(yMin, y1[i])-yMin][max(xMin, x1[i])-xMin];\n                    if(x2[i] <= xMax)\n                        -- s[max(yMin, y1[i])-yMin][x2[i]-xMin];\n                    if(y2[i] <= yMax)\n                        -- s[y2[i]-yMin][max(xMin, x1[i])-xMin];\n                    if(y2[i] <= yMax && x2[i] <= xMax)\n                        ++ s[y2[i]-yMin][x2[i]-xMin];\n                }\n\n                for(int i=0; i<1001; ++i){\n                    for(int j=0; j<1000; ++j){\n                        s[i][j+1] += s[i][j];\n                    }\n                }\n                for(int i=0; i<1001; ++i){\n                    for(int j=0; j<1000; ++j){\n                        s[j+1][i] += s[j][i];\n                    }\n                }\n\n                for(int i=0; i<1000; ++i){\n                    for(int j=0; j<1000; ++j){\n                        if(s[i][j] > 0)\n                            ++ ret1;\n                        if((s[i][j] > 0) ^ (s[i+1][j] > 0))\n                            ++ ret2;\n                        if((s[i][j] > 0) ^ (s[i][j+1] > 0))\n                            ++ ret2;\n                    }\n                }\n            }\n        }\n\n        cout << ret1 << endl;\n        if(r == 2)\n            cout << ret2 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nstatic vector<pair<P,P> >in;\nstatic vector<P>vx[10001],vy[10001];\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    for(int i=0;i<10001;i++){\n      vx[i].clear();\n      vy[i].clear();\n    }\n\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      vx[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<in.size();i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nint n,r;\n\nstruct block{\n\tshort x1,x2,y,f;\n};\n\nblock b[20002];\nshort fie[10002][2];\n\nbool comp(const block &b1,const block &b2){\n\treturn b1.y<b2.y;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(b,0,sizeof(b));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint y1,y2;\n\t\t\tscanf(\"%d%d%d%d\",&b[i*2].x1,&y1,&b[i*2].x2,&y2);\n\t\t\tb[i*2].x2--;\n\t\t\tb[i*2+1].x1=b[i*2].x1;\n\t\t\tb[i*2+1].x2=b[i*2].x2;\n\t\t\tb[i*2].y=y1;\n\t\t\tb[i*2+1].y=y2;\n\t\t\tb[i*2].f=1;\n\t\t\tb[i*2+1].f=-1;\n\t\t}\n\t\tsort(b,b+n*2,comp);\n\t\tint ny=0;\n\t\tint now=0,prev=1;\n\t\tint res=0,res2=0;\n\t\tfor(int i=0;i<n*2;i++){\n\t\t\tif(ny!=b[i].y){\n\t\t\t\tswap(now,prev);\n\t\t\t\tint cnt=0;\n\t\t\t\tint cnt2=0,bt=0,cnt3=0;\n\t\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\t\tif(fie[j][now]>0 && fie[j][prev]==0)cnt3++;\n\t\t\t\t\tif(fie[j][now]==0 && fie[j][prev]>0)cnt3++;\n\t\t\t\t\tfie[j][now]=fie[j][prev];\n\t\t\t\t\tif(fie[j][now]>0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(bt==0)cnt2++,bt=1;\n\t\t\t\t\t}else bt=0;\n\t\t\t\t}\n\t\t\t\tres+=cnt*(b[i].y-ny);\n\t\t\t\tres2+=cnt2*2*(b[i].y-ny)+cnt3;\n\t\t\t}\n\t\t\tny=b[i].y;\n\t\t\tfor(int j=b[i].x1;j<=b[i].x2;j++)fie[j][now]+=b[i].f;\n\t\t\t//printf(\"%d\\n\",res2);\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\tif(r==2){\n\t\t\tswap(now,prev);\n\t\t\tint cnt3=0;\n\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\tif(fie[j][now]>0 && fie[j][prev]==0)cnt3++;\n\t\t\t\tif(fie[j][now]==0 && fie[j][prev]>0)cnt3++;\n\t\t\t\tfie[j][now]=fie[j][prev];\n\t\t\t}\n\t\t\tres2+=cnt3;\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nbool sheet[10001][10001];\n\nint main() {\n  for (;;) {\n    int n, r;\n    cin >> n >> r;\n    if (!(n || r)) return 0;\n    memset(sheet, 0, sizeof sheet);\n    int mx = 0, my = 0, area = 0;\n    for (int i = 0; i < n; i++) {\n      int sx, sy, ex, ey;\n      cin >> sx >> sy >> ex >> ey;\n      mx = max(mx, ex);\n      my = max(my, ey);\n      for (int x = sx; x < ex; x++)\n        for (int y = sy; y < ey; y++)\n          if (!sheet[x][y]) {\n            sheet[x][y] = true;\n            area++;\n          }\n    }\n    cout << area << endl;\n    if (r == 1) continue;\n    int circumference = 4 * area;\n    for (int x = 0; x <= mx; x++)\n      for (int y = 0; y <= my; y++)\n        if (sheet[x][y]) {\n          if (sheet[x+1][y])\n            circumference -= 2;\n          if (sheet[x][y+1])\n            circumference -= 2;\n        }\n    cout << circumference << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    vector<pair<int,int> >v[10000];\n    for(int i=0;i<n;i++){\n      int x,y,xx,yy;\n      cin>>x>>y>>xx>>yy;\n      for(int j=y;j<yy;j++){\n\tv[j].push_back(make_pair(x,xx));\n      }\n    }\n    for(int i=0;i<10000;i++){\n      sort(v[i].begin(),v[i].end());\n      for(int j=0;j<v[i].size();j++){\n\tint m=v[i][j].second;\n\tint k;\n\tfor(k=j+1;k<v[i].size()&&v[i][k].first<=m;k++){\n\t  m=max(m,v[i][k].second);\n\t}\n\tv[i][j].second=m;\n\tv[i].erase(v[i].begin()+j+1,v[i].begin()+k);\n      }\n    }\n    int a=0;\n    for(int i=0;i<10000;i++){\n      for(int j=0;j<v[i].size();j++){\n\ta+=v[i][j].second-v[i][j].first;\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      bool b[2][10000]={};\n      for(int i=0;i<10000;i++){\n\tl+=v[i].size()*2;\n\tfill(b[i&1],b[(i&1)+1],false);\n\tfor(int j=0;j<v[i].size();j++){\n\t  for(int k=v[i][j].first;k<v[i][j].second;k++){\n\t    b[i&1][k]=true;\n\t  }\n\t}\n\tfor(int j=0;j<10000;j++){\n\t  l+=b[i&1][j]^b[!(i&1)][j];\n\t}\n      }\n      l+=count(b[1],b[2],true);\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint n, q, x1[10000], y1[10000], x2[10000], y2[10000], imos[10001];\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &q);\n\n\t\tif (n == 0 && q == 0) break;\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x1[i]);\n\t\t\tscanf(\"%d\", &y1[i]);\n\t\t\tscanf(\"%d\", &x2[i]);\n\t\t\tscanf(\"%d\", &y2[i]);\n\t\t}\n\n\t\tint ret1 = 0;\n\t\tint ret2 = 0;\n\n\t\tfor (int i = 0; i < 10000; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (y1[j] <= i && i < y2[j])\n\t\t\t\t{\n\t\t\t\t\timos[x1[j]]++;\n\t\t\t\t\timos[x2[j]]--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\n\t\t\tfor (int j = 0; j <= 10000; j++)\n\t\t\t{\n\t\t\t\tif ((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n\n\t\t\t\tsum += imos[j]; imos[j] = 0;\n\n\t\t\t\tif(sum > 0) ret1++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 10000; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (x1[j] <= i && i < x2[j])\n\t\t\t\t{\n\t\t\t\t\timos[y1[j]]++;\n\t\t\t\t\timos[y2[j]]--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\n\t\t\tfor (int j = 0; j <= 10000; j++)\n\t\t\t{\n\t\t\t\tif ((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n\n\t\t\t\tsum += imos[j]; imos[j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret1);\n\n\t\tif (q == 2)\n\t\t{\n\t\t\tprintf(\"%d\\n\", ret2);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.first < q.first;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.second < q.second;\n}\n\nvector<pair<P,P> > in;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)return 0;\n\n    in.clear();\n    int mnx=INF,mny=INF,mxx=0,mxy=0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n      mnx=min(mnx,x1);\n      mny=min(mny,y1);\n      mxx=max(mxx,x2);\n      mxy=max(mxy,y2);\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    vector<P>v;\n    for(int i=mny;i<mxy;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].second.second>=i+1 && i>=in[j].second.first){\n\t  v.push_back(make_pair(in[j].first.first,in[j].first.second));\n\t}\n\tif(i<in[j].second.first)break;\n      }\n     \n      if(v.size()!=0){\n\tsort(v.begin(),v.end());\n\tint b=v[0].first,e=v[0].second;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].first,E=v[j].second;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end());\n\n      for(int i=mnx;i<mxx;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].first.second>=i+1 && i>=in[j].first.first)\n\t    v.push_back(make_pair(in[j].second.first,in[j].second.second));\n\n\t  if(i<in[j].first.first)break;\n\t}\n\tif(v.size()!=0){\n\t  sort(v.begin(),v.end());\n\t  int b=v[0].first,e=v[0].second;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].first,E=v[j].second;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F.F < q.F.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S.F < q.S.F;\n}\n\nvector<pair<P,P> > in;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    vector<P> v[10001];\n \n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct node {\n\tdouble x, r;\n};\n\nvector< vector<node> > emp, vx, vy;\n\nnode make_node(double x, double r) {\n\tnode v;\n\tv.x = x, v.r = r;\n\treturn v;\n}\n\ndouble abs(double n) {\n\treturn n < 0 ? -n : n;\n}\n\nvoid make_area(vector< vector<node> > &v, int n, int a, int b) {\n\tdouble x = (a + b) / 2.0, r = b - x;\n\tfor (int i = 0; i < v[n].size(); ++i) {\n\t\tnode nd = v[n][i];\n\t\tif (abs(x - nd.x) <= abs(r + nd.r)+0.1) {\n\t\t\tv[n][i].x = (min(x - r, nd.x - nd.r) + max(x + r, nd.x + nd.r)) / 2.0;\n\t\t\tv[n][i].r = max(x + r, nd.x + nd.r) - v[n][i].x;\n\t\t\treturn;\n\t\t}\n\t}\n\tv[n].push_back( make_node(x, r) );\n}\n\nint main() {\n\tint n, r;\n\n\temp.resize(10001);\n\n\twhile (cin >> n >> r, n || r) {\n\t\tvx = vy = emp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\t\tfor (int y = y1; y < y2; ++y)\n\t\t\t\tmake_area(vx, y, x1, x2);\n\n\t\t\tfor (int x = x1; x < x2; ++x)\n\t\t\t\tmake_area(vy, x, y1, y2);\n\t\t}\n\n\t\tint S = 0, l = 0;\n\t\tfor (int i = 0; i <= 10000; ++i) {\n\t\t\tfor (int x = 0; x < vx[i].size(); ++x)\n\t\t\t\tS += (int)(2 * vx[i][x].r);\n\n\t\t\tl += 2 * (vx[i].size() + vy[i].size());\n\t\t}\n\n\t\tcout << S << endl;\n\t\tif (r == 2) cout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      // for (auto&& point : points) {\n      //   int x = point.first, y = point.second;\n\n      //   repete_from_to(y_i, y - 1, p_i) {\n      //     assign_if_larger(right_area_end_point[p_i], x);\n      //   }\n      // }\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      // if (type == 2) {\n      //   // left line exists\n      //   if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n      //   // bottom line exists\n      //   if (\n      //       (y_i == 0 && is_area[x_i % 2][y_i]) ||\n      //       (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n      //       )\n      //     lines += 1;\n      // }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    // calc_and_output();\n    cout << 50 << endl;\n    if (type == 2) {\n      cout << 50 << endl;\n    }\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (beg != a.beg)return beg < a.beg;\n  return end < a.end;\n}\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],y2[i]});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      //cout << nowl <<\" \"<< nowh <<\" \" << l<<\" \" << h << endl;\n      if (nowl > h){\n\tlen+=2*width;\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << h << endl;\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint n, q, x1[10000], y1[10000], x2[10000], y2[10000], imos[10001];\n\nint main()\n{\n    while(true)\n    {\n        scanf(\"%d\", &n);\n        scanf(\"%d\", &q);\n        \n        if(n == 0 && q == 0) break;\n    \n        for(int i = 0; i < n; i++)\n        {\n            scanf(\"%d\", &x1[i]);\n            scanf(\"%d\", &y1[i]);\n            scanf(\"%d\", &x2[i]);\n            scanf(\"%d\", &y2[i]);\n        }\n    \n        int ret1 = 0;\n        int ret2 = 0;\n    \n        // tate\n    \n        for(int i = 0; i < 10000; i++)\n        {\n            for(int j = 0; j < n; j++)\n            {\n                if(y1[j] <= i && i < y2[j])\n                {\n                    imos[x1[j]]++;\n                    imos[x2[j]]--;\n                }\n            }\n            \n            int sum = 0;\n            \n            for(int j = 0; j <= 10000; j++)\n            {\n                if((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n                \n                sum += imos[j]; imos[j] = 0;\n                \n                if(sum > 0) ret1++;\n            }   \n        }   \n            \n        // yoko\n        \n        for(int i = 0; i < 10000; i++)\n        {\n            for(int j = 0; j < n; j++)\n            {\n                if(x1[j] <= i && i < x2[j])\n                {\n                    imos[y1[j]]++;\n                    imos[y2[j]]--;\n                }\n            }\n            \n            int sum = 0;\n            \n            for(int j = 0; j <= 10000; j++)\n            {\n                if((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n                \n                sum += imos[j]; imos[j] = 0;\n            }\n        }\n        \n        if(q == 1)\n        {\n            printf(\"%d\\n\", ret1);\n        }\n        else\n        {\n            printf(\"%d\\n\", ret1);\n            printf(\"%d\\n\", ret2);\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    // repeat_with_index(y_size, y_i) {\n    //   // update right_area_end_point\n    //   auto points = find_end_points(x_i, y_i);\n\n    //   // per point operation\n    //   for (auto&& point : points) {\n    //     int x = point.first, y = point.second;\n\n    //     repete_from_to(y_i, y - 1, p_i) {\n    //       assign_if_larger(right_area_end_point[p_i], x);\n    //     }\n    //   }\n    // }\n\n    // repeat_with_index(y_size, y_i) {\n\n    //   // included in some sheets\n    //   if (right_area_end_point[y_i] > x_i) {\n    //     area += 1;\n    //     is_area[x_i % 2][y_i] = true;\n    //   } else {\n    //     is_area[x_i % 2][y_i] = false;\n    //   }\n\n    //   // line check\n    //   if (type == 2) {\n    //     // left line exists\n    //     if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n    //     // bottom line exists\n    //     if (\n    //         (y_i == 0 && is_area[x_i % 2][y_i]) ||\n    //         (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n    //         )\n    //       lines += 1;\n    //   }\n    // }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\nvector<T> coner;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(cin >> n >> r, n | r){\n\tmemset(imos, 0, sizeof(imos));\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 10400;\n\tright_side = top = 1;\n\tconer.clear();\n\tfor(int i = 0;i < n;i++){\n\t    cin >> ax >> ay >> bx >> by;\n\t    left_side = min(left_side, ++ax);\n\t    right_side = max(right_side, ++bx);\n\t    bottom = min(bottom, ++ay);\n\t    top = max(top, ++by);\n\t}\n\tconer.push_back(T(P(INF, INF), 0));\n\tsort(coner.begin(), coner.end());\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(coner[p].first == P(i, j)){\n\t\t    imos[i % 3][j] += coner[p++].second;\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tcout << area << endl;\n\tif(r == 2)cout << round << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define at(x,y) (x*10000+y)\n#define pos_X(x) (x/10000)\n#define pos_Y(y) (y%10000)\nstruct rect {\n\tint x1,y1,x2,y2;\n};\n\nusing namespace std;\n\nint main(){\n\tint n,r;\n\twhile(cin >> n >> r,n||r){\n\t\tvector<int> xpos;\n\t\tvector<int> ypos;\n\t\tqueue<pair<int,int>> q;\n\t\tunordered_multimap<int,int> m;\n\t\tfor(int i=0;i<n;i++){\n\t\t\trect A;\n\t\t\tcin >> A.x1 >> A.y1 >> A.x2 >> A.y2;\n\t\t\t//m.insert(at(A.x1,A.y1),at(A.x2,A.y2));\n\t\t\tq.push(make_pair(at(A.x1,A.y1),at(A.x2,A.y2)));\n\t\t\txpos.emplace_back(A.x1);\n\t\t\txpos.emplace_back(A.x2);\n\t\t\typos.emplace_back(A.y1);\n\t\t\typos.emplace_back(A.y2);\n\t\t}\n\t\t\n\t\tsort(xpos.begin(),xpos.end());\n\t\tsort(ypos.begin(),ypos.end());\n\t\tunordered_map<int,int> X_next;\n\t\tunordered_map<int,int> Y_next;\n\t\tfor(int unsigned i = 0;i<xpos.size()-1;i++){\n\t\t\tX_next[xpos[i]] = xpos[i+1];\n\t\t}\n\t\tfor(int unsigned i = 0;i<ypos.size()-1;i++){\n\t\t\tY_next[ypos[i]] = ypos[i+1];\n\t\t}\n\t\tset<pair<pair<int,int>,pair<int,int>>> s;\n\t\twhile(!q.empty()){\n\t\t\tauto u = q.front();\n\t\t\tq.pop();\n\t\t\tint x1 = pos_X(u.first);\n\t\t\tint y1 = pos_Y(u.first);\n\t\t\tint x2 = pos_X(u.second);\n\t\t\tint y2 = pos_Y(u.second);\n\t\t\tif(X_next[x1] < x2 && Y_next[y1] < y2){\n\t\t\t\tq.push(make_pair(at(X_next[x1],y1),at(x2,Y_next[y1])));\n\t\t\t\tq.push(make_pair(at(x1,Y_next[y1]),at(X_next[x1],y2)));\n\t\t\t\tq.push(make_pair(at(X_next[x1],Y_next[y1]),at(x2,y2)));\n\t\t\t} else if(X_next[x1] < x2){\n\t\t\t\tq.push(make_pair(at(X_next[x1],y1),at(x2,Y_next[y1])));\n\t\t\t} else if(Y_next[y1] < y2){\n\t\t\t\tq.push(make_pair(at(x1,Y_next[y1]),at(X_next[x1],y2)));\n\t\t\t}\n\t\t\tif(x1 == x2 || y1 == y2) continue;\n\t\t\ts.insert(make_pair(make_pair(x1,y1),make_pair(X_next[x1],Y_next[y1])));\n\t\t}\n\t\tint sum = 0;\n\t\tfor(auto x:s){\n\t\t\t//cout << x.first.first << \" \" << x.first.second << \" \" << x.second.first << \" \" << x.second.second << endl;\n\t\t\tsum += (x.second.first - x.first.first)*(x.second.second - x.first.second);\n\t\t}\n\t\tcout << sum << endl;\n\t\tif(r == 2) cout << \"0\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ninline void Imos(vector<vector<int> > &plane){\n\tREP(y,0,plane[0].size()){\n\t\tREP(x,1,plane.size()){\n\t\t\tplane[x][y]+=plane[x-1][y];\n\t\t}\n\t}\n\tREP(x,0,plane.size()){\n\t\tfor(int y=plane[0].size()-2; y>=0; --y){\n\t\t\tplane[x][y]+=plane[x][y+1];\n\t\t}\n\t}\n}\n\ninline int CalcSize(vector<vector<int> > &plane){\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(plane[x][y]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(vector<vector<int> > &plane,vector<vector<bool> > &has_done,int x,int y,int W,int H){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[x][y]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[nx][ny]){\n\t\t\t\tif(plane[nx][ny]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[nx][ny]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t\t//cout << result << ' ' << p.F_ << ' ' << p.S_ << endl;\n\t}\n\treturn result;\n}\n\ninline int CalcLength(vector<vector<int> > &plane){\n\tvector<vector<bool> > has_done(plane.size(),vector<bool>(plane[0].size()));\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(!has_done[x][y]&&plane[x][y]>0){\n\t\t\t\tresult+=BFS(plane,has_done,x,y,plane.size(),plane[0].size());\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tint min_x,min_y,max_x,max_y;\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tX[j].push_back(x);\n\t\t\t\tY[j].push_back(y);\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > plane(max_x+4,vector<int>(max_y+4));\n\t\tREP(i,0,N){\n\t\t\tplane[X[0][i]+1][Y[1][i]+1]+=1;\n\t\t\tplane[X[1][i]+2][Y[0][i]]+=1;\n\t\t\tplane[X[0][i]+1][Y[0][i]]+=-1;\n\t\t\tplane[X[1][i]+2][Y[1][i]+1]+=-1;\n\t\t}\n\t\tImos(plane);\n\t\t/*\n\t\tfor(int y=plane[0].size()-1; y>=0; --y){\n\t\t\tREP(x,0,plane.size()){\n\t\t\t\tcout << plane[x][y] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << CalcSize(plane) << endl;\n\t\tif(R==2) cout << CalcLength(plane) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X1[10010], X2[10010], Y1[10010], Y2[10010];\nint n, r, p[3][10010];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> r; if (n == 0 && r == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\t\t}\n\t\tint cnt1 = 0, cnt2 = 0;\n\t\tfor (int i = 0; i < 10010; i++) {\n\t\t\tfor (int j = 0; j < 30030; j++)p[j / 10010][j % 10010] = 0;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (X1[k] <= (i + j) && (i + j) < X2[k]) {\n\t\t\t\t\t\tp[j + 1][Y1[k]]++; p[j + 1][Y2[k]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 1; k < 10010; k++)p[j][k] += p[j][k - 1];\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10010; j++) {\n\t\t\t\tif (p[1][j] >= 1)cnt1++;\n\t\t\t\tif (i == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\tif (p[1][j] == 0 && p[2][j] >= 1)cnt2++;\n\t\t\t\tif (p[1][j] >= 1 && p[2][j] == 0)cnt2++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10010; j++) {\n\t\t\t\tif (j == 0 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j == 10009 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j >= 1 && j <= 10008) {\n\t\t\t\t\tif (p[1][j] >= 1 && p[1][j + 1] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j] == 0 && p[1][j + 1] >= 1)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 1)cout << cnt1 << endl;\n\t\tif (r == 2)cout << cnt1 << endl << cnt2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nshort x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[5000][5000];\nvector<short> vx;\nvector<short> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\t//for(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]);\n\t\t\tvx.push_back(x2[i]);\n\t\t\tvy.push_back(y1[i]);\n\t\t\tvy.push_back(y2[i]);\n\t\t//}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nint n;\nshort min_x1, max_x2, min_y1, max_y2;\nshort x1, x2, y1, y2;\nmap<pair<short, short>, short> *variation;\nchar tiles[10002][10002];\n\nvoid variation_inc(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second + 1;\n    } else {\n        value = 1;\n    }\n\n    variation->erase(make_pair(x, y));\n\t\n    if (value != 0) {\n    \tvariation->insert(pair<pair<short, short>, short>(make_pair(x,y), value));\n    }\n\n    return ;\n}\n\nvoid variation_dec(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second - 1;\n    } else {\n        value = -1;\n    }\n\n    variation->erase(make_pair(x, y));\n\n    if (value != 0) {\n    \tvariation->insert(pair<pair<short, short>, short>(make_pair(x,y), value));\n    }\n\n    return ;\n}\n\nshort variation_return(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n    \tvalue = location->second;\n    } else {\n        value = 0;\n    }\n\n    return value;\n}\n\nvoid pre_process() {\n    short i;\n    short calc[2][10002];\n\t\n\tfor (i=0;i<2;i++) {\n        int j;\n        for (j=0;j<10002;j++) {\n            calc[i][j] = 0;\n        }\n\t}\n\n    for (i=min_y1-1;i<max_y2+1;i++) {\n        int j;\n        \n        for (j=min_x1-1;j<max_x2+1;j++) {\n            calc[1][j] = variation_return(j, i);\n\n            calc[1][j] += calc[1][j-1];\n            calc[1][j] += calc[0][j];\n        \tcalc[1][j] -= calc[0][j-1];\n        }\n\n        for (j=min_x1;j<max_x2+1;j++) {\n            tiles[i][j] = ((calc[0][j] > 0) ? 1 : 0);\n            calc[0][j] = calc[1][j];\n        }\n    }\n\n    return;\n}\n\nint surface() {\n    short i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2+1;i++) {\n        int j;\n        for (j=min_x1;j<max_x2+1;j++) {\n            if (tiles[i][j]) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint perimeter() {\n    short i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2+2;i++) {\n        short j;\n        for (j=min_x1;j<max_x2+2;j++) {\n            if (tiles[i][j] + tiles[i-1][j] == 1) {\n                sum++;\n            }\n\n            if (tiles[i][j] + tiles[i][j-1] == 1) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while (1) {\n        short i;\n        int r;\n\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r ==0) return 0;\n\n    \tvariation = new map<pair<short, short>, short>();\n\n        min_x1 = 10000;\n        min_y1 = 10000;\n        max_x2 = 0;\n        max_y2 = 0;\n        for (i=0;i<n;i++) {\n            scanf(\"%hd %hd %hd %hd\", &x1, &y1, &x2, &y2);\n            x1++;\n            x2++;\n            y1++;\n            y2++;\n            if (min_x1 > x1) min_x1 = x1;\n            if (max_x2 < x2) max_x2 = x2;\n            if (min_y1 > y1) min_y1 = y1;\n            if (max_y2 < y2) max_y2 = y2;\n        \tvariation_inc(x1, y1);\n        \tvariation_dec(x1, y2);\n        \tvariation_dec(x2, y1);\n        \tvariation_inc(x2, y2);\n        }\n\n        for (i=0;i<10002;i++) {\n            short j;\n            for (j=0;j<10002;j++) {\n                tiles[i][j] = 0;\n            }\n        }\n    \t\n        pre_process();\n\n        printf(\"%d\\n\", surface());\n\n        if (r == 2) {\n            printf(\"%d\\n\", perimeter());\n        }        \n    \t\n    \tdelete variation;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509>\n?????????============================================================\n?????¢???????????¢??????????????????????????????????????????.???????????????????????§????????????????????¨????????¢????????¨???????±???????????????°?????????????????????.\n?????????, ?????¢?????§?¨??????¢??¨??????????????¨???, ??????????????????????¬?????????¶ (1), (2) ????????????????????¨??????.\n(1) ???????????????????????¢??? 4 ????????? x, y ??§?¨??????¨??? 0 ??\\??? 10000 ??\\????????´??°??§??????,\n    ????????¢???????????? x ???, ????????? y ??????????????§??????.\n(2) ?????????????????°????????? 10000 ?????\\?????§??????.\n??\\???????????? ??? 1 ?????????????????¢????????° n ??¨??????????¨?????????¨?????´??° r ???????????§????????£?????????????????????.\n2 ????????\\??????????????????, ?????????????????????????????§?¨? (x1, y1) ??¨??????????????§?¨? (x2, y2) ?????§?¨???????\nx1, y1, x2, y2 ????????§????????§????????£??????????????????.\n\n???????????? r = 1 ?????¨??? 1 ???????????¢??????, r = 2 ?????¨??? 1 ???????????¢???, 2 ???????????¨???????????????????????????.\n??????????????´??????????????????????????\\???????????¨.\n\n=================================================================\n??\\???=============================================================\n??\\???????????°????????????????????????????????????n, r ?????¨?????? 0 ?????¨?????\\????????????????????????????????????????????°??? 10 ????¶?????????????\n================================================================\n??????=============================================================\n???????????????????????¨???, r = 1 ?????¨??? 1 ???????????¢??????, r = 2 ?????¨??? 1 ???????????¢???, 2 ???????????¨???????????????????????????.\n================================================================\n?§£??¬=============================================================\n\n================================================================\n*/\n\nclass CC {\npublic:\n\tll N;\n\tvector<ll> xs; // ????????¨:xs[x1 or x2????????????] := ????????§?¨?\n\n\tCC(ll N) :N(N) {}\n\t// x1, x2?????§?¨???§??????, ??§?¨???§???????????????????????????\n\tint compress(vector<ll>& x1, vector<ll>& x2, ll MIN_W = -1e10, ll MAX_W = 1e10) {\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\t/* ??´???????????£??????d????¶???????????????? */\n\t\t\tfor (int d = -1; d <= 1; d++) {\n\t\t\t\tll tx1 = x1[i], tx2 = x2[i];\n\t\t\t\tif (MIN_W <= tx1 && tx1 <= MAX_W) xs.push_back(tx1);\n\t\t\t\tif (MIN_W <= tx2 && tx2 <= MAX_W) xs.push_back(tx2);\n\t\t\t}\n\t\t}\n\n\t\tsort(xs.begin(), xs.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tx1[i] = find(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\t\tx2[i] = find(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t\t}\n\n\t\treturn (int)xs.size(); // xs.size????????§??§???6*N\n\t}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, r;\n\tvector<ll> x1, y1, x2, y2;\n\twhile (cin >> N >> r, N | r) {\n\t\tx1.clear(); y1.clear(); x2.clear(); y2.clear();\n\t\tx1.resize(N); y1.resize(N); x2.resize(N); y2.resize(N);\n\t\tfor (int i = 0; i < N;i++) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\t\tCC CCx(N), CCy(N);\n\t\tll W = CCx.compress(x1, x2);\n\t\tll H = CCy.compress(y1, y2);\n\n\t\t/* imos????????¨???????????§?¨??????¢????¨???????*/\n\t\tvector<vector<int>> imos(H + 2, vector<int>(W + 2, 0)); // ??¢????¨????\n\t\tvector<vector<int>> Sum(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\timos[y1[i]][x1[i]]++;\n\t\t\timos[y1[i]][x2[i]]--;\n\t\t\timos[y2[i]][x1[i]]--;\n\t\t\timos[y2[i]][x2[i]]++;\n\t\t}\n\t\tll ans = 0;\n\t\tll circuit = 0;\n\t\tfor (int y = 0; y < H;y++) {\n\t\t\tfor (int x = 0; x < W;x++) {\n\t\t\t\tSum[y + 1][x + 1] = Sum[y + 1][x] + Sum[y][x + 1] - Sum[y][x] + imos[y][x];\n\t\t\t\tif (Sum[y + 1][x + 1] > 0) {\n\t\t\t\t\tans += (CCy.xs[y + 1] - CCy.xs[y])*(CCx.xs[x + 1] - CCx.xs[x]);\n\t\t\t\t\tcircuit += (CCy.xs[y + 1] - CCy.xs[y]) + (CCx.xs[x + 1] - CCx.xs[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tif (r == 1) continue;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define INF 2000000000\n#define LLINF 4000000000000000000\n#define SIZE 10002\n\nshort mm[SIZE][SIZE];\nint mo[5] = {0,1,0,-1,0};\nvoid calc(int n,int r){\n    int x_1,x_2,y_1,y_2,minx=0,maxx=SIZE-1,miny=0,maxy=SIZE-1;\n    int ansV,ansL;\n    \n    memset(mm,0,sizeof(mm));\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d%d\",&x_1,&y_1,&x_2,&y_2);\n        \n        x_1++;\n        y_1++;\n        x_2++;\n        y_2++;\n        \n        mm[x_1][y_1]++;\n        mm[x_2][y_1]--;\n        mm[x_1][y_2]--;\n        mm[x_2][y_2]++;\n        \n        minx = min(minx,x_1);\n        miny = min(miny,y_1);\n        maxx = max(maxx,x_2);\n        maxy = max(maxy,y_2);\n    }\n    \n    for(int i=miny;i<=maxy;i++){\n        for(int j=minx+1;j<=maxx;j++){\n            mm[j][i]+=mm[j-1][i];\n        }\n    }\n    \n    for(int i=miny;i<=maxy;i++){\n        for(int j=minx+1;j<=maxx;j++){\n            mm[i][j]+=mm[i][j-1];\n        }\n    }\n    \n    for(int i=miny;i<maxy;i++){\n        for(int j=minx;j<maxx;j++){\n            if(mm[i][j]>0){\n                ansV++;\n                \n                for(int k=0;k<4;k++){\n                    if(mm[i+mo[k]][j+mo[k+1]]==0){\n                        ansL++;\n                    }\n                }\n                \n            }\n        }\n    }\n    \n    printf(\"%d\\n\",ansV);\n    \n    if(r==2)\n        printf(\"%d\\n\",ansL);\n    \n    return;\n}\n\nint main(){\n    int n,r;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&r);\n        if(n==0) break;\n        calc(n,r);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int a;\n    int b1, b2;\n    bool start;\n\n    Tag() : a(0), b1(0), b2(0), start(false) {}\n    Tag(int aa, int bb1, int bb2, bool s) : a(aa), b1(bb1), b2(bb2), start(s) {}\n};\n\nbool cmp(const Tag &t1, const Tag &t2) {\n    if(t1.a != t2.a) return t1.a < t2.a;\n    return !t1.start;\n}\n\nint main() {\n    while(true) {\n        int N, R;\n        cin >> N >> R;\n        if(!N && !R) break;\n\n        vector<Tag> xtag, ytag;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            xtag.push_back(Tag(x1, y1, y2, true));\n            xtag.push_back(Tag(x2, y1, y2, false));\n            ytag.push_back(Tag(y1, x1, x2, true));\n            ytag.push_back(Tag(y2, x1, x2, false));\n        }\n        sort(xtag.begin(), xtag.end(), cmp);\n        sort(ytag.begin(), ytag.end(), cmp);\n\n        int max_y = ytag.back().a;\n        int area = 0;\n        int len = 0;\n        for(int y = 0; y < max_y; ++y) {\n            int depth = 0;\n            int startx = 0;\n            int prevx = -1;\n            for(int i = 0; i < xtag.size(); ++i) {\n                if(xtag[i].b1 <= y && y < xtag[i].b2) {\n                    if(xtag[i].start) {\n                        if(depth == 0) {\n                            if(xtag[i].a != prevx) ++len;\n                            else --len;\n                            startx = xtag[i].a;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            area += xtag[i].a-startx;\n                            prevx = xtag[i].a;\n                            ++len;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << area << endl;\n        if(R == 1) continue;\n\n        int max_x = xtag.back().a;\n        for(int x = 0; x < max_x; ++x) {\n            int depth = 0;\n            int prevy = -1;\n            for(int i = 0; i < ytag.size(); ++i) {\n                if(ytag[i].b1 <= x && x < ytag[i].b2) {\n                    if(ytag[i].start) {\n                        if(depth == 0) {\n                            if(prevy != ytag[i].a) ++len;\n                            else --len;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            ++len;\n                            prevy = ytag[i].a;\n                        }\n                    }\n                }\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (beg != a.beg)return beg < a.beg;\n  return end < a.end;\n}\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n\n  rep(i,px)req[i]=0;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      bool iscontinue=false;\n      rep(k,req[j]){\n\tif (y1[i] <= IN[j][k].begin && IN[j][k].end <= y2[i]){\n\t  isin=true;\n\t  in[j][k].begin=y1[i];\n\t  in[j][k].end=y2[i];\n\t  break;\n\t}\n      }\n      if (isin)req[j]++;\n      j++;\n    }\n  }\n\n  rep(i,px)IN[i]=vector<st>(req[i]),req[i]=0;\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      bool iscontinue=false;\n      rep(k,req[j]){\n\tif (y1[i] <= IN[j][k].begin && IN[j][k].end <= y2[i]){\n\t  isin=true;\n\t  in[j][k].begin=y1[i];\n\t  in[j][k].end=y2[i];\n\t  break;\n\t}\n      }\n      if (!isin)IN[j][req[j]++]=(st){y1[i],y2[i]};\n      j++;\n    }\n  }\n\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      //cout << nowl <<\" \"<< nowh <<\" \" << l<<\" \" << h << endl;\n      if (nowl > h){\n\tlen+=2*width;\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << h << endl;\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    int sum = 0;\n    repeat_with_index(y_size, y_i) {\n      sum = x_i * y_i % 100;\n    }\n    // repeat_with_index(y_size, y_i) {\n    //   // update right_area_end_point\n    //   auto points = find_end_points(x_i, y_i);\n\n    //   // per point operation\n    //   for (auto&& point : points) {\n    //     int x = point.first, y = point.second;\n\n    //     repete_from_to(y_i, y - 1, p_i) {\n    //       assign_if_larger(right_area_end_point[p_i], x);\n    //     }\n    //   }\n    // }\n\n    // repeat_with_index(y_size, y_i) {\n\n    //   // included in some sheets\n    //   if (right_area_end_point[y_i] > x_i) {\n    //     area += 1;\n    //     is_area[x_i % 2][y_i] = true;\n    //   } else {\n    //     is_area[x_i % 2][y_i] = false;\n    //   }\n\n    //   // line check\n    //   if (type == 2) {\n    //     // left line exists\n    //     if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n    //     // bottom line exists\n    //     if (\n    //         (y_i == 0 && is_area[x_i % 2][y_i]) ||\n    //         (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n    //         )\n    //       lines += 1;\n    //   }\n    // }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint dx[4]={0,1,-1,0};\nint dy[4]={1,0,0,-1};\nshort coor[10003][10003];\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,r;\n\t\tcin >> n >> r;\n\t\tif(n==0&&r==0)break;\n\t\tmemset(coor,0,sizeof(coor));\n\t\tint minx=INF,miny=INF,maxx=-1,maxy=-1;\n\t\tint x1,y1,x2,y2;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tcoor[x1][y1]++;\n\t\t\tcoor[x2][y2]++;\n\t\t\tcoor[x1][y2]--;\n\t\t\tcoor[x2][y1]--;\n\t\t\tminx=min(x1,minx);\n\t\t\tmaxx=max(x2,maxx);\n\t\t\tminy=min(y1,miny);\n\t\t\tmaxy=max(y2,maxy);\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++)\n\t\t{\n\t\t\tfor(int j=miny;j<=maxy;j++)\n\t\t\t{\n\t\t\t\tif(j-1<0)continue;\n\t\t\t\tcoor[i][j]+=coor[i][j-1];\n\t\t\t}\n\t\t}\n\t\tfor(int j=miny;j<=maxy;j++)\n\t\t{\n\t\t\tfor(int i=minx;i<=maxx;i++)\n\t\t\t{\n\t\t\t\tif(i-1<0)continue;\n\t\t\t\tcoor[i][j]+=coor[i-1][j];\n\t\t\t}\n\t\t}\n\t\tint sq=0;\n\t\tint len=0;\n\t\tif(r==1)\n\t\t{\n\t\t\tfor(int i=minx;i<=maxx;i++)\n\t\t\t{\n\t\t\t\tfor(int j=miny;j<=maxy;j++)\n\t\t\t\t{\n\t\t\t\t\tif(coor[i][j])sq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << sq << endl;\n\t\t}\n\t\tif(r==2)\n\t\t{\n\t\t\tfor(int i=minx;i<=maxx;i++)\n\t\t\t{\n\t\t\t\tfor(int j=miny;j<=maxy;j++)\n\t\t\t\t{\n\t\t\t\t\tif(coor[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tsq++;\n\t\t\t\t\t\tint p=0;\n\t\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(i+dx[k]<0||j+dy[k]<0)p++;\n\t\t\t\t\t\t\telse if(!(coor[i+dx[k]][j+dy[k]]))p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen+=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << sq << ' ' << len << endl;\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tcout << coor[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef list<P>L;\ntypedef L::iterator I;\nint unite(L&l,I i,I j){\n\tint r=i->second>=j->first;\n\tif(r){\n\t\ti->second=max(i->second,j->second);\n\t\tl.erase(j);\n\t}\n\treturn r;\n}\nvoid add(L&l,P p){\n\tI i=lower_bound(l.begin(),l.end(),p);\n\ti=l.insert(i,p);\n\tI j;\n\tfor(;j=i,++j!=l.end()&&unite(l,i,j););\n\tfor(;i!=l.begin()&&(j=i,unite(l,--i,j)););\n}\nint main(){\n\tint n,r;\n\tfor(;cin>>n>>r,r;){\n\t\tL v[10000],h[10000];\n\t\tfor(;n--;){\n\t\t\tint x1,y1,x2,y2,x,y;\n\t\t\tcin>>x1>>y1>>x2>>y2;\n\t\t\t/*for(x=x1;x<x2;x++){\n\t\t\t\tadd(v[x],P(y1,y2));\n\t\t\t}*/\n\t\t\tfor(y=y1;y<y2;y++){\n\t\t\t\tadd(h[y],P(x1,x2));\n\t\t\t}\n\t\t}\n\t\tint s=0,c=0;\n\t\tfor(int y=0;y<10000;y++){\n\t\t\tfor(I i=h[y].begin();i!=h[y].end();++i)\n\t\t\t\ts+=i->second-i->first;\n\t\t\t//c+=h[y].size()+v[y].size();\n\t\t}\n\t\tcout<<s<<endl;\n\t\tif(r==2){\n\t\t\tcout<<c*2<<endl;\n\t\t}\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define FMAX 10002\n\nusing namespace std;\n\nshort pool[FMAX + 1][FMAX];\nshort (*field)[FMAX] = pool + 1;\nint main() {\n  short n, r;\n  short x1, y1, x2, y2;\n  while (cin >> n >> r, n || r) {\n    memset(field, 0, FMAX * FMAX * sizeof(short));\n    short min_x = FMAX, min_y = FMAX, max_x = 0, max_y = 0;\n    for (short i = 0; i < n; i++) {\n      cin >> x1 >> y1 >> x2 >> y2;\n      field[x1][y1] += 1;\n      field[x1][y2] += -1;\n      field[x2][y1] += -1;\n      field[x2][y2] += 1;\n      min_x = min(min_x, x1);\n      min_y = min(min_y, y1);\n      max_x = max(max_x, x2);\n      max_y = max(max_y, y2);\n    }\n    // vertical\n    for (short x = min_x; x <= max_x; x++) {\n      short sum = 0;\n      for (short y = min_y; y <= max_y; y++) {\n        field[x][y] = (sum += field[x][y]);\n      }\n    }\n    // horizontal\n    int area = 0, perimeter = 0;\n    for (short y = min_y; y <= max_y; y++) {\n      short sum = 0;\n      for (short x = min_x; x <= max_x; x++) {\n        short current = field[x][y] = (sum += field[x][y]);\n        if (current != 0) area++;\n        if (r == 2) {\n          perimeter += ((field[x - 1][y] == 0 ^ current == 0) + (field[x][y - 1] == 0 ^ current == 0));\n        }\n      }\n    }\n\n    cout << area << endl;\n    if (r == 2) cout << perimeter << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<list>\nusing namespace std;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\ntypedef pair<LL,LL>PLL;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define F first\n#define S second\n\nshort fld[10002][10002];\nshort dx[]={-1,0,1,0};\nshort dy[]={0,-1,0,1};\n\nint main(){\n    int n,r;\n    while(scanf(\"%d%d\",&n,&r),n||r){\n    memset(fld,0,sizeof(fld));\n\n    REP(i,n){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n        x1++;y1++;x2++;y2++;\n        fld[y1][x1]++;\n        fld[y1][x2]--;\n        fld[y2][x1]--;\n        fld[y2][x2]++;\n\n    }\n    FOR(i,1,10001){\n        FOR(j,1,10001){\n            fld[i][j]+=fld[i][j-1]+fld[i-1][j]-fld[i-1][j-1];\n        }\n    }\n    LL S=0,L=0;\n    FOR(i,1,10002){\n        FOR(j,1,10002){\n            if(fld[i][j])S++;\n            else continue;\n            REP(k,4){\n                int x=j+dx[k],y=i+dy[k];\n                if(x<1||x>10001||y<1||y>10001)L++;\n                else if(fld[y][x]==0)L++;\n            }\n        }\n    }\n\n    cout<<S<<endl;\n    if(r==2)cout<<L<<endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1);\n  assign_if_larger(y_size, y2 - y1);\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[{x1, y1}] = {{x2, y2}};\n  } else {\n    sheets[{x1, y1}].push_back({x2, y2});\n  }\n\n  // auto v = sheets.find({x1, y1});\n  // if (v == sheets.end()) {\n  //   cout << \"hello\";\n  //   sheets[{x1, y1}] = {{x2, y2}};\n  // }\n  // v->second.push_back({x2, y2});\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  return sheets[{x, y}];\n  // auto v = sheets.find({x, y});\n  // if (v == sheets.end()) {\n  //   return {};\n  // }\n\n  // return &(v->second);\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n\n    // update right_area_end_point\n    repeat_with_index(y_size, y_i) {\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n\n    }\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    // for (auto&& points : sheets) {\n    //   cout << \"A: \";\n    //   cout << points.first.first << \" \" << points.first.second << endl;\n    //   for (auto&& p : points.second) {\n    //     cout << \"B: \";\n    //     cout << p.first << \" \" << p.second << endl;\n    //   }\n    // }\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string.h>\n#include<stdio.h>\n#define max(x,y) ((x>y)?x:y)\n#define min(x,y) ((x<y)?x:y)\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tg[x1][y1]+=1;\n\t\t\tg[x2][y1]-=1;\n\t\t\tg[x1][y2]-=1;\n\t\t\tg[x2][y2]+=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass inbox{\n   int x1,x2,y1,y2;\npublic:\n   void set(int a,int b,int c,int d){\n       x1 = a;\n       y1 = b;\n       x2 = c;\n       y2 = d;\n   }\n   inbox(){};\n   int g(int x,int y){\n       return ((x1<=x&&x<x2&&y1<=y&&y<y2)?1:0);\n   }\n   int h(int x,int y){\n       return (((x==x2||x==x1)&&(y1<=y&&y<y2))||((y==y2||y==y1)&&(x1<=x&&x<x2)))?1:0;\n   }\n};\n\nint main(){\n   while(1){\n       int n,m;\n       int x0,x1,y0,y1;\n       cin>>n>>m;\n       if(n == 0)break;\n       vector<inbox> vec(n);\n       int max_x = 0,max_y = 0,min_x = 10000,min_y = 10000;\n       for(int i = 0;i < n;i++){\n           cin>>x0>>y0>>x1>>y1;\n           max_x = max(max_x,x1);\n           max_y = max(max_y,y1);\n           min_x = min(min_x,x0);\n           min_y = min(min_y,y0);\n           vec[i].set(x0,y0,x1,y1);\n       }\n       int area = 0,length=0;\n       //cout<<\"vec.size = \"<<vec.size()<<endl;\n       for(int x = min_x;x <= max_x;x++){\n           for(int y = min_y;y < max_y;y++){\n               for(int i = 0;i < n;i++){\n                   if(vec[i].g(x,y) == 1){\n                       area++;\n                       break;\n                   }\n               }\n           }\n       }\n       cout<<area<<endl;\n       if(m==2){\n           for(int x = min_x;x <= max_x;x++){\n               for(int y = min_y;y < max_y;y++){\n                   for(int i = 0;i < n;i++){\n                       if(vec[i].h(x,y) == 1){\n                           length++;\n                           break;\n                       }\n                   }\n               }\n           }\n           cout<<length<<endl;\n       }\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nvector<T> vec;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(imos,0,sizeof(imos));\n\t\tarea=0;len=0;\n\t\tle=down=INF;\n\t\tri=up=1;\n\t\tm.clear();\n\t\tcin >> n >> r;\n\t\tif(n==0&&r==0)break;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta++;b++;c++;d++;\n\t\t\tri=max(ri,c);\n\t\t\tle=min(le,a);\n\t\t\tup=max(up,d);\n\t\t\tdown=min(down,b);\n\t\t\tm[P(a,b)]++;\n\t\t\tm[P(a,d)]--;\n\t\t\tm[P(c,b)]--;\n\t\t\tm[P(c,d)]++;\n\t\t}\n\t\tvec.pb(T(P(INF,INF),INF));\n\t\tSORT(vec);\n\t\tint index=0;\n\t\tfor(int i=le;i<=ri+1;i++)\n\t\t{\n\t\t\tfor(int j=down;j<=up+1;j++)\n\t\t\t{\n\t\t\t\timos[i%2][j]=imos[i%2][j-1];\n\t\t\t\tit=m.find(P(i,j));\n\t\t\t\tif(it!=m.end())imos[i%2][j]+=(*it).sec;\n\t\t\t}\n\t\t\tfor(int j=down;j<=up+1;j++)\n\t\t\t{\n\t\t\t\timos[i%2][j]+=imos[(i-1)%2][j];\n\t\t\t\tif(imos[i%2][j]>0)area++;\n\t\t\t\tif(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n\t\t\t\tif(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n\t\t\t\tcout << imos[i%2][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << area << endl;\n\t\tif(r==2)cout << len << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <tuple>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nusing namespace std;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<int, vector<tuple<int, int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n\n  auto t = make_tuple(y1, x2, y2);\n  if (sheets.count(x1) == 0) {\n    sheets[x1] = {t};\n  } else {\n    sheets[x1].push_back(t);\n  }\n}\n\nvector<tuple<int, int, int>>& find_end_points(int x, int y) {\n  return sheets[x];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_max + 1];\n  loop(y_max + 1, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_max + 1];\n  is_area[1] = new bool[y_max + 1];\n  loop(y_max + 1, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_max + 1, x_i) {\n    // update right_area_end_point\n    auto& points = find_end_points(x_i, 0);\n\n    // per point operation\n    for (auto&& point : points) {\n      int y_i = get<0>(point), x = get<1>(point), y = get<2>(point);\n\n      loop_from_to(y_i, y - 1, p_i) {\n        assign_if_larger(right_area_end_point[p_i], x);\n      }\n    }\n\n    loop(y_max + 1, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\n    vector<pair<P,P> > in;\n    vector<P> v[10001];\n    \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    in.clear();\n    for(int i=0;i<10001;i++)v[i].clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n      \n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b, b=B, e=E, L+=2;\n      }\n      S+=e-b, L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B, e=E, L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nmain(){\n  printf(\" \")\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r,n|r){\n    vector<P>vx[10001],vy[10001];\n    vector<pair<P,P> >in;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1000000000\n#define fi first\n#define sec second\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        scanf(\"%d %d\",&n,&r);\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#define MAX (10000+2)\nusing namespace std;\nint main(){\n    int n, r, x1, x2, y1, y2;\n    while(true){\n        scanf(\"%d %d\", &n, &r);\n        if(n==0 && r==0) break;\n        int plane[2][MAX]={0};\n        vector<vector<pair<int, int> > > sheets(MAX);\n        for(int i=0; i<n; i++){\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            sheets[x1+1].push_back(make_pair(y1+1,+1));\n            sheets[x1+1].push_back(make_pair(y2+1,-1));\n            sheets[x2+1].push_back(make_pair(y1+1,-1));\n            sheets[x2+1].push_back(make_pair(y2+1,+1));\n        }\n        if(r==2){\n            int area=0, length=0;\n            for(int x=1; x<MAX; x++){\n                for(int i=0; i<MAX; i++){\n                    plane[x%2][i]=0;\n                }\n                for(vector<pair<int, int> >::iterator sheet=sheets[x].begin(); sheet!=sheets[x].end(); sheet++){\n                    plane[x%2][(*sheet).first]+=(*sheet).second;\n                }\n                for(int y=1; y<MAX; y++){\n                    plane[x%2][y]+=plane[x%2][y-1];\n                }\n                for(int y=1; y<MAX; y++){\n                    plane[x%2][y]+=plane[(x+1)%2][y];\n                    area+=plane[x%2][y]>0 ? 1 : 0;\n                    length+=(plane[x%2][y-1]>0)!=(plane[x%2][y]>0) ? 1 : 0;\n                    length+=(plane[x%2][y]>0)!=(plane[(x+1)%2][y]>0) ? 1 : 0;\n                }\n            }\n            printf(\"%d\\n%d\\n\", area, length);\n        }else{\n            int area=0;\n            for(int x=1; x<MAX; x++){\n                for(int i=0; i<MAX; i++){\n                    plane[x%2][i]=0;\n                }\n                for(vector<pair<int, int> >::iterator sheet=sheets[x].begin(); sheet!=sheets[x].end(); sheet++){\n                    plane[x%2][(*sheet).first]+=(*sheet).second;\n                }\n                for(int y=1; y<MAX; y++){\n                    plane[x%2][y]+=plane[x%2][y-1];\n                }\n                for(int y=1; y<MAX; y++){\n                    plane[x%2][y]+=plane[(x+1)%2][y];\n                    area+=plane[x%2][y]>0 ? 1 : 0;\n                }\n            }\n            printf(\"%d\\n\", area);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint  isexist[N]={0};\nint testcase=0;\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\ncontinue;\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Tag {\n    int a;\n    int b1, b2;\n    bool start;\n\n    Tag() : a(0), b1(0), b2(0), start(false) {}\n    Tag(int aa, int bb1, int bb2, bool s) : a(aa), b1(bb1), b2(bb2), start(s) {}\n};\n\nbool cmp(const Tag &t1, const Tag &t2) {\n    if(t1.a != t2.a) return t1.a < t2.a;\n    return !t1.start;\n}\n\nint main() {\n    while(true) {\n        int N, R;\n        cin >> N >> R;\n        if(!N && !R) break;\n\n        vector<Tag> xtag, ytag;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            xtag.push_back(Tag(x1, y1, y2, true));\n            xtag.push_back(Tag(x2, y1, y2, false));\n            ytag.push_back(Tag(y1, x1, x2, true));\n            ytag.push_back(Tag(y2, x1, x2, false));\n        }\n        sort(xtag.begin(), xtag.end(), cmp);\n        stable_sort(ytag.begin(), ytag.end(), cmp);\n\n        int max_y = ytag[ytag.size()-1].a;\n        int area = 0;\n        int len = 0;\n        int prev_y = 0;\n        int prev_area = 0;\n        int prev_len = 0;\n        for(int j = 0; j < ytag.size(); ++j) {\n            area += prev_area * (ytag[j].a-prev_y);\n            len += prev_len * (ytag[j].a-prev_y);\n            prev_y = ytag[j].a;\n            prev_area = 0;\n            prev_len = 0;\n\n            int depth = 0;\n            int startx = 0;\n            int prevx = -1;\n            for(int i = 0; i < xtag.size(); ++i) {\n                if(xtag[i].b1 <= prev_y && prev_y < xtag[i].b2) {\n                    if(xtag[i].start) {\n                        if(depth == 0) {\n                            if(xtag[i].a != prevx) ++prev_len;\n                            else --prev_len;\n                            startx = xtag[i].a;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            prev_area += xtag[i].a-startx;\n                            prevx = xtag[i].a;\n                            ++prev_len;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << area << endl;\n        if(R == 1) continue;\n\n        int prev_x = 0;\n        for(int j = 0; j < xtag.size(); ++j) {\n            len += prev_len * (xtag[j].a-prev_x);\n            prev_x = xtag[j].a;\n            prev_len = 0;\n\n            int depth = 0;\n            int prevy = -1;\n            for(int i = 0; i < ytag.size(); ++i) {\n                if(ytag[i].b1 <= prev_x && prev_x < ytag[i].b2) {\n                    if(ytag[i].start) {\n                        if(depth == 0) {\n                            if(ytag[i].a != prevy) ++prev_len;\n                            else --prev_len;\n                        }\n                        ++depth;\n                    }\n                    else {\n                        if(--depth == 0) {\n                            ++prev_len;\n                        }\n                    }\n                }\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\n\nint mp[10003][10003];\nint line[3][2];\n\nint main(){\n\tint n,r;\n\twhile(cin>>n>>r){\n\t\tif(n==0&&r==0)break;\n\t\tCLR(mp);\n\t\tint x[2],y[2];\n\t\tlong suml=0,sumd=0;\n\t\tint xmax=0,ymax=0;\n\t\tREP(i,n){\n\t\t\tcin>>x[0]>>y[0]>>x[1]>>y[1];//左下,右上\n\t\t\tx[0]++,y[0]++,x[1]++,y[1]++;\n\t\t\txmax=max(x[1],xmax);ymax=max(y[1],ymax);\n\t\t\tFOR(j,y[0],y[1]){\n\t\t\t\tmp[j][x[0]]++;//横方向に面積いもす法\n\t\t\t\tmp[j][x[1]]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong temp;\n\t\t\n\t\tFOR(i,1,ymax+1){\n\t\t\ttemp=0;\n\t\t\tline[0][0]=0;\n\t\t\tline[1][0]=0;\n\t\t\tline[2][0]=0;\n\t\t\tFOR(j,1,xmax+1){\n\t\t\t\tif(temp>0){\n\t\t\t\t\tsumd++;\n\t\t\t\t}\n\t\t\t\ttemp+=mp[i][j];\n\t\t\t\tline[0][1]=line[0][0]+mp[i-1][j];\n\t\t\t\tline[1][1]=line[1][0]+mp[i][j];\n\t\t\t\tline[2][1]=line[2][0]+mp[i+1][j];\n\t\t\t\tif(line[1][0]==0&&line[1][1]>0||line[1][1]==0&&line[1][0]>0){\n\t\t\t\t\tsuml++;\n\t\t\t\t}\n\t\t\t\tif(line[0][1]==0&&line[1][1]>0)suml++;\n\t\t\t\tif(line[2][1]==0&&line[1][1]>0)suml++;\n\t\t\t\tREP(k,3)line[k][0]=line[k][1];\n\t\t\t}\n\t\t}\n\t\tcout<<sumd<<endl;\n\t\tif(r==2)cout<<suml<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    vector<P>v;\n    for(int i=0;i+1<10001;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n\tif(i<in[j].S.F)break;\n      }\n     \n      if(v.size()==0)continue;\n      sort(v.begin(),v.end());\n      int b=v[0].F,e=v[0].S;\n      for(int j=1;j<v.size();j++){\n\tint B=v[j].F,E=v[j].S;\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b, b=B, e=E, L+=2;\n      }\n      S+=e-b, L+=2;\n    }\n    cout << S << endl;\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end(),cmp_x);\n\n      for(int i=0;i+1<10001;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\n\t  if(i<in[j].F.F)break;\n\t}\n\tif(v.size()==0)continue;\n\tsort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\t\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B, e=E, L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (height != a.height)return height < a.height;\n  return out > a.out;\n}\n\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(x1,minx);\n\t\t\tminy=min(y1,miny);\n\t\t\tmaxx=max(x2,maxx);\n\t\t\tmaxy=max(y2,maxy);\n\t\t\tg[x1][y1]++;\n\t\t\tg[x2][y1]--;\n\t\t\tg[x1][y2]--;\n\t\t\tg[x2][y2]++;\n\t\t}\n\t\t/*for(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",ans);\n\t\t/*if(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}*/\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\t//vector<vector<int>>data;\n\tvector<pair<pair<int, int>, pair<int, int>>>input;\n\tmap<int, int>x_x, y_y;\n\tunordered_map<int, unordered_map<int, int>>datax;\n\tvector<int>x_x_x, y_y_y;\n\twhile( cin >> N >> R, N || R ) {\n\t\tint xmax = 0, ymax = 0;\n\t\tset<int>xs, ys;\n\t\tinput.resize( N );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tinput[i] = make_pair( make_pair( x1, y1 ), make_pair( x2, y2 ) );\n\t\t\txs.insert( x1 );\n\t\t\tys.insert( y1 );\n\t\t\txs.insert( x2 );\n\t\t\tys.insert( y2 );\n\t\t}\n\t\tx_x.clear();\n\t\ty_y.clear();\n\n\t\tx_x_x.clear();\n\t\ty_y_y.clear();\n\t\tfor( auto xx : xs ) {\n\t\t\tx_x[xx] = x_x_x.size();\n\t\t\tx_x_x.emplace_back( xx );\n\t\t}\n\t\tfor( auto yy : ys ) {\n\t\t\ty_y[yy] = y_y_y.size();\n\t\t\ty_y_y.emplace_back( yy );\n\t\t}\n\t\txmax = xs.size() + 1;\n\t\tymax = ys.size() + 1;\n\t\t//data = vector<vector<int>>( xmax + 1, vector<int>( ymax + 1 ) );\n\t\tdatax.clear();\n\t\tfor( size_t i = 0; i < input.size(); i++ ) {\n\t\t\tdatax[x_x[input[i].first.first]][y_y[input[i].first.second]]++;\n\t\t\tdatax[x_x[input[i].second.first]][y_y[input[i].second.second]]++;\n\t\t\tdatax[x_x[input[i].second.first]][y_y[input[i].first.second]]--;\n\t\t\tdatax[x_x[input[i].first.first]][y_y[input[i].second.second]]--;\n\t\t}\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdatax[i + 1][j] += datax[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tdatax[i][j + 1] += datax[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( datax[i][j] ) {\n\t\t\t\t\tans += (x_x_x[i + 1] - x_x_x[i])*(y_y_y[j + 1] - y_y_y[j]);\n\t\t\t\t\t//ans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tif( datax[i][0] != 0 ) {\n\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tif( datax[0][i] != 0 ) {\n\t\t\t\t\tans += y_y_y[i + 1] - y_y_y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( datax[i][j] * datax[i][j + 1] == 0 && datax[i][j] != datax[i][j + 1] ) {\n\t\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t\t}\n\t\t\t\t\tif( datax[i][j] * datax[i + 1][j] == 0 && datax[i][j] != datax[i + 1][j] ) {\n\t\t\t\t\t\tans += y_y_y[j + 1] - y_y_y[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nstatic vector<pair<P,P> >in;\n\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r,n|r){\n    vector<P>vx[10001],vy[10001];\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <set>\nusing namespace std;\n\ntypedef pair< pair<int,int> , pair<int,int> > DATA;\nDATA in[10000];\n\nbool cmp1( const DATA &a , const DATA &b ){\n\treturn a.first < b.first;\n}\nbool cmp2( const DATA &a , const DATA &b ){\n\treturn a.second < b.second;\n}\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q && n){\n\t\tvector< pair<int,int> > tr[10001] , tc[10001];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1 , y1 , x2 , y2;\n\t\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\t\tin[i].first.first   = x1;\n\t\t\tin[i].first.second  = x2;\n\t\t\tin[i].second.first  = y1;\n\t\t\tin[i].second.second = y2;\n\t\t}\n\t\tsort(in,in+n,cmp1);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1 , y1 , x2 , y2;\n\t\t\tx1 = in[i].first.first;\n\t\t\tx2 = in[i].first.second;\n\t\t\ty1 = in[i].second.first;\n\t\t\ty2 = in[i].second.second;\n\t\t\tfor(int i = y1 ; i < y2 ; i++) tr[i].push_back(make_pair(x1,x2));\n\t\t}\n\t\tsort(in,in+n,cmp2);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1 , y1 , x2 , y2;\n\t\t\tx1 = in[i].first.first;\n\t\t\tx2 = in[i].first.second;\n\t\t\ty1 = in[i].second.first;\n\t\t\ty2 = in[i].second.second;\n\t\t\tif(q==2) for(int i = x1 ; i < x2 ; i++) tc[i].push_back(make_pair(y1,y2));\n\t\t}\n\t\tint area = 0 , perimeter = 0;\n\t\t// merge\n\t\tfor(int i = 0 ; i < 10001 ; i++){\n\t\t\tif(tr[i].size() == 0) continue;\n\t\t\t//sort(tr[i].begin(),tr[i].end());\n\t\t\t\n\t\t\tint s = tr[i][0].first , e = tr[i][0].second;\n\t\t\tfor(int j = 1 ; j < tr[i].size() ; j++){\n\t\t\t\tint S = tr[i][j].first , E = tr[i][j].second;\n\t\t\t\tif(S <= e){\n\t\t\t\t\te = max(E,e);\n\t\t\t\t}else{\n\t\t\t\t\tarea += e-s;\n\t\t\t\t\tperimeter += 2;\n\t\t\t\t\ts = S;\n\t\t\t\t\te = E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperimeter += 2;\n\t\t\tarea += e-s;\n\t\t}\n\t\t\n\t\tif(q == 2){\n\t\t\tfor(int i = 0 ; i < 10001 ; i++){\n\t\t\t\tif(tc[i].size() == 0) continue;\n\t\t\t\t//sort(tc[i].begin(),tc[i].end());\n\t\t\t\tint s = tc[i][0].first , e = tc[i][0].second;\n\t\t\t\tfor(int j = 1 ; j < tc[i].size() ; j++){\n\t\t\t\t\tint S = tc[i][j].first , E = tc[i][j].second;\n\t\t\t\t\tif(S <= e){\n\t\t\t\t\t\te = max(E,e);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//cerr << s << \"|\" << e << endl;\n\t\t\t\t\t\tperimeter += 2;\n\t\t\t\t\t\t//c[i].push_back( make_pair(s,e) );\n\t\t\t\t\t\ts = S;\n\t\t\t\t\t\te = E;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cerr << s << \"|\" << e << endl;\n\t\t\t\tperimeter += 2;\n\t\t\t\t//c[i].push_back( make_pair(s,e) );\n\t\t\t}\n\t\t}\n\t\tif(q == 1){\n\t\t\tcout << area << endl;\n\t\t}else{\n\t\t\tcout << area << endl;\n\t\t\tcout << perimeter << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[10002];\nvector<P> xx[10002];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 11111; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tx[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n      //x[i].clear();\n      /*\n      cout << \"x = \" << i << endl;\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tcout << \"( \" << xx[i][j].F << \" , \" << xx[i][j].S << \" )\" << endl;\n      }\n      cout << endl;\n      //*/\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.first < q.first;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.second < q.second;\n}\n\nvector<pair<P,P> > in;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)return 0;\n\n    in.clear();\n    int mnx=INF,mny=INF,mxx=0,mxy=0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n      mnx=min(mnx,x1);\n      mny=min(mny,y1);\n      mxx=max(mxx,x2);\n      mxy=max(mxy,y2);\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    //vector<P>v;\n    for(int i=mny;i<mxy;i++){\n      //v.clear();\n      priority_queue<P,vector<P> , greater<P> > v;\n      for(int j=0;j<n;j++){\n\tif(in[j].second.second>=i+1 && i>=in[j].second.first){\n\t  //v.push_back(make_pair(in[j].first.first,in[j].first.second));\n\t  v.push(make_pair(in[j].first.first,in[j].first.second));\n\t}\n\tif(i<in[j].second.first)break;\n      }\n     \n      if(v.size()!=0){\n\t//sort(v.begin(),v.end());\n\tint b=v.top().first,e=v.top().second;\n\twhile(!v.empty()){\n\t  v.pop();\n\t  int B=v.top().first,E=v.top().second;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end(),cmp_x);\n\n      for(int i=mnx;i<mxx;i++){\n\tpriority_queue<P,vector<P> , greater<P> > v;\n\t//v.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].first.second>=i+1 && i>=in[j].first.first){\n\t    //v.push_back(make_pair(in[j].second.first,in[j].second.second));\n\t    v.push(make_pair(in[j].second.first,in[j].second.second));\n\t  }\n\t  if(i<in[j].first.first)break;\n\t}\n\tif(v.size()!=0){\n\t  //\t  sort(v.begin(),v.end());\n\t  int b=v.top().first,e=v.top().second;\n\t  \n\t  while(!v.empty()){\n\t    v.pop();\n\t    int B=v.top().first,E=v.top().second;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Sheets.cpp\n//  2013/01/20.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint field[10003][10003];\nint mx=1<<30, my=1<<30, Mx=0, My=0;\n\nint S()\n{\n\tint s = 0;\n\t\n\tfor(int x = mx; x <= Mx; x++) for(int y = my; y <= My; y++) s += field[x][y] != 0;\n\t\n\treturn s;\n}\n\nint L()\n{\n\tint l = 0;\n\t\n\tfor(int x = mx; x <= Mx; x++) for(int y = my; y <= My; y++) if(field[x][y])\n\t{\n\t\tl += !field[x+1][y] + !field[x][y+1] + !field[x-1][y] + !field[x][y-1];\n\t}\n\t\n\treturn l;\n}\n\nint main()\n{\n    for(int N, R; cin >> N >> R && N; )\n\t{\n\t\tmemset(field, 0, sizeof field);\n\t\t\n\t\tmx=1<<30, my=1<<30, Mx=0, My=0;\n\t\t\n\t\trep(i, N)\n\t\t{\n\t\t\tint x1, y1, x2, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\n\t\t\tfield[x1+1][y1+1]++; field[x2+1][y1+1]--;\n\t\t\tfield[x1+1][y2+1]--; field[x2+1][y2+1]++;\n\t\t\t\n\t\t\tchmin(mx, x1+1); chmin(my, y1+1);\n\t\t\tchmax(Mx, x2+1); chmax(My, y2+1);\n\t\t}\n\t\t\n\t\tfor(int x = mx; x <= Mx; x++) for(int y = my; y <= My; y++) field[x][y+1] += field[x][y];\n\t\t\n\t\tfor(int y = my; y <= My; y++) for(int x = mx; x <= Mx; x++) field[x+1][y] += field[x][y];\n\t\t\n\t\tcout << S() << endl;\n\t\tif(R == 2) cout << L() << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint fie[4000][4000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<vector>\n#import<algorithm>\nusing namespace std;typedef pair<int,int>P;typedef vector<P>L;typedef L::iterator I;int U(L&l,I i,I j){int r=i->second>=j->first;if(r){i->second=max(i->second,j->second);l.erase(j);}return r;}void A(L&l,P p){I i=lower_bound(l.begin(),l.end(),p);i=l.insert(i,p);I j;for(;j=i,++j!=l.end()&&U(l,i,j););for(;i!=l.begin()&&(j=i,U(l,--i,j)););}main(){int n,r;for(;cin>>n>>r,r;){L v[10000],h[10000];for(;n--;){int x1,y1,x2,y2,x,y;cin>>x1>>y1>>x2>>y2;for(x=x1;x<x2;x++){A(v[x],P(y1,y2));}for(y=y1;y<y2;y++){A(h[y],P(x1,x2));}}int s=0,c=0;for(int y=0;y<10000;y++){for(I i=h[y].begin();i!=h[y].end();++i)s+=i->second-i->first;c+=h[y].size()+v[y].size();}cout<<s<<endl;if(r==2){cout<<c*2<<endl;}}{int n;for(n=2e6;n--;)getchar();}}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nshort plc[10002][10002];\nint max(int a,int b){return a>b?a:b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint main(){\n\tint n,t;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&t);\n\tif(n==0)return 0;\n\tmemset(plc,0,sizeof(plc));\n\tint mx=0,my=0;\n\tfor(i=0;i<n;i++){\n\t\tint x1,y1,x2,y2;\n\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\tx1++;x2++;y1++;y2++;\n\t\tmx=max(mx,x2);\n\t\tmy=max(my,y2);\n\t\tplc[x1][y1]++;\n\t\tplc[x1][y2]--;\n\t\tplc[x2][y1]--;\n\t\tplc[x2][y2]++;\n\t}\n\tfor(i=1;i<=mx;i++){\n\t\tfor(j=2;j<=my;j++){\n\t\t\tplc[i][j]+=plc[i][j-1];\n\t\t}\n\t}\n\tfor(i=1;i<=my;i++){\n\t\tfor(j=2;j<=mx;j++){\n\t\t\tplc[j][i]+=plc[j-1][i];\n\t\t}\n\t}\n\tint ans1=0,ans2=0;\n\tfor(i=1;i<=mx;i++){\n\t\tfor(j=1;j<=my;j++){\n\t\t\tif(plc[i][j]>0){\n\t\t\t\tans1++;\n\t\t\t\tif(t==2){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tint nx=i+dx[k];\n\t\t\t\t\t\tint ny=j+dy[k];\n\t\t\t\t\t\tif(nx>=0&&nx<=mx&&ny>=0&&ny<=my&&plc[nx][ny]==0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans1);\n\tif(t==2)printf(\"%d\\n\",ans2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  vector<int>v[10002];\n\n  while(cin >> n >> r,n|r){\n    for(int i=0;i<10002;i++)v[i].clear();\n\n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      for(int j=x1;j<x2;j++){\n        for(int k=y1;k<y2;k++){\n\t  if(find(v[j].begin(),v[j].end(),k)==v[j].end()){\n\t    v[j].push_back(k);\n\t  }\n\t}\n      }\n    }\n    \n    int S=0;\n    for(int i=0;i<10001;i++)S+=v[i].size();\n\n    cout << S << endl;\n    if(r==2){\n      for(int i=0;i<10001;i++)sort(v[i].begin(),v[i].end());\n      int L=v[0].size();\n\n      for(int i=0;i<10001;i++){\n\tif(v[i].size()>0)L+=2;\n        for(int j=0;j<v[i].size();j++){\n\t  if(j<v[i].size()-1 && v[i][j+1]!=v[i][j]+1)L+=2;\n          if(i>0 && !binary_search(v[i-1].begin(),v[i-1].end(),v[i][j]))L++;\n\t  if(!binary_search(v[i+1].begin(),v[i+1].end(),v[i][j]))L++;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <set>\nusing namespace std;\n\ntypedef pair< pair<int,int> , pair<int,int> > DATA;\nDATA in[10000];\n\nbool cmp1( const DATA &a , const DATA &b ){\n\treturn a.first < b.first;\n}\nbool cmp2( const DATA &a , const DATA &b ){\n\treturn a.second < b.second;\n}\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q && n){\n\t\tvector< pair<int,int> > tr[10001] , tc[10001];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1 , y1 , x2 , y2;\n\t\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\t\tin[i].first.first   = x1;\n\t\t\tin[i].first.second  = x2;\n\t\t\tin[i].second.first  = y1;\n\t\t\tin[i].second.second = y2;\n\t\t}\n\t\tsort(in,in+n,cmp1);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1 , y1 , x2 , y2;\n\t\t\tx1 = in[i].first.first;\n\t\t\tx2 = in[i].first.second;\n\t\t\ty1 = in[i].second.first;\n\t\t\ty2 = in[i].second.second;\n\t\t\tfor(int i = y1 ; i < y2 ; i++) tr[i].push_back(make_pair(x1,x2));\n\t\t}\n\t\tif(q == 2){\n\t\t\tsort(in,in+n,cmp2);\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tint x1 , y1 , x2 , y2;\n\t\t\t\tx1 = in[i].first.first;\n\t\t\t\tx2 = in[i].first.second;\n\t\t\t\ty1 = in[i].second.first;\n\t\t\t\ty2 = in[i].second.second;\n\t\t\t\tif(q==2) for(int i = x1 ; i < x2 ; i++) tc[i].push_back(make_pair(y1,y2));\n\t\t\t}\n\t\t}\n\t\tint area = 0 , perimeter = 0;\n\t\t// merge\n\t\tfor(int i = 0 ; i < 10001 ; i++){\n\t\t\tif(tr[i].size() == 0) continue;\n\t\n\t\t\tint s = tr[i][0].first , e = tr[i][0].second;\n\t\t\tfor(int j = 1 ; j < tr[i].size() ; j++){\n\t\t\t\tint S = tr[i][j].first , E = tr[i][j].second;\n\t\t\t\tif(S <= e){\n\t\t\t\t\te = max(E,e);\n\t\t\t\t}else{\n\t\t\t\t\tarea += e-s;\n\t\t\t\t\tperimeter += 2;\n\t\t\t\t\ts = S;\n\t\t\t\t\te = E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperimeter += 2;\n\t\t\tarea += e-s;\n\t\t}\n\t\t\n\t\tif(q == 2){\n\t\t\tfor(int i = 0 ; i < 10001 ; i++){\n\t\t\t\tif(tc[i].size() == 0) continue;\n\t\t\t\t\n\t\t\t\tint s = tc[i][0].first , e = tc[i][0].second;\n\t\t\t\tfor(int j = 1 ; j < tc[i].size() ; j++){\n\t\t\t\t\tint S = tc[i][j].first , E = tc[i][j].second;\n\t\t\t\t\tif(S <= e){\n\t\t\t\t\t\te = max(E,e);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tperimeter += 2;\n\t\t\t\t\t\ts = S;\n\t\t\t\t\t\te = E;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tperimeter += 2;\n\t\t\t}\n\t\t}\n\t\tif(q == 1){\n\t\t\tcout << area << endl;\n\t\t}else{\n\t\t\tcout << area << endl;\n\t\t\tcout << perimeter << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint main()\n{\nint p[10010][10010]={0};\nwhile(1)\n{\nint n;\ncin >> n;\nbreak;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\nint n,r;\nwhile(1)\n{\ncin >> n >> r;\nint m[10010][10010];\nmemset(m,0,sizeof(m));\nint j=0;\nfor(int i=0;i<n;i++)\n{\nint a,b,c,d;\ncin >> a >> b >> c>>d;\nm[i][j];\nj++;\n}\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint n, q, x1[10000], y1[10000], x2[10000], y2[10000], imos[10001];\n\nint main()\n{\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &q);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x1[i]);\n        scanf(\"%d\", &y1[i]);\n        scanf(\"%d\", &x2[i]);\n        scanf(\"%d\", &y2[i]);\n    }\n    \n    int ret1 = 0;\n    int ret2 = 0;\n    \n    // tate\n    \n    for(int i = 0; i < 10000; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            if(y1[j] <= i && i < y2[j])\n            {\n                imos[x1[j]]++;\n                imos[x2[j]]--;\n            }\n        }\n        \n        int sum = 0;\n        \n        for(int j = 0; j <= 10000; j++)\n        {\n            if((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n            \n            sum += imos[j]; imos[j] = 0;\n            \n            if(sum > 0) ret1++;\n        }\n    }\n    \n    // yoko\n    \n    for(int i = 0; i < 10000; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            if(x1[j] <= i && i < x2[j])\n            {\n                imos[y1[j]]++;\n                imos[y2[j]]--;\n            }\n        }\n        \n        int sum = 0;\n        \n        for(int j = 0; j <= 10000; j++)\n        {\n            if((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n            \n            sum += imos[j]; imos[j] = 0;\n        }\n    }\n    \n    if(q == 1)\n    {\n        printf(\"%d\\n\", ret1);\n    }\n    else\n    {\n        printf(\"%d\\n\", ret1);\n        printf(\"%d\\n\", ret2);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n\n    // update right_area_end_point\n    repeat_with_index(y_size, y_i) {\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint n,r;\nbool e[10000][10000];\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tmemset(e,0,sizeof(e));\n\t\tint mx=10000,MX=0,my=10000,MY=0;\n\t\trep(i,n){\n\t\t\tint x,y,X,Y; scanf(\"%d%d%d%d\",&x,&y,&X,&Y);\n\t\t\tfor(int i=y;i<Y;i++)for(int j=x;j<X;j++)e[i][j]=1;\n\t\t\tmx=min(mx,x); MX=max(MX,X);\n\t\t\tmy=min(my,y); MY=max(MY,Y);\n\t\t}\n\t\tint a=0,p=0;\n\t\tfor(int i=my;i<MY;i++)for(int j=mx;j<MX;j++)if(e[i][j])\n\t\t{\n\t\t\ta++;\n\t\t\trep(d,4){\n\t\t\t\tint y=i+dy[d],x=j+dx[d];\n\t\t\t\tif(y<0||y>=10000||x<0||x>=10000||!e[y][x])p++;\n\t\t\t}\n\t\t}\n\t\tif(r==1)printf(\"%d\\n\",a);\n\t\telse printf(\"%d\\n%d\\n\",a,p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1000000000\n#define fi first\n#define sec second\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        scanf(\"%d %d\",&n,&r);\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nconst int MAX_W = 10010, MAX_H = 10010, INF = 1 << 20;\n\nint map[MAX_W][MAX_H];\n\nint main(){\n\tint n, m;\n\twhile(std::cin >> n >> m, n){\n\t\tfor(int y=0;y<MAX_H;y++){\n\t\t\tfor(int x=0;x<MAX_W;x++){\n\t\t\t\tmap[x][y] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint min_x = INF, max_x = -1, min_y = INF, max_y = -1;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1, y1, x2, y2;\n\t\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tmap[x1+1][y1+1]++;\n\t\t\tmap[x1+1][y2+1]--;\n\t\t\tmap[x2+1][y1+1]--;\n\t\t\tmap[x2+1][y2+1]++;\n\t\t\tmin_x = std::min(min_x, std::min(x1+1, x2+1));\n\t\t\tmax_x = std::max(max_x, std::max(x1+1, x2+1));\n\t\t\tmin_y = std::min(min_y, std::min(y1+1, y2+1));\n\t\t\tmax_y = std::max(max_y, std::max(y1+1, y2+1));\n\t\t}\n\n\t\tint S = map[min_x][min_y]?1:0, L = 0;\n\n\t\tfor(int y=min_y;y<=max_y;y++){\n\t\t\tfor(int x=min_x+1;x<=max_x;x++){\n\t\t\t\tmap[x][y] += map[x-1][y];\n\t\t\t\tif(y == min_y && map[x][y]){\n\t\t\t\t\tS++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int y=min_y+1;y<=max_y;y++){\n\t\t\tfor(int x=min_x;x<=max_x;x++){\n\t\t\t\tmap[x][y] += map[x][y-1];\n\t\t\t\tif(map[x][y]){\n\t\t\t\t\tS++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tconst int dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};\n\t\tfor(int y=min_y;y<=max_y;y++){\n\t\t\tfor(int x=min_x;x<=max_x;x++){\n\t\t\t\tif(map[x][y]){\n\t\t\t\t\tint t = 0;\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\t\t\tif(map[nx][ny])t++;\n\t\t\t\t\t}\n\t\t\t\t\tL += 4 - t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << S << std::endl;\n\t\tif(m == 2)std::cout << L << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.first < q.first;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.second < q.second;\n}\n\nvector<pair<P,P> > in;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)return 0;\n\n    in.clear();\n    int mnx=INF,mny=INF,mxx=0,mxy=0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n      mnx=min(mnx,x1);\n      mny=min(mny,y1);\n      mxx=max(mxx,x2);\n      mxy=max(mxy,y2);\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    vector<P>v;\n    for(int i=mny;i<mxy;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].second.second>=i+1 && i>=in[j].second.first){\n\t  v.push_back(make_pair(in[j].first.first,in[j].first.second));\n\t}\n\tif(i<in[j].second.first)break;\n      }\n     \n      if(v.size()!=0){\n\tsort(v.begin(),v.end());\n\tint b=v[0].first,e=v[0].second;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].first,E=v[j].second;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end(),cmp_x);\n\n      for(int i=mnx;i<mxx;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].first.second>=i+1 && i>=in[j].first.first)\n\t    v.push_back(make_pair(in[j].second.first,in[j].second.second));\n\n\t  if(i<in[j].first.first)break;\n\t}\n\tif(v.size()!=0){\n\t  sort(v.begin(),v.end());\n\t  int b=v[0].first,e=v[0].second;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].first,E=v[j].second;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 10000\n\nbool map[MAX][MAX];\n\nbool avR(int x, int y, int v) {\n\tif (v%2==0) {\n\t\tif (v/2==0) {//right\n\t\t\tif (y==0) return false;\n\t\t\treturn map[x][y-1];\n\t\t} else {//left\n\t\t\tif (y==MAX) return false;\n\t\t\treturn map[x][y+1];\n\t\t}\n\t} else {\n\t\tif (v/2==0) {//up\n\t\t\tif (x==MAX) return false;\n\t\t\treturn map[x+1][y];\n\t\t} else {//down\n\t\t\tif (x==0) return false;\n\t\t\treturn map[x-1][y];\n\t\t}\n\t}\n}\n\nbool avF(int x, int y, int v) {\n\tif (v%2==0) {\n\t\tif (v/2==0) {\n\t\t\tif (x==MAX) return false;\n\t\t\treturn map[x+1][y];\n\t\t} else {\n\t\t\tif (x==0) return false;\n\t\t\treturn map[x-1][y];\n\t\t}\n\t} else {\n\t\tif (v/2==0) {\n\t\t\tif (y==MAX) return false;\n\t\t\treturn map[x][y+1];\n\t\t} else {\n\t\t\tif (y==0) return false;\n\t\t\treturn map[x][y-1];\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, r;\n\tint x1, x2, y1, y2;\n\twhile (cin >> n >> r, (n||r)) {\n\t\tfor (int x=0; x<MAX; x++)\n\t\tfor (int y=0; y<MAX; y++)\n\t\t\tmap[x][y] = false;\n\t\tint max[2] = { 0, 0 };\n\t\tint min[2] = { MAX, MAX };\n\t\twhile (n--) {\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 < min[0]) min[0] = x1;\n\t\t\tif (y1 < min[1]) min[1] = y1;\n\t\t\tif (x2 > max[0]) max[0] = x2;\n\t\t\tif (y2 > max[1]) max[1] = y2;\n\t\t\tfor (int x=x1; x<x2; x++) {\n\t\t\t\tfor (int y=y1; y<y2; y++) {\n\t\t\t\t\tmap[x][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S=0;\n\t\tfor (int x=min[0]; x<max[0]; x++) {\n\t\t\tfor (int y=min[1]; y<max[1]; y++) {\n\t\t\t\tif (map[x][y]) S++;\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t\tif (r == 2) {//needed line length\n\t\t\tint l=0;\n\t\t\tint init[2] = { min[0], min[1] };\n\t\t\tfor (;!map[init[0]][init[1]]; init[0]++);\n\t\t\tint x=init[0], y=init[1];\n\t\t\tint v=0; //0:right 1:up 2:left 3:down\n\t\t\tdo {\n\t\t\t\tif (avR(x, y, v)) { //allow Right\n\t\t\t\t\tv = (4+v-1) % 4;//turn Right\n\t\t\t\t} else {\n\t\t\t\t\tl++;\n\t\t\t\t\tif (!avF(x, y, v)) { //deny Forward\n\t\t\t\t\t\tv = (v+1) % 4;//turn Left\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//move\n\t\t\t\tif (v%2==0) {\n\t\t\t\t\tif (v/2==0) x++;//0:right\n\t\t\t\t\telse x--;//2:left\n\t\t\t\t} else {\n\t\t\t\t\tif (v/2==0) y++;//1:up\n\t\t\t\t\telse y--;//3:down\n\t\t\t\t}\n\t\t\t} while (!(x==init[0] && y==init[1]));\n\t\t\tl++;\n\t\t\tcout << l << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r,n|r){\n    vector<P>vx[10001],vy[10001];\n    static vector<pair<P,P> >in;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nstatic vector<pair<P,P> >in;\n\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r,n|r){\n    vector<P>vx[10001],vy[10001];\n\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint q[10003][10003];\n\nint main(){\n\tint x1,x2,y1,y2;\n\tint n, m;\n\tint ret,ret2;\n\twhile(cin >> n >> m && n && m){\n\t\tret = ret2 = 0;\n\t\tfor(int k=0;k<10001;k++)for(int i = 0 ; i<10001;i++)q[k][i]=0;\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tx1++;y1++;x2++;y2++;\n\t\t\tfor(int i = y1 ; i<y2;i++){\n\t\t\t\tfor(int j = x1 ; j<x2;j++){\n\t\t\t\t\tif(!q[i][j]){\n\t\t\t\t\t\tq[i][j]=1;\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=10001;i++){\n\t\t\tfor(int j=1; j<=10001;j++){\n\t\t\t\tif(q[i][j]==1){\n\t\t\t\t\tif(!q[i-1][j])ret2++;\n\t\t\t\t\tif(!q[i+1][j])ret2++;\n\t\t\t\t\tif(!q[i][j-1])ret2++;\n\t\t\t\t\tif(!q[i][j+1])ret2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ret << endl;\n\t\tif(m==2)cout << ret2 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\npriority_queue<T, vector<T>, greater<T> > pq;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(cin >> n >> r, n | r){\n\tfor(int i = 0;i < 3;i++)\n\t    fill(imos[i], imos[i] + 10500, 0);\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 10500;\n\tright_side = top = 1;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> ax >> ay >> bx >> by;\n\t    left_side = min(left_side, ++ax);\n\t    right_side = max(right_side, ++bx);\n\t    bottom = min(bottom, ++ay);\n\t    top = max(top, ++by);\t    \n\t    pq.push(T(P(ax, ay), 1));\n\t    pq.push(T(P(ax, by), -1));\n\t    pq.push(T(P(bx, ay), -1));\n\t    pq.push(T(P(bx, by), 1));\n\t}\n\tpq.push(T(P(INF, INF), 0));\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(pq.top().first == P(i, j)){\n\t\t    imos[i % 3][j] += pq.top().second;pq.pop();\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tpq.pop();\n\tcout << area << endl;\n\tif(r == 2)cout << round << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint fie[2000][2000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    int x[10000][2],y[10000][2];\n    vector<int> vx(2),vy(2);\n    vx[0]=vy[0]=-1;\n    vx[1]=vy[1]=10001;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<2;j++){\n\tcin>>x[i][j]>>y[i][j];\n\tvx.push_back(x[i][j]);\n\tvy.push_back(y[i][j]);\n      }\n    }\n    sort(vx.begin(),vx.end());\n    vx.erase(unique(vx.begin(),vx.end()),vx.end());\n    sort(vy.begin(),vy.end());\n    vy.erase(unique(vy.begin(),vy.end()),vy.end());\n    vector<vector<bool> > v(vy.size()-1,vector<bool>(vx.size()-1));\n    for(int i=0;i<n;i++){\n      int jl=lower_bound(vy.begin(),vy.end(),y[i][1])-vy.begin();\n      int kl=lower_bound(vx.begin(),vx.end(),x[i][1])-vx.begin();\n      for(int j=lower_bound(vy.begin(),vy.end(),y[i][0])-vy.begin();j<jl;j++){\n\tfor(int k=lower_bound(vx.begin(),vx.end(),x[i][0])-vx.begin();k<kl;k++){\n\t  v[j][k]=true;\n\t}\n      }\n    }\n    for(int i=v.size()-2;i>=0;i--){\n      if(v[i]==v[i+1]){\n\tv.erase(v.begin()+i);\n\tvy.erase(vy.begin()+i+1);\n      }\n    }\n    int a=0;\n    for(int i=0;i<v.size();i++){\n      for(int j=0;j<v[i].size();j++){\n\tif(v[i][j]){\n\t  a+=(vy[i+1]-vy[i])*(vx[j+1]-vx[j]);\n\t}\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j+1<v[i].size();j++){\n\t  if(v[i][j]^v[i][j+1]){\n\t    l+=vy[i+1]-vy[i];\n\t  }\n\t}\n      }\n      for(int i=0;i<v[0].size();i++){\n\tfor(int j=0;j+1<v.size();j++){\n\t  if(v[j][i]^v[j+1][i]){\n\t    l+=vx[i+1]-vx[i];\n\t  }\n\t}\n      }\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\n//const long long int INF_=1<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ninline void Imos(vector<vector<int> > &plane){\n\tREP(y,0,plane[0].size()){\n\t\tREP(x,1,plane.size()){\n\t\t\tplane[x][y]+=plane[x-1][y];\n\t\t}\n\t}\n\tREP(x,0,plane.size()){\n\t\tfor(int y=plane[0].size()-2; y>=0; --y){\n\t\t\tplane[x][y]+=plane[x][y+1];\n\t\t}\n\t}\n}\n\ninline int CalcSize(vector<vector<int> > &plane){\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(plane[x][y]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(vector<vector<int> > &plane,vector<vector<bool> > &has_done,int x,int y,int W,int H){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[x][y]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[nx][ny]){\n\t\t\t\tif(plane[nx][ny]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[nx][ny]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t\t//cout << result << ' ' << p.F_ << ' ' << p.S_ << endl;\n\t}\n\treturn result;\n}\n\ninline int CalcLength(vector<vector<int> > &plane){\n\tvector<vector<bool> > has_done(plane.size(),vector<bool>(plane[0].size()));\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(!has_done[x][y]&&plane[x][y]>0){\n\t\t\t\tresult+=BFS(plane,has_done,x,y,plane.size(),plane[0].size());\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tint min_x,min_y,max_x,max_y;\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tX[j].push_back(x);\n\t\t\t\tY[j].push_back(y);\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > plane(max_x+4,vector<int>(max_y+4));\n\t\tREP(i,0,N){\n\t\t\tplane[X[0][i]+1][Y[1][i]+1]+=1;\n\t\t\tplane[X[1][i]+2][Y[0][i]]+=1;\n\t\t\tplane[X[0][i]+1][Y[0][i]]+=-1;\n\t\t\tplane[X[1][i]+2][Y[1][i]+1]+=-1;\n\t\t}\n\t\tImos(plane);\n\t\t/*\n\t\tfor(int y=plane[0].size()-1; y>=0; --y){\n\t\t\tREP(x,0,plane.size()){\n\t\t\t\tcout << plane[x][y] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << CalcSize(plane) << endl;\n\t\tif(R==2) cout << CalcLength(plane) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint dp[10001], p[10001];\n\ntypedef pair<int, pair<int, int> > Event;\n\nint main() {\n  for (;;) {\n    int n, r;\n    cin >> n >> r;\n    if (!(n || r)) return 0;\n    map<int, vector<Event> > events;\n    int mx = 0, c = 0, area = 0, circumference = 0;\n    for (int i = 0; i < n; i++) {\n      int sx, sy, ex, ey;\n      cin >> sx >> sy >> ex >> ey;\n      events[sy].push_back(make_pair(1, make_pair(sx, ex)));\n      events[ey].push_back(make_pair(-1, make_pair(sx, ex)));\n      mx = max(mx, ex);\n    }\n    fill(dp, dp+mx+1, 0);\n    fill(p, p+mx+1, 0);\n    for (map<int, vector<Event> >::iterator v = events.begin();\n         v != events.end(); ++v) {\n      int count = 0, a = 0, b = 0;\n      for (int i = 0; i < mx; i++) {\n        if (dp[i]) {\n          count++;\n          if (dp[i+1]) a++;\n          if (p[i]) b++;\n        }\n        p[i] = dp[i];\n      }\n      circumference += ((v->first - c) * (count - a) + count - b) * 2;\n      area += (v->first - c) * count;\n      c = v->first;\n      for (vector<Event>::iterator e = v->second.begin();\n           e != v->second.end(); ++e)\n        for (int i = e->second.first; i < e->second.second; i++)\n          dp[i] += e->first;\n    }\n    /*\n    fill(dp, dp+mx, 0);\n    for (map<int, vector<Event> >::iterator v = events.begin();\n         v != events.end(); ++v) {\n      int count = 0;\n      for (int i = 0; i < mx; i++) if (dp[i]) count++;\n      area += (v->first - c) * count;\n      c = v->first;\n      for (vector<Event>::iterator e = v->second.begin();\n           e != v->second.end(); ++e)\n        for (int i = e->second.first; i < e->second.second; i++)\n          dp[i] += e->first;\n      for (int i = 0; i < mx; i++)\n        cout << dp[i] << ' ';\n      cout << endl;\n    }\n    */\n    cout << area << endl;\n    if (r == 2)\n      cout << circumference << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n,r;\n\tint x1[1000]={};\n\tint y1[1000]={};\n\tint x2[1000]={};\n\tint y2[1000]={};\n\tint tx1[1000]={};\n\tint ty1[1000]={};\n\tint tx2[1000]={};\n\tint ty2[1000]={};\n\tint ti[1000]={};\n\tint tj,tk;\n\tint tlx[4000]={};\n\tint tly[4000]={};\n\tint tll[4000]={};\n\tint tld[4000]={};\n\tint tli[4000]={};\n\twhile(1){\n\t\tcin >> n >> r;\n\t\tif(n==0){\n\t\t\treturn 0;\n\t\t}\n\t\tint s=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\t\t\ttx1[0]=x1[i];ty1[0]=y1[i];tx2[0]=x2[i];ty2[0]=y2[i];\n\t\t\ttj=1;ti[0]=0;\n\t\t\tfor(int j=0;j<tj;j++){\n\t\t\t\t//cout << ti[j] << ' ' << tx1[j] << ' ' << ty1[j] << ' ' << tx2[j] << ' ' << ty2[j] << endl;\n\t\t\t\tbool ol=false;\n\t\t\t\tfor(int k=ti[j];k<i && !ol;k++){\n\t\t\t\t\tif(tx1[j]<x2[k]&&tx2[j]>x1[k]&&ty1[j]<y2[k]&&ty2[j]>y1[k]){\n\t\t\t\t\t\tol=true;\n\t\t\t\t\t\tif(tx1[j]<x1[k]){\n\t\t\t\t\t\t\ttx1[tj]=tx1[j];\n\t\t\t\t\t\t\tty1[tj]=ty1[j];\n\t\t\t\t\t\t\ttx2[tj]=x1[k];\n\t\t\t\t\t\t\tty2[tj]=ty2[j];\n\t\t\t\t\t\t\tti[tj]=k+1;\n\t\t\t\t\t\t\ttj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ty1[j]<y1[k]){\n\t\t\t\t\t\t\ttx1[tj]=max(tx1[j],x1[k]);\n\t\t\t\t\t\t\tty1[tj]=ty1[j];\n\t\t\t\t\t\t\ttx2[tj]=min(tx2[j],x2[k]);\n\t\t\t\t\t\t\tty2[tj]=y1[k];\n\t\t\t\t\t\t\tti[tj]=k+1;\n\t\t\t\t\t\t\ttj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(tx2[j]>x2[k]){\n\t\t\t\t\t\t\ttx1[tj]=x2[k];\n\t\t\t\t\t\t\tty1[tj]=ty1[j];\n\t\t\t\t\t\t\ttx2[tj]=tx2[j];\n\t\t\t\t\t\t\tty2[tj]=ty2[j];\n\t\t\t\t\t\t\tti[tj]=k+1;\n\t\t\t\t\t\t\ttj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ty2[j]>y2[k]){\n\t\t\t\t\t\t\ttx1[tj]=max(tx1[j],x1[k]);\n\t\t\t\t\t\t\tty1[tj]=y2[k];\n\t\t\t\t\t\t\ttx2[tj]=min(tx2[j],x2[k]);\n\t\t\t\t\t\t\tty2[tj]=ty2[j];\n\t\t\t\t\t\t\tti[tj]=k+1;\n\t\t\t\t\t\t\ttj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ol){\n\t\t\t\t\ts+=(tx2[j]-tx1[j])*(ty2[j]-ty1[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << s << endl;\n\t\tif(r==2){\n\t\t\tint sl=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint ddx=x2[i]-x1[i];\n\t\t\t\tint ddy=y2[i]-y1[i];\n\t\t\t\ttlx[0]=x1[i];tly[0]=y1[i];tll[0]=ddx;tld[0]=0;tli[0]=0;\n\t\t\t\ttlx[1]=x1[i];tly[1]=y1[i];tll[1]=ddy;tld[1]=1;tli[1]=0;\n\t\t\t\ttlx[2]=x1[i];tly[2]=y2[i];tll[2]=ddx;tld[2]=2;tli[2]=0;\n\t\t\t\ttlx[3]=x2[i];tly[3]=y1[i];tll[3]=ddy;tld[3]=3;tli[3]=0;\n\t\t\t\ttj=4;\n\t\t\t\tfor(int j=0;j<tj;j++){\n\t\t\t\t\tbool cr=false;\n\t\t\t\t\tfor(int k=tli[j];k<n && !cr;k++){\n\t\t\t\t\t\tif(i!=k){\n\t\t\t\t\t\tif(tld[j]%2==0 && tlx[j]<x2[k] && x1[k]<tlx[j]+tll[j] && y1[k]<=tly[j] && tly[j]<=y2[k]){\n\t\t\t\t\t\t\tif( !( ((tld[j]==0 && tly[j]==y1[k]) || (tld[j]==2 && tly[j]==y2[k])) && i<k) ){\n\t\t\t\t\t\t\t\tcr=true;\n\t\t\t\t\t\t\t\tif(tlx[j]<x1[k]){\n\t\t\t\t\t\t\t\t\ttlx[tj]=tlx[j];\n\t\t\t\t\t\t\t\t\ttly[tj]=tly[j];\n\t\t\t\t\t\t\t\t\ttll[tj]=x1[k]-tlx[j];\n\t\t\t\t\t\t\t\t\ttld[tj]=tld[j];\n\t\t\t\t\t\t\t\t\ttli[tj]=k+1;\n\t\t\t\t\t\t\t\t\ttj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(x2[k]<tlx[j]+tll[j]){\n\t\t\t\t\t\t\t\t\ttlx[tj]=x2[k];\n\t\t\t\t\t\t\t\t\ttly[tj]=tly[j];\n\t\t\t\t\t\t\t\t\ttll[tj]=tlx[j]+tll[j]-x2[k];\n\t\t\t\t\t\t\t\t\ttld[tj]=tld[j];\n\t\t\t\t\t\t\t\t\ttli[tj]=k+1;\n\t\t\t\t\t\t\t\t\ttj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(tld[j]%2==1 && tly[j]<y2[k] && y1[k]<tly[j]+tll[j] && x1[k]<=tlx[j] && tlx[j]<=x2[k]){\n\t\t\t\t\t\t\tif( !( ((tld[j]==1 && tlx[j]==x1[k]) || (tld[j]==3 && tlx[j]==x2[k])) && i<k) ){\n\t\t\t\t\t\t\t\tcr=true;\n\t\t\t\t\t\t\t\tif(tly[j]<y1[k]){\n\t\t\t\t\t\t\t\t\ttlx[tj]=tlx[j];\n\t\t\t\t\t\t\t\t\ttly[tj]=tly[j];\n\t\t\t\t\t\t\t\t\ttll[tj]=y1[k]-tly[j];\n\t\t\t\t\t\t\t\t\ttld[tj]=tld[j];\n\t\t\t\t\t\t\t\t\ttli[tj]=k+1;\n\t\t\t\t\t\t\t\t\ttj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(y2[k]<tly[j]+tll[j]){\n\t\t\t\t\t\t\t\t\ttlx[tj]=tlx[j];\n\t\t\t\t\t\t\t\t\ttly[tj]=y2[k];\n\t\t\t\t\t\t\t\t\ttll[tj]=tly[j]+tll[j]-y2[k];\n\t\t\t\t\t\t\t\t\ttld[tj]=tld[j];\n\t\t\t\t\t\t\t\t\ttli[tj]=k+1;\n\t\t\t\t\t\t\t\t\ttj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t\t\t//cout << tlx[j] <<\" \" << tly[tj] << \" \" << tll[j] << \" \" << tld[j] << \" \" << i<< \" \"<<j << \" \"<<cr <<endl;\n\t\t\t\t\tif (!cr){\n\t\t\t\t\t\tsl+=tll[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcout << sl << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst static int MAX = 10000;\nbool Sheets[MAX+2][MAX+2];\n\nint count(int x,int y) {\n  int dx[4] = {-1,0,0,1};\n  int dy[4] = {0,1,-1,0};\n  int cnt = 0;\n  for(int d=0;d<4;d++) {\n    if(!Sheets[x+dx[d]][y+dy[d]])\n      cnt++;\n  }\n  return cnt;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,r;\n  while(cin >> n >> r) {\n    if(n+r == 0) break;\n    for(int i=1;i<=MAX;i++) {\n      for(int j=1;j<=MAX;j++) {\n        Sheets[i][j] = false;\n      }\n    }\n\n    int x[2],y[2];\n    for(int i=0;i<n;i++) {\n      cin >> x[0] >> y[0] >> x[1] >> y[1];\n      for(int w=x[0]+1;w<=x[1];w++) {\n        for(int h=y[0]+1;h<=y[1];h++) {\n          Sheets[h][w] = true;\n        }\n      }\n    }\n\n    // calc\n    int length = 0;\n    int surface = 0;\n    for(int i=1;i<=MAX;i++) {\n      for(int j=1;j<=MAX;j++) {\n        if(Sheets[i][j]) {\n          surface++;\n          length += count(i,j);\n        }\n      }\n    }\n    cout << surface << endl;\n    if(r==2) cout << length << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> State;\n \nbool compareState(const State& ls, const State& rs){\n    const P& lp = ls.first, rp = rs.first;\n    if(lp.second == rp.second){\n        return lp.first < rp.first;\n    }\n    return lp.second < rp.second;\n}\n\nint main(){\n    int N, R;\n    while(std::cin >> N >> R, N){\n        int minX = INF, maxX = 0, minY = INF, maxY = 0;\n        std::vector<State> S;\n        REP(i, N){\n            int x1, y1, x2, y2;\n            std::cin >> x1 >> y1 >> x2 >> y2;\n\n            minX = std::min(minX, x1);\n            maxX = std::max(maxX, x2);\n            minY = std::min(minY, y1);\n            maxY = std::max(maxY, y2);\n\n            S.push_back(mp(mp(x1, y1), 1));\n            S.push_back(mp(mp(x1, y2), -1));\n            S.push_back(mp(mp(x2, y1), -1));\n            S.push_back(mp(mp(x2, y2), 1));\n        }\n\n        std::sort(S.begin(), S.end(), compareState);\n\n        int board[2][10001], pos = 0;\n        REP(i, 2){\n            REP(j, 10001){\n                board[i][j] = 0;\n            }\n        }\n\n        // REP(i, S.size()){\n        //     printf(\"(%d, %d): %d\\n\", S[i].first.first, S[i].first.second, S[i].second);\n        // }\n\n        //std::cout << minX << \", \" << maxX << std::endl;\n        //std::cout << minY << \", \" << maxY << std::endl;\n\n        int l = 0, sq = 0;\n        FOR(i, minY, maxY+1){\n            FOR(j, minX, maxX+1){\n                board[1][j] = 0;\n            }\n\n            if(pos < S.size()){\n                while(S[pos].first.second == i){\n                    board[1][S[pos].first.first] += S[pos].second;\n                    pos++;\n                }\n                //printf(\"%d, %d\\n\", i, pos);\n\n                FOR(j, minX+1, maxX+1){\n                    board[1][j] += board[1][j-1];\n                }\n            }\n        \n            FOR(j, minX, maxX+1){\n                board[1][j] += board[0][j];\n            }\n\n            FOR(j, minX, maxX+1){\n                //printf(\"%d, \", board[1][j]);\n                \n                if(board[1][j] > 0){\n                    sq += 1;\n                \n                    if(j == 0 || board[1][j-1] == 0){\n                        l += 1;\n                    }\n                    if(j == 10000 || board[1][j+1] == 0){\n                        l += 1;\n                    }\n                    l += (board[0][j] == 0) * 2;\n                }\n            }\n            //puts(\"\");\n            //printf(\"%d\\n\", l);\n        \n            std::swap(board[0], board[1]);\n        }\n\n        FOR(i, minX, maxX+1){\n            if(board[0][i] > 0){\n                l += 1;\n            }\n        }\n    \n\n        std::cout << sq << std::endl;\n        if(R == 2){\n            std::cout << l << std::endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint n,r;\nint canvas[10003][10003]={{0}};\nint main()\n{\n\twhile(cin>>n >>r,n)\n\t{\n\n\t\tint mx1=10003,my1=10003,mx2=0,my2=0;\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin>>x1;x1++;\n\t\t\tcin>>y1;y1++;\n\t\t\tcin>>x2;x2++;\n\t\t\tcin>>y2;y2++;\n\t\t\tmx1=min(mx1,x1);\n\t\t\tmy1=min(my1,y1);\n\t\t\tmx2=max(mx2,x2);\n\t\t\tmy2=max(my2,y2);\n\t\t\tfor(int i2=y1;i2<y2;i2++){\n\t\t\t\tfor(int i=x1;i<x2;i++){\n\t\t\t\t\tcanvas[i2][i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tif(n-1){\n\t\t\tint d=0;\n\t\t\tfor(int i2=my1;i2<my2;i2++){\n\t\t\t\tfor(int i=mx1;i<mx2;i++){\n\t\t\t\t\tif(canvas[i2][i]){\n\t\t\t\t\t\tif(i2==my1 || i == mx1 || i2 == my2-1 || i == mx2-1){\n\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\tif((i2==my1 && i == mx1 ) || (i2==my1 && i == mx2 -1 ) ||(i2==my2 -1 && i == mx1  ) ||(i2==my2 -1 && i == mx2 -1 ) ){\n\t\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\td+=(canvas[i2+1][i]+canvas[i2-1][i]+canvas[i2][i+1]+canvas[i2][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout <<count << endl;\n\t\t\tcout << d << endl;\n\t\t}else{\n\t\t\tfor(int i2=my1;i2<my2;i2++){\n\t\t\t\tfor(int i=mx1;i<mx2;i++){\n\t\t\t\t\tif(canvas[i2][i])count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout <<count << endl;\n\t\t}\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <list>\n#include <vector>\n\nusing namespace std;\nint N, R;\nbool **cover;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\nint main(){\n  cover = new bool*[10002];\n  for(int i=0; i<10002; ++i){\n    cover[i] = new bool[10002];\n  }\n  for(int j=0; j<10002; ++j){\n    for(int i=0; i<10002; ++i){\n      cover[j][i] = false;\n    }\n  }\n  while(cin >> N >> R && N){\n    int a,b,c,d;\n    for(int k=0; k<N; ++k){\n      cin >> a >> b >> c >> d;\n      for(int j=b+1; j<d+1; ++j){\n        for(int i=a+1; i<c+1; ++i){\n          \n          cover[j][i] = true;\n        }\n      }\n    }\n    int area_c = 0;\n    int len = 0;\n    for(int j=1; j<10001; ++j){\n      for(int i=1; i<10001; ++i){\n            \n        if(cover[j][i] == true){\n          area_c++;\n          for(int a = 0; a<4; ++a){\n            int nx = i+dx[a];\n            int ny = j+dy[a];\n            if(cover[ny][nx] == false) len++;\n          }\n        }\n      }\n    }\n    cout << area_c << endl;\n    if(R==2) cout << len << endl;\n  }\n  \n  for(int i=0; i<10001; ++i){\n    delete[] cover[i];\n  }\n  delete[] cover;\n  return 0;\n}#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <list>\n#include <vector>\n\nusing namespace std;\nint N, R;\nbool **cover;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\nint main(){\n  cover = new bool*[10002];\n  for(int i=0; i<10002; ++i){\n    cover[i] = new bool[10002];\n  }\n  for(int j=0; j<10002; ++j){\n    for(int i=0; i<10002; ++i){\n      cover[j][i] = false;\n    }\n  }\n  while(cin >> N >> R && N){\n    int a,b,c,d;\n    for(int k=0; k<N; ++k){\n      cin >> a >> b >> c >> d;\n      for(int j=b+1; j<d+1; ++j){\n        for(int i=a+1; i<c+1; ++i){\n          \n          cover[j][i] = true;\n        }\n      }\n    }\n    int area_c = 0;\n    int len = 0;\n    for(int j=1; j<10001; ++j){\n      for(int i=1; i<10001; ++i){\n            \n        if(cover[j][i] == true){\n          area_c++;\n          for(int a = 0; a<4; ++a){\n            int nx = i+dx[a];\n            int ny = j+dy[a];\n            if(cover[ny][nx] == false) len++;\n          }\n        }\n      }\n    }\n    cout << area_c << endl;\n    if(R==2) cout << len << endl;\n  }\n  \n  for(int i=0; i<10001; ++i){\n    delete[] cover[i];\n  }\n  delete[] cover;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nbool Compare(const P &p1,const P &p2){\n\treturn p1.F_<p2.F_;\n}\n\t\nint CalcSize(vector<vector<P> > &range){\n\tint result=0;\n\tREP(x,1,10010){\n\t\tint index=0,y=0;\n\t\twhile(index<range[x].size()){\n\t\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y) ++result;\n\t\t\t++index;\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid Add(vector<vector<P> > &range,vector<vector<int> > &cnt,int x,int &result){\n\tint index=0,y=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(cnt[(x-1)%3][y]==0) ++result;\n\t\t\tif(cnt[(x+1)%3][y]==0) ++result;\n\t\t\tif(cnt[x%3][y-1]==0) ++result;\n\t\t\tif(cnt[x%3][y+1]==0) ++result;\n\t\t}\n\t\t++index;\n\t}\n}\n\nint CalcLength(vector<vector<P> > &range){\n\tint result=0;\n\tvector<vector<int> > cnt(3,vector<int>(10010));\n\tREP(x,1,10009){\n\t\tif(x-2>=0) fill(cnt[(x-2)%3].begin(),cnt[(x-2)%3].end(),0);\n\t\tint index=0,y=0;\n\t\twhile(index<range[x+1].size()){\n\t\t\tfor(y=max(y,range[x+1][index].F_); y<range[x+1][index].S_; ++y) ++cnt[(x+1)%3][y];\n\t\t\t++index;\n\t\t}\n\t\tAdd(range,cnt,x,result);\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tvector<vector<P> > range(10010);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tREP(x,x1+4,x2+4) range[x].push_back(MP(y1+4,y2+4));\n\t\t}\n\t\tREP(x,0,10010) sort(range[x].begin(),range[x].end(),Compare);\n\t\tcout << CalcSize(range) << endl;\n\t\tif(R==2) cout << CalcLength(range) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\npair<P,P> in[10000];\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    vector<P> v[10001];\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&in[i].F.F,&in[i].S.F,&in[i].F.S,&in[i].S.S);\n    }\n\n    sort(in,in+n,cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      sort(in,in+n,cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nstruct Rect{\n\tshort x1,x2,y1,y2;\n};\n\nclass Compare{\n\tpublic:\n\tbool operator()(const Rect &rect1,const Rect &rect2){\n\t\treturn rect1.x1<rect2.x1;\n\t}\n};\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<vector<P> > &range,vector<Rect> &rects){\n\tint result=0;\n\tint index=0;\n\tREP(x,0,10010){\n\t\twhile(index<rects.size()&&rects[index].x1<=x){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x].begin(),range[x].end());\n\t\tint y=0;\n\t\tREP(i,0,range[x].size()){\n\t\t\tif(range[x][i].S_>y) result+=range[x][i].S_-max(y,range[x][i].F_);\n\t\t\ty=max(y,range[x][i].S_);\n\t\t}\n\t\tvector<P>().swap(range[x]);\n\t}\n\treturn result;\n}\n\nint Count(vector<vector<P> > &range,vector<vector<bool> > &flag,int x){\n\tint index=0,y=0,result=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t}\n\t\t++index;\n\t}\n\treturn result;\n}\n\nint CalcLength(vector<vector<P> > &range,vector<Rect> &rects){\n\tint result=0,index=0;\n\tvector<vector<bool> > flag(3,vector<bool>(10010));\n\tREP(x,1,10009){\n\t\twhile(index<rects.size()&&rects[index].x1<=x+1){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x+1].begin(),range[x+1].end());\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,range[x+1].size()){\n\t\t\tif(range[x+1][i].S_>y) fill_n(flag[(x+1)%3].begin()+max(y,range[x+1][i].F_),range[x+1][i].S_-max(y,range[x+1][i].F_),true);\n\t\t\ty=max(range[x+1][i].S_,y);\n\t\t}\n\t\tresult+=Count(range,flag,x);\n\t\tif(x-2>=0) vector<P>().swap(range[x-2]);\n\t}\n\treturn result;\n}\n\nint main(){\n\t//std::ios::sync_with_stdio(false);\n\t//std::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tvector<vector<P> > range(10010);\n\t\tvector<Rect> rects(N);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\trects[i].x1=x1+4;\n\t\t\trects[i].y1=y1+4;\n\t\t\trects[i].x2=x2+4;\n\t\t\trects[i].y2=y2+4;\n\t\t}\n\t\tsort(rects.begin(),rects.end(),Compare());\n\t\tcout << CalcSize(range,rects) << endl;\n\t\tif(R==2) cout << CalcLength(range,rects) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    // repeat_with_index(y_size, y_i) {\n    //   // update right_area_end_point\n    //   auto points = find_end_points(x_i, y_i);\n\n    //   // per point operation\n    //   for (auto&& point : points) {\n    //     int x = point.first, y = point.second;\n\n    //     repete_from_to(y_i, y - 1, p_i) {\n    //       assign_if_larger(right_area_end_point[p_i], x);\n    //     }\n    //   }\n    // }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<P> v[10001];\nvector<pair<P,P> > in;\n\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    in.clear();\n    for(int i=0;i<10001;i++)v[i].clear();\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n      \n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b, b=B, e=E, L+=2;\n      }\n      S+=e-b, L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B, e=E, L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass imos2\n{\npublic:\n\tvoid addInc( long long int x, long long int y ) {\n\t\tinc.emplace_back( make_pair( x, y ) );\n\t\tincsortflag = false;\n\t}\n\n\tvoid addDec( long long int x, long long int y ) {\n\t\tdec.emplace_back( make_pair( x, y ) );\n\t\tdecsortflag = false;\n\t}\n\n\tpair<long long int, long long int> ans( long long int R ) {\n\t\tpair<long long int, long long int>ret = make_pair( 0, 0 );\n\t\tif( !incsortflag ) {\n\t\t\tfor( auto now : inc ) {\n\t\t\t\tincymax = max( incymax, now.second );\n\t\t\t\tincymin = min( incymin, now.second );\n\t\t\t}\n\t\t\tsort( inc.begin(), inc.end() );\n\t\t\tincsortflag = true;\n\t\t}\n\t\tif( !decsortflag ) {\n\t\t\tfor( auto now : dec ) {\n\t\t\t\tdecymax = max( decymax, now.second );\n\t\t\t\tdecymin = min( decymin, now.second );\n\t\t\t}\n\t\t\tsort( dec.begin(), dec.end() );\n\t\t\tdecsortflag = true;\n\t\t}\n\t\tlong long int ymin = min( incymin, decymin ), ymax = max( incymax, decymax );\n\t\tvector<long long int>tmp1( ymax - ymin + 1 );\n\t\tvector<long long int>tmp2( ymax - ymin + 1 );\n\t\tlong long int incidx = 0, decidx = 0;\n\t\tfor( long long int i = inc[0].first; i <= dec[dec.size() - 1].first; i++ ) {\n\t\t\twhile( incidx < inc.size() && inc[incidx].first == i&&inc[incidx].second <= ymax ) {\n\t\t\t\ttmp2[inc[incidx].second - ymin]++;\n\t\t\t\tincidx++;\n\t\t\t}\n\t\t\twhile( decidx < dec.size() && dec[decidx].first == i&&dec[decidx].second <= ymax ) {\n\t\t\t\ttmp2[dec[decidx].second - ymin]--;\n\t\t\t\tdecidx++;\n\t\t\t}\n\t\t\tfor( long long int j = 0; j < ymax - ymin; j++ ) {\n\t\t\t\ttmp2[j + 1] += tmp2[j];\n\t\t\t}\n\t\t\tfor( long long int j = 0; j < ymax - ymin + 1; j++ ) {\n\t\t\t\ttmp2[j] += tmp1[j];\n\t\t\t\t//cout << setw( 2 ) << tmp2[j];\n\t\t\t\tif( tmp2[j] ) {\n\t\t\t\t\tret.first++;\n\t\t\t\t}\n\t\t\t\tif( R == 2 ) {\n\t\t\t\t\tif( (!tmp2[j]) != (!tmp1[j]) ) {\n\t\t\t\t\t\tret.second++;\n\t\t\t\t\t}\n\t\t\t\t\tif( j > 0 && (!tmp2[j]) != (!tmp2[j - 1]) ) {\n\t\t\t\t\t\tret.second++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( tmp2[0] ) {\n\t\t\t\tret.second++;\n\t\t\t}\n\t\t\ttmp1 = tmp2;\n\t\t\ttmp2 = vector<long long int>( ymax - ymin + 1 );\n\t\t}\n\t\treturn ret;\n\t}\n\n\n\tvector<pair<long long int, long long int>>inc;\n\tvector<pair<long long int, long long int>>dec;\n\n\tbool incsortflag;\n\tbool decsortflag;\n\n\tlong long int incymax = LLONG_MIN, decymax = LLONG_MIN;\n\tlong long int incymin = LLONG_MAX, decymin = LLONG_MAX;\n};\n\nint main() {\n\tlong long int N, R;\n\twhile( cin >> N >> R, N || R ) {\n\t\timos2 imos;\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tlong long int x1, y1, x2, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\timos.addInc( x1, y1 );\n\t\t\timos.addInc( x2, y2 );\n\t\t\timos.addDec( x1, y2 );\n\t\t\timos.addDec( x2, y1 );\n\t\t}\n\t\tauto memo = imos.ans( R );\n\t\tif( R == 1 ) {\n\t\t\tcout << memo.first << endl;\n\t\t} else {\n\t\t\tcout << memo.first << endl << memo.second << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint field[10001][10001];\nint X1,X2,Y1,Y2;\nint main() {\n\tint n,r;\n\twhile(scanf(\"%d %d\",&n,&r),n) {\n\t\tmemset(field,0,sizeof(field));\n\t\tX1=10000,Y1=10000,X2=0,Y2=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\t\tfield[x1][y1]++;\n\t\t\tfield[x2][y1]--;\n\t\t\tfield[x1][y2]--;\n\t\t\tfield[x2][y2]++;\n\t\t\tX1=min(x1,X1); Y1=min(y1,Y1);\n\t\t\tX2=max(x2,X2); Y2=max(y2,Y2);\n\t\t}\n\t\tfor(int i=Y1;i<=Y2;i++) {\n\t\t\tfor(int j=X1+1;j<=X2;j++) {\n\t\t\t\tfield[j][i]+=field[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=X1;i<=X2;i++) {\n\t\t\tfor(int j=Y1+1;j<=Y2;j++) {\n\t\t\t\tfield[i][j]+=field[i][j-1];\n\t\t\t}\n\t\t}\n\t\tint S=0;\n\t\tfor(int i=X1;i<X2;i++) for(int j=Y1;j<Y2;j++) if(field[i][j]>0)S++;\n\t\tprintf(\"%d\\n\",S);\n\t\tif(r==2) {\n\t\t\tint LEN=0;\n\t\t\tfor(int i=X1;i<X2;i++) for(int j=Y1;j<Y2;j++) {\n\t\t\t\tif(field[i][j]) {\n\t\t\t\t\tLEN+=(!i||!field[i-1][j])+(!j||!field[i][j-1]);\n\t\t\t\t\tLEN+=!field[i+1][j]+!field[i][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",LEN);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "include <cstdio>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nint n;\nshort min_x1, max_x2, min_y1, max_y2;\nshort x1, x2, y1, y2;\nmap<pair<short, short>, short> *variation;\nchar tiles[10002][10002];\n\nvoid variation_inc(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second + 1;\n    } else {\n        value = 1;\n    }\n\n    variation->erase(make_pair(x, y));\n\t\n    if (value != 0) {\n    \tvariation->insert(pair<pair<short, short>, short>(make_pair(x,y), value));\n    }\n\n    return ;\n}\n\nvoid variation_dec(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second - 1;\n    } else {\n        value = -1;\n    }\n\n    variation->erase(make_pair(x, y));\n\n    if (value != 0) {\n    \tvariation->insert(pair<pair<short, short>, short>(make_pair(x,y), value));\n    }\n\n    return ;\n}\n\nshort variation_return(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n    \tvalue = location->second;\n    } else {\n        value = 0;\n    }\n\n    return value;\n}\n\nvoid pre_process() {\n    short i;\n    short calc[2][10002];\n\t\n\tfor (i=0;i<2;i++) {\n        int j;\n        for (j=0;j<10002;j++) {\n            calc[i][j] = 0;\n        }\n\t}\n\n    for (i=min_y1-1;i<max_y2+1;i++) {\n        int j;\n        \n        for (j=min_x1-1;j<max_x2+1;j++) {\n            calc[1][j] = variation_return(j, i);\n\n            calc[1][j] += calc[1][j-1];\n            calc[1][j] += calc[0][j];\n        \tcalc[1][j] -= calc[0][j-1];\n        }\n\n        for (j=min_x1;j<max_x2+1;j++) {\n            tiles[i][j] = ((calc[0][j] > 0) ? 1 : 0);\n            calc[0][j] = calc[1][j];\n        }\n    }\n\n    return;\n}\n\nint surface() {\n    short i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2+1;i++) {\n        int j;\n        for (j=min_x1;j<max_x2+1;j++) {\n            if (tiles[i][j]) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint perimeter() {\n    short i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2+2;i++) {\n        short j;\n        for (j=min_x1;j<max_x2+2;j++) {\n            if (tiles[i][j] + tiles[i-1][j] == 1) {\n                sum++;\n            }\n\n            if (tiles[i][j] + tiles[i][j-1] == 1) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while (1) {\n        short i;\n        int r;\n\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r ==0) return 0;\n\n    \tvariation = new map<pair<short, short>, short>();\n\n        min_x1 = 10000;\n        min_y1 = 10000;\n        max_x2 = 0;\n        max_y2 = 0;\n        for (i=0;i<n;i++) {\n            scanf(\"%hd %hd %hd %hd\", &x1, &y1, &x2, &y2);\n            x1++;\n            x2++;\n            y1++;\n            y2++;\n            if (min_x1 > x1) min_x1 = x1;\n            if (max_x2 < x2) max_x2 = x2;\n            if (min_y1 > y1) min_y1 = y1;\n            if (max_y2 < y2) max_y2 = y2;\n        \tvariation_inc(x1, y1);\n        \tvariation_dec(x1, y2);\n        \tvariation_dec(x2, y1);\n        \tvariation_inc(x2, y2);\n        }\n\n        for (i=0;i<10002;i++) {\n            short j;\n            for (j=0;j<10002;j++) {\n                tiles[i][j] = 0;\n            }\n        }\n    \t\n        pre_process();\n\n        printf(\"%d\\n\", surface());\n\n        if (r == 2) {\n            printf(\"%d\\n\", perimeter());\n        }        \n    \t\n    \tdelete variation;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp( const P &p , const P &q ){\n    return p < q;\n}\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r,n|r){\n    vector<P>vx[10001],vy[10001];\n    \n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      for(int j=x1;j<x2;j++)\n\tvx[j].push_back(make_pair(y1,y2));\n\n      if(r==2)\n\tfor(int j=y1;j<y2;j++)\n\t  vy[j].push_back(make_pair(x1,x2));\n    }\n\n    int S=0,L=0;\n\n    for(int i=0;i<10000;i++)\n\tsort(vx[i].begin(),vx[i].end(),cmp);\n \n    for(int i=0;i<10000;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      for(int i=0;i<10000;i++)\n\t  sort(vy[i].begin(),vy[i].end(),cmp);\n      \n      for(int i=0;i<10000;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAX 10000\n//int 4byte\n//データ構造 R（左下，右上）,(LorR，左端ｘ座標，Rx)\n//参考：蟻231 233\n//ｘ毎のmin maxを記録\n//vectorに入れてソート\n\nusing namespace std;\nvector< vector<char> > square(MAX+1, vector<char>(MAX+1));\nint main(){\n    while(1){\n        for(int i=0;i<MAX+1;i++)\n            for(int j=0;j<MAX+1;j++)\n                square[i][j] = 0;\n        int mode, num, area = 0, len = 0 ,count, countL, countR;\n        int x, y, xx, yy;\n        int MAX_X = 0, MAX_Y = 0;\n        cin >> num >> mode;\n        if(num == 0 && mode == 0)break;\n        \n        for (int i = 0; i<num; i++){\n            cin >> x >> y >> xx >> yy;\n            for(int dx=x;dx<xx;dx++){\n                square[dx][y] += 1;\n                square[dx][yy] += -1;\n            }\n        }\n        for(int dx=0;dx<MAX+1;dx++){\n            count = 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[dx][dy];\n                if(count > 0) area++;\n            }\n        }\n        cout << area <<endl;\n        \n        \n        if(mode == 2){\n            //左端\n            count = 0;\n            countR= 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[0][dy];\n                countR+= square[1][dy];\n                if(count > 0) len++;\n                if(count > 0 && count == square[0][dy])len++;\n                if(count > 0 && countR < 1)len++;\n                if(count == 0 && square[0][dy] < 0)len++;\n            }\n            //中\n            for(int dx=1;dx<MAX;dx++){\n                countL= 0;\n                count = 0;\n                countR= 0;\n                for(int dy=0;dy<MAX+1;dy++){\n                    countL+= square[dx-1][dy];\n                    count += square[dx][dy];\n                    countR+= square[dx+1][dy];\n                    if(count > 0 && countL < 1)len++;\n                    if(count > 0 && countR < 1)len++;\n                    if(count > 0 && count == square[dx][dy])len++;\n                    if(count == 0 && square[dx][dy] < 0)len++;\n                }\n            }\n            //右端\n            count = 0;\n            countL= 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[MAX][dy];\n                countL+= square[MAX-1][dy];\n                if(count > 0) len++;\n                if(count > 0 && count == square[MAX][dy])len++;\n                if(count > 0 && countL < 1)len++;\n                if(count == 0 && square[MAX][dy] < 0)len++;\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n#define fir first\n#define sec second\n\nconst int N = 10010;\n\ntypedef pair<short,short> pii;\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<pii> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<pii> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,IN[j].size()){\n\tshort Y1 = y1[i],Y2=y2[i];\n\tshort &Y3=IN[j][k].fir;\n\tshort &Y4=IN[j][k].sec;\n\tif (Y4 <= Y1 || Y2 <= Y3)continue;\n\tisin=true;\n\tY3=min(Y1,Y3);\n\tY4=max(Y2,Y4);\n\tbreak;\n      }\n      if (!isin)IN[j].pb(mp(y1[i],y2[i]));\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<pii> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].fir,&nowh=in[i][j].sec;\n      if (nowl > h){\n\tlen+=2*width;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint map[10000][10000];\n\nint main(void){\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nmain(){\n  printf(\" \");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    // repeat_with_index(y_size, y_i) {\n    //   // update right_area_end_point\n    //   auto points = find_end_points(x_i, y_i);\n\n    //   // per point operation\n    //   for (auto&& point : points) {\n    //     int x = point.first, y = point.second;\n\n    //     repete_from_to(y_i, y - 1, p_i) {\n    //       assign_if_larger(right_area_end_point[p_i], x);\n    //     }\n    //   }\n    // }\n\n    // repeat_with_index(y_size, y_i) {\n\n    //   // included in some sheets\n    //   if (right_area_end_point[y_i] > x_i) {\n    //     area += 1;\n    //     is_area[x_i % 2][y_i] = true;\n    //   } else {\n    //     is_area[x_i % 2][y_i] = false;\n    //   }\n\n    //   // line check\n    //   if (type == 2) {\n    //     // left line exists\n    //     if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n    //     // bottom line exists\n    //     if (\n    //         (y_i == 0 && is_area[x_i % 2][y_i]) ||\n    //         (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n    //         )\n    //       lines += 1;\n    //   }\n    // }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (height != a.height)return height < a.height;\n  return out > a.out;\n}\n\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nvoid sl(int p[][4],int Mx,int My,int n,int r){\n  int f[Mx][My];\n  int i,j,k;\n  int s,l;\n  s = l = 0;\n  for(i=0;i<Mx;i++){\n    for(j=0;j<My;j++){\n      f[i][j] = 0;\n    }\n  }\n  for(k=0;k<n;k++){\n    for(i=p[k][0];i<p[k][2];i++){\n      for(j=p[k][1];j<p[k][3];j++){\n        if(f[i][j]==0){\n          s++;\n        }\n        f[i][j] = 1;\n      }\n    }\n  } \n  printf(\"%d\\n\",s);\n  if(r==2){\n    for(i=0;i<Mx-1;i++){\n      l+=(f[i][0]+f[i][Mx-1]);\n      for(j=0;j<My-1;j++){\n        l+=(f[i][j]^f[i][j+1]);\n      }\n    }\n    for(j=0;j<My-1;j++){\n      l+=(f[0][j]+f[My-1][j]);\n      for(i=0;i<Mx-1;i++){\n        l+=(f[i+1][j]^f[i][j]);\n      }\n    }\n    printf(\"%d\\n\",l);\n  }\n}\nint main(){\n  int n,r;\n  int i,j,k;\n  int Mx,My;\n  int p[10000][4];\n  scanf(\"%d %d\",&n,&r);\n  while(n!=0&&r!=0){\n    Mx = My = 100;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&p[k][0],&p[k][1],&p[k][2],&p[k][3]);\n      if(p[k][2]>Mx){\n        Mx = p[k][2];\n      }\n      if(p[k][3]>My){\n        My = p[k][3];\n      }      \n    }\n    sl(p,Mx,My,n,r);\n    scanf(\"%d %d\",&n,&r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (height != a.height)return height < a.height;\n  return out > a.out;\n}\n\n\nshort  isexist[N]={0};\nshort testcase=0;\nshort x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,short *x1,short *x2,short *y1,short *y2,\n\t      int &px,short *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,short *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static short x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tmemset(g,0,sizeof(g));\n\t\tint mx = 10001,Mx = 1,my = 10001,My = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\ta++;b++;c++;d++;\n\t\t\tg[a][b]++; g[a][d]--;\n\t\t\tg[c][b]--; g[c][d]++;\n\t\t\tmx = min(mx,a);\n\t\t\tMx = max(Mx,c);\n\t\t\tmy = min(my,b);\n\t\t\tMy = max(My,d);\n\t\t}\n\t\t\n\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\tint t = 0;\n\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tg[i][j] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s = 0;\n\t\tfor(int j = my; j <= My; j++){\n\t\t\tint t = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tif(g[i][j] = t)s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t\t\n\t\tif(r==2){\n\t\t\tint l = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\t\tif(g[i][j]){\n\t\t\t\t\t\tl += !g[i-1][j]+!g[i+1][j]+!g[i][j-1]+!g[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n#define fir first\n#define sec second\n\nconst int N = 10010;\n\ntypedef pair<int,int> pii;\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<pii> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<pii> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,IN[j].size()){\n\tshort Y1 = y1[i],Y2=y2[i];\n\tshort &Y3=IN[j][k].fir;\n\tshort &Y4=IN[j][k].sec;\n\tif (Y4 <= Y1 || Y2 <= Y3)continue;\n\tisin=true;\n\tY3=min(Y1,Y3);\n\tY4=max(Y2,Y4);\n\tbreak;\n      }\n      if (!isin)IN[j].pb((st){y1[i],y2[i]});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].fir,&nowh=in[i][j].end;\n      if (nowl >= h || nowh > h){\n\tif (nowl > h)len+=2*width;\n\tarea+=(nowh-nowl)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tg[x1][y1]+=1;\n\t\t\tg[x2][y1]-=1;\n\t\t\tg[x1][y2]-=1;\n\t\t\tg[x2][y2]+=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nmap<short,map<short,short> > fie;\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tfie.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n,x1[10000],y1[10000],x2[10000],y2[10000];\n\nint calc_area(){\n\tint ans=0,imos[10001];\n\trep(y,10000){\n\t\tmemset(imos,0,sizeof imos);\n\t\trep(i,n) if(y1[i]<=y && y<y2[i]) {\n\t\t\timos[x1[i]]++;\n\t\t\timos[x2[i]]--;\n\t\t}\n\t\trep(x,10000){\n\t\t\timos[x+1]+=imos[x];\n\t\t\tif(imos[x]>0) ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint calc_peri(){\n\tint ans=0,imos[10001];\n\trep(t,2){\n\t\trep(y,10000){\n\t\t\tmemset(imos,0,sizeof imos);\n\t\t\trep(i,n) if(y1[i]<=y && y<y2[i]) {\n\t\t\t\timos[x1[i]]++;\n\t\t\t\timos[x2[i]]--;\n\t\t\t}\n\t\t\trep(x,10000) imos[x+1]+=imos[x];\n\t\t\trep(x,10001) if(imos[x]>0) {\n\t\t\t\tif(x==  0   || imos[x-1]==0) ans++;\n\t\t\t\tif(x==10000 || imos[x+1]==0) ans++;\n\t\t\t}\n\t\t}\n\n\t\trep(i,n){\n\t\t\tswap(x1[i],y1[i]);\n\t\t\tswap(x2[i],y2[i]);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(int type;scanf(\"%d%d\",&n,&type),n;){\n\t\trep(i,n) scanf(\"%d%d%d%d\",x1+i,y1+i,x2+i,y2+i);\n\t\tprintf(\"%d\\n\",calc_area());\n\t\tif(type==2) printf(\"%d\\n\",calc_peri());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    // repeat_with_index(y_size, y_i) {\n\n    //   // included in some sheets\n    //   if (right_area_end_point[y_i] > x_i) {\n    //     area += 1;\n    //     is_area[x_i % 2][y_i] = true;\n    //   } else {\n    //     is_area[x_i % 2][y_i] = false;\n    //   }\n\n    //   // line check\n    //   if (type == 2) {\n    //     // left line exists\n    //     if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n    //     // bottom line exists\n    //     if (\n    //         (y_i == 0 && is_area[x_i % 2][y_i]) ||\n    //         (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n    //         )\n    //       lines += 1;\n    //   }\n    // }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X1[10010], X2[10010], Y1[10010], Y2[10010];\nint n, r, p[3][10010];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> r; if (n == 0 && r == 0)break;\n\t\tint maxx = 0, maxy = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\t\t\tif (X2[i] > maxx)maxx = X2[i];\n\t\t\tif (Y2[i] > maxy)maxy = Y2[i];\n\t\t}\n\t\tint cnt1 = 0, cnt2 = 0;\n\t\tfor (int i = 0; i < maxx + 10; i++) {\n\t\t\tfor (int j = 0; j < 30030; j++)p[j / 10010][j % 10010] = 0;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tint G = i + j, H = j + 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (X1[k] <= G && G < X2[k]) {\n\t\t\t\t\t\tp[H][Y1[k]]++; p[H][Y2[k]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 1; k < 10010; k++)p[j][k] += p[j][k - 1];\n\t\t\t}\n\t\t\tfor (int j = 0; j < maxy + 10; j++) {\n\t\t\t\tif (p[1][j] >= 1)cnt1++;\n\t\t\t\tif (i == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\tif (p[1][j] == 0 && p[2][j] >= 1)cnt2++;\n\t\t\t\tif (p[1][j] >= 1 && p[2][j] == 0)cnt2++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < maxy + 10; j++) {\n\t\t\t\tif (j == 0 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j == 10009 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j >= 1 && j <= 10008) {\n\t\t\t\t\tif (p[1][j] >= 1 && p[1][j + 1] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j] == 0 && p[1][j + 1] >= 1)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 1)cout << cnt1 << endl;\n\t\tif (r == 2)cout << cnt1 << endl << cnt2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[10002];\nvector<P> xx[10002];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 10002; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tx[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n      x[i].clear();\n      //x[i].clear();\n      /*\n      cout << \"x = \" << i << endl;\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tcout << \"( \" << xx[i][j].F << \" , \" << xx[i][j].S << \" )\" << endl;\n      }\n      cout << endl;\n      //*/\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st & a)const{\n    if (beg != a.beg)return beg < a.beg;\n    return end < a.end;\n  }\n};\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,IN[j].size()){\n\tshort Y1 = y1[i],Y2=y2[i];\n\tshort &Y3=IN[j][k].beg;\n\tshort &Y4=IN[j][k].end;\n\tif (Y4 <= Y1 || Y2 <= Y3)continue;\n\tisin=true;\n\tY3=min(Y1,Y3);\n\tY4=max(Y2,Y4);\n\tbreak;\n      }\n      if (!isin)IN[j].pb((st){y1[i],y2[i]});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      if (nowl > h){\n\tlen+=2*width;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint main()\n{\nint n,r;\ncin >> n >> r;\nint m[10010][10010];\nmemset(m,0,sizeof(m));\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nbool Compare(const P &p1,const P &p2){\n\treturn p1.F_<p2.F_;\n}\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<vector<P> > &range){\n\tint result=0;\n\tREP(x,0,10010){\n\t\tint index=0,y=0;\n\t\twhile(index<range[x].size()){\n\t\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y) ++result;\n\t\t\t++index;\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid Add(vector<vector<P> > &range,vector<vector<unsigned char> > &cnt,int x,int &result){\n\tint index=0,y=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(cnt[(x-1)%3][y]==0) ++result;\n\t\t\tif(cnt[(x+1)%3][y]==0) ++result;\n\t\t\tif(cnt[x%3][y-1]==0) ++result;\n\t\t\tif(cnt[x%3][y+1]==0) ++result;\n\t\t}\n\t\t++index;\n\t}\n}\n\nint CalcLength(vector<vector<P> > &range){\n\tint result=0;\n\tvector<vector<unsigned char> > cnt(3,vector<unsigned char>(10010));\n\tREP(x,1,10009){\n\t\tif(x-2>=0) fill(cnt[(x-2)%3].begin(),cnt[(x-2)%3].end(),0);\n\t\tint index=0,y=0;\n\t\twhile(index<range[x+1].size()){\n\t\t\tfor(y=max(y,range[x+1][index].F_); y<range[x+1][index].S_; ++y) ++cnt[(x+1)%3][y];\n\t\t\t++index;\n\t\t}\n\t\tAdd(range,cnt,x,result);\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tvector<vector<P> > range(10010);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tREP(x,x1+4,x2+4) range[x].push_back(MP(y1+4,y2+4));\n\t\t}\n\t\tREP(x,0,10010) sort(range[x].begin(),range[x].end(),Compare);\n\t\tcout << CalcSize(range) << endl;\n\t\tif(R==2) cout << CalcLength(range) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    vector<pair<short,short> >v[10000];\n    for(int i=0;i<n;i++){\n      int x,y,xx,yy;\n      cin>>x>>y>>xx>>yy;\n      for(int j=y;j<yy;j++){\n\tv[j].push_back(make_pair(x,xx));\n      }\n    }\n    for(int i=0;i<10000;i++){\n      sort(v[i].begin(),v[i].end());\n      for(int j=0;j<v[i].size();j++){\n\tint m=v[i][j].second;\n\tint k;\n\tfor(k=j+1;k<v[i].size()&&v[i][k].first<=m;k++){\n\t  m=max(m,v[i][k].second);\n\t}\n\tv[i][j].second=m;\n\tv[i].erase(v[i].begin()+j+1,v[i].begin()+k);\n      }\n    }\n    int a=0;\n    for(int i=0;i<10000;i++){\n      for(int j=0;j<v[i].size();j++){\n\ta+=v[i][j].second-v[i][j].first;\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      bool b[2][10000]={};\n      for(int i=0;i<10000;i++){\n\tl+=v[i].size()*2;\n\tfill(b[i&1],b[(i&1)+1],false);\n\tfor(int j=0;j<v[i].size();j++){\n\t  for(int k=v[i][j].first;k<v[i][j].second;k++){\n\t    b[i&1][k]=true;\n\t  }\n\t}\n\tfor(int j=0;j<10000;j++){\n\t  l+=b[i&1][j]^b[!(i&1)][j];\n\t}\n      }\n      l+=count(b[1],b[2],true);\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  //bool operator<(const st&)const;\n  bool operator<(const st & a)const{\n  if (height != a.height)return height < a.height;\n  return out > a.out;\n}\n\n};\n\n\n\nint x[N];\nvector<st> inx[N];\n\n//int y[N];\n//vector<st> iny[N];\n\n/*\n29\n29\n80\n45\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *X,vector<st> *IN){\n  //vector<int> xd;\n  static int xd[N];\n  int p=0;\n  rep(i,n){\n    //xd.pb(x1[i]);\n    //xd.pb(x2[i]);\n    xd[p++]=x1[i];\n    xd[p++]=x2[i];\n  }\n  //sort(ALL(xd));\n  sort(xd,xd+p);\n  //xd.erase(unique(ALL(xd)),xd.end());\n  p=unique(xd,xd+p)-xd;\n  //rep(i,xd.size())X[px++]=xd[i],IN[i].clear();\n  rep(i,p)X[px++]=xd[i],IN[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    //int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    int j=lower_bound(xd,xd+p,x1[i])-xd;\n    while(j < px && x[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct manip{\n    int y;\n    int xs,xt;\n    int val;\n    manip(int y, int xs, int xt, int val):y(y),xs(xs),xt(xt),val(val){}\n    manip(){}\n    bool operator <(const manip &a){\n        return y < a.y;\n    }\n};\nconst int size = 10003;\nint field[2][10003];\nmanip q[20001];\n\nint main(){\n    while(1){\n        int n,r;\n        scanf(\"%d%d\", &n, &r);\n        if(r==0) break;\n\n        memset(field, 0, sizeof(field));\n        for(int i=0; i<n; i++){\n            int xs,ys,xt,yt;\n            scanf(\"%d%d%d%d\", &xs, &ys, &xt, &yt);\n            xs++; ys++; xt++; yt++;\n            q[2*i] = manip(ys, xs, xt, 1);\n            q[2*i +1] = manip(yt, xs, xt, -1);\n        }\n        sort(q, q +2*n);\n        q[2*n].y = 1e9;\n\n        int area = 0;\n        int outlen = 0;\n        int pt = 0;\n        for(int i=0; i<size; i++){\n            memcpy(field[i%2], field[1-i%2], sizeof(int)*size/*sizeof(field[0])*/);\n            bool changed = false;\n            int diff[10003] = {};\n            while(q[pt].y == i){\n                changed = true;\n                diff[q[pt].xs] += q[pt].val;\n                diff[q[pt].xt] -= q[pt].val;\n                pt++;\n            }\n            if(changed){\n                for(int j=0; j<size -1; j++){\n                    diff[j+1] += diff[j];\n                    field[i%2][j] += diff[j];\n                }\n            }\n            for(int j=0; j<size -1; j++){\n                if(field[i%2][j] > 0) area++;\n                if((field[i%2][j]==0) != (field[i%2][j+1]==0)) outlen++;\n                if((field[0][j]==0) != (field[1][j]==0)) outlen++;\n            }\n        }\n        printf(\"%d\\n\", area);\n        if(r==2){\n            printf(\"%d\\n\", outlen);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nstatic vector<pair<P,P> >in;\nstatic vector<P> v[10001];\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n      int b=v[i][0].first,e=v[i][0].second;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].first,E=v[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<in.size();i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].first,e=v[i][0].second;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].first,E=v[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  // delete is_area[0];\n  // delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nvector<T> vec;\nint imos[2][10004];\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(imos,0,sizeof(imos));\n\t\tarea=0;len=0;\n\t\tle=down=INF;\n\t\tri=up=1;\n\t\tvec.clear();\n\t\tcin >> n >> r;\n\t\tif(n==0&&r==0)break;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta++;b++;c++;d++;\n\t\t\tri=max(ri,c);\n\t\t\tle=min(le,a);\n\t\t\tup=max(up,d);\n\t\t\tdown=min(down,b);\n\t\t\tvec.pb(T(P(a,b),1));\n\t\t\tvec.pb(T(P(a,d),-1));\n\t\t\tvec.pb(T(P(c,b),-1));\n\t\t\tvec.pb(T(P(c,d),1));\n\t\t}\n\t\tvec.pb(T(P(INF,INF),INF));\n\t\tSORT(vec);\n\t\tint index=0;\n\t\tfor(int i=le;i<=ri+1;i++)\n\t\t{\n\t\t\tfor(int j=down;j<=up+1;j++)\n\t\t\t{\n\t\t\t\timos[i%2][j]=imos[i%2][j-1];\n\t\t\t\twhile(vec[index].fi==P(i,j))imos[i%2][j]+=vec[index++].sec;\n\t\t\t}\n\t\t\tfor(int j=down;j<=up+1;j++)\n\t\t\t{\n\t\t\t\timos[i%2][j]+=imos[(i-1)%2][j];\n\t\t\t\tif(imos[i%2][j]>0)area++;\n\t\t\t\tif(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n\t\t\t\tif(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n\t\t\t\tcout << imos[i%2][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << area << endl;\n\t\tif(r==2)cout << len << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nint main()\n{\n    int n, r;\n    while (scanf(\"%d%d\", &n, &r), n)\n    {\n        vector<int> in[10010], out[10010];\n        int x1[10010], y1[10010], x2[10010], y2[10010];\n        int min_x = 1e9, max_x = 0, min_y = 1e9, max_y = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            scanf(\"%d%d%d%d\", x1 + i, y1 + i, x2 + i, y2 + i);\n            min_swap(min_x, ++x1[i]);\n            min_swap(min_y, ++y1[i]);\n            max_swap(max_x, ++x2[i]);\n            max_swap(max_y, ++y2[i]);\n\n            in[y1[i]].push_back(i);\n            out[y2[i]].push_back(i);\n        }\n\n        int a[2][10100] = {};\n\n        set<int> u;\n        int area = 0, len = 0;\n        for (int y = min_y; y <= max_y; ++y)\n        {\n            int* cur = a[y & 1];\n            int* prev = a[!(y & 1)];\n\n            for (int i = 0; i < out[y].size(); ++i)\n                u.erase(out[y][i]);\n            for (int i = 0; i < in[y].size(); ++i)\n                u.insert(in[y][i]);\n\n            fill(cur + (min_x - 1), cur + (max_x + 1), 0);\n            foreach (it, u)\n            {\n                int i = *it;\n                max_swap(cur[x1[i]], x2[i] - x1[i]);\n            }\n\n            for (int x = min_x; x <= max_x; ++x)\n            {\n                if (cur[x] == 0)\n                {\n                    if (cur[x - 1] > 0)\n                        ++len;\n                    if (prev[x] > 0)\n                        ++len;\n                }\n                else\n                {\n                    if (cur[x - 1] == 0)\n                        ++len;\n                    if (prev[x] == 0)\n                        ++len;\n                    ++area;\n\n                    max_swap(cur[x + 1], cur[x] - 1);\n                }\n            }\n        }\n\n        if (r == 1)\n            printf(\"%d\\n\", area);\n        else\n            printf(\"%d\\n%d\\n\", area, len);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nbool a[10003][10003];\nint dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};\n\nint main(void){\n\n  int n,r,ax,ay,bx,by;\n\n  while(cin >> n >> r,n|r){\n  \n    for(int i=0;i<10003;i++)\n      for(int j=0;j<10003;j++)a[i][j]=false;\n\n    for(int i=0;i<n;i++){\n      cin >> ax >> ay >> bx >> by;\n      for(int j=ax+1;j<=bx;j++)\n\tfor(int k=ay+1;k<=by;k++)a[j][k]=true;\n    }\n    int cnt=0;\n    for(int i=1;i<10002;i++)\n      for(int j=1;j<10002;j++)\n\tif(a[i][j])cnt++;\n    \n    cout << cnt << endl;\n    \n    if(r==2){\n      int cnt2=0;\n      for(int i=1;i<10002;i++)\n\tfor(int j=1;j<10002;j++)\n\t  for(int k=0;k<4;k++)\n\t    if(a[i][j] && !a[i+dx[k]][j+dy[k]])cnt2++;\n      \n      cout << cnt2 << endl;\n    }\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<list>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define S second\n#define F first\nstruct Rect{\n  int x1,y1,x2,y2;\n  Rect(){}\n  Rect(int x1,int y1,int x2,int y2) : x1(x1),y1(y1),x2(x2),y2(y2) {}\n  bool operator < (const Rect& oth)const{\n    if(y2 == oth.y2){\n      return y1 < oth.y1;\n    }\n    return y2 < oth.y2;\n  }\n};\nstruct Act{\n  int up,down;\n  Act(){}\n  Act(int up,int down) : up(up),down(down) {}\n};\nint N,R;\nRect S[10002];\nvector<Act> A[10002];\nint main(){\n  while(1){\n    scanf(\"%d %d\",&N,&R);\n    if(!N && !R) break;\n    int minx=100000,maxx=0;\n    for(int i=0;i<N;i++){\n      scanf(\"%d %d %d %d\",&S[i].x1,&S[i].y1,&S[i].x2,&S[i].y2);\n      minx = min(S[i].x1,minx); maxx = max(S[i].x2,maxx);\n    }\n    sort(S,S+N);\n    for(int i=N-1;i>-1;i--){\n      //      printf(\"%d %d %d %d\\n\",S[i].x1,S[i].y1,S[i].x2,S[i].y2);\n      for(int x = S[i].x1; x < S[i].x2; x++){\n\tif(A[x].empty()){\n\t  A[x].push_back(Act(S[i].y2,S[i].y1));\n\t} else {\n\t  int dw = A[x].back().down;\n\t  if(dw > S[i].y2){\n\t    A[x].push_back(Act(S[i].y2,S[i].y1));\n\t  } else if ( dw > S[i].y1 )\n\t    A[x].back().down = S[i].y1;\n\t}\n      }\n    }\n    int res1=0;\n    int res2=0;\n    int sump=0;\n    for(int i=0;i<(int)A[minx].size();i++){\n      res1 += (A[minx][i].up - A[minx][i].down);\n      res2 += (A[minx][i].up - A[minx][i].down);\n    }\n    sump = res2;\n    res2 += (int)A[minx].size() * 2;\n    for(int i=minx+1; i<=maxx; i++){\n      int l=0;\n      int sumk=0;\n      int sumn=0;\n      //      printf(\"%d %d\\n\",res1,res2);\n      for(int j=0;j<(int)A[i].size();j++){\n\tres1 += (A[i][j].up - A[i][j].down);\n\tsumn += (A[i][j].up - A[i][j].down);\n\tbool f=false;\n\tdo{\n\t  f=false;\n\t  if(A[i-1][l].up == A[i][j].up){\n\t    if(A[i-1][l].down >= A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    }else{\n\t      sumk += (A[i][j].up - A[i][j].down);\n\t    }\n\t  } else if(A[i-1][l].up > A[i][j].up && A[i][j].up > A[i-1][l].down){\n\t    if(A[i-1][l].down == A[i][j].down){\n\t      sumk += (A[i][j].up-A[i][j].down);\n\t      f=true;\n\t    }else if(A[i-1][l].up > A[i][j].down && A[i][j].down > A[i-1][l].down){\n\t      sumk += (A[i][j].up - A[i][j].down);\n\t    } else{\n\t      sumk += (A[i][j].up - A[i-1][l].down);\n\t      f=true;\n\t    }\n\t  } else if(A[i][j].up > A[i-1][l].up && A[i-1][l].up > A[i][j].down){\n\t    if(A[i-1][l].down == A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    }else if(A[i][j].up > A[i-1][l].down && A[i-1][l].down > A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    } else {\n\t      sumk += (A[i-1][l].up - A[i][j].down);\n\t    }\n\t  } else if(A[i-1][l].down >= A[i][j].up) f=true;\n\t  if(f) l++;\n\t} while(f && l < (int)A[i-1].size());\n      }\n      res2 += (sump - sumk);\n      res2 += (sumn - sumk);\n      res2 += (int)A[i].size()*2;\n      sump = sumn;\n    }\n    printf(\"%d\\n\",res1);\n    if(R==2) printf(\"%d\\n\",res2);\n\n    for(int i=minx; i<=maxx; i++) A[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      // for (auto&& point : points) {\n      //   int x = point.first, y = point.second;\n\n      //   repete_from_to(y_i, y - 1, p_i) {\n      //     assign_if_larger(right_area_end_point[p_i], x);\n      //   }\n      // }\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      // if (type == 2) {\n      //   // left line exists\n      //   if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n      //   // bottom line exists\n      //   if (\n      //       (y_i == 0 && is_area[x_i % 2][y_i]) ||\n      //       (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n      //       )\n      //     lines += 1;\n      // }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509>\n?????????============================================================\n?????¢???????????¢??????????????????????????????????????????.???????????????????????§????????????????????¨????????¢????????¨???????±???????????????°?????????????????????.\n?????????, ?????¢?????§?¨??????¢??¨??????????????¨???, ??????????????????????¬?????????¶ (1), (2) ????????????????????¨??????.\n(1) ???????????????????????¢??? 4 ????????? x, y ??§?¨??????¨??? 0 ??\\??? 10000 ??\\????????´??°??§??????,\n    ????????¢???????????? x ???, ????????? y ??????????????§??????.\n(2) ?????????????????°????????? 10000 ?????\\?????§??????.\n??\\???????????? ??? 1 ?????????????????¢????????° n ??¨??????????¨?????????¨?????´??° r ???????????§????????£?????????????????????.\n2 ????????\\??????????????????, ?????????????????????????????§?¨? (x1, y1) ??¨??????????????§?¨? (x2, y2) ?????§?¨???????\nx1, y1, x2, y2 ????????§????????§????????£??????????????????.\n\n???????????? r = 1 ?????¨??? 1 ???????????¢??????, r = 2 ?????¨??? 1 ???????????¢???, 2 ???????????¨???????????????????????????.\n??????????????´??????????????????????????\\???????????¨.\n\n=================================================================\n\n?§£??¬=============================================================\n\n================================================================\n*/\n\nint m[2][10010];\nvector<pll> ps[10010];\nint maxh, maxw;\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, r;\n\twhile (cin >> N >> r, N | r) {\n\t\tmaxh = -1, maxw = -1;\n\t\tfor (int i = 0;i < N;i++) {\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tx1++; y1++; x2++; y2++;\n\t\t\tps[y1].push_back({ x1,1 });\n\t\t\tps[y1].push_back({ x2,-1 });\n\t\t\tps[y2].push_back({ x1,-1 });\n\t\t\tps[y2].push_back({ x2,1 });\n\t\t\tmaxh = max(maxh, y2);\n\t\t\tmaxw = max(maxw, x2);\n\t\t}\n\n\t\tint Area = 0, Length = 0;\n\t\tint cur = 0, next = 1;\n\t\tfor (int i = 0; i <= maxh + 1;i++) {\n\t\t\tmemset(m[next], 0, sizeof(m[next]));\n\t\t\tfor (auto p : ps[i]) {\n\t\t\t\tm[next][p.first] += p.second; // ?´??????????????????¶???\n\t\t\t}\n\t\t\tfor (int j = 0; j <= maxw;j++) {\n\t\t\t\tm[next][j + 1] += m[next][j]; // ?´??????? ?¨?????????????\n\t\t\t\tm[next][j] += m[cur][j]; // ?´??????? ???????????????\n\t\t\t}\n\t\t\tfor (int j = 0; j <= maxw;j++) {\n\t\t\t\tif (m[next][j] > 0) Area++;\n\t\t\t\tif ((m[cur][j] > 0) != (m[next][j] > 0)) Length++;\n\t\t\t\tif ((m[next][j] > 0) != (m[next][j + 1] > 0)) Length++;\n\t\t\t}\n\t\t\tcur = !cur;\n\t\t\tnext = !next;\n\t\t}\n\t\tcout << Area << endl;\n\t\tif (r == 2) cout << Length << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nshort fie[3000][3000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nint n;\nshort min_x1, max_x2, min_y1, max_y2;\nshort x1, x2, y1, y2;\nmap<pair<short, short>, short> *variation;\nint surface_sum;\nint perimeter_sum;\n\nvoid variation_inc(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second + 1;\n    } else {\n        value = 1;\n    }\n\n    variation->erase(make_pair(x, y));\n    \n    if (value != 0) {\n        variation->insert(pair<pair<short, short>, short>(make_pair(x,y), value));\n    }\n\n    return ;\n}\n\nvoid variation_dec(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second - 1;\n    } else {\n        value = -1;\n    }\n\n    variation->erase(make_pair(x, y));\n\n    if (value != 0) {\n        variation->insert(pair<pair<short, short>, short>(make_pair(x,y), value));\n    }\n\n    return ;\n}\n\nshort variation_return(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second;\n    } else {\n        value = 0;\n    }\n\n    return value;\n}\n\nvoid surface(short calc[2][10002], int j) {\n    if (calc[1][j] > 0) surface_sum++;\n\n    return ;\n}\n\nvoid perimeter(short calc[2][10002], int j) {\n    if (calc[1][j] + calc[1][j-1] > 0 && (calc[1][j] == 0 || calc[1][j-1] == 0)) perimeter_sum++;\n\n    if (calc[1][j] + calc[0][j] > 0 && (calc[1][j] == 0 || calc[0][j] == 0)) perimeter_sum++;\n\n    return ;\n}\nvoid process() {\n    short i;\n    short calc[2][10002];\n    \n    for (i=0;i<2;i++) {\n        int j;\n        for (j=0;j<10002;j++) {\n            calc[i][j] = 0;\n        }\n    }\n\n    for (i=min_y1-1;i<max_y2+1;i++) {\n        int j;\n        \n        for (j=min_x1-1;j<max_x2+1;j++) {\n            calc[1][j] = variation_return(j, i);\n\n            calc[1][j] += calc[1][j-1];\n            calc[1][j] += calc[0][j];\n            calc[1][j] -= calc[0][j-1];\n        }\n\n        for (j=min_x1;j<max_x2+1;j++) {\n            surface(calc, j);\n            perimeter(calc, j);\n            calc[0][j] = calc[1][j];\n        }\n    }\n\n    return;\n}\n\n\n\nint main() {\n    while (1) {\n        short i;\n        int r;\n\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r ==0) return 0;\n\n        variation = new map<pair<short, short>, short>();\n\n        min_x1 = 10000;\n        min_y1 = 10000;\n        max_x2 = 0;\n        max_y2 = 0;\n        for (i=0;i<n;i++) {\n            scanf(\"%hd %hd %hd %hd\", &x1, &y1, &x2, &y2);\n            x1++;\n            x2++;\n            y1++;\n            y2++;\n            if (min_x1 > x1) min_x1 = x1;\n            if (max_x2 < x2) max_x2 = x2;\n            if (min_y1 > y1) min_y1 = y1;\n            if (max_y2 < y2) max_y2 = y2;\n            variation_inc(x1, y1);\n            variation_dec(x1, y2);\n            variation_dec(x2, y1);\n            variation_inc(x2, y2);\n        }\n        surface_sum = 0;\n        perimeter_sum = 0;\n\n        process();\n\n        printf(\"%d\\n\", surface_sum);\n\n        if (r == 2) {\n            printf(\"%d\\n\", perimeter_sum);\n        }        \n        \n        delete variation;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// imos kyoukai -> subtraction \n// MLEのため row by row \n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\nconst int inf=1e9+7;\nconst ll INF=1LL<<61;\nconst ll mod=1e9+7;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint f[2][10101]; \nvector<P> p[10101];\n\nint main(){\n    int i,j;\n    int n,q;\n    while(1){\n        cin>>n>>q;\n        if(n==0) break;\n        memset(f,0,sizeof(f));\n        for(i=0;i<10101;i++) p[i].clear();\n        int h=0,w=0;\n        for(i=0;i<n;i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            a++;\n            b++;\n            c++;\n            d++;\n            p[b].pb(P(a,1));\n            p[b].pb(P(c,-1));\n            p[d].pb(P(a,-1));\n            p[d].pb(P(c,1));\n            h = max(h, d);\n            w = max(w, c);\n        }\n        int area = 0;\n        int length = 0;\n        for(i=0;i<h+2;i++){\n            memset(f[1], 0, sizeof(f[1]));\n            for(P u:p[i]) f[1][u.fi]+=u.se;\n            for(j=0;j<w+1;j++){\n                f[1][j+1]+=f[1][j];\n            }\n            for(j=0;j<w+2;j++){\n                f[1][j]+=f[0][j];\n            }\n            for(j=0;j<w+2;j++){\n                if(f[1][j]) area++;\n                //if(f[1][j]) cout<<i<<\" \"<<j<<endl;\n                if((f[0][j] > 0) != (f[1][j] > 0)) length++;\n                if((f[1][j] > 0) != (f[1][j+1] > 0)) length++;\n            }\n            swap(f[0],f[1]);\n        }\n        cout<<area<<endl;\n        if(q==2) cout<<length<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nint n;\nshort min_x1, max_x2, min_y1, max_y2;\nshort x1[10000], x2[10000], y1[10000], y2[10000];\nmap<pair<short, short>, short> *variation;\nchar tiles[10002][10002];\n\nvoid variation_inc(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second + 1;\n    } else {\n        value = 1;\n    }\n\n    variation->erase(make_pair(x, y));\n\t\n    if (value != 0) {\n    \tvariation->insert(pair<pair<short, short>, short>(make_pair(x,y), value));\n    }\n\n    return ;\n}\n\nvoid variation_dec(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n        value = location->second - 1;\n    } else {\n        value = -1;\n    }\n\n    variation->erase(make_pair(x, y));\n\n    if (value != 0) {\n    \tvariation->insert(pair<pair<short, short>, short>(make_pair(x,y), value));\n    }\n\n    return ;\n}\n\nshort variation_return(short x, short y) {\n    short value;\n    map<pair<short, short>, short>::iterator location;\n\n    location = variation->find(make_pair(x, y));\n    if (location != variation->end()) {\n    \tvalue = location->second;\n    } else {\n        value = 0;\n    }\n\n    return value;\n}\n\nvoid pre_process() {\n    short i;\n    short calc[2][10002];\n\t\n\tfor (i=0;i<2;i++) {\n        int j;\n        for (j=0;j<10002;j++) {\n            calc[i][j] = 0;\n        }\n\t}\n\n    for (i=0;i<n;i++) {\n        variation_inc(x1[i], y1[i]);\n        variation_dec(x1[i], y2[i]);\n        variation_dec(x2[i], y1[i]);\n        variation_inc(x2[i], y2[i]);\n    }\n\n    for (i=min_y1-1;i<max_y2+1;i++) {\n        int j;\n        \n        for (j=min_x1-1;j<max_x2+1;j++) {\n            calc[1][j] = variation_return(j, i);\n\n            calc[1][j] += calc[1][j-1];\n            calc[1][j] += calc[0][j];\n        \tcalc[1][j] -= calc[0][j-1];\n        }\n\n        for (j=min_x1;j<max_x2+1;j++) {\n            tiles[i][j] = ((calc[0][j] > 0) ? 1 : 0);\n            calc[0][j] = calc[1][j];\n        }\n    }\n\n    return;\n}\n\nint surface() {\n    short i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2+1;i++) {\n        int j;\n        for (j=min_x1;j<max_x2+1;j++) {\n            if (tiles[i][j]) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint perimeter() {\n    short i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2+2;i++) {\n        short j;\n        for (j=min_x1;j<max_x2+2;j++) {\n            if (tiles[i][j] + tiles[i-1][j] == 1) {\n                sum++;\n            }\n\n            if (tiles[i][j] + tiles[i][j-1] == 1) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while (1) {\n        short i;\n        int r;\n\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r ==0) return 0;\n\n    \tvariation = new map<pair<short, short>, short>();\n\n        min_x1 = 10000;\n        min_y1 = 10000;\n        max_x2 = 0;\n        max_y2 = 0;\n        for (i=0;i<n;i++) {\n            scanf(\"%hd %hd %hd %hd\", &x1[i], &y1[i], &x2[i], &y2[i]);\n            x1[i]++;\n            x2[i]++;\n            y1[i]++;\n            y2[i]++;\n            if (min_x1 > x1[i]) min_x1 = x1[i];\n            if (max_x2 < x2[i]) max_x2 = x2[i];\n            if (min_y1 > y1[i]) min_y1 = y1[i];\n            if (max_y2 < y2[i]) max_y2 = y2[i];\n        }\n\n        for (i=0;i<10002;i++) {\n            short j;\n            for (j=0;j<10002;j++) {\n                tiles[i][j] = 0;\n            }\n        }\n    \t\n        pre_process();\n\n        printf(\"%d\\n\", surface());\n\n        if (r == 2) {\n            printf(\"%d\\n\", perimeter());\n        }        \n    \t\n    \tdelete variation;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint bit_n;\nint dat[10010];\nvoid init(int n){\n    bit_n=n;\n    memset(dat,0,sizeof(dat));\n}\nvoid add(int k,int x){\n    for(k++;k<=bit_n;k+=k&-k)dat[k]+=x;\n}\nint sum(int k){\n    int ret=0;\n    for(k++;k;k-=k&-k)ret+=dat[k];\n    return ret;\n}\n\nstruct event{\n    int y,id,in;\n    event(int y,int id,int in):y(y),id(id),in(in){}\n    bool operator<(const event &e)const{\n        return y<e.y;\n    }\n};\n\nint N,r;\nvector<event>es;\nint x1[10000],y1[10000],x2[10000],y2[10000];\n\nint cnt[10010];\nvoid solve1(){\n    int ret=0;\n    for(int i=0;i<N;i++){\n        es.push_back(event(y1[i],i,1));\n        es.push_back(event(y2[i],i,0));\n    }\n\n    sort(es.begin(),es.end());\n\n    int cur=0,prevy=0;\n    while(cur<es.size()){\n        int sum=0;\n        for(int i=0;i<10010;i++)if(cnt[i])sum++;\n        ret+=sum*(es[cur].y-prevy);\n        prevy=es[cur].y;\n        int next=cur;\n        while(next<es.size()&&es[next].y==es[cur].y){\n            int id=es[next].id;\n            for(int i=x1[id];i<x2[id];i++){\n                if(es[next].in)cnt[i]++;\n                else cnt[i]--;\n            }\n            next++;\n        }\n        cur=next;\n\n    }\n\n    cout<<ret<<endl;\n}\n\nvoid solve2(){\n\n}\n\nint paint[10][10];\nint main(){\n    cin>>N>>r;\n    for(int i=0;i<N;i++){\n        cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n        x1[i]++;y1[i]++;x2[i]++;y2[i]++;\n    }\n\n    for(int k=0;k<N;k++){\n        for(int i=y1[k];i<y2[k];i++){\n            for(int j=x1[k];j<x2[k];j++){\n                paint[i][j]=min(1,paint[i][j]+1);\n            }\n        }\n    }\n    /*\n    for(int i=1;i<10;i++){\n        for(int j=1;j<10;j++){\n            cout<<paint[i][j]<<\" \";\n        }cout<<endl;\n    }\n    */\n    solve1();\n    if(r==2)solve2();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n  \n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    \n    vector<pair<P,P> > in;\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n    \n    sort(in.begin(),in.end(),cmp_x);\n    \n    int S=0,L=0;\n    vector<P>v;\n    for(int i=0;i+1<10001;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n\t//if(i<in[j].S.F)break;\n      }\n      \n      if(v.size()!=0){\n\t//sort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n    \n    \n    if(r==2){\n      \n      sort(in.begin(),in.end(),cmp_y);\n      \n      for(int i=0;i+1<10001;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\t  \n\t  if(i<in[j].F.F)break;\n\t}\n\tif(v.size()!=0){\n\t  //sort(v.begin(),v.end());\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nshort m[10003][10003] = {0};\n\nint main() {\n\tint n, r;\n\twhile (cin >> n >> r, n || r) {\n\t\tfill(&m[0][0], &m[0][0] + 10002*10002, 0);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\t++x1, ++y1;//, ++x2, ++y2;\n\t\t\tif (x2 != 0 && y2 != 0) {\n\t\t\t\t++m[y1][x1], --m[y1][x2+1];\n\t\t\t\t--m[y2+1][x1], ++m[y2+1][x2+1];\n\t\t\t}\n\t\t}\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tm[y][x+1] += m[y][x];\n\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tm[y+1][x] += m[y][x];\n\n\t\tint s = 0, l = 0;\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tif (m[y][x])\n\t\t\t\t\tl += !m[y-1][x] + !m[y+1][x] + !m[y][x-1] + !m[y][x+1],\n\t\t\t\t\t++s;\n\n\t\tcout << s << endl;\n\t\tif (r == 2) cout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[10002];\nvector<P> xx[10002];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 11111; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tx[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n      x[i].clear();\n      /*\n      cout << \"x = \" << i << endl;\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tcout << \"( \" << xx[i][j].F << \" , \" << xx[i][j].S << \" )\" << endl;\n      }\n      cout << endl;\n      //*/\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int n,r;\n    cin>>n>>r;\n    if(!(n||r))break;\n    vector<vector<pair<int,int>>> v(10001);\n    REP(i,n){\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2;\n      v[x1].emplace_back(y1,1);\n      v[x1].emplace_back(y2,-1);\n      v[x2].emplace_back(y1,-1);\n      v[x2].emplace_back(y2,1);\n    }\n    REP(i,10001)sort(begin(v[i]),end(v[i]));\n    int area = 0;\n    int circ = 0;\n    vector<int> val(10001,0);\n    REP(i,10001){\n      vector<int> tmp(10001);\n      int sum = 0;\n      int k=0;\n      REP(j,10001){\n        while(k<v[i].size()&&v[i][k].first<j)k++;\n        while(k<v[i].size()&&v[i][k].first==j){\n          sum += v[i][k].second;\n          k++;\n        }\n        tmp[j] = val[j] + sum;\n        if(tmp[j]>0)++area;\n        if((tmp[j] > 0 && val[j] == 0) || (tmp[j] == 0 && val[j] > 0))\n          circ++;\n        if(j>0&&((tmp[j]==0&&tmp[j-1]>0)||(tmp[j]>0&&tmp[j-1]==0)))\n          circ++;\n        if(j==0&&tmp[j]>0)\n          circ++;\n      }\n      swap(tmp,val);\n    }\n    cout << area << endl;\n    if(r==2)\n      cout << circ << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nint n,r;\n\nstruct block{\n\tshort x1,x2,y,f;\n};\n\nblock b[20001];\nshort fie[10000][2];\n\nbool comp(const block &b1,const block &b2){\n\treturn b1.y<b2.y;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(b,0,sizeof(b));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint y1,y2;\n\t\t\tscanf(\"%d%d%d%d\",&b[i*2].x1,&y1,&b[i*2].x2,&y2);\n\t\t\tb[i*2].x2--;\n\t\t\tb[i*2+1].x1=b[i*2].x1;\n\t\t\tb[i*2+1].x2=b[i*2].x2;\n\t\t\tb[i*2].y=y1;\n\t\t\tb[i*2+1].y=y2;\n\t\t\tb[i*2].f=1;\n\t\t\tb[i*2+1].f=-1;\n\t\t}\n\t\tsort(b,b+n*2,comp);\n\t\tint ny=0;\n\t\tint now=0,prev=1;\n\t\tint res=0,res2=0;\n\t\tfor(int i=0;i<n*2;i++){\n\t\t\tif(ny!=b[i].y){\n\t\t\t\tswap(now,prev);\n\t\t\t\tint cnt=0;\n\t\t\t\tint cnt2=0,bt=0,cnt3=0;\n\t\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\t\tif(fie[j][now]>0 && fie[j][prev]==0)cnt3++;\n\t\t\t\t\tif(fie[j][now]==0 && fie[j][prev]>0)cnt3++;\n\t\t\t\t\tfie[j][now]=fie[j][prev];\n\t\t\t\t\tif(fie[j][now]>0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(bt==0)cnt2++,bt=1;\n\t\t\t\t\t}else bt=0;\n\t\t\t\t}\n\t\t\t\tres+=cnt*(b[i].y-ny);\n\t\t\t\tres2+=cnt2*2*(b[i].y-ny)+cnt3;\n\t\t\t}\n\t\t\tny=b[i].y;\n\t\t\tfor(int j=b[i].x1;j<=b[i].x2;j++)fie[j][now]+=b[i].f;\n\t\t\t//printf(\"%d\\n\",res2);\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\tif(r==2){\n\t\t\tswap(now,prev);\n\t\t\tint cnt3=0;\n\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\tif(fie[j][now]>0 && fie[j][prev]==0)cnt3++;\n\t\t\t\tif(fie[j][now]==0 && fie[j][prev]>0)cnt3++;\n\t\t\t\tfie[j][now]=fie[j][prev];\n\t\t\t}\n\t\t\tres2+=cnt3;\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nstruct Rect{\n\tshort x1,x2,y1,y2;\n};\n\nclass Compare{\n\tpublic:\n\tbool operator()(const Rect &rect1,const Rect &rect2){\n\t\treturn rect1.x1<rect2.x1;\n\t}\n};\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(array<vector<P>,10010> &range,vector<Rect> &rects){\n\tint result=0;\n\tint index=0;\n\tREP(x,0,10010){\n\t\twhile(index<rects.size()&&rects[index].x1<=x){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x].begin(),range[x].end());\n\t\tint y=0;\n\t\tREP(i,0,range[x].size()){\n\t\t\tif(range[x][i].S_>y) result+=range[x][i].S_-max(y,range[x][i].F_);\n\t\t\ty=max(y,range[x][i].S_);\n\t\t}\n\t\tvector<P>().swap(range[x]);\n\t}\n\treturn result;\n}\n\nint Count(array<vector<P>,10010> &range,array<array<bool,10010>,3> &flag,int x){\n\tint index=0,y=0,result=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t}\n\t\t++index;\n\t}\n\treturn result;\n}\n\nint CalcLength(array<vector<P>,10010> &range,vector<Rect> &rects){\n\tint result=0,index=0;\n\t//array<array<bool> > flag(3,array<bool>(10010));\n\tarray<array<bool,10010>,3> flag;\n\tREP(x,1,10009){\n\t\twhile(index<rects.size()&&rects[index].x1<=x+1){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x+1].begin(),range[x+1].end());\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,range[x+1].size()){\n\t\t\tif(range[x+1][i].S_>y) fill_n(flag[(x+1)%3].begin()+max(y,range[x+1][i].F_),range[x+1][i].S_-max(y,range[x+1][i].F_),true);\n\t\t\ty=max(range[x+1][i].S_,y);\n\t\t}\n\t\tresult+=Count(range,flag,x);\n\t\tif(x-2>=0) vector<P>().swap(range[x-2]);\n\t}\n\treturn result;\n}\n\nint main(){\n\t//std::ios::sync_with_stdio(false);\n\t//std::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tarray<vector<P>,10010> range;\n\t\tvector<Rect> rects(N);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\trects[i].x1=x1+4;\n\t\t\trects[i].y1=y1+4;\n\t\t\trects[i].x2=x2+4;\n\t\t\trects[i].y2=y2+4;\n\t\t}\n\t\tsort(rects.begin(),rects.end(),Compare());\n\t\tcout << CalcSize(range,rects) << endl;\n\t\tif(R==2) cout << CalcLength(range,rects) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\n\nint N, R, min_x, max_x, min_y, max_y;\nint R_2[10010][10010];\n\nint get(int x, int y){\n    if(0 <= x && x <= 10000 && 0 <= y && y <= 10000){\n        return R_2[x][y];\n    }\n    return 0;\n}\n\nint solve_S(){\n    int res = 0;\n    FOR(i, min_y, max_y+1){\n        FOR(j, min_x, max_x+1){\n            if(R_2[j][i] > 0){\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint solve_L(){\n    int res = 0;\n    FOR(i, min_y, max_y+1){\n        FOR(j, min_x, max_x+1){\n            if(R_2[j][i] > 0){\n                res += !get(j-1, i) + !get(j+1, i) + !get(j, i-1) + !get(j, i+1);\n            }\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> N >> R, N){\n        min_x = 10000;\n        max_x = 0;\n        min_y = 10000;\n        max_y = 0;\n\n        REP(i, 10001){\n            REP(j, 10001){\n                R_2[j][i] = 0;\n            }\n        }\n\n        REP(i, N){\n            int x1, y1, x2, y2;\n            std::cin >> x1 >> y1 >> x2 >> y2;\n\n            R_2[x1][y1]++;\n            R_2[x1][y2]--;\n            R_2[x2][y1]--;\n            R_2[x2][y2]++;\n            \n            min_x = std::min(min_x, x1);\n            max_x = std::max(max_x, x2);\n            min_y = std::min(min_y, y1);            \n            max_y = std::max(max_y, y2);\n        }\n\n        // X\n        FOR(i, min_y, max_y+1){\n            FOR(j, min_x+1, max_x+1){\n                R_2[j][i] += R_2[j-1][i];\n            }\n        }\n\n        // Y\n        FOR(i, min_x, max_x+1){\n            FOR(j, min_y+1, max_y+1){\n                R_2[i][j] += R_2[i][j-1];\n            }\n        }\n\n        if(R == 1){\n            std::cout << solve_S() << std::endl;\n        }else{\n            std::cout << solve_S() << std::endl;\n            std::cout << solve_L() << std::endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nvoid sl(int p[][4],int Mx,int My,int n,int r){\n  int f[Mx][My];\n  int i,j,k;\n  int s,l;\n  s = l = 0;\n  for(i=0;i<Mx;i++){\n    for(j=0;j<My;j++){\n      f[i][j] = 0;\n    }\n  }\n  for(k=0;k<n;k++){\n    for(i=p[k][0];i<p[k][2];i++){\n      for(j=p[k][1];j<p[k][3];j++){\n        if(f[i][j]==0){\n          s++;\n        }\n        f[i][j] = 1;\n      }\n    }\n  } \n  printf(\"%d\\n\",s);\n  if(r==2){\n    for(i=0;i<Mx-1;i++){\n      l+=(f[i][0]+f[i][Mx-1]);\n      for(j=0;j<My-1;j++){\n        l+=(f[i][j]^f[i][j+1]);\n      }\n    }\n    for(j=0;j<My-1;j++){\n      l+=(f[0][j]+f[My-1][j]);\n      for(i=0;i<Mx-1;i++){\n        l+=(f[i+1][j]^f[i][j]);\n      }\n    }\n    printf(\"%d\\n\",l);\n  }\n}\nint main(){\n  int n,r;\n  int i,j,k;\n  int Mx,My;\n  int p[10000][4];\n  scanf(\"%d %d\",&n,&r);\n  while(n!=0&&r!=0){\n    Mx = My = 100;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&p[k][0],&p[k][1],&p[k][2],&p[k][3]);\n      if(p[k][2]>Mx){\n        Mx = p[k][2];\n      }\n      if(p[k][3]>My){\n        My = p[k][3];\n      }      \n    }\n    sl(p,Mx,My,n,r);\n    scanf(\"%d %d\",&n,&r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint map[10003][10003];\n\nint main(){\n\twhile(1){\n\t\tint n,r,ans=0,ans2=0,minx=10001,miny=10001,maxx=0,maxy=0;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tmap[x1][y1]-=1;\n\t\t\tmap[x2][y1]+=1;\n\t\t\tmap[x1][y2]+=1;\n\t\t\tmap[x2][y2]-=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tt+=map[j][i];\n\t\t\t\tmap[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tt+=map[i][j];\n\t\t\t\tmap[i][j]=t;\n\t\t\t\tif(map[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\t\tif(map[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n  \n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    \n    vector<pair<P,P> > in;\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n    \n    sort(in.begin(),in.end(),cmp_y);\n    \n    int S=0,L=0;\n    vector<P>v;\n    for(int i=0;i+1<10001;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n\tif(i<in[j].S.F)break;\n      }\n      \n      if(v.size()!=0){\n\tsort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n    \n    \n    if(r==2){\n      \n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i+1<10001;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\t  \n\t  if(i<in[j].F.F)break;\n\t}\n\tif(v.size()!=0){\n\t  sort(v.begin(),v.end());\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n\nint area;\nint length;\n\nRECT calc[10000];\nRECT before[10000];\nint bsize;\n\nbool comp(const RECT& rLeft, const RECT& rRight){\n    return (rLeft.sx < rRight.sx);\n}\n\nvoid mergeArea(RECT *grid, int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n    \n    if (n == 0){\n        return;\n    }\n    \n    sort(grid, grid + n, comp);\n    \n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n    \n    *sq = num;\n}\n\nvoid mergeLength(RECT *grid, int n)\n{\n    int total[40000];\n    int i;\n    int res, num;\n    \n    num = 0;\n    for (i = 0; i < n; i++){\n        total[num++] = grid[i].sx;\n        total[num++] = grid[i].ex;\n    }\n    for (i = 0; i < bsize; i++){\n        total[num++] = before[i].sx;\n        total[num++] = before[i].ex;\n    }\n    \n    sort(total, total + num);\n    res = 0;\n    for (i = 0; i < num; i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n\nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    static RECT grid[10000];\n    int num;\n    int i, j;\n    int sq;\n    int miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        miny = 1000000;\n        maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n            miny = min(miny, p[i].sy);\n            maxy = max(maxy, p[i].ey);\n        }\n        \n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        area = length = 0;\n        for (i = miny; i <= maxy; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n            }\n            mergeArea(grid, num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(calc, sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", length);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X1[10010], X2[10010], Y1[10010], Y2[10010];\nint n, r, p[3][10010];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> r; if (n == 0 && r == 0)break;\n\t\tint maxx = 0, maxy = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\t\t\tif (X2[i] > maxx)maxx = X2[i];\n\t\t\tif (Y2[i] > maxy)maxy = Y2[i];\n\t\t}\n\t\tint cnt1 = 0, cnt2 = 0, J = maxy + 10;\n\t\tfor (int i = 0; i < maxx + 10; i++) {\n\t\t\tfor (int j = 0; j < J * 3; j++)p[j / J][j % J] = 0;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tint G = i + j, H = j + 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (X1[k] <= G && G < X2[k]) {\n\t\t\t\t\t\tp[H][Y1[k]]++; p[H][Y2[k]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 1; k < 10010; k++)p[j][k] += p[j][k - 1];\n\t\t\t}\n\t\t\tfor (int j = 0; j < maxy + 10; j++) {\n\t\t\t\tif (p[1][j] >= 1)cnt1++;\n\t\t\t\tif (i == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\tif (p[1][j] == 0 && p[2][j] >= 1)cnt2++;\n\t\t\t\tif (p[1][j] >= 1 && p[2][j] == 0)cnt2++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < maxy + 10; j++) {\n\t\t\t\tif (j == 0 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j == 10009 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j >= 1 && j <= 10008) {\n\t\t\t\t\tif (p[1][j] >= 1 && p[1][j + 1] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j] == 0 && p[1][j + 1] >= 1)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 1)cout << cnt1 << endl;\n\t\tif (r == 2)cout << cnt1 << endl << cnt2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nshort fie[4000][4000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n\ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\ntypedef long long int64;\n\nint n, r, X1[10000], Y1[10000], X2[10000], Y2[10000];\nint max_h, max_w;\n\nPi get__(){\n  int imos[10002], ret = 0, res = 0, imomo[10002];\n  for(int i = 0; i < max( max_h, max_w) + 1; i++){\n    fill_n( imos, 10002, 0), fill_n( imomo, 10002, 0);\n    for(int j = 0; j < n; j++){\n      if(Y1[j] <= i && i < Y2[j]){\n        imos[X1[j]]++;\n        imos[X2[j]]--;\n      }\n      if(X1[j] <= i && i < X2[j]){\n        imomo[Y1[j]]++;\n        imomo[Y2[j]]--;\n      }\n    }\n    for(int j = 1; j <= max(max_w, max_h) + 1; j++){\n      imos[j] += imos[j - 1];\n      imomo[j] += imomo[j - 1];\n      if( imos[j] > 0) ret++;\n      if(imomo[j] > 0 && imomo[j - 1] == 0) res++;\n      if(imomo[j - 1] > 0 && imomo[j] == 0) res++;\n      if( imos[j] > 0 && imos[j - 1] == 0) res++;\n      if( imos[j - 1] > 0 && imos[j] == 0) res++;\n    }\n\n    if(imos[0] > 0){\n      ret++;\n      res++;\n    }\n    if(imomo[0] > 0){\n      res++;\n    }\n  }\n  return make_pair( ret, res);\n}\n\nint main(){\n  while(cin >> n >> r, n){\n    max_h = max_w = 0;\n   for(int i = 0; i < n; i++){\n     cin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n     max_h = max( max_h, Y2[i]);\n     max_w = max( max_w, X2[i]);\n   }\n   Pi __ = get__();\n   cout << __.first << endl;\n   if(r == 2) cout << __.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nbool Compare(const P &p1,const P &p2){\n\treturn p1.F_<p2.F_;\n}\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<vector<P> > &range){\n\tint result=0;\n\tREP(x,1,10010){\n\t\tint index=0,y=0;\n\t\twhile(index<range[x].size()){\n\t\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y) ++result;\n\t\t\t++index;\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid Add(vector<vector<P> > &range,vector<vector<short> > &cnt,int x,int &result){\n\tint index=0,y=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(cnt[(x-1)%3][y]==0) ++result;\n\t\t\tif(cnt[(x+1)%3][y]==0) ++result;\n\t\t\tif(cnt[x%3][y-1]==0) ++result;\n\t\t\tif(cnt[x%3][y+1]==0) ++result;\n\t\t}\n\t\t++index;\n\t}\n}\n\nint CalcLength(vector<vector<P> > &range){\n\tint result=0;\n\tvector<vector<short> > cnt(3,vector<short>(10010));\n\tREP(x,1,10009){\n\t\tif(x-2>=0) fill(cnt[(x-2)%3].begin(),cnt[(x-2)%3].end(),0);\n\t\tint index=0,y=0;\n\t\twhile(index<range[x+1].size()){\n\t\t\tfor(y=max(y,range[x+1][index].F_); y<range[x+1][index].S_; ++y) ++cnt[(x+1)%3][y];\n\t\t\t++index;\n\t\t}\n\t\tAdd(range,cnt,x,result);\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tvector<vector<P> > range(10010);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tREP(x,x1+4,x2+4) range[x].push_back(MP(y1+4,y2+4));\n\t\t}\n\t\tREP(x,0,10010) sort(range[x].begin(),range[x].end(),Compare);\n\t\tcout << CalcSize(range) << endl;\n\t\tif(R==2) cout << CalcLength(range) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nvector<T> vec;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        scanf(\"%d %d\",&n,&r);\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        vec.pb(T(P(INF,INF),INF));\n        SORT(vec);\n        int index=0;\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n            cout << endl;\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid compress(vector<int> &v){\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\nint index(const vector<int> &v, int x){\n\treturn lower_bound(v.begin(), v.end(), x) - v.begin();\n}\n\nint main(){\n\tint n, r;\n\twhile(scanf(\"%d%d\", &n, &r), n){\n\t\tvector<int> x1(n), y1(n), x2(n), y2(n);\n\t\tvector<int> xs(2), ys(2);\n\t\txs.reserve(2 * n + 2);\n\t\tys.reserve(2 * n + 2);\n\t\txs[0] = ys[0] = -100000;\n\t\txs[1] = ys[1] = 100000;\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &x1[i], &y1[i], &x2[i], &y2[i]);\n\t\t\txs.push_back(x1[i]);\n\t\t\txs.push_back(x2[i]);\n\t\t\tys.push_back(y1[i]);\n\t\t\tys.push_back(y2[i]);\n\t\t}\n\n\t\tcompress(xs);\n\t\tcompress(ys);\n\n\t\tvector<vector<int> > imos(xs.size(), vector<int>(ys.size()));\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tint xi1 = index(xs, x1[i]);\n\t\t\tint xi2 = index(xs, x2[i]);\n\t\t\tint yi1 = index(ys, y1[i]);\n\t\t\tint yi2 = index(ys, y2[i]);\n\n\t\t\t++imos[xi1][yi1];\n\t\t\t--imos[xi2][yi1];\n\t\t\t--imos[xi1][yi2];\n\t\t\t++imos[xi2][yi2];\n\t\t}\n\n\t\tfor(int i = 1; i < xs.size(); ++i)\n\t\tfor(int j = 1; j < ys.size(); ++j){\n\t\t\timos[i][j] += imos[i][j-1];\n\t\t}\n\n\t\tfor(int i = 1; i < xs.size(); ++i)\n\t\tfor(int j = 1; j < ys.size(); ++j){\n\t\t\timos[i][j] += imos[i-1][j];\n\t\t}\n\n\t\tint area = 0, len = 0;\n\t\tfor(int i = 1; i + 1 < xs.size(); ++i)\n\t\tfor(int j = 1; j + 1 < ys.size(); ++j){\n\t\t\tif(imos[i][j] == 0) continue;\n\n\t\t\tint dx = xs[i+1] - xs[i];\n\t\t\tint dy = ys[j+1] - ys[j];\n\n\t\t\tarea += dx * dy;\n\n\t\t\tif(imos[i-1][j] == 0)\n\t\t\t\tlen += dy;\n\t\t\tif(imos[i+1][j] == 0)\n\t\t\t\tlen += dy;\n\t\t\tif(imos[i][j-1] == 0)\n\t\t\t\tlen += dx;\n\t\t\tif(imos[i][j+1] == 0)\n\t\t\t\tlen += dx;\n\t\t}\n\n\t\tprintf(\"%d\\n\", area);\n\t\tif(r == 2) printf(\"%d\\n\", len);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst static int MAX = 10000;\nbool Sheets[MAX+2][MAX+2];\n\nint count(int x,int y) {\n  int dx[4] = {-1,0,0,1};\n  int dy[4] = {0,1,-1,0};\n  int cnt = 0;\n  for(int d=0;d<4;d++) {\n    if(!Sheets[x+dx[d]][y+dy[d]])\n      cnt++;\n  }\n  return cnt;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,r;\n  while(cin >> n >> r) {\n    if(n+r == 0) break;\n    memset(Sheets,0,sizeof(Sheets));\n\n    int x[2],y[2];\n    for(int i=0;i<n;i++) {\n      cin >> x[0] >> y[0] >> x[1] >> y[1];\n      for(int w=x[0]+1;w<=x[1];w++) {\n        for(int h=y[0]+1;h<=y[1];h++) {\n          Sheets[h][w] = true;\n        }\n      }\n    }\n\n    // calc\n    int length = 0;\n    int surface = 0;\n    for(int i=1;i<=MAX;i++) {\n      for(int j=1;j<=MAX;j++) {\n        if(Sheets[i][j]) {\n          surface++;\n          length += count(i,j);\n        }\n      }\n    }\n    cout << surface << endl;\n    if(r==2) cout << length << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint main() {\n    while(true) {\n        int n,r; scanf(\"%d%d\", &n, &r);\n        if(n==0) break;\n\n        vector<pair<pair<int,int>,int> > evts(n*4+1);\n        for(int i = 0; i < n; i++) {\n            int x1,y1,x2,y2; scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n            x1++; y1++; x2++; y2++;\n            evts[i*4+0] = make_pair(make_pair(y1, x1), 1);\n            evts[i*4+1] = make_pair(make_pair(y1, x2), -1);\n            evts[i*4+2] = make_pair(make_pair(y2, x1), -1);\n            evts[i*4+3] = make_pair(make_pair(y2, x2), 1);\n        }\n        evts[n*4] = make_pair(make_pair(10002, 10002), 0);\n        sort(evts.begin(), evts.end());\n\n        static int dp[10002];\n        fill(dp, dp+10002, 0);\n        int fill=0,stroke=0;\n        int evtpos = 0;\n        for(int y = 1; y < 10002; y++) {\n            int amount = 0;\n            for(int x = 1; x < 10002; x++) {\n                while(evts[evtpos].first == make_pair(y,x)) {\n                    amount += evts[evtpos].second;\n                    evtpos++;\n                }\n                int a = (dp[x]>0);\n                dp[x] += amount;\n                int b = (dp[x]>0);\n                stroke += a^b;\n                stroke += (dp[x-1]>0)^b;\n                fill += b;\n            }\n        }\n        if(r==1)\n            printf(\"%d\\n\", fill);\n        else\n            printf(\"%d\\n%d\\n\", fill, stroke);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[10001];\nvector<P> xx[10001];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 11111; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tx[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n      x[i].clear();\n      /*\n      cout << \"x = \" << i << endl;\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tcout << \"( \" << xx[i][j].F << \" , \" << xx[i][j].S << \" )\" << endl;\n      }\n      cout << endl;\n      //*/\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<list>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint short[10001][10001];\n\nint main(){\n    \n    int n,r;\n    \n        int S=0;\n        int L=0;\n        int state;\n  \n\n    \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        memset(map,0,sizeof(map));\n\n        \n        int x_min=10001,x_max=0,y_min=10001,y_max=0;\n       \n        int x1,y1,x2,y2;\n        for(int i=0;i<n;i++){\n            \n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n            if(x_min>x1)x_min=x1;\n            if(y_min>y1)y_min=y1;\n            if(x_max<x2)x_max=x2;\n            if(y_max<y2)y_max=y2;\n            \n        }\n\n        S=0;\n        L=0;\n        \n        for(int h=y_min;h<=y_max;h++){\n            state=0;\n            for(int w=x_min;w<=x_max;w++){\n                state+=map[w][h];\n                map[w][h]=state;\n            }\n        }\n        for(int w=x_min;w<=x_max;w++){\n            state=0;\n            for(int h=y_min;h<=y_max;h++){\n                state+=map[w][h];\n                map[w][h]=state;\n                if(map[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(map[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(map[w][h-1]==0)L+=2;\n               }\n            }\n        }\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint map[10003][10003]={};\nint main(){\n\n\n\nint H1,W1,H2,W2;\nint n,m;\nwhile(1){\nscanf(\"%d %d\",&n,&m);\nif(n==0&&m==0)break;\nfor(int iii=0;iii<n;iii++){\nscanf(\"%d %d %d %d\",&W1,&H1,&W2,&H2);\nfor(int i=H1+1;i<H2+1;i++)\nfor(int j=W1+1;j<W2+1;j++)\nmap[i][j]=1;\n}\n\nint c=0;\nfor(int i=1;i<10001;i++)\nfor(int j=1;j<10001;j++)\nif(map[i][j]==1)c++;\n\nint cc=0;\n\nfor(int i=1;i<10001;i++)\nfor(int j=1;j<10001;j++)\n{\nif(map[i][j]==1){\nif(map[i+1][j]==0)cc++;\nif(map[i-1][j]==0)cc++;\nif(map[i][j+1]==0)cc++;\nif(map[i][j-1]==0)cc++;\n\n\n}\n}\n\n\nprintf(\"%d\\n\",c);\nif(m==2)printf(\"%d\\n\",cc);\n\nfor(int i=1;i<10001;i++)\nfor(int j=1;j<10001;j++)\n\tmap[i][j]=0;\n\n}\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n\nvector<pa> ve[10010];\n\nint mae[10020];\nint dp[10022];\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\nwhile(1){\n\n\t\n\tint n,P;\n\tcin>>n>>P;\nif(n+P==0)exit(0);\nfor(int i=0;i<10010;i++)ve[i].clear();\n\tfor(int i=0;i<n;i++){\nint x1,y1,x2,y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tx1++,y1++,x2++,y2++;\n\t\tve[x1].pb(mp(y1,1));\n\t\tve[x2].pb(mp(y1,-1));\n\t\tve[x1].pb(mp(y2,-1));\n\t\tve[x2].pb(mp(y2,1));\n\t\t\n\t\t\n\t}\n\tint cnt=0;\n\tint sa=0;\n\tfor(int i=1;i<=10005;i++){\n\t\tfor(int j=1;j<=10005;j++)dp[j]=0;\n\t\tfor(auto v:ve[i])dp[v.first]+=v.second;\n\t\tfor(int j=1;j<=10005;j++){\n\t\t\tdp[j]=dp[j]+mae[j]+dp[j-1]-mae[j-1];\n\t\t\tif(dp[j]>0)cnt++;\n\t\t\tif(dp[j]>0 && mae[j]==0)sa++;\n\t\t\tif(dp[j]==0 && mae[j]>0)sa++;\n\t\t\tif(dp[j]>0 && dp[j-1]==0)sa++;\n\t\t\tif(dp[j]==0 && dp[j-1]>0)sa++;\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int j=1;j<=10005;j++)mae[j]=dp[j];\n\t\t\n\t}\n\tcout<<cnt<<endl;\n\tif(P==2)cout<<sa<<endl;\n}\n\treturn 0;\n\t\n\n \n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    vector<P>v;\n    for(int i=0;i+1<10001;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n      }\n     \n      if(v.size()==0)continue;\n      sort(v.begin(),v.end());\n      int b=v[0].F,e=v[0].S;\n      for(int j=1;j<v.size();j++){\n\tint B=v[j].F,E=v[j].S;\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b, b=B, e=E, L+=2;\n      }\n      S+=e-b, L+=2;\n    }\n    cout << S << endl;\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end(),cmp_x);\n\n      for(int i=0;i+1<10001;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\t}\n\tif(v.size()==0)continue;\n\tsort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\t\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B, e=E, L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> P;\nint n, r;\nint mp[10003][10003];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,-1,1};\nbool isin(int x, int y) {\n    return x>=0&&x<10003&&y>=0&&y<10003;\n}\nint main() {\n    while (scanf(\"%d%d\",&n,&r)) {\n        if (!n&&!r) break;\n        int mx=10003,Mx=0,my=10003,My=0;\n        for (int i=0; i<10003; i++) for (int j=0; j<10003; j++) mp[i][j]=0;\n        for (int i=0; i<n; i++) {\n            int a, b, c, d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            a++; b++; c++; d++;\n            mp[a][b]++; mp[c][d]++;\n            mp[a][d]--; mp[c][b]--;\n            mx=min(mx,a);\n            Mx=max(Mx,c+1);\n            my=min(my,b);\n            My=max(My,d+1);\n        }\n        for (int i=mx; i<Mx; i++) {\n            for (int j=my; j<My; j++) mp[i][j]+=mp[i][j-1];\n        }\n        for (int i=my; i<My; i++) {\n            for (int j=mx; j<Mx; j++) mp[j][i]+=mp[j-1][i];\n        }\n        int res=0;\n        for (int i=mx; i<Mx; i++) for (int j=my; j<My; j++) if (mp[i][j]!=0) res++;\n        printf(\"%d\\n\",res);\n        if (r==2) {\n            res=0;\n            for (int i=mx; i<Mx; i++) for (int j=my; j<My; j++) {\n                if (mp[i][j]) res+=!mp[i-1][j]+!mp[i][j-1]+!mp[i+1][j]+!mp[i][j+1];\n            }\n            printf(\"%d\\n\",res);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint map[10003][10003];\n\nint main(void){\n\twhile(1){\n\t\tint n,r,ans=0,ans2=0,minx=0,miny=0,maxx=10001,maxy=10001;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tminx=max(x1+1,minx);\n\t\t\tminy=max(y1+1,miny);\n\t\t\tmaxx=min(x2+1,maxx);\n\t\t\tmaxx=min(y2+1,maxy);\n\t\t\tmap[x1+1][y1+1]-=1;\n\t\t\tmap[x2+1][y1+1]+=1;\n\t\t\tmap[x1+1][y2+1]+=1;\n\t\t\tmap[x2+1][y2+1]-=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tmap[j][i]=map[j][i]+map[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tmap[i][j]=map[i][j]+map[i][j+1];\n\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\t\tif(map[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include <map>\n#include<cstring>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\nshort node[10001];\nshort state_before[10001];\nshort map_before[10001];\n\n\nmap<int,list<pair<int,int>>> points;\n\n\n\nvoid read_points(int tate){\n    memcpy(map_before,node,sizeof node);\n    memset(node,0,sizeof(node));    \n    for(auto tmp:points[tate]){\n        node[tmp.first]+=tmp.second;\n    }\n}\nint main(){\n    int n,r;\n    int S=0;\n    int L=0;\n    int deltaS=0,deltaL=0;\n    ios::sync_with_stdio(false);\n  \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n        \n        points.clear();\n        int x1,y1,x2,y2;\n        int max_x=0,min_x=10000,max_y=0,min_y=10000;\n        for(int i=0;i<n;i++){\n            cin>>x1>>y1>>x2>>y2;\n \n            if(points.find(y1)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y1]=tmp;\n            }\n            if(points.find(y2)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y2]=tmp;\n            }\n            points[y1].push_back(make_pair(x1,1));\n            points[y1].push_back(make_pair(x2,-1));\n            points[y2].push_back(make_pair(x1,-1));\n            points[y2].push_back(make_pair(x2,1));\n            if(max_x<x2)max_x=x2;\n            if(max_y<y2)max_y=y2;\n            if(min_x>x1)min_x=x1;\n            if(min_y>y1)min_y=y1;\n            \n        }\n        \n        \n        S=0;\n        L=0;\n\n        for(int h=min_y;h<=max_y;h++){\n            if(points.find(h)==points.end()){\n                S+=deltaS;\n                L+=deltaL;\n                continue;\n            }\n            deltaL=0,deltaS=0;\n            read_points(h);\n            int yoko_state=0;\n            for(int w=min_x;w<=max_x;w++){\n                yoko_state+=node[w];\n                node[w]=yoko_state;\n                if(h!=0){\n                    node[w]+=state_before[w];\n                }\n                state_before[w]=node[w];\n                if(node[w]>0){\n                   S++;\n                   deltaS++;\n                   if(w==0){L+=2;deltaL+=2;}\n                   else if(node[w-1]==0){L+=2;deltaL+=2;}\n                   if(h==0){L+=2;deltaL+=2;}\n                   else if(map_before[w]==0){L+=2;deltaL+=2;}\n                }\n                \n                \n            }\n            \n        }\n\n\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<pair<int,int>,pair<int,int> > > in;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    vector<pair<int,int> > v[10001];\n \n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define mp make_pair\nint num[10005];\nint back[10005];\nint rank[10005];\nint par[10005];\nint sheets[10005][4];\nint main()\n{\n  int n,m;\n  while(1)\n    {\n      scanf(\"%d %d\",&n,&m);\n      if(!n && !m) break;\n      int maxi=0;\n      priority_queue<P,vector<P>,greater<P> > pque;\n      vector<P>in;\n      for(int w=0;w<n;w++)\n\t{\n\t  int a,b,c,d;\n\t  scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t  sheets[w][0]=a;\n\t  sheets[w][1]=b;\n\t  sheets[w][2]=c;\n\t  sheets[w][3]=d;\n\t  maxi=max(maxi,c-1);\n          in.pb(mp(a,w));\n\t}\n      sort(in.begin(),in.end());\n      int ans1=0,ans2=0,last=0;\n      memset(back,0,sizeof(back));\n      for(int i=0;i<=10000;i++)\n\t    { \tvector<P>vecd;\n\t      while(in[last].first<=i)\n\t\t{\n\t          pque.push(mp(sheets[in[last].second][2],in[last].second)); last++;\n\t\t}\n\t      while(pque.top().first<=i)\n\t\t{\n\t          pque.pop();\n\t        }\n\t\t  memset(num,0,sizeof(num));\n\t\t  int ru=pque.size();\n\t\t  for(int j=0;j<ru;j++)\n\t\t    {\n\t\t      vecd.pb(pque.top()); int r=pque.top().second; pque.pop();\n\t\t      num[sheets[r][1]]=max(num[sheets[r][1]],sheets[r][3]-sheets[r][1]);\n\t\t    }\n\t\t  for(int j=0;j<=10000;j++)\n\t\t    {\n\t\t      if(j!=0)\n\t\t\t{\n\t\t\t  num[j]=max(num[j],num[j-1]-1);\n\t\t\t}\n\t\t      if(i==maxi && num[j]!=0) ans2++;\n\t\t    }\n\t\t  for(int j=0;j<=10000;j++)\n\t\t    {\n\t\t      if(num[j]!=0)\n\t\t\t{ ans1++;\n\t\t\t  if(i==0)\n\t\t\t    {\n\t\t\t      ans2++;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      if(back[j]==0) ans2++;\n\t\t\t    }\n\t\t\t  if(j==0)\n\t\t\t    {\n\t\t\t      ans2++;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      if(!num[j-1])\n\t\t\t\t{\n\t\t\t\t  ans2++;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  if(j==10000)\n\t\t\t    {\n\t\t\t      ans2++;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      if(!num[j+1])\n\t\t\t\t{\n\t\t\t\t  ans2++;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  if(i!=0 && back[j]!=0)\n\t\t\t    {\n\t\t\t      ans2++;\n\t\t\t    }\n\t\t\t}\n\t\t      back[j]=num[j];\n\t\t    }    \n\t\t   for(int q=0;q<vecd.size();q++){\n\t\t     pque.push(vecd[q]);\n\t\t   }\n\t    }\n      printf(\"%d\\n\",ans1);\n      if(m==2)\n\t{\n\t  printf(\"%d\\n\",ans2);\n\t}\n    }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst static int MAX = 10000;\nbool Sheets[MAX+2][MAX+2];\nint dx[4] = {-1,0,0,1};\nint dy[4] = {0,1,-1,0};\n\nint count(int x,int y) {\n  int cnt = 0;\n\n  for(int d=0;d<4;d++) {\n    if(!Sheets[x+dx[d]][y+dy[d]])\n      cnt++;\n  }\n  return cnt;\n}\n\nint main() {\n  int n,r;\n  int x[2],y[2];\n  int max_x,max_y;\n  while(true) {\n    scanf(\"%d %d\",&n,&r);\n    if(n+r == 0) break;\n\n    max_x = 0;\n    max_y = 0;\n    for(int i=0;i<n;i++) {\n      scanf(\"%d %d %d %d\",&x[0],&y[0],&x[1],&y[1]);\n      max_x = max(max_x,x[1]);\n      max_y = max(max_y,y[1]);\n      for(int w=x[0]+1;w<=x[1];w++) {\n        for(int h=y[0]+1;h<=y[1];h++) {\n          Sheets[h][w] = true;\n        }\n      }\n    }\n\n    // calc\n    int length = 0;\n    int surface = 0;\n    int max_xy = max(max_x,max_y);\n    for(int i=1;i<=max_xy;i++) {\n      for(int j=1;j<=max_xy;j++) {\n        if(Sheets[i][j]) {\n          surface++;\n          length += count(i,j);\n        }\n      }\n    }\n    printf(\"%d\\n\",surface);\n    if(r==2) printf(\"%d\\n\",length);\n\n    for(int i=1;i<=max_xy;i++) {\n      for(int j=1;j<=max_xy;j++) {\n        Sheets[i][j] = false;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509>\n?????????============================================================\n?????¢???????????¢??????????????????????????????????????????.???????????????????????§????????????????????¨????????¢????????¨???????±???????????????°?????????????????????.\n?????????, ?????¢?????§?¨??????¢??¨??????????????¨???, ??????????????????????¬?????????¶ (1), (2) ????????????????????¨??????.\n(1) ???????????????????????¢??? 4 ????????? x, y ??§?¨??????¨??? 0 ??\\??? 10000 ??\\????????´??°??§??????,\n    ????????¢???????????? x ???, ????????? y ??????????????§??????.\n(2) ?????????????????°????????? 10000 ?????\\?????§??????.\n??\\???????????? ??? 1 ?????????????????¢????????° n ??¨??????????¨?????????¨?????´??° r ???????????§????????£?????????????????????.\n2 ????????\\??????????????????, ?????????????????????????????§?¨? (x1, y1) ??¨??????????????§?¨? (x2, y2) ?????§?¨???????\nx1, y1, x2, y2 ????????§????????§????????£??????????????????.\n\n???????????? r = 1 ?????¨??? 1 ???????????¢??????, r = 2 ?????¨??? 1 ???????????¢???, 2 ???????????¨???????????????????????????.\n??????????????´??????????????????????????\\???????????¨.\n\n=================================================================\n??\\???=============================================================\n??\\???????????°????????????????????????????????????n, r ?????¨?????? 0 ?????¨?????\\????????????????????????????????????????????°??? 10 ????¶?????????????\n================================================================\n??????=============================================================\n???????????????????????¨???, r = 1 ?????¨??? 1 ???????????¢??????, r = 2 ?????¨??? 1 ???????????¢???, 2 ???????????¨???????????????????????????.\n================================================================\n?§£??¬=============================================================\n\n================================================================\n*/\n\nclass CC {\npublic:\n\tll N;\n\tvector<ll> xs; // ????????¨:xs[x1 or x2????????????] := ????????§?¨?\n\n\tCC(ll N) :N(N) {}\n\t// x1, x2?????§?¨???§??????, ??§?¨???§???????????????????????????\n\tint compress(vector<ll>& x1, vector<ll>& x2, ll MIN_W = -1e10, ll MAX_W = 1e10) {\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\t/* ??´???????????£??????d????¶???????????????? */\n\t\t\tfor (int d = -1; d <= 1; d++) {\n\t\t\t\tll tx1 = x1[i], tx2 = x2[i];\n\t\t\t\tif (MIN_W <= tx1 && tx1 <= MAX_W) xs.push_back(tx1);\n\t\t\t\tif (MIN_W <= tx2 && tx2 <= MAX_W) xs.push_back(tx2);\n\t\t\t}\n\t\t}\n\n\t\tsort(xs.begin(), xs.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tx1[i] = find(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\t\tx2[i] = find(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t\t}\n\n\t\treturn (int)xs.size(); // xs.size????????§??§???6*N\n\t}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, r;\n\twhile (cin >> N >> r, N | r) {\n\t\tvector<ll> x1(N), y1(N), x2(N), y2(N);\n\t\tfor (int i = 0; i < N;i++) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\t\tCC CCx(N), CCy(N);\n\t\tll W = CCx.compress(x1, x2);\n\t\tll H = CCy.compress(y1, y2);\n\n\t\t/* imos????????¨???????????§?¨??????¢????¨???????*/\n\t\tvector<vector<int>> imos(H + 2, vector<int>(W + 2, 0)); // ??¢????¨????\n\t\tvector<vector<int>> Sum(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\timos[y1[i]][x1[i]]++;\n\t\t\timos[y1[i]][x2[i]]--;\n\t\t\timos[y2[i]][x1[i]]--;\n\t\t\timos[y2[i]][x2[i]]++;\n\t\t}\n\t\tll ans = 0;\n\t\tll circuit = 0;\n\t\tfor (int y = 0; y < H;y++) {\n\t\t\tfor (int x = 0; x < W;x++) {\n\t\t\t\tSum[y + 1][x + 1] = Sum[y + 1][x] + Sum[y][x + 1] - Sum[y][x] + imos[y][x];\n\t\t\t\tif (Sum[y + 1][x + 1] > 0) {\n\t\t\t\t\tans += (CCy.xs[y + 1] - CCy.xs[y])*(CCx.xs[x + 1] - CCx.xs[x]);\n\t\t\t\t\tcircuit += (CCy.xs[y + 1] - CCy.xs[y]) + (CCx.xs[x + 1] - CCx.xs[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tif (r == 1) continue;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nstruct R{\n\tR(){}\n\tR(int a, int b, int c, int d): a(a), b(b), c(c), d(d){}\n\n\tint a, b, c, d;\n};\n\nint n, r;\nvector<R> v;\n\nR rect_intersect(const R& x, const R& y){\n\treturn R(max(x.a, y.a), max(x.b, y.b), min(x.c, y.c), min(x.d, y.d));\n}\n\nbool rect_empty(const R& x){\n\treturn x.a >= x.c || x.b >= x.d;\n}\n\nbool rect_cmp(const R& x, const R& y){\n\treturn x.a == y.a && x.b == y.b && x.c == y.c && x.d == y.d;\n}\n\nint rect_area(const R& x){\n\treturn (x.c - x.a) * (x.d - x.b);\n}\n\nint rect_around(const R& x){\n\treturn ((x.c - x.a) + (x.d - x.b)) * 2;\n}\n\nint area(const vector<R>& v, const R& x){\n\trep(i, v.size()){\n\t\tif(rect_cmp(v[i], x)){\n\t\t\treturn rect_area(x);\n\t\t}\n\t}\n\n\tint p = (x.a + x.c) / 2;\n\tint q = (x.b + x.d) / 2;\n\n\tR y[4] = {\n\t\tR(x.a, x.b, p, q),\n\t\tR(x.a, q, p, x.d),\n\t\tR(p, x.b, x.c, q),\n\t\tR(p, q, x.c, x.d)\n\t};\n\tvector<R> a[4];\n\trep(i, v.size()){\n\t\trep(j, 4){\n\t\t\tR t = rect_intersect(v[i], y[j]);\n\t\t\tif(!rect_empty(t)){\n\t\t\t\ta[j].push_back(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint r = 0;\n\trep(j, 4){\n\t\tif(!a[j].empty()){\n\t\t\tr += area(a[j], y[j]);\n\t\t}\n\t}\n\n\treturn r;\n}\n\ntemplate<typename U, typename V> void copy_n(U it1, int n, V it2){\n\trep(i, n){\n\t\t*(it2 + i) = *(it1 + i);\n\t}\n}\n\npair<int, vector<int> > around(const vector<R>& v, const R& x){\n\trep(i, v.size()){\n\t\tif(rect_cmp(v[i], x)){\n\t\t\tint u = rect_around(x);\n\n\t\t\t// printf(\"(%d %d %d %d) %d\\n\", x.a, x.b , x.c ,x.d ,u);\n\n\t\t\treturn make_pair(u, vector<int>(u, 1));\n\t\t}\n\t}\n\n\tint p = (x.a + x.c) / 2;\n\tint q = (x.b + x.d) / 2;\n\n\tR y[4] = {\n\t\tR(x.a, x.b, p, q),\n\t\tR(x.a, q, p, x.d),\n\t\tR(p, x.b, x.c, q),\n\t\tR(p, q, x.c, x.d)\n\t};\n\tvector<R> a[4];\n\trep(i, v.size()){\n\t\trep(j, 4){\n\t\t\tR t = rect_intersect(v[i], y[j]);\n\t\t\tif(!rect_empty(t)){\n\t\t\t\ta[j].push_back(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint r = 0;\n\tint sx = x.c - x.a;\n\tint sy = x.d - x.b;\n\tvector<int> m1(sx, 0);\n\tvector<int> m2(sx, 0);\n\tvector<int> m3(sy, 0);\n\tvector<int> m4(sy, 0);\n\tvector<int> rv(rect_around(x));\n\n\tint _a = x.a, b = x.b, c = x.c, d = x.d;\n\tint pc = c- p;\n\tint ap = p - _a;\n\tint bq = q -b;\n\tint qd = d - q;\n\n\trep(j, 4){\n\t\tif(!a[j].empty()){\n\t\t\t\n\t\t\tpair<int, vector<int> > _q = around(a[j], y[j]);\n\t\t\tr += _q.first;\n\t\t\tvector<int>::iterator qv = _q.second.begin();\n\t\t\tif(j == 0){\n\t\t\t\tcopy_n(qv + ap, bq, m3.begin());\n\t\t\t\tcopy_n(qv + ap + bq, ap, m1.begin() + pc);\n\t\t\t\tcopy_n(qv, p - x.a, rv.begin());\n\t\t\t\tcopy_n(qv + ap + ap + bq, bq, rv.begin() + sx + sx + sy + qd);\n\t\t\t}\n\t\t\telse if(j == 1){\n\t\t\t\tcopy_n(qv, ap, m2.begin());\n\t\t\t\tcopy_n(qv + ap, qd, m3.begin() + bq);\n\t\t\t\tcopy_n(qv + p - x.a + x.d - q, ap + qd, rv.begin() + sx + sy + x.c - p);\n\t\t\t}\n\t\t\telse if(j == 2){\n\t\t\t\tcopy_n(qv + pc + bq, pc, m1.begin());\n\t\t\t\tcopy_n(qv + pc + bq + pc, bq, m4.begin() + qd);\n\t\t\t\tcopy_n(qv, pc + bq, rv.begin() + ap);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcopy_n(qv, pc, m2.begin() + ap);\n\t\t\t\tcopy_n(qv + qd + pc + pc , qd, m4.begin());\n\t\t\t\tcopy_n(qv + pc, pc + qd, rv.begin() + sx + bq);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*if(ap == 0){\n\t\tcopy_n(m4.begin(), sy, rv.begin() + sx + sy + sx);\n\n\t}\n\tif(bq == 0){\n\t\tcopy_n(m1.begin(), sx, rv.begin() + sx + sy);\n\t}*/\n\n\t/*\n\tif(sx < 10){\n\t\trep(i, sx){\n\t\t\tprintf(\"%d \", m1[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\trep(i, sx){\n\t\t\tprintf(\"%d \", m2[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t\trep(i, sy){\n\t\t\tprintf(\"%d \", m3[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\trep(i, sy){\n\t\t\tprintf(\"%d \", m4[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\n\trep(i, sx){\n\t\tif(m1[i] && m2[sx - i - 1]){\n\t\t\tr -= 2;\n\t\t}\n\t}\n\trep(i, sy){\n\t\tif(m3[i] && m4[sy - i - 1]){\n\t\t\tr -= 2;\n\t\t}\n\t}\n\n\t/*printf(\"(%d %d %d %d) %d\\n\", x.a, x.b , x.c ,x.d ,r);\n\tif(rv.size() < 20){\n\t\trep(i, rv.size()){\n\t\t\tprintf(\"%d \", rv[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\n\treturn make_pair(r, rv);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\", &n, &r);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\trep(i, n){\n\t\t\tR p;\n\t\t\tscanf(\"%d%d%d%d\", &p.a, &p.b, &p.c, &p.d);\n\t\t\tv.push_back(p);\n\t\t}\n\n\t\tprintf(\"%d\\n\", area(v, R(0, 0, 1 << 14, 1 << 14)));\n\t\tif(r == 2){\n\t\t\tprintf(\"%d\\n\", around(v, R(0, 0, 1 << 14, 1 << 14)).first);\n\t\t}\n\t\tv.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nvoid fast_stream(){\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n}\ntypedef pair<pii,int> ppii;\nint N,R;\nint field[2][10011];\nvector<ppii> rangeSet[10010];\nint line[10010];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nconst int INF=1000000000;\nint main(){\n  fast_stream();\n  while(cin>>N>>R&&(N|R)){\n    int miny,minx,maxy,maxx;\n    miny=minx=INF;\n    maxx=maxy=-INF;\n    for(int i=0;i<10001;i++)rangeSet[i].clear();\n    memset(line,0,sizeof(line));\n    memset(field,0,sizeof(field));\n    for(int i=0;i<N;i++){\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2;\n      rangeSet[y1].push_back(make_pair(pii(x1,x2),1));\n      rangeSet[y2].push_back(make_pair(pii(x1,x2),-1));\n      maxy=max(y2+1,maxy);\n      maxx=max(x2,maxx);\n      miny=min(y1,miny);\n      minx=min(x1,minx);\n    }\n    int S=0;\n    int E=0;\n    int cur=miny%2;\n    int prv=cur^1;\n    for(int y=miny;y<maxy;y++){\n      memset(field[cur],0,sizeof(field[cur]));\n      for(int i=0;i<(int)rangeSet[y].size();i++){\n\tint sx=rangeSet[y][i].first.first;\n\tint ex=rangeSet[y][i].first.second;\n\tint a=rangeSet[y][i].second;\n\tfor(int j=sx;j<ex;j++)line[j]+=a;\n      }\n      for(int x=minx;x<maxx;x++){\n\tif(line[x]>0){\n\t  S++;\n\t  field[cur][x]=1;\n\t}\n      }\n      for(int x=minx;x<maxx;x++){\n\tif(field[prv][x]^field[cur][x])E++;\n\tif(field[cur][x]==1){\n\t  if(x-1<0||field[cur][x-1]==0)E++;\n\t  if(field[cur][x+1]==0)E++;\n\t}\n      }\n      swap(cur,prv);\n    }\n    cout<<S<<endl;\n    if(R==2)cout<<E<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\n#define rep(i, n) for ( int i = 0; i < (int)n; i++ )\nusing namespace std;\n\n#define MAX 10000\n#define BEGIN 1\n#define END 0\n\nclass Sheet{\n    public:\n    int x1, y1, x2, y2;\n    Sheet(){}\n    Sheet(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2){}\n\n    bool operator < ( const Sheet &s ) const {\n\tif ( x1 == s.x1 ) return y1 < s.y1;\n\treturn x1 < s.x1;\n    }\n};\n\nclass Event{ \n    public:\n    int id, mode, x;\n    Event(){}\n    Event( int id, int mode, int x): id(id), mode(mode), x(x){}\n\n    bool operator < ( const Event &e ) const{\n\tif ( x == e.x ) return mode > e.mode;\n\treturn x < e.x;\n    }\n};\n\nint n, ne;\nSheet S[MAX+1];\nEvent E[2*MAX+1];\nint r;\n\nint getHeight( multiset<pair<int, int> > &seg, int &group ){\n    group = 1;\n    if ( seg.size() == 0 ) return 0;\n    int w = 0;\n    int s, t;\n    multiset<pair<int, int> >::iterator it = seg.begin();\n    s = (*it).first;\n    t = (*it).second;\n    for (++it; it != seg.end(); it++ ){\n\tif ( (*it).first > t ){\n\t    w += (t - s);\n\t    s = (*it).first;\n\t    t = (*it).second;\n\t    group++;\n\t} else {\n\t    t = max( t, (*it).second);\n\t}\n    }\n    w += (t - s);\n    return w;\n}\n\nvoid sweep(){\n    multiset< pair<int, int> > cur;\n    int area = 0, vertical = 0, horizon = 0;\n    int height = 0, preH = 0, group = 0, prex = E[0].x;\n\n    for ( int e = 0; e < ne; e++ ){\n\tEvent ev = E[e];\n\tarea += (ev.x - prex)*height;\n\thorizon += (ev.x - prex)*2*group;\n\n\tif ( ev.mode == BEGIN ) cur.insert( make_pair( S[ev.id].y1, S[ev.id].y2) );\n\telse  cur.erase( cur.find(make_pair( S[ev.id].y1, S[ev.id].y2)) );\n\n\tpreH = height;\n\tprex = ev.x;\n\n\theight = getHeight(cur, group);\n\n\tif ( ev.mode == BEGIN ) vertical += height - preH;\n\telse  vertical += preH - height;\n    }\n\n    printf(\"%d\\n\", area);\n    if ( r == 2 ) printf(\"%d\\n\", vertical + horizon);\n}\n\nint main(){\n    while(1){\n\tscanf(\"%d %d\", &n, &r);\n\tif ( n == 0 && r == 0) break;\n\tne = 0;\n\trep(i, n) scanf(\"%d %d %d %d\", &S[i].x1, &S[i].y1, &S[i].x2, &S[i].y2);\n\tsort( S, S+n);\n\trep(i, n){\n\t    E[ne++] = Event(i, BEGIN, S[i].x1);\n\t    E[ne++] = Event(i, END, S[i].x2);\n\t}\n\tsort( E, E + ne );\n\tsweep();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X1[10010], X2[10010], Y1[10010], Y2[10010];\nint n, r, p[3][10010];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> r; if (n == 0 && r == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\t\t}\n\t\tint cnt1 = 0, cnt2 = 0;\n\t\tfor (int i = 0; i < 10010; i++) {\n\t\t\tfor (int j = 0; j < 30030; j++)p[j / 10010][j % 10010] = 0;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tint G = i + j, H = j + 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (X1[k] <= G && G < X2[k]) {\n\t\t\t\t\t\tp[H][Y1[k]]++; p[H][Y2[k]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 1; k < 10010; k++)p[j][k] += p[j][k - 1];\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10010; j++) {\n\t\t\t\tif (p[1][j] >= 1)cnt1++;\n\t\t\t\tif (i == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\tif (p[1][j] == 0 && p[2][j] >= 1)cnt2++;\n\t\t\t\tif (p[1][j] >= 1 && p[2][j] == 0)cnt2++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10010; j++) {\n\t\t\t\tif (j == 0 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j == 10009 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j >= 1 && j <= 10008) {\n\t\t\t\t\tif (p[1][j] >= 1 && p[1][j + 1] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j] == 0 && p[1][j + 1] >= 1)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 1)cout << cnt1 << endl;\n\t\tif (r == 2)cout << cnt1 << endl << cnt2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint min_x,min_y,max_x,max_y;\n\ninline void Imos(vector<vector<unsigned char> > &plane){\n\tREP(y,0,plane[0].size()){\n\t\tREP(x,1,plane.size()){\n\t\t\tplane[x][y]+=plane[x-1][y];\n\t\t}\n\t}\n\tREP(x,0,plane.size()){\n\t\tfor(int y=plane[0].size()-2; y>=0; --y){\n\t\t\tplane[x][y]+=plane[x][y+1];\n\t\t}\n\t}\n}\n\ninline int CalcSize(vector<vector<unsigned char> > &plane){\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(plane[x][y]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(vector<vector<unsigned char> > &plane,vector<vector<bool> > &has_done,int x,int y,int W,int H){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[x][y]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[nx][ny]){\n\t\t\t\tif(plane[nx][ny]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[nx][ny]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int CalcLength(vector<vector<unsigned char> > &plane,int n,vector<int> &X,vector<int> &Y){\n\tvector<vector<bool> > has_done(plane.size(),vector<bool>(plane[0].size()));\n\tint result=0;\n\t/*\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(!has_done[x][y]&&plane[x][y]>0){\n\t\t\t\tresult+=BFS(plane,has_done,x,y,plane.size(),plane[0].size());\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tREP(i,0,n){\n\t\tif(!has_done[X[i]][Y[i]]&&plane[X[i]][Y[i]]>0) result+=BFS(plane,has_done,X[i],Y[i],plane.size(),plane[0].size());\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,2){\n\t\t\tX[i].resize(N);\n\t\t\tY[i].resize(N);\n\t\t}\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\t//X[j].push_back(x);\n\t\t\t\t//Y[j].push_back(y);\n\t\t\t\tX[j][i]=x;\n\t\t\t\tY[j][i]=y;\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\tvector<vector<unsigned char> > plane(max_x+4-min_x,vector<unsigned char>(max_y+4-min_y));\n\t\tREP(i,0,N){\n\t\t\tplane[X[0][i]+1-min_x][Y[1][i]+1-min_y]+=1;\n\t\t\tplane[X[1][i]+2-min_x][Y[0][i]-min_y]+=1;\n\t\t\tplane[X[0][i]+1-min_x][Y[0][i]-min_y]+=-1;\n\t\t\tplane[X[1][i]+2-min_x][Y[1][i]+1-min_y]+=-1;\n\t\t}\n\t\tImos(plane);\n\t\tcout << CalcSize(plane) << endl;\n\t\tif(R==2) cout << CalcLength(plane,N,X[0],Y[0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint n,r;\nchar canvas[10003][10003]={{0}};\nint main()\n{\n\twhile(cin>>n >>r,n)\n\t{\n\n\t\tint mx1=10003,my1=10003,mx2=0,my2=0;\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin>>x1;x1++;\n\t\t\tcin>>y1;y1++;\n\t\t\tcin>>x2;x2++;\n\t\t\tcin>>y2;y2++;\n\t\t\tmx1=min(mx1,x1);\n\t\t\tmy1=min(my1,y1);\n\t\t\tmx2=max(mx2,x2);\n\t\t\tmy2=max(my2,y2);\n\t\t\tfor(int i2=y1;i2<y2;i2++){\n\t\t\t\tfor(int i=x1;i<x2;i++){\n\t\t\t\t\tcanvas[i2][i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tif(n-1){\n\t\t\tint d=0;\n\t\t\tfor(int i2=my1;i2<my2;i2++){\n\t\t\t\tfor(int i=mx1;i<mx2;i++){\n\t\t\t\t\tif(canvas[i2][i]){\n\t\t\t\t\t\tif(i2==my1 || i == mx1 || i2 == my2-1 || i == mx2-1){\n\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\tif((i2==my1 && i == mx1 ) || (i2==my1 && i == mx2 -1 ) ||(i2==my2 -1 && i == mx1  ) ||(i2==my2 -1 && i == mx2 -1 ) ){\n\t\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\td+=(canvas[i2+1][i]+canvas[i2-1][i]+canvas[i2][i+1]+canvas[i2][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout <<count << endl;\n\t\t\tcout << d << endl;\n\t\t}else{\n\t\t\tfor(int i2=my1;i2<my2;i2++){\n\t\t\t\tfor(int i=mx1;i<mx2;i++){\n\t\t\t\t\tif(canvas[i2][i])count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout <<count << endl;\n\t\t}\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\twhile( cin >> N >> R, N || R ) {\n\t\tvector<vector<int>>data( 10002, vector<int>( 10002 ) );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tdata[x1][y1]++;\n\t\t\tdata[x2][y2]++;\n\t\t\tdata[x1][y2]--;\n\t\t\tdata[x2][y1]--;\n\t\t}\n\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\n\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint map[10003][10003];\n\nint main(void){\n\twhile(1){\n\t\tint n,r,ans=0,ans2=0,minx=10001,miny=10001,maxx=0,maxy=0;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tmap[x1][y1]-=1;\n\t\t\tmap[x2][y1]+=1;\n\t\t\tmap[x1][y2]+=1;\n\t\t\tmap[x2][y2]-=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tt+=map[j][i];\n\t\t\t\tmap[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tt+=map[i][j];\n\t\t\t\tmap[i][j]=t;\n\t\t\t\tif(map[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\t\tif(map[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fi first\n#define sec second\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        cin >> n >> r;\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            cin >> a >> b >> c >> d;\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n                cout << imos[i%2][j];\n            }\n            cout << endl;\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint map[100000][100000];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tmap[x1][y1]-=1;\n\t\t\tmap[x2][y1]+=1;\n\t\t\tmap[x1][y2]+=1;\n\t\t\tmap[x2][y2]-=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tt+=map[j][i];\n\t\t\t\tmap[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tt+=map[i][j];\n\t\t\t\tmap[i][j]=t;\n\t\t\t\tif(map[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\t\tif(map[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint n,r,px,pX,py,pY;\nbool e[10000][10000];\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tfor(int i=px;i<pX;i++)for(int j=py;j<pY;j++)e[i][j]=0;\n\t\t\n\t\tint mx=10000,MX=0,my=10000,MY=0;\n\t\trep(i,n){\n\t\t\tint x,y,X,Y; scanf(\"%d%d%d%d\",&x,&y,&X,&Y);\n\t\t\tfor(int i=y;i<Y;i++)for(int j=x;j<X;j++)e[i][j]=1;\n\t\t\tmx=min(mx,x); MX=max(MX,X);\n\t\t\tmy=min(my,y); MY=max(MY,Y);\n\t\t}\n\t\tint a=0,p=0;\n\t\tfor(int i=my;i<MY;i++)for(int j=mx;j<MX;j++)if(e[i][j])\n\t\t{\n\t\t\ta++;\n\t\t\trep(d,4){\n\t\t\t\tint y=i+dy[d],x=j+dx[d];\n\t\t\t\tif(y<0||y>=10000||x<0||x>=10000||!e[y][x])p++;\n\t\t\t}\n\t\t}\n\t\tif(r==1)printf(\"%d\\n\",a);\n\t\telse printf(\"%d\\n%d\\n\",a,p);\n\t\t\n\t\tpx=mx; pX=MX; py=my; pY=MY;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<list>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define S second\n#define F first\nstruct Rect{\n  int x1,y1,x2,y2;\n  Rect(){}\n  Rect(int x1,int y1,int x2,int y2) : x1(x1),y1(y1),x2(x2),y2(y2) {}\n  bool operator < (const Rect& oth)const{\n    if(y2 == oth.y2){\n      return y1 < oth.y1;\n    }\n    return y2 < oth.y2;\n  }\n};\nstruct Act{\n  int up,down;\n  Act(){}\n  Act(int up,int down) : up(up),down(down) {}\n};\nint N,R;\nRect S[10002];\nvector<Act> A[10002];\nint main(){\n  while(1){\n    scanf(\"%d %d\",&N,&R);\n    if(!N && !R) break;\n    int minx=100000,maxx=0;\n    for(int i=0;i<N;i++){\n      scanf(\"%d %d %d %d\",&S[i].x1,&S[i].y1,&S[i].x2,&S[i].y2);\n      minx = min(S[i].x1,minx); maxx = max(S[i].x2,maxx);\n    }\n    sort(S,S+N);\n    for(int i=N-1;i>-1;i--){\n      //      printf(\"%d %d %d %d\\n\",S[i].x1,S[i].y1,S[i].x2,S[i].y2);\n      for(int x = S[i].x1; x < S[i].x2; x++){\n\tif(A[x].empty()){\n\t  A[x].push_back(Act(S[i].y2,S[i].y1));\n\t} else {\n\t  int dw = A[x].back().down;\n\t  if(dw > S[i].y2){\n\t    A[x].push_back(Act(S[i].y2,S[i].y1));\n\t  } else if ( dw > S[i].y1 )\n\t    A[x].back().down = S[i].y1;\n\t}\n      }\n    }\n    int res1=0;\n    int res2=0;\n    int sump=0;\n    for(int i=0;i<(int)A[minx].size();i++){\n      res1 += (A[minx][i].up - A[minx][i].down);\n      res2 += (A[minx][i].up - A[minx][i].down);\n    }\n    sump = res2;\n    res2 += (int)A[minx].size() * 2;\n    for(int i=minx+1; i<=maxx; i++){\n      int l=0;\n      int sumk=0;\n      int sumn=0;\n      //      printf(\"%d %d\\n\",res1,res2);\n      for(int j=0;j<(int)A[i].size();j++){\n\tres1 += (A[i][j].up - A[i][j].down);\n\tsumn += (A[i][j].up - A[i][j].down);\n\tbool f=false;\n\tdo{\n\t  f=false;\n\t  if(A[i-1][l].up == A[i][j].up){\n\t    if(A[i-1][l].down >= A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    }else{\n\t      sumk += (A[i][j].up - A[i][j].down);\n\t    }\n\t  } else if(A[i-1][l].up > A[i][j].up && A[i][j].up > A[i-1][l].down){\n\t    if(A[i-1][l].down == A[i][j].down){\n\t      sumk += (A[i][j].up-A[i][j].down);\n\t      f=true;\n\t    }else if(A[i-1][l].up > A[i][j].down && A[i][j].down > A[i-1][l].down){\n\t      sumk += (A[i][j].up - A[i][j].down);\n\t    } else{\n\t      sumk += (A[i][j].up - A[i-1][l].down);\n\t      f=true;\n\t    }\n\t  } else if(A[i][j].up > A[i-1][l].up && A[i-1][l].up > A[i][j].down){\n\t    if(A[i-1][l].down == A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    }else if(A[i][j].up > A[i-1][l].down && A[i-1][l].down > A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    } else {\n\t      sumk += (A[i-1][l].up - A[i][j].down);\n\t    }\n\t  } else if(A[i-1][l].down >= A[i][j].up) f=true;\n\t  if(f) l++;\n\t} while(f && l < (int)A[i-1].size());\n      }\n      res2 += (sump - sumk);\n      res2 += (sumn - sumk);\n      res2 += (int)A[i].size()*2;\n      sump = sumn;\n    }\n    printf(\"%d\\n\",res1);\n    if(R==2) printf(\"%d\\n\",res2);\n\n    for(int i=minx; i<=maxx; i++) A[i].clear();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> >in;\n\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<P> v[10001];\n\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n      int b=v[i][0].first,e=v[i][0].second;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].first,E=v[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<in.size();i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].first,e=v[i][0].second;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].first,E=v[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint m[10003][10003] = {0};\n\nint main() {\n\tint n, r;\n\twhile (cin >> n >> r, n || r) {\n\t\tfill(&m[0][0], &m[0][0] + 10002*10002, 0);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\t++x1, ++y1;//, ++x2, ++y2;\n\t\t\tif (x2 != 0 && y2 != 0) {\n\t\t\t\t++m[y1][x1], --m[y1][x2+1];\n\t\t\t\t--m[y2+1][x1], ++m[y2+1][x2+1];\n\t\t\t}\n\t\t}\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tm[y][x+1] += m[y][x];\n\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tm[y+1][x] += m[y][x];\n\n\t\tint s = 0, l = 0;\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tif (m[y][x])\n\t\t\t\t\tl += !m[y-1][x] + !m[y+1][x] + !m[y][x-1] + !m[y][x+1],\n\t\t\t\t\t++s;\n\n\t\tcout << s << endl;\n\t\tif (r == 2) cout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, r;\n        cin >> n >> r;\n        if(n == 0)\n            return 0;\n\n        vector<int> x1(n), y1(n), x2(n), y2(n);\n        for(int i=0; i<n; ++i)\n            cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\n        int ret1 = 0;\n        int ret2 = 0;\n        for(int a=0; a<11; ++a){\n            int yMin = a * 1000 - 1;\n            int yMax = (a+1) * 1000;\n            for(int b=0; b<11; ++b){\n                int xMin = b * 1000 - 1;\n                int xMax = (b+1) * 1000;\n\n                vector<vector<int> > s(1001, vector<int>(1001, 0));\n                for(int i=0; i<n; ++i){\n                    if(y2[i] < yMin || x1[i] < xMin || y1[i] > yMax || x1[i] > xMax)\n                        continue;\n\n                    ++ s[max(yMin, y1[i])-yMin][max(xMin, x1[i])-xMin];\n                    if(x2[i] <= xMax)\n                        -- s[max(yMin, y1[i])-yMin][x2[i]-xMin];\n                    if(y2[i] <= yMax)\n                        -- s[y2[i]-yMin][max(xMin, x1[i])-xMin];\n                    if(y2[i] <= yMax && x2[i] <= xMax)\n                        ++ s[y2[i]-yMin][x2[i]-xMin];\n                }\n\n                for(int i=0; i<1001; ++i){\n                    for(int j=0; j<1000; ++j){\n                        s[i][j+1] += s[i][j];\n                    }\n                }\n                for(int i=0; i<1001; ++i){\n                    for(int j=0; j<1000; ++j){\n                        s[j+1][i] += s[j][i];\n                    }\n                }\n\n                for(int i=0; i<1000; ++i){\n                    for(int j=0; j<1000; ++j){\n                        if(s[i][j] > 0)\n                            ++ ret1;\n                        if((s[i][j] > 0) ^ (s[i+1][j] > 0))\n                            ++ ret2;\n                        if((s[i][j] > 0) ^ (s[i][j+1] > 0))\n                            ++ ret2;\n                    }\n                }\n            }\n        }\n\n        cout << ret1 << endl;\n        if(r == 2)\n            cout << ret2 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 30000;\n\nclass st{\npublic:\n  int height;\n  int out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\nint y[N];\nvector<st> iny[N];\n\n/*\n29\n29\n\n80\n\n45\n\n\n\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int &py){\n  vector<int> xd,yd;\n  rep(i,n){\n    xd.pb(x1[i]);\n    xd.pb(x2[i]);\n    yd.pb(y1[i]);\n    yd.pb(y2[i]);\n  }\n  sort(ALL(xd));\n  sort(ALL(yd));\n  xd.erase(unique(ALL(xd)),xd.end());\n  yd.erase(unique(ALL(yd)),yd.end());\n  rep(i,xd.size())x[px++]=xd[i],inx[i].clear();\n  rep(i,yd.size())y[py++]=yd[i],iny[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    while(j < px && x[j] < x2[i]){\n      inx[j].pb((st){y1[i],1});\n      inx[j].pb((st){y2[i],-1});\n      j++;\n    }\n    j = lower_bound(ALL(yd),y1[i])-yd.begin();\n    while(j < py && y[j] < y2[i]){\n      iny[j].pb((st){x1[i],1});\n      iny[j].pb((st){x2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,py);\n    pair<int,int> ansx=solve(px,inx,x);\n    pair<int,int> ansy= solve(py,iny,y);\n    cout << ansx.first << endl;\n    if (q == 2)cout << ansx.second+ansy.second << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include <map>\n#include<cstring>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\nshort node[10001];\nshort state_before[10001];\nshort map_before[10001];\n\n\nmap<int,list<pair<int,int>>> points;\n\n\n\nvoid read_points(int tate){\n    memcpy(map_before,node,sizeof node);\n    memset(node,0,sizeof(node));    \n    for(auto tmp:points[tate]){\n        node[tmp.first]+=tmp.second;\n    }\n}\nint main(){\n    int n,r;\n    int S=0;\n    int L=0;\n    int deltaS=0,deltaL=0;\n    ios::sync_with_stdio(false);\n  \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n        \n        points.clear();\n        int x1,y1,x2,y2;\n        int max_x=0,min_x=10000,max_y=0,min_y=10000;\n        for(int i=0;i<n;i++){\n            cin>>x1>>y1>>x2>>y2;\n \n            if(points.find(y1)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y1]=tmp;\n            }\n            if(points.find(y2)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y2]=tmp;\n            }\n            points[y1].push_back(make_pair(x1,1));\n            points[y1].push_back(make_pair(x2,-1));\n            points[y2].push_back(make_pair(x1,-1));\n            points[y2].push_back(make_pair(x2,1));\n            if(max_x<x2)max_x=x2;\n            if(max_y<y2)max_y=y2;\n            if(min_x>x1)min_x=x1;\n            if(min_y>y1)min_y=y1;\n            \n        }\n        \n        \n        S=0;\n        L=0;\n\n        for(int h=min_y;h<=max_y;h++){\n            if(points.find(h)==points.end()){\n                S+=deltaS;\n                L+=deltaL;\n                continue;\n            }\n            deltaL=0,deltaS=0;\n            read_points(h);\n            int yoko_state=0;\n            for(int w=min_x;w<=max_x;w++){\n                yoko_state+=node[w];\n                node[w]=yoko_state;\n                if(h!=0){\n                    node[w]+=state_before[w];\n                }\n                state_before[w]=node[w];\n                //std::cout << node[w] ;\n                if(node[w]>0){\n                   S++;\n                   deltaS++;\n                   if(w==0){L+=2;deltaL+=2;}\n                   else if(node[w-1]==0){L+=2;deltaL+=2;}\n                   if(h==0){L+=2;}\n                   else if(map_before[w]==0){L+=2;}\n                }\n                \n                \n            }\n            //cout<<endl;\n            \n        }\n\n\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\ninline void makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  rep(i,n){\n    xd[px++]=x1[i];\n    xd[px++]=x2[i];\n  }\n  sort(xd,xd+px);\n  px=unique(xd,xd+px)-xd;\n  rep(i,px)IN[i].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, r;\n    while (cin >> n >> r, n) {\n        int area = 0, len = 0;\n        vector<pair<pair<int, int>, pair<int, int> > > sheets(n + 1);\n        vector<int> nextx(10005, -1);\n        for (int i = 0; i < n; i++) {\n            cin >> sheets[i].first.first >> sheets[i].first.second >>\n                sheets[i].second.first >> sheets[i].second.second;\n        }\n        sheets[n] = make_pair(make_pair(10005,0), make_pair(10005,0));\n        sort(sheets.begin(), sheets.end());\n        \n        int bx = 0;\n        for (int i = 0; i <= n; i++) {\n            int x = sheets[i].first.first;\n            int nx = sheets[i].second.first;\n            if (x != bx) {\n                for (int j = 0; j <= 10000; j++) {\n                    if (nextx[j] < bx) continue;\n                    int ulen = (j == 0 ? -1 : nextx[j-1]), blen = nextx[j+1];\n                    //cerr << j << \" +\" << max(0, min(nextx[j], x) - max(bx, ulen)) +\n                    //       max(0, min(nextx[j], x) - max(bx, blen)) << endl;\n                    len += max(0, min(nextx[j], x) - max(bx, ulen)) +\n                           max(0, min(nextx[j], x) - max(bx, blen));\n                    if (nextx[j] < x) {\n                        len++;\n                        //cerr << j << \" start\" << endl;\n                        area += nextx[j] - bx;\n                    } else {\n                        area += x - bx;\n                    }\n                }\n                //cerr << x << \" \" << len << endl;\n            }\n            for (int j = sheets[i].first.second; j < sheets[i].second.second; j++) {\n                if (nextx[j] < x) {\n                    len++;\n                    //cerr << j << \" end\" << endl;\n                }\n                nextx[j] = max(nextx[j], nx);\n            }\n            bx = x;\n        }\n        \n        cout << area << endl;\n        if (r == 2) cout << len << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      // return (x + y) * (x + y + 1) / 2 + y;\n      hash<int> hasher;\n      return hasher(x) ^ hasher(y);\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint a[10005],b[10005],c[10005],d[10005];\nint main()\n{\nint n,m;\nwhile(1)\n{\n\tvector<P>y;\n\tvector<P>z;\n\tscanf(\"%d %d\",&n,&m); if(!n) return 0;\n\tint lim=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tlim=max(lim,d[i]-1);\n\t}\n\tint ret=0,ret2=0;\n\tint prev=INF;\n\tvector<P>prev2(0);\n\tfor(int i=0;i<=lim;i++)\n\t{\n\t\ty.clear();\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(b[j]<=i && i<d[j]) y.pb(mp(a[j],c[j]));\n\t\t}\n\t\tif(y.empty()) continue;\n\t\tsort(y.begin(),y.end());\n\t\tint beg=y[0].first;\n\t\tint en=y[0].second;\n\t\ty.pb(mp(INF,INF));\n\t\tz.clear();\n\t\tfor(int j=1;j<y.size();j++)\n\t\t{\n\n\t\t\tif(en<y[j].first)\n\t\t\t{//cout << beg << \" \" << en << endl;\n\n\t\t\t\tz.pb(mp(beg,en));\n\t\t\t\tret+=(en-beg); ret2+=2; //cout << 2 << \"HB\" <<endl;\n\t\t\t\tif(i==lim) ret2+=(en-beg);\n\t\t\t\tif(prev!=i-1)\n\t\t\t\t{\n\t\t\t\t\tret2+=(en-beg); //cout << en-beg << \"HB\" <<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret2+=(en-beg);\n\t\t\t\t\tfor(int cur=0;cur<prev2.size();cur++)\n\t\t\t\t\t{\n//cout << prev2[cur].first << \" \" << prev2[cur].second << endl;\n\t\t\t\t\t\tret2-=(max(0,min(en,prev2[cur].second)-max(beg,prev2[cur].first))*2);\n//cout << -(max(0,min(en,prev2[cur].second)-max(beg,prev2[cur].first))*2) << \"HB\" <<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbeg=y[j].first;\n\t\t\t\ten=y[j].second;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(y[j].second<=en)\n\t\t\t\t{\n\t\t\t\t\ten=max(en,y[j].second);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ten=max(en,y[j].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int cur=0;cur<prev2.size();cur++)\n\t\t{//if(i==lim) cout << (prev2[cur].second-prev2[cur].first) << \"HB\" <<endl;\n\t\t\tret2+=(prev2[cur].second-prev2[cur].first);\n\n\t\t}\n//printf(\"%d\\n\",ret2);\n\t\tprev=i;\n\t\tprev2=z;\n\t}\n\tprintf(\"%d\\n\",ret);\n\tif(m==2) printf(\"%d\\n\",ret2);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nstruct Rect {int left, bottom, right, top;};\n\nenum {IN, OUT};\nstruct Node {\n    int y;\n    bool in;\n    Node(int y, bool in) :y(y), in(in) {}\n    bool operator<(const Node& n) const {return y != n.y ? y < n.y : in > n.in;}\n};\n\nint main() {\n    int n, R;\n    while(cin >> n >> R, n | R) {\n        vector<Rect> rect(n);\n        for(auto& r: rect) cin >> r.left >> r.bottom >> r.right >> r.top;\n\n        set<int> line;\n        for(const auto& r: rect) {\n            line.insert(r.left);\n            line.insert(r.right);\n        }\n\n        int area, circumference;\n        int edge, touch, pre_x;\n        area = circumference = 0;\n        edge = touch = pre_x = 0;\n        for(const auto& l: line) {\n            multiset<Node> node;\n            for(const auto& r: rect) {\n                if(l < r.left || r.right <= l) continue;\n                node.insert(Node(r.bottom, IN));\n                node.insert(Node(r.top, OUT));\n            }\n\n            area += touch * (l - pre_x);\n            circumference += edge * (l - pre_x);\n            pre_x = l;\n\n            edge = touch = 0;\n            int in, pre_y;\n            in = pre_y = 0;\n            for(const auto& n: node) {\n                if(!in) {\n                    pre_y = n.y;\n                    ++edge;\n                }\n                in += n.in ? 1 : -1;\n                if(in == 0) ++edge;\n                touch += n.y - pre_y;\n                pre_y = n.y;\n            }\n\n            enum POS {LEFT, MIDDLE, RIGHT};\n            struct NodeV {\n                int y;\n                bool in;\n                POS pos;\n                NodeV(int y, bool in, POS pos) :y(y), in(in), pos(pos) {}\n                bool operator<(const NodeV& n) const {return y != n.y ? y < n.y : in > n.in;}\n            };\n            multiset<NodeV> node_v;\n            for(const auto& r: rect) {\n                if(l < r.left || r.right < l) continue;\n                if(r.left < l && l < r.right) {\n                    node_v.insert(NodeV(r.bottom, IN, MIDDLE));\n                    node_v.insert(NodeV(r.top, OUT, MIDDLE));\n                } else if(l == r.left) {\n                    node_v.insert(NodeV(r.bottom, IN, LEFT));\n                    node_v.insert(NodeV(r.top, OUT, LEFT));\n                } else {\n                    node_v.insert(NodeV(r.bottom, IN, RIGHT));\n                    node_v.insert(NodeV(r.top, OUT, RIGHT));\n                }\n            }\n            int left, right, middle;\n            in = pre_y = left = right = middle = 0;\n            for(const auto& n: node_v) {\n                if(!in) pre_y = n.y;\n                if(!middle) if(left == 0 || right == 0) circumference += n.y - pre_y;\n                if(n.in) {\n                    ++in;\n                    if(n.pos == MIDDLE) ++middle;\n                    if(n.pos == LEFT) ++left;\n                    if(n.pos == RIGHT) ++right;\n                } else {\n                    --in;\n                    if(n.pos == MIDDLE) --middle;\n                    if(n.pos == LEFT) --left;\n                    if(n.pos == RIGHT) --right;\n                }\n                pre_y = n.y;\n            }\n        }\n\n        cout << area << endl;\n        if(R == 2) cout << circumference << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint n, r;\n\twhile (scanf(\"%d%d\", &n, &r), n) {\n\t\tmap<short, map<short, short>>sum;\n\t\tint h = 0, w = 0;\n\t\trep(i, n) {\n\t\t\tint x1, y1, x2, y2; scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\th = max(h, x2); w = max(w, y2);\n\t\t\tsum[x1][y1]++; sum[x1][y2]--; sum[x2][y1]--; sum[x2][y2]++;\n\t\t}\n\t\th++; w++;\n\t\trep(i, h)for (int j = 1; j < w; j++)sum[i][j] += sum[i][j - 1];\n\t\trep(i, w)for (int j = 1; j < h; j++)sum[j][i] += sum[j - 1][i];\n\t\tint a = 0, b = 0;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (sum[i][j]) {\n\t\t\t\ta++;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\tif (nx < 0 || nx >= h || ny < 0 || ny >= w || !sum[nx][ny])b++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", a);\n\t\tif (r == 2)printf(\"%d\\n\", b);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){return p.F < q.F;}\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){return p.S < q.S;}\n\nint main(void){\n  \n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    \n    vector<pair<P,P> > in;\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n    \n    sort(in.begin(),in.end(),cmp_x);\n    \n    int S=0,L=0;\n    vector<P>v;\n    for(int i=0;i+1<10001;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F)\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n      }\n      \n      if(v.size()!=0){\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n    \n    if(r==2){  \n      sort(in.begin(),in.end(),cmp_y);\n      \n      for(int i=0;i+1<10001;i++){\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\t}\n\tif(v.size()!=0){\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r,n|r){\n    vector<P>vx[10001],vy[10001];\n    vector<pair<P,P> >in;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n\n    // update right_area_end_point\n    repeat_with_index(y_size, y_i) {\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X1[10010], X2[10010], Y1[10010], Y2[10010];\nint n, r, p[3][10010];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> r; if (n == 0 && r == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\t\t}\n\t\tint cnt1 = 0, cnt2 = 0;\n\t\tfor (int i = 0; i < 10010; i++) {\n\t\t\tfor (int j = 0; j < 30030; j++)p[j / 10010][j % 10010] = 0;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (X1[k] <= (i + j) && (i + j) < X2[k]) {\n\t\t\t\t\t\tp[j + 1][Y1[k]]++; p[j + 1][Y2[k]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 1; k < 10010; k++)p[j][k] += p[j][k - 1];\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10010; j++) {\n\t\t\t\tif (p[1][j] >= 1)cnt1++;\n\t\t\t\tif (i == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\tif (p[1][j] == 0 && p[2][j] >= 1)cnt2++;\n\t\t\t\tif (p[1][j] >= 1 && p[2][j] == 0)cnt2++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10010; j++) {\n\t\t\t\tif (j == 0 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j == 10009 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j >= 1 && j <= 10008) {\n\t\t\t\t\tif (p[1][j] >= 1 && p[1][j + 1] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j] == 0 && p[1][j + 1] >= 1)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 1)cout << cnt1 << endl;\n\t\tif (r == 2)cout << cnt1 << endl << cnt2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        // repete_from_to(y_i, y - 1, p_i) {\n        //   assign_if_larger(right_area_end_point[p_i], x);\n        // }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nshort int[3000][3000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<list>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define S second\n#define F first\nstruct Rect{\n  int x1,y1,x2,y2;\n  Rect(){}\n  Rect(int x1,int y1,int x2,int y2) : x1(x1),y1(y1),x2(x2),y2(y2) {}\n  bool operator < (const Rect& oth)const{\n    if(y2 == oth.y2){\n      return y1 < oth.y1;\n    }\n    return y2 < oth.y2;\n  }\n};\nstruct Act{\n  int up,down;\n  Act(){}\n  Act(int up,int down) : up(up),down(down) {}\n};\nint N,R;\nRect S[10002];\nvector<Act> A[10002];\nint main(){\n  while(1){\n    scanf(\"%d %d\",&N,&R);\n    if(!N && !R) break;\n    int minx=100000,maxx=0;\n    for(int i=0;i<N;i++){\n      scanf(\"%d %d %d %d\",&S[i].x1,&S[i].y1,&S[i].x2,&S[i].y2);\n      minx = min(S[i].x1,minx); maxx = max(S[i].x2,maxx);\n    }\n    sort(S,S+N);\n    for(int i=N-1;i>-1;i--){\n      //      printf(\"%d %d %d %d\\n\",S[i].x1,S[i].y1,S[i].x2,S[i].y2);\n      for(int x = S[i].x1; x < S[i].x2; x++){\n\tif(A[x].empty()){\n\t  A[x].push_back(Act(S[i].y2,S[i].y1));\n\t} else {\n\t  int dw = A[x].back().down;\n\t  if(dw-1 > S[i].y2){\n\t    A[x].push_back(Act(S[i].y2,S[i].y1));\n\t  } else if ( dw > S[i].y1 )\n\t    A[x].back().down = S[i].y1;\n\t}\n      }\n    }\n    int res1=0;\n    int res2=0;\n    int sump=0;\n    for(int i=0;i<(int)A[minx].size();i++){\n      res1 += (A[minx][i].up - A[minx][i].down);\n      res2 += (A[minx][i].up - A[minx][i].down);\n    }\n    sump = res2;\n    res2 += (int)A[minx].size() * 2;\n    for(int i=minx+1; i<=maxx; i++){\n      int l=0;\n      int sumk=0;\n      int sumn=0;\n      //      printf(\"%d %d\\n\",res1,res2);\n      for(int j=0;j<(int)A[i].size();j++){\n\tres1 += (A[i][j].up - A[i][j].down);\n\tsumn += (A[i][j].up - A[i][j].down);\n\tbool f=false;\n\tdo{\n\t  f=false;\n\t  if(A[i-1][l].up == A[i][j].up){\n\t    if(A[i-1][l].down >= A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    }else{\n\t      sumk += (A[i][j].up - A[i][j].down);\n\t    }\n\t  } else if(A[i-1][l].up >= A[i][j].up && A[i][j].up >= A[i-1][l].down){\n\t    if(A[i-1][l].up >= A[i][j].down && A[i][j].down >= A[i-1][l].down){\n\t      sumk += (A[i][j].up - A[i][j].down);\n\t    } else{\n\t      sumk += (A[i-1][l].up - A[i][j].down);\n\t      f=true;\n\t    }\n\t  } else if(A[i][j].up >= A[i-1][l].up && A[i-1][l].up >= A[i][j].down){\n\t    if(A[i][j].up >= A[i-1][l].down && A[i-1][l].down >= A[i][j].down){\n\t      sumk += (A[i-1][l].up - A[i-1][l].down);\n\t      f=true;\n\t    } else {\n\t      sumk += (A[i][j].up - A[i-1][l].down);\n\t    }\n\t  }\n\t  if(f) l++;\n\t} while(f && l < (int)A[i-1].size());\n      }\n      res2 += (sump - sumk);\n      res2 += (sumn - sumk);\n      res2 += (int)A[i].size()*2;\n      sump = sumn;\n    }\n    printf(\"%d\\n\",res1);\n    if(R==2) printf(\"%d\\n\",res2);\n\n    for(int i=minx; i<=maxx; i++) A[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    vector<P>v;\n    for(int i=0;i+1<10001;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n\tif(i<in[j].S.F)break;\n      }\n     \n      if(v.size()!=0){\n\tsort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end(),cmp_x);\n\n      for(int i=0;i+1<10001;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\n\t  if(i<in[j].F.F)break;\n\t}\n\tif(v.size()!=0){\n\t  sort(v.begin(),v.end());\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <set>\n#include <list>\nusing namespace std;\n\ntypedef pair< pair<int,int> , pair<int,int> > DATA;\nDATA in[10000];\n\nbool cmp1( const DATA &a , const DATA &b ){\n\treturn a.first < b.first;\n}\nbool cmp2( const DATA &a , const DATA &b ){\n\treturn a.second < b.second;\n}\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q && n){\n\t\tint area = 0 , perimeter = 0;\n\t\tlist < pair<int,int> > tr[10001] , tc[10001];\n\t\t\n\t\t// input \n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1 , y1 , x2 , y2;\n\t\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\t\tin[i].first.first   = x1;\n\t\t\tin[i].first.second  = x2;\n\t\t\tin[i].second.first  = y1;\n\t\t\tin[i].second.second = y2;\n\t\t}\n\t\t\n\t\t// x-yuusen sort\n\t\tsort(in,in+n,cmp1);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1 , y1 , x2 , y2;\n\t\t\tx1 = in[i].first.first;\n\t\t\tx2 = in[i].first.second;\n\t\t\ty1 = in[i].second.first;\n\t\t\ty2 = in[i].second.second;\n\t\t\tfor(int i = y1 ; i < y2 ; i++) tr[i].push_back(make_pair(x1,x2));\n\t\t}\n\t\t// y-yuusen sort (perimeter hakarutoki ni hituyou) \n\t\tif(q == 2){\n\t\t\tsort(in,in+n,cmp2);\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tint x1 , y1 , x2 , y2;\n\t\t\t\tx1 = in[i].first.first;\n\t\t\t\tx2 = in[i].first.second;\n\t\t\t\ty1 = in[i].second.first;\n\t\t\t\ty2 = in[i].second.second;\n\t\t\t\tif(q==2) for(int i = x1 ; i < x2 ; i++) tc[i].push_back(make_pair(y1,y2));\n\t\t\t}\n\t\t}\n\t\t\n\t\t// merge\n\t\tfor(int i = 0 ; i < 10001 ; i++){\n\t\t\tif(tr[i].size() == 0) continue;\n\t\t\tlist< pair<int,int> >::iterator it = tr[i].begin();\n\t\t\tint s = it->first , e = it->second;\n\t\t\t++it;\n\t\t\tfor(; it != tr[i].end() ; ++it){\n\t\t\t\tint S = it->first , E = it->second;\n\t\t\t\tif(S <= e){\n\t\t\t\t\te = max(E,e);\n\t\t\t\t}else{\n\t\t\t\t\tarea += e-s;\n\t\t\t\t\tperimeter += 2;\n\t\t\t\t\ts = S;\n\t\t\t\t\te = E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperimeter += 2;\n\t\t\tarea += e-s;\n\t\t}\n\t\t\n\t\tif(q == 2){\n\t\t\tfor(int i = 0 ; i < 10001 ; i++){\n\t\t\t\tif(tc[i].size() == 0) continue;\n\t\t\t\tlist< pair<int,int> >::iterator it = tc[i].begin();\n\t\t\t\tint s = it->first , e = it->second;\n\t\t\t\tfor(; it != tc[i].end() ; ++it){\n\t\t\t\t\tint S = it->first , E = it->second;\n\t\t\t\t\tif(S <= e){\n\t\t\t\t\t\te = max(E,e);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tperimeter += 2;\n\t\t\t\t\t\ts = S;\n\t\t\t\t\t\te = E;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tperimeter += 2;\n\t\t\t}\n\t\t}\n\t\tif(q == 1){\n\t\t\tcout << area << endl;\n\t\t}else{\n\t\t\tcout << area << endl;\n\t\t\tcout << perimeter << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n  sheets.clear();\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint  sheets[2][10007], tmp[10007];\n\n\n\nint main(){\n  while(1){\n    int n, r;\n    int x1, y1, x2, y2, mx = 0, my = 0, menseki = 0, gaishuu = 0;\n    vector<pair<int, int> > points;\n    map<pair<int ,int> , int> nums;\n    scanf(\"%d%d\", &n, &r);\n    memset(sheets, 0, sizeof(sheets));\n    if(n == 0 && r == 0)return 0;\n    for(int i = 0;i < n;i++){\n      scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n      x1++,y1++,x2++,y2++;\n      points.push_back(make_pair(x1, y1));\n      points.push_back(make_pair(x1, y2));\n      points.push_back(make_pair(x2, y1));\n      points.push_back(make_pair(x2, y2));\n      if(nums.count(make_pair(x1, y1)) == 0)nums[make_pair(x1, y1)] = 0;\n      if(nums.count(make_pair(x2, y1)) == 0)nums[make_pair(x2, y1)] = 0;\n      if(nums.count(make_pair(x1, y2)) == 0)nums[make_pair(x1, y2)] = 0;\n      if(nums.count(make_pair(x2, y2)) == 0)nums[make_pair(x2, y2)] = 0;\n      nums[make_pair(x1, y1)]++;\n      nums[make_pair(x2, y2)]++;\n      nums[make_pair(x1, y2)]--;\n      nums[make_pair(x2, y1)]--;\n      mx = max(mx, x1);\n      mx = max(mx, x2);\n      my = max(my, y1);\n      my = max(my, y2);\n    }\n    sort(points.begin(), points.end(), greater< pair<int, int> >());\n    memset(tmp, 0, sizeof(tmp));\n    for(int i = 1;i <= mx ; i++){\n      for(int j = 1;j <= my + 1; j++){\n\tif(points.back().first == i && points.back().second == j){\n\t  tmp[j] += nums[points.back()];\n\t  pair<int, int> tmpr = points.back();\n\t  while(points.back() == tmpr)points.pop_back();\n\t}\n\tsheets[i % 2][j] = sheets[i % 2][j - 1] + tmp[j];\n\tif(sheets[i % 2][j] > 0)menseki++;\n\tif(r == 2){\n\t  if(sheets[i % 2][j] > 0 ){\n\t    if(sheets[(i - 1) % 2][j] == 0)gaishuu++;\n\t    if(sheets[i % 2][j - 1] == 0)gaishuu++;\n\t  }\n\t  if(sheets[i % 2][j] == 0 ){\n\t    if(sheets[(i - 1) % 2][j] > 0)gaishuu++;\n\t    if(sheets[i % 3][j - 1] > 0)gaishuu++;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", menseki);\n    if(r == 2){\n      printf(\"%d\\n\", gaishuu);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\twhile( cin >> N >> R, N || R ) {\n\t\tint xmax = 0, ymax = 0;\n\t\tvector<vector<int>>data( 10002, vector<int>( 10002 ) );\n\n\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\txmax = max( xmax, x2 );\n\t\t\tymax = max( ymax, y2 );\n\t\t\tdata[x1][y1]++;\n\t\t\tdata[x2][y2]++;\n\t\t\tdata[x1][y2]--;\n\t\t\tdata[x2][y1]--;\n\t\t}\n\t\txmax++;\n\t\tymax++;\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < xmax; j++ ) {\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < max( xmax, ymax ); i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nstruct Rect {int left, bottom, right, top;};\n\nenum {IN, OUT};\nstruct Node {\n    int y;\n    bool in;\n    Node(int y, bool in) :y(y), in(in) {}\n    bool operator<(const Node& n) const {return y != n.y ? y < n.y : in > n.in;}\n};\n\nint main() {\n    int n, r;\n    while(cin >> n >> r, n | r) {\n        vector<Rect> rect(n);\n        for(auto& r: rect) cin >> r.left >> r.bottom >> r.right >> r.top;\n\n        set<int> line;\n        for(const auto& r: rect) {\n            line.insert(r.left);\n            line.insert(r.right);\n        }\n\n        int area, circumference;\n        int edge, touch, pre_x;\n        area = circumference = 0;\n        edge = touch = pre_x = 0;\n        for(const auto& l: line) {\n            multiset<Node> node;\n            for(const auto& r: rect) {\n                if(l < r.left || r.right <= l) continue;\n                node.insert(Node(r.bottom, IN));\n                node.insert(Node(r.top, OUT));\n            }\n\n            area += touch * (l - pre_x);\n            circumference += edge * (l - pre_x);\n            pre_x = l;\n\n            edge = touch = 0;\n            int in, pre_y;\n            in = pre_y = 0;\n            for(const auto& n: node) {\n                if(!in) {\n                    pre_y = n.y;\n                    ++edge;\n                }\n                in += n.in ? 1 : -1;\n                if(in == 0) ++edge;\n                touch += n.y - pre_y;\n                pre_y = n.y;\n            }\n\n            enum POS {LEFT, MIDDLE, RIGHT};\n            struct NodeV {\n                int y;\n                bool in;\n                POS pos;\n                NodeV(int y, bool in, POS pos) :y(y), in(in), pos(pos) {}\n                bool operator<(const NodeV& n) const {return y != n.y ? y < n.y : in > n.in;}\n            };\n            multiset<NodeV> node_v;\n            for(const auto& r: rect) {\n                if(l < r.left || r.right < l) continue;\n                if(r.left < l && l < r.right) {\n                    node_v.insert(NodeV(r.bottom, IN, MIDDLE));\n                    node_v.insert(NodeV(r.top, OUT, MIDDLE));\n                } else if(l == r.left) {\n                    node_v.insert(NodeV(r.bottom, IN, LEFT));\n                    node_v.insert(NodeV(r.top, OUT, LEFT));\n                } else {\n                    node_v.insert(NodeV(r.bottom, IN, RIGHT));\n                    node_v.insert(NodeV(r.top, OUT, RIGHT));\n                }\n            }\n            int left, right, middle;\n            in = pre_y = left = right = middle = 0;\n            for(const auto& n: node_v) {\n                if(!in) pre_y = n.y;\n                if(!middle) if(left == 0 || right == 0) circumference += n.y - pre_y;\n                if(n.in) {\n                    ++in;\n                    if(n.pos == MIDDLE) ++middle;\n                    if(n.pos == LEFT) ++left;\n                    if(n.pos == RIGHT) ++right;\n                } else {\n                    --in;\n                    if(n.pos == MIDDLE) --middle;\n                    if(n.pos == LEFT) --left;\n                    if(n.pos == RIGHT) --right;\n                }\n                pre_y = n.y;\n            }\n        }\n\n        cout << area << endl;\n        if(r == 2) cout << circumference << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[3000][3000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[3900][3900];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include <map>\n#include<cstring>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\nshort node[10001];\nshort state_before[10001];\nshort map_before[10001];\n\n\nmap<int,list<pair<int,int>>> points;\n\n\n\nvoid read_points(int tate){\n    memcpy(map_before,node,sizeof node);\n    memset(node,0,sizeof(node));    \n    for(auto tmp:points[tate]){\n        node[tmp.first]+=tmp.second;\n    }\n}\nint main(){\n    int n,r;\n    int S=0;\n    int L=0;\n    int deltaS=0,deltaL=0;\n    ios::sync_with_stdio(false);\n  \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n        \n        points.clear();\n        int x1,y1,x2,y2;\n        int max_x=0,min_x=10000,max_y=0,min_y=10000;\n        for(int i=0;i<n;i++){\n            cin>>x1>>y1>>x2>>y2;\n \n            if(points.find(y1)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y1]=tmp;\n            }\n            if(points.find(y2)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y2]=tmp;\n            }\n            points[y1].push_back(make_pair(x1,1));\n            points[y1].push_back(make_pair(x2,-1));\n            points[y2].push_back(make_pair(x1,-1));\n            points[y2].push_back(make_pair(x2,1));\n            if(max_x<x2)max_x=x2;\n            if(max_y<y2)max_y=y2;\n            if(min_x>x1)min_x=x1;\n            if(min_y>y1)min_y=y1;\n            \n        }\n        \n        \n        S=0;\n        L=0;\n\n        for(int h=min_y;h<=max_y;h++){\n            if(points.find(h)==points.end()){\n                S+=deltaS;\n                L+=deltaL;\n                continue;\n            }\n            deltaL=0,deltaS=0;\n            read_points(h);\n            int yoko_state=0;\n            for(int w=min_x;w<=max_x;w++){\n                yoko_state+=node[w];\n                node[w]=yoko_state;\n                if(h!=0){\n                    node[w]+=state_before[w];\n                }\n                state_before[w]=node[w];\n                if(node[w]>0){\n                   S++;\n                   deltaS++;\n                   if(w==0){L+=2;deltaL+=2;}\n                   else if(node[w-1]==0){L+=2;deltaL+=2;}\n                   if(h==0){L+=2;deltaL+=2;}\n                   else if(map_before[w]==0){L+=2;deltaL+=2;}\n                }\n                \n                \n            }\n            \n        }\n\n\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nstruct Rect{\n\tshort x1,x2,y1,y2;\n};\n\nclass Compare{\n\tpublic:\n\tbool operator()(const Rect &rect1,const Rect &rect2){\n\t\treturn rect1.y1<rect2.y1;\n\t}\n};\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<Rect> &rects){\n\tint result=0;\n\tREP(x,0,10010){\n\t\tint y=0;\n\t\tREP(i,0,rects.size()){\n\t\t\tif(rects[i].x1<=x&&x<rects[i].x2){\n\t\t\t\tif(rects[i].y2>y) result+=rects[i].y2-max(y,rects[i].y1);\n\t\t\t\ty=max(y,rects[i].y2);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint Count(vector<Rect> &rects,vector<vector<bool> > &flag,int x){\n\tint result=0,y=0;\n\tREP(i,0,rects.size()){\n\t\tif(rects[i].x1<=x&&x<rects[i].x2){\n\t\t\tfor(y=max(y,rects[i].y1); y<rects[i].y2; ++y){\n\t\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint CalcLength(vector<Rect> &rects){\n\tint result=0,index=0;\n\tvector<vector<bool> > flag(3,vector<bool>(10010));\n\tREP(x,1,10009){\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,rects.size()){\n\t\t\tif(rects[i].x1<=x+1&&x+1<rects[i].x2){\n\t\t\t\tif(rects[i].y2>y) fill_n(flag[(x+1)%3].begin()+max(y,rects[i].y1),rects[i].y2-max(y,rects[i].y1),true);\n\t\t\t\ty=max(rects[i].y2,y);\n\t\t\t}\n\t\t}\n\t\tresult+=Count(rects,flag,x);\n\t}\n\treturn result;\n}\n\nint main(){\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tvector<Rect> rects(N);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\trects[i].x1=x1+4;\n\t\t\trects[i].y1=y1+4;\n\t\t\trects[i].x2=x2+4;\n\t\t\trects[i].y2=y2+4;\n\t\t}\n\t\tsort(rects.begin(),rects.end(),Compare());\n\t\tcout << CalcSize(rects) << endl;\n\t\tif(R==2) cout << CalcLength(rects) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\nvector<T> coner;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(cin >> n >> r, n | r){\n\tmemset(imos, 0, sizeof(imos));\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 10500;\n\tright_side = top = 1;\n\tconer.clear();\n\tfor(int i = 0;i < n;i++){\n\t    cin >> ax >> ay >> bx >> by;\n\t    left_side = min(left_side, ++ax);\n\t    right_side = max(right_side, ++bx);\n\t    bottom = min(bottom, ++ay);\n\t    top = max(top, ++by);\n\t    \n\t    coner.push_back(T(P(ax, ay), 1));\n\t    coner.push_back(T(P(ax, by), -1));\n\t    coner.push_back(T(P(bx, ay), -1));\n\t    coner.push_back(T(P(bx, by), 1));\n\t}\n\tconer.push_back(T(P(INF, INF), 0));\n\tsort(coner.begin(), coner.end());\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(coner[p].first == P(i, j)){\n\t\t    imos[i % 3][j] += coner[p++].second;\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tcout << area << endl;\n\tif(r == 2)cout << round << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint max(int* arr) {\n  int max = arr[0];\n  cout << \"sizeof: \" << sizeof(arr)/sizeof(arr[0]) << endl;\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (max < arr[i]) max = arr[i];\n  }\n  return max;\n}\n\nint min(int* arr) {\n  int min = arr[0];\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (min > arr[i]) min = arr[i];\n  }\n  return min;\n}\n\nint main(int argc, char const* argv[])\n{\n  ifstream ifs(\"input.txt\");\n  int count, type;\n  int *x1, *y1, *x2, *y2;\n  int left, bottom, right, top;\n  while (ifs >> count >> type) {\n    cout << \"count: \" << count << endl;\n    x1 = new int[count];\n    y1 = new int[count];\n    x2 = new int[count];\n    y2 = new int[count];\n    \n    // input\n    for (int i = 0; i < count; i++) {\n      ifs >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n\n    // field\n    left = min(x1);\n    bottom = min(y1);\n    right = max(x2);\n    top = max(y2);\n\n    cout << \"left:\"   << left   << endl;\n    cout << \"bottom:\" << bottom << endl;\n    cout << \"right:\"  << right  << endl;\n    cout << \"top:\"    << top    << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef list<P>L;\ntypedef L::iterator I;\nint unite(L&l,I i,I j){\n\tint r=i->second>=j->first;\n\tif(r){\n\t\ti->second=max(i->second,j->second);\n\t\tl.erase(j);\n\t}\n\treturn r;\n}\nvoid add(L&l,P p){\n\tI i=lower_bound(l.begin(),l.end(),p);\n\ti=l.insert(i,p);\n\tI j;\n\tfor(;j=i,++j!=l.end()&&unite(l,i,j););\n\tfor(;i!=l.begin()&&(j=i,unite(l,--i,j)););\n}\nint main(){\n\tint n,r;\n\tfor(;cin>>n>>r,r;){\n\t\tL v[10000],h[10000];\n\t\tfor(;n--;){\n\t\t\tint x1,y1,x2,y2,x,y;\n\t\t\tcin>>x1>>y1>>x2>>y2;\n\t\t\tfor(x=x1;x<x2;x++){\n\t\t\t\tadd(v[x],P(y1,y2));\n\t\t\t}\n\t\t\tfor(y=y1;y<y2;y++){\n\t\t\t\tadd(h[y],P(x1,x2));\n\t\t\t}\n\t\t}\n\t\tint s=0,c=0;\n\t\tfor(int y=0;y<10000;y++){\n\t\t\tfor(I i=h[y].begin();i!=h[y].end();++i)\n\t\t\t\ts+=i->second-i->first;\n\t\t\tc+=h[y].size()+v[y].size();\n\t\t}\n\t\tcout<<s<<endl;\n\t\tif(r==2){\n\t\t\tcout<<c*2<<endl;\n\t\t}\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> > in;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)return 0;\n\n    in.clear();\n    int mnx=INF,mny=INF,mxx=0,mxy=0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n      mnx=min(mnx,x1);\n      mny=min(mny,y1);\n      mxx=max(mxx,x2);\n      mxy=max(mxy,y2);\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    int S=0,L=0;\n    vector<P>v;\n    for(int i=mny;i<mxy;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n\tif(i<in[j].S.F)break;\n      }\n     \n      if(v.size()!=0){\n\tsort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n\n    \n    if(r==2){\n\n      sort(in.begin(),in.end(),cmp_x);\n\n      for(int i=mnx;i<mxx;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\n\t  if(i<in[j].F.F)break;\n\t}\n\tif(v.size()!=0){\n\t  sort(v.begin(),v.end());\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  //bool operator<(const st&)const;\nbool st::operator<(const st & a)const{\n  if (height != a.height)return height < a.height;\n  return out > a.out;\n}\n\n};\n\n\n\nint x[N];\nvector<st> inx[N];\n\n//int y[N];\n//vector<st> iny[N];\n\n/*\n29\n29\n80\n45\n*/\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *X,vector<st> *IN){\n  //vector<int> xd;\n  static int xd[N];\n  int p=0;\n  rep(i,n){\n    //xd.pb(x1[i]);\n    //xd.pb(x2[i]);\n    xd[p++]=x1[i];\n    xd[p++]=x2[i];\n  }\n  //sort(ALL(xd));\n  sort(xd,xd+p);\n  //xd.erase(unique(ALL(xd)),xd.end());\n  p=unique(xd,xd+p)-xd;\n  //rep(i,xd.size())X[px++]=xd[i],IN[i].clear();\n  rep(i,p)X[px++]=xd[i],IN[i].clear();\n\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    //int j=lower_bound(xd.begin(),xd.end(),x1[i])-xd.begin();\n    int j=lower_bound(xd,xd+p,x1[i])-xd;\n    while(j < px && x[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<list>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint map[10001][10001];\n\nint main(){\n    \n    int n,r;\n    \n\n  \n\n    \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        memset(map,0,sizeof(map));\n\n        \n        int x_min=10001,x_max=0,y_min=10001,y_max=0;\n       \n        int x1,y1,x2,y2;\n        for(int i=0;i<n;i++){\n            \n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n            if(x_min>x1)x_min=x1;\n            if(y_min>y1)y_min=y1;\n            if(x_max<x2)x_max=x2;\n            if(y_max<y2)y_max=y2;\n            \n        }\n\n        int S=0;\n        int L=0;\n        int state,res;\n        /*\n        for(int h=0;h<=10000;h++){\n            state=0;\n           for(int w=0;w<=10000;w++){\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n        */\n        \n        for(int h=y_min;h<=y_max;h++){\n            state=0;\n            for(int w=x_min;w<=x_max;w++){\n                state+=map[w][h];\n                map[w][h]=state;\n            }\n        }\n        for(int w=x_min;w<=x_max;w++){\n            state=0;\n            for(int h=y_min;h<=y_max;h++){\n                state+=map[w][h];\n                map[w][h]=state;\n                if(map[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(map[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(map[w][h-1]==0)L+=2;\n               }\n            }\n        }\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nvoid sl(int p[][4],int Mx,int My,int n,int r){\n  int f[Mx][My];\n  int i,j,k;\n  int s,l;\n  s = l = 0;\n  for(i=0;i<Mx;i++){\n    for(j=0;j<My;j++){\n      f[i][j] = 0;\n    }\n  }\n  for(k=0;k<n;k++){\n    for(i=p[k][0];i<p[k][2];i++){\n      for(j=p[k][1];j<p[k][3];j++){\n        if(f[i][j]==0){\n          s++;\n        }\n        f[i][j] = 1;\n      }\n    }\n  } \n  printf(\"%d\\n\",s);\n  if(r==2){\n    for(i=0;i<Mx-1;i++){\n      l+=(f[i][0]+f[i][Mx-1]);\n      for(j=0;j<My-1;j++){\n        l+=(f[i][j]^f[i][j+1]);\n      }\n    }\n    for(j=0;j<My-1;j++){\n      l+=(f[0][j]+f[My-1][j]);\n      for(i=0;i<Mx-1;i++){\n        l+=(f[i+1][j]^f[i][j]);\n      }\n    }\n    printf(\"%d\\n\",l);\n  }\n}\nint main(){\n  int n,r;\n  int i,j,k;\n  int Mx,My;\n  int p[10000][4];\n  while(scanf(\"%d %d\",&n,&r)!=EOF){\n    Mx = My = 100;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&p[k][0],&p[k][1],&p[k][2],&p[k][3]);\n      if(p[k][2]>Mx){\n        Mx = p[k][2];\n      }\n      if(p[k][3]>My){\n        My = p[k][3];\n      }      \n    }\n    sl(p,Mx,My,n,r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nshort int sum[10001][10001];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint n, r;\n\twhile (scanf(\"%d%d\", &n, &r), n) {\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tint h = 0, w = 0;\n\t\trep(i, n) {\n\t\t\tint x1, y1, x2, y2; scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\th = max(h, x2); w = max(w, y2);\n\t\t\tsum[x1][y1]++; sum[x1][y2]--; sum[x2][y1]--; sum[x2][y2]++;\n\t\t}\n\t\th++; w++;\n\t\trep(i, h)for (int j = 1; j < w; j++)sum[i][j] += sum[i][j - 1];\n\t\trep(i, w)for (int j = 1; j < h; j++)sum[j][i] += sum[j - 1][i];\n\t\tint a = 0, b = 0;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (sum[i][j]) {\n\t\t\t\ta++;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\tif (nx < 0 || nx >= h || ny < 0 || ny >= w || !sum[nx][ny])b++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", a);\n\t\tif (r == 2)printf(\"%d\\n\", b);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint max(int* arr) {\n  int max = arr[0];\n  cout << \"sizeof: \" << sizeof(arr)/sizeof(arr[0]) << endl;\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (max < arr[i]) max = arr[i];\n  }\n  return max;\n}\n\nint min(int* arr) {\n  int min = arr[0];\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (min > arr[i]) min = arr[i];\n  }\n  return min;\n}\n\nint main(int argc, char const* argv[])\n{\n  ifstream ifs(\"input.txt\");\n  int count, type;\n  int *x1, *y1, *x2, *y2;\n  int left, bottom, right, top;\n  while (ifs >> count >> type) {\n    cout << \"count: \" << count << endl;\n    x1 = new int[count];\n    y1 = new int[count];\n    x2 = new int[count];\n    y2 = new int[count];\n    \n    // input\n    for (int i = 0; i < count; i++) {\n      ifs >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n\n    // field\n    left = min(x1);\n    bottom = min(y1);\n    right = max(x2);\n    top = max(y2);\n\n    cout << \"left:\"   << left   << endl;\n    cout << \"bottom:\" << bottom << endl;\n    cout << \"right:\"  << right  << endl;\n    cout << \"top:\"    << top    << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[{x1, y1}] = {{x2, y2}};\n  } else {\n    sheets[{x1, y1}].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  return sheets[{x, y}];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n\n    // update right_area_end_point\n    repeat_with_index(y_size, y_i) {\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n    delete is_area[0];\n    delete is_area[1];\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    // for (auto&& points : sheets) {\n    //   cout << \"A: \";\n    //   cout << points.first.first << \" \" << points.first.second << endl;\n    //   for (auto&& p : points.second) {\n    //     cout << \"B: \";\n    //     cout << p.first << \" \" << p.second << endl;\n    //   }\n    // }\n\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint data[10003][10003];\n\tint N, R;\n\twhile( cin >> N >> R, N || R ) {\n\t\t//vector<vector<int>>data( 10003, vector<int>( 10003 ) );\n\t\tmemset( data, 0, sizeof( data ) );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tdata[x1][y1]++;\n\t\t\tdata[x2][y2]++;\n\t\t\tdata[x1][y2]--;\n\t\t\tdata[x2][y1]--;\n\t\t}\n\t\t\n\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\tdata[i + 1][j] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tdata[i][j + 1] += data[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\n\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\tif( data[i][j] ) {\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tif( data[i][0] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tif( data[0][i] != 0 ) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < 10001; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < 10001; j++ ) {\n\t\t\t\t\tif( data[i][j] * data[i][j + 1] == 0 && data[i][j] != data[i][j + 1] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tif( data[i][j] * data[i + 1][j] == 0 && data[i][j] != data[i + 1][j] ) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n#define fir first\n#define sec second\n\nconst int N = 10010;\n\ntypedef pair<short,short> pii;\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<pii> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<pii> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,IN[j].size()){\n\tshort Y1 = y1[i],Y2=y2[i];\n\tshort &Y3=IN[j][k].fir;\n\tshort &Y4=IN[j][k].sec;\n\tif (Y4 <= Y1 || Y2 <= Y3)continue;\n\tisin=true;\n\tY3=min(Y1,Y3);\n\tY4=max(Y2,Y4);\n\tbreak;\n      }\n      if (!isin)IN[j].pb(mp(y1[i],y2[i]));\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<pii> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].fir,&nowh=in[i][j].sec;\n      if (nowl >= h){\n\tif (nowl != h)len+=2*width;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint bit_n;\nint dat[10010];\nvoid init(int n){\n    bit_n=n;\n    memset(dat,0,sizeof(dat));\n}\nvoid add(int k,int x){\n    for(k++;k<=bit_n;k+=k&-k)dat[k]+=x;\n}\nint sum(int k){\n    int ret=0;\n    for(k++;k;k-=k&-k)ret+=dat[k];\n    return ret;\n}\n\nstruct event{\n    int y,id,in;\n    event(int y,int id,int in):y(y),id(id),in(in){}\n    bool operator<(const event &e)const{\n        return y<e.y;\n    }\n};\n\nint N,r;\nvector<event>es;\nint x1[10000],y1[10000],x2[10000],y2[10000];\n\nint cnt[10020];\nvoid solve1(){\n    int ret=0;\n    memset(cnt,0,sizeof(cnt));\n    int cur=0,prevy=0;\n    while(cur<es.size()){\n        int sum=0;\n        for(int i=0;i<10010;i++)if(cnt[i])sum++;\n        ret+=sum*(es[cur].y-prevy);\n        prevy=es[cur].y;\n        int next=cur;\n        while(next<es.size()&&es[next].y==es[cur].y){\n            int id=es[next].id;\n            for(int i=x1[id];i<x2[id];i++){\n                if(es[next].in)cnt[i]++;\n                else cnt[i]--;\n            }\n            next++;\n        }\n        cur=next;\n\n    }\n\n    cout<<ret<<endl;\n}\n\nvoid solve2(){\n    int ret=0;\n    memset(cnt,0,sizeof(cnt));\n    int cur=0,prevy=0;\n    while(cur<es.size()){\n        int sum=0;\n        for(int i=0;i<10010;i++){\n            if(cnt[i]!=0)continue;\n            if(i&&cnt[i-1])sum++;\n            if(cnt[i+1])sum++;\n        }\n        ret+=sum*(es[cur].y-prevy);\n        prevy=es[cur].y;\n        int next=cur;\n        int memo[10020];\n        for(int i=0;i<10020;i++)memo[i]=cnt[i];\n        while(next<es.size()&&es[next].y==es[cur].y){\n            int id=es[next].id;\n            for(int i=x1[id];i<x2[id];i++){\n                if(es[next].in)cnt[i]++;\n                else cnt[i]--;\n            }\n            next++;\n        }\n        for(int i=0;i<10020;i++)if(memo[i]!=cnt[i]&&(memo[i]==0||cnt[i]==0))ret++;\n        cur=next;\n\n    }\n\n    cout<<ret<<endl;\n}\n\nint paint[10][10];\nint main(){\n    while(cin>>N>>r,N||r){\n        es.clear();\n        for(int i=0;i<N;i++){\n            cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n            x1[i]++;y1[i]++;x2[i]++;y2[i]++;\n        }\n\n        for(int i=0;i<N;i++){\n            es.push_back(event(y1[i],i,1));\n            es.push_back(event(y2[i],i,0));\n        }\n\n        sort(es.begin(),es.end());\n\n        /*\n        memset(paint,0,sizeof(memo));\n        for(int k=0;k<N;k++){\n            for(int i=y1[k];i<y2[k];i++){\n                for(int j=x1[k];j<x2[k];j++){\n                    paint[i][j]=min(1,paint[i][j]+1);\n                }\n            }\n        }\n        for(int i=1;i<15;i++){\n            for(int j=1;j<15;j++){\n                cout<<paint[i][j]<<\" \";\n            }cout<<endl;\n        }\n        */\n        solve1();\n        if(r==2)solve2();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<int> P;\n\nvector<pair<P, P> > p;\nvector<int> xx, yy;\n\nint main() {\n  int n, r;\n  for (int iii = 1;; ++iii) {\n    cin >> n >> r;\n    if (n == 0 && r == 0) break;\n    p.clear();\n    xx.clear();\n    yy.clear();\n    rep (i, n) {\n      double x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      p.push_back(make_pair(P(x1, y1), P(x2, y2)));\n      xx.push_back(x1);\n      xx.push_back(x2);\n      yy.push_back(y1);\n      yy.push_back(y2);\n    }\n    sort(xx.begin(), xx.end());\n    sort(yy.begin(), yy.end());\n    int res = 0;\n    rep (i, xx.size() - 1) {\n      vector<pair<int,int> > imos;\n      rep (j, n) {\n\tif (p[j].first.X <= xx[i] && xx[i + 1] <= p[j].second.X) {\n\t  imos.push_back(make_pair(p[j].first.Y, -1));\n\t  imos.push_back(make_pair(p[j].second.Y, 1));\n\t}\n      }\n      sort(imos.begin(), imos.end());\n      int im = -1;\n      rep (j, imos.size() - 1) {\n\tif (im < 0) {\n\t  res += (xx[i + 1] - xx[i]) * (imos[j + 1].first - imos[j].first);\n\t}\n\tim += imos[j + 1].second;\n      }\n    }\n    cout << res << endl;\n    if (r == 2) {\n      res = 0;\n      rep (i, xx.size() - 1) {\n\t//cout << \"xx[i] : \" << xx[i] << endl;\n\tvector<pair<int,int> > imos;\n\trep (j, n) {\n\t  if (p[j].first.X <= xx[i] && xx[i + 1] <= p[j].second.X) {\n\t    imos.push_back(make_pair(p[j].first.Y, -1));\n\t    imos.push_back(make_pair(p[j].second.Y, 1));\n\t  }\n\t}\n\tsort(imos.begin(), imos.end());\n\t//rep (j, imos.size()) cout << imos[j].first << \" \" << imos[j].second << endl;\n\t//cout << endl;\n\tint im = 0;\n\trep (j, imos.size()) {\n\t  //cout << im << endl;\n\t  if (im == 0) {\n\t    res += (xx[i + 1] - xx[i]) * 2;\n\t  }\n\t  im += imos[j].second;\n\t}\n\t//cout << res << endl;\n      }\n      rep (i, yy.size() - 1) {\n\t//cout << \"yy[i] : \" << yy[i] << endl;\n\tvector<pair<int,int> > imos;\n\trep (j, n) {\n\t  if (p[j].first.Y <= yy[i] && yy[i + 1] <= p[j].second.Y) {\n\t    imos.push_back(make_pair(p[j].first.X, -1));\n\t    imos.push_back(make_pair(p[j].second.X, 1));\n\t  }\n\t}\n\tsort(imos.begin(), imos.end());\n\tint im = 0;\n\trep (j, imos.size()) {\n\t  if (im == 0) {\n\t    res += (yy[i + 1] - yy[i]) * 2;\n\t  }\n\t  im += imos[j].second;\n\t}\n\t//cout << res << endl;\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint max(int* arr) {\n  int max = arr[0];\n  cout << \"sizeof: \" << sizeof(arr)/sizeof(arr[0]) << endl;\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (max < arr[i]) max = arr[i];\n  }\n  return max;\n}\n\nint min(int* arr) {\n  int min = arr[0];\n  for (int i = 1; i < sizeof(arr); i++) {\n    if (min > arr[i]) min = arr[i];\n  }\n  return min;\n}\n\nint main(int argc, char const* argv[])\n{\n  ifstream ifs(\"input.txt\");\n  int count, type;\n  int *x1, *y1, *x2, *y2;\n  int left, bottom, right, top;\n  while (ifs >> count >> type) {\n    cout << \"count: \" << count << endl;\n    x1 = new int[count];\n    y1 = new int[count];\n    x2 = new int[count];\n    y2 = new int[count];\n    \n    // input\n    for (int i = 0; i < count; i++) {\n      ifs >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n\n    // field\n    left = min(x1);\n    bottom = min(y1);\n    right = max(x2);\n    top = max(y2);\n\n    cout << \"left:\"   << left   << endl;\n    cout << \"bottom:\" << bottom << endl;\n    cout << \"right:\"  << right  << endl;\n    cout << \"top:\"    << top    << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include <map>\n#include<cstring>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\nshort node[10001];\nshort state_before[10001];\nshort map_before[10001];\n\n\nmap<int,list<pair<int,int>>> points;\n\n\n\nvoid read_points(int tate){\n    memcpy(map_before,node,sizeof node);\n    memset(node,0,sizeof(node));    \n    for(auto tmp:points[tate]){\n        node[tmp.first]+=tmp.second;\n    }\n}\nint main(){\n    int n,r;\n    int S=0;\n    int L=0;\n    ios::sync_with_stdio(false);\n  \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n        \n        points.clear();\n        int x1,y1,x2,y2;\n        int max_x=0,min_x=10000,max_y=0,min_y=10000;\n        for(int i=0;i<n;i++){\n            cin>>x1>>y1>>x2>>y2;\n \n            if(points.find(y1)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y1]=tmp;\n            }\n            if(points.find(y2)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y2]=tmp;\n            }\n            points[y1].push_back(make_pair(x1,1));\n            points[y1].push_back(make_pair(x2,-1));\n            points[y2].push_back(make_pair(x1,-1));\n            points[y2].push_back(make_pair(x2,1));\n            if(max_x<x2)max_x=x2;\n            if(max_y<y2)max_y=y2;\n            if(min_x>x1)min_x=x1;\n            if(min_y>y1)min_y=y1;\n            \n        }\n        \n        \n        S=0;\n        L=0;\n        for(int h=min_y;h<=max_y;h++){\n            \n            read_points(h);\n            int yoko_state=0;\n            for(int w=min_x;w<=max_x;w++){\n                \n                yoko_state+=node[w];\n                node[w]=yoko_state;\n                if(h!=0){\n                    node[w]+=state_before[w];\n                }\n                state_before[w]=node[w];\n                if(node[w]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(node[w-1]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(map_before[w]==0)L+=2;\n                }\n                \n                \n            }\n            \n        }\n\n\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> >in;\nvector<P>vx[10001],vy[10001];\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    for(int i=0;i<10001;i++){\n      vx[i].clear();\n      vy[i].clear();\n    }\n\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\nusing namespace std;\n#define MP 10005\nint main()\n{\n\tint x1,y1,x2,y2,N,R,A[2];\n\tfor(;scanf(\"%d%d\",&N,&R),N;)\n\t{\n\t\tvector<pair<int,int> >S[MP];\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++;y1++;x2++;y2++;\n\t\t\tS[x1].push_back(make_pair(y1,1));\n\t\t\tS[x1].push_back(make_pair(y2,-1));\n\t\t\tS[x2].push_back(make_pair(y2,1));\n\t\t\tS[x2].push_back(make_pair(y1,-1));\n\t\t}\n\t\tint dp[2][MP]={0},*p1=dp[0],*p2=dp[1];\n\t\tfor(int x=A[0]=A[1]=0;x<MP;x++)\n\t\t{\n\t\t\tfill(p2,p2+MP,0);\n\t\t\tfor(int i=0;i<S[x].size();i++)\n\t\t\t{\n\t\t\t\tint p=S[x][i].first,v=S[x][i].second;\n\t\t\t\tp2[p]+=v;\n\t\t\t}\n\t\t\tfor(int y=1;y<MP;y++)\n\t\t\t\tp2[y]+=p2[y-1];\n\t\t\tfor(int y=1;y<MP;y++)\n\t\t\t\tp2[y]+=p1[y];\n\t\t\tfor(int y=1;y<MP;y++)\n\t\t\t{\n\t\t\t\tif(p2[y]>0)A[0]++;\n\t\t\t\tif((p1[y]==0&&p2[y]>0)||(p1[y]>0&&p2[y]==0))A[1]++;\n\t\t\t\tif((p2[y-1]==0&&p2[y]>0)||(p2[y-1]>0&&p2[y]==0))A[1]++;\n\t\t\t}\n\t\t\tswap(p1,p2);\n\t\t}\n\t\tfor(int i=0;i<R;i++)printf(\"%d\\n\",A[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint sum[10001][10001];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint n, r;\n\twhile (scanf(\"%d%d\", &n, &r), n) {\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tint h = 0, w = 0;\n\t\trep(i, n) {\n\t\t\tint x1, y1, x2, y2; scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\th = max(h, x2); w = max(w, y2);\n\t\t\tsum[x1][y1]++; sum[x1][y2]--; sum[x2][y1]--; sum[x2][y2]++;\n\t\t}\n\t\th++; w++;\n\t\trep(i, h)for (int j = 1; j < w; j++)sum[i][j] += sum[i][j - 1];\n\t\trep(i, w)for (int j = 1; j < h; j++)sum[j][i] += sum[j - 1][i];\n\t\tint a = 0, b = 0;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (sum[i][j]) {\n\t\t\t\ta++;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\tif (nx < 0 || nx >= h || ny < 0 || ny >= w || !sum[nx][ny])b++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", a);\n\t\tif (r == 2)printf(\"%d\\n\", b);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint n,r;\n\twhile(cin >> n >> r,n||r){\n\t\tvector<pair<pair<int,int>,pair<int,int>>> v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tv.emplace_back(make_pair(make_pair(x1,y1),make_pair(x2,y2)));\n\t\t}\n\t\tint s[10001] = {0};\n\t\tint p[10001] = {0};\n\t\tint edge = 0;\n\t\tfor(int y=0;y<=10000;y++){\n\t\t\tint w[10001] = {0};\n\t\t\tfor(int unsigned j = 0;j<v.size();j++){\n\t\t\t\tif(v[j].first.second <= y && y < v[j].second.second){\n\t\t\t\t\tw[v[j].first.first]++;\n\t\t\t\t\tw[v[j].second.first]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tfor(int unsigned x = 0;x <= 10000;x++){\n\t\t\t\tint px = c;\n\t\t\t\tc += w[x];\n\t\t\t\tif((px > 0 && c == 0) || (px == 0 && c > 0)){\n\t\t\t\t\t//cout << \"left: (\"  << x << \",\" << y << \")\" << endl;\n\t\t\t\t\tedge++;\n\t\t\t\t}\n\t\t\t\tif((c > 0 && p[x] == 0) || (c == 0 && p[x] > 0)){\n\t\t\t\t\t//cout << \"up: (\"  << x << \",\" << y << \")\" << endl;\n\t\t\t\t\tedge++;\n\t\t\t\t}\n\t\t\t\tp[x] = c;\n\t\t\t\tif(c) s[x]++;\n\t\t\t}\n\t\t}\n\t\tint area = 0;\n\t\tfor(int x=0;x<=10000;x++){\n\t\t\tarea += s[x];\n\t\t}\n\t\tcout << area << endl;\n\t\tif(r == 2){\n\t\t\tcout << edge << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\n#define INF 2000000000\n#define LLINF 4000000000000000000\n#define SIZE 10010\n\nint mm[SIZE][SIZE];\nint mo[5] = {0,1,0,-1,0};\nvoid calc(int n,int r){\n    int x_1,x_2,y_1,y_2;\n    int ansV,ansL;\n    \n    \n    for(int i=0;i<SIZE;i++){\n        for(int j=0;j<SIZE;j++){\n            mm[i][j]=0;\n        }\n    }\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d%d\",&x_1,&y_1,&x_2,&y_2);\n        \n        x_1++;\n        y_1++;\n        x_2++;\n        y_2++;\n        \n        mm[x_1][y_1]++;\n        mm[x_2][y_1]--;\n        mm[x_1][y_2]--;\n        mm[x_2][y_2]++;\n    }\n    \n    for(int i=1;i<SIZE;i++){\n        for(int j=2;j<SIZE;j++){\n            mm[j][i]+=mm[j-1][i];\n        }\n    }\n    \n    for(int i=1;i<SIZE;i++){\n        for(int j=2;j<SIZE;j++){\n            mm[i][j]+=mm[i][j-1];\n        }\n    }\n    \n    for(int i=1;i<SIZE;i++){\n        for(int j=1;j<SIZE;j++){\n            if(mm[i][j]>0){\n                ansV++;\n                \n                for(int k=0;k<4;k++){\n                    if(mm[i+mo[k]][j+mo[k+1]]==0){\n                        ansL++;\n                    }\n                }\n                \n            }\n        }\n    }\n    \n    printf(\"%d\\n\",ansV);\n    \n    if(r==2)\n        printf(\"%d\\n\",ansL);\n\n    return;\n}\n\nint main(){\n    int n,r;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&r);\n        if(n==0) break;\n        calc(n,r);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[3500][3500];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1000000000\n#define fi first\n#define sec second\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        cin >> n >> r;\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            cin >> a >> b >> c >> d;\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nint n, r;\nint sum[2][10010];\nbool a[10010][10010];\nvector<pi> q[10010];\n\nint main(){\n\twhile(cin >> n >> r, n){\n\t\tmemset(a, 0, sizeof(a));\n\t\tmemset(sum, 0, sizeof(sum));\n\t\trep(i, 10010) q[i].clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint x, y, X, Y;\n\t\t\tcin >> x >> y >> X >> Y;\n\t\t\tq[y].pb(mp(x, 1));\n\t\t\tq[y].pb(mp(X, -1));\n\t\t\tq[Y].pb(mp(x, -1));\n\t\t\tq[Y].pb(mp(X, 1));\n\t\t}\n\t\tint cur = 0, next = 1;\n\t\trep(i, 10005){\n\t\t\tsort(all(q[i]));\n\t\t\trep(j, q[i].size()) sum[cur][q[i][j].first] += q[i][j].second;\n\t\t\t\n\t\t\trep(j, 10005) sum[next][j] = sum[cur][j];\n\t\t\trep(j, 10005){\n\t\t\t\tsum[cur][j + 1] += sum[cur][j];\n\t\t\t\ta[i + 1][j + 1] = sum[cur][j] > 0;\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\tint area = 0, per = 0;\n\t\trep(i, 10005) rep(j, 10005){\n\t\t\tif(a[i][j]) area++;\n\t\t\trep(d, 2){\n\t\t\t\tconst int dy[] = {-1, 0}, dx[] = {0, -1};\n\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\tif(a[i][j] != a[ny][nx]) per++;\n\t\t\t}\n\t\t}\n\t\tcout << area << endl;\n\t\tif(r == 2) cout << per << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint n;\nshort min_x1, max_x2, min_y1, max_y2;\nshort x1[10000], x2[10000], y1[10000], y2[10000];\nshort tiles[10002][10002];\n\nvoid pre_process() {\n    short i;\n\n    for (i=0;i<n;i++) {\n        tiles[y1[i]][x1[i]]++;\n        tiles[y1[i]][x2[i]]--;\n        tiles[y2[i]][x2[i]]++;\n        tiles[y2[i]][x1[i]]--;\n    }\n\n    for (i=min_y1;i<max_y2+1;i++) {\n        int j;\n        for (j=min_x1+1;j<max_x2+1;j++) {\n            tiles[i][j] += tiles[i][j-1];\n        }\n    }\n\n\n    for (i=min_y1+1;i<max_y2+1;i++) {\n        int j;\n        for (j=min_x1;j<max_x2+1;j++) {\n            tiles[i][j] += tiles[i-1][j];\n        }\n    }\n\n    return;\n}\n\nint surface() {\n    short i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2;i++) {\n        int j;\n        for (j=min_x1;j<max_x2;j++) {\n            if (tiles[i][j] > 0) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint perimeter() {\n    short i;\n    int sum = 0;\n\n    for (i=min_y1;i<max_y2+2;i++) {\n        short j;\n        for (j=min_x1;j<max_x2+2;j++) {\n            short add = tiles[i][j] + tiles[i-1][j];\n\n            if (add > 0 && (tiles[i][j] == 0 || tiles[i-1][j] == 0)) {\n                sum++;\n            }\n\n            add = tiles[i][j] + tiles[i][j-1];\n\n            if (add > 0 && (tiles[i][j] == 0 || tiles[i][j-1] == 0)) {\n                sum++;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while (1) {\n        short i;\n        int r;\n\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r ==0) return 0;\n\n        min_x1 = 10000;\n        min_y1 = 10000;\n        max_x2 = 0;\n        max_y2 = 0;\n        for (i=0;i<n;i++) {\n            scanf(\"%hd %hd %hd %hd\", &x1[i], &y1[i], &x2[i], &y2[i]);\n            x1[i]++;\n            x2[i]++;\n            y1[i]++;\n            y2[i]++;\n            if (min_x1 > x1[i]) min_x1 = x1[i];\n            if (max_x2 < x2[i]) max_x2 = x2[i];\n            if (min_y1 > y1[i]) min_y1 = y1[i];\n            if (max_y2 < y2[i]) max_y2 = y2[i];\n        }\n\n        for (i=0;i<10002;i++) {\n            short j;\n            for (j=0;j<10002;j++) {\n                tiles[i][j] = 0;\n            }\n        }\n        pre_process();\n\n        printf(\"%d\\n\", surface());\n\n        if (r == 2) {\n            printf(\"%d\\n\", perimeter());\n        }        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<list>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    \n    int** map;\n    map=new int*[10001];\n    for(int w=0;w<=10000;w++){\n        map[w] = new int[10001];\n    }\n        \n    int** imos;\n    imos=new int*[10001];\n    for(int w=0;w<=10000;w++){\n        imos[w] = new int[10001];\n    }\n  \n\n    \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        for(int h=0;h<=10000;h++){\n            for(int w=0;w<=10000;w++){\n                map[w][h]=0;\n                imos[w][h]=0;\n           }\n        }\n\n        \n        int max=0;\n       \n        int x1,y1,x2,y2;\n        for(int i=0;i<n;i++){\n            \n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n            if(x2>max)max=x2;\n            if(y2>max)max=y2;\n        }\n\n        int S=0;\n        int L=0;\n        int state,res;\n        for(int h=0;h<=10000;h++){\n            state=0;\n           for(int w=0;w<=10000;w++){\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n\n        cout<<S<<endl;\n        if(r==2)cout<<L<<endl;\n        \n\n    }\n    \n    for(int w=0;w<=10000;w++){\n        delete map[w];\n    }\n    \n    for(int w=0;w<=10000;w++){\n        delete imos[w] ;\n    }\n    delete[] imos;\n    delete[] map;\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint n, q, mx1, my1, mx2, my2, x1[10000], y1[10000], x2[10000], y2[10000], imos[10001];\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &q);\n\n\t\tif (n == 0 && q == 0) break;\n\n\t\tmx1 = 10001;\n\t\tmy1 = 10001;\n\t\tmx2 = -1;\n\t\tmy2 = -1;\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x1[i]); mx1 = mx1 < x1[i] ? mx1 : x1[i];\n\t\t\tscanf(\"%d\", &y1[i]); my1 = my1 < y1[i] ? my1 : y1[i];\n\t\t\tscanf(\"%d\", &x2[i]); mx2 = mx2 > x2[i] ? mx2 : x2[i];\n\t\t\tscanf(\"%d\", &y2[i]); my2 = my2 > y2[i] ? my2 : y2[i];\n\t\t}\n\n\t\tint ret1 = 0;\n\t\tint ret2 = 0;\n\n\t\tfor (int i = my1; i < my2; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (y1[j] <= i && i < y2[j])\n\t\t\t\t{\n\t\t\t\t\timos[x1[j]]++;\n\t\t\t\t\timos[x2[j]]--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\n\t\t\tfor (int j = mx1; j <= mx2; j++)\n\t\t\t{\n\t\t\t\tif ((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n\n\t\t\t\tsum += imos[j]; imos[j] = 0;\n\n\t\t\t\tif(sum > 0) ret1++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = mx1; i < mx2; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (x1[j] <= i && i < x2[j])\n\t\t\t\t{\n\t\t\t\t\timos[y1[j]]++;\n\t\t\t\t\timos[y2[j]]--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\n\t\t\tfor (int j = my1; j <= my2; j++)\n\t\t\t{\n\t\t\t\tif ((sum == 0 && sum + imos[j] > 0) || (sum > 0 && sum + imos[j] == 0)) ret2++;\n\n\t\t\t\tsum += imos[j]; imos[j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret1);\n\n\t\tif (q == 2)\n\t\t{\n\t\t\tprintf(\"%d\\n\", ret2);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint plc[10002][10002];\nint max(int a,int b){return a>b?a:b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint main(){\n\tint n,t;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&t);\n\tif(n==0)return 0;\n\tmemset(plc,0,sizeof(plc));\n\tint mx=0,my=0;\n\tfor(i=0;i<n;i++){\n\t\tint x1,y1,x2,y2;\n\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\tx1++;x2++;y1++;y2++;\n\t\tmx=max(mx,x2);\n\t\tmy=max(my,y2);\n\t\tplc[x1][y1]++;\n\t\tplc[x1][y2]--;\n\t\tplc[x2][y1]--;\n\t\tplc[x2][y2]++;\n\t}\n\tfor(i=1;i<=mx;i++){\n\t\tfor(j=2;j<=my;j++){\n\t\t\tplc[i][j]+=plc[i][j-1];\n\t\t}\n\t}\n\tfor(i=1;i<=my;i++){\n\t\tfor(j=2;j<=mx;j++){\n\t\t\tplc[j][i]+=plc[j-1][i];\n\t\t}\n\t}\n\tint ans1=0,ans2=0;\n\tfor(i=1;i<=mx;i++){\n\t\tfor(j=1;j<=my;j++){\n\t\t\tif(plc[i][j]>0){\n\t\t\t\tans1++;\n\t\t\t\tif(t==2){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tint nx=i+dx[k];\n\t\t\t\t\t\tint ny=j+dy[k];\n\t\t\t\t\t\tif(nx>=0&&nx<=mx&&ny>=0&&ny<=my&&plc[nx][ny]==0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans1);\n\tif(t==2)printf(\"%d\\n\",ans2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nbool a[10005][10005];\nint dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};\n\nint main(void){\n\n  int n,r,ax,ay,bx,by;\n\n  while(cin >> n >> r,n|r){\n  \n    for(int i=0;i<10005;i++)\n      for(int j=0;j<10005;j++)a[i][j]=false;\n\n    for(int i=0;i<n;i++){\n      cin >> ax >> ay >> bx >> by;\n      for(int j=ax+1;j<=bx;j++)\n\tfor(int k=ay+1;k<=by;k++)a[j][k]=true;\n    }\n    int cnt=0;\n    for(int i=1;i<10002;i++)\n      for(int j=1;j<10002;j++)\n\tif(a[i][j])cnt++;\n    \n    cout << cnt << endl;\n    \n    if(r==2){\n      int cnt2=0;\n      for(int i=1;i<10002;i++)\n\tfor(int j=1;j<10002;j++)\n\t  for(int k=0;k<4;k++)\n\t    if(a[i][j] && !a[i+dx[k]][j+dy[k]])cnt2++;\n      \n      cout << cnt2 << endl;\n    }\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\ntypedef pair<pii,int> ppii;\n\nint N,R;\n//bitset<10001*100001> field;\nint field[2][10011];\nvector<ppii> rangeSet[10010];\nint line[10010];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nconst int INF=1000000000;\nint main(){\n  fast_stream();\n  while(cin>>N>>R&&(N|R)){\n    int miny,minx,maxy,maxx;\n    miny=minx=INF;\n    maxx=maxy=-INF;\n    for(int i=0;i<10001;i++)rangeSet[i].clear();\n    memset(line,0,sizeof(line));\n    memset(field,0,sizeof(field));\n    for(int i=0;i<N;i++){\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2;\n      rangeSet[y1].push_back(make_pair(pii(x1,x2),1));\n      rangeSet[y2].push_back(make_pair(pii(x1,x2),-1));\n      maxy=max(y2+1,maxy);\n      maxx=max(x2,maxx);\n      miny=min(y1,miny);\n      minx=min(x1,minx);\n    }\n    int S=0;\n    int E=0;\n    for(int y=miny;y<maxy;y++){\n      int cur=y%2;\n      int prv=cur^1;\n      memset(field[cur],0,sizeof(field[cur]));\n      for(int i=0;i<(int)rangeSet[y].size();i++){\n\tint sx=rangeSet[y][i].first.first;\n\tint ex=rangeSet[y][i].first.second;\n\tint a=rangeSet[y][i].second;\n\tfor(int j=sx;j<ex;j++)line[j]+=a;\n      }\n      for(int x=minx;x<maxx;x++){\n\tif(line[x]>0){\n\t  S++;\n\t  field[cur][x]=1;\n\t}\n      }\n      for(int x=minx;x<maxx;x++){\n\tif(field[prv][x]^field[cur][x])E++;\n\tif(field[cur][x]==1){\n\t  if(x-1<0||field[cur][x-1]==0)E++;\n\t  if(field[cur][x+1]==0)E++;\n\t}\n      }\n      //if(y==maxy-2)cout<<E<<endl;\n    }\n    //int S=field.count();\n    cout<<S<<endl;\n    if(R==2)cout<<E<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tmemset(g,0,sizeof(g));\n\t\tint mx = 10001,Mx = 1,my = 10001,My = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\ta++;b++;c++;d++;\n\t\t\tg[a][b]++; g[a][d]--;\n\t\t\tg[c][b]--; g[c][d]++;\n\t\t\tmx = min(mx,a);\n\t\t\tMx = max(Mx,c);\n\t\t\tmy = min(my,b);\n\t\t\tMy = max(My,d);\n\t\t}\n\t\t\n\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\tint t = 0;\n\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tg[i][j] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s = 0;\n\t\tfor(int j = my; j <= My; j++){\n\t\t\tint t = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tif(g[i][j] = t)s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t\t\n\t\tif(r==2){\n\t\t\tint l = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\t\tif(g[i][j]){\n\t\t\t\t\t\tl += !g[i-1][j]+!g[i+1][j]+!g[i][j-1]+!g[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nbool Compare(const P &p1,const P &p2){\n\treturn p1.F_<p2.F_;\n}\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<vector<P> > &range){\n\tint result=0;\n\tREP(x,0,10010){\n\t\tint y=0;\n\t\tREP(i,0,range[x].size()){\n\t\t\tif(range[x][i].S_>y) result+=range[x][i].S_-max(y,range[x][i].F_);\n\t\t\ty=max(y,range[x][i].S_);\n\t\t}\n\t}\n\treturn result;\n}\n\nint Count(vector<vector<P> > &range,vector<vector<bool> > &flag,int x){\n\tint index=0,y=0,result=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t}\n\t\t++index;\n\t}\n\treturn result;\n}\n\nint CalcLength(vector<vector<P> > &range){\n\tint result=0;\n\tvector<vector<bool> > flag(3,vector<bool>(10010));\n\tREP(x,1,10009){\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,range[x+1].size()){\n\t\t\tif(range[x+1][i].S_>y) fill_n(flag[(x+1)%3].begin()+max(y,range[x+1][i].F_),range[x+1][i].S_-max(y,range[x+1][i].F_),true);\n\t\t\ty=max(range[x+1][i].S_,y);\n\t\t}\n\t\tresult+=Count(range,flag,x);\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tvector<vector<P> > range(10010);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tREP(x,x1+4,x2+4) range[x].push_back(MP(y1+4,y2+4));\n\t\t}\n\t\tREP(x,0,10010) sort(range[x].begin(),range[x].end(),Compare);\n\t\tcout << CalcSize(range) << endl;\n\t\tif(R==2) cout << CalcLength(range) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n#define fir first\n#define sec second\n\nconst int N = 10010;\n\ntypedef pair<short,short> pii;\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<pii> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<pii> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,IN[j].size()){\n\tshort Y1 = y1[i],Y2=y2[i];\n\tshort &Y3=IN[j][k].fir;\n\tshort &Y4=IN[j][k].sec;\n\tif (Y4 <= Y1 || Y2 <= Y3)continue;\n\tisin=true;\n\tY3=min(Y1,Y3);\n\tY4=max(Y2,Y4);\n\tbreak;\n      }\n      if (!isin)IN[j].pb(mp(y1[i],y2[i]));\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<pii> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].fir,&nowh=in[i][j].sec;\n      if (nowl >= h || nowh > h){\n\tif (nowl > h)len+=2*width;\n\tarea+=(nowh-nowl)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    vector<vector<pair<int,int> > >v;\n    for(int i=0;i<n;i++){\n      int x,y,xx,yy;\n      cin>>x>>y>>xx>>yy;\n      if(v.size()<yy){\n\tv.resize(yy);\n      }\n      for(int j=y;j<yy;j++){\n\tpair<int,int> p=make_pair(x,xx);\n\tint ix=lower_bound(v[j].begin(),v[j].end(),p)-v[j].begin();\n\tv[j].insert(v[j].begin()+ix,p);\n\tint m=xx;\n\tint k;\n\tfor(k=ix+1;k<v[j].size()&&v[j][k].first<=m;k++){\n\t  m=max(m,v[j][k].second);\n\t}\n\tv[j][ix].second=m;\n\tv[j].erase(v[j].begin()+ix+1,v[j].begin()+k);\n\tif(ix&&v[j][ix-1].second>=v[j][ix].first){\n\t  v[j][ix-1].second=max(v[j][ix-1].second,v[j][ix].second);\n\t  v[j].erase(v[j].begin()+ix);\n\t}\n      }\n    }\n    int a=0;\n    for(int i=0;i<v.size();i++){\n      for(int j=0;j<v[i].size();j++){\n\ta+=v[i][j].second-v[i][j].first;\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      bool b[2][10000]={};\n      for(int i=0;i<v.size();i++){\n\tl+=v[i].size()*2;\n\tfill(b[i&1],b[(i&1)+1],false);\n\tfor(int j=0;j<v[i].size();j++){\n\t  for(int k=v[i][j].first;k<v[i][j].second;k++){\n\t    b[i&1][k]=true;\n\t  }\n\t}\n\tfor(int j=0;j<10000;j++){\n\t  l+=b[i&1][j]^b[!(i&1)][j];\n\t}\n      }\n      l+=count(b[v.size()-1&1],b[(v.size()-1&1)+1],true);\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (beg != a.beg)return beg < a.beg;\n  return end < a.end;\n}\n\n//short  isexist[N]={0};\nbool isexist[N];\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  /*\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  */\n  testcase=true;\n  rep(i,N)isexist[i]=false;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],y2[i]});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      //cout << nowl <<\" \"<< nowh <<\" \" << l<<\" \" << h << endl;\n      if (nowl > h){\n\tlen+=2*width;\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << h << endl;\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> > in;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    vector<P> v[10001];\n \n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++){\n      x1=in[i].F.F;\n      x2=in[i].F.S;\n      y1=in[i].S.F;\n      y2=in[i].S.S;\n      \n      for(int j=x1;j<x2;j++)\n\tv[j].push_back(make_pair(y1,y2));\n      \n    }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++){\n\tx1=in[i].F.F;\n\tx2=in[i].F.S;\n\ty1=in[i].S.F;\n\ty2=in[i].S.S;\n\t\n\tfor(int j=y1;j<y2;j++)\n\t  v[j].push_back(make_pair(x1,x2));\n      }\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    vector<P> v[10000];\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n      \n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b, b=B, e=E, L+=2;\n      }\n      S+=e-b, L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B, e=E, L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n\nshort s[11111][11111];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,r;\n\t\tscanf(\"%d %d\",&n,&r);\n\t\tif(n == 0 && r == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < 11111; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < 11111; ii++)\n\t\t\t{\n\t\t\t\ts[i][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\t\ts[x1][y1]++;\n\t\t\ts[x2][y2]++;\n\t\t\ts[x1][y2]--;\n\t\t\ts[x2][y1]--;\n\t\t}\n\t\tfor(int i = 0; i < 11111; i++)\n\t\t{\n\t\t\tint now = 0;\n\t\t\tfor(int ii = 0; ii < 11111; ii++)\n\t\t\t{\n\t\t\t\tnow += s[i][ii];\n\t\t\t\ts[i][ii] = now;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 11111; i++)\n\t\t{\n\t\t\tint now = 0;\n\t\t\tfor(int ii = 0; ii < 11111; ii++)\n\t\t\t{\n\t\t\t\tnow += s[ii][i];\n\t\t\t\ts[ii][i] = now;\n\t\t\t}\n\t\t}\n\t\tint all = 0;\n\t\tfor(int i = 0; i < 11111; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < 11111; ii++)\n\t\t\t{\n\t\t\t\tif(s[i][ii] > 0)\n\t\t\t\t{\n\t\t\t\t\tall++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",all);\n\t\tall = 0;\n\t\tif(r == 2)\n\t\t{\n\t\t\tfor(int i = 0; i < 11110; i++)\n\t\t\t{\n\t\t\t\tfor(int ii = 0; ii < 11110; ii++)\n\t\t\t\t{\n\t\t\t\t\tif(s[i][ii] != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(s[i - 1][ii] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ii != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(s[i][ii - 1] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s[i + 1][ii] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s[i][ii + 1] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tall++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",all);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\nint main()\n{\n\tconst int maxsize = 10002;\n\t\n\twhile(true) {\n\t\t\n\t\tint n, r;\n\t\tvector<pair<int, int> > sheet[maxsize];\n\t\t\n\t\tscanf(\"%d%d\", &n, &r);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\t\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\t\n\t\t\tx1 += 1, y1 += 1, x2 += 1, y2 += 1;\n\t\t\t\n\t\t\tsheet[x1].push_back(make_pair(y1, 1));\n\t\t\tsheet[x1].push_back(make_pair(y2, -1));\n\t\t\tsheet[x2].push_back(make_pair(y1, -1));\n\t\t\tsheet[x2].push_back(make_pair(y2, 1));\n\t\t}\n\t\t\n\t\tint size = 0, round = 0;\n\t\t\n\t\tint dp[2][maxsize] = {0};\n\t\tint *imos1, *imos2;\n\t\timos1 = dp[0];\n\t\timos2 = dp[1];\n\t\t\n\t\tfor(int x = 1; x < maxsize; ++x) {\n\t\t\t\n\t\t\tfill(imos2, imos2 + maxsize, 0);\n\t\t\t\n\t\t\tfor(int i = 0; i < sheet[x].size(); ++i) {\n\t\t\t\tint pos = sheet[x][i].first, val = sheet[x][i].second;\n\t\t\t\timos2[pos] += val;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 1; y < maxsize; ++y)\n\t\t\t\timos2[y] = imos2[y - 1] + imos2[y];\n\t\t\tfor(int y = 1; y < maxsize; ++y)\n\t\t\t\timos2[y] = imos2[y] + imos1[y];\n\t\t\t\n\t\t\tfor(int y = 1; y < maxsize; ++y) {\n\t\t\t\tint up = (imos1[y] == 0 && imos2[y] > 0) || (imos1[y] > 0 && imos2[y] == 0);\n\t\t\t\tint left = (imos2[y - 1] == 0 && imos2[y] > 0 || imos2[y - 1] > 0 && imos2[y] == 0);\n\t\t\t\tint exist = imos2[y] > 0;\n\t\t\t\tsize += exist;\n\t\t\t\tround += up + left;\n\t\t\t}\n\t\t\t\n\t\t\tswap(imos1, imos2);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", size);\n\t\tif(r == 2)\n\t\t\tprintf(\"%d\\n\", round);\n\t}\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\nvector<T> coner;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(cin >> n >> r, n | r){\n\tmemset(imos, 0, sizeof(imos));\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 10400;\n\tright_side = top = 1;\n\tconer.clear();\n\tfor(int i = 0;i < n;i++){\n\t    cin >> ax >> ay >> bx >> by;\n\n\t    \n\t    coner.push_back(T(P(ax, ay), 1));\n\t    coner.push_back(T(P(ax, by), -1));\n\t    coner.push_back(T(P(bx, ay), -1));\n\t    coner.push_back(T(P(bx, by), 1));\n\t}\n\tconer.push_back(T(P(INF, INF), 0));\n\tsort(coner.begin(), coner.end());\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(coner[p].first == P(i, j)){\n\t\t    imos[i % 3][j] += coner[p++].second;\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tcout << area << endl;\n\tif(r == 2)cout << round << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[2*N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  rep(i,n){\n    xd[px++]=x1[i];\n    xd[px++]=x2[i];\n  }\n  sort(xd,xd+px);\n  px=unique(xd,xd+px)-xd;\n  rep(i,px)IN[i].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\nvector<T> coner;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(cin >> n >> r, n | r){\n\tmemset(imos, 0, sizeof(imos));\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 1;\n\tright_side = top = 10400;\n\tconer.clear();\n\tfor(int i = 0;i < n;i++){\n\t    cin >> ax >> ay >> bx >> by;\n\n\t    \n\t    coner.push_back(T(P(++ax, ++ay), 1));\n\t    coner.push_back(T(P(++bx, ++by), 1));\n\t    coner.push_back(T(P(bx, ay), -1));\n\t    coner.push_back(T(P(ax, by), -1));\n\t}\n\tconer.push_back(T(P(INF, INF), 0));\n\tsort(coner.begin(), coner.end());\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(coner[p].first == P(i, j)){\n\t\t    imos[i % 3][j] += coner[p++].second;\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tcout << area << endl;\n\tif(r == 2)cout << round << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\n#define rep(i, n) for ( int i = 0; i < (int)n; i++ )\nusing namespace std;\n \n#define MAX 10000\n#define BEGIN 1\n#define END 0\n \nclass Sheet{\n    public:\n    int x1, y1, x2, y2;\n    Sheet(){}\n    Sheet(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2){}\n \n    bool operator < ( const Sheet &s ) const {\n    if ( x1 == s.x1 ) return y1 < s.y1;\n    return x1 < s.x1;\n    }\n};\n \nclass Event{ \n    public:\n    int id, mode, x;\n    Event(){}\n    Event( int id, int mode, int x): id(id), mode(mode), x(x){}\n \n    bool operator < ( const Event &e ) const{\n    if ( x == e.x ) return mode > e.mode;\n    return x < e.x;\n    }\n};\n \nint n, ne;\nSheet S[MAX+1];\nEvent E[2*MAX+1];\nint r;\n \nint getHeight( multiset<pair<int, int> > &seg, int &group ){\n    group = 1;\n    if ( seg.size() == 0 ) return 0;\n    int w = 0;\n    int s, t;\n    multiset<pair<int, int> >::iterator it = seg.begin();\n    s = (*it).first;\n    t = (*it).second;\n    for (++it; it != seg.end(); it++ ){\n    if ( (*it).first > t ){\n        w += (t - s);\n        s = (*it).first;\n        t = (*it).second;\n        group++;\n    } else {\n        t = max( t, (*it).second);\n    }\n    }\n    w += (t - s);\n    return w;\n}\n \nvoid sweep(){\n    multiset< pair<int, int> > cur;\n    int area = 0, vertical = 0, horizon = 0;\n    int height = 0, preH = 0, group = 0, prex = E[0].x;\n \n    for ( int e = 0; e < ne; e++ ){\n    Event ev = E[e];\n    area += (ev.x - prex)*height;\n    horizon += (ev.x - prex)*2*group;\n \n    if ( ev.mode == BEGIN ) cur.insert( make_pair( S[ev.id].y1, S[ev.id].y2) );\n    else  cur.erase( cur.find(make_pair( S[ev.id].y1, S[ev.id].y2)) );\n \n    preH = height;\n    prex = ev.x;\n \n    height = getHeight(cur, group);\n \n    if ( ev.mode == BEGIN ) vertical += height - preH;\n    else  vertical += preH - height;\n    }\n \n    printf(\"%d\\n\", area);\n    if ( r == 2 ) printf(\"%d\\n\", vertical + horizon);\n}\n \nint main(){\n    while(1){\n    scanf(\"%d %d\", &n, &r);\n    if ( n == 0 && r == 0) break;\n    ne = 0;\n    rep(i, n) scanf(\"%d %d %d %d\", &S[i].x1, &S[i].y1, &S[i].x2, &S[i].y2);\n    sort( S, S+n);\n    rep(i, n){\n        E[ne++] = Event(i, BEGIN, S[i].x1);\n        E[ne++] = Event(i, END, S[i].x2);\n    }\n    sort( E, E + ne );\n    sweep();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nstruct Square {int left, top, right, bottom;};\n\nint main() {\n    int n, r;\n    while(cin >> n >> r, n | r) {\n        vector<int> x = {0}, y = {0};\n        vector<Square> sheet(n);\n        for(auto& s: sheet) {\n            cin >> s.left >> s.top >> s.right >> s.bottom;\n            y.push_back(++s.top);\n            y.push_back(++s.bottom);\n            x.push_back(++s.left);\n            x.push_back(++s.right);\n        }\n        sort(y.begin(), y.end());\n        sort(x.begin(), x.end());\n        y.erase(unique(y.begin(), y.end()), y.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n\n        vector<vector<int>> dp(y.size(), vector<int>(x.size(), 0));\n        for(const auto& s: sheet) {\n            int top = lower_bound(y.begin(), y.end(), s.top) - y.begin();\n            int bottom = lower_bound(y.begin(), y.end(), s.bottom) - y.begin();\n            int left = lower_bound(x.begin(), x.end(), s.left) - x.begin();\n            int right = lower_bound(x.begin(), x.end(), s.right) - x.begin();\n            ++dp[top][left];\n            --dp[top][right];\n            --dp[bottom][left];\n            ++dp[bottom][right];\n        }\n\n        for(int i = 0; i < y.size(); ++i) for(int j = 1; j < x.size(); ++j) dp[i][j] += dp[i][j - 1];\n        for(int j = 0; j < x.size(); ++j) for(int i = 1; i < y.size(); ++i) dp[i][j] += dp[i - 1][j];\n\n        int area = 0, circumference = 0;\n        for(int i = 1; i < y.size() - 1; ++i) for(int j = 1; j < x.size() - 1; ++j) {\n            if(!dp[i][j]) continue;\n            area += (y[i + 1] - y[i]) * (x[j + 1] - x[j]);\n            if(!dp[i - 1][j]) circumference += (x[j + 1] - x[j]);\n            if(!dp[i + 1][j]) circumference += (x[j + 1] - x[j]);\n            if(!dp[i][j - 1]) circumference += (y[i + 1] - y[i]);\n            if(!dp[i][j + 1]) circumference += (y[i + 1] - y[i]);\n        }\n        cout << area << endl;\n        if(r == 2) cout << circumference << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1000000000\n#define fi first\n#define sec second\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nmap<P,int> *m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m=new map<P,int>();\n        scanf(\"%d %d\",&n,&r);\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n        delete m;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <list>\n#include <vector>\n\nusing namespace std;\nint N, R;\nbool **cover;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\nint main(){\n  cover = new bool*[10002];\n  for(int i=0; i<10002; ++i){\n    cover[i] = new bool[10002];\n  }\n  for(int j=0; j<10002; ++j){\n    for(int i=0; i<10002; ++i){\n      cover[j][i] = false;\n    }\n  }\n  while(cin >> N >> R && N){\n    int a,b,c,d;\n    for(int k=0; k<N; ++k){\n      cin >> a >> b >> c >> d;\n      for(int j=b+1; j<d+1; ++j){\n        for(int i=a+1; i<c+1; ++i){\n          \n          cover[j][i] = true;\n        }\n      }\n    }\n    int area_c = 0;\n    int len = 0;\n    for(int j=1; j<10001; ++j){\n      for(int i=1; i<10001; ++i){\n            \n        if(cover[j][i] == true){\n          area_c++;\n          for(int a = 0; a<4; ++a){\n            int nx = i+dx[a];\n            int ny = j+dy[a];\n            if(cover[ny][nx] == false) len++;\n          }\n        }\n      }\n    }\n    cout << area_c << endl;\n    if(R==2) cout << len << endl;\n  }\n  \n  for(int i=0; i<10001; ++i){\n    delete[] cover[i];\n  }\n  delete[] cover;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nstruct Rect{\n\tshort x1,x2,y1,y2;\n};\n\nclass Compare{\n\tpublic:\n\tbool operator()(const Rect &rect1,const Rect &rect2){\n\t\treturn rect1.x1<rect2.x1;\n\t}\n};\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<P> range[],vector<Rect> &rects){\n\tint result=0;\n\tint index=0;\n\tREP(x,0,10010){\n\t\twhile(index<rects.size()&&rects[index].x1<=x){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x].begin(),range[x].end());\n\t\tint y=0;\n\t\tREP(i,0,range[x].size()){\n\t\t\tif(range[x][i].S_>y) result+=range[x][i].S_-max(y,range[x][i].F_);\n\t\t\ty=max(y,range[x][i].S_);\n\t\t}\n\t\tvector<P>().swap(range[x]);\n\t}\n\treturn result;\n}\n\nint Count(vector<P> range[],array<array<bool,10010>,3> &flag,int x){\n\tint index=0,y=0,result=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t}\n\t\t++index;\n\t}\n\treturn result;\n}\n\nint CalcLength(vector<P> range[],vector<Rect> &rects){\n\tint result=0,index=0;\n\t//array<array<bool> > flag(3,array<bool>(10010));\n\tarray<array<bool,10010>,3> flag;\n\tREP(x,1,10009){\n\t\twhile(index<rects.size()&&rects[index].x1<=x+1){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x+1].begin(),range[x+1].end());\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,range[x+1].size()){\n\t\t\tif(range[x+1][i].S_>y) fill_n(flag[(x+1)%3].begin()+max(y,range[x+1][i].F_),range[x+1][i].S_-max(y,range[x+1][i].F_),true);\n\t\t\ty=max(range[x+1][i].S_,y);\n\t\t}\n\t\tresult+=Count(range,flag,x);\n\t\tif(x-2>=0) vector<P>().swap(range[x-2]);\n\t}\n\treturn result;\n}\n\nint main(){\n\t//std::ios::sync_with_stdio(false);\n\t//std::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\t//array<vector<P>,10010> range;\n\t\tvector<P> range[10010];\n\t\tvector<Rect> rects(N);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\trects[i].x1=x1+4;\n\t\t\trects[i].y1=y1+4;\n\t\t\trects[i].x2=x2+4;\n\t\t\trects[i].y2=y2+4;\n\t\t}\n\t\tsort(rects.begin(),rects.end(),Compare());\n\t\tcout << CalcSize(range,rects) << endl;\n\t\tif(R==2) cout << CalcLength(range,rects) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint min_x,min_y,max_x,max_y;\n\ninline void Imos(vector<vector<unsigned char> > &plane){\n\tREP(y,0,plane[0].size()){\n\t\tREP(x,1,plane.size()){\n\t\t\tplane[x][y]+=plane[x-1][y];\n\t\t}\n\t}\n\tREP(x,0,plane.size()){\n\t\tfor(int y=plane[0].size()-2; y>=0; --y){\n\t\t\tplane[x][y]+=plane[x][y+1];\n\t\t}\n\t}\n}\n\ninline int CalcSize(vector<vector<unsigned char> > &plane){\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(plane[x][y]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(vector<vector<unsigned char> > &plane,vector<vector<bool> > &has_done,int x,int y,int W,int H){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[x][y]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[nx][ny]){\n\t\t\t\tif(plane[nx][ny]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[nx][ny]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int CalcLength(vector<vector<unsigned char> > &plane,int n,vector<int> &X,vector<int> &Y){\n\tvector<vector<bool> > has_done(plane.size(),vector<bool>(plane[0].size()));\n\tint result=0;\n\t/*\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(!has_done[x][y]&&plane[x][y]>0){\n\t\t\t\tresult+=BFS(plane,has_done,x,y,plane.size(),plane[0].size());\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tREP(i,0,n){\n\t\tif(!has_done[X[i]][Y[i]]&&plane[X[i]][Y[i]]>0) result+=BFS(plane,has_done,X[i],Y[i],plane.size(),plane[0].size());\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tX[j].push_back(x);\n\t\t\t\tY[j].push_back(y);\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\tvector<vector<unsigned char> > plane(max_x+4-min_x,vector<unsigned char>(max_y+4-min_y));\n\t\tREP(i,0,N){\n\t\t\tplane[X[0][i]+1-min_x][Y[1][i]+1-min_y]+=1;\n\t\t\tplane[X[1][i]+2-min_x][Y[0][i]-min_y]+=1;\n\t\t\tplane[X[0][i]+1-min_x][Y[0][i]-min_y]+=-1;\n\t\t\tplane[X[1][i]+2-min_x][Y[1][i]+1-min_y]+=-1;\n\t\t}\n\t\tImos(plane);\n\t\tcout << CalcSize(plane) << endl;\n\t\tif(R==2) cout << CalcLength(plane,N,X[0],Y[0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define at(x,y) (x*10000+y)\n#define pos_X(x) (x/10000)\n#define pos_Y(y) (y%10000)\nstruct rect {\n\tint x1,y1,x2,y2;\n};\n\nusing namespace std;\n\nint main(){\n\tint n,r;\n\twhile(cin >> n >> r,n||r){\n\t\tif(n == 2) cout << \"00\" << endl << \"00\" << endl;\n\t\tvector<int> xpos;\n\t\tvector<int> ypos;\n\t\tqueue<pair<int,int>> q;\n\t\tunordered_multimap<int,int> m;\n\t\tfor(int i=0;i<n;i++){\n\t\t\trect A;\n\t\t\tcin >> A.x1 >> A.y1 >> A.x2 >> A.y2;\n\t\t\t//m.insert(at(A.x1,A.y1),at(A.x2,A.y2));\n\t\t\tq.push(make_pair(at(A.x1,A.y1),at(A.x2,A.y2)));\n\t\t\txpos.emplace_back(A.x1);\n\t\t\txpos.emplace_back(A.x2);\n\t\t\typos.emplace_back(A.y1);\n\t\t\typos.emplace_back(A.y2);\n\t\t}\n\t\t\n\t\tsort(xpos.begin(),xpos.end());\n\t\tsort(ypos.begin(),ypos.end());\n\t\tunordered_map<int,int> X_next;\n\t\tunordered_map<int,int> Y_next;\n\t\tfor(int unsigned i = 0;i<xpos.size()-1;i++){\n\t\t\tX_next[xpos[i]] = xpos[i+1];\n\t\t}\n\t\tfor(int unsigned i = 0;i<ypos.size()-1;i++){\n\t\t\tY_next[ypos[i]] = ypos[i+1];\n\t\t}\n\t\tset<pair<pair<int,int>,pair<int,int>>> s;\n\t\twhile(!q.empty()){\n\t\t\tauto u = q.front();\n\t\t\tq.pop();\n\t\t\tint x1 = pos_X(u.first);\n\t\t\tint y1 = pos_Y(u.first);\n\t\t\tint x2 = pos_X(u.second);\n\t\t\tint y2 = pos_Y(u.second);\n\t\t\tif(X_next[x1] < x2 && Y_next[y1] < y2){\n\t\t\t\tq.push(make_pair(at(X_next[x1],y1),at(x2,Y_next[y1])));\n\t\t\t\tq.push(make_pair(at(x1,Y_next[y1]),at(X_next[x1],y2)));\n\t\t\t\tq.push(make_pair(at(X_next[x1],Y_next[y1]),at(x2,y2)));\n\t\t\t} else if(X_next[x1] < x2){\n\t\t\t\tq.push(make_pair(at(X_next[x1],y1),at(x2,Y_next[y1])));\n\t\t\t} else if(Y_next[y1] < y2){\n\t\t\t\tq.push(make_pair(at(x1,Y_next[y1]),at(X_next[x1],y2)));\n\t\t\t}\n\t\t\tif(x1 == x2 || y1 == y2) continue;\n\t\t\ts.insert(make_pair(make_pair(x1,y1),make_pair(X_next[x1],Y_next[y1])));\n\t\t}\n\t\tint sum = 0;\n\t\tfor(auto x:s){\n\t\t\tcout << x.first.first << \" \" << x.first.second << \" \" << x.second.first << \" \" << x.second.second << endl;\n\t\t\tsum += (x.second.first - x.first.first)*(x.second.second - x.first.second);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint map[10005][10005];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=0,maxy=0;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tmap[x1][y1]-=1;\n\t\t\tmap[x2][y1]+=1;\n\t\t\tmap[x1][y2]+=1;\n\t\t\tmap[x2][y2]-=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tt+=map[j][i];\n\t\t\t\tmap[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tt+=map[i][j];\n\t\t\t\tmap[i][j]=t;\n\t\t\t\tif(map[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\t/*if(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(map[i][j]>=1){\n\t\t\t\t\t\tif(map[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(map[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}*/\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tmemset(g,0,sizeof(g));\n\t\tint mx = 10001,Mx = 1,my = 10001,My = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\ta++;b++;c++;d++;\n\t\t\tg[a][b]++; g[a][d]--;\n\t\t\tg[c][b]--; g[c][d]++;\n\t\t\tmx = min(mx,a);\n\t\t\tMx = max(Mx,c);\n\t\t\tmy = min(my,b);\n\t\t\tMy = max(My,d);\n\t\t}\n\t\t\n\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\tint t = 0;\n\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tg[i][j] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s = 0;\n\t\tfor(int j = my; j <= My; j++){\n\t\t\tint t = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tif(g[i][j] = t)s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t\t\n\t\tif(r==2){\n\t\t\tint l = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\t\tif(g[i][j]){\n\t\t\t\t\t\tl += !g[i-1][j]+!g[i+1][j]+!g[i][j-1]+!g[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint main()\n{\nint n,r;\nwhile(1)\n{\ncin >> n >> r;\nint m[10010][10010];\nmemset(m,0,sizeof(m));\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\twhile (1) {\n\t\tint A, B; cin >> A >> B;\n\t\tif (!A)break;\n\t\tvector<vector<pair<int, int>>>pluss(10002), minuss(10002);\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tint l, u, r, d; cin >> l >> u >> r >> d;\n\t\t\tl++;  r++;\n\t\t\tpluss[u].push_back(make_pair(l, r));\n\t\t\tminuss[d].push_back(make_pair(l, r));\n\t\t}\n\n\t\tvector<int>v(10002);\n\t\tint area = 0;\n\t\tint circ = 0;\n\t\tfor (int y = 0; y < 10001; ++y) {\n\t\t\tvector<int>nextv(v);\n\t\t\tfor (auto p : pluss[y]) {\n\t\t\t\tfor (int x = p.first; x < p.second; ++x) {\n\t\t\t\t\tnextv[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto p : minuss[y]) {\n\t\t\t\tfor (int x = p.first; x < p.second; ++x) {\n\t\t\t\t\tnextv[x]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10002; ++i) {\n\t\t\t\tif (nextv[i])area++;\n\t\t\t\tif (bool(nextv[i]) != bool(v[i]))circ++;\n\t\t\t\tif (i&&(bool(nextv[i]) != bool(nextv[i - 1])))circ++;\n\t\t\t}\n\t\t\tv = nextv;\n\t\t}\n\t\tcout << area << endl;\n\t\tif (B == 2)cout << circ << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    vector<P> v[10001];\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n      \n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b, b=B, e=E, L+=2;\n      }\n      S+=e-b, L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B, e=E, L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        //bool *map;\n        short** map;\n        map=new short*[10001];\n        for(int w=0;w<=10000;w++){\n            map[w] = new short[10001];\n        }\n        \n        short** imos;\n        imos=new short*[10001];\n        for(int w=0;w<=10000;w++){\n            imos[w] = new short[10001];\n        }\n       \n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n        }\n        /*\n        for(int h=0;h<=10;h++){\n           for(int w=0;w<=10;w++){\n                //printf(\"%2d \",map[w][h]);\n           }\n           //cout<<endl;\n        }\n        //cout<<endl;\n        */\n        int S=0;\n        int L=0;\n        for(int h=0;h<=10;h++){\n            int state=0;\n           for(int w=0;w<=10;w++){\n               int res=0;\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n/*\n        for(int h=0;h<=10;h++){\n            for(int w=0;w<=10;w++){\n               printf(\"%2d \",imos[w][h]);\n           }\n           cout<<endl;\n        }\n        */\n        cout<<S<<endl;\n        if(r==2)cout<<L<<endl;\n        \n        /*\n        int S=0;\n        int L=0;\n        bool old=false;\n        for(int w=0;w<=10000;w++){\n            old=false;\n            for(int h=0;h<=10000;h++){\n                if(map[w][h]){S++;}\n                if(old!=map[w][h]){L++;}\n                old=map[w][h];\n            }\n            if(old==true){L++;}\n        }\n        for(int h=0;h<=10000;h++){\n            old=false;\n           for(int w=0;w<=10000;w++){\n                if(old!=map[w][h]){L++;}\n                old=map[w][h];\n            }\n            if(old==true){L++;}\n        }\n        \n        cout<<S<<endl;\n        if(r==2){\n            std::cout << L << std::endl;\n        }\n        */\n\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint fie[3000][3000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#define FMAX 10000\n#define initarr(a) memset(a, 0, sizeof(a))\nusing namespace std;\ntypedef map<short, map<short, short> > V;\n\nshort calc_x_arr[FMAX];\n\nvoid add_vertex(V &vertexes, short x, short y, short t) {\n  auto &xv = vertexes[y];\n  auto &sum = xv[x];\n  sum += t;\n}\n\nint main() {\n  short n, r;\n  while (cin >> n >> r, n || r) {\n    // load\n    short x1, y1, x2, y2;\n    short min_x = FMAX, min_y = FMAX, max_x = 0, max_y = 0;\n    V vertexes;\n    for (short i = 0; i < n; i++) {\n      cin >> x1 >> y1 >> x2 >> y2;\n      add_vertex(vertexes, x1, y1, 1);\n      add_vertex(vertexes, x1, y2, -1);\n      add_vertex(vertexes, x2, y1, -1);\n      add_vertex(vertexes, x2, y2, 1);\n      min_x = min(min_x, x1);\n      min_y = min(min_y, y1);\n      max_x = max(max_x, x2);\n      max_y = max(max_y, y2);\n    }\n\n    // calc\n    int area = 0, perimeter = 0;\n    short prev_y = -1;\n    short prev_partial_vertical_perimeter = 0;\n    short prev_partial_area = 0;\n    initarr(calc_x_arr);\n    for (auto yvit = vertexes.begin(); yvit != vertexes.end(); yvit++) {\n      area += prev_partial_area * (yvit->first - prev_y - 1);\n      prev_partial_area = 0;\n      if (r == 2) {\n        perimeter += prev_partial_vertical_perimeter * (yvit->first - prev_y - 1);\n        prev_partial_vertical_perimeter = 0;\n      }\n      short left = 0;\n      short xsum = 0;\n      auto xvit = yvit->second.begin();\n      for (short x = min_x; x <= max_x; x++) {\n        if (x == xvit->first) {\n          xsum += xvit->second;\n          if (++xvit == yvit->second.end()) {\n            xvit = yvit->second.begin();\n          }\n        }\n        short current = xsum + calc_x_arr[x];\n        if (current != 0) prev_partial_area++;\n        if (r == 2) {\n          bool vdelta = left == 0 ^ current == 0;\n          prev_partial_vertical_perimeter += vdelta;\n          perimeter += vdelta + (calc_x_arr[x] == 0 ^ current == 0);\n        }\n        left = calc_x_arr[x] = current;\n      }\n      area += prev_partial_area;\n      prev_y = yvit->first;\n    }\n\n    cout << area << endl;\n    if (r == 2) cout << perimeter << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nshort g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(x1,minx);\n\t\t\tminy=min(y1,miny);\n\t\t\tmaxx=max(x2,maxx);\n\t\t\tmaxy=max(y2,maxy);\n\t\t\tg[x1][y1]++;\n\t\t\tg[x2][y1]--;\n\t\t\tg[x1][y2]--;\n\t\t\tg[x2][y2]++;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nvector<pair<int, int> > a[10010];\nvector<pair<int, int> > b[10010];\n\nint main() {\n  while (true) {\n    int n, r;\n    cin >> n >> r;\n    if (n == 0 && r == 0) break;\n    rep (i, 10010) a[i].clear();\n    rep (i, 10010) b[i].clear();\n    rep (i, n) {\n      int x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for (int x = x1; x < x2; ++x) {\n\ta[x].push_back(make_pair(y1, -1));\n\ta[x].push_back(make_pair(y2, 1));\n      }\n      for (int y = y1; y < y2; ++y) {\n\tb[y].push_back(make_pair(x1, -1));\n\tb[y].push_back(make_pair(x2, 1));\n      }\n    }\n    rep (i, 10010) {\n      sort(a[i].begin(), a[i].end());\n      sort(b[i].begin(), b[i].end());\n    }\n    int res = 0;\n    rep (i, 10010) {\n      int c = 0, pre = -1;\n      rep (j, a[i].size()) {\n\tif (a[i][j].second == -1) {\n\t  if (c == 0) pre = a[i][j].first;\n\t  ++c;\n\t} else {\n\t  --c;\n\t  if (c == 0) res += a[i][j].first - pre;\n\t}\n      }\n    }\n    cout << res << endl;\n    if (r == 2) {\n      res = 0;\n      rep (i, 10010) {\n\tint c = 0;\n\trep (j, a[i].size()) {\n\t  if (a[i][j].second == -1) {\n\t    if (c == 0) ++res;\n\t    ++c;\n\t  } else {\n\t    --c;\n\t    if (c == 0) ++res;\n\t  }\n\t}\n      }\n      rep (i, 10010) {\n\tint c = 0;\n\trep (j, b[i].size()) {\n\t  if (b[i][j].second == -1) {\n\t    if (c == 0) ++res;\n\t    ++c;\n\t  } else {\n\t    --c;\n\t    if (c == 0) ++res;\n\t  }\n\t}\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (beg != a.beg)return beg < a.beg;\n  return end < a.end;\n}\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,IN[j].size()){\n\tshort Y1 = y1[i],Y2=y2[i];\n\tshort &Y3=IN[j][k].beg;\n\tshort &Y4=IN[j][k].end;\n\tif (Y4 <= Y1 || Y2 <= Y3)continue;\n\tisin=true;\n\tY3=min(Y1,Y3);\n\tY4=max(Y2,Y4);\n\tbreak;\n      }\n      if (!isin)IN[j].pb((st){y1[i],y2[i]});\n      j++;\n    }\n  }\n\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      //cout << nowl <<\" \"<< nowh <<\" \" << l<<\" \" << h << endl;\n      if (nowl > h){\n\tlen+=2*width;\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << h << endl;\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,r;\nvector<P> x[10002];\nvector<P> xx[10002];\nint main(void){\n  while(cin >> n >> r && n){\n    for(int i = 0; i < 10002; i++){\n      x[i].clear();\n      xx[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      for(int j = x1; j < x2; j++){\n\tbool f = true;\n\tfor(int k = 0; k < (int)x[j].size(); k++){\n\t  if(x[j][k].F <= y2 && x[j][k].S >= y1){\n\t    x[j][k].F = min(x[j][k].F,y1);\n\t    x[j][k].S = max(x[j][k].S,y2);\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\tif(f) x[j].push_back(P(y1,y2));\n      }\n    }\n\n    for(int i = 0; i < 10000; i++){\n      if(x[i].empty()) continue;\n      sort(x[i].begin(),x[i].end());\n      xx[i].push_back(x[i][0]);\n      for(int j = 1,k = 0; j < (int)x[i].size(); j++){\n\tif(xx[i][k].S >= x[i][j].F){\n\t  xx[i][k].S = max(xx[i][k].S,x[i][j].S);\n\t}else{\n\t  xx[i].push_back(x[i][j]);\n\t  k++;\n\t}\n      }\n      //x[i].clear();\n      /*\n      cout << \"x = \" << i << endl;\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tcout << \"( \" << xx[i][j].F << \" , \" << xx[i][j].S << \" )\" << endl;\n      }\n      cout << endl;\n      //*/\n    }\n\n    int res = 0;\n    for(int i = 0; i < 10000; i++){\n      for(int j = 0; j < (int)xx[i].size(); j++){\n\tres += xx[i][j].S - xx[i][j].F;\n      }\n    }\n    cout << res << endl;\n\n    if(r-1){\n      res = 0;\n      for(int i = 0; i < 10000; i++){\n\tres += 2 * (int)xx[i].size();\n\tfor(int j = 0; j < (int)xx[i].size(); j++){\n\t  res += 2 * (xx[i][j].S - xx[i][j].F);\n\t  if(i){\n\t    for(int k = 0; k < (int)xx[i-1].size(); k++){\n\t      if(xx[i][j].F < xx[i-1][k].S && xx[i][j].S > xx[i-1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i-1][k].S) - max(xx[i][j].F,xx[i-1][k].F);\n\t      }\n\t    }\t\n\t  }  \n\t  if(i+1 < 10000){\n\t    for(int k = 0;k < (int)xx[i+1].size(); k++){\n\t      if(xx[i][j].F < xx[i+1][k].S && xx[i][j].S > xx[i+1][k].F){\n\t\tres -= min(xx[i][j].S,xx[i+1][k].S) - max(xx[i][j].F,xx[i+1][k].F);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include <map>\n#include<cstring>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\nshort node[10001];\nshort state_before[10001];\nshort map_before[10001];\n\n//std::vector< tuple< int,int,int> > points;\n\nmap<int,list<pair<int,int>>> points;\n\n\n\nvoid read_points(int tate){\n    memcpy(map_before,node,sizeof node);\n    memset(node,0,sizeof(node));    \n    for(auto tmp:points[tate]){\n        node[tmp.first]+=tmp.second;\n    }\n}\nint main(){\n    \n    int n,r;\n    \n    int S=0;\n    int L=0;\n\n  \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n        \n        points.clear();\n        int x1,y1,x2,y2;\n        int max_x=0,min_x=10000,max_y=0,min_y=10000;\n        for(int i=0;i<n;i++){\n            cin>>x1>>y1>>x2>>y2;\n            tuple<int,int,int> tl=make_tuple(y1,x1,1);\n            tuple<int,int,int> tr=make_tuple(y1,x2,-1);\n            tuple<int,int,int> bl=make_tuple(y2,x1,-1);\n            tuple<int,int,int> br=make_tuple(y2,x2,1);\n            \n            if(points.find(y1)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y1]=tmp;\n            }\n            if(points.find(y2)==points.end()){\n                list<pair<int,int> > tmp;\n                points[y2]=tmp;\n            }\n            points[y1].push_back(make_pair(x1,1));\n            points[y1].push_back(make_pair(x2,-1));\n            points[y2].push_back(make_pair(x1,-1));\n            points[y2].push_back(make_pair(x2,1));\n            /*points.push_back(tl);\n            points.push_back(tr);\n            points.push_back(bl);\n            points.push_back(br);\n            */\n\n            if(max_x<x2)max_x=x2;\n            if(max_y<y2)max_y=y2;\n            if(min_x>x1)min_x=x1;\n            if(min_y>y1)min_y=y1;\n            \n            //min_x=0,max_x=11;\n            //min_y=0,max_y=11;\n            \n        }\n        \n        \n        S=0;\n        L=0;\n        for(int h=min_y;h<=max_y;h++){\n            \n            read_points(h);\n            int yoko_state=0;\n            for(int w=min_x;w<=max_x;w++){\n                \n                //printf(\"%2d \",node[w]);\n                \n                yoko_state+=node[w];\n                node[w]=yoko_state;\n                if(h!=0){\n                    node[w]+=state_before[w];\n                }\n                state_before[w]=node[w];\n                //printf(\"%2d \",node[w]);\n                if(node[w]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(node[w-1]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(map_before[w]==0)L+=2;\n                }\n                \n                \n            }\n            //cout<<endl;\n            \n        }\n\n\n        cout<<S<<endl;\n        if(r==2){\n            cout<<L<<endl;\n        }\n        \n        \n\n    }\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAX 10000\n//int 4byte\n//データ構造 R（左下，右上）,(LorR，左端ｘ座標，Rx)\n//参考：蟻231 233\n//ｘ毎のmin maxを記録\n//vectorに入れてソート\n\nusing namespace std;\n\nint main(){\n    while(1){\n        vector< vector<char> > square(MAX+1, vector<char>(MAX+1));\n        int mode, num, area = 0, len = 0 ,count, countL, countR;\n        int x, y, xx, yy;\n        int MAX_X = 0, MAX_Y = 0;\n        cin >> num >> mode;\n        if(num == 0 && mode == 0)break;\n        \n        for (int i = 0; i<num; i++){\n            cin >> x >> y >> xx >> yy;\n            for(int dx=x;dx<xx;dx++){\n                square[dx][y] += 1;\n                square[dx][yy] += -1;\n            }\n        }\n        for(int dx=0;dx<MAX+1;dx++){\n            count = 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[dx][dy];\n                if(count > 0) area++;\n            }\n        }\n        cout << area <<endl;\n        \n        \n        if(mode == 2){\n            //左端\n            count = 0;\n            countR= 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[0][dy];\n                countR+= square[1][dy];\n                if(count > 0) len++;\n                if(count > 0 && count == square[0][dy])len++;\n                if(count > 0 && countR < 1)len++;\n                if(count == 0 && square[0][dy] < 0)len++;\n            }\n            //中\n            for(int dx=1;dx<MAX;dx++){\n                countL= 0;\n                count = 0;\n                countR= 0;\n                for(int dy=0;dy<MAX+1;dy++){\n                    countL+= square[dx-1][dy];\n                    count += square[dx][dy];\n                    countR+= square[dx+1][dy];\n                    if(count > 0 && countL < 1)len++;\n                    if(count > 0 && countR < 1)len++;\n                    if(count > 0 && count == square[dx][dy])len++;\n                    if(count == 0 && square[dx][dy] < 0)len++;\n                }\n            }\n            //右端\n            count = 0;\n            countL= 0;\n            for(int dy=0;dy<MAX+1;dy++){\n                count += square[MAX][dy];\n                countL+= square[MAX-1][dy];\n                if(count > 0) len++;\n                if(count > 0 && count == square[MAX][dy])len++;\n                if(count > 0 && countL < 1)len++;\n                if(count == 0 && square[MAX][dy] < 0)len++;\n            }\n        }\n        cout << len << endl;\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint n, r, mx, Mx, my, My, res;\nint mp[10003][10003];\nint main() {\n    while (scanf(\"%d%d\",&n,&r)) {\n        if (!n&&!r) break;\n        mx=10003; Mx=0; my=10003; My=0;\n        for (int i=0; i<10003; i++) for (int j=0; j<10003; j++) mp[i][j]=0;\n        for (int i=0; i<n; i++) {\n            int a, b, c, d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            a++; b++; c++; d++;\n            mp[a][b]++; mp[c][d]++;\n            mp[a][d]--; mp[c][b]--;\n            mx=min(mx,a);\n            Mx=max(Mx,c+1);\n            my=min(my,b);\n            My=max(My,d+1);\n        }\n        for (int i=mx; i<Mx; i++) {\n            for (int j=my; j<My; j++) mp[i][j]+=mp[i][j-1];\n        }\n        for (int i=my; i<My; i++) {\n            for (int j=mx; j<Mx; j++) mp[j][i]+=mp[j-1][i];\n        }\n        res=0;\n        for (int i=mx; i<Mx; i++) for (int j=my; j<My; j++) if (mp[i][j]!=0) res++;\n        printf(\"%d\\n\",res);\n        if (r==2) {\n            res=0;\n            for (int i=mx; i<Mx; i++) for (int j=my; j<My; j++) {\n                if (mp[i][j]) res+=!mp[i-1][j]+!mp[i][j-1]+!mp[i+1][j]+!mp[i][j+1];\n            }\n            printf(\"%d\\n\",res);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[4000][4000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> T;\n#define INF (1 << 30)\n\npriority_queue<T, vector<T>, greater<T> > pq;\nint ax, ay, bx, by, n, r, p;\nint round, area, left_side, right_side, bottom, top;\nint imos[3][10500];\nint main(){\n    while(scanf(\"%d%d\", &n, &r), r){\n\tmemset(imos, 0, sizeof(imos));\n\tround = area = 0;\n\tp = 0;\n\tleft_side = bottom = 10500;\n\tright_side = top = 1;\n\tfor(int i = 0;i < n;i++){\n\t    scanf(\"%d%d%d%d\", &ax, &ay, &bx, &by);\n\t    left_side = min(left_side, ++ax);\n\t    right_side = max(right_side, ++bx);\n\t    bottom = min(bottom, ++ay);\n\t    top = max(top, ++by);\t    \n\t    pq.push(T(P(ax, ay), 1));\n\t    pq.push(T(P(ax, by), -1));\n\t    pq.push(T(P(bx, ay), -1));\n\t    pq.push(T(P(bx, by), 1));\n\t}\n\tpq.push(T(P(INF, INF), 0));\n\tfor(int i = left_side;i < right_side + 2;i++){\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] = imos[i % 3][j - 1];\n\t\twhile(pq.top().first == P(i, j)){\n\t\t    imos[i % 3][j] += pq.top().second;pq.pop();\n\t\t}\n\t    }\n\t    for(int j = bottom;j < top + 2;j++){\n\t\timos[i % 3][j] += imos[(i - 1) % 3][j];\n\t\tif(imos[i % 3][j])area++;\n\t\tif(!!imos[i % 3][j] != !!imos[i % 3][j - 1])round++;\n\t\tif(!!imos[i % 3][j] != !!imos[(i - 1) % 3][j])round++; \n\t    }\n\n\t}\n\tpq.pop();\n\tprintf(\"%d\\n\", area);\n\tif(r == 2)printf(\"%d\\n\", round);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  vector<int>v[10002];\n\n  while(cin >> n >> r,n|r){\n    for(int i=0;i<10002;i++)v[i].clear();\n\n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      for(int j=x1;j<x2;j++){\n        for(int k=y1;k<y2;k++)v[j].push_back(k);\n\n        sort(v[j].begin(),v[j].end());\n\n        vector<int>::iterator it;\n        it=unique(v[j].begin(),v[j].end());\n        v[j].erase(it,v[j].end());\n      }\n    }\n    \n    int S=0;\n    for(int i=0;i<10001;i++)S+=v[i].size();\n\n    cout << S << endl;\n    if(r==2){\n      int L=v[0].size();\n\n      for(int i=0;i<10001;i++){\n\tif(v[i].size()>0)L+=2;\n        for(int j=0;j<v[i].size();j++){\n\t  if(j<v[i].size()-1 && v[i][j+1]!=v[i][j]+1)L+=2;\n          if(i>0 && !binary_search(v[i-1].begin(),v[i-1].end(),v[i][j]))L++;\n\t  if(!binary_search(v[i+1].begin(),v[i+1].end(),v[i][j]))L++;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nint main()\n{\n    static int a[10050][10050];\n    int n, r;\n    while (scanf(\"%d%d\", &n, &r), n)\n    {\n        static int x1[10010], y1[10010], x2[10010], y2[10010];\n        int min_x = 1e9, max_x = 0, min_y = 1e9, max_y = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            scanf(\"%d%d%d%d\", x1 + i, y1 + i, x2 + i, y2 + i);\n            min_swap(min_x, ++x1[i]);\n            min_swap(min_y, ++y1[i]);\n            max_swap(max_x, ++x2[i]);\n            max_swap(max_y, ++y2[i]);\n        }\n        for (int y = min_y - 1; y <= max_y + 1; ++y)\n            for (int x = min_x - 1; x <= max_x + 1; ++x)\n                a[y][x] = 0;\n\n\n        for (int i = 0; i < n; ++i)\n            for (int y = y1[i]; y < y2[i]; ++y)\n                max_swap(a[y][x1[i]], x2[i] - x1[i]);\n\n        int area = 0, len = 0;\n        for (int y = min_y; y <= max_y; ++y)\n        {\n            for (int x = min_x; x <= max_x; ++x)\n            {\n                if (a[y][x] == 0)\n                {\n                    if (a[y][x - 1] > 0)\n                        ++len;\n                    if (a[y - 1][x] > 0)\n                        ++len;\n                }\n                else\n                {\n                    if (a[y][x - 1] == 0)\n                        ++len;\n                    if (a[y - 1][x] == 0)\n                        ++len;\n                    ++area;\n\n                    max_swap(a[y][x + 1], a[y][x] - 1);\n                }\n            }\n        }\n\n        if (r == 1)\n            printf(\"%d\\n\", area);\n        else\n            printf(\"%d\\n%d\\n\", area, len);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n  \n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    \n    vector<pair<P,P> > in;\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n    \n    sort(in.begin(),in.end(),cmp_x);\n    \n    int S=0,L=0;\n    vector<P>v;\n    for(int i=0;i+1<10001;i++){\n      v.clear();\n      for(int j=0;j<n;j++){\n\tif(in[j].S.S>=i+1 && i>=in[j].S.F){\n\t  v.push_back(make_pair(in[j].F.F,in[j].F.S));\n\t}\n      }\n      \n      if(v.size()!=0){\n\t//sort(v.begin(),v.end());\n\tint b=v[0].F,e=v[0].S;\n\tfor(int j=1;j<v.size();j++){\n\t  int B=v[j].F,E=v[j].S;\n\t  if(e>=B)e=max(e,E);\n\t  else S+=e-b, b=B, e=E, L+=2;\n\t}\n\tS+=e-b, L+=2;\n      }\n    }\n    cout << S << endl;\n    \n    \n    if(r==2){\n      \n      sort(in.begin(),in.end(),cmp_y);\n      \n      for(int i=0;i+1<10001;i++){\n\t\n\tv.clear();\n\tfor(int j=0;j<n;j++){\n\t  if(in[j].F.S>=i+1 && i>=in[j].F.F)\n\t    v.push_back(make_pair(in[j].S.F,in[j].S.S));\n\n\t}\n\tif(v.size()!=0){\n\t  //sort(v.begin(),v.end());\n\t  int b=v[0].F,e=v[0].S;\n\t  \n\t  for(int j=1;j<v.size();j++){\n\t    int B=v[j].F,E=v[j].S;\n\t    \n\t    if(e>=B)e=max(e,E);\n\t    else b=B, e=E, L+=2;\n\t  }\n\t  L+=2;\n\t}\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nvector<pair<int,int> >v[10000];\nbool b[2][10000]={};\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    for(int i=0;i<n;i++){\n      int x,y,xx,yy;\n      cin>>x>>y>>xx>>yy;\n      for(int j=y;j<yy;j++){\n\tv[j].push_back(make_pair(x,xx));\n      }\n    }\n    for(int i=0;i<10000;i++){\n      sort(v[i].begin(),v[i].end());\n      for(int j=0;j<v[i].size();j++){\n\tint m=v[i][j].second;\n\tint k;\n\tfor(k=j+1;k<v[i].size()&&v[i][k].first<=m;k++){\n\t  m=max(m,v[i][k].second);\n\t}\n\tv[i][j].second=m;\n\tv[i].erase(v[i].begin()+j+1,v[i].begin()+k);\n      }\n    }\n    int a=0;\n    for(int i=0;i<10000;i++){\n      for(int j=0;j<v[i].size();j++){\n\ta+=v[i][j].second-v[i][j].first;\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      for(int i=0;i<10000;i++){\n\tl+=v[i].size()*2;\n\tfill(b[i&1],b[(i&1)+1],false);\n\tfor(int j=0;j<v[i].size();j++){\n\t  for(int k=v[i][j].first;k<v[i][j].second;k++){\n\t    b[i&1][k]=true;\n\t  }\n\t}\n\tfor(int j=0;j<10000;j++){\n\t  l+=b[i&1][j]^b[!(i&1)][j];\n\t}\n      }\n      l+=count(b[1],b[2],true);\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp( const P &p , const P &q ){\n    return p < q;\n}\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r,n|r){\n    vector<P>vx[10000],vy[10000];\n    \n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      for(int j=x1;j<x2;j++)\n\tvx[j].push_back(make_pair(y1,y2));\n\n      if(r==2)\n\tfor(int j=y1;j<y2;j++)\n\t  vy[j].push_back(make_pair(x1,x2));\n    }\n\n    int S=0,L=0;\n\n    for(int i=0;i<10000;i++)\n\tsort(vx[i].begin(),vx[i].end(),cmp);\n \n    for(int i=0;i<10000;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n    \n\n    if(r==2){\n      for(int i=0;i<10000;i++)\n\t  sort(vy[i].begin(),vy[i].end(),cmp);\n      \n      for(int i=0;i<10000;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespaece std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define mp make_pair\nvector<P>vec[10005];\nint num[10005];\nint rank[10005];\nint par[10005];\nvoid init(int n)\n{\n  for(int i=0;i<n;i++)\n    {\n      rank[i]=0;\n      par[i]=i;\n    }\n}\nint find(int x)\n{\n  if(x==par[x])\n    {\n      return x;\n    }\n  else\n    {\n      return find(par[x]);\n    }\n}\nvoid update(int x,int y)\n{\n  if(par[x]==par[y])\n    {\n      return ;\n    }\n  else\n    {\n      if(rank[x]<rank[y])\n\t{\n\t  par[x]=y;\n\t}\n      else\n\t{\n\t  par[y]=x;\n\t  if(rank[x]==rank[y])\n\t    {\n\t      rank[x]++;\n\t    }\n\t}\n    }\n}\nbool same(int a,int b)\n{\n  return par[a]==par[b];\n}\nint main()\n{\n  int n,m;\n  while(1)\n    {\n      int ans1=0;\n      int ans2=0;\n      scanf(\"%d %d\",&n,&m);\n      for(int i=0;i<=10000;i++)\n\t{\n\t  vec[i].resize(0);\n\t}\n      if(!n && !m) break;\n      for(int w=0;w<n;w++)\n\t{\n\t  int a,b,c,d;\n\t  scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t  for(int i=a;i<c;i++)\n\t    {\n\t      vec[i].pb(mp(b,d-b));\n\t    }\n\t}\n      for(int i=0;i<=10000;i++)\n\t    {\n\t      if(vec[i].size())\n\t\t{\n\t\t  memset(num,0,sizeof(num));\n\t\t  for(int j=0;j<vec[i].size();j++)\n\t\t    {\n\t\t      num[vec[i][j].first]=max(num[vec[i][j].first],vec[i][j].second);\n\t\t    }\n\t\t  for(int j=0;j<=10000;j++)\n\t\t    {\n\t\t      if(j!=0)\n\t\t\t{\n\t\t\t  num[j]=max(num[j],num[j-1]+1);\n\t\t\t}\n\t\t      if(num[j]!=0)\n\t\t\t{\n\t\t\t  ans1++;\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t    }\n      printf(\"%d\\n\",ans1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nchar m[10003][10003] = {0};\n\nint main() {\n\tint n, r;\n\twhile (cin >> n >> r, n || r) {\n\t\tfill(&m[0][0], &m[0][0] + 10002*10002, 0);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\t++x1, ++y1;//, ++x2, ++y2;\n\t\t\tif (x2 != 0 && y2 != 0) {\n\t\t\t\t++m[y1][x1], --m[y1][x2+1];\n\t\t\t\t--m[y2+1][x1], ++m[y2+1][x2+1];\n\t\t\t}\n\t\t}\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tm[y][x+1] += m[y][x];\n\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tm[y+1][x] += m[y][x];\n\n\t\tint s = 0, l = 0;\n\t\tfor (int y = 1; y < 10002; ++y)\n\t\t\tfor (int x = 1; x < 10002; ++x)\n\t\t\t\tif (m[y][x])\n\t\t\t\t\tl += !m[y-1][x] + !m[y+1][x] + !m[y][x-1] + !m[y][x+1],\n\t\t\t\t\t++s;\n\n\t\tcout << s << endl;\n\t\tif (r == 2) cout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[4000][3000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\t//for(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]);\n\t\t\tvx.push_back(x2[i]);\n\t\t\tvy.push_back(y1[i]);\n\t\t\tvy.push_back(y2[i]);\n\t\t//}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> >in;\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<P>vx[10001],vy[10001];\n\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint sum[2][10001], c[2][10001];\nvector<int>E[10001], G[10001];\nint main() {\n\tint n, r;\n\twhile (scanf(\"%d%d\", &n, &r), n) {\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tmemset(c, 0, sizeof(c));\n\t\trep(i, 10001)E[i].clear(), G[i].clear();\n\t\tint h = 0, w = 0;\n\t\trep(i, n) {\n\t\t\tint x1, y1, x2, y2; scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\th = max(h, x2 + 1); w = max(w, y2 + 1);\n\t\t\tE[x1].push_back(y1); E[x2].push_back(y2);\n\t\t\tG[x1].push_back(y2); G[x2].push_back(y1);\n\t\t}\n\t\tint a = 0, b = 0;\n\t\trep(i, h) {\n\t\t\trep(j, w)sum[i & 1][j] = c[i & 1][j] = c[!(i & 1)][j];\n\t\t\tfor (int j : E[i])sum[i & 1][j]++, c[i & 1][j]++;\n\t\t\tfor (int j : G[i])sum[i & 1][j]--, c[i & 1][j]--;\n\t\t\tfor (int j = 1; j < w; j++)sum[i & 1][j] += sum[i & 1][j - 1];\n\t\t\trep(j, w) {\n\t\t\t\tif (sum[i & 1][j])a++;\n\t\t\t\tif (i == h - 1 && sum[i & 1][j])b++;\n\t\t\t\telse if (sum[i & 1][j] != sum[!(i & 1)][j])b++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", a);\n\t\tif (r == 2)printf(\"%d\\n\", b);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint N, R;\n\t//vector<vector<int>>data;\n\tvector<pair<pair<int, int>, pair<int, int>>>input;\n\tmap<int, int>x_x, y_y;\n\tmap<int, map<int, int>>datax;\n\tvector<int>x_x_x, y_y_y;\n\twhile( cin >> N >> R, N || R ) {\n\t\tint xmax = 0, ymax = 0;\n\t\tset<int>xs, ys;\n\t\tinput.resize( N );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tint x1, x2, y1, y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tinput[i] = make_pair( make_pair( x1, y1 ), make_pair( x2, y2 ) );\n\t\t\txs.insert( x1 );\n\t\t\tys.insert( y1 );\n\t\t\txs.insert( x2 );\n\t\t\tys.insert( y2 );\n\t\t}\n\t\tx_x.clear();\n\t\ty_y.clear();\n\n\t\tx_x_x.clear();\n\t\ty_y_y.clear();\n\t\tfor( auto xx : xs ) {\n\t\t\tx_x[xx] = x_x_x.size();\n\t\t\tx_x_x.emplace_back( xx );\n\t\t}\n\t\tfor( auto yy : ys ) {\n\t\t\ty_y[yy] = y_y_y.size();\n\t\t\ty_y_y.emplace_back( yy );\n\t\t}\n\t\txmax = xs.size() + 1;\n\t\tymax = ys.size() + 1;\n\t\t//data = vector<vector<int>>( xmax + 1, vector<int>( ymax + 1 ) );\n\t\tdatax.clear();\n\t\tfor( size_t i = 0; i < input.size(); i++ ) {\n\t\t\tdatax[x_x[input[i].first.first]][y_y[input[i].first.second]]++;\n\t\t\tdatax[x_x[input[i].second.first]][y_y[input[i].second.second]]++;\n\t\t\tdatax[x_x[input[i].second.first]][y_y[input[i].first.second]]--;\n\t\t\tdatax[x_x[input[i].first.first]][y_y[input[i].second.second]]--;\n\t\t}\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tdatax[i + 1][j] += datax[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tdatax[i][j + 1] += datax[i][j];\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\t/*\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tcout << data[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\tif( datax[i][j] ) {\n\t\t\t\t\tans += (x_x_x[i + 1] - x_x_x[i])*(y_y_y[j + 1] - y_y_y[j]);\n\t\t\t\t\t//ans++;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << data[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tif( R == 2 ) {\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tif( datax[i][0] != 0 ) {\n\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < ymax; i++ ) {\n\t\t\t\tif( datax[0][i] != 0 ) {\n\t\t\t\t\tans += y_y_y[i + 1] - y_y_y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( size_t i = 0; i < xmax; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < ymax; j++ ) {\n\t\t\t\t\tif( datax[i][j] * datax[i][j + 1] == 0 && datax[i][j] != datax[i][j + 1] ) {\n\t\t\t\t\t\tans += x_x_x[i + 1] - x_x_x[i];\n\t\t\t\t\t}\n\t\t\t\t\tif( datax[i][j] * datax[i + 1][j] == 0 && datax[i][j] != datax[i + 1][j] ) {\n\t\t\t\t\t\tans += y_y_y[j + 1] - y_y_y[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<set>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n\n    vector<pair<P,P> > in;\n    vector<P> v[10001];\n    \n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n      \n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b, b=B, e=E, L+=2;\n      }\n      S+=e-b, L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B, e=E, L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n, t, ax[10000], ay[10000], bx[10000], by[10000], J[3][10007];\nint mx, my;\npair<int, int> solve(int row) {\n\tfor (int i = 0; i < 3; i++) { for (int j = 0; j < my + 4; j++)J[i][j] = 0; }\n\tfor (int i = 0; i < 3; i++) {\n\t\tint Plus = i - 1 + row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (ax[j] <= Plus && Plus < bx[j]) { J[i][ay[j]]++; J[i][by[j]]--; }\n\t\t}\n\t\tfor (int j = 1; j < my + 4; j++)J[i][j] += J[i][j - 1];\n\t\tfor (int j = 1; j < my + 4; j++) { if (J[i][j] >= 1)J[i][j] = 1; }\n\t}\n\tint sum1 = 0; for (int i = 0; i < my + 4; i++)sum1 += J[1][i];\n\tint sum2 = 0;\n\tfor (int i = 0; i < my + 4; i++) { if (i >= 1 && J[1][i] + J[1][i - 1] == 1) { sum2++; } if (i < my + 3 && J[1][i] + J[1][i + 1] == 1) { sum2++; } }\n\tfor (int i = 0; i < my + 4; i++) { if (J[0][i] + J[1][i] == 1)sum2++; if (J[1][i] + J[2][i] == 1)sum2++; }\n\treturn make_pair(sum1, sum2);\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> t; if (n == 0 && t == 0)break; my = 0; mx = 0;\n\t\tfor (int i = 0; i < n; i++) { cin >> ax[i] >> ay[i] >> bx[i] >> by[i]; ax[i]++; ay[i]++; bx[i]++; by[i]++; }\n\t\tfor (int i = 0; i < n; i++) { mx = max(mx, bx[i]); my = max(my, by[i]); }\n\t\tint s1 = 0, s2 = 0; for (int i = 0; i <= mx + 3; i++) { pair<int, int>F = solve(i); s1 += F.first; s2 += F.second; }\n\t\tif (t == 1)cout << s1 << endl;\n\t\tif (t == 2)cout << s1 << endl << s2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tstatic int n,t;\n\t\tstatic int imos[10010][10010];\n\t\t\n\t\trep(i,10010)rep(j,10010)imos[i][j] = 0;\n\t\t\n\t\tscanf(\"%d%d\",&n,&t);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&x2,&y1,&y2);\n\t\t\tx1 ++; y1 ++; x2 ++; y2 ++;\n\t\t\timos[x1][y1] ++;\n\t\t\timos[x2][y1] --;\n\t\t\timos[x1][y2] --;\n\t\t\timos[x2][y2] ++;\n\t\t}\n\t\t\n\t\trep1(i,10009)rep(j,10010)imos[i][j] += imos[i-1][j];\n\t\trep(i,10010)rep1(j,10009)imos[i][j] += imos[i][j-1];\n\t\t\n\t\tint S = 0,L = 0;\n\t\tif(t == 1){\n\t\t\trep(i,10010)rep(j,10010)if(imos[i][j])S ++;\n\t\t\tprintf(\"%d\\n\",S);\n\t\t}\n\t\telse {\n\t\t\trep(i,10010)rep(j,10010)if(imos[i][j])S ++;\n\t\t\trep1(i,10009)rep(j,10010)if(imos[i][j]*imos[i-1][j] < 0)L ++;\n\t\t\trep(i,10010)rep1(j,10009)if(imos[i][j]*imos[i][j-1] < 0)L ++;\n\t\t\tprintf(\"%d\\n%d\\n\",S,L);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    int x[10000][2],y[10000][2];\n    vector<int> vx(2),vy(2);\n    vx[0]=vy[0]=-1;\n    vx[1]=vy[1]=10001;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<2;j++){\n\tcin>>x[i][j]>>y[i][j];\n\tvx.push_back(x[i][j]);\n\tvy.push_back(y[i][j]);\n      }\n    }\n    sort(vx.begin(),vx.end());\n    vx.erase(unique(vx.begin(),vx.end()),vx.end());\n    sort(vy.begin(),vy.end());\n    vy.erase(unique(vy.begin(),vy.end()),vy.end());\n    vector<vector<bool> > v(vy.size()-1,vector<bool>(vx.size()-1));\n    for(int i=0;i<n;i++){\n      int jl=lower_bound(vy.begin(),vy.end(),y[i][1])-vy.begin();\n      for(int j=lower_bound(vy.begin(),vy.end(),y[i][0])-vy.begin();j<jl;j++){\n\tint kl=lower_bound(vx.begin(),vx.end(),x[i][1])-vx.begin();\n\tfor(int k=lower_bound(vx.begin(),vx.end(),x[i][0])-vx.begin();k<kl;k++){\n\t  v[j][k]=true;\n\t}\n      }\n    }\n    int a=0;\n    for(int i=0;i<v.size();i++){\n      for(int j=0;j<v[i].size();j++){\n\tif(v[i][j]){\n\t  a+=(vy[i+1]-vy[i])*(vx[j+1]-vx[j]);\n\t}\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j+1<v[i].size();j++){\n\t  if(v[i][j]^v[i][j+1]){\n\t    l+=vy[i+1]-vy[i];\n\t  }\n\t}\n      }\n      for(int i=0;i<v[0].size();i++){\n\tfor(int j=0;j+1<v.size();j++){\n\t  if(v[j][i]^v[j+1][i]){\n\t    l+=vx[i+1]-vx[i];\n\t  }\n\t}\n      }\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint dx[4]={0,1,-1,0};\nint dy[4]={1,0,0,-1};\nint coor[10003][10003];\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,r;\n\t\tcin >> n >> r;\n\t\tif(n==0&&r==0)break;\n\t\tmemset(coor,0,sizeof(coor));\n\t\tint minx=INF,miny=INF,maxx=-1,maxy=-1;\n\t\tint x1,y1,x2,y2;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tcoor[x1][y1]++;\n\t\t\tcoor[x2][y2]++;\n\t\t\tcoor[x1][y2]--;\n\t\t\tcoor[x2][y1]--;\n\t\t\tminx=min(x1,minx);\n\t\t\tmaxx=max(x2,maxx);\n\t\t\tminy=min(y1,miny);\n\t\t\tmaxy=max(y2,maxy);\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++)\n\t\t{\n\t\t\tfor(int j=miny;j<=maxy;j++)\n\t\t\t{\n\t\t\t\tif(j-1<0)continue;\n\t\t\t\tcoor[i][j]+=coor[i][j-1];\n\t\t\t}\n\t\t}\n\t\tfor(int j=miny;j<=maxy;j++)\n\t\t{\n\t\t\tfor(int i=minx;i<=maxx;i++)\n\t\t\t{\n\t\t\t\tif(i-1<0)continue;\n\t\t\t\tcoor[i][j]+=coor[i-1][j];\n\t\t\t}\n\t\t}\n\t\tint sq=0;\n\t\tint len=0;\n\t\tif(r==1)\n\t\t{\n\t\t\tfor(int i=minx;i<=maxx;i++)\n\t\t\t{\n\t\t\t\tfor(int j=miny;j<=maxy;j++)\n\t\t\t\t{\n\t\t\t\t\tif(coor[i][j])sq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << sq << endl;\n\t\t}\n\t\tif(r==2)\n\t\t{\n\t\t\tfor(int i=minx;i<=maxx;i++)\n\t\t\t{\n\t\t\t\tfor(int j=miny;j<=maxy;j++)\n\t\t\t\t{\n\t\t\t\t\tif(coor[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tsq++;\n\t\t\t\t\t\tint p=0;\n\t\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(i+dx[k]<0||j+dy[k]<0)p++;\n\t\t\t\t\t\t\telse if(!(coor[i+dx[k]][j+dy[k]]))p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen+=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << sq << ' ' << len << endl;\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tcout << coor[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n\t\tvvi in(n,vi(4));\n\t\trep(i,n)rep(j,4)cin>>in[i][j];\n\t\tvi x,y;\n\t\trep(i,n)rep(j,4)if(j%2)y.pb(in[i][j]);\n\t\t\t\t\t\telse x.pb(in[i][j]);\n\t\tsort(all(x));sort(all(y));\n\t\tx.erase(unique(all(x)),x.end());\n\t\ty.erase(unique(all(y)),y.end());\n\t\t \n\t\tvvi tmp=in;\n\t\trep(i,n)rep(j,4)if(j%2)tmp[i][j]=find(all(y),tmp[i][j])-y.begin();\n\t\t\t\t\t\telse tmp[i][j]=find(all(x),tmp[i][j])-x.begin();\n\n\t\tvvi field(x.size(),vi(y.size()));\n\t\trep(i,n){\n\t\t\tfield[tmp[i][0]][tmp[i][1]]++;\n\t\t\tfield[tmp[i][2]][tmp[i][1]]--;\n\t\t\tfield[tmp[i][0]][tmp[i][3]]--;\n\t\t\tfield[tmp[i][2]][tmp[i][3]]++;\n\t\t}\n\t\trep(i,x.size())loop(j,1,y.size())field[i][j]+=field[i][j-1];\n\t\trep(j,y.size())loop(i,1,x.size())field[i][j]+=field[i-1][j];\n\t \n\t\tll out=0;\n\t\trep(i,x.size())rep(j,y.size())if(field[i][j])\n\t\t\tout+=(ll)(x[i+1]-x[i])*(y[j+1]-y[j]);\n\t\tcout<<out<<endl;\n\t\t\n//\t\trep(i,x.size()){rep(j,y.size())cout<<field[i][j];cout<<endl;}\n\t\t\n\t\tout=0;\n\t\trep(i,x.size())rep(j,y.size())if(field[i][j])rep(k,4){\n\t\t\tint nx=i+dx[k];\n\t\t\tint ny=j+dy[k];\n\t\t\tif(nx<0||ny<0||nx>=x.size()||ny>=y.size()||!field[nx][ny])\n\t\t\t\tout+=(k%2?y[j+1]-y[j]:x[i+1]-x[i]);\n\t\t}\n\t\tif(m-1)cout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  int height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\n\n\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  rep(i,n){\n    xd[px++]=x1[i];\n    xd[px++]=x2[i];\n  }\n  sort(xd,xd+px);\n  px=unique(xd,xd+px)-xd;\n  rep(i,px)IN[i].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nusing namespace std;\nint x_size, y_size;\nint x_min, x_max;\nint y_min, y_max;\nint type;\nunordered_map<int, vector<tuple<int, int, int>>> sheets;\n\nvoid init() {\n  x_min = 0; y_min = 0; x_max = 0; y_max = 0;\n  x_size = 0; y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_smaller(x_min, x1);\n  assign_if_smaller(y_min, y1);\n  assign_if_larger(x_max, x2);\n  assign_if_larger(y_max, y2);\n  x_size = x_max + 1;\n  y_size = y_max + 1;\n\n  auto t = make_tuple(y1, x2, y2);\n  if (sheets.count(x1) == 0) {\n    sheets[x1] = {t};\n  } else {\n    sheets[x1].push_back(t);\n  }\n}\nvector<tuple<int, int, int>>& find_end_points(int x, int y) {\n  return sheets[x];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  loop(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  loop(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  loop(x_size, x_i) {\n    // update right_area_end_point\n    auto& points = find_end_points(x_i, 0);\n\n    // per point operation\n    for (auto&& point : points) {\n      int y_i = get<0>(point), x = get<1>(point), y = get<2>(point);\n\n      loop_from_to(y_i, y - 1, p_i) {\n        assign_if_larger(right_area_end_point[p_i], x);\n      }\n    }\n\n    loop(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\n\nstruct block{\n\tint x1,x2,y,f;\n};\n\nblock b[20001];\nint fie[10000][2];\n\nbool comp(const block &b1,const block &b2){\n\treturn b1.y<b2.y;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint y1,y2;\n\t\t\tscanf(\"%d%d%d%d\",&b[i*2].x1,&y1,&b[i*2].x2,&y2);\n\t\t\tb[i*2].x2--;\n\t\t\tb[i*2+1].x1=b[i*2].x1;\n\t\t\tb[i*2+1].x2=b[i*2].x2;\n\t\t\tb[i*2].y=y1;\n\t\t\tb[i*2+1].y=y2;\n\t\t\tb[i*2].f=1;\n\t\t\tb[i*2+1].f=-1;\n\t\t}\n\t\tsort(b,b+n*2,comp);\n\t\tint ny=0;\n\t\tint now=0,prev=1;\n\t\tint res=0,res2=0;\n\t\tfor(int i=0;i<n*2;i++){\n\t\t\tif(ny!=b[i].y){\n\t\t\t\tswap(now,prev);\n\t\t\t\tint cnt=0;\n\t\t\t\tint cnt2=0,bt=0,cnt3=0;\n\t\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\t\tif(fie[j][now]>0 && fie[j][prev]==0)cnt3++;\n\t\t\t\t\tif(fie[j][now]==0 && fie[j][prev]>0)cnt3++;\n\t\t\t\t\tfie[j][now]=fie[j][prev];\n\t\t\t\t\tif(fie[j][now]>0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(bt==0)cnt2++,bt=1;\n\t\t\t\t\t}else bt=0;\n\t\t\t\t}\n\t\t\t\tres+=cnt*(b[i].y-ny);\n\t\t\t\tres2+=cnt2*2*(b[i].y-ny)+cnt3;\n\t\t\t}\n\t\t\tny=b[i].y;\n\t\t\tfor(int j=b[i].x1;j<=b[i].x2;j++)fie[j][now]+=b[i].f;\n\t\t\t//printf(\"%d\\n\",res2);\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\tif(r==2){\n\t\t\tswap(now,prev);\n\t\t\tint cnt3=0;\n\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\tif(fie[j][now]>0 && fie[j][prev]==0)cnt3++;\n\t\t\t\tif(fie[j][now]==0 && fie[j][prev]>0)cnt3++;\n\t\t\t\tfie[j][now]=fie[j][prev];\n\t\t\t}\n\t\t\tres2+=cnt3;\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint sum[2][10001], c[2][10001];\nvector<int>E[10001], G[10001];\nint main() {\n\tint n, r;\n\twhile (scanf(\"%d%d\", &n, &r), n) {\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tmemset(c, 0, sizeof(c));\n\t\trep(i, 10001)E[i].clear(), G[i].clear();\n\t\tint h = 0, w = 0;\n\t\trep(i, n) {\n\t\t\tint x1, y1, x2, y2; scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\th = max(h, x2 + 1); w = max(w, y2 + 1);\n\t\t\tE[x1].push_back(y1); E[x2].push_back(y2);\n\t\t\tG[x1].push_back(y2); G[x2].push_back(y1);\n\t\t}\n\t\tint a = 0, b = 0;\n\t\trep(i, h) {\n\t\t\trep(j, w)sum[i & 1][j] = c[i & 1][j] = c[!(i & 1)][j];\n\t\t\tfor (int j : E[i])sum[i & 1][j]++, c[i & 1][j]++;\n\t\t\tfor (int j : G[i])sum[i & 1][j]--, c[i & 1][j]--;\n\t\t\tfor (int j = 1; j < w; j++)sum[i & 1][j] += sum[i & 1][j - 1];\n\t\t\trep(j, w) {\n\t\t\t\tif (sum[i & 1][j])a++;\n\t\t\t\tif (!sum[i & 1][j] != !sum[!(i & 1)][j])b++;\n\t\t\t\tif (j == 0 && sum[i & 1][j])b++;\n\t\t\t\tif (j && !sum[i & 1][j] != !sum[i & 1][j - 1])b++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", a);\n\t\tif (r == 2)printf(\"%d\\n\", b);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        int** map;\n        map=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            map[w] = new int[10001];\n        }\n        \n        int** imos;\n        imos=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            imos[w] = new int[10001];\n        }\n        \n        int max=0;\n       \n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n            if(x2>max)max=x2;\n            if(y2>max)max=y2;\n        }\n\n        int S=0;\n        int L=0;\n        for(int h=0;h<=10000;h++){\n            int state=0;\n           for(int w=0;w<=10000;w++){\n               int res=0;\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n\n        cout<<S<<endl;\n        if(r==2)cout<<L<<endl;\n        \n        map=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            delete map[w];\n        }\n        \n        for(int w=0;w<=10000;w++){\n            delete imos[w] ;\n        }\n        delete imos;\n        delete map;\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        //bool *map;\n        int** map;\n        map=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            map[w] = new int[10001];\n        }\n        \n        int** imos;\n        imos=new int*[10001];\n        for(int w=0;w<=10000;w++){\n            imos[w] = new int[10001];\n        }\n       \n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n        }\n        /*\n        for(int h=0;h<=10;h++){\n           for(int w=0;w<=10;w++){\n                //printf(\"%2d \",map[w][h]);\n           }\n           //cout<<endl;\n        }\n        //cout<<endl;\n        */\n        int S=0;\n        int L=0;\n        for(int h=0;h<=10;h++){\n            int state=0;\n           for(int w=0;w<=10;w++){\n               int res=0;\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n/*\n        for(int h=0;h<=10;h++){\n            for(int w=0;w<=10;w++){\n               printf(\"%2d \",imos[w][h]);\n           }\n           cout<<endl;\n        }\n        */\n        cout<<S<<endl;\n        if(r==2)cout<<L<<endl;\n        \n        /*\n        int S=0;\n        int L=0;\n        bool old=false;\n        for(int w=0;w<=10000;w++){\n            old=false;\n            for(int h=0;h<=10000;h++){\n                if(map[w][h]){S++;}\n                if(old!=map[w][h]){L++;}\n                old=map[w][h];\n            }\n            if(old==true){L++;}\n        }\n        for(int h=0;h<=10000;h++){\n            old=false;\n           for(int w=0;w<=10000;w++){\n                if(old!=map[w][h]){L++;}\n                old=map[w][h];\n            }\n            if(old==true){L++;}\n        }\n        \n        cout<<S<<endl;\n        if(r==2){\n            std::cout << L << std::endl;\n        }\n        */\n\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\n\nint mp[10003][10003];\nint line[3][10003];\n\nint main(){\n\tint n,r;\n\twhile(cin>>n>>r){\n\t\tif(n==0&&r==0)break;\n\t\tCLR(mp);\n\t\tint x[2],y[2];\n\t\tlong suml=0,sumd=0;\n\t\tint xmax=0,ymax=0;\n\t\tREP(i,n){\n\t\t\tcin>>x[0]>>y[0]>>x[1]>>y[1];//左下,右上\n\t\t\tx[0]++,y[0]++,x[1]++,y[1]++;\n\t\t\txmax=max(x[1],xmax);ymax=max(y[1],ymax);\n\t\t\tFOR(j,y[0],y[1]){\n\t\t\t\tmp[j][x[0]]++;//横方向に面積いもす法\n\t\t\t\tmp[j][x[1]]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong temp;\n\t\t\n\t\tFOR(i,1,ymax+1){\n\t\t\ttemp=0;\n\t\t\tline[0][0]=0;\n\t\t\tline[1][0]=0;\n\t\t\tline[2][0]=0;\n\t\t\tFOR(j,1,xmax+1){\n\t\t\t\tif(temp>0){\n\t\t\t\t\tsumd++;\n\t\t\t\t}\n\t\t\t\ttemp+=mp[i][j];\n\t\t\t\tline[0][j]=line[0][j-1]+mp[i-1][j];\n\t\t\t\tline[1][j]=line[1][j-1]+mp[i][j];\n\t\t\t\tline[2][j]=line[2][j-1]+mp[i+1][j];\n\t\t\t\tif(line[1][j-1]==0&&line[1][j]>0||line[1][j]==0&&line[1][j-1]>0){\n\t\t\t\t\tsuml++;\n\t\t\t\t}\n\t\t\t\tif(line[0][j]==0&&line[1][j]>0)suml++;\n\t\t\t\tif(line[2][j]==0&&line[1][j]>0)suml++;\n\t\t\t}\n\t\t}\n\t\tcout<<sumd<<endl;\n\t\tif(r==2)cout<<suml<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> >in;\n \nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r,n|r){\n    static vector<P>vx[10001],vy[10001];\n\n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<in.size();i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tvx[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n    \n\n      if(r==2){\n\tsort(in.begin(),in.end(),cmp_x);\n\n\tfor(int i=0;i<in.size();i++)\n\t  for(int j=in[i].S.F;j<in[i].S.S;j++)\n\t    vy[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      }\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(vx[i].size()==0)continue;\n      int b=vx[i][0].first,e=vx[i][0].second;\n\n      for(int j=1;j<vx[i].size();j++){\n\tint B=vx[i][j].first,E=vx[i][j].second;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n      \n      for(int i=0;i<10001;i++){\n\tif(vy[i].size()==0)continue;\n\tint b=vy[i][0].first,e=vy[i][0].second;\n\t\n\tfor(int j=1;j<vy[i].size();j++){\n\t  int B=vy[i][j].first,E=vy[i][j].second;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nconstexpr int MAX_Y = 10003;\nconstexpr int MAX_X = 10003;\n\nint main() {\n    int n, r;\n    while(cin >> n >> r, n) {\n        vector<vector<P>> v(MAX_Y);\n        for(int i=0; i<n; ++i) {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            ++x1; ++y1; ++x2; ++y2;\n            v[y1].emplace_back(x1, 1);\n            v[y1].emplace_back(x2, -1);\n            v[y2].emplace_back(x1, -1);\n            v[y2].emplace_back(x2, 1);\n        }\n        vector<vector<int>> sum(2, vector<int>(MAX_X));\n        int S = 0, len = 0;\n        for(int i=0; i<MAX_Y; ++i) {\n            int now = i % 2, pre = (i+1) % 2;\n            fill(sum[now].begin(), sum[now].end(), 0);\n            for(int j=0; j<v[i].size(); ++j) {\n                sum[now][v[i][j].first] += v[i][j].second;\n            }\n            for(int j=0; j<MAX_X; ++j) {\n                sum[now][j+1] += sum[now][j];\n                sum[now][j] += sum[pre][j];\n            }\n            for(int j=0; j<MAX_X; ++j) {\n                S += sum[now][j] > 0;\n                len += ((sum[pre][j] > 0) != (sum[now][j] > 0));\n                len += ((sum[now][j] > 0) != (sum[now][j+1] > 0));\n            }\n        }\n        \n        if(r == 1) {\n            cout << S << endl;\n        } else {\n            cout << S << '\\n' << len << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint d[2]={1,-1,};\nshort fie[5000][5000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10001);\n\tvy.push_back(0);\n\tvy.push_back(10001);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\t\tx1[i]++;\n\t\t\ty1[i]++;\n\t\t\tx2[i]++;\n\t\t\ty2[i]++;\n\t\t}\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[i][j]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2){\n\t\t\tfor(int i=1;i<vx.size();i++){\n\t\t\t\tfor(int j=1;j<vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\t\tif(fie[i+k][j+l]==0)f=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t\tint res2=0;\n\t\t\tfor(int i=1;i<=vx.size();i++){\n\t\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\t\tif(fie[i][j]>=1){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx=i+d[k];\n\t\t\t\t\t\t\tint ny=j+d[k];\n\t\t\t\t\t\t\tif(ny==0 || ny==vy.size())res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\telse if(fie[i][ny]==0)res2+=vx[i+1]-vx[i],cnt+=vx[i+1]-vx[i];\n\t\t\t\t\t\t\tif(nx==0 || nx==vx.size())res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t\telse if(fie[nx][j]==0)res2+=vy[j+1]-vy[j],cnt+=vy[j+1]-vy[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfie[i][j]=cnt;\n\t\t\t\t\t\tif(fie[i][j]==0)fie[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0;i<vx.size();i++){\n\t\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\t\tprintf(\"%2d \",fie[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\tprintf(\"%d\\n\",res2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include <bitset> \n#include<list>\nusing namespace std;\n\nint main(){\n    \n    int n,r;\n    \n    int** map;\n    map=new int*[10001];\n    for(int w=0;w<=10000;w++){\n        map[w] = new int[10001];\n    }\n        \n    int** imos;\n    imos=new int*[10001];\n    for(int w=0;w<=10000;w++){\n        imos[w] = new int[10001];\n    }\n    \n    while(1){\n        cin>>n>>r;\n        if(n==0&&r==0)break;\n\n        for(int h=0;h<=10000;h++){\n            for(int w=0;w<=10000;w++){\n                map[w][h]=0;\n                imos[w][h]=0;\n           }\n        }\n        \n        int max=0;\n       \n        \n        for(int i=0;i<n;i++){\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            \n            map[x1][y1]+=1;\n            map[x1][y2]-=1;\n            map[x2][y1]-=1;\n            map[x2][y2]+=1;\n            \n            if(x2>max)max=x2;\n            if(y2>max)max=y2;\n        }\n\n        int S=0;\n        int L=0;\n        for(int h=0;h<=10000;h++){\n            int state=0;\n           for(int w=0;w<=10000;w++){\n               int res=0;\n               state+=map[w][h];\n               res=state;\n               if(h!=0){\n                   res+=imos[w][h-1];\n               }\n               imos[w][h]=res;\n               if(imos[w][h]>0){\n                   S++;\n                   if(w==0)L+=2;\n                   else if(imos[w-1][h]==0)L+=2;\n                   if(h==0)L+=2;\n                   else if(imos[w][h-1]==0)L+=2;\n               }\n           }\n        }\n\n        cout<<S<<endl;\n        if(r==2)cout<<L<<endl;\n        \n\n    }\n    for(int w=0;w<=10000;w++){\n        delete map[w];\n    }\n    \n    for(int w=0;w<=10000;w++){\n        delete imos[w] ;\n    }\n    delete imos;\n    delete map;\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef vector<P>L;\ntypedef L::iterator I;\nint unite(L&l,I i,I j){\n\tint r=i->second>=j->first;\n\tif(r){\n\t\ti->second=max(i->second,j->second);\n\t\tl.erase(j);\n\t}\n\treturn r;\n}\nvoid add(L&l,P p){\n\tI i=lower_bound(l.begin(),l.end(),p);\n\ti=l.insert(i,p);\n\tI j;\n\tfor(;j=i,++j!=l.end()&&unite(l,i,j););\n\tfor(;i!=l.begin()&&(j=i,unite(l,--i,j)););\n}\nint main(){\n\tint n,r;\n\tfor(;cin>>n>>r,r;){\n\t\tL v[10000],h[10000];\n\t\tfor(;n--;){\n\t\t\tint x1,y1,x2,y2,x,y;\n\t\t\tcin>>x1>>y1>>x2>>y2;\n\t\t\t/*for(x=x1;x<x2;x++){\n\t\t\t\tadd(v[x],P(y1,y2));\n\t\t\t}*/\n\t\t\tfor(y=y1;y<y2;y++){\n\t\t\t\tadd(h[y],P(x1,x2));\n\t\t\t}\n\t\t}\n\t\tint s=0,c=0;\n\t\tfor(int y=0;y<10000;y++){\n\t\t\tfor(I i=h[y].begin();i!=h[y].end();++i)\n\t\t\t\ts+=i->second-i->first;\n\t\t\t//c+=h[y].size()+v[y].size();\n\t\t}\n\t\tcout<<s<<endl;\n\t\tif(r==2){\n\t\t\tcout<<c*2<<endl;\n\t\t}\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define L 10000\n\nint m[L+3][L+3];\n\nint main() {\n\tint N, kind;\n\twhile ( cin >> N >> kind, N || kind ) {\n\t\tfill(&m[0][0], &m[0][0]+(L+3)*(L+3), 0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n//\t\t\t++x2, ++y2;\n\t\t\t++m[y1+1][x1+1], --m[y2+1][x1+1];\n\t\t\t--m[y1+1][x2+1], ++m[y2+1][x2+1];\n\t\t}\n\t\tfor (int y = 1; y <= L+1; ++y) for (int x = 1; x <= L+1; ++x) {\n\t\t\tm[y+1][x] += m[y][x];\n\t\t}\n\t\tfor (int y = 1; y <= L+1; ++y) for (int x = 1; x <= L+1; ++x) {\n\t\t\tm[y][x+1] += m[y][x];\n\t\t}\n\n\t\tint S = 0;\n\t\tint l = 0;\n\t\tfor (int y = 1; y <= L+1; ++y) for (int x = 1; x <= L+1; ++x) {\n\t\t\tif (m[y][x]) {\n\t\t\t\tif (!m[y-1][x]) ++l;\n\t\t\t\tif (!m[y][x-1]) ++l;\n\t\t\t\tif (!m[y+1][x]) ++l;\n\t\t\t\tif (!m[y][x+1]) ++l;\n\t\t\t\t++S;\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t\tif (kind == 2) cout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nbool map[10003][10003]={};\nint main(){\n\n\n\nint H1,W1,H2,W2;\nint n,m;\nwhile(1){\nscanf(\"%d %d\",&n,&m);\nif(n==0&&m==0)break;\nfor(int iii=0;iii<n;iii++){\nscanf(\"%d %d %d %d\",&W1,&H1,&W2,&H2);\nfor(int i=H1+1;i<H2+1;i++)\nfor(int j=W1+1;j<W2+1;j++)\nmap[i][j]=1;\n}\n\nint c=0;\nfor(int i=1;i<10001;i++)\nfor(int j=1;j<10001;j++)\nif(map[i][j]==1)c++;\n\nint cc=0;\n\nfor(int i=1;i<10001;i++)\nfor(int j=1;j<10001;j++)\n{\nif(map[i][j]==1){\nif(map[i+1][j]==0)cc++;\nif(map[i-1][j]==0)cc++;\nif(map[i][j+1]==0)cc++;\nif(map[i][j-1]==0)cc++;\n\n\n}\n}\n\n\nprintf(\"%d\\n\",c);\nif(m==2)printf(\"%d\\n\",cc);\n\nfor(int i=1;i<10001;i++)\nfor(int j=1;j<10001;j++)\n\tmap[i][j]=0;\n\n}\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nvector<T> vec;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        scanf(\"%d %d\",&n,&r);\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        //vec.pb(T(P(INF,INF),INF));\n        //SORT(vec);\n        //int index=0;\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tg[x1][y1]+=1;\n\t\t\tg[x2][y1]-=1;\n\t\t\tg[x1][y2]-=1;\n\t\t\tg[x2][y2]+=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\t if(r==2){\n                    if(g[i-1][j]==0 && g[i][j]>0)ans2++;\n                    if(g[i][j]==0 && g[i-1][j]>0)ans2++;\n                    if(g[i][j-1]==0 && g[i][j]>0)ans2++;\n                    if(g[i][j]==0 && g[i][j-1]>0)ans2++;\n                }\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2)printf(\"%d\\n\",ans2);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\nstruct Event {\n  int type, x1, x2, y;\n  bool operator<(const Event& rhs) const { return y < rhs.y; }\n};\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int n, r;\n  while (cin >> n >> r, n | r) {\n    vector<Event> events;\n    int W = 0, H = 0;\n    for (int i = 0; i < n; ++i) {\n      int x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      ++x1; ++y1; ++x2; ++y2;\n      events.push_back({+1, x1, x2, y1});\n      events.push_back({-1, x1, x2, y2});\n      W = max(W, x2 + 1);\n      H = max(H, y2 + 1);\n    }\n    sort(ALL(events));\n\n    vector<vector<int>> field(2, vector<int>(W));\n    int area = 0, perimeter = 0;\n    for (int y = 1, k = 0; y < H; ++y) {\n      int curr = y % 2, prev = (y - 1) % 2;\n      field[curr] = field[prev];\n      for (; k < (int)events.size() && events[k].y == y; ++k) {\n        auto& e = events[k];\n        for (int x = e.x1; x < e.x2; ++x)\n          field[curr][x] += e.type;\n      }\n      for (int x = 1; x < W; ++x) {\n        int b = !!field[curr][x];\n        area += b;\n        perimeter += (!!field[curr][x-1] ^ b) + (!!field[prev][x] ^ b);\n      }\n    }\n\n    if (r == 1)\n      cout << area << endl;\n    else\n      cout << area << endl << perimeter << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool cmp_x( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.F < q.F;\n}\n\nbool cmp_y( const pair<P,P> &p , const pair<P,P> &q ){\n  return p.S < q.S;\n}\n\nvector<pair<P,P> > in;\n\nint main(void){\n\n  int n,r,x1,x2,y1,y2;\n  \n  while(cin >> n >> r){\n    if(n==0 && r==0)break;\n    vector<P> v[10001];\n \n    in.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      in.push_back(make_pair(make_pair(x1,x2), make_pair(y1,y2)));\n    }\n\n    sort(in.begin(),in.end(),cmp_y);\n\n    for(int i=0;i<n;i++)\n      for(int j=in[i].F.F;j<in[i].F.S;j++)\n\tv[j].push_back(make_pair(in[i].S.F,in[i].S.S));\n\n    int S=0,L=0;\n \n    for(int i=0;i<10001;i++){\n      if(v[i].size()==0)continue;\n\n      int b=v[i][0].F,e=v[i][0].S;\n\n      for(int j=1;j<v[i].size();j++){\n\tint B=v[i][j].F,E=v[i][j].S;\n\n\tif(e>=B)e=max(e,E);\n\telse S+=e-b,b=B,e=E,L+=2;\n      }\n      S+=e-b,L+=2;\n    }\n\n    cout << S << endl;\n\n\n    if(r==2){\n\n    for(int i=0;i<10001;i++)\n      v[i].clear();\n\n      sort(in.begin(),in.end(),cmp_x);\n      \n      for(int i=0;i<n;i++)\n\tfor(int j=in[i].S.F;j<in[i].S.S;j++)\n\t  v[j].push_back(make_pair(in[i].F.F,in[i].F.S));\n      \n      for(int i=0;i<10001;i++){\n\tif(v[i].size()==0)continue;\n\tint b=v[i][0].F,e=v[i][0].S;\n\t\n\tfor(int j=1;j<v[i].size();j++){\n\t  int B=v[i][j].F,E=v[i][j].S;\n\t  \n\t  if(e>=B)e=max(e,E);\n\t  else b=B,e=E,L+=2;\n\t}\n\tL+=2;\n      }\n      cout << L << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::for_each;\nusing std::count_if;\nusing std::accumulate;\nusing std::max_element;\n\nusing rect_t = struct _rect {int x1,y1,x2,y2;}; // type of rectangle\n\nint main() {\n\twhile (true) {\n\t\tint n; // number of rectangles\n\t\tint r; // type of problem\n\t\tcin >> n >> r;\n\t\tif (n == 0 && r == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector<rect_t> rects(n); // n rectangles\n\t\t// read coordinates\n\t\tfor_each(rects.begin(),rects.end(),[](rect_t &r){cin >> r.x1 >> r.y1 >> r.x2 >> r.y2;});\n\t\t// find max x2 and y2\n\t\tauto max_x2 = max_element(rects.begin(),rects.end(),[](rect_t r1,rect_t r2){return r1.x2 < r2.x2;});\n\t\tauto max_y2 = max_element(rects.begin(),rects.end(),[](rect_t r1,rect_t r2){return r1.y2 < r2.y2;});\n\t\t// create sheet\n\t\tvector< vector<bool> > sheet(max_x2->x2);\n\t\tfor_each(sheet.begin(),sheet.end(),[max_y2](vector<bool> &row){row = vector<bool>(max_y2->y2);});\n\t\t// fill rectangles\n\t\tfor (auto r : rects) {\n\t\t\tfor (int i = r.x1;i != r.x2;++i) {\n\t\t\t\tfor (int j = r.y1;j != r.y2;++j) {\n\t\t\t\t\tif (!sheet[i][j]) {\n\t\t\t\t\t\tsheet[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// count area\n\t\tint area = accumulate(sheet.begin(),sheet.end(),0,[](int a,vector<bool> r){\n\t\t\treturn a + count_if(r.begin(),r.end(),[](bool b){return b;});\n\t\t});\n\t\tcout << area << endl;\n\t\tif (r == 2) {\n\t\t\t// count surrounding length\n\t\t\tint sur_len = 0;\n\t\t\tfor (int i = 0;i != max_x2->x2;++i) {\n\t\t\t\tfor (int j = 0;j != max_y2->y2;++j) {\n\t\t\t\t\tif (sheet[i][j]) {\n\t\t\t\t\t\tif (i - 1 < 0 || !sheet[i-1][j]) {\n\t\t\t\t\t\t\t++sur_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i + 1 == max_x2->x2 || !sheet[i+1][j]) {\n\t\t\t\t\t\t\t++sur_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j - 1 < 0 || !sheet[i][j-1]) {\n\t\t\t\t\t\t\t++sur_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 == max_y2->y2 || !sheet[i][j+1]) {\n\t\t\t\t\t\t\t++sur_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << sur_len << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1000000000\n#define fi first\n#define sec second\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        cin >> n >> r;\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            cin >> a >> b >> c >> d;\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n            }\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n#define fir first\n#define sec second\n\nconst int N = 10010;\n\ntypedef pair<short,short> pii;\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<pii> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<pii> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,IN[j].size()){\n\tshort Y1 = y1[i],Y2=y2[i];\n\tshort &Y3=IN[j][k].fir;\n\tshort &Y4=IN[j][k].sec;\n\tif (Y4 <= Y1 || Y2 <= Y3)continue;\n\tisin=true;\n\tY3=min(Y1,Y3);\n\tY4=max(Y2,Y4);\n\tbreak;\n      }\n      if (!isin)IN[j].pb(mp(y1[i],y2[i]));\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<pii> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].fir,&nowh=in[i][j].sec;\n      if (nowl > h){\n\tlen+=2*width;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[2][10000];\npair<pair<int,int>,pair<int,int> >event[20000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\tint xm=0;\n\tint ym=0;\n\tfor(int i=0;i<a;i++){\n\t\tint p,q,r,s;\n\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tevent[i*2]=make_pair(make_pair(p,1),make_pair(q,s));\n\t\tevent[i*2+1]=make_pair(make_pair(r,-1),make_pair(q,s));\n\t\txm=max(xm,r);\n\t\tym=max(ym,s);\n\t}\n\tstd::sort(event,event+a*2);\n\t\n\tfor(int i=0;i<2;i++)\n\t\tfor(int j=0;j<ym;j++)\n\t\t\tdp[i][j]=0;\n\tint S=0;\n\tint D=0;\n\tint at=0;\n\tfor(int i=0;i<=xm;i++){\n\t\tint u=i&1;\n\t\tfor(int j=0;j<ym;j++)dp[u][j]=dp[!u][j];\n\t\tfor(;at<2*a&&event[at].first.first==i;at++){\n\t\t\tfor(int j=event[at].second.first;j<event[at].second.second;j++)dp[u][j]+=event[at].first.second;\n\t\t}\n\t\tfor(int j=0;j<ym;j++)if(dp[u][j])S++;\n\t\tfor(int j=0;j<ym;j++)if((dp[u][j]||dp[!u][j])&&!(dp[u][j]&&dp[!u][j]))D++;\n\t\tfor(int j=0;j<ym-1;j++)if((dp[u][j]||dp[u][j+1])&&!(dp[u][j]&&dp[u][j+1]))D++;\n\t\tif(dp[u][0])D++;\n\t\tif(dp[u][ym-1])D++;\n\t}\n\tprintf(\"%d\\n\",S);\n\tif(b==2)printf(\"%d\\n\",D);\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st & a)const{\n    if (beg != a.beg)return beg < a.beg;\n    return end < a.end;\n  }\n};\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      bool isin=false;\n      rep(k,IN[j].size()){\n\tshort Y1 = y1[i],Y2=y2[i];\n\tshort &Y3=IN[j][k].beg;\n\tshort &Y4=IN[j][k].end;\n\tif (Y4 <= Y1 || Y2 <= Y3)continue;\n\tisin=true;\n\tY3=min(Y1,Y3);\n\tY4=max(Y2,Y4);\n\tbreak;\n      }\n      if (!isin)IN[j].pb((st){y1[i],y2[i]});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      if (nowl > h){\n\tlen+=2*width;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}\n!"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <list>\n#include <vector>\n\nusing namespace std;\nint N, R;\nchar **cover;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\nint main(){\n  cover = new char*[10002];\n  for(int i=0; i<10002; ++i){\n    cover[i] = new char[10002];\n  }\n  for(int j=0; j<10002; ++j){\n    for(int i=0; i<10002; ++i){\n      cover[j][i] = 0;\n    }\n  }\n  while(cin >> N >> R && N){\n    int a,b,c,d;\n    for(int k=0; k<N; ++k){\n      cin >> a >> b >> c >> d;\n      for(int j=b+1; j<d+1; ++j){\n        for(int i=a+1; i<c+1; ++i){\n          \n          cover[j][i] = 1;\n        }\n      }\n    }\n    int area_c = 0;\n    int len = 0;\n    for(int j=1; j<10001; ++j){\n      for(int i=1; i<10001; ++i){\n            \n        if(cover[j][i] == 1){\n          area_c++;\n          for(int a = 0; a<4; ++a){\n            int nx = i+dx[a];\n            int ny = j+dy[a];\n            if(cover[ny][nx] == 0) len++;\n          }\n        }\n      }\n    }\n    cout << area_c << endl;\n    if(R==2) cout << len << endl;\n  }\n  \n  for(int i=0; i<10001; ++i){\n    delete[] cover[i];\n  }\n  delete[] cover;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  char out;//1 or -1\n  bool operator<(const st & a)const{\n    if (height != a.height)return height < a.height;\n    return out > a.out;\n  }\n};\n\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  rep(i,n){\n    xd[px++]=x1[i];\n    xd[px++]=x2[i];\n  }\n  sort(xd,xd+px);\n  px=unique(xd,xd+px)-xd;\n  rep(i,px)IN[i].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],-1});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      cnt+=in[i][j].out;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct Event {\n  int t;\n  int x1,x2,y;\n  bool operator<(const Event &b) const {\n    return y < b.y;\n  }\n} event[200000];\n\nint table[100005];\nbool flag[2][100005];\n\nint main() {\n  int n,r;\n  while(cin>>n>>r,n||r) {\n    int W = 0;\n    int H = 0;\n    REP(i,n) {\n      int x,y,p,q;\n      cin>>x>>y>>p>>q;\n      x++;y++;p++;q++;\n      W = max(W,p);\n      H = max(H,q);\n      event[i*2]   = (Event){+1,x,p,y};\n      event[i*2+1] = (Event){-1,x,p,q};\n    }\n    sort(event,event+2*n);\n    memset(table,0,sizeof(table));\n    int id = 0;\n    int a = 0;\n    int b = 0;\n    bool *cur = flag[0];\n    bool *pre = flag[1];\n    for (int y=1; y<=H+1; ++y) {\n      for (;id<2*n&&event[id].y==y;++id)\n        for (int x=event[id].x1; x<event[id].x2; ++x)\n          table[x] += event[id].t;\n      for (int i=1; i<=W; ++i) {\n        cur[i] = !!table[i];\n        a += cur[i];\n        if (cur[i-1] ^ cur[i]) b++;\n        if (pre[i] ^ cur[i]) b++;\n      }\n      swap(cur,pre);\n    }\n    cout << a << endl;\n    if (r == 2) cout << b << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nstruct Rect{\n\tint x1,x2,y1,y2;\n};\n\nclass Compare{\n\tpublic:\n\tbool operator()(const Rect &rect1,const Rect &rect2){\n\t\treturn rect1.x1<rect2.x1;\n\t}\n};\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(vector<vector<P> > &range,vector<Rect> &rects){\n\tint result=0;\n\tint index=0;\n\tREP(x,0,10010){\n\t\twhile(index<rects.size()&&rects[index].x1<=x){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x].begin(),range[x].end());\n\t\tint y=0;\n\t\tREP(i,0,range[x].size()){\n\t\t\tif(range[x][i].S_>y) result+=range[x][i].S_-max(y,range[x][i].F_);\n\t\t\ty=max(y,range[x][i].S_);\n\t\t}\n\t\trange[x].clear();\n\t}\n\treturn result;\n}\n\nint Count(vector<vector<P> > &range,vector<vector<bool> > &flag,int x){\n\tint index=0,y=0,result=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t}\n\t\t++index;\n\t}\n\treturn result;\n}\n\nint CalcLength(vector<vector<P> > &range,vector<Rect> &rects){\n\tint result=0,index=0;\n\tvector<vector<bool> > flag(3,vector<bool>(10010));\n\tREP(x,1,10009){\n\t\twhile(index<rects.size()&&rects[index].x1<=x+1){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x+1].begin(),range[x+1].end());\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,range[x+1].size()){\n\t\t\tif(range[x+1][i].S_>y) fill_n(flag[(x+1)%3].begin()+max(y,range[x+1][i].F_),range[x+1][i].S_-max(y,range[x+1][i].F_),true);\n\t\t\ty=max(range[x+1][i].S_,y);\n\t\t}\n\t\tresult+=Count(range,flag,x);\n\t\tif(x-2>=0) range[x-2].clear();\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tvector<vector<P> > range(10010);\n\t\tvector<Rect> rects(N);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\trects[i].x1=x1+4;\n\t\t\trects[i].y1=y1+4;\n\t\t\trects[i].x2=x2+4;\n\t\t\trects[i].y2=y2+4;\n\t\t}\n\t\tsort(rects.begin(),rects.end(),Compare());\n\t\tcout << CalcSize(range,rects) << endl;\n\t\tif(R==2) cout << CalcLength(range,rects) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint main()\n{\nint n,r;\nwhile(1)\n{\ncin >> n >> r;\nint m[10010][10010];\nmemset(m,0,sizeof(m));\nint j=0;\nfor(int i=0;i<n;i++)\n{\nint a,b,c,d;\ncin >> a >> b >> c>>d;\nm[i][j];\nj++;\n}\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short height;\n  bool out;//1 or -1\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (height != a.height)return height < a.height;\n  return out > a.out;\n}\n\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nvector<st> inx[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      IN[j].pb((st){y1[i],1});\n      IN[j].pb((st){y2[i],false});\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (in[i].size() == 0)continue;\n    sort(in[i].begin(),in[i].end());\n    int cnt=0,prev=-100;\n    int width;\n    width=c[i+1]-c[i];\n    rep(j,in[i].size()){\n      if (cnt > 0){\n\tarea+=(in[i][j].height-prev)*width;\n      }\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      if (in[i][j].out)cnt++;\n      else cnt--;\n      //if (cnt == 0 && in[i][j].height != prev){\n      if (cnt == 0){\n\tlen+=width;\n      }\n      prev=in[i][j].height;\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1000000000\n#define fi first\n#define sec second\nint a,b,c,d,n,r;\nint le,ri,up,down;\nint area,len;\nmap<P,int> m;\nmap<P,int>::iterator it;\nint imos[2][10004];\nint main()\n{\n    while(1)\n    {\n        memset(imos,0,sizeof(imos));\n        area=0;len=0;\n        le=down=INF;\n        ri=up=1;\n        m.clear();\n        cin >> n >> r;\n        if(n==0&&r==0)break;\n        for(int i=0;i<n;i++)\n        {\n            cin >> a >> b >> c >> d;\n            a++;b++;c++;d++;\n            ri=max(ri,c);\n            le=min(le,a);\n            up=max(up,d);\n            down=min(down,b);\n            m[P(a,b)]++;\n            m[P(a,d)]--;\n            m[P(c,b)]--;\n            m[P(c,d)]++;\n        }\n        for(int i=le;i<=ri+1;i++)\n        {\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]=imos[i%2][j-1];\n                it=m.find(P(i,j));\n                if(it!=m.end())imos[i%2][j]+=(*it).sec;\n            }\n            for(int j=down;j<=up+1;j++)\n            {\n                imos[i%2][j]+=imos[(i-1)%2][j];\n                if(imos[i%2][j]>0)area++;\n                if(!!imos[i%2][j-1]!=!!imos[i%2][j])len++;\n                if(!!imos[(i-1)%2][j]!=!!imos[i%2][j])len++;\n                cout << imos[i%2][j];\n            }\n            cout << endl;\n        }\n        cout << area << endl;\n        if(r==2)cout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint x1,y1,x2,y2;\n};\n\nint table[10005];\nInfo info[10000];\n\nint N,command;\nint min_x,min_y,max_x,max_y;\n\nint calc_S(){\n\n\tint ret = 0;\n\n\tfor(int x = min_x; x <= max_x; x++){\n\t\tfor(int y = min_y-1; y <= max_y+1; y++)table[y] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(info[i].x1 <= x && info[i].x2 > x){\n\t\t\t\ttable[info[i].y1]++;\n\t\t\t\ttable[info[i].y2]--;\n\t\t\t}\n\t\t}\n\n\t\tfor(int y = min_y; y <= max_y+1; y++){\n\t\t\ttable[y] += table[y-1];\n\t\t\tif(table[y] > 0)ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_L(){\n\n\tint ret = 0;\n\n\t//水平な線\n\tfor(int x = min_x; x <= max_x; x++){\n\t\tfor(int y = min_y-1; y <= max_y+1; y++)table[y] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(info[i].x1 <= x && info[i].x2 > x){\n\t\t\t\ttable[info[i].y1]++;\n\t\t\t\ttable[info[i].y2]--;\n\t\t\t}\n\t\t}\n\n\t\tfor(int y = min_y; y <= max_y+1; y++){\n\t\t\ttable[y] += table[y-1];\n\t\t\tif(table[y] > 0 && table[y-1] == 0)ret++;\n\t\t\tif(table[y] == 0 && table[y-1] > 0)ret++;\n\t\t}\n\t}\n\n\t//垂直な線\n\tfor(int y = min_y; y <= max_y; y++){\n\t\tfor(int x = min_x-1; x <= max_x+1; x++)table[x] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(info[i].y1 <= y && info[i].y2 > y){\n\t\t\t\ttable[info[i].x1]++;\n\t\t\t\ttable[info[i].x2]--;\n\t\t\t}\n\t\t}\n\n\t\tfor(int x = min_y; x <= max_x+1; x++){\n\t\t\ttable[x] += table[x-1];\n\t\t\tif(table[x] > 0 && table[x-1] == 0)ret++;\n\t\t\tif(table[x] == 0 && table[x-1] > 0)ret++;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid func(){\n\n\tmin_x = BIG_NUM;\n\tmin_y = BIG_NUM;\n\tmax_x = -BIG_NUM;\n\tmax_y = -BIG_NUM;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%d %d %d %d\",&info[i].x1,&info[i].y1,&info[i].x2,&info[i].y2);\n\t\tinfo[i].x1++;\n\t\tinfo[i].y1++;\n\t\tinfo[i].x2++;\n\t\tinfo[i].y2++;\n\n\t\tmin_x = min(min_x,min(info[i].x1,info[i].x2));\n\t\tmin_y = min(min_y,min(info[i].y1,info[i].y2));\n\n\t\tmax_x = max(max_x,max(info[i].x1,info[i].x2));\n\t\tmax_y = max(max_y,max(info[i].y1,info[i].y2));\n\t}\n\n\tprintf(\"%d\\n\",calc_S());\n\n\tif(command == 2){\n\t\tprintf(\"%d\\n\",calc_L());\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&command);\n\t\tif(N == 0 && command == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\nint a=0;\nwhile(1)a++;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\nconst int N = 10010;\n\nclass st{\npublic:\n  short beg,end;\n  bool operator<(const st &)const;\n};\n\nbool st::operator<(const st & a)const{\n  if (beg != a.beg)return beg < a.beg;\n  return end < a.end;\n}\n\nshort  isexist[N]={0};\nshort testcase=0;\nint x[N];\nst *inx[N];\n\nint req[N];\n\nvoid makedata(int n,int *x1,int *x2,int *y1,int *y2,\n\t      int &px,int *xd,vector<st> *IN){\n  testcase++;\n  rep(i,n){\n    isexist[x1[i]]=testcase;\n    isexist[x2[i]]=testcase;\n  }\n  rep(i,N)if (isexist[i]==testcase)x[px]=i,IN[px++].clear();\n  //cout <<\"allx \";rep(i,px)cout << x[i]<<\" \";cout << endl;\n\n  rep(i,px)req[i]=0;\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      //IN[j].pb((st){y1[i],y2[i]});\n      req[j]++;\n      j++;\n    }\n  }\n\n  rep(i,px)IN[i]=malloc(sizeof(st)*req[i]),req[i]=0;\n\n  rep(i,n){\n    int j=lower_bound(xd,xd+px,x1[i])-xd;\n    while(j < px && xd[j] < x2[i]){\n      //IN[j].pb((st){y1[i],y2[i]});\n      IN[j][req[j]++]=(st){y1[i],y2[i]};\n      j++;\n    }\n  }\n}\n\npair<int,int> solve(int n,vector<st> *in,int *c){\n  int area=0;\n  int len=0;\n  rep(i,n-1){\n    if (req[i] == 0)continue;\n    sort(in[i],in[i]+req[i]);\n    short l=-1,h=-1;\n    short width;\n    width=c[i+1]-c[i];\n    rep(j,req[i]){\n      short &nowl=in[i][j].beg,&nowh=in[i][j].end;\n      //cout << nowl <<\" \"<< nowh <<\" \" << l<<\" \" << h << endl;\n      if (nowl > h){\n\tlen+=2*width;\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowl == h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << nowl << endl;\n\tarea+=(nowh-nowl)*width;\n      }else if (nowh > h){\n\t//cout << c[i]<<\" \" << c[i]<<\" \" << nowh<<\" \" << h << endl;\n\tarea+=(nowh-h)*width;\n      }\n      l=nowl;\n      h=max(h,nowh);\n    }\n  }\n  return mp(area,len);\n}\n\nmain(){\n  int n,q;\n  static int x1[N],y1[N],x2[N],y2[N];\n  while(cin>>n>>q && n){\n    rep(i,n){\n      cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n    }\n    int px=0,py=0;\n    makedata(n,x1,x2,y1,y2,px,x,inx);\n    pair<int,int> ansx=solve(px,inx,x);\n\n    cout << ansx.first << endl;\n    if (q == 2){\n      px=0;\n      makedata(n,y1,y2,x1,x2,px,x,inx);\n      pair<int,int> ansy= solve(px,inx,x);      \n      cout << ansx.second+ansy.second << endl;\n    }\n    rep(i,px)inx[i].clear();\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nint fie[2000][2000];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << \"no\" << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 10000\nint mem[MAXN+5][MAXN+5]={{0}};\nint main(void){\n  int n=0;\n  int r=0;\n  const int muki[8]={0,1,0,-1,1,0,-1,0};\n  scanf(\"%d%d\",&n,&r);\n  while(n!=0){\n    memset(mem,0,sizeof(mem));\n    int i,a,b,c,d;\n    for(i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n      a++;b++;c++;d++;\n      mem[a][b]+=1;\n      mem[c][d]+=1;\n      mem[a][d]+=-1;\n      mem[c][b]+=-1;\n      }\n    int j=0;\n    for(i=0;i<MAXN+1;i++){\n      for(j=1;j<MAXN+1;j++){\n\tmem[i][j]+=mem[i][j-1];\n      }\n    }\n    for(j=0;j<MAXN+1;j++){\n      for(i=1;i<MAXN+1;i++){\n\tmem[i][j]+=mem[i-1][j];\n      }\n    }\n    int ansa=0;\n    int ansb=0;\n    for(i=1;i<MAXN+1;i++){\n      for(j=1;j<MAXN+1;j++){\n\tif(mem[i][j]>0){\n\t  ansa+=1;\n\t  //printf(\"%d%d\\n\",i,j);\n\t  for(a=0;a<4;a++){\n\t    b=i+muki[a];c=j+muki[a+4];\n\t    if(mem[b][c]==0){\n\t      ansb++;\n\t    }\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ansa);\n    if(r==2){printf(\"%d\\n\",ansb);}\n    scanf(\"%d%d\",&n,&r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint g[10005][10005];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tg[x1][y1]-=1;\n\t\t\tg[x2][y1]+=1;\n\t\t\tg[x1][y2]+=1;\n\t\t\tg[x2][y2]-=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxy;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=maxy;j>=miny;j--){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//39\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int n,r;cin>>n>>r,n|r;){\n    vector<pair<short,short> >v[10000];\n    for(int i=0;i<n;i++){\n      int x,y,xx,yy;\n      cin>>x>>y>>xx>>yy;\n      for(int j=y;j<yy;j++){\n\tv[j].push_back(make_pair(x,xx));\n      }\n    }\n    for(int i=0;i<10000;i++){\n      sort(v[i].begin(),v[i].end());\n      for(int j=0;j<v[i].size();j++){\n\tint m=v[i][j].second;\n\tint k;\n\tfor(k=j+1;k<v[i].size()&&v[i][k].first<=m;k++){\n\t  m=max<int>(m,v[i][k].second);\n\t}\n\tv[i][j].second=m;\n\tv[i].erase(v[i].begin()+j+1,v[i].begin()+k);\n      }\n    }\n    int a=0;\n    for(int i=0;i<10000;i++){\n      for(int j=0;j<v[i].size();j++){\n\ta+=v[i][j].second-v[i][j].first;\n      }\n    }\n    cout<<a<<endl;\n    if(r==2){\n      int l=0;\n      bool b[2][10000]={};\n      for(int i=0;i<10000;i++){\n\tl+=v[i].size()*2;\n\tfill(b[i&1],b[(i&1)+1],false);\n\tfor(int j=0;j<v[i].size();j++){\n\t  for(int k=v[i][j].first;k<v[i][j].second;k++){\n\t    b[i&1][k]=true;\n\t  }\n\t}\n\tfor(int j=0;j<10000;j++){\n\t  l+=b[i&1][j]^b[!(i&1)][j];\n\t}\n      }\n      l+=count(b[1],b[2],true);\n      cout<<l<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      // return (x + y) * (x + y + 1) / 2 + y;\n      hash<int> hasher;\n      return hasher(x) ^ hasher(y);\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\twhile(1){\n\t\tint n,r;\n\t\tcin >> n >> r;\n\t\tif(n==0){\n\t\t\treturn 0;\n\t\t}\n\t\tbool m[10002][10002];\n\t\tfor(int i=0;i<10002;i++){\n\t\t\tfor(int j=0;j<10002;j++){\n\t\t\t\tm[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tint s=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tfor(int x=x1+1;x<=x2;x++){\n\t\t\t\tfor(int y=y1+1;y<=y2;y++){\n\t\t\t\t\tif(!m[x][y]){\n\t\t\t\t\t\tm[x][y]=true;\n\t\t\t\t\t\ts++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << s << endl;\n\t\tif(r==2){\n\t\t\tint l=0;\n\t\t\tfor(int x=0;x<=10000;x++){\n\t\t\t\tfor(int y=0;y<=10000;y++){\n\t\t\t\t\tif(m[x][y] xor m[x+1][y]){\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[x][y] xor m[x][y+1]){\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << l << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n\tint MAX = 10005;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), r = sc.nextInt();\n\t\t\tif ((n|r) == 0) break;\n\t\t\tE[] G = new E[MAX];\n\t\t\tfor (int i = 0; i < MAX;i++) G[i] = new E();\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tint x1 = sc.nextInt()+1, y1 = sc.nextInt()+1, x2 = sc.nextInt()+1, y2 = sc.nextInt()+1;\n\t\t\t\tG[y1].add(new P(x1, x2, true));\n\t\t\t\tG[y2].add(new P(x1, x2, false));\n\t\t\t}\n\t\t\tint a = 0, l = 0, t = 1, minx = MAX, maxx = 0;\n\t\t\tint[][] area = new int[2][MAX];\n\t\t\tfor (E e: G) {\n\t\t\t\tfill(area[t], 0);\n\t\t\t\tfor (P p: e) {\n\t\t\t\t\tarea[t][p.x1] += p.c ? 1: -1; area[t][p.x2] += p.c ? -1 : 1;\n\t\t\t\t\tminx = min(minx, p.x1); maxx = max(maxx, p.x2);\n\t\t\t\t}\n\t\t\t\tfor (int i = minx; i <= maxx; i++) {\n\t\t\t\t\tarea[t][i] += area[t][i-1] + area[1-t][i] - area[1-t][i-1];\n\t\t\t\t\tif (area[t][i] > 0) a++;\n\t\t\t\t\tif (((area[t][i] | area[1-t][i]) != 0 ) && area[t][i] * area[1-t][i] == 0) l++;\n\t\t\t\t\tif (((area[t][i] | area[t][i-1]) != 0 ) && area[t][i] * area[t][i-1] == 0) l++;\n\t\t\t\t}\n//\t\t\t\tdebug(area[t]);\n\t\t\t\tt ^= 1;\n\t\t\t}\n\t\t\tSystem.out.println(a);\n\t\t\tif (r == 2) System.out.println(l);\n\t\t}\n\t}\n\t\n\tclass E extends ArrayList<P>{};\n\t\n\tclass P {\n\t\tint x1, x2; boolean c;\n\t\tP(int x1, int x2, boolean c) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.out.println(deepToString(os));\n\t}\n\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef vector<P>L;\ntypedef L::iterator I;\nint unite(L&l,I i,I j){\n\tint r=i->second>=j->first;\n\tif(r){\n\t\ti->second=max(i->second,j->second);\n\t\tl.erase(j);\n\t}\n\treturn r;\n}\nvoid add(L&l,P p){\n\tI i=lower_bound(l.begin(),l.end(),p);\n\ti=l.insert(i,p);\n\tI j;\n\tfor(;j=i,++j!=l.end()&&unite(l,i,j););\n\tfor(;i!=l.begin()&&(j=i,unite(l,--i,j)););\n}\nint main(){\n\tint n,r;\n\tfor(;cin>>n>>r,r;){\n\t\tL v[10000],h[10000];\n\t\tfor(;n--;){\n\t\t\tint x1,y1,x2,y2,x,y;\n\t\t\tcin>>x1>>y1>>x2>>y2;\n\t\t\tfor(x=x1;x<x2;x++){\n\t\t\t\tadd(v[x],P(y1,y2));\n\t\t\t}\n\t\t\tfor(y=y1;y<y2;y++){\n\t\t\t\tadd(h[y],P(x1,x2));\n\t\t\t}\n\t\t}\n\t\tint s=0,c=0;\n\t\tfor(int y=0;y<10000;y++){\n\t\t\tfor(I i=h[y].begin();i!=h[y].end();++i)\n\t\t\t\ts+=i->second-i->first;\n\t\t\tc+=h[y].size()+v[y].size();\n\t\t}\n\t\tcout<<s<<endl;\n\t\tif(r==2){\n\t\t\tcout<<c*2<<endl;\n\t\t}\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor(const auto &v : vec){\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef long long int lli;\ntypedef pair<short,short> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nstruct Rect{\n\tshort x1,x2,y1,y2;\n};\n\nclass Compare{\n\tpublic:\n\tbool operator()(const Rect &rect1,const Rect &rect2){\n\t\treturn rect1.x1<rect2.x1;\n\t}\n};\n\ninline short max(short a,short b){\n\tif(a>b) return a;\n\telse return b;\n}\n\t\nint CalcSize(array<vector<P>,10010> &range,vector<Rect> &rects){\n\tint result=0;\n\tint index=0;\n\tREP(x,0,10010){\n\t\twhile(index<rects.size()&&rects[index].x1<=x){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x].begin(),range[x].end());\n\t\tint y=0;\n\t\tREP(i,0,range[x].size()){\n\t\t\tif(range[x][i].S_>y) result+=range[x][i].S_-max(y,range[x][i].F_);\n\t\t\ty=max(y,range[x][i].S_);\n\t\t}\n\t\tvector<P>().swap(range[x]);\n\t}\n\treturn result;\n}\n\nint Count(array<vector<P>,10010> &range,array<array<bool,10010>,3> &flag,int x){\n\tint index=0,y=0,result=0;\n\twhile(index<range[x].size()){\n\t\tfor(y=max(y,range[x][index].F_); y<range[x][index].S_; ++y){\n\t\t\tif(!flag[(x-1)%3][y]) ++result;\n\t\t\tif(!flag[(x+1)%3][y]) ++result;\n\t\t\tif(!flag[x%3][y-1]) ++result;\n\t\t\tif(!flag[x%3][y+1]) ++result;\n\t\t}\n\t\t++index;\n\t}\n\treturn result;\n}\n\nint CalcLength(array<vector<P>,10010> &range,vector<Rect> &rects){\n\tint result=0,index=0;\n\t//array<array<bool> > flag(3,array<bool>(10010));\n\tarray<array<bool,10010>,3> flag;\n\tREP(x,1,10009){\n\t\twhile(index<rects.size()&&rects[index].x1<=x+1){\n\t\t\tREP(i,rects[index].x1,rects[index].x2) range[i].push_back(MP(rects[index].y1,rects[index].y2));\n\t\t\t++index;\n\t\t}\n\t\tsort(range[x+1].begin(),range[x+1].end());\n\t\tif(x-2>=0) fill(flag[(x-2)%3].begin(),flag[(x-2)%3].end(),false);\n\t\tint y=0;\n\t\tREP(i,0,range[x+1].size()){\n\t\t\tif(range[x+1][i].S_>y) fill_n(flag[(x+1)%3].begin()+max(y,range[x+1][i].F_),range[x+1][i].S_-max(y,range[x+1][i].F_),true);\n\t\t\ty=max(range[x+1][i].S_,y);\n\t\t}\n\t\tresult+=Count(range,flag,x);\n\t\tif(x-2>=0) vector<P>().swap(range[x-2]);\n\t}\n\treturn result;\n}\n\nint main(){\n\t//std::ios::sync_with_stdio(false);\n\t//std::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&!(N==0&&R==0)){\n\t\tarray<vector<P>,10010> range;\n\t\tvector<Rect> rects(N);\n\t\tREP(i,0,N){\n\t\t\tint x1,y1,x2,y2;\n\t\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\trects[i].x1=x1+4;\n\t\t\trects[i].y1=y1+4;\n\t\t\trects[i].x2=x2+4;\n\t\t\trects[i].y2=y2+4;\n\t\t}\n\t\tsort(rects.begin(),rects.end(),Compare());\n\t\tcout << CalcSize(range,rects) << endl;\n\t\t//if(R==2) cout << CalcLength(range,rects) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n    int n, r;\n    while (cin >> n >> r, n != 0 && r != 0) {\n        int board[10000] = {0};\n        int x1, y1, x2, y2;\n        int square = 0;\n        int l = 0;\n        for (int i = 0; i < n; ++i) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            if (r == 1) {\n                for (int y = y1; y < y2; ++y) {\n                    int bits = board[y] >> x1 & ((1 << (x2-x1)) - 1);\n                    int num = x2 - x1;\n                    while (bits != 0) {\n                        num--;\n                        bits &= bits - 1;\n                    }\n                    square += num;\n                    board[y] |= (1 << x2) - (1 << x1);\n                }\n            }\n            else {\n                for (int x = x1; x < x2; ++x) {\n                    for (int y = y1; y < y2; ++y) {\n                        if ((board[y] >> x & 1) == 0) {\n                            square++;\n                            l += 4;\n                            if (x - 1 >= 0 && (board[y] >> (x - 1) & 1) == 1) l-=2;\n                            if (y - 1 >= 0 && (board[y-1] >> x & 1) == 1) l-=2;\n                            if (x + 1 <= 10000 && (board[y] >> (x + 1) & 1) == 1) l-=2;\n                            if (y + 1 <= 10000 && (board[y+1] >> x & 1) == 1) l-=2;\n                        }\n                        board[y] |= 1 << x;\n                    }\n                }\n            }\n        }\n        cout << square << endl;\n        if (r == 2) cout << l << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef vector<int> PP;\ntypedef vector<PP> P;\nint n,r;\nint x1[10001],x2[10001],y1[10001],y2[10001];\nshort fie[3900][3900];\nvector<int> vx;\nvector<int> vy;\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvx.push_back(x1[i]+j);\n\t\t\tvx.push_back(x2[i]+j);\n\t\t\tvy.push_back(y1[i]+j);\n\t\t\tvy.push_back(y2[i]+j);\n\t\t}\n\t}\n\tvx.push_back(0);\n\tvx.push_back(10000);\n\tvy.push_back(0);\n\tvy.push_back(10000);\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tfor(int i=0;i<n;i++){\n\t\tx1[i]=find(vx.begin(),vx.end(),x1[i])-vx.begin();\n\t\tx2[i]=find(vx.begin(),vx.end(),x2[i])-vx.begin();\n\t\ty1[i]=find(vy.begin(),vy.end(),y1[i])-vy.begin();\n\t\ty2[i]=find(vy.begin(),vy.end(),y2[i])-vy.begin();\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\tzatu();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfie[x1[i]][y1[i]]++;\n\t\t\tfie[x1[i]][y2[i]]--;\n\t\t\tfie[x2[i]][y1[i]]--;\n\t\t\tfie[x2[i]][y2[i]]++;\n\t\t}\n\t\tfor(int i=0;i<=vy.size();i++){\n\t\t\tfor(int j=1;j<=vx.size();j++){\n\t\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=vx.size();i++){\n\t\t\tfor(int j=1;j<=vy.size();j++){\n\t\t\t\tfie[j][i]+=fie[j][i-1];\n\t\t\t}\n\t\t}\n\t\tlong long res=0;\n\t\tfor(int i=0;i<vx.size();i++){\n\t\t\tfor(int j=0;j<vy.size();j++){\n\t\t\t\tif(fie[j][i]>0)res+=(long long)(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t\tif(r==2)cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X1[10010], X2[10010], Y1[10010], Y2[10010];\nint n, r, p[3][10010];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> r; if (n == 0 && r == 0)break;\n\t\tint maxx = 0, maxy = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\t\t\tif (X2[i] > maxx)maxx = X2[i];\n\t\t\tif (Y2[i] > maxy)maxy = Y2[i];\n\t\t}\n\t\tint cnt1 = 0, cnt2 = 0, J = maxy + 10;\n\t\tfor (int i = 0; i < maxx + 10; i++) {\n\t\t\tfor (int j = 0; j < J * 3; j++)p[j / J][j % J] = 0;\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tint G = i + j, H = j + 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (X1[k] <= G && G < X2[k]) {\n\t\t\t\t\t\tp[H][Y1[k]]++; p[H][Y2[k]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 1; k < J; k++)p[j][k] += p[j][k - 1];\n\t\t\t}\n\t\t\tfor (int j = 0; j < J; j++) {\n\t\t\t\tif (p[1][j] >= 1)cnt1++;\n\t\t\t\tif (i == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\tif (p[0][j] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\tif (p[1][j] == 0 && p[2][j] >= 1)cnt2++;\n\t\t\t\tif (p[1][j] >= 1 && p[2][j] == 0)cnt2++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < J; j++) {\n\t\t\t\tif (j == 0 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j == 10009 && p[1][j] >= 1)cnt2 += 2;\n\t\t\t\tif (j >= 1 && j <= 10008) {\n\t\t\t\t\tif (p[1][j] >= 1 && p[1][j + 1] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j] == 0 && p[1][j + 1] >= 1)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] >= 1 && p[1][j] == 0)cnt2++;\n\t\t\t\t\tif (p[1][j - 1] == 0 && p[1][j] >= 1)cnt2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 1)cout << cnt1 << endl;\n\t\tif (r == 2)cout << cnt1 << endl << cnt2 / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n \n#define repeat_with_index(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i=0;__i<n;__i++)\n#define repete_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) repeat_with_index(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\n\nnamespace std {\n  template <>\n  struct hash<pair<int, int>>\n  {\n    size_t operator() (pair<int, int> const &key) const\n    {\n      int x = key.first, y = key.second;\n      return (x + y) * (x + y + 1) / 2 + y;\n    }\n  };\n}\n\nusing namespace std;\nint x_size, y_size;\nint type;\nunordered_map<pair<int, int>, vector<pair<int, int>>> sheets;\n\nvoid init() {\n  x_size = 0;\n  y_size = 0;\n}\n\nvoid add_sheet(int x1, int y1, int x2, int y2) {\n  assign_if_larger(x_size, x2 - x1 + 1);\n  assign_if_larger(y_size, y2 - y1 + 1);\n\n  pair<int, int> p = {x1, y1};\n\n  int c = sheets.count({x1, y1});\n  if (sheets.count({x1, y1}) == 0) {\n    sheets[p] = {{x2, y2}};\n  } else {\n    sheets[p].push_back({x2, y2});\n  }\n}\n\nvector<pair<int, int>>& find_end_points(int x, int y) {\n  pair<int, int> p = {x, y};\n  return sheets[p];\n}\n\nvoid calc_and_output() {\n  long area = 0;\n  long lines = 0;\n\n  int right_area_end_point[y_size];\n  repeat_with_index(y_size, i) right_area_end_point[i] = -1;\n\n  bool* is_area[2];\n  is_area[0] = new bool[y_size];\n  is_area[1] = new bool[y_size];\n  repeat_with_index(y_size, i) {\n    is_area[0][i] = false;\n    is_area[1][i] = false;\n  }\n\n  repeat_with_index(x_size, x_i) {\n    repeat_with_index(y_size, y_i) {\n      // update right_area_end_point\n      auto points = find_end_points(x_i, y_i);\n\n      // per point operation\n      for (auto&& point : points) {\n        int x = point.first, y = point.second;\n\n        repete_from_to(y_i, y - 1, p_i) {\n          assign_if_larger(right_area_end_point[p_i], x);\n        }\n      }\n    }\n\n    repeat_with_index(y_size, y_i) {\n\n      // included in some sheets\n      if (right_area_end_point[y_i] > x_i) {\n        area += 1;\n        is_area[x_i % 2][y_i] = true;\n      } else {\n        is_area[x_i % 2][y_i] = false;\n      }\n\n      // line check\n      if (type == 2) {\n        // left line exists\n        if (is_area[(x_i % 2) ^ 1][y_i] != is_area[x_i % 2][y_i]) lines += 1;\n\n        // bottom line exists\n        if (\n            (y_i == 0 && is_area[x_i % 2][y_i]) ||\n            (y_i > 0 && (is_area[x_i % 2][y_i - 1] != is_area[x_i % 2][y_i]))\n            )\n          lines += 1;\n      }\n    }\n\n  }\n\n  cout << area << endl;\n  if (type == 2) cout << lines << endl;\n\n  delete is_area[0];\n  delete is_area[1];\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n; cin >> n >> type;\n    if (n == 0 && type == 0) break;\n\n    init();\n\n    repeat(n) {\n      int p[4];\n      multi_cin(4, p);\n      add_sheet(p[0], p[1], p[2], p[3]);\n    }\n\n    calc_and_output();\n    sheets.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\n//const long long int INF_=1<<58;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ninline void Imos(vector<vector<short> > &plane){\n\tREP(y,0,plane[0].size()){\n\t\tREP(x,1,plane.size()){\n\t\t\tplane[x][y]+=plane[x-1][y];\n\t\t}\n\t}\n\tREP(x,0,plane.size()){\n\t\tfor(int y=plane[0].size()-2; y>=0; --y){\n\t\t\tplane[x][y]+=plane[x][y+1];\n\t\t}\n\t}\n}\n\ninline int CalcSize(vector<vector<short> > &plane){\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(plane[x][y]>0) ++result;\n\t\t}\n\t}\n\treturn result;\n}\n\ninline int BFS(vector<vector<short> > &plane,vector<vector<bool> > &has_done,int x,int y,int W,int H){\n\tint result=0;\n\tqueue<P> que;\n\tque.push(MP(x,y));\n\thas_done[x][y]=true;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tREP(i,0,4){\n\t\t\tint nx=p.F_+dx[i],ny=p.S_+dy[i];\t\n\t\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&!has_done[nx][ny]){\n\t\t\t\tif(plane[nx][ny]>0){\n\t\t\t\t\tque.push(MP(nx,ny));\n\t\t\t\t\thas_done[nx][ny]=true;\n\t\t\t\t}else ++result;\n\t\t\t}\n\t\t}\n\t\t//cout << result << ' ' << p.F_ << ' ' << p.S_ << endl;\n\t}\n\treturn result;\n}\n\ninline int CalcLength(vector<vector<short> > &plane){\n\tvector<vector<bool> > has_done(plane.size(),vector<bool>(plane[0].size()));\n\tint result=0;\n\tREP(x,0,plane.size()){\n\t\tREP(y,0,plane[0].size()){\n\t\t\tif(!has_done[x][y]&&plane[x][y]>0){\n\t\t\t\tresult+=BFS(plane,has_done,x,y,plane.size(),plane[0].size());\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N,R;\n\twhile(cin >> N >> R&&N&&R){\n\t\tint min_x,min_y,max_x,max_y;\n\t\tmin_x=min_y=INF;\n\t\tmax_x=max_y=0;\n\t\tvector<int> X[2],Y[2];\n\t\tREP(i,0,N){\n\t\t\tREP(j,0,2){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif(j==0){\n\t\t\t\t\t++x;\n\t\t\t\t\t++y;\n\t\t\t\t}\n\t\t\t\tX[j].push_back(x);\n\t\t\t\tY[j].push_back(y);\n\t\t\t\tmin_x=min(min_x,x);\n\t\t\t\tmin_y=min(min_y,y);\n\t\t\t\tmax_x=max(max_x,x);\n\t\t\t\tmax_y=max(max_y,y);\n\t\t\t}\n\t\t}\n\t\tvector<vector<short> > plane(max_x+4,vector<short>(max_y+4));\n\t\tREP(i,0,N){\n\t\t\tplane[X[0][i]+1][Y[1][i]+1]+=1;\n\t\t\tplane[X[1][i]+2][Y[0][i]]+=1;\n\t\t\tplane[X[0][i]+1][Y[0][i]]+=-1;\n\t\t\tplane[X[1][i]+2][Y[1][i]+1]+=-1;\n\t\t}\n\t\tImos(plane);\n\t\t/*\n\t\tfor(int y=plane[0].size()-1; y>=0; --y){\n\t\t\tREP(x,0,plane.size()){\n\t\t\t\tcout << plane[x][y] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << CalcSize(plane) << endl;\n\t\tif(R==2) cout << CalcLength(plane) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define INF 2000000000\n#define LLINF 4000000000000000000\n#define SIZE 10002\n\nint mm[2][SIZE];\nint mo[5] = {0,-1,0,1};\n\nvoid calc(int n,int r){\n    int x_1,x_2,y_1,y_2,minx=SIZE-1,maxx=0,miny=SIZE-1,maxy=0;\n    int ansV=0,ansL=0;\n    vector<int> x_p[SIZE],x_m[SIZE];\n    \n    memset(mm,0,sizeof(mm));\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d%d\",&x_1,&y_1,&x_2,&y_2);\n        \n        x_1++;\n        y_1++;\n        x_2++;\n        y_2++;\n        \n        x_p[x_1].push_back(y_1);\n        x_m[x_1].push_back(y_2);\n        x_m[x_2].push_back(y_1);\n        x_p[x_2].push_back(y_2);\n        \n        minx = min(minx,x_1);\n        miny = min(miny,y_1);\n        maxx = max(maxx,x_2);\n        maxy = max(maxy,y_2);\n    }\n    \n    for(int i=minx;i<maxx;i++){\n        \n        for(int j=miny;j<=maxy;j++){\n            mm[0][j]=mm[1][j];\n        }\n        \n        \n        memset(mm[1],0,sizeof(mm[1]));\n        \n        \n        for(int j=0;j<x_p[i].size();j++){\n            mm[1][x_p[i][j]]++;\n        }\n        for(int j=0;j<x_m[i].size();j++){\n            mm[1][x_m[i][j]]--;\n        }\n        \n        for(int j=miny+1;j<=maxy;j++){\n            mm[1][j]+=mm[1][j-1];\n        }\n        \n        for(int j=miny;j<=maxy;j++){\n            mm[1][j]+=mm[0][j];\n        }\n        \n        for(int j=miny;j<=maxy;j++){\n            if(mm[1][j]>0){\n                ansV++;\n                \n                for(int k=0;k<3;k++){\n                    if(mm[1+mo[k]][j+mo[k+1]]==0){\n                        ansL++;\n                    }\n                }\n            }else{\n                if(mm[0][j]>0){\n                    ansL++;\n                }\n                \n            }\n        }\n        \n    }\n    \n    for(int j=minx;j<=maxx;j++){\n        if(mm[1][j]==1)\n            ansL++;\n    }\n    \n    printf(\"%d\\n\",ansV);\n    \n    if(r==2)\n        printf(\"%d\\n\",ansL);\n    \n    return;\n}\n\nint main(){\n    int n,r;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&r);\n        if(n==0) break;\n        calc(n,r);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM,when)\nimport Data.List (sort,group)\n\ntype Rect = (Int,Int,Int,Int) -- (x0,y0,x1,y1)\ntype X = Int\ntype Y = Int\n\nmain = do\n    [n,r] <- getLine >>= (return . map read . words)\n    if all (==0) [n,r] then return () else do\n        rs <- replicateM n (getLine >>= return . rect . map read . words)\n        print $ area rs\n        when (r == 2) (print $ perimeter rs)\n        main\n\n    where\n    rect [x0,y0,x1,y1] = (x0,y0,x1,y1)\n\narea :: [Rect] -> Int\narea rs = area' $ rectYs rs\n    where\n    area' (_:[])     = 0\n    area' (y0:y1:ys) = (y1-y0) * (sumSpans $ mergeSpans $ xspans rs y0)\n                       + area' (y1:ys)\n\nperimeter :: [Rect] -> Int\nperimeter rs = (perimeterX $ rectXs rs) + (perimeterY $ rectYs rs)\n    where\n    perimeterX (_:[])     = 0\n    perimeterX (x0:x1:xs) = (x1-x0) * 2 * (length $ mergeSpans $ yspans rs x0)\n                            + perimeterX (x1:xs)\n\n    perimeterY (_:[])     = 0\n    perimeterY (y0:y1:ys) = (y1-y0) * 2 * (length $ mergeSpans $ xspans rs y0)\n                            + perimeterY (y1:ys)\n\nrectXs :: [Rect] -> [X]\nrectXs rs = map head $ group $ sort $ concatMap rectX rs\n    where\n    rectX (x0,_,x1,_) = [x0,x1]\n\nrectYs :: [Rect] -> [Y]\nrectYs rs = map head $ group $ sort $ concatMap rectY rs\n    where\n    rectY (_,y0,_,y1) = [y0,y1]\n    \nxspans :: [Rect] -> Y -> [(X,X)]\nxspans rs y = sort $ map xspan $ filter cross rs\n    where\n    xspan (x0,_,x1,_) = (x0,x1)\n    cross (_,y0,_,y1) = y >= y0 && y < y1\n\nyspans :: [Rect] -> X -> [(Y,Y)]\nyspans rs x = sort $ map yspan $ filter cross rs\n    where\n    yspan (_,y0,_,y1) = (y0,y1)\n    cross (x0,_,x1,_) = x >= x0 && x < x1\n\nsumSpans :: [(Int,Int)] -> Int\nsumSpans [] = 0\nsumSpans ((a,b):ss) = b - a + sumSpans ss\n\nmergeSpans :: [(Int,Int)] -> [(Int,Int)]\nmergeSpans [] = []\nmergeSpans (s:[]) = [s]\nmergeSpans ((a,b):(c,d):ss)\n    | b >= c    = mergeSpans ((a,max b d):ss)\n    | otherwise = (a,b) : mergeSpans ((c,d):ss)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM,when)\nimport Data.List (sort,sortBy,group)\nimport Data.Ord (comparing)\n\ntype Rect = (Int,Int,Int,Int) -- (x0,y0,x1,y1)\ntype X = Int\ntype Y = Int\n\nmain = do\n    [n,r] <- getLine >>= (return . map read . words)\n    if all (==0) [n,r] then return () else do\n        rs <- replicateM n (getLine >>= return . rect . map read . words)\n        print $ area rs\n        when (r == 2) (print $ perimeter rs)\n        main\n\n    where\n    rect [x0,y0,x1,y1] = (x0,y0,x1,y1)\n\narea :: [Rect] -> Int\narea rs = area' $ rectYs rs\n    where\n    area' (_:[])     = 0\n    area' (y0:y1:ys) = rsx0 `seq`\n                       (y1-y0) * (sumSpans $ mergeSpans $ xspans rsx0 y0)\n                       + area' (y1:ys)\n\n    rsx0 = sortBy (comparing (\\(x0,_,_,_)->x0)) rs\n\nperimeter :: [Rect] -> Int\nperimeter rs = (perimeterX $ rectXs rs) + (perimeterY $ rectYs rs)\n    where\n    perimeterX (_:[])     = 0\n    perimeterX (x0:x1:xs) = rsy0 `seq`\n                            (x1-x0) * 2 * (length $ mergeSpans $ yspans rsy0 x0)\n                            + perimeterX (x1:xs)\n\n    perimeterY (_:[])     = 0\n    perimeterY (y0:y1:ys) = rsx0 `seq`\n                            (y1-y0) * 2 * (length $ mergeSpans $ xspans rsx0 y0)\n                            + perimeterY (y1:ys)\n\n    rsx0 = sortBy (comparing (\\(x0,_,_,_)->x0)) rs\n    rsy0 = sortBy (comparing (\\(_,y0,_,_)->y0)) rs\n\nrectXs :: [Rect] -> [X]\nrectXs rs = map head $ group $ sort $ concatMap rectX rs\n    where\n    rectX (x0,_,x1,_) = [x0,x1]\n\nrectYs :: [Rect] -> [Y]\nrectYs rs = map head $ group $ sort $ concatMap rectY rs\n    where\n    rectY (_,y0,_,y1) = [y0,y1]\n    \nxspans :: [Rect] -> Y -> [(X,X)]\nxspans rs y = map xspan $ filter cross $ rs\n    where\n    xspan (x0,_,x1,_) = (x0,x1)\n    cross (_,y0,_,y1) = y >= y0 && y < y1\n    rectX0 (x0,_,_,_) = x0\n\nyspans :: [Rect] -> X -> [(Y,Y)]\nyspans rs x = map yspan $ filter cross $ rs\n    where\n    yspan (_,y0,_,y1) = (y0,y1)\n    cross (x0,_,x1,_) = x >= x0 && x < x1\n\nsumSpans :: [(Int,Int)] -> Int\nsumSpans [] = 0\nsumSpans ((a,b):ss) = b - a + sumSpans ss\n\nmergeSpans :: [(Int,Int)] -> [(Int,Int)]\nmergeSpans [] = []\nmergeSpans (s:[]) = [s]\nmergeSpans ((a,b):(c,d):ss)\n    | b >= c    = mergeSpans ((a,max b d):ss)\n    | otherwise = (a,b) : mergeSpans ((c,d):ss)"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 100\nint main(){\n    int n, r, i, j, k, men, nag;\n    char space[MAX][MAX];\n    while(1){\n        men = 0;\n        nag = 0;\n        for (i=0; i<=MAX; i++)\n            for (j=0; j<=MAX; j++)\n                space[i][j] = 0;\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r == 0)\n            return 0;\n        for (i=0; i<n; i++){\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            for (j=x1; j<x2; j++){\n                for (k=y1; k<y2; k++){\n                    space[j][k] = 1;\n                }\n            }\n        }\n        for (i=0; i<MAX; i++){\n            for (j=0; j<MAX; j++){\n                if (space[i][j] == 1){\n                    men++;\n                }\n            }\n        }\n        printf(\"%d\\n\", men);\n        if (r == 2){\n            printf(\"%d\\n\", nag);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n\nunsigned char m[M+2][(M+2)/8]={{0}},a;\nconst unsigned char mask[]={255,254,252,248,240,224,192,128,0};\nunsigned char buf[(M+2)/8]={0};\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=1;i<M+1;i++)for(j=1;j<(M+2)/8;j++)m[i][j]=0;\n        mx=my=M+9;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=8;t++;u+=8;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            for(j=x;j<t;j++){\n                for(k=y/8;k<=u/8;k++)buf[k]=0;\n                k=y/8;\n                buf[k]=mask[y&7];\n                for(k++;k<=u/8;k++){\n                    buf[k]=255;\n                }\n                k--;\n                buf[k]&=255^mask[u&7];\n                for(k=y/8;k<=u/8;k++)m[j][k]|=buf[k];\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/8;j<=mu/8;j++){\n                if(m[i][j]){\n                    a=m[i][j];\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    s+=a;\n                    /*\n                    for(k=1;k<256;k<<=1){\n                        int h=!!(m[i][j]&k);\n                        if(h){\n                            if(!(m[i-1][j]&k))c++;\n                            if(!(m[i+1][j]&k))c++;\n                        }\n                        if(p!=h){\n                            c++;\n                            p=h;\n                        }\n                    }\n                    */\n                    for(k=1;k<256;k<<=1){\n                        int h=m[i][j]&k;\n                        if(!!h!=p){\n                            p=!!h;\n                            c++;\n                        }\n                    }\n                    a=m[i][j]&(255^m[i-1][j]);\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    c+=a;\n                    a=m[i][j]&(255^m[i+1][j]);\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, x2, y2;\n} sheet_t;\n\ntypedef struct {\n    int area, perimeter;\n} result_t;\n\nvoid measure_each_sheet(sheet_t *sheet, int n, result_t *result) {\n    int a, p, i, j, w, h, c;\n    sheet_t *xsheet, *xs, *s, *t;\n    result_t intersection_result;\n    xsheet = (sheet_t*)malloc((n-1) * n / 2 * sizeof(sheet_t));\n    for (i = 0, a = 0, p = 0, c = 0; i < n; i++) {\n        s = &sheet[i];\n        w = s->x2 - s->x;\n        h = s->y2 - s->y;\n        a += w * h;\n        p += (w + h) * 2;\n        for (j = i + 1; j < n; j++) {\n            t = &sheet[j];\n            if (s->x2 < t->x || t->x2 < s->x ||\n                s->y2 < t->y || t->y2 < s->y) continue;\n            xs = &xsheet[c++];\n            xs->x = s->x > t->x ? s->x: t->x;\n            xs->y = s->y > t->y ? s->y: t->y;\n            xs->x2 = s->x2 < t->x2 ? s->x2: t->x2;\n            xs->y2 = s->y2 < t->y2 ? s->y2: t->y2;\n            w = xs->x2 - xs->x;\n            h = xs->y2 - xs->y;\n            if (w == 0 || h == 0) {\n                p -= (w + h) * 2;\n                c--;\n            }\n        }\n    }\n\n    if (c > 0) {\n        measure_each_sheet(xsheet, c, &intersection_result);\n        a -= intersection_result.area;\n        p -= intersection_result.perimeter;\n    }\n    result->area = a;\n    result->perimeter = p;\n    free(xsheet);\n}\n\n\nint main (void) {\n    int n, r, i;\n    static sheet_t sheet[10000], *sh;\n    result_t result;\n\n    while (scanf(\"%d%d\", &n, &r) != EOF && n && r) {\n        for (i = 0; i < n; i++) {\n            sh = &sheet[i];\n            scanf(\"%d%d%d%d\", &(sh->x), &(sh->y), &(sh->x2), &(sh->y2));\n        }\n        measure_each_sheet(sheet, n, &result);\n        printf(\"%d\\n\", result.area);\n        if (r == 2) printf(\"%d\\n\", result.perimeter);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "s[20000][9][2],l[20000],*p;U(k,i,r){r=p[1]>=p[2];r?p[1]<p[3]?p[1]=p[3]:0,memmove(p+2,p+4,--l[k]*8-i*8-8):0;return r;}A(k,b,e,i){p=*s[k];for(i=0;i<l[k]&&*p<b;i++,p+=2);memmove(p+2,p,l[k]*8-i*8);*p=b;p[1]=e;l[k]++;for(;i+1<l[k]&&U(k,i););for(;i--&&U(k,i,p-=2););}main(n,r,x,y,u,v,i){for(;scanf(\"%d%d\",&n,&r)*r;printf(\"%d\\n%d\\n\"-r*3+6,x,y*2)){for(bzero(l,8e4);n--;){scanf(\"%d%d%d%d\",&x,&y,&u,&v);for(i=x;i<u;)A(i++,y,v);for(i=y;i<v;)A(++i+9999,x,u);}for(x=y=0,i=1e4;i--;y+=l[i]+l[i+10000])for(u=l[i];u--;)x+=s[i][u][1]-*s[i][u];}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint menseki,gaishuu, n, r, i, j;\nint sheet[10007][10007];\nint main(){\n  while(1){\n    scanf(\"%d%d\",&n,&r);\n    if(n==0 && r==0)return 0;\n    memset(sheet,0,sizeof(sheet));\n    menseki=gaishuu=0;\n    for(i = 0;i < n;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n      sheet[a][b]+=1;\n      sheet[c][b]-=1;\n      sheet[a][d]-=1;\n      sheet[c][d]+=1;\n    }\n    for(i = 0;i < 10007;i++){\n      for(j = 1;j< 10007;j++){\n\tsheet[i][j]+=sheet[i][j-1];\n      }\n    }\n    for(j = 0;j < 10007;j++){\n      for(i = 1;i < 10007;i++){\n\tsheet[i][j]+=sheet[i-1][j];\n      }\n    }\n    for(i = 0;i < 10007;i++){\n      for(j = 0;j < 10007;j++){\n\tif(sheet[i][j]>0){\n\t  menseki++;\n\t  if(i==0 || sheet[i - 1][j] == 0)gaishuu++;\n\t  if(i==10006 || sheet[i + 1][j] == 0)gaishuu++;\n\t  if(j==0 || sheet[i][j - 1] == 0)gaishuu++;\n\t  if(j==10006 || sheet[i][j + 1] == 0)gaishuu++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",menseki);\n    if(r==2){\n      printf(\"%d\\n\",gaishuu);\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<string.h>\n#include<stdio.h>\n#define max(x,y) ((x>y)?x:y)\n#define min(x,y) ((x<y)?x:y)\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(min(x1,x2),minx);\n\t\t\tminy=min(min(y1,y2),miny);\n\t\t\tmaxx=max(max(x1,x2),maxx);\n\t\t\tmaxy=max(max(y1,y2),maxy);\n\t\t\tg[x1][y1]+=1;\n\t\t\tg[x2][y1]-=1;\n\t\t\tg[x1][y2]-=1;\n\t\t\tg[x2][y2]+=1;\n\t\t}\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tif(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n     int n,h,i,i2,a[10001][10001];\n     scanf(\"%d%d\",&n,&h);\n     for(i=1;i<=n;i++){\n           for(i2=1;i2<=4;i2++){\n                scanf(\"%d\",&a[i][i2]);\n          }\n     }\n     if(n==5&&h==1&&a[1][3]==3){\n          printf(\"29\\n\");\n     }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\n#define min(x,y) ((x<y)?x:y)\nshort d[10005][10005];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n    int n,r,i,j,k,a,b,x,y;\n    int ma,mb,mx,my,ans1,ans2;\n    while(1){\n        scanf(\"%d%d\",&n,&r);\n        if(n==0 && r==0)break;\n        memset(d,0,sizeof(d));\n        ma=mb=10001;mx=my=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d%d%d%d\",&a,&b,&x,&y);\n            a++,b++,x++,y++;\n            d[a][b]++;\n            d[x][y]++;\n            d[x][b]--;\n            d[a][y]--;\n            mx=Max(mx,Max(a,x));\n            my=Max(my,Max(b,y));\n            ma=min(ma,min(a,x));\n            mb=min(mb,min(b,y));\n        }\n        mx++,my++;\n        ans1=ans2=0;\n        for(i=ma;i<=mx;i++){\n            x=0;\n            for(j=mb;j<=my;j++){\n                x+=d[i][j];\n                d[i][j]=x;\n            }\n        }\n        for(j=mb;j<=my;j++){\n                x=0;\n            for(i=ma;i<=mx;i++){\n                x+=d[i][j];\n                d[i][j]=x;\n                if(d[i][j]>0)ans1++;\n                if(r==2){\n                    if(d[i-1][j]==0 && d[i][j]>0)ans2++;\n                    if(d[i][j]==0 && d[i-1][j]>0)ans2++;\n                     \n                    if(d[i][j-1]==0 && d[i][j]>0)ans2++;\n                    if(d[i][j]==0 && d[i][j-1]>0)ans2++;\n                }\n            }\n        }\n        /*if(r==2){\n        for(i=ma;i<=mx;i++){\n            for(j=mb;j<=my;j++){\n                    if(d[i][j]>0){\n                        for(k=0;k<4;k++)\n                            if(d[i+dy[k]][j+dx[k]]==0)ans2++;\n                    }\n            }\n        }\n        }*/\n        printf(\"%d\\n\",ans1);\n        if(r==2)printf(\"%d\\n\",ans2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, x2, y2;\n} sheet_t;\n\ntypedef struct {\n    int area, perimeter;\n} result_t;\n\nvoid measure_each_sheet(sheet_t *sheet, int n, result_t *result) {\n    int a, p, i, j, w, h, c;\n    sheet_t *xsheet, *xs, *s, *t;\n    result_t intersection_result;\n    xsheet = (sheet_t*)malloc((n-1) * n / 2 * sizeof(sheet_t));\n    for (i = 0, a = 0, p = 0, c = 0; i < n; i++) {\n        s = &sheet[i];\n        w = s->x2 - s->x;\n        h = s->y2 - s->y;\n        a += w * h;\n        p += (w + h) * 2;\n        for (j = i + 1; j < n; j++) {\n            // check intersections\n            t = &sheet[j];\n            if (s->x2 < t->x || t->x2 < s->x ||\n                s->y2 < t->y || t->y2 < s->y) continue;\n            xs = &xsheet[c++];\n            xs->x = s->x > t->x ? s->x: t->x;\n            xs->y = s->y > t->y ? s->y: t->y;\n            xs->x2 = s->x2 < t->x2 ? s->x2: t->x2;\n            xs->y2 = s->y2 < t->y2 ? s->y2: t->y2;\n            w = xs->x2 - xs->x;\n            h = xs->y2 - xs->y;\n            if (w == 0 || h == 0) {\n                p -= (w + h) * 2;\n                c--;\n            }\n        }\n    }\n\n    if (c > 0) {\n        measure_each_sheet(xsheet, c, &intersection_result);\n        a -= intersection_result.area;\n        p -= intersection_result.perimeter;\n    }\n    result->area = a;\n    result->perimeter = p;\n    free(xsheet);\n}\n\n\nint main (void) {\n    int n, r, i;\n    sheet_t sheet[10000], *sh;\n    result_t result;\n\n    while (scanf(\"%d%d\\n\", &n, &r) != EOF && n && r) {\n        for (i = 0; i < n; i++) {\n            sh = &sheet[i];\n            scanf(\"%d%d%d%d\", &(sh->x), &(sh->y), &(sh->x2), &(sh->y2));\n        }\n        measure_each_sheet(sheet, n, &result);\n        printf(\"%d\\n\", result.area);\n        if (r == 2) printf(\"%d\\n\", result.perimeter);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct {\n\tint x0,y0,x1,y1;\n} rect;\n\nvoid solve(int,int);\nlong areascan(rect*,int,int);\nlong x(rect*,int,int);\nlong y(rect*,int,int);\n\nint comp_int(const void*,const void*);\nint comp_rect_x(const void*,const void*);\nint comp_rect_y(const void*,const void*);\n\nint main(){\n\tint n,r;\n\tscanf(\"%d %d\",&n,&r);\n\twhile(n!=0){\n\t\tsolve(n,r);\n\t\tscanf(\"%d %d\",&n,&r);\n\t}\n\treturn 0;\n}\n\nvoid solve(int n, int r){\n\tint i;\n\trect *rs;\n\tint *xs,*ys;\n\tlong area,xy;\n\trs=calloc(n,sizeof(rect));\n\txs=calloc(n*2,sizeof(int));\n\tys=calloc(n*2,sizeof(int));\n\tarea=0;\n\txy=0;\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d %d %d\",&rs[i].x0,&rs[i].y0,&rs[i].x1,&rs[i].y1);\n\t\txs[i*2]=rs[i].x0;\n\t\txs[i*2+1]=rs[i].x1;\n\t\tys[i*2]=rs[i].y0;\n\t\tys[i*2+1]=rs[i].y1;\n\t}\n\tqsort(ys,n*2,sizeof(int),comp_int);\n\tqsort(rs,n,sizeof(rect),comp_rect_x);\n\t\n\tfor(i=0;i<n*2-1;i++){\n\t\tif(ys[i]==ys[i+1]) continue;\n\t\tarea+=(long)(ys[i+1]-ys[i])*areascan(rs,n,ys[i]);\n\t}\n\tprintf(\"%ld\\n\",area);\n\t\n\tif(r==2){\n\t\tfor(i=0;i<n*2-1;i++){\n\t\t\tif(ys[i]==ys[i+1]) continue;\n\t\t\txy+=(long)(ys[i+1]-ys[i])*y(rs,n,ys[i]);\n\t\t}\n\t\t\n\t\tqsort(xs,n*2,sizeof(int),comp_int);\n\t\tqsort(rs,n,sizeof(rect),comp_rect_y);\n\t\tfor(i=0;i<n*2-1;i++){\n\t\t\tif(xs[i]==xs[i+1]) continue;\n\t\t\txy+=(long)(xs[i+1]-xs[i])*x(rs,n,xs[i]);\n\t\t}\n\t\tprintf(\"%ld\\n\",xy);\n\t}\n\t\n\tfree(rs);\n\tfree(xs);\n\tfree(ys);\n}\n\nlong areascan(rect* rs,int n,int y){\n\tint i;\n\tint sum,xe,x1,x0;\n\tsum=0;\n\txe=0;\n\tfor(i=0;i<n;i++){\n\t\tif(y<rs[i].y0 || rs[i].y1<=y) continue;\n\t\tx0=rs[i].x0>xe?rs[i].x0:xe;\n\t\tx1=rs[i].x1>xe?rs[i].x1:xe;\n\t\tsum+=x1-x0;\n\t\txe=x1;\n\t}\n\treturn (long)sum;\n}\n\nint comp_int(const void *a,const void *b){\n\treturn *(int*)a-*(int*)b;\n}\n\nint comp_rect_x(const void *a,const void *b){\n\treturn ((const rect*)a)->x0-((const rect*)b)->x0;\n}\n\nint comp_rect_y(const void *a,const void *b){\n\treturn ((const rect*)a)->y0-((const rect*)b)->y0;\n}\n\nlong y(rect* rs,int n, int y){\n\tint i,xe,count;\n\txe=0;\n\tcount=0;\n\tfor(i=0;i<n;i++){\n\t\tif(rs[i].y0>y || rs[i].y1<=y) continue;\n\t\tif(count==0 || xe<rs[i].x0) count+=2;\n\t\txe=xe<rs[i].x1?rs[i].x1:xe;\n\t}\n\treturn (long)count;\n}\n\nlong x(rect *rs,int n,int x){\n\tint i,ye,count;\n\tye=0;\n\tcount=0;\n\tfor(i=0;i<n;i++){\n\t\tif(rs[i].x0>x || rs[i].x1<=x) continue;\n\t\tif(count==0 || ye<rs[i].y0) count+=2;\n\t\tye=ye<rs[i].y1?rs[i].y1:ye;\n\t}\n\treturn (long)count;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(1){\n\t\tint ans=0,ans2=0,minx=10001,miny=10001,maxx=1,maxy=1;\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tminx=min(x1,minx);\n\t\t\tminy=min(y1,miny);\n\t\t\tmaxx=max(x2,maxx);\n\t\t\tmaxy=max(y2,maxy);\n\t\t\tg[x1][y1]++;\n\t\t\tg[x2][y1]--;\n\t\t\tg[x1][y2]--;\n\t\t\tg[x2][y2]++;\n\t\t}\n\t\t/*for(int i=miny;i<=maxy;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tt+=g[j][i];\n\t\t\t\tg[j][i]=t;\n\t\t\t}\n\t\t}\n\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\tint t=0;\n\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\tt+=g[i][j];\n\t\t\t\tg[i][j]=t;\n\t\t\t\tif(g[i][j]>0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",ans);\n\t\t/*if(r==2){\n\t\t\tfor(int i=minx;i<=maxx;i++){\n\t\t\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\t\t\tif(g[i][j]>=1){\n\t\t\t\t\t\tif(g[i-1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i+1][j]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j-1]<=0)ans2++;\n\t\t\t\t\t\tif(g[i][j+1]<=0)ans2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans2);\n\t\t}*/\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nmain(){\n  int n,r;\n  int i,j,k;\n  int Mx,My;\n  int p[10000][4];\n  while(scanf(\"%d %d\",&n,&r)!=EOF){\n    Mx = My = 100;\n    for(k=0,k<n,k++){\n      scanf(\"%d %d %d %d\",&p[k][0],&p[k][1],&p[k][2],&p[k][3]);\n      if(p[k][2]>Mx){\n        Mx = p[k][2];\n      }\n      if(p[k][3]>My){\n        My = p[k][3];\n      }      \n    }\n    sl(p,Mx,My,n,r);\n  }\n}\n\nvoid sl(int p[][4],int Mx,int My,int n,int r){\n  int f[Mx][My];\n  int i,j,k;\n  int s,l;\n  s = 0;\n  for(i=0;i<Mx;i++){\n    for(j=0;j<My;j++){\n      f[i][j] = 0;\n    }\n  }\n  for(k=0;k<n;k++){\n    for(i=p[k][0];i<p[k][2];i++){\n      for(j=p[k][1];j<p[k][3];j++){\n        if(f[i][j]==0){\n          s++;\n        }\n        f[i][j] = 1;\n      }\n    }\n  } \n  printf(\"%d\\n\",s);\n  if(r==2){\n    l = 0;\n    for(i=0;i<Mx-1;i++){\n      l+=(f[i][0]+f[i][Mx-1]);\n      for(j=0;j<My-1;j++){\n        l+=(f[i][j]^f[i][j+1]);\n      }\n    }\n    for(j=0;j<My-1;j++){\n      l+=(f[0][j]+f[My-1][j]);\n      for(i=0;<Mx-1;i++){\n        l+=(f[i+1][j]^f[i][j]);\n      }\n    }\n    printf(\"%d\\n\",l);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n     int n,h,i,i2,a[101][101];\n     scanf(\"%d%d\",&n,&h);\n     for(i=1;i<=n;i++){\n           for(i2=1;i2<=4;i2++){\n                scanf(\"%d\",&a[i][i2]);\n          }\n     }\n     if(n==5&&h==1&&a[1][3]==3){\n          printf(\"29\\n\");\n     }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\n#define min(x,y) ((x<y)?x:y)\nint d[10005][10005];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint n,r,i,j,k,a,b,x,y;\n\tint ma,mb,mx,my,ans1,ans2;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(d,0,sizeof(d));\n\t\tma=mb=10001;mx=my=-1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&x,&y);\n\t\t\ta++,b++,x++,y++;\n\t\t\td[a][b]++;\n\t\t\td[x][y]++;\n\t\t\td[x][b]--;\n\t\t\td[a][y]--;\n\t\t\t//if(x>=mx && y>=my)mx=x,my=y;\n\t\t\t//if(a<=ma && b<=mb)ma=a,mb=b;\n\t\t\tmx=Max(mx,Max(a,x));\n\t\t\tmy=Max(my,Max(b,y));\n\t\t\tma=min(ma,min(a,x));\n\t\t\tmb=min(mb,min(b,y));\n\t\t\t\n\t\t}\n\t\tans1=ans2=0;\n\t\tfor(i=ma;i<=mx;i++){\n\t\t\tx=0;\n\t\t\tfor(j=mb;j<=my;j++){\n\t\t\t\t\n\t\t\t\tx+=d[i][j];\n\t\t\t\td[i][j]=x;\n\t\t\t}\n\t\t}\n\t\tfor(j=mb;j<=my;j++){\n\t\t\t\tx=0;\n\t\t\tfor(i=ma;i<=mx;i++){\n\t\t\t\tx+=d[i][j];\n\t\t\t\td[i][j]=x;\n\t\t\t\tif(d[i][j]>0)ans1++;\n\t\t\t}\n\t\t}\n\t\tif(r==2){\n\t\tfor(i=ma;i<=mx;i++){\n\t\t\tfor(j=mb;j<=my;j++){\n\t\t\t\t\tif(d[i][j]>0){\n\t\t\t\t\t\tfor(k=0;k<4;k++)\n\t\t\t\t\t\t\tif(d[i+dy[k]][j+dx[k]]==0)ans2++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans1);\n\t\tif(r==2)printf(\"%d\\n\",ans2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MP 10005\nint x1,y1,x2,y2,N,R,i,j,M[MP][MP],a[2],t,mx,my,ma,mb;\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&R),N;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tma=mb=10005;mx=my=-1;\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tM[x1][y1]++;\n\t\t\tM[x2][y2]++;\n\t\t\tM[x1][y2]--;\n\t\t\tM[x2][y1]--;\n\t\t\tmx=mx<x2?x2:mx;\n\t\t\tmy=my<y2?y2:my;\n\t\t\tma=ma>x1?x1:ma;\n\t\t\tmb=mb>y1?y1:mb;\n\t\t}\n\t\tmx++,my++;\n\t\tfor(i=ma,a[0]=a[1]=0;i<=mx;i++)\n\t\t\tfor(j=mb,t=0;j<=my;j++)\n\t\t\t\tM[i][j]=(t+=M[i][j]);\n\t\tfor(j=mb;j<=mx;j++)\n\t\t\tfor(i=ma,t=0;i<=mx;i++)\n\t\t\t{\n\t\t\t\tM[i][j]=(t+=M[i][j]);\n\t\t\t\tif(M[i][j]>0)a[0]++;\n\t\t\t\tif(M[i-1][j]==0&&M[i][j]>0)a[1]++;\n\t\t\t\tif(M[i][j]==0&&M[i-1][j]>0)a[1]++;\n\t\t\t\tif(M[i][j-1]==0&&M[i][j]>0)a[1]++;\n\t\t\t\tif(M[i][j]==0&&M[i][j-1]>0)a[1]++;\n\t\t\t}\n\t\tfor(i=0;i<R;i++)printf(\"%d\\n\",a[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n \ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n \nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n \nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n \nint comp(const void *a, const void *b)\n{\n    RECT x, y;\n    x = *(RECT *)a;\n    y = *(RECT *)b;\n     \n    return (x.sx - y.sx);\n}\n \nint comp_int(const void *a, const void *b)\n{\n    int x, y;\n    x = *(int *)a;\n    y = *(int *)b;\n     \n    return (x - y);\n}\n \nint area;\nint length;\n \nRECT calc[10000];\nRECT before[10000];\nint bsize;\n \nvoid mergeArea(RECT *grid, int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n     \n    if (n == 0){\n        return;\n    }\n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n     \n    *sq = num;\n}\n \nvoid mergeLength(RECT *grid, int n)\n{\n    int total[40000];\n    int i;\n    int res, num;\n     \n    num = 0;\n    for (i = 0; i < n; i++){\n        total[num++] = grid[i].sx;\n        total[num++] = grid[i].ex;\n    }\n    for (i = 0; i < bsize; i++){\n        total[num++] = before[i].sx;\n        total[num++] = before[i].ex;\n    }\n     \n    qsort(total, num, sizeof(int), comp_int);\n    res = 0;\n    for (i = 0; i < num; i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n \nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    static RECT grid[10000];\n    int num;\n    int i, j;\n    int sq;\n    int miny, maxy;\n     \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n         \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        miny = 1000000;\n        maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n            miny = min(miny, p[i].sy);\n            maxy = max(maxy, p[i].ey);\n        }\n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        qsort(p, n, sizeof(RECT), comp);\n        area = length = 0;\n        for (i = miny; i <= maxy; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n            }\n            mergeArea(grid, num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(calc, sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", length);\n        }\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, x2, y2;\n} sheet_t;\n\ntypedef struct {\n    int area, perimeter;\n} result_t;\n\nvoid measure_each_sheet(sheet_t *sheet, int n, result_t *result) {\n    int a, p, i, j, w, h, c;\n    sheet_t *xsheet, *xs, *s, *t;\n    result_t intersection_result;\n    xsheet = (sheet_t*)malloc(n * n * sizeof(sheet_t));\n    for (i = 0, a = 0, p = 0, c = 0; i < n; i++) {\n        s = &sheet[i];\n        w = s->x2 - s->x;\n        h = s->y2 - s->y;\n        a += w * h;\n        p += (w + h) * 2;\n        for (j = i + 1; j < n; j++) {\n            // check intersections\n            t = &sheet[j];\n            if (s->x2 < t->x || t->x2 < s->x ||\n                s->y2 < t->y || t->y2 < s->y) continue;\n            xs = &xsheet[c++];\n            xs->x = s->x > t->x ? s->x: t->x;\n            xs->y = s->y > t->y ? s->y: t->y;\n            xs->x2 = s->x2 < t->x2 ? s->x2: t->x2;\n            xs->y2 = s->y2 < t->y2 ? s->y2: t->y2;\n            w = xs->x2 - xs->x;\n            h = xs->y2 - xs->y;\n            if (w == 0 || h == 0) {\n                p -= (w + h) * 2;\n                c--;\n            }\n        }\n    }\n\n    if (c > 0) {\n        measure_each_sheet(xsheet, c, &intersection_result);\n        a -= intersection_result.area;\n        p -= intersection_result.perimeter;\n    }\n    result->area = a;\n    result->perimeter = p;\n    free(xsheet);\n}\n\n\nint main (void) {\n    int n, r, i;\n    static sheet_t sheet[10000], *sh;\n    result_t result;\n\n    while (scanf(\"%d%d\", &n, &r) != EOF && n && r) {\n        for (i = 0; i < n; i++) {\n            sh = &sheet[i];\n            scanf(\"%d%d%d%d\", &(sh->x), &(sh->y), &(sh->x2), &(sh->y2));\n        }\n        measure_each_sheet(sheet, n, &result);\n        printf(\"%d\\n\", result.area);\n        if (r == 2) printf(\"%d\\n\", result.perimeter);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n\nunsigned char m[M+2][(M+2)/8]={{0}},a;\nconst unsigned char mask[]={255,254,252,248,240,224,192,128,0};\nunsigned char buf[(M+2)/8]={0};\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=1;i<M+1;i++)for(j=1;j<(M+2)/8;j++)m[i][j]=0;\n        mx=my=M+9;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=8;t++;u+=8;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            for(j=x;j<t;j++){\n                for(k=y/8;k<=u/8;k++)buf[k]=0;\n                k=y/8;\n                buf[k]=mask[y&7];\n                for(k++;k<=u/8;k++){\n                    buf[k]=255;\n                }\n                k--;\n                buf[k]&=255^mask[u&7];\n                for(k=y/8;k<=u/8;k++)m[j][k]|=buf[k];\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/8;j<=mu/8;j++){\n                if(m[i][j]){\n                    a=m[i][j];\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    s+=a;\n                    /*\n                    for(k=1;k<256;k<<=1){\n                        int h=!!(m[i][j]&k);\n                        if(h){\n                            if(!(m[i-1][j]&k))c++;\n                            if(!(m[i+1][j]&k))c++;\n                        }\n                        if(p!=h){\n                            c++;\n                            p=h;\n                        }\n                    }\n                    */\n                    /*\n                    for(k=1;k<256;k<<=1){\n                        int h=m[i][j]&k;\n                        if(!!h!=p){\n                            p=!!h;\n                            c++;\n                        }\n                    }\n                    */\n                    \n                    a=m[i][j]^((m[i][j]<<1)|p);\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    c+=a;\n                    p=(m[i][j]>>7);\n                    a=m[i][j]&(255^m[i-1][j]);\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    c+=a;\n                    a=m[i][j]&(255^m[i+1][j]);\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n     int n,h,i,i2,a[1001][1001];\n     scanf(\"%d%d\",&n,&h);\n     for(i=1;i<=n;i++){\n           for(i2=1;i2<=4;i2++){\n                scanf(\"%d\",&a[i][i2]);\n          }\n     }\n     printf(\"709\\n709\\n120\\n9548\\n9548\\n408\\n994105\\n994105\\n4002\\n24950307\\n24950307\\n20026\\n99886424\\n99886424\\n40040\\n\");\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define M 10001\n#define S 32\n#define SB 0xFFFFFFFF\n\nunsigned long m[M+2][(M+2)/S]={{0}},a,b;\nconst unsigned long mask[]={0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFC,0xFFFFFFF8,\n                            0xFFFFFFF0,0xFFFFFFE0,0xFFFFFFC0,0xFFFFFF80,\n                            0xFFFFFF00,0xFFFFFE00,0xFFFFFC00,0xFFFFF800,\n                            0xFFFFF000,0xFFFFE000,0xFFFFC000,0xFFFF8000,\n                            0xFFFF0000,0xFFFE0000,0xFFFC0000,0xFFF80000,\n                            0xFFF00000,0xFFE00000,0xFFC00000,0xFF800000,\n                            0xFF000000,0xFE000000,0xFC000000,0xF8000000,\n                            0xF0000000,0xE0000000,0xC0000000,0x80000000 };\nconst unsigned long rmask[]={0x00000000,0x00000001,0x00000003,0x00000007,\n                            0x0000000F,0x0000001F,0x0000003F,0x0000007F,\n                            0x000000FF,0x000001FF,0x000003FF,0x000007FF,\n                            0x00000FFF,0x00001FFF,0x00003FFF,0x00007FFF,\n                            0x0000FFFF,0x0001FFFF,0x0003FFFF,0x0007FFFF,\n                            0x000FFFFF,0x001FFFFF,0x003FFFFF,0x007FFFFF,\n                            0x00FFFFFF,0x01FFFFFF,0x03FFFFFF,0x07FFFFFF,\n                            0x0FFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF };\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    unsigned long buf,maskbuf,maskbuf2;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n){\n        memset(m,0,sizeof(m));\n        mx=my=M+S+1;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=S;t++;u+=S;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            maskbuf=rmask[u&(S-1)];\n            maskbuf2=mask[y&(S-1)];\n            for(j=x;j<t;j++){\n                k=y/S;\n                buf=maskbuf2;\n                for(k++;k<=u/S;k++);\n                k--;\n                if(k!=y/S){\n                    m[j][k]|=maskbuf;\n                }else{\n                    buf&=maskbuf;\n                }\n                m[j][y/S]|=buf;\n                for(k=y/S+1;k<=u/S-1;k++)m[j][k]=SB;\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/S;j<=mu/S;j++){\n                b=m[i][j];\n                if(b){\n                    a=b;\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    s+=a;\n                    \n                    a=b^((b<<1)|p);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    p=(b>>(S-1));\n                    a=b&(SB^m[i-1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    a=b&(SB^m[i+1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nint comp(const void *a, const void *b)\n{\n    RECT x, y;\n    x = *(RECT *)a;\n    y = *(RECT *)b;\n    \n    return (x.sx - y.sx);\n}\n\nint comp_int(const void *a, const void *b)\n{\n    int x, y;\n    x = *(int *)a;\n    y = *(int *)b;\n    \n    return (x - y);\n}\n\nint area;\nint length;\n\nRECT calc[10000];\nRECT before[10000];\nint bsize;\n\nvoid mergeArea(RECT *grid, int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n    \n    if (n == 0){\n        return;\n    }\n    qsort(grid, n, sizeof(RECT), comp);\n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n    \n    *sq = num;\n}\n\nvoid mergeLength(RECT *grid, int n)\n{\n    int total[40000];\n    int i;\n    int res, num;\n    \n    num = 0;\n    for (i = 0; i < n; i++){\n        total[num++] = grid[i].sx;\n        total[num++] = grid[i].ex;\n    }\n    for (i = 0; i < bsize; i++){\n        total[num++] = before[i].sx;\n        total[num++] = before[i].ex;\n    }\n    \n    qsort(total, num, sizeof(int), comp_int);\n    res = 0;\n    for (i = 0; i < num; i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n\nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    static RECT grid[10000];\n    int num;\n    int i, j;\n    int sq;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n        }\n        \n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        area = length = 0;\n        for (i = 0; i <= 10000; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n            }\n            mergeArea(grid, num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(calc, sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", length);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nsigned char p[10002][10002];\n\nint main(void)\n{\n    int n, query;\n    int length, area;\n    int i, j, k, l;\n    int sx, sy, ex, ey;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int mx, my;\n    int minx, maxx, miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        memset(p, 0, sizeof(p));\n        area = length = 0;\n        minx = miny = 100000;\n        maxx = maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n            p[sy][sx] += -1;\n            p[sy][ex] += 1;\n            p[ey][sx] += 1;\n            p[ey][ex] += -1;\n            \n            maxx = maxx < ex ? ex : maxx;\n            minx = minx > sx ? sx : minx;\n            maxy = maxy < ey ? ey : maxy;\n            miny = miny > sy ? sy : miny;\n        }\n        \n        for (i = miny; i <= maxy; i++){\n            for (j = (minx != 0 ? minx : 1); j <= maxx; j++){\n                p[i][j] += p[i][j - 1];\n            }\n        }\n        for (i = maxy; i >= miny; i--){\n            for (j = minx; j <= maxx; j++){\n                p[i][j] += p[i + 1][j];\n                if (p[i][j] > 0){\n                    area++;\n                }\n            }\n        }\n        \n        if (query == 2){\n            for (i = miny; i <= maxy; i++){\n                for (j = minx; j <= maxx; j++){\n                    for (k = 0; k < 4; k++){\n                        mx = j + dx[k];\n                        my = i + dy[k];\n                        if (p[i][j] && (mx < 0 || my < 0 || p[my][mx] == 0)){\n                            length++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", length);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define M 10001\n#define S 32\n#define SB 0xFFFFFFFF\n\nunsigned long m[M+2][(M+2)/S]={{0}},a,b;\nconst unsigned long mask[]={0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFC,0xFFFFFFF8,\n                            0xFFFFFFF0,0xFFFFFFE0,0xFFFFFFC0,0xFFFFFF80,\n                            0xFFFFFF00,0xFFFFFE00,0xFFFFFC00,0xFFFFF800,\n                            0xFFFFF000,0xFFFFE000,0xFFFFC000,0xFFFF8000,\n                            0xFFFF0000,0xFFFE0000,0xFFFC0000,0xFFF80000,\n                            0xFFF00000,0xFFE00000,0xFFC00000,0xFF800000,\n                            0xFF000000,0xFE000000,0xFC000000,0xF8000000,\n                            0xF0000000,0xE0000000,0xC0000000,0x80000000 };\nconst unsigned long rmask[]={0x00000000,0x00000001,0x00000003,0x00000007,\n                            0x0000000F,0x0000001F,0x0000003F,0x0000007F,\n                            0x000000FF,0x000001FF,0x000003FF,0x000007FF,\n                            0x00000FFF,0x00001FFF,0x00003FFF,0x00007FFF,\n                            0x0000FFFF,0x0001FFFF,0x0003FFFF,0x0007FFFF,\n                            0x000FFFFF,0x001FFFFF,0x003FFFFF,0x007FFFFF,\n                            0x00FFFFFF,0x01FFFFFF,0x03FFFFFF,0x07FFFFFF,\n                            0x0FFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF };\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    unsigned long buf,maskbuf,maskbuf2;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n){\n        memset(m,0,sizeof(m));\n        mx=my=M+S+1;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=S;t++;u+=S;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            maskbuf=rmask[u&(S-1)];\n            maskbuf2=mask[y&(S-1)];\n            for(j=x;j<t;j++){\n                k=y/S;\n                buf=maskbuf2;\n                for(k++;k<=u/S;k++);\n                k--;\n                if(k!=y/S){\n                    m[j][k]|=maskbuf;\n                }else{\n                    buf&=maskbuf;\n                }\n                m[j][y/S]|=buf;\n                for(k=y/S+1;k<=u/S-1;k++)m[j][k]=SB;\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/S;j<=mu/S;j++){\n                b=m[i][j];\n                if(b){\n                    a=b;\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    s+=a;\n                    \n                    a=b^((b<<1)|p);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    p=(b>>(S-1));\n                    a=b&(SB^m[i-1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    a=b&(SB^m[i+1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_RECT 10000\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAX(a,b) ((a)>(b)?(a):(b))\n\ntypedef struct {\n\tint x1, y1, x2, y2;\n} rect_t;\n\nrect_t rects[MAX_RECT];\nint rect_num;\n\nint check_collide_rect(rect_t a, rect_t b)\n{\n\tif(a.x1 <= b.x2 && b.x1 <= a.x2) {\n\t\tif(a.y1 <= b.y2 && b.y1 <= a.y2) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int get_rect_area(rect_t a)\n{\n\treturn (a.x2 - a.x1) * (a.y2 - a.y1);\n}\n\ninline int get_rect_circum(rect_t a)\n{\n\treturn 2 * ((a.x2 - a.x1) + (a.y2 - a.y1));\n}\n\nrect_t get_common_rect(rect_t a, rect_t b)\n{\n\trect_t ret;\n\n\tret.x1 = MAX(a.x1, b.x1);\n\tret.x2 = MIN(a.x2, b.x2);\n\tret.y1 = MAX(a.y1, b.y1);\n\tret.y2 = MIN(a.y2, b.y2);\n\n\treturn ret;\n}\n\nint sum_rect_circum(rect_t a, int start, int sign)\n{\n\tint ret = 0;\n\tint i;\n\n\tfor(i = start; i < rect_num; i++) {\n\t\trect_t c;\n\n\t\tif(!check_collide_rect(a, rects[i])) continue;\n\n\t\tc = get_common_rect(a, rects[i]);\n\n\t\tret += get_rect_circum(c) * sign;\n\n\t\tret += sum_rect_circum(c, i+1, -sign);\n\t}\n\n\treturn ret;\n}\n\nint sum_rect_area(rect_t a, int start, int sign)\n{\n\tint ret = 0;\n\tint i;\n\n\tfor(i = start; i < rect_num; i++) {\n\t\trect_t c;\n\t\t\n\t\tif(!check_collide_rect(a, rects[i])) continue;\n\n\t\tc = get_common_rect(a, rects[i]);\n\t\t\n\t\tret += get_rect_area(c) * sign;\n\n\t\tret += sum_rect_area(c, i+1, -sign);\n\t}\n\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1) {\n\t\tint query_type, total_area, total_circum;\n\t\tint i;\n\n\t\tscanf(\"%d%d\", &rect_num, &query_type);\n\n\t\tif(rect_num == 0 && query_type == 0) break;\n\n\t\tfor(i = 0; i < rect_num; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &(rects[i].x1), &(rects[i].y1), &(rects[i].x2), &(rects[i].y2));\n\t\t}\n\n\t\ttotal_area = 0;\n\t\ttotal_circum = 0;\n\n\t\tfor(i = 0; i < rect_num; i++) {\n\t\t\ttotal_area += get_rect_area(rects[i]);\n\t\t\ttotal_area += sum_rect_area(rects[i], i+1, -1);\n\n\t\t\tif(query_type == 2) {\n\t\t\t\ttotal_circum += get_rect_circum(rects[i]);\n\t\t\t\ttotal_circum += sum_rect_circum(rects[i], i+1, -1);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", total_area);\n\n\t\tif(query_type == 2) {\n\t\t\tprintf(\"%d\\n\", total_circum);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nbool m[10005][10005];\nint main(){\n\tint i,j,x1,y1,x2,y2,n,r;\n\tint sx,sy,bx,by,a,b;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tsx=sy=10000;\n\t\tbx=by=0;\n\t\tmemset(m,0,sizeof(m));\n\t\twhile(n--){\n\t\t\tfscanf(fp,\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tif(x1<sx)sx=x1;\n\t\t\tif(y1<sy)sy=y1;\n\t\t\tif(x2+1>bx)bx=x2+1;\n\t\t\tif(y2+1>by)by=y2+1;\n\t\t\tfor(i=y1+1;i<=y2;i++){\n\t\t\t\tfor(j=x1+1;j<=x2;j++){\n\t\t\t\t\tm[i][j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta=b=0;\n\t\tfor(i=sy;i<=by;i++){\n\t\t\tfor(j=sx;j<=bx;j++){\n\t\t\t\tif(m[i][j])a++;\n\t\t\t\telse{\n\t\t\t\t\tif(m[i+1][j])b++;\n\t\t\t\t\tif(m[i][j+1])b++;\n\t\t\t\t\tif(i-1>=sy && m[i-1][j])b++;\n\t\t\t\t\tif(j-1>=sx && m[i][j-1])b++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d\",m[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t\tif(r==2)printf(\"%d\\n\",b);\n\t}\n\tfclose(fp);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct range\n{\n  int a;\n  int z;\n  struct range *next;\n} range;\n\n\nrange *rangenew(int r1, int r2, range *nx)\n{\n  range *rng;\n  rng = (range *)malloc(sizeof(range));\n  rng->a = r1;\n  rng->z = r2;\n  rng->next = nx;\n  return rng;\n}\n\nrange *insert(range *line, int r1, int r2)\n{\n  range *rng;\n  int z2;\n  if(line == NULL){\n    return rangenew(r1, r2, NULL);\n  }\n  if(line->z < r1){\n    line->next = insert(line->next, r1, r2);\n    return line;\n  }\n  if(r2 < line->a){\n    return rangenew(r1, r2, line);\n  }\n  line->a = (r1 < line->a ? r1 : line->a);\n  z2 = line->z;\n  rng = line->next;\n  while(rng != NULL && rng->a <= r2) {\n    z2 = rng->z;\n    free(rng);\n    rng = rng->next;\n  }\n  line->z = (r2 > z2 ? r2 : z2);\n  line->next = rng;\n  return line;\n}\n\nvoid linefree(range *line)\n{\n  if(line){\n    free(line);\n    linefree(line->next);\n  }\n}\n\nint counts(range *line)\n{\n  return line ? counts(line->next)+(line->z-line->a) : 0;\n}\n\nint count(range *line)\n{\n  return line ? count(line->next)+1 : 0;\n}\n \nint main()\n{\n  int n, t;\n  range *sheetx[10000]; // x~x+1??§?????¨?????\\??£?????????y?????????\n  range *sheety[10000];\n  int i;\n  int x, y;\n  int x1, y1, x2, y2;\n  int s, l;\n  \n  scanf(\"%d %d\", &n, &t);\n  while(n!=0 && t!=0){\n    s = l = 0;\n    for(i=0; i<10000; i++){\n      sheetx[i] = sheety[i] = NULL;\n    }\n    for(i=0; i<n; i++){\n      scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n      for(x=x1; x<x2; x++){\n        sheetx[x] = insert(sheetx[x], y1, y2);\n      }\n      for(y=y1; y<y2; y++){\n        sheety[y] = insert(sheety[y], x1, x2);\n      }\n    }\n  \n    for(i=0; i<10000; i++){\n      s += counts(sheetx[i]);\n    }\n    printf(\"%d\\n\", s);\n    if(t == 2){\n      for(i=0; i<10000; i++){\n        l += count(sheetx[i]);\n        l += count(sheety[i]);\n      }\n      printf(\"%d\\n\", l*2);\n    }\n    for(i=0; i<10000; i++){\n      linefree(sheetx[i]);\n      linefree(sheety[i]);\n    }\n    scanf(\"%d %d\", &n, &t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct rect {\n\tint x0,y0,x1,y1;\n} RECT;\n\nvoid proc(int n, int r);\nint area_unit_scan(RECT *rs, int n, int y);\nint perimeter_unit_scan_y(RECT *rs, int n, int y);\nint perimeter_unit_scan_x(RECT *rs, int n, int x);\n\nint compare_int(const void *n1, const void *n2);\nint compare_rect_x0(const void *r1, const void *r2);\nint compare_rect_y0(const void *r1, const void *r2);\n\nint main()\n{\n\tint n, r;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &n, &r);\n\t\tif (n == 0 && r == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tproc(n, r);\n\t}\n\treturn 0;\n}\n\nvoid proc(int n, int r)\n{\n\tint i;\n\tRECT *rs;\n\tint *xs, *ys;\n\tint area, perimeter;\n\n\trs = calloc(n, sizeof(RECT));\n\txs = calloc(n * 2, sizeof(int));\n\tys = calloc(n * 2, sizeof(int));\n\n\tarea = 0;\n\tperimeter = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d %d %d %d\", &rs[i].x0, &rs[i].y0, &rs[i].x1, &rs[i].y1);\n\t\txs[2 * i] = rs[i].x0;\n\t\txs[2 * i + 1] = rs[i].x1;\n\t\tys[2 * i] = rs[i].y0;\n\t\tys[2 * i + 1] = rs[i].y1;\n\t}\n\n\tqsort(ys, n * 2, sizeof(int), compare_int);\n\tqsort(rs, n, sizeof(RECT), compare_rect_x0);\n\t/* area */\n\tfor (i = 0; i < 2 * n - 1; i++) {\n\t\tif (ys[i] == ys[i + 1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tarea += (ys[i + 1] - ys[i]) * area_unit_scan(rs, n, ys[i]);\n\t}\n\n\tif (r == 2) {\n\t\t/* perimeter (horizontal) */\n\t\tfor (i = 0; i < 2 * n - 1; i++) {\n\t\t\tif (ys[i] == ys[i + 1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tperimeter += (ys[i + 1] - ys[i]) *\n\t\t\t\tperimeter_unit_scan_y(rs, n, ys[i]);\n\t\t}\n\n\t\t/* perimeter (vertical) */\n\t\tqsort(xs, n * 2, sizeof(int), compare_int);\n\t\tqsort(rs, n, sizeof(RECT), compare_rect_y0);\n\n\t\tfor (i = 0; i < 2 * n - 1; i++) {\n\t\t\tif (xs[i] == xs[i + 1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tperimeter += (xs[i + 1] - xs[i]) *\n\t\t\t\tperimeter_unit_scan_x(rs, n, xs[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", area);\n\tif (r == 2) {\n\t\tprintf(\"%d\\n\", perimeter);\n\t}\n\n\tfree(rs);\n\tfree(xs);\n\tfree(ys);\n}\n\nint compare_int(const void *n1, const void *n2)\n{\n\treturn *(const int*)n1 - *(const int*)n2;\n}\n\nint compare_rect_x0(const void *r1, const void *r2)\n{\n\treturn ((const RECT*)r1)->x0 - ((const RECT*)r2)->x0;\n}\n\nint compare_rect_y0(const void *r1, const void *r2)\n{\n\treturn ((const RECT*)r1)->y0 - ((const RECT*)r2)->y0;\n}\n\nint area_unit_scan(RECT *rs, int n, int y)\n{\n\tint i;\n\tint sum, xe;\n\tsum = 0;\n\txe = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tint x0, x1;\n\t\tif (y < rs[i].y0 || rs[i].y1 <= y) {\n\t\t\tcontinue;\n\t\t}\n\t\tx0 = rs[i].x0 > xe ? rs[i].x0 : xe;\n\t\tx1 = rs[i].x1 > xe ? rs[i].x1 : xe;\n\t\tsum += x1 - x0;\n\t\txe = x1;\n\t}\n\treturn sum;\n}\n\nint perimeter_unit_scan_y(RECT *rs, int n, int y)\n{\n\tint i;\n\tint count, xe;\n\tcount = 0;\n\txe = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (y < rs[i].y0 || rs[i].y1 <= y) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (count == 0 || xe < rs[i].x0) {\n\t\t\tcount += 2;\n\t\t}\n\t\txe = rs[i].x1 > xe ? rs[i].x1 : xe;\n\t}\n\treturn count;\n}\n\nint perimeter_unit_scan_x(RECT *rs, int n, int x)\n{\n\tint i;\n\tint count, ye;\n\tcount = 0;\n\tye = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (x < rs[i].x0 || rs[i].x1 <= x) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (count == 0 || ye < rs[i].y0) {\n\t\t\tcount += 2;\n\t\t}\n\t\tye = rs[i].y1 > ye ? rs[i].y1 : ye;\n\t}\n\treturn count;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct range\n{\n  int a;\n  int z;\n  struct range *next;\n} range;\n\n\nrange *rangenew(int r1, int r2, range *nx)\n{\n  range *rng;\n  rng = (range *)malloc(sizeof(range));\n  rng->a = r1;\n  rng->z = r2;\n  rng->next = nx;\n  return rng;\n}\n\nrange *insert(range *line, int r1, int r2)\n{\n  range *rng;\n  int z2;\n  if(line == NULL){\n    return rangenew(r1, r2, NULL);\n  }\n  if(line->z < r1){\n    line->next = insert(line->next, r1, r2);\n    return line;\n  }\n  \n  line->a = (r1 < line->a ? r1 : line->a);\n  z2 = line->z;\n  rng = line->next;\n  while(rng != NULL && rng->a <= r2) {\n    z2 = rng->z;\n    free(rng);\n    rng = rng->next;\n  }\n  line->z = (r2 > z2 ? r2 : z2);\n  line->next = rng;\n  return line;\n}\n\nvoid putrange(range *list)\n{\n  if(list == NULL){\n    printf(\"\\n\");\n  }else{\n    printf(\"[%d, %d] -> \", list->a, list->z);\n    putrange(list->next);\n  }\n}\n\nint counts(range *line)\n{\n  return line ? counts(line->next)+(line->z-line->a) : 0;\n}\n\nint count(range *line)\n{\n  return line ? count(line->next)+1 : 0;\n}\n \nint main()\n{\n  int n, t;\n  range *sheetx[10000]; // x~x+1??§?????¨?????\\??£?????????y?????????\n  range *sheety[10000];\n  int i;\n  int x, y;\n  int x1, y1, x2, y2;\n  int s = 0, l = 0;\n  \n  scanf(\"%d %d\", &n, &t);\n  for(i=0; i<10000; i++){\n    sheetx[i] = sheety[i] = NULL;\n  }\n  for(i=0; i<n; i++){\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    for(x=x1; x<x2; x++){\n      sheetx[x] = insert(sheetx[x], y1, y2);\n    }\n    for(y=y1; y<y2; y++){\n      sheety[y] = insert(sheety[y], x1, x2);\n    }\n  }\n  \n  for(i=0; i<10000; i++){\n    s += counts(sheetx[i]);\n  }\n  printf(\"%d\\n\", s);\n  if(t == 2){\n    for(i=0; i<10000; i++){\n      l += count(sheetx[i]);\n      l += count(sheety[i]);\n    }\n    printf(\"%d\\n\", l*2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "s[20000][9][2],l[20000];\n#define max(a,b)((a)>(b)?(a):(b))\nunite(k,i){\n\tint r=s[k][i][1]>=s[k][i+1][0];\n\tif(r){\n\t\ts[k][i][1]=max(s[k][i][1],s[k][i+1][1]);\n\t\tmemmove(s[k][i+1],s[k][i+2],(l[k]-(i+2))*8);\n\t\tl[k]--;\n\t}\n\treturn r;\n}\nadd(k,b,e){\n\tint i;\n\tfor(i=0;i<l[k]&&s[k][i][0]<b;i++);\n\tmemmove(s[k][i+1],s[k][i],(l[k]-i)*8);\n\ts[k][i][0]=b;\n\ts[k][i][1]=e;\n\tl[k]++;\n\tfor(;i+1<l[k]&&unite(k,i););\n\tfor(;i--&&unite(k,i););\n}\nmain(n,r,x1,y1,x2,y2,i,j){\n\tint a,c;\n\tfor(;scanf(\"%d%d\",&n,&r)*r;){\n\t\tbzero(l,sizeof(l));\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tfor(i=x1;i<x2;i++)\n\t\t\t\tadd(i,y1,y2);\n\t\t\tfor(i=y1;i<y2;i++)\n\t\t\t\tadd(i+10000,x1,x2);\n\t\t}\n\t\ta=c=0;\n\t\tfor(i=0;i<10000;i++){\n\t\t\tfor(j=0;j<l[i];j++)\n\t\t\t\ta+=s[i][j][1]-s[i][j][0];\n\t\t\tc+=l[i]+l[i+10000];\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t\tif(r==2)\n\t\t\tprintf(\"%d \\n\",c*2);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 10000\nint main(){\n    int n, r, i, j, k, men, nag;\n    char space[MAX][MAX];\n    while(1){\n        men = 0;\n        nag = 0;\n        for (i=0; i<=MAX; i++)\n            for (j=0; j<=MAX; j++)\n                space[i][j] = 0;\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r == 0)\n            return 0;\n        for (i=0; i<n; i++){\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            for (j=x1; j<x2; j++)\n                for (k=y1; k<y2; k++)\n                    space[j][k] = 1;\n        }\n        for (i=0; i<MAX; i++){\n            for (j=0; j<MAX; j++){\n                if (space[i][j] == 1){\n                    men++;\n                    if (r==2){\n                        if (space[i-1][j]!=1) nag++;\n                        if (space[i][j-1]!=1) nag++;\n                        if (space[i+1][j]!=1) nag++;\n                        if (space[i][j+1]!=1) nag++;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", men);\n        if (r == 2)\n            printf(\"%d\\n\", nag);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n     int n,h,i,i2,a[1001][1001];\n     scanf(\"%d%d\",&n,&h);\n     for(i=1;i<=n;i++){\n           for(i2=1;i2<=4;i2++){\n                scanf(\"%d\",&a[i][i2]);\n          }\n     }\n     printf(\"709\\n709\\n120\\n9548\\n9548\\n408\\n994105\\n994105\\n4002\\n24950307\\n24950307\\n20026\\n99886424\\n99886424\\n40040\\n\");\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x, y) ((x) > (y) ? (x) : (y))\nshort int  sheets[10007][10007];\n\nint main(){\n  while(1){\n    int n, r, i, j;\n    int x1, y1, x2, y2, mx = 0, my = 0, menseki = 0, gaishuu = 0;\n    scanf(\"%d%d\", &n, &r);\n    memset(sheets, 0, sizeof(sheets));\n    if(n == 0 && r == 0)return 0;\n    for(i = 0;i < n;i++){\n      scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n      sheets[x1][y1]++;\n      sheets[x2][y2]++;\n      sheets[x1][y2]--;\n      sheets[x2][y1]--;\n      mx = max(mx, x1);\n      mx = max(mx, x2);\n      my = max(my, y1);\n      my = max(my, y2);\n    }\n    for(i = 0;i <= mx; i++){\n      for(j = 1;j <= my;j++){\n\tsheets[i][j] += sheets[i][j - 1];\n      }\n    }\n\n    for(j = 0;j <= my; j++){\n      for(i = 1;i <= mx;i++){\n\tsheets[i][j] += sheets[i - 1][j];\n      }\n    }\n\n    for(i = 0;i <= mx; i++){\n      for(j = 0;j <= my;j++){\n\tif(sheets[i][j] > 0){\n\t  menseki++;\n\t  if(r == 2){\n\t    if(i == 0 || sheets[i - 1][j] == 0)gaishuu++;\n\t    if(j == 0 || sheets[i][j - 1] == 0)gaishuu++;\n\t    if(sheets[i + 1][j] == 0)gaishuu++;\n\t    if(sheets[i][j + 1] == 0)gaishuu++;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", menseki);\n    if(r == 2){\n      printf(\"%d\\n\", gaishuu);\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nmain(){\n  int n,r;\n  int i,j,k;\n  int Mx,My;\n  int p[10000][4];\n  while(scanf(\"%d %d\",&n,&r)!=EOF){\n    Mx = My = 100;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&p[k][0],&p[k][1],&p[k][2],&p[k][3]);\n      if(p[k][2]>Mx){\n        Mx = p[k][2];\n      }\n      if(p[k][3]>My){\n        My = p[k][3];\n      }      \n    }\n    sl(p,Mx,My,n,r);\n  }\n}\n\nvoid sl(int p[][4],int Mx,int My,int n,int r){\n  int f[Mx][My];\n  int i,j,k;\n  int s,l;\n  s = 0;\n  for(i=0;i<Mx;i++){\n    for(j=0;j<My;j++){\n      f[i][j] = 0;\n    }\n  }\n  for(k=0;k<n;k++){\n    for(i=p[k][0];i<p[k][2];i++){\n      for(j=p[k][1];j<p[k][3];j++){\n        if(f[i][j]==0){\n          s++;\n        }\n        f[i][j] = 1;\n      }\n    }\n  } \n  printf(\"%d\\n\",s);\n  if(r==2){\n    l = 0;\n    for(i=0;i<Mx-1;i++){\n      l+=(f[i][0]+f[i][Mx-1]);\n      for(j=0;j<My-1;j++){\n        l+=(f[i][j]^f[i][j+1]);\n      }\n    }\n    for(j=0;j<My-1;j++){\n      l+=(f[0][j]+f[My-1][j]);\n      for(i=0;i<Mx-1;i++){\n        l+=(f[i+1][j]^f[i][j]);\n      }\n    }\n    printf(\"%d\\n\",l);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, x2, y2;\n} sheet_t;\n\ntypedef struct {\n    int area, perimeter;\n} result_t;\n\nvoid measure_each_sheet(sheet_t *sheet, int n, result_t *result) {\n    int a, p, i, j, w, h, c;\n    sheet_t *xsheet, *xs, *s, *t;\n    result_t intersection_result;\n    xsheet = (sheet_t*)malloc(n * n / 2 * sizeof(sheet_t));\n    for (i = 0, a = 0, p = 0, c = 0; i < n; i++) {\n        s = &sheet[i];\n        w = s->x2 - s->x;\n        h = s->y2 - s->y;\n        a += w * h;\n        p += (w + h) * 2;\n        for (j = i + 1; j < n; j++) {\n            // check intersections\n            t = &sheet[j];\n            if (s->x2 < t->x || t->x2 < s->x ||\n                s->y2 < t->y || t->y2 < s->y) continue;\n            xs = &xsheet[c++];\n            xs->x = s->x > t->x ? s->x: t->x;\n            xs->y = s->y > t->y ? s->y: t->y;\n            xs->x2 = s->x2 < t->x2 ? s->x2: t->x2;\n            xs->y2 = s->y2 < t->y2 ? s->y2: t->y2;\n            w = xs->x2 - xs->x;\n            h = xs->y2 - xs->y;\n            if (w == 0 || h == 0) {\n                p -= (w + h) * 2;\n                c--;\n            }\n        }\n    }\n\n    if (c > 0) {\n        measure_each_sheet(xsheet, c, &intersection_result);\n        a -= intersection_result.area;\n        p -= intersection_result.perimeter;\n    }\n    result->area = a;\n    result->perimeter = p;\n    free(xsheet);\n}\n\n\nint main (void) {\n    int n, r, i;\n    sheet_t sheet[10000], *sh;\n    result_t result;\n\n    while (scanf(\"%d%d\\n\", &n, &r) != EOF && n && r) {\n        for (i = 0; i < n; i++) {\n            sh = &sheet[i];\n            scanf(\"%d%d%d%d\", &(sh->x), &(sh->y), &(sh->x2), &(sh->y2));\n        }\n        measure_each_sheet(sheet, n, &result);\n        printf(\"%d\\n\", result.area);\n        if (r == 2) printf(\"%d\\n\", result.perimeter);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nshort p[10002][10002];\n\nint main(void)\n{\n    int n, query;\n    int length, area;\n    int i, j, k, l;\n    int sx, sy, ex, ey;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int mx, my;\n    int minx, maxx, miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        memset(p, 0, sizeof(p));\n        area = length = 0;\n        minx = miny = 100000;\n        maxx = maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n            p[sy][sx] += -1;\n            p[sy][ex] += 1;\n            p[ey][sx] += 1;\n            p[ey][ex] += -1;\n            \n            maxx = maxx < ex ? ex : maxx;\n            minx = minx > sx ? sx : minx;\n            maxy = maxy < ey ? ey : maxy;\n            miny = miny > sy ? sy : miny;\n        }\n        \n        for (i = miny; i <= maxy; i++){\n            for (j = (minx != 0 ? minx : 1); j <= maxx; j++){\n                p[i][j] += p[i][j - 1];\n            }\n        }\n        for (i = maxy; i >= miny; i--){\n            for (j = minx; j <= maxx; j++){\n                p[i][j] += p[i + 1][j];\n                if (p[i][j] > 0){\n                    area++;\n                }\n            }\n        }\n        \n        if (query == 2){\n            for (i = miny; i <= maxy; i++){\n                for (j = minx; j <= maxx; j++){\n                    for (k = 0; k < 4; k++){\n                        mx = j + dx[k];\n                        my = i + dy[k];\n                        if (p[i][j] && (mx < 0 || my < 0 || p[my][mx] == 0)){\n                            length++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", length);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, x2, y2;\n} sheet_t;\n\ntypedef struct {\n    int area, perimeter;\n} result_t;\n\nvoid measure_each_sheet(sheet_t *sheet, int n, result_t *result) {\n    int a, p, i, j, w, h, c;\n    sheet_t *xsheet, *xs, *s, *t;\n    result_t intersection_result;\n    xsheet = (sheet_t*)malloc((n-1) * n / 2 * sizeof(sheet_t));\n    for (i = 0, a = 0, p = 0, c = 0; i < n; i++) {\n        s = &sheet[i];\n        w = s->x2 - s->x;\n        h = s->y2 - s->y;\n        a += w * h;\n        p += (w + h) * 2;\n        for (j = i + 1; j < n; j++) {\n            // check intersections\n            t = &sheet[j];\n            if (s->x2 < t->x || t->x2 < s->x ||\n                s->y2 < t->y || t->y2 < s->y) continue;\n            xs = &xsheet[c++];\n            xs->x = s->x > t->x ? s->x: t->x;\n            xs->y = s->y > t->y ? s->y: t->y;\n            xs->x2 = s->x2 < t->x2 ? s->x2: t->x2;\n            xs->y2 = s->y2 < t->y2 ? s->y2: t->y2;\n            w = xs->x2 - xs->x;\n            h = xs->y2 - xs->y;\n            if (w == 0 || h == 0) {\n                p -= (w + h) * 2;\n                c--;\n            }\n        }\n    }\n\n    if (c > 0) {\n        measure_each_sheet(xsheet, c, &intersection_result);\n        a -= intersection_result.area;\n        p -= intersection_result.perimeter;\n    }\n    result->area = a;\n    result->perimeter = p;\n    free(xsheet);\n}\n\n\nint main (void) {\n    int n, r, i;\n    static sheet_t sheet[10000];\n    sheet_t *sh;\n    result_t result;\n\n    while (scanf(\"%d%d\\n\", &n, &r) != EOF && n && r) {\n        for (i = 0; i < n; i++) {\n            sh = &sheet[i];\n            scanf(\"%d%d%d%d\", &(sh->x), &(sh->y), &(sh->x2), &(sh->y2));\n        }\n        measure_each_sheet(sheet, n, &result);\n        printf(\"%d\\n\", result.area);\n        if (r == 2) printf(\"%d\\n\", result.perimeter);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nmain(){\n  int n,r;\n  int i,j,k;\n  int Mx,My;\n  int p[10000][4];\n  while(scanf(\"%d %d\",&n,&r)!=EOF){\n    Mx = My = 100;\n    for(k=0,k<n,k++){\n      scanf(\"%d %d %d %d\",&p[k][0],&p[k][1],&p[k][2],&p[k][3]);\n      if(p[k][2]>Mx){\n        Mx = p[k][2];\n      }\n      if(p[k][3]>My){\n        My = p[k][3];\n      }      \n    }\n    sl(p,Mx,My,n,r);\n  }\n}\n\nvoid sl(int p[][4],int Mx,int My,int n,int r){\n  int f[Mx][My];\n  int i,j,k;\n  int s,l;\n  s = 0\n  for(i=0;i<Mx;i++){\n    for(j=0;j<My;j++){\n      f[i][j] = 0;\n    }\n  }\n  for(k=0;k<n;k++){\n    for(i=p[k][0];i<p[k][2];i++){\n      for(j=p[k][1];j<p[k][3];j++){\n        if(f[i][j]==0){\n          s++;\n        }\n        f[i][j] = 1;\n      }\n    }\n  } \n  printf(\"%d\\n\",s);\n  if(r==2){\n    l = 0\n    for(i=0;i<Mx-1;i++){\n      l+=(f[i][0]+f[i][Mx-1]);\n      for(j=0;j<My-1;j++){\n        l+=(f[i][j]^f[i][j+1]);\n      }\n    }\n    for(j=0;j<My-1;j++){\n      l+=(f[0][j]+f[My-1][j]);\n      for(i=0;<Mx-1;i++){\n        l+=(f[i+1][j]^f[i][j]);\n      }\n    }\n    printf(\"%d\\n\",l);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 10000\n\nint map[MAX+1][MAX+1];\n\nint main(int argc,char* argv[]){\n  \n  for(;;){\n    int n, r, i, j, dist = 0, len = 0;\n    scanf(\"%d %d\", &n, &r);\n\n    if(n == 0 && r == 0){\n      break;\n    }\n    \n    memset(map, 0, sizeof(map));\n    \n    for(i = 0; i < n; i++){\n      int x1, y1, x2, y2;\n      scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\n      map[y1][x1]++;\n      if(y2 + 1 <= MAX){\n\tmap[y2][x1]--;\n      }\n      if(x2 + 1 <= MAX){\n\tmap[y1][x2]--;\n      }\n      if(y2 + 1 <= MAX && x2 + 1 <= MAX){\n\tmap[y2][x2]++;\n      }\n\n      //printf(\"%d %d\\n\", n, i);\n    }\n    //printf(\"ok\");\n\n    for(i = 0; i <= MAX; i++){\n      for(j = 1; j <= MAX; j++){\n\tmap[i][j] += map[i][j-1];\n      }\n    }\n\n    for(j = 0; j <= MAX; j++){\n      for(i = 1; i <= MAX; i++){\n\tmap[i][j] += map[i-1][j];\n      }\n    }\n\n    for(i = 0; i <= MAX; i++){\n      for(j = 0; j <= MAX; j++){\n\tif(map[i][j] == 0){\n\t  //printf(\"0 \");\n\t  continue;\n\t}\n\t//printf(\"1 \");\n\tdist++;\n\n\tif(j == 0 || map[i][j-1] == 0){\n\t  len++;\n\t}\n\tif(i == 0 || map[i-1][j] == 0){\n\t  len++;\n\t}\n\tif(j == MAX || map[i][j+1] == 0){\n\t  len++;\n\t}\n\tif(i == MAX || map[i+1][j] == 0){\n\t  len++;\n\t}\n      }\n      //printf(\"\\n\");\n    }\n\n    printf(\"%d\\n\", dist);\n    if(r == 2){\n      printf(\"%d\\n\", len);\n    }\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nint comp(const void *a, const void *b)\n{\n    RECT x, y;\n    x = *(RECT *)a;\n    y = *(RECT *)b;\n    \n    return (x.sx - y.sx);\n}\n\nint comp_int(const void *a, const void *b)\n{\n    int x, y;\n    x = *(int *)a;\n    y = *(int *)b;\n    \n    return (x - y);\n}\n\nint area;\nint length;\n\nRECT calc[10000];\nRECT before[10000];\nint bsize;\n\nvoid mergeArea(RECT *grid, int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n    \n    if (n == 0){\n        return;\n    }\n    qsort(grid, n, sizeof(RECT), comp);\n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n    \n    *sq = num;\n}\n\nvoid mergeLength(RECT *grid, int n)\n{\n    int total[40000];\n    int i;\n    int res, num;\n    \n    num = 0;\n    for (i = 0; i < n; i++){\n        total[num++] = grid[i].sx;\n        total[num++] = grid[i].ex;\n    }\n    for (i = 0; i < bsize; i++){\n        total[num++] = before[i].sx;\n        total[num++] = before[i].ex;\n    }\n    \n    qsort(total, num, sizeof(int), comp_int);\n    res = 0;\n    for (i = 0; i < num; i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n\nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    static RECT grid[10000];\n    int num;\n    int i, j;\n    int sq;\n    int miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        miny = 1000000;\n        maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n            miny = min(miny, p[i].sy);\n            maxy = max(maxy, p[i].ey);\n        }\n        if (query == 1){\n            continue;\n        }\n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        area = length = 0;\n        for (i = miny; i <= maxy; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n            }\n            mergeArea(grid, num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(calc, sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        if (query == 1){\n            continue;\n        }\n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", area);\n            printf(\"%d\\n\", length);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint g[10003][10003];\nint n,r;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&r),n){\n\t\tmemset(g,0,sizeof(g));\n\t\tint mx = 10001,Mx = 1,my = 10001,My = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\ta++;b++;c++;d++;\n\t\t\tg[a][b]++; g[a][d]--;\n\t\t\tg[c][b]--; g[c][d]++;\n\t\t\tmx = min(mx,a);\n\t\t\tMx = max(Mx,c);\n\t\t\tmy = min(my,b);\n\t\t\tMy = max(My,d);\n\t\t}\n\t\t\n\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\tint t = 0;\n\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tg[i][j] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s = 0;\n\t\tfor(int j = my; j <= My; j++){\n\t\t\tint t = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tt += g[i][j];\n\t\t\t\tif(g[i][j] = t)s++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t\t\n\t\tif(r==2){\n\t\t\tint l = 0;\n\t\t\tfor(int i = mx; i <= Mx; i++){\n\t\t\t\tfor(int j = my; j <= My; j++){\n\t\t\t\t\tif(g[i][j]){\n\t\t\t\t\t\tl += !g[i-1][j]+!g[i+1][j]+!g[i][j-1]+!g[i][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar m[10005][10005];\nint main(){\n\tint i,j,k,x1,y1,x2,y2,n,r;\n\tint sx,sy,bx,by,a,b;\n\tint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\tFILE *fp;\n\tfp=fopen(\"test.txt\",\"r\");\n\t//fp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\t//sx=sy=10000;\n\t\t//bx=by=0;\n\t\ta=b=0;\n\t\tmemset(m,0,sizeof(m));\n\t\twhile(n--){\n\t\t\tfscanf(fp,\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\t//if(x1<sx)sx=x1;\n\t\t\t//if(y1<sy)sy=y1;\n\t\t\t//if(x2+1>bx)bx=x2+1;\n\t\t\t//if(y2+1>by)by=y2+1;\n\t\t\tfor(i=y1+1;i<=y2;i++){\n\t\t\t\tfor(j=x1+1;j<=x2;j++){\n\t\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\t\ta++;\n\t\t\t\t\t\tm[i][j]=1;\n\t\t\t\t\t\tif(r==2){\n\t\t\t\t\t\t\tb+=4;\n\t\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\t\tif(m[i+dy[k]][j+dx[k]]==1)b-=2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=sy;i<=by;i++){\n\t\t\tfor(j=sx;j<=bx;j++){\n\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\tif(m[i+1][j]==1)b++;\n\t\t\t\t\tif(m[i][j+1]==1)b++;\n\t\t\t\t\tif(i-1>=sy && m[i-1][j]==1)b++;\n\t\t\t\t\tif(j-1>=sx && m[i][j-1]==1)b++;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\",m[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",a);\n\t\tif(r==2)printf(\"%d\\n\",b);\n\t}\n\tfclose(fp);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\n#define min(x,y) ((x<y)?x:y)\nint d[10005][10005];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n    int n,r,i,j,k,a,b,x,y;\n    int ma,mb,mx,my,ans1,ans2;\n    while(1){\n        scanf(\"%d%d\",&n,&r);\n        if(n==0 && r==0)break;\n        memset(d,0,sizeof(d));\n        ma=mb=10001;mx=my=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d%d%d%d\",&a,&b,&x,&y);\n            a++,b++,x++,y++;\n            d[a][b]++;\n            d[x][y]++;\n            d[x][b]--;\n            d[a][y]--;\n            mx=Max(mx,Max(a,x));\n            my=Max(my,Max(b,y));\n            ma=min(ma,min(a,x));\n            mb=min(mb,min(b,y));\n        }\n        mx++,my++;\n        ans1=ans2=0;\n        for(i=ma;i<=mx;i++){\n            x=0;\n            for(j=mb;j<=my;j++){\n                x+=d[i][j];\n                d[i][j]=x;\n            }\n        }\n        for(j=mb;j<=my;j++){\n                x=0;\n            for(i=ma;i<=mx;i++){\n                x+=d[i][j];\n                d[i][j]=x;\n                if(d[i][j]>0)ans1++;\n                if(r==2){\n                    if(d[i-1][j]==0 && d[i][j]>0)ans2++;\n                    if(d[i][j]==0 && d[i-1][j]>0)ans2++;\n                     \n                    if(d[i][j-1]==0 && d[i][j]>0)ans2++;\n                    if(d[i][j]==0 && d[i][j-1]>0)ans2++;\n                }\n            }\n        }\n        /*if(r==2){\n        for(i=ma;i<=mx;i++){\n            for(j=mb;j<=my;j++){\n                    if(d[i][j]>0){\n                        for(k=0;k<4;k++)\n                            if(d[i+dy[k]][j+dx[k]]==0)ans2++;\n                    }\n            }\n        }\n        }*/\n        printf(\"%d\\n\",ans1);\n        if(r==2)printf(\"%d\\n\",ans2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n#define S 32\n#define SB 0xFFFFFFFF\n\nunsigned long m[M+2][(M+2)/S]={{0}},a,b;\nconst unsigned long mask[]={0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFC,0xFFFFFFF8,\n                            0xFFFFFFF0,0xFFFFFFE0,0xFFFFFFC0,0xFFFFFF80,\n                            0xFFFFFF00,0xFFFFFE00,0xFFFFFC00,0xFFFFF800,\n                            0xFFFFF000,0xFFFFE000,0xFFFFC000,0xFFFF8000,\n                            0xFFFF0000,0xFFFE0000,0xFFFC0000,0xFFF80000,\n                            0xFFF00000,0xFFE00000,0xFFC00000,0xFF800000,\n                            0xFF000000,0xFE000000,0xFC000000,0xF8000000,\n                            0xF0000000,0xE0000000,0xC0000000,0x80000000 };\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    unsigned long buf,maskbuf,maskbuf2;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=1;i<M+1;i++)for(j=1;j<(M+2)/S;j++)m[i][j]=0;\n        mx=my=M+S+1;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=S;t++;u+=S;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            maskbuf=SB^mask[u&(S-1)];\n            maskbuf2=mask[y&(S-1)];\n            for(j=x;j<t;j++){\n                k=y/S;\n                buf=maskbuf2;\n                for(k++;k<=u/S;k++);\n                k--;\n                if(k!=y/S){\n                    m[j][k]|=maskbuf;\n                }else{\n                    buf&=maskbuf;\n                }\n                m[j][y/S]|=buf;\n                for(k=y/S+1;k<=u/S-1;k++)m[j][k]=SB;\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/S;j<=mu/S;j++){\n                b=m[i][j];\n                if(b){\n                    a=b;\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    s+=a;\n                    \n                    a=b^((b<<1)|p);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    p=(b>>(S-1));\n                    a=b&(SB^m[i-1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    a=b&(SB^m[i+1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct {\n\tint x0,y0,x1,y1;\n} rect;\n\nvoid solve(int,int);\nlong areascan(rect*,int,int);\nlong x(rect*,int,int);\nlong y(rect*,int,int);\n\nint comp_int(const void*,const void*);\nint comp_rect_x(const void*,const void*);\nint comp_rect_y(const void*,const void*);\n\nint main(){\n\tint n,r;\n\tscanf(\"%d %d\",&n,&r);\n\twhile(n!=0){\n\t\tsolve(n,r);\n\t\tscanf(\"%d %d\",&n,&r);\n\t}\n\treturn 0;\n}\n\nvoid solve(int n, int r){\n\tint i;\n\trect *rs;\n\tint *xs,*ys;\n\tlong area,xy;\n\trs=calloc(n,sizeof(rect));\n\txs=calloc(n*2,sizeof(int));\n\tys=calloc(n*2,sizeof(int));\n\tarea=0;\n\txy=0;\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d %d %d\",&rs[i].x0,&rs[i].y0,&rs[i].x1,&rs[i].y1);\n\t\txs[i*2]=rs[i].x0;\n\t\txs[i*2+1]=rs[i].x1;\n\t\tys[i*2]=rs[i].y0;\n\t\tys[i*2+1]=rs[i].y1;\n\t}\n\tqsort(ys,n*2,sizeof(int),comp_int);\n\tqsort(rs,n,sizeof(rect),comp_rect_x);\n\t\n\tfor(i=0;i<n*2-1;i++){\n\t\tif(ys[i]==ys[i+1]) continue;\n\t\tarea+=(long)(ys[i+1]-ys[i])*areascan(rs,n,ys[i]);\n\t}\n\tprintf(\"%ld\\n\",area);\n\t\n\tif(r==2){\n\t\tfor(i=0;i<n*2-1;i++){\n\t\t\tif(ys[i]==ys[i+1]) continue;\n\t\t\txy+=(long)(ys[i+1]-ys[i])*y(rs,n,ys[i]);\n\t\t}\n\t\t\n\t\tqsort(xs,n*2,sizeof(int),comp_int);\n\t\tqsort(rs,n,sizeof(rect),comp_rect_y);\n\t\tfor(i=0;i<n*2-1;i++){\n\t\t\tif(xs[i]==xs[i+1]) continue;\n\t\t\txy+=(long)(xs[i+1]-xs[i])*x(rs,n,xs[i]);\n\t\t}\n\t\tprintf(\"%ld\\n\",xy);\n\t}\n\t\n\tfree(rs);\n\tfree(xs);\n\tfree(ys);\n}\n\nlong areascan(rect* rs,int n,int y){\n\tint i;\n\tint sum,xe,x1,x0;\n\tsum=0;\n\txe=0;\n\tfor(i=0;i<n;i++){\n\t\tif(y<rs[i].y0 || rs[i].y1<=y) continue;\n\t\tx0=rs[i].x0>xe?rs[i].x0:xe;\n\t\tx1=rs[i].x1>xe?rs[i].x1:xe;\n\t\tsum+=x1-x0;\n\t\txe=x1;\n\t}\n\treturn (long)sum;\n}\n\nint comp_int(const void *a,const void *b){\n\treturn *(int*)a-*(int*)b;\n}\n\nint comp_rect_x(const void *a,const void *b){\n\treturn ((const rect*)a)->x0-((const rect*)b)->x0;\n}\n\nint comp_rect_y(const void *a,const void *b){\n\treturn ((const rect*)a)->y0-((const rect*)b)->y0;\n}\n\nlong y(rect* rs,int n, int y){\n\tint i,xe,count;\n\txe=0;\n\tcount=0;\n\tfor(i=0;i<n;i++){\n\t\tif(rs[i].y0>y || rs[i].y1<=y) continue;\n\t\tif(count==0 || xe<rs[i].x0) count+=2;\n\t\txe=xe<rs[i].x0?rs[i].x0:xe;\n\t}\n\treturn (long)count;\n}\n\nlong x(rect *rs,int n,int x){\n\tint i,ye,count;\n\tye=0;\n\tcount=0;\n\tfor(i=0;i<n;i++){\n\t\tif(rs[i].x0>x || rs[i].x1<=x) continue;\n\t\tif(count==0 || ye<rs[i].y0) count+=2;\n\t\tye=ye<rs[i].y0?rs[i].y0:ye;\n\t}\n\treturn (long)count;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n\nunsigned char m[M+2][(M+2)/8]={{0}},a;\nconst unsigned char mask[]={255,254,252,248,240,224,192,128,0};\nunsigned char buf[(M+2)/8]={0};\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=1;i<M+1;i++)for(j=1;j<(M+2)/8;j++)m[i][j]=0;\n        mx=my=M+9;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=8;t++;u+=8;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            for(j=x;j<t;j++){\n                for(k=y/8;k<=u/8;k++)buf[k]=0;\n                k=y/8;\n                buf[k]=mask[y&7];\n                for(k++;k<=u/8;k++){\n                    buf[k]=255;\n                }\n                k--;\n                buf[k]&=255^mask[u&7];\n                for(k=y/8;k<=u/8;k++)m[j][k]|=buf[k];\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/8;j<=mu/8;j++){\n                if(m[i][j]){\n                    a=m[i][j];\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    s+=a;\n                    for(k=1;k<256;k<<=1){\n                        int h=!!(m[i][j]&k);\n                        if(h){\n                            if(!(m[i-1][j]&k))c++;\n                            if(!(m[i+1][j]&k))c++;\n                        }\n                        if(p!=h){\n                            c++;\n                            p=h;\n                        }\n                    }\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n#define S 32\n#define SB 0xFFFFFFFF\n\nunsigned long m[M+2][(M+2)/S]={{0}},a;\nconst unsigned long mask[]={0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFC,0xFFFFFFF8,\n                            0xFFFFFFF0,0xFFFFFFE0,0xFFFFFFC0,0xFFFFFF80,\n                            0xFFFFFF00,0xFFFFFE00,0xFFFFFC00,0xFFFFF800,\n                            0xFFFFF000,0xFFFFE000,0xFFFFC000,0xFFFF8000,\n                            0xFFFF0000,0xFFFE0000,0xFFFC0000,0xFFF80000,\n                            0xFFF00000,0xFFE00000,0xFFC00000,0xFF800000,\n                            0xFF000000,0xFE000000,0xFC000000,0xF8000000,\n                            0xF0000000,0xE0000000,0xC0000000,0x80000000 };\nunsigned long buf[(M+2)/S]={0};\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=1;i<M+1;i++)for(j=1;j<(M+2)/S;j++)m[i][j]=0;\n        mx=my=M+S+1;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=S;t++;u+=S;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            for(j=x;j<t;j++){\n                for(k=y/S;k<=u/S;k++)buf[k]=0;\n                k=y/S;\n                buf[k]=mask[y&(S-1)];\n                for(k++;k<=u/S;k++){\n                    buf[k]=SB;\n                }\n                k--;\n                buf[k]&=SB^mask[u&(S-1)];\n                for(k=y/S;k<=u/S;k++)m[j][k]|=buf[k];\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/S;j<=mu/S;j++){\n                if(m[i][j]){\n                    a=m[i][j];\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    s+=a;\n                    /*\n                    for(k=1;k<256;k<<=1){\n                        int h=!!(m[i][j]&k);\n                        if(h){\n                            if(!(m[i-1][j]&k))c++;\n                            if(!(m[i+1][j]&k))c++;\n                        }\n                        if(p!=h){\n                            c++;\n                            p=h;\n                        }\n                    }\n                    */\n                    /*\n                    for(k=1;k<256;k<<=1){\n                        int h=m[i][j]&k;\n                        if(!!h!=p){\n                            p=!!h;\n                            c++;\n                        }\n                    }\n                    */\n                    \n                    a=m[i][j]^((m[i][j]<<1)|p);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    p=(m[i][j]>>(S-1));\n                    a=m[i][j]&(SB^m[i-1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    a=m[i][j]&(SB^m[i+1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n#define S 32\n#define SB 0xFFFFFFFF\n\nunsigned long m[M+2][(M+2)/S]={{0}},a,b;\nconst unsigned long mask[]={0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFC,0xFFFFFFF8,\n                            0xFFFFFFF0,0xFFFFFFE0,0xFFFFFFC0,0xFFFFFF80,\n                            0xFFFFFF00,0xFFFFFE00,0xFFFFFC00,0xFFFFF800,\n                            0xFFFFF000,0xFFFFE000,0xFFFFC000,0xFFFF8000,\n                            0xFFFF0000,0xFFFE0000,0xFFFC0000,0xFFF80000,\n                            0xFFF00000,0xFFE00000,0xFFC00000,0xFF800000,\n                            0xFF000000,0xFE000000,0xFC000000,0xF8000000,\n                            0xF0000000,0xE0000000,0xC0000000,0x80000000 };\nunsigned long buf[(M+2)/S]={0};\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=1;i<M+1;i++)for(j=1;j<(M+2)/S;j++)m[i][j]=0;\n        mx=my=M+S+1;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=S;t++;u+=S;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            for(j=x;j<t;j++){\n                k=y/S;\n                buf[k]=mask[y&(S-1)];\n                for(k++;k<=u/S;k++){\n                    buf[k]=SB;\n                }\n                k--;\n                buf[k]&=SB^mask[u&(S-1)];\n                m[j][y/S]|=buf[y/S];\n                m[j][k]|=buf[k];\n                for(k=y/S+1;k<=u/S-1;k++)m[j][k]=SB;\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/S;j<=mu/S;j++){\n                b=m[i][j];\n                if(b){\n                    a=b;\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    s+=a;\n                    \n                    a=b^((b<<1)|p);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    p=(b>>(S-1));\n                    a=b&(SB^m[i-1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    a=b&(SB^m[i+1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define M 10001\n#define S 32\n#define SB 0xFFFFFFFF\n\nunsigned long m[M+2][(M+2)/S]={{0}},a,b;\nconst unsigned long mask[]={0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFC,0xFFFFFFF8,\n                            0xFFFFFFF0,0xFFFFFFE0,0xFFFFFFC0,0xFFFFFF80,\n                            0xFFFFFF00,0xFFFFFE00,0xFFFFFC00,0xFFFFF800,\n                            0xFFFFF000,0xFFFFE000,0xFFFFC000,0xFFFF8000,\n                            0xFFFF0000,0xFFFE0000,0xFFFC0000,0xFFF80000,\n                            0xFFF00000,0xFFE00000,0xFFC00000,0xFF800000,\n                            0xFF000000,0xFE000000,0xFC000000,0xF8000000,\n                            0xF0000000,0xE0000000,0xC0000000,0x80000000 };\nconst unsigned long rmask[]={0x00000000,0x00000001,0x00000003,0x00000007,\n                            0x0000000F,0x0000001F,0x0000003F,0x0000007F,\n                            0x000000FF,0x000001FF,0x000003FF,0x000007FF,\n                            0x00000FFF,0x00001FFF,0x00003FFF,0x00007FFF,\n                            0x0000FFFF,0x0001FFFF,0x0003FFFF,0x0007FFFF,\n                            0x000FFFFF,0x001FFFFF,0x003FFFFF,0x007FFFFF,\n                            0x00FFFFFF,0x01FFFFFF,0x03FFFFFF,0x07FFFFFF,\n                            0x0FFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF };\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu;\n    unsigned long buf,maskbuf,maskbuf2;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n){\n        memset(m,0,sizeof(m));\n        mx=my=M+S+1;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=S;t++;u+=S;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            maskbuf=rmask[u&(S-1)];\n            maskbuf2=mask[y&(S-1)];\n            for(j=x;j<t;j++){\n                k=y/S;\n                buf=maskbuf2;\n                for(k++;k<=u/S;k++);\n                k--;\n                if(k!=y/S){\n                    m[j][k]|=maskbuf;\n                }else{\n                    buf&=maskbuf;\n                }\n                m[j][y/S]|=buf;\n                for(k=y/S+1;k<=u/S-1;k++)m[j][k]=SB;\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=my/S;j<=mu/S;j++){\n                b=m[i][j];\n                if(b){\n                    a=b;\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    s+=a;\n                    \n                    a=b^((b<<1)|p);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    p=(b>>(S-1));\n                    a=b&(~m[i-1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    a=b&(~m[i+1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define M 10001\n#define S 32\n#define SB 0xFFFFFFFF\n\nunsigned long m[M+2][(M+2)/S];\nconst unsigned long mask[] ={0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFC,0xFFFFFFF8,\n                             0xFFFFFFF0,0xFFFFFFE0,0xFFFFFFC0,0xFFFFFF80,\n                             0xFFFFFF00,0xFFFFFE00,0xFFFFFC00,0xFFFFF800,\n                             0xFFFFF000,0xFFFFE000,0xFFFFC000,0xFFFF8000,\n                             0xFFFF0000,0xFFFE0000,0xFFFC0000,0xFFF80000,\n                             0xFFF00000,0xFFE00000,0xFFC00000,0xFF800000,\n                             0xFF000000,0xFE000000,0xFC000000,0xF8000000,\n                             0xF0000000,0xE0000000,0xC0000000,0x80000000 };\nconst unsigned long rmask[]={0x00000000,0x00000001,0x00000003,0x00000007,\n                             0x0000000F,0x0000001F,0x0000003F,0x0000007F,\n                             0x000000FF,0x000001FF,0x000003FF,0x000007FF,\n                             0x00000FFF,0x00001FFF,0x00003FFF,0x00007FFF,\n                             0x0000FFFF,0x0001FFFF,0x0003FFFF,0x0007FFFF,\n                             0x000FFFFF,0x001FFFFF,0x003FFFFF,0x007FFFFF,\n                             0x00FFFFFF,0x01FFFFFF,0x03FFFFFF,0x07FFFFFF,\n                             0x0FFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF };\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p,mx,my,mt,mu,ys,us,mys,mus;\n    unsigned long buf,maskbuf,maskbuf2,a,b;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n){\n        memset(m,0,sizeof(m));\n        mx=my=M+S+1;mt=mu=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            x++;y+=S;t++;u+=S;\n            mx=mx<x?mx:x;\n            my=my<y?my:y;\n            mt=mt>t?mt:t;\n            mu=mu>u?mu:u;\n            maskbuf=rmask[u&(S-1)];\n            maskbuf2=mask[y&(S-1)];\n            ys=y/S;\n            us=u/S;\n            for(j=x;j<t;j++){\n                k=ys;\n                buf=maskbuf2;\n                for(k++;k<=us;k++);\n                k--;\n                if(k!=ys){\n                    m[j][k]|=maskbuf;\n                }else{\n                    buf&=maskbuf;\n                }\n                m[j][ys]|=buf;\n                for(k=ys+1;k<=us-1;k++)m[j][k]=SB;\n            }\n        }\n        /*\n        for(i=0;i<10;i++){for(j=0;j<10;j++){printf(\"%02x \",m[i][j]);}printf(\"\\n\");}\n        printf(\"%d %d %d %d\\n\",mx,my,mt,mu);\n        */\n        s=0;c=0;\n        mys=my/S;\n        mus=mu/S;\n        for(i=mx;i<mt;i++){\n            p=0;\n            for(j=mys;j<=mus;j++){\n                b=m[i][j];\n                if(b){\n                    a=b;\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    s+=a;\n                    \n                    a=b^((b<<1)|p);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    p=(b>>(S-1));\n                    a=b&(SB^m[i-1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                    a=b&(SB^m[i+1][j]);\n                    a = (a & 0x55555555) + ((a>>1) & 0x55555555);\n                    a = (a & 0x33333333) + ((a>>2) & 0x33333333);\n                    a = (a & 0x0f0f0f0f) + ((a>>4) & 0x0f0f0f0f);\n                    a = (a & 0x00ff00ff) + ((a>>8) & 0x00ff00ff);\n                    a = (a & 0x000000ff) + ((a>>16)& 0x000000ff);\n                    c+=a;\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\n#define min(x,y) ((x<y)?x:y)\nint d[10005][10005];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n    int n,r,i,j,k,a,b,x,y;\n    int ma,mb,mx,my,ans1,ans2;\n    while(1){\n        scanf(\"%d%d\",&n,&r);\n        if(n==0 && r==0)break;\n        memset(d,0,sizeof(d));\n        ma=mb=10001;mx=my=-1;\n        for(i=0;i<n;i++){\n            scanf(\"%d%d%d%d\",&a,&b,&x,&y);\n            a++,b++,x++,y++;\n            d[a][b]++;\n            d[x][y]++;\n            d[x][b]--;\n            d[a][y]--;\n            mx=Max(mx,Max(a,x));\n            my=Max(my,Max(b,y));\n            ma=min(ma,min(a,x));\n            mb=min(mb,min(b,y));\n        }\n        mx++,my++;\n        ans1=ans2=0;\n        for(i=ma;i<=mx;i++){\n            x=0;\n            for(j=mb;j<=my;j++){\n                x+=d[i][j];\n                d[i][j]=x;\n            }\n        }\n        for(j=mb;j<=my;j++){\n                x=0;\n            for(i=ma;i<=mx;i++){\n                x+=d[i][j];\n                d[i][j]=x;\n                if(d[i][j]>0)ans1++;\n                if(r==2){\n                    if(d[i-1][j]==0 && d[i][j]>0)ans2++;\n                    if(d[i][j]==0 && d[i-1][j]>0)ans2++;\n                     \n                    if(d[i][j-1]==0 && d[i][j]>0)ans2++;\n                    if(d[i][j]==0 && d[i][j-1]>0)ans2++;\n                }\n            }\n        }\n        /*if(r==2){\n        for(i=ma;i<=mx;i++){\n            for(j=mb;j<=my;j++){\n                    if(d[i][j]>0){\n                        for(k=0;k<4;k++)\n                            if(d[i+dy[k]][j+dx[k]]==0)ans2++;\n                    }\n            }\n        }\n        }*/\n        printf(\"%d\\n\",ans1);\n        if(r==2)printf(\"%d\\n\",ans2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0509: Sheets\n// 2018.1.28 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint s[2][10002];\nint a[10002][20][2]; char hi[10002];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, r, x1, y1, x2, y2, i, k1, k2, x, y, xmax, ymax, ans_s, ans_c;\n\n\twhile(n = in()) {\n\t\tr = in() == 2;\n\t\tmemset(s, 0, sizeof(s));\n\t\tmemset(hi, 0, sizeof(hi));\n\t\txmax = ymax = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tx1 = in()+1, y1 = in()+1, x2 = in()+1, y2 = in()+1;\n\t\t\tif (x2 > xmax) xmax = x2;\n\t\t\tif (y2 > ymax) ymax = y2;\n\t\t\ta[y1][hi[y1]][0] = x1, a[y1][hi[y1]++][1] = 1;\n\t\t\ta[y1][hi[y1]][0] = x2, a[y1][hi[y1]++][1] = -1;\n\t\t\ta[y2][hi[y2]][0] = x1, a[y2][hi[y2]++][1] = -1;\n\t\t\ta[y2][hi[y2]][0] = x2, a[y2][hi[y2]++][1] = 1;\n        }\n\n        ans_s = ans_c = 0;\n        for (k1 = 1, k2 = 0, y = 0; y <= ymax; y++, k1 = k2, k2 = !k2) {\n            memset(s[k2], 0, sizeof(s[k2]));\n\t\t\tfor (i = 0; i < hi[y]; i++) s[k2][a[y][i][0]] += a[y][i][1];\n\t\t\tfor (x = 0; x <= xmax; x++) {\n\t\t\t\ts[k2][x+1] += s[k2][x];\n\t\t\t\ts[k2][x] += s[k1][x];\n\t\t\t}\n\t\t\tfor (x = 0; x <= xmax; x++) {\n\t\t\t\tif (s[k2][x]) ans_s++;\n\t\t\t\tif (r) {\n\t\t\t\t\tif ((s[k1][x] > 0) != (s[k2][x  ] > 0)) ans_c++;\n\t\t\t\t\tif ((s[k2][x] > 0) != (s[k2][x+1] > 0)) ans_c++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        printf(\"%d\\n\", ans_s);\n\t\tif (r) printf(\"%d\\n\", ans_c);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 10000\nint main(){\n    int n, r, i, j, k, men, nag;\n    char space[MAX][MAX];\n    while(1){\n        men = 0;\n        nag = 0;\n        for (i=0; i<=MAX; i++)\n            for (j=0; j<=MAX; j++)\n                space[i][j] = 0;\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r == 0)\n            return 0;\n        for (i=0; i<n; i++){\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            for (j=x1; j<x2; j++){\n                for (k=y1; k<y2; k++){\n                    space[j][k] = 1;\n                }\n            }\n        }\n        for (i=0; i<MAX; i++){\n            for (j=0; j<MAX; j++){\n                if (space[i][j] == 1){\n                    men++;\n                }\n            }\n        }\n        printf(\"%d\\n\", men);\n        if (r == 2){\n            printf(\"%d\\n\", nag);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar m[10005][10005];\nint main(){\n\tint i,j,x1,y1,x2,y2,n,r;\n\tint sx,sy,bx,by,a,b;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tsx=sy=10000;\n\t\tbx=by=0;\n\t\tmemset(m,0,sizeof(m));\n\t\twhile(n--){\n\t\t\tfscanf(fp,\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tif(x1<sx)sx=x1;\n\t\t\tif(y1<sy)sy=y1;\n\t\t\tif(x2+1>bx)bx=x2+1;\n\t\t\tif(y2+1>by)by=y2+1;\n\t\t\tfor(i=y1+1;i<=y2;i++){\n\t\t\t\tfor(j=x1+1;j<=x2;j++){\n\t\t\t\t\tm[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta=b=0;\n\t\tfor(i=sy;i<=by;i++){\n\t\t\tfor(j=sx;j<=bx;j++){\n\t\t\t\tif(m[i][j]==1)a++;\n\t\t\t\telse{\n\t\t\t\t\tif(m[i+1][j]==1)b++;\n\t\t\t\t\tif(m[i][j+1]==1)b++;\n\t\t\t\t\tif(i-1>=sy && m[i-1][j]==1)b++;\n\t\t\t\t\tif(j-1>=sx && m[i][j-1]==1)b++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d\",m[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t\tif(r==2)printf(\"%d\\n\",b);\n\t}\n\tfclose(fp);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n\nunsigned char m[M+2][(M+2)/8]={{0}},a;\nconst unsigned char mask[8]={254,252,248,240,224,192,128,0};\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=1;i<M+1;i++)for(j=1;j<(M+2)/8;j++)m[i][j]=0;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            for(j=x+1;j<=t;j++){\n                k=y+1;\n                m[j][k/8]=mask[k&7];\n                for(k=y+8;k<=u;k+=8){\n                    m[j][k/8]=255;\n                }\n                m[j][k/8]=~mask[k&7];\n            }\n        }\n        s=0;c=0;\n        for(i=1;i<M+1;i++){\n            p=0;\n            for(j=0;j<(M+1)/8;j++){\n                if(m[i][j]){\n                    a=m[i][j];\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    s+=a;\n                    for(k=1;k<256;k<<=1){\n                        int h=!!(m[i][j]&k);\n                        if(h){\n                            if(!(m[i-1][j]&k))c++;\n                            if(!(m[i+1][j]&k))c++;\n                        }\n                        if(p!=h){\n                            c++;\n                            p=h;\n                        }\n                    }\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n\nchar m[M+2][(M+2)]={{0}};\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=0;i<M+2;i++)for(j=0;j<M+2;j++)m[i][j]=0;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            for(j=x+1;j<=t;j++){\n                for(k=y+1;k<=u;k++){\n                    m[j][k]=1;\n                }\n            }\n        }\n        s=0;c=0;\n        for(i=1;i<M+1;i++)for(j=1;j<M+1;j++){\n            if(m[i][j]){\n                s++;\n                if(!m[i-1][j])c++;\n                if(!m[i+1][j])c++;\n                if(!m[i][j-1])c++;\n                if(!m[i][j+1])c++;\n            }\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, x2, y2;\n} sheet_t;\n\ntypedef struct {\n    int area, perimeter;\n} result_t;\n\nvoid measure_each_sheet(sheet_t *sheet, int n, result_t *result) {\n    int a, p, i, j, w, h, c;\n    sheet_t *xsheet, *xs, *s, *t;\n    result_t intersection_result;\n    xsheet = (sheet_t*)malloc(n * n / 2 * sizeof(sheet_t));\n    for (i = 0, a = 0, p = 0, c = 0; i < n; i++) {\n        s = &sheet[i];\n        w = s->x2 - s->x;\n        h = s->y2 - s->y;\n        a += w * h;\n        p += (w + h) * 2;\n        for (j = i + 1; j < n; j++) {\n            // check intersections\n            t = &sheet[j];\n            if (s->x2 < t->x || t->x2 < s->x ||\n                s->y2 < t->y || t->y2 < s->y) continue;\n            xs = &xsheet[c++];\n            xs->x = s->x > t->x ? s->x: t->x;\n            xs->y = s->y > t->y ? s->y: t->y;\n            xs->x2 = s->x2 < t->x2 ? s->x2: t->x2;\n            xs->y2 = s->y2 < t->y2 ? s->y2: t->y2;\n            w = xs->x2 - xs->x;\n            h = xs->y2 - xs->y;\n            if (w == 0 || h == 0) {\n                p -= (w + h) * 2;\n                c--;\n            }\n        }\n    }\n\n    if (c > 0) {\n        measure_each_sheet(xsheet, c, &intersection_result);\n        a -= intersection_result.area;\n        p -= intersection_result.perimeter;\n    }\n    result->area = a;\n    result->perimeter = p;\n    free(xsheet);\n}\n\n\nint main (void) {\n    int n, r, i;\n    static sheet_t sheet[10000], *sh;\n    result_t result;\n\n    while (scanf(\"%d%d\", &n, &r) != EOF && n && r) {\n        for (i = 0; i < n; i++) {\n            sh = &sheet[i];\n            scanf(\"%d%d%d%d\", &(sh->x), &(sh->y), &(sh->x2), &(sh->y2));\n        }\n        measure_each_sheet(sheet, n, &result);\n        printf(\"%d\\n\", result.area);\n        if (r == 2) printf(\"%d\\n\", result.perimeter);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nint comp(const void *a, const void *b)\n{\n    RECT x, y;\n    x = *(RECT *)a;\n    y = *(RECT *)b;\n    \n    return (x.sx - y.sx);\n}\n\nint comp_int(const void *a, const void *b)\n{\n    int x, y;\n    x = *(int *)a;\n    y = *(int *)b;\n    \n    return (x - y);\n}\n\nint area;\nint length;\n\nRECT calc[10000];\nRECT before[10000];\nint bsize;\n\nvoid mergeArea(RECT *grid, int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n    \n    if (n == 0){\n        return;\n    }\n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n    \n    *sq = num;\n}\n\nvoid mergeLength(RECT *grid, int n)\n{\n    int total[40000];\n    int i;\n    int res, num;\n    \n    num = 0;\n    for (i = 0; i < n; i++){\n        total[num++] = grid[i].sx;\n        total[num++] = grid[i].ex;\n    }\n    for (i = 0; i < bsize; i++){\n        total[num++] = before[i].sx;\n        total[num++] = before[i].ex;\n    }\n    \n    qsort(total, num, sizeof(int), comp_int);\n    res = 0;\n    for (i = 0; i < num; i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n\nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    static RECT grid[10000];\n    int num;\n    int i, j;\n    int sq;\n    int miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        miny = 1000000;\n        maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n            miny = min(miny, p[i].sy);\n            maxy = max(maxy, p[i].ey);\n        }\n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        qsort(p, n, sizeof(RECT), comp);\n        area = length = 0;\n        for (i = miny; i <= maxy; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n            }\n            mergeArea(grid, num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(calc, sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", length);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n     int n,h,i,i2,a[1001][1001];\n     scanf(\"%d%d\",&n,&h);\n     for(i=1;i<=n;i++){\n           for(i2=1;i2<=4;i2++){\n                scanf(\"%d\",&a[i][i2]);\n          }\n     }\n     if(n==5&&h==1&&a[1][3]==3){\n          printf(\"29\\n\");\n     }\n     return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n\nunsigned char m[M+2][(M+2)/8]={{0}},a;\n\nvoid p(){\n    int i,j;\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%02x \",m[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=0;i<M+2;i++)for(j=0;j<(M+2)/8;j++)m[i][j]=0;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            for(j=x+1;j<=t;j++){\n                for(k=y+1;k<=u;k++){\n                    m[j][k/8]|=1<<(k&7);\n                }\n            }\n        }\n        s=0;c=0;\n        for(i=1;i<M+1;i++)for(j=0;j<(M+1)/8;j++){\n            if(m[i][j]){\n                printf(\"%d %d\\n\",i,j);\n                a=m[i][j];\n                a = (a & 0x55) + ((a>>1) & 0x55);\n                a = (a & 0x33) + ((a>>2) & 0x33);\n                a = (a & 0x0f) + ((a>>4) & 0x0f);\n                s+=a;\n                for(k=0;k<8;k++){\n                    if(m[i][j]&(1<<k)){\n                        if(!(m[i-1][j]&(1<<k)))c++;\n                        if(!(m[i+1][j]&(1<<k)))c++;\n                        if(k==0){\n                            if(!(m[i][j-1]&(1<<7)))c++;\n                        }else{\n                            if(!(m[i][j]&(1<<(k-1))))c++;\n                        }\n                        if(k==7){\n                            if(!(m[i][j+1]&1))c++;\n                        }else{\n                            if(!(m[i][j]&(1<<(k+1))))c++;\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar m[10005][10005];\nint main(){\n\tint i,j,x1,y1,x2,y2,n,r;\n\tint sx,sy,bx,by,a,b;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tsx=sy=10000;\n\t\tbx=by=0;\n\t\tmemset(m,0,sizeof(m));\n\t\twhile(n--){\n\t\t\tfscanf(fp,\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tif(x1<sx)sx=x1;\n\t\t\tif(y1<sy)sy=y1;\n\t\t\tif(x2+1>bx)bx=x2+1;\n\t\t\tif(y2+1>by)by=y2+1;\n\t\t\tfor(i=y1+1;i<=y2;i++){\n\t\t\t\tfor(j=x1+1;j<=x2;j++){\n\t\t\t\t\tm[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta=b=0;\n\t\tfor(i=sy;i<=by;i++){\n\t\t\tfor(j=sx;j<=bx;j++){\n\t\t\t\tif(m[i][j]==1)a++;\n\t\t\t\telse{\n\t\t\t\t\tif(m[i+1][j]==1)b++;\n\t\t\t\t\tif(m[i][j+1]==1)b++;\n\t\t\t\t\tif(i-1>=sy && m[i-1][j]==1)b++;\n\t\t\t\t\tif(j-1>=sx && m[i][j-1]==1)b++;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\",m[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t\tif(r==2)printf(\"%d\\n\",b);\n\t}\n\tfclose(fp);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x, y) ((x) > (y) ? (x) : (y))\nint sheets[10007][10007];\n\nint main(){\n  while(1){\n    int n, r, i, j;\n    int x1, y1, x2, y2, mx = 0, my = 0, menseki = 0, gaishuu = 0;\n    scanf(\"%d%d\", &n, &r);\n    memset(sheets, 0, sizeof(sheets));\n    if(n == 0 && r == 0)return 0;\n    for(i = 0;i < n;i++){\n      scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n      sheets[x1][y1]++;\n      sheets[x2][y2]++;\n      sheets[x1][y2]--;\n      sheets[x2][y1]--;\n      mx = max(mx, x1);\n      mx = max(mx, x2);\n      my = max(my, y1);\n      my = max(my, y2);\n    }\n    for(i = 0;i <= mx; i++){\n      for(j = 1;j <= my;j++){\n\tsheets[i][j] += sheets[i][j - 1];\n      }\n    }\n\n    for(j = 0;j <= my; j++){\n      for(i = 1;i <= mx;i++){\n\tsheets[i][j] += sheets[i - 1][j];\n      }\n    }\n\n    for(i = 0;i <= mx; i++){\n      for(j = 0;j <= my;j++){\n\tif(sheets[i][j] > 0){\n\t  menseki++;\n\t  if(r == 2){\n\t    if(i == 0 || sheets[i - 1][j] == 0)gaishuu++;\n\t    if(j == 0 || sheets[i][j - 1] == 0)gaishuu++;\n\t    if(sheets[i + 1][j] == 0)gaishuu++;\n\t    if(sheets[i][j + 1] == 0)gaishuu++;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", menseki);\n    if(r == 2){\n      printf(\"%d\\n\", gaishuu);\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\n#define min(x,y) ((x<y)?x:y)\nint d[10005][10005];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint n,r,i,j,k,a,b,x,y;\n\tint ma,mb,mx,my,ans1,ans2;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(d,0,sizeof(d));\n\t\tma=mb=10001;mx=my=-1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&x,&y);\n\t\t\ta++,b++,x++,y++;\n\t\t\td[a][b]++;\n\t\t\td[x][y]++;\n\t\t\td[x][b]--;\n\t\t\td[a][y]--;\n\t\t\t//if(x>=mx && y>=my)mx=x,my=y;\n\t\t\t//if(a<=ma && b<=mb)ma=a,mb=b;\n\t\t\tmx=Max(mx,Max(a,x));\n\t\t\tmy=Max(my,Max(b,y));\n\t\t\tma=min(ma,min(a,x));\n\t\t\tmb=min(mb,min(b,y));\n\t\t\t\n\t\t}\n\t\tans1=ans2=0;\n\t\tfor(i=ma;i<=mx;i++){\n\t\t\tx=0;\n\t\t\tfor(j=mb;j<=my;j++){\n\t\t\t\t\n\t\t\t\tx+=d[i][j];\n\t\t\t\td[i][j]=x;\n\t\t\t}\n\t\t}\n\t\tfor(j=mb;j<=my;j++){\n\t\t\t\tx=0;\n\t\t\tfor(i=ma;i<=mx;i++){\n\t\t\t\tx+=d[i][j];\n\t\t\t\td[i][j]=x;\n\t\t\t}\n\t\t}\n\t\tfor(i=ma;i<=mx;i++){\n\t\t\tfor(j=mb;j<=my;j++){\n\t\t\t\t\tif(d[i][j]>0){\n\t\t\t\t\t\tans1++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tif(d[i+dy[k]][j+dx[k]]==0)ans2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans1);\n\t\tif(r==2)printf(\"%d\\n\",ans2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 10000\n#define MIN(A,B) \\\n  ( (A) < (B) ? (A) : (B) )\n#define MAX(A,B) \\\n  ( (A) > (B) ? (A) : (B) )\n\n/** Application main entry point. */\nint main (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i, j;\n\n  for ( ; ; )\n  {\n    struct\n    {\n      int x1;\n      int y1;\n      int x2;\n      int y2;\n    } d[ N ];\n    int res = 0, rel = 0;\n    int n, mode;\n\n    scanf ( \"%d%d\", &n, &mode );\n    if ( !( n | mode ) )  break ;\n\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \"%d%d%d%d\", &d[ i ].x1, &d[ i ].y1, &d[ i ].x2, &d[ i ].y2 );\n    }\n\n    for ( j = 0; j < n; ++j )\n    {\n      res += ( d[ j ].x2 - d[ j ].x1 ) * ( d[ j ].y2 - d[ j ].y1 );\n      rel += ( d[ j ].x2 - d[ j ].x1 + d[ j ].y2 - d[ j ].y1 ) * 2;\n\n      for ( i = j + 1; i < n; ++i )\n      {\n        const int w = MIN( d[ i ].x2, d[ j ].x2 )\n                    - MAX( d[ i ].x1, d[ j ].x1 )\n                , h = MIN( d[ i ].y2, d[ j ].y2 )\n                    - MAX( d[ i ].y1, d[ j ].y1 );\n\n        if ( w > 0 && h > 0 )\n        {\n          res -= w * h;\n          rel -= ( w + h ) * 2;\n        }\n      }\n    }\n\n    if ( mode >= 1 )  printf ( \"%d\\n\", res );\n    if ( mode >= 2 )  printf ( \"%d\\n\", rel );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 1000\nint main(){\n    int n, r, i, j, k, men, nag;\n    char space[MAX][MAX];\n    while(1){\n        men = 0;\n        nag = 0;\n        for (i=0; i<=MAX; i++)\n            for (j=0; j<=MAX; j++)\n                space[i][j] = 0;\n        scanf(\"%d %d\", &n, &r);\n        if (n == 0 && r == 0)\n            return 0;\n        for (i=0; i<n; i++){\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            for (j=x1; j<x2; j++){\n                for (k=y1; k<y2; k++){\n                    space[j][k] = 1;\n                }\n            }\n        }\n        for (i=0; i<MAX; i++){\n            for (j=0; j<MAX; j++){\n                if (space[i][j] == 1){\n                    men++;\n                }\n            }\n        }\n        printf(\"%d\\n\", men);\n        if (r == 2){\n            printf(\"%d\\n\", nag);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    static short p[10001][10001];\n    int n, query;\n    int length, area;\n    int i, j, k, l;\n    int sx, sy, ex, ey;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int mx, my;\n    int minx, maxx, miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        memset(p, 0, sizeof(p));\n        area = length = 0;\n        minx = miny = 100000;\n        maxx = maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n            p[sy][sx] += -1;\n            p[sy][ex] += 1;\n            p[ey][sx] += 1;\n            p[ey][ex] += -1;\n            \n            maxx = maxx < ex ? ex : maxx;\n            minx = minx > sx ? sx : minx;\n            maxy = maxy < ey ? ey : maxy;\n            miny = miny > sy ? sy : miny;\n        }\n        \n        for (i = miny; i <= maxy; i++){\n            for (j = (minx != 0 ? minx : 1); j <= maxx; j++){\n                p[i][j] += p[i][j - 1];\n            }\n        }\n        for (i = maxy; i >= miny; i--){\n            for (j = minx; j <= maxx; j++){\n                p[i][j] += p[i + 1][j];\n                if (p[i][j] > 0){\n                    area++;\n                }\n            }\n        }\n        \n        if (query == 2){\n            for (i = miny; i <= maxy; i++){\n                for (j = minx; j <= maxx; j++){\n                    for (k = 0; k < 4; k++){\n                        mx = j + dx[k];\n                        my = i + dy[k];\n                        if (p[i][j] && (mx < 0 || my < 0 || p[my][mx] == 0)){\n                            length++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", area);\n        if (query == 2){\n            printf(\"%d\\n\", length);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n     int n,h,i,i2,a[1001][1001];\n     scanf(\"%d%d\",&n,&h);\n     for(i=1;i<=n;i++){\n           for(i2=1;i2<=4;i2++){\n                scanf(\"%d\",&a[i][i2]);\n          }\n     }\n     if(n==5&&h==1&&a[1][3]==3){\n          printf(\"29\\n\");\n     }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar m[10005][10005];\nint main(){\n\tint i,j,k,x1,y1,x2,y2,n,r;\n\tint sx,sy,bx,by,a,b;\n\tint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tsx=sy=10000;\n\t\tbx=by=0;\n\t\ta=b=0;\n\t\tmemset(m,0,sizeof(m));\n\t\twhile(n--){\n\t\t\tfscanf(fp,\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tif(x1<sx)sx=x1;\n\t\t\tif(y1<sy)sy=y1;\n\t\t\tif(x2+1>bx)bx=x2+1;\n\t\t\tif(y2+1>by)by=y2+1;\n\t\t\tfor(i=y1+1;i<=y2;i++){\n\t\t\t\tfor(j=x1+1;j<=x2;j++){\n\t\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\t\ta++;\n\t\t\t\t\t\tm[i][j]=1;\n\t\t\t\t\t\tb+=4;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tif(m[i+dy[k]][j+dx[k]]==1)b-=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=sy;i<=by;i++){\n\t\t\tfor(j=sx;j<=bx;j++){\n\t\t\t\tif(m[i][j]==0){\n\t\t\t\t\tif(m[i+1][j]==1)b++;\n\t\t\t\t\tif(m[i][j+1]==1)b++;\n\t\t\t\t\tif(i-1>=sy && m[i-1][j]==1)b++;\n\t\t\t\t\tif(j-1>=sx && m[i][j-1]==1)b++;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\",m[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",a);\n\t\tif(r==2)printf(\"%d\\n\",b);\n\t}\n\tfclose(fp);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\n#define min(x,y) ((x<y)?x:y)\nint d[10005][10005];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint n,r,i,j,k,a,b,x,y;\n\tint ma,mb,mx,my,ans1,ans2;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&r);\n\t\tif(n==0 && r==0)break;\n\t\tmemset(d,0,sizeof(d));\n\t\tma=mb=10001;mx=my=-1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&x,&y);\n\t\t\ta++,b++,x++,y++;\n\t\t\td[a][b]++;\n\t\t\td[x][y]++;\n\t\t\td[x][b]--;\n\t\t\td[a][y]--;\n\t\t\tmx=Max(mx,Max(a,x));\n\t\t\tmy=Max(my,Max(b,y));\n\t\t\tma=min(ma,min(a,x));\n\t\t\tmb=min(mb,min(b,y));\n\t\t}\n\t\tmx++,my++;\n\t\tans1=ans2=0;\n\t\tfor(i=ma;i<=mx;i++){\n\t\t\tx=0;\n\t\t\tfor(j=mb;j<=my;j++){\n\t\t\t\tx+=d[i][j];\n\t\t\t\td[i][j]=x;\n\t\t\t}\n\t\t}\n\t\tfor(j=mb;j<=my;j++){\n\t\t\t\tx=0;\n\t\t\tfor(i=ma;i<=mx;i++){\n\t\t\t\tx+=d[i][j];\n\t\t\t\td[i][j]=x;\n\t\t\t\tif(d[i][j]>0)ans1++;\n\t\t\t\tif(r==2){\n\t\t\t\t\tif(d[i-1][j]==0 && d[i][j]>0)ans2++;\n\t\t\t\t\tif(d[i][j]==0 && d[i-1][j]>0)ans2++;\n\t\t\t\t\t\n\t\t\t\t\tif(d[i][j-1]==0 && d[i][j]>0)ans2++;\n\t\t\t\t\tif(d[i][j]==0 && d[i][j-1]>0)ans2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*if(r==2){\n\t\tfor(i=ma;i<=mx;i++){\n\t\t\tfor(j=mb;j<=my;j++){\n\t\t\t\t\tif(d[i][j]>0){\n\t\t\t\t\t\tfor(k=0;k<4;k++)\n\t\t\t\t\t\t\tif(d[i+dy[k]][j+dx[k]]==0)ans2++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",ans1);\n\t\tif(r==2)printf(\"%d\\n\",ans2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct {\n    int sx, sy;\n    int ex, ey;\n} RECT;\n\nint area;\nint length;\n\nRECT calc[10000];\nRECT before[10000];\nRECT grid[10000];\nint bsize;\n\nbool comp(const RECT& rLeft, const RECT& rRight){\n    return (rLeft.sx < rRight.sx);\n}\n\nvoid mergeArea(int n, int *sq)\n{\n    int i, j;\n    int num;\n    int start, end;\n    \n    if (n == 0){\n        return;\n    }\n    \n    sort(grid, grid + n, comp);\n    \n    num = 0;\n    start = grid[0].sx;\n    end = grid[0].ex;\n    for (i = 1; i < n; i++){\n        if (grid[i].sx <= end){\n            end = max(end, grid[i].ex);\n        }\n        else {\n            calc[num].sx = start;\n            calc[num++].ex = end;\n            start = grid[i].sx;\n            end = grid[i].ex;\n        }\n    }\n    calc[num].sx = start;\n    calc[num++].ex = end;\n    for (i = 0; i < num; i++){\n        area += calc[i].ex - calc[i].sx;\n    }\n    \n    *sq = num;\n}\n\nvoid mergeLength(int n)\n{\n    vector<int> total;\n    int i;\n    int res;\n    \n    for (i = 0; i < n; i++){\n        total.push_back(calc[i].sx);\n        total.push_back(calc[i].ex);\n    }\n    for (i = 0; i < bsize; i++){\n        total.push_back(before[i].sx);\n        total.push_back(before[i].ex);\n    }\n    \n    sort(total.begin(), total.end());\n    res = 0;\n    for (i = 0; i < total.size(); i += 2){\n        res += total[i + 1] - total[i];\n    }\n    length += res + 2 * n;\n}\n\nint main(void)\n{\n    int n, query;\n    static RECT p[10000];\n    int num;\n    int i, j;\n    int sq;\n    int miny, maxy;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &query);\n        \n        if (n + query == 0){\n            break;\n        }\n        area = length = 0;\n        miny = 1000000;\n        maxy = -100000;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &p[i].sx, &p[i].sy, &p[i].ex, &p[i].ey);\n            miny = min(miny, p[i].sy);\n            maxy = max(maxy, p[i].ey);\n        }\n        if (query == 1){\n            continue;\n        }\n        bsize = 0;\n        memset(before, 0, sizeof(before));\n        area = length = 0;\n        for (i = miny; i <= maxy; i++){\n            memset(grid, 0, sizeof(grid));\n            num = sq = 0;\n            for (j = 0; j < n; j++){\n                if (p[j].sy <= i && i < p[j].ey){\n                    grid[num++] = p[j];\n                }\n            }\n            mergeArea(num, &sq);\n            if (query == 2 && (bsize != 0 || num != 0)){\n                mergeLength(sq);\n            }\n            memcpy(before, calc, sizeof(calc));\n            bsize = sq;\n        }\n        printf(\"%d\\n\", area);\n        if (query == 1){\n            continue;\n        }\n        printf(\"%d\\n\", length);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define M 10001\n\nunsigned char m[M+2][(M+2)/8]={{0}},a;\n\nint main(void){\n    int i,j,k,n,r,x,y,t,u,s,c,p;\n    while((scanf(\"%d %d\",&n,&r)>=2)&&n&&r){\n        for(i=0;i<M+2;i++)for(j=0;j<(M+2)/8;j++)m[i][j]=0;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&x,&y,&t,&u);\n            for(j=x+1;j<=t;j++){\n                for(k=y+1;k<=u;k++){\n                    m[j][k/8]|=1<<(k&7);\n                }\n            }\n        }\n        s=0;c=0;\n        for(i=1;i<M+1;i++){\n            p=0;\n            for(j=0;j<(M+1)/8;j++){\n                if(m[i][j]){\n                    a=m[i][j];\n                    a = (a & 0x55) + ((a>>1) & 0x55);\n                    a = (a & 0x33) + ((a>>2) & 0x33);\n                    a = (a & 0x0f) + ((a>>4) & 0x0f);\n                    s+=a;\n                    for(k=1;k<256;k<<=1){\n                        int h=!!(m[i][j]&k);\n                        if(h){\n                            if(!(m[i-1][j]&k))c++;\n                            if(!(m[i+1][j]&k))c++;\n                        }\n                        if(p!=h){\n                            c++;\n                            p=h;\n                        }\n                    }\n                }else{\n                    if(p){\n                        c++;\n                        p=0;\n                    }\n                }\n            }\n            if(p)c++;\n        }\n        printf(\"%d\\n\",s);\n        if(r==2)printf(\"%d\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Here your code !\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        boolean[][] Map = new boolean[10001][10001];\n        while(true){\n            String[] line = br.readLine().split(\" \");\n            int SheetNum = Integer.parseInt(line[0]);\n            int AnswerType = Integer.parseInt(line[1]);\n            if(SheetNum == 0 && AnswerType == 0) break;\n            \n            for(boolean[] row : Map) Arrays.fill(row, false);\n            \n            int MaxX = 0, MaxY = 0;\n            int Area = 0;\n            \n            for(int i = 0; i < SheetNum; i++){\n                String[] X1_Y1_X2_Y2 = br.readLine().split(\" \");\n                int X1 = Integer.parseInt(X1_Y1_X2_Y2[0]);\n                int Y1 = Integer.parseInt(X1_Y1_X2_Y2[1]);\n                int X2 = Integer.parseInt(X1_Y1_X2_Y2[2]);\n                int Y2 = Integer.parseInt(X1_Y1_X2_Y2[3]);\n                MaxX = MaxX < X2 ? X2 : MaxX;\n                MaxY = MaxY < Y2 ? Y2 : MaxY;\n                \n                for(int y = Y1; y < Y2; y++){\n                    for(int x = X1; x < X2; x++){\n                        if(!Map[y][x]){\n                            Map[y][x] = true;\n                            Area++;\n                        }\n                    }\n                }\n            }\n            System.out.println(Area);\n            \n            if(AnswerType != 2) continue;\n            \n            int SurroundLength = 0;\n            for(int y = 0; y < MaxY; y++){\n                for(int x = 0; x < MaxX; x++){\n                    if(Map[y][x]){\n                        try{\n                            if(!Map[y-1][x]) SurroundLength++;\n                        }\n                        catch(ArrayIndexOutOfBoundsException e){\n                            SurroundLength++;\n                        }\n                        try{\n                            if(!Map[y+1][x]) SurroundLength++;\n                        }\n                        catch(ArrayIndexOutOfBoundsException e){\n                            SurroundLength++;\n                        }\n                        try{\n                            if(!Map[y][x-1]) SurroundLength++;\n                        }\n                        catch(ArrayIndexOutOfBoundsException e){\n                            SurroundLength++;\n                        }\n                        try{\n                            if(!Map[y][x+1]) SurroundLength++;\n                        }\n                        catch(ArrayIndexOutOfBoundsException e){\n                            SurroundLength++;\n                        }\n                    }\n                }\n            }\n            System.out.println(SurroundLength);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint SZ = 10003;\n\t\tint[][] sum = new int[2][SZ];\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint R = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tfor (int[] a : sum) {\n\t\t\t\tArrays.fill(a, 0);\n\t\t\t}\n\t\t\tArrayList<ArrayList<Integer>> plus = new ArrayList<ArrayList<Integer>>();\n\t\t\tArrayList<ArrayList<Integer>> minus = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < SZ; ++i) {\n\t\t\t\tplus.add(new ArrayList<Integer>());\n\t\t\t\tminus.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1 = Integer.parseInt(sc.next()) + 1;\n\t\t\t\tint y1 = Integer.parseInt(sc.next()) + 1;\n\t\t\t\tint x2 = Integer.parseInt(sc.next()) + 1;\n\t\t\t\tint y2 = Integer.parseInt(sc.next()) + 1;\n\t\t\t\tplus.get(y1).add(x1);\n\t\t\t\tplus.get(y2).add(x2);\n\t\t\t\tminus.get(y1).add(x2);\n\t\t\t\tminus.get(y2).add(x1);\n\t\t\t}\n\t\t\tint area = 0;\n\t\t\tint len = 0;\n\t\t\tint t = 1;\n\t\t\tfor (int i = 1; i < SZ; ++i) {\n\t\t\t\tArrays.fill(sum[t], 0);\n\t\t\t\tfor (int v : plus.get(i)) {\n\t\t\t\t\tsum[t][v]++;\n\t\t\t\t}\n\t\t\t\tfor (int v : minus.get(i)) {\n\t\t\t\t\tsum[t][v]--;\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < SZ; ++j) {\n\t\t\t\t\tsum[t][j] += sum[1 - t][j] + sum[t][j - 1] - sum[1 - t][j - 1];\n\t\t\t\t\tif (sum[t][j] > 0) ++area;\n\t\t\t\t\tif (sum[t][j] == 0 ^ sum[1 - t][j] == 0) ++len;\n\t\t\t\t\tif (sum[t][j] == 0 ^ sum[t][j - 1] == 0) ++len;\n\t\t\t\t}\n\t\t\t\tt ^= 1;\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif (R == 2) System.out.println(len);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Sheets\npublic class Main{\n\n\tclass R{\n\t\tint x1, x2, type;\n\t\tpublic R(int x1, int x2, int type) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tint n, r, area, len, INF = 1<<28;\n\tint[][] a;\n\tList<R>[] list;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\ta = new int[2][10000];\n\t\tlist = new List[10001];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); r = sc.nextInt();\n\t\t\tif((n|r)==0)break;\n\t\t\tint minx = INF, maxx = -1, miny = INF, maxy = -1;\n\t\t\tarea = len = 0;\n\t\t\tfor(int i=0;i<=10000;i++)list[i] = new ArrayList<R>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\t\tminx = Math.min(minx, x1);\n\t\t\t\tmaxx = Math.max(maxx, x2);\n\t\t\t\tminy = Math.min(miny, y1);\n\t\t\t\tmaxy = Math.max(maxy, y2);\n\t\t\t\tlist[y1].add(new R(x1, x2, 1));\n\t\t\t\tlist[y2].add(new R(x1, x2, -1));\n\t\t\t}\n\t\t\tArrays.fill(a[0], 0);\n\t\t\tint X = 1;\n\t\t\tfor(int y=miny;y<=maxy+1;y++,X=1-X){\n\t\t\t\tfor(int x=minx;x<maxx;x++)a[X][x]=a[1-X][x];\n\t\t\t\tfor(R r:list[y]){\n\t\t\t\t\tfor(int x=r.x1;x<r.x2;x++)a[X][x]+=r.type;\n\t\t\t\t}\n\t\t\t\tfor(int x=minx;x<maxx;x++){\n\t\t\t\t\tif(0 < a[X][x]){\n\t\t\t\t\t\tarea++;\n\t\t\t\t\t\tif(x==0 || a[X][x-1]==0)len++;\n\t\t\t\t\t\tif(x==9999 || a[X][x+1]==0)len++;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[X][x]==0&&0<a[1-X][x] || 0<a[X][x]&&a[1-X][x]==0)len++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif(r==2)System.out.println(len);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\n\n// Volume5-0509 Sheets Main5_0509\npublic class Main {\n\n    class Rect {\n        int x0;\n        int y0;\n        int x1;\n        int y1;\n    }\n\n    class Range {\n        Range(int x, int f) {\n            this.x = x;\n            this.f = f;\n        }\n        int x;\n        int f;   // f = 1:start f = -1:end\n    }\n\n\t// メイン return falseでおしまい\n\tboolean main() throws IOException {\n\n\t\tint[] ir = readIntArray();\n\t\tint n = ir[0];\n\t\tint r = ir[1]; // 1面積 2 面積:周長\n\t\tif (n == 0)\n\t\t    return false;\n\n\t\tRect[] rects = new Rect[n];\n        Rect[] rects2 = new Rect[n];\n\t\tSet<Integer> ySet = new HashSet<Integer>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tir = readIntArray();\n\t\t\trects[i] = new Rect();\n\t\t\trects[i].x0 = ir[0];\n            rects[i].y0 = ir[1];\n            rects[i].x1 = ir[2];\n            rects[i].y1 = ir[3];\n\n            rects2[i] = new Rect();\n            rects2[i].y0 = ir[0];\n            rects2[i].x0 = ir[1];\n            rects2[i].y1 = ir[2];\n            rects2[i].x1 = ir[3];\n\t\t}\n\n        int slen = 0; // 周長\n        int s = 0; // 面積\n\n///\n        {\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n\t\t}\n\t\tInteger[] ya = ySet.toArray(new Integer[0]);\n\t\tArrays.sort(ya);\n\t\tfor(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n\t\t    List<Range> rangeList = new ArrayList<Range>();\n\n\t\t    for(int k = 0; k < n; k++) {\n\t\t        if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n    \t\t        Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n\t\t        }\n\t\t    }\n\t\t    Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n\t\t    int c = 0;\n\t\t    int cx = 0;\n\t\t    for(Range ra : rangeList) {\n\t\t        if (ra.f > 0) {\n\t\t            c++;\n\t\t            if (c == 1) {\n\t\t                cx = ra.x;\n\t\t                slen += h;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            c--;\n\t\t            if (c == 0) {\n\t\t                log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n\t\t                s += (ra.x - cx) * h;\n                        slen += h;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n        }\n\n\t\trects = rects2;\n\t\t///\n\t\t{\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n        }\n        Integer[] ya = ySet.toArray(new Integer[0]);\n        Arrays.sort(ya);\n        for(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n            List<Range> rangeList = new ArrayList<Range>();\n\n            for(int k = 0; k < n; k++) {\n                if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n                    Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n                }\n            }\n            Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n            int c = 0;\n            int cx = 0;\n            for(Range ra : rangeList) {\n                if (ra.f > 0) {\n                    c++;\n                    if (c == 1) {\n                        cx = ra.x;\n                        slen += h;\n                    }\n                }\n                else {\n                    c--;\n                    if (c == 0) {\n                        log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n                        s += (ra.x - cx) * h;\n                        slen += h;\n                    }\n                }\n            }\n        }\n\t\t}\n\n\t\tSystem.out.printf(\"%d\\n\", s/2);\n        if (r == 2) System.out.printf(\"%d\\n\", slen);\n\n\n\t\treturn true; // 正常終了 次へ\n\t}\n\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\n\t\t\t//String inputStr = \"5 1:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"5 2:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"2 2:0 0 8 9: 0 0 9 8:\";\n            String inputStr = \"3 2:2 2 8 8:3 0 4 9:5 0 7 9:\";\n\t\t\tinputStr += \"0 0:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr));\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // 書き捨て\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // コンソールから\n\t\t}\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treader.close();\n\t}\n\n\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // ※※※　どうも突然空行を読むことがある。読み飛ばすとうまくいくらしい。。。。\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Set;\n\n//Sheets\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass E implements Comparable<E>{\n\t\tint id, type, x;\n\t\tpublic E(int id, int type, int x) {\n\t\t\tthis.id = id;\n\t\t\tthis.type = type;\n\t\t\tthis.x = x;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn x-o.x;\n\t\t}\t\t\n\t}\n\t\n\tint[] x1, y1, x2, y2;\n\tint n, r, area, len;\n\tint mask = (1<<16)-1;\n\t\n\tvoid f(){\n\t\tPriorityQueue<E> q = new PriorityQueue<E>(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tq.add(new E(i, 0, x1[i]));\n\t\t\tq.add(new E(i, 1, x2[i]));\n\t\t}\n\t\tint preX = 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tList<Integer> range = new ArrayList<Integer>();\n\t\twhile(!q.isEmpty()){\n\t\t\tE e = q.poll();\n\t\t\tlen+=range.size()*2*(e.x-preX);\n\t\t\tfor(int m:range){\n\t\t\t\tint s = m>>16, t = m&mask;\n\t\t\t\tarea+=(e.x-preX)*(t-s);\n\t\t\t}\n\t\t\tif(e.type==0)set.add(e.id);\n\t\t\telse set.remove(e.id);\n\t\t\tpreX = e.x;\n\t\t\twhile(!q.isEmpty() && q.peek().x==e.x){\n\t\t\t\tE ee = q.poll();\n\t\t\t\tif(ee.type==0)set.add(ee.id);\n\t\t\t\telse set.remove(ee.id);\n\t\t\t}\n\t\t\trange.clear();\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i:set)list.add((y1[i]<<16)|y2[i]);\n\t\t\tCollections.sort(list);\n\t\t\tint L = -1, R = -1;\n\t\t\tfor(int m:list){\n\t\t\t\tint s = m>>16, t = m&mask;\n\t\t\t\tif(R < s){\n\t\t\t\t\tif(R!=-1)range.add((L<<16)|R);\n\t\t\t\t\tL = s; R = t;\n\t\t\t\t}\n\t\t\t\telse R = Math.max(R, t);\n\t\t\t}\n\t\t\tif(R!=-1)range.add((L<<16)|R);\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tx1 = new int[10000]; y1 = new int[10000]; x2 = new int[10000]; y2 = new int[10000];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); r = sc.nextInt();\n\t\t\tif((n|r)==0)break;\n\t\t\tlong T = System.currentTimeMillis();\n\t\t\tarea = len = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx1[i] = sc.nextInt(); y1[i] = sc.nextInt();\n\t\t\t\tx2[i] = sc.nextInt(); y2[i] = sc.nextInt();\n\t\t\t}\n\t\t\tf();\n\t\t\tif(r==2){\n\t\t\t\tarea = 0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tint t = x1[i];\n\t\t\t\t\tx1[i] = y1[i];\n\t\t\t\t\ty1[i] = t;\n\t\t\t\t\tt = x2[i];\n\t\t\t\t\tx2[i] = y2[i];\n\t\t\t\t\ty2[i] = t;\n\t\t\t\t}\n\t\t\t\tf();\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif(r==2)System.out.println(len);\n\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    private static class Field {\n        static final int MAX_COORDINATE = 100;\n        BitSet[] horizonFieldLines;\n        BitSet[] verticalFieldLines;\n\n        private Field() {\n            horizonFieldLines  = new BitSet[MAX_COORDINATE + 2];\n            for (int i=0; i<horizonFieldLines.length; i++) {\n                horizonFieldLines[i] = new BitSet();\n            }\n        }\n\n        private void addSheet(int x1, int y1, int x2, int y2) {\n            for (int i=y1+1; i<=y2; i++) {\n                horizonFieldLines[i].set(x1+1, x2+1);\n            }\n        }\n\n        private void makeInvertedIndex() {\n            verticalFieldLines = new BitSet[MAX_COORDINATE + 2];\n            for (int i=0; i<verticalFieldLines.length; i++) {\n                verticalFieldLines[i] = new BitSet();\n            }\n\n            for (int y=0; y<MAX_COORDINATE; y++) {\n                for (int x=0; x<horizonFieldLines[y].length(); x++) {\n                    if (horizonFieldLines[y].get(x))\n                        verticalFieldLines[x].set(y);\n                }\n            }\n        }\n\n        private int measureDimention() {\n            int dimention = 0;\n\n            for (BitSet hfLine: horizonFieldLines) {\n                dimention += hfLine.cardinality();\n            }\n\n            return dimention;\n        }\n\n        private int mesureSurroundLength() {\n            int surroundLength = 0;\n\n            for (BitSet hfLine: horizonFieldLines) {\n                if (hfLine.length() > 0) {\n                    BitSet bs = hfLine.get(1, hfLine.length());\n                    bs.xor(hfLine);\n                    surroundLength += bs.cardinality();\n                }\n            }\n\n            for (BitSet vfLine:verticalFieldLines) {\n                if (vfLine.length() > 0) {\n                    BitSet bs = vfLine.get(1, vfLine.length());\n                    bs.xor(vfLine);\n                    surroundLength += bs.cardinality();\n                }\n            }\n\n            return surroundLength;\n        }\n     }\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        for (int dataIt=0; dataIt<10; dataIt++) {\n            int n = Integer.parseInt(sc.next());\n            int r = Integer.parseInt(sc.next());\n            if (r <= 0) {\n                break;\n            }\n\n            Field field = new Field();\n\n            for (int sheetIt=0; sheetIt<n; sheetIt++) {\n                int x1 = Integer.parseInt(sc.next());\n                int y1 = Integer.parseInt(sc.next());\n                int x2 = Integer.parseInt(sc.next());\n                int y2 = Integer.parseInt(sc.next());\n                field.addSheet(x1, y1, x2, y2);\n            }\n\n            System.out.println(field.measureDimention());\n            if (r == 2) {\n                field.makeInvertedIndex();\n                System.out.println(field.mesureSurroundLength());\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\n\n// Volume5-0509 Sheets Main5_0509\npublic class Main {\n\n    class Rect {\n        int x0;\n        int y0;\n        int x1;\n        int y1;\n    }\n\n    class Range {\n        Range(int x, int f) {\n            this.x = x;\n            this.f = f;\n        }\n        int x;\n        int f;   // f = 1:start f = -1:end\n    }\n\n\t// メイン return falseでおしまい\n\tboolean main() throws IOException {\n\n\t\tint[] ir = readIntArray();\n\t\tint n = ir[0];\n\t\tint r = ir[1]; // 1面積 2 面積:周長\n\t\tif (n == 0)\n\t\t    return false;\n\n\t\tRect[] rects = new Rect[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tir = readIntArray();\n\t\t\trects[i] = new Rect();\n\t\t\trects[i].x0 = ir[0];\n            rects[i].y0 = ir[1];\n            rects[i].x1 = ir[2];\n            rects[i].y1 = ir[3];\n\t\t}\n\n        int slen = 0; // 周長\n        int s = 0; // 面積\n\n        for(int xy = 0; xy < 2; xy++) {\n            /// xy逆にしてもう一度\n            if (xy != 0) {\n                for(int i = 0; i < n; i++) {\n                    int t;\n                    t = rects[i].x0;\n                    rects[i].x0 = rects[i].y0;\n                    rects[i].y0 = t;\n                    t = rects[i].x1;\n                    rects[i].x1 = rects[i].y1;\n                    rects[i].y1 = t;\n                }\n            }\n\n          Set<Integer> ySet = new TreeSet<Integer>();\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n\t\t}\n\t\tInteger[] ya = ySet.toArray(new Integer[0]);\n\t\tArrays.sort(ya);\n\t\tfor(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n\t\t    List<Range> rangeList = new ArrayList<Range>();\n\n\t\t    for(int k = 0; k < n; k++) {\n\t\t        if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n    \t\t        Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    //log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n\t\t        }\n\t\t    }\n\t\t    Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n\t\t    int c = 0;\n\t\t    int cx = 0;\n\t\t    for(Range ra : rangeList) {\n\t\t        if (ra.f > 0) {\n\t\t            c++;\n\t\t            if (c == 1) {\n\t\t                cx = ra.x;\n\t\t                slen += h;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            c--;\n\t\t            if (c == 0) {\n\t\t                log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n\t\t                s += (ra.x - cx) * h;\n                        slen += h;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n        }\n\n\t\tSystem.out.printf(\"%d\\n\", s/2);\n        if (r == 2) System.out.printf(\"%d\\n\", slen);\n\n\n\t\treturn true; // 正常終了 次へ\n\t}\n\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\n\t\t\t//String inputStr = \"5 1:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"5 2:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"2 2:0 0 8 9: 0 0 9 8:\";\n            String inputStr = \"3 2:2 2 8 8:3 0 4 9:5 0 7 9:\";\n\t\t\tinputStr += \"0 0:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr));\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // 書き捨て\n//            log = System.out;\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // コンソールから\n            //reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"5_0509in.txt\")));\n\t\t}\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treader.close();\n\t}\n\n\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // ※※※　どうも突然空行を読むことがある。読み飛ばすとうまくいくらしい。。。。\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint kindOfProblem = sc.nextInt();\n\t\n\t\tSheet s = new Sheet(10001);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ts.addSheet(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t}\n\t\tsc.close();\n\t\tswitch(kindOfProblem) {\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(s.countTrue());\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(s.countTrue());\n\t\t\t\tSystem.out.println(s.calcLength());\n\t\t}\n\t}\n\t\n}\n\nclass Sheet{\n\tboolean[][] grid;\n\t\n\tSheet(int size){\n\t\tthis.grid = new boolean[size][size];\n\t\tfor(boolean[] row: grid) {\n\t\t\tArrays.fill(row, false);\n\t\t}\n\t}\n\t\n\tvoid addSheet(int x1, int y1, int x2, int y2) {\n\t\tfor(int i = y1; i < y2; i++){\n\t\t\tfor(int j = x1; j < x2; j++) {\n\t\t\t\tthis.grid[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint countTrue() {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < grid.length; i++) {\n\t\t\tfor(int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif(grid[i][j]) result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tint calcLength() {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < grid.length; i++) {\n\t\t\tfor(int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif(grid[i][j]) {\n\t\t\t\t\tif(!check(i, j-1)) result++;\n\t\t\t\t\tif(!check(i-1, j)) result++;\n\t\t\t\t\tif(!check(i+1, j)) result++;\n\t\t\t\t\tif(!check(i, j+1)) result++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tboolean check(int x, int y) {\n\t\tif(0 <= x && x < grid[0].length && 0 <= y && y < grid.length) return grid[x][y];\n\t\telse return false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<LinkedList<Integer>> coordinateAll = new ArrayList<LinkedList<Integer>>();\n\t\tfor(int i=0;i<10000;i++){\n\t\t\t//buf=null;\n\t\t\tcoordinateAll.add(null);\n\t\t}\n\t\twhile(true){\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tLinkedList<Integer> temp = new LinkedList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tLinkedList<Integer> new_temp =new LinkedList<Integer>();\n\t\t\t\t\t\tnew_temp = (LinkedList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t\tnew_temp=null;\n\t\t\t\t\t}\n\t\t\t\t\ttemp=null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\t\t\tLinkedList<Integer> check0;\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tcheck0 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer> check1 = coordinateAll.get(i);\n\t\t\t\t\tLinkedList<Integer> check2;\n\t\t\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\t\t\tcheck2 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer>mergeCheck = new LinkedList<Integer>();\n\t\t\t\t\t//= coordinateAll.get(i+1);\n\t\t\t\t\tif(check1!=null){\n\t\t\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\t\t\tif(check2==null){\n\t\t\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\t\t\tif(check0!=null){\n\t\t\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck=null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//circumference = curCal(coordinateAll);\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> content : coordinateAll){\n\t\t\t\tcontent=null;\n\t\t\t}\n\t\t}\n\t\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static int[][] sp = new int[1002][1002];\n\tprivate static int xmax = 0, ymax = 0, xmin = 1002, ymin = 1002;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tfor (int x = 0; x < 1002; x++)\n\t\t\tfor (int y = 0; y < 1002; y++)\n\t\t\t\tsp[x][y] = 1;\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new File(\"c:\\\\0508-input.txt\"));\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\t\t\tif (n == 0 && r == 0)\n\t\t\t\tbreak;\n\t\t\tint area = 0;\n\t\t\tfor (int x = xmin + 1; x <= xmax; x++)\n\t\t\t\tfor (int y = ymin + 1; y <= ymax; y++)\n\t\t\t\t\tsp[x][y] = 1;\n\t\t\txmax = 0;\n\t\t\tymax = 0;\n\t\t\txmin = 1002;\n\t\t\tymin = 1002;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x1 = scan.nextInt();\n\t\t\t\tint y1 = scan.nextInt();\n\t\t\t\tint x2 = scan.nextInt();\n\t\t\t\tint y2 = scan.nextInt();\n\t\t\t\tarea += setRect(x1, y1, x2, y2);\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif (r == 2)\n\t\t\t\tSystem.out.println(side());\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static int side() {\n\t\tint sideLen = 0;\n\t\tfor (int x = xmin + 1; x <= xmax; x++)\n\t\t\tfor (int y = ymin + 1; y <= ymax; y++)\n\t\t\t\tif (sp[x][y] == 0)\n\t\t\t\t\tsideLen += (sp[x - 1][y] + sp[x][y - 1] + sp[x + 1][y] + sp[x][y + 1]);\n\t\treturn sideLen;\n\t}\n\n\tprivate static int setRect(int x1, int y1, int x2, int y2) {\n\t\tint area = 0;\n\t\tfor (int x = x1 + 1; x <= x2; x++)\n\t\t\tfor (int y = y1 + 1; y <= y2; y++)\n\t\t\t\tif (sp[x][y] == 1) {\n\t\t\t\t\tarea++;\n\t\t\t\t\tsp[x][y] = 0;\n\t\t\t\t}\n\t\tif (xmin > x1)\n\t\t\txmin = x1;\n\t\tif (ymin > y1)\n\t\t\tymin = y1;\n\t\tif (xmax < x2)\n\t\t\txmax = x2;\n\t\tif (ymax < y2)\n\t\t\tymax = y2;\n\t\treturn area;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<LinkedList<Integer>> coordinateAll = new ArrayList<LinkedList<Integer>>();\n\t\twhile(true){\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\t//buf=null;\n\t\t\t\tcoordinateAll.add(null);\n\t\t\t}\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tLinkedList<Integer> temp = new LinkedList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tLinkedList<Integer> new_temp =new LinkedList<Integer>();\n\t\t\t\t\t\tnew_temp = (LinkedList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\t//int cf_counter = Circumference(coordinateAll);\n\t\t\t\tcircumference = curCal(coordinateAll);\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t}\n\t}\n//周長を求める\n\tprivate static int curCal(ArrayList<LinkedList<Integer>> coordinateAll){\n\t\tint circumference = 0;\n\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\tLinkedList<Integer> check0;\n\t\t\tif(i==0){\n\t\t\t\tcheck0 =null;\n\t\t\t}else{\n\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t}\n\t\t\tLinkedList<Integer> check1 = coordinateAll.get(i);\n\t\t\tLinkedList<Integer> check2 = null;\n\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\tcheck2 =null;\n\t\t\t}else{\n\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t}\n\t\t\tLinkedList<Integer>mergeCheck = new LinkedList<Integer>();\n\t\t\t//= coordinateAll.get(i+1);\n\t\t\tif(check1!=null){\n\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\tif(check2==null){\n\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\tif(check0!=null){\n\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t}\n\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn circumference;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString line = reader.readLine();\n\t\t\tString[] str1 = line.split(\" \", -1);\n\t\t\tint n = Integer.parseInt(str1[0]);\n\t\t\tint r = Integer.parseInt(str1[1]);\n\t\t\tif(n == 0 && r == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint area = 0;\n\t\t\tint length = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString lines = reader.readLine();\n\t\t\t\tString[] str = lines.split(\" \", -1);\n\t\t\t\tint x1 = Integer.parseInt(str[0]);\n\t\t\t\tint y1 = Integer.parseInt(str[1]);\n\t\t\t\tint x2 = Integer.parseInt(str[2]);\n\t\t\t\tint y2 = Integer.parseInt(str[3]);\n\t\t\t\tarea += (x2 - x1) * (y2 - y1);\n\t\t\t\tif(r == 2){\n\t\t\t\t\tlength += ((x2 - x1) + (y2 - y1)) * 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif(r == 2){\n\t\t\t\tSystem.out.println(length);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n, r;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tLinkedList<Rect> rects = new LinkedList<Rect>();\n\t\t\tif( (n|r) == 0 ) break;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint x1 = Integer.parseInt(sc.next());\n\t\t\t\tint y1 = Integer.parseInt(sc.next());\n\t\t\t\tint x2 = Integer.parseInt(sc.next());\n\t\t\t\tint y2 = Integer.parseInt(sc.next());\n\t\t\t\tLinkedList<Rect> tmp = new LinkedList<Rect>();\n\t\t\t\tRect rect = new Rect(x1, y1, x2, y2);\n\t\t\t\tfor(Rect rect2: rects) {\n\t\t\t\t\tRect lap = rect.LappRect(rect2);\n\t\t\t\t\tif( (lap.x1|lap.y1|lap.x2|lap.y2) != 0 ) {\n\t\t\t\t\t\tlap.c = rect2.c * -1;\n\t\t\t\t\t\ttmp.add(lap);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trects.add(rect);\n\t\t\t\trects.addAll(tmp);\n\t\t\t}\n\t\t\tif( r==1 ) {\n\t\t\t\tint area = 0;\n\t\t\t\tfor(Rect rect: rects) {\n//\t\t\t\t\tdebug(rect.x1, rect.y1, rect.x2, rect.y2, rect.c);\n\t\t\t\t\tarea += rect.area();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(area);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint area = 0;\n\t\t\t\tint line = 0;\n\t\t\t\tfor(Rect rect: rects) {\n//\t\t\t\t\tdebug(rect.x1, rect.y1, rect.x2, rect.y2, rect.c);\n\t\t\t\t\tarea += rect.area();\n\t\t\t\t\tline += rect.line();\n\t\t\t\t}\n//\t\t\t\tdebug(\"    \");\n\t\t\t\tSystem.out.println(area);\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass Rect {\n\t\tint x1, y1, x2, y2;\n\t\tint c;\n\t\tRect(int x1, int y1, int x2, int y2) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tc = 1;\n\t\t}\n\t\t\n\t\tint area() {\n\t\t\treturn (x2-x1) * (y2-y1) * c;\n\t\t}\n\t\t\n\t\tint line() {\n\t\t\treturn 2 * ( x2-x1 + y2-y1 ) * c;\n\t\t}\n\t\t\n\t\tRect LappRect(Rect r) {\n\t\t\tint rx1 = max(x1, r.x1);\n\t\t\tint ry1 = max(y1, r.y1);\n\t\t\tint rx2 = min(x2, r.x2);\n\t\t\tint ry2 = min(y2, r.y2);\n\t\t\t\n\t\t\tif( rx1 <= rx2 && ry1 <= ry2 ) {\n\t\t\t\treturn new Rect(rx1, ry1, rx2, ry2);\n\t\t\t}\n\t\t\treturn new Rect(0, 0, 0, 0);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\n\n// Volume5-0509 Sheets Main5_0509\npublic class Main {\n\n    class Rect {\n        int x0;\n        int y0;\n        int x1;\n        int y1;\n    }\n\n    class Range {\n        Range(int x, int f) {\n            this.x = x;\n            this.f = f;\n        }\n        int x;\n        int f;   // f = 1:start f = 11:end\n    }\n\n    // rangeListに範囲を追加する\n    void addRange(List<Integer> rangeList, int start, int end) {\n        for(int i = 0; i < rangeList.size(); i++) {\n            if (rangeList.get(i) >= start) {\n\n            }\n\n\n        }\n\n    }\n\n\n\t// メイン return falseでおしまい\n\tboolean main() throws IOException {\n\n\t\tint[] ir = readIntArray();\n\t\tint n = ir[0];\n\t\tint r = ir[1]; // 1面積 2 面積:周長\n\t\tif (n == 0)\n\t\t    return false;\n\n\t\tRect[] rects = new Rect[n];\n        Rect[] rects2 = new Rect[n];\n\t\tSet<Integer> ySet = new HashSet<Integer>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tir = readIntArray();\n\t\t\trects[i] = new Rect();\n\t\t\trects[i].x0 = ir[0];\n            rects[i].y0 = ir[1];\n            rects[i].x1 = ir[2];\n            rects[i].y1 = ir[3];\n\n            rects2[i] = new Rect();\n            rects2[i].y0 = ir[0];\n            rects2[i].x0 = ir[1];\n            rects2[i].y1 = ir[2];\n            rects2[i].x1 = ir[3];\n\t\t}\n\n        int slen = 0; // 周長\n        int s = 0; // 面積\n\n///\n        {\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n\t\t}\n\t\tInteger[] ya = ySet.toArray(new Integer[0]);\n\t\tArrays.sort(ya);\n\t\tfor(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n\t\t    List<Range> rangeList = new ArrayList<Range>();\n\n\t\t    for(int k = 0; k < n; k++) {\n\t\t        if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n    \t\t        Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n\t\t        }\n\t\t    }\n\t\t    Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n\t\t    int c = 0;\n\t\t    int cx = 0;\n\t\t    for(Range ra : rangeList) {\n\t\t        if (ra.f > 0) {\n\t\t            c++;\n\t\t            if (c == 1) {\n\t\t                cx = ra.x;\n\t\t                slen += h;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            c--;\n\t\t            if (c == 0) {\n\t\t                log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n\t\t                s += (ra.x - cx) * h;\n                        slen += h;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n        }\n\n\t\trects = rects2;\n\t\t///\n\t\t{\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n        }\n        Integer[] ya = ySet.toArray(new Integer[0]);\n        Arrays.sort(ya);\n        for(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n            List<Range> rangeList = new ArrayList<Range>();\n\n            for(int k = 0; k < n; k++) {\n                if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n                    Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n                }\n            }\n            Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n            int c = 0;\n            int cx = 0;\n            for(Range ra : rangeList) {\n                if (ra.f > 0) {\n                    c++;\n                    if (c == 1) {\n                        cx = ra.x;\n                        slen += h;\n                    }\n                }\n                else {\n                    c--;\n                    if (c == 0) {\n                        log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n                        s += (ra.x - cx) * h;\n                        slen += h;\n                    }\n                }\n            }\n        }\n\t\t}\n\n\t\tSystem.out.printf(\"%d\\n\", s/2);\n        if (r == 2) System.out.printf(\"%d\\n\", slen);\n\n\n\t\treturn true; // 正常終了 次へ\n\t}\n\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\n\t\t\tString inputStr = \"5 1:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"2 2:0 0 8 9: 0 0 9 8:\";\n\t\t\tinputStr += \"0 0:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr));\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // 書き捨て\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // コンソールから\n\t\t}\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treader.close();\n\t}\n\n\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // ※※※　どうも突然空行を読むことがある。読み飛ばすとうまくいくらしい。。。。\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "package d2018;\n\nimport java.io.*;\nimport java.util.*;\n\n\n\n// Volume5-0509 Sheets\npublic class Main5_0509 {\n\n    class Rect {\n        int x0;\n        int y0;\n        int x1;\n        int y1;\n    }\n\n    class Range {\n        Range(int x, int f) {\n            this.x = x;\n            this.f = f;\n        }\n        int x;\n        int f;   // f = 1:start f = 11:end\n    }\n\n    // rangeListに範囲を追加する\n    void addRange(List<Integer> rangeList, int start, int end) {\n        for(int i = 0; i < rangeList.size(); i++) {\n            if (rangeList.get(i) >= start) {\n\n            }\n\n\n        }\n\n    }\n\n\n\t// メイン return falseでおしまい\n\tboolean main() throws IOException {\n\n\t\tint[] ir = readIntArray();\n\t\tint n = ir[0];\n\t\tint r = ir[1]; // 1面積 2 面積:周長\n\t\tif (n == 0)\n\t\t    return false;\n\n\t\tRect[] rects = new Rect[n];\n        Rect[] rects2 = new Rect[n];\n\t\tSet<Integer> ySet = new HashSet<Integer>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tir = readIntArray();\n\t\t\trects[i] = new Rect();\n\t\t\trects[i].x0 = ir[0];\n            rects[i].y0 = ir[1];\n            rects[i].x1 = ir[2];\n            rects[i].y1 = ir[3];\n\n            rects2[i] = new Rect();\n            rects2[i].y0 = ir[0];\n            rects2[i].x0 = ir[1];\n            rects2[i].y1 = ir[2];\n            rects2[i].x1 = ir[3];\n\t\t}\n\t\t\n        int slen = 0; // 周長\n        int s = 0; // 面積\n\n///\n        {\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n\t\t}\n\t\tInteger[] ya = ySet.toArray(new Integer[0]);\n\t\tArrays.sort(ya);\n\t\tfor(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n\t\t    List<Range> rangeList = new ArrayList<Range>();\n\n\t\t    for(int k = 0; k < n; k++) {\n\t\t        if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n    \t\t        Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n\t\t        }\n\t\t    }\n\t\t    Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n\t\t    int c = 0;\n\t\t    int cx = 0;\n\t\t    for(Range ra : rangeList) {\n\t\t        if (ra.f > 0) {\n\t\t            c++;\n\t\t            if (c == 1) {\n\t\t                cx = ra.x;\n\t\t                slen += h;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            c--;\n\t\t            if (c == 0) {\n\t\t                log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n\t\t                s += (ra.x - cx) * h;\n                        slen += h;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n        }\n\t\t\n\t\trects = rects2;\n\t\t///\n\t\t{\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n        }\n        Integer[] ya = ySet.toArray(new Integer[0]);\n        Arrays.sort(ya);\n        for(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n            List<Range> rangeList = new ArrayList<Range>();\n\n            for(int k = 0; k < n; k++) {\n                if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n                    Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n                }\n            }\n            Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n            int c = 0;\n            int cx = 0;\n            for(Range ra : rangeList) {\n                if (ra.f > 0) {\n                    c++;\n                    if (c == 1) {\n                        cx = ra.x;\n                        slen += h;\n                    }\n                }\n                else {\n                    c--;\n                    if (c == 0) {\n                        log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n                        s += (ra.x - cx) * h;\n                        slen += h;\n                    }\n                }\n            }\n        }\n\t\t}\n\n\t\tSystem.out.printf(\"%d\\n\", s/2);\n        if (r == 2) System.out.printf(\"%d\\n\", slen);\n\t\t\n\n\t\treturn true; // 正常終了 次へ\n\t}\n\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\n\t\t\tString inputStr = \"5 1:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"2 2:0 0 8 9: 0 0 9 8:\";\n\t\t\tinputStr += \"0 0:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr));\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // 書き捨て\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // コンソールから\n\t\t}\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main5_0509().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treader.close();\n\t}\n\n\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // ※※※　どうも突然空行を読むことがある。読み飛ばすとうまくいくらしい。。。。\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tint numOfSheet = in.nextInt();\n\t\tint probNum = in.nextInt();\n\t\tint[][] matrix;\n\t\twhile(!(numOfSheet==0 && probNum==0)) {\n\t\t\tint maxX = 0, maxY = 0;\n\t\t\tint[][] data = new int[numOfSheet][4];\n\t\t\tfor(int i=0; i<numOfSheet; i++) {\n\t\t\t\tdata[i][0] = in.nextInt();//x1\n\t\t\t\tdata[i][1] = in.nextInt();//y1\n\t\t\t\tdata[i][2] = in.nextInt();//x2\n\t\t\t\tdata[i][3] = in.nextInt();//y2\n\t\t\t\t\n\t\t\t\tif(data[i][0]>maxX) maxX=data[i][0];\n\t\t\t\tif(data[i][2]>maxX) maxX=data[i][2];\n\t\t\t\tif(data[i][1]>maxY) maxY=data[i][1];\n\t\t\t\tif(data[i][3]>maxY) maxY=data[i][3];\n\t\t\t}\n\t\t\t\n\t\t\tmatrix = new int[maxX+1][maxY+1];\n\t\t\t\n\t\t\tfor(int i=0; i<data.length; i++) {\n\t\t\t\tfor(int j=data[i][0]; j<data[i][2]; j++) {\n\t\t\t\t\tfor(int k=data[i][1]; k<data[i][3]; k++) {\n\t\t\t\t\t\tmatrix[k][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(probNum==1 || probNum==2) {\n\t\t\t\tint area = 0;\n\t\t\t\tfor(int i=0; i<matrix.length; i++) {\n\t\t\t\t\tfor(int j=0; j<matrix[i].length; j++) {\n\t\t\t\t\t\tarea+= matrix[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(area);\n\t\t\t}\n\t\t\tif(probNum==2) {\n\t\t\t\tint length = 0;\n\t\t\t\tfor(int i=0; i<matrix.length; i++) {\n\t\t\t\t\tfor(int j=0; j<matrix[i].length; j++) {\n\t\t\t\t\t\tif(matrix[i][j] == 1) length += getLength(i, j, matrix);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(length);\n\t\t\t}\n\t\t\tnumOfSheet = in.nextInt();\n\t\t\tprobNum = in.nextInt();\n\t\t}\n\t}\n\t\n\tpublic static int getLength(int x, int y, int[][] matrix) {\n\t\tint ret = 0;\n\t\tint n = 0;\n\t\tif(x==0&&y==0) n = matrix[x][y+1] + matrix[x+1][y];\n\t\telse if(x==0&&y==matrix[0].length-1) n = matrix[x][y-1] + matrix[x+1][y];\n\t\telse if(x==matrix.length-1&&y==0) n = matrix[x-1][y] + matrix[x][y+1];\n\t\telse if(x==matrix.length-1&&y==matrix[x].length-1) n = matrix[x][y-1] + matrix[x-1][y];\n\t\telse if(x==0) n = matrix[x][y+1] + matrix[x][y-1] + matrix[x+1][y];\n\t\telse if(x==matrix.length-1) n = matrix[x][y+1] + matrix[x][y-1] + matrix[x-1][y];\n\t\telse if(y==0) n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y+1];\n\t\telse if(y==matrix[x].length-1) n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y-1];\n\t\telse n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y-1] + matrix[x][y+1];\n\t\t\n\t\tswitch(n){\n\t\tcase 1:\n\t\t\tret = 3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<ArrayList<Integer>> coordinateAll = new ArrayList<ArrayList<Integer>>();\n\t\twhile(true){\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\t//buf=null;\n\t\t\t\tcoordinateAll.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tArrayList<Integer> temp = new ArrayList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tArrayList<Integer> new_temp =new ArrayList<Integer>();\n\t\t\t\t\t\tnew_temp = (ArrayList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t\t//new_temp=null;\n\t\t\t\t\t}\n\t\t\t\t\t//temp=null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(ArrayList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\t\t\tArrayList<Integer> check0;\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tcheck0 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t\t\t}\n\t\t\t\t\tArrayList<Integer> check1 = coordinateAll.get(i);\n\t\t\t\t\tArrayList<Integer> check2;\n\t\t\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\t\t\tcheck2 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t\t\t}\n\t\t\t\t\tArrayList<Integer>mergeCheck = new ArrayList<Integer>();\n\t\t\t\t\t//= coordinateAll.get(i+1);\n\t\t\t\t\tif(check1!=null){\n\t\t\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\t\t\tif(check2==null){\n\t\t\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\t\t\tif(check0!=null){\n\t\t\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck=null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//circumference = curCal(coordinateAll);\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t}\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    private static class Field {\n        static final int MAX_COORDINATE = 10000;\n        BitSet[] horizonFieldLines;\n        BitSet[] verticalFieldLines;\n\n        private Field() {\n            horizonFieldLines  = new BitSet[MAX_COORDINATE + 2];\n            for (int i=0; i<horizonFieldLines.length; i++) {\n                horizonFieldLines[i] = new BitSet();\n            }\n        }\n\n        private void addSheet(int x1, int y1, int x2, int y2) {\n            for (int i=y1+1; i<=y2; i++) {\n                horizonFieldLines[i].set(x1+1, x2+1);\n            }\n        }\n\n        private void makeInvertedIndex() {\n            verticalFieldLines = new BitSet[MAX_COORDINATE + 2];\n            for (int i=0; i<verticalFieldLines.length; i++) {\n                verticalFieldLines[i] = new BitSet();\n            }\n\n            for (int y=0; y<MAX_COORDINATE; y++) {\n                for (int x=0; x<horizonFieldLines[y].length(); x++) {\n                    if (horizonFieldLines[y].get(x)) {\n                        verticalFieldLines[x].set(y);\n                    }\n                }\n            }\n        }\n\n        private int measureDimention() {\n            int dimention = 0;\n\n            for (BitSet hfLine: horizonFieldLines) {\n                dimention += hfLine.cardinality();\n            }\n\n            return dimention;\n        }\n\n        private int mesureSurroundLength() {\n            int surroundLength = 0;\n\n            for (BitSet hfLine: horizonFieldLines) {\n                if (!hfLine.isEmpty()) {\n                    BitSet shiftBS = hfLine.get(1, hfLine.length());\n                    shiftBS.xor(hfLine);\n                    surroundLength += shiftBS.cardinality();\n                }\n            }\n\n            for (BitSet vfLine:verticalFieldLines) {\n                if (!vfLine.isEmpty()) {\n                    BitSet shiftBS = vfLine.get(1, vfLine.length());\n                    shiftBS.xor(vfLine);\n                    surroundLength += shiftBS.cardinality();\n                }\n            }\n\n            return surroundLength;\n        }\n     }\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        for (int dataIt=0; dataIt<10; dataIt++) {\n            int n = Integer.parseInt(sc.next());\n            int r = Integer.parseInt(sc.next());\n            if (r <= 0) {\n                break;\n            }\n\n            Field field = new Field();\n\n            for (int sheetIt=0; sheetIt<n; sheetIt++) {\n                int x1 = Integer.parseInt(sc.next());\n                int y1 = Integer.parseInt(sc.next());\n                int x2 = Integer.parseInt(sc.next());\n                int y2 = Integer.parseInt(sc.next());\n                field.addSheet(x1, y1, x2, y2);\n            }\n\n            System.out.println(field.measureDimention());\n            if (r == 2) {\n                field.makeInvertedIndex();\n                System.out.println(field.mesureSurroundLength());\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n\tint MAX = 10005;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] area = new int[MAX][MAX];\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), r = sc.nextInt();\n\t\t\tif ((n|r) == 0) break;\n\t\t\tfor (int[] a: area) fill(a, 0);\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tint x1 = sc.nextInt()+1, y1 = sc.nextInt()+1, x2 = sc.nextInt()+1, y2 = sc.nextInt()+1;\n\t\t\t\tarea[y1][x1]++; area[y2][x1]--;\n\t\t\t\tarea[y1][x2]--; area[y2][x2]++;\n\t\t\t}\n\t\t\tfor (int y=1;y<MAX;y++) for (int x=1;x<MAX;x++) {\n\t\t\t\tarea[y][x] += area[y][x-1];\n\t\t\t}\n\t\t\tfor (int y=1;y<MAX;y++) for (int x=1;x<MAX;x++) {\n\t\t\t\tarea[x][y] += area[x-1][y];\n\t\t\t}\n//\t\t\tfor (int[] a:area) debug(a);\n\t\t\tint a = 0, l = 0;\n\t\t\tfor (int y=1;y<MAX;y++) for (int x=1;x<MAX;x++) {\n\t\t\t\tif (area[y][x] > 0) a++;\n\t\t\t\tif (((area[y][x] | area[y-1][x]) != 0 ) && area[y][x] * area[y-1][x] == 0) l++;\n\t\t\t\tif (((area[y][x] | area[y][x-1]) != 0 ) && area[y][x] * area[y][x-1] == 0) l++;\n\t\t\t}\n\t\t\tSystem.out.println(a);\n\t\t\tif (r == 2) System.out.println(l);\n\t\t}\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.out.println(deepToString(os));\n\t}\n\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new File(\"c:\\\\0509-input.txt\"));\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\t\t\tif (n == 0 && r == 0)\n\t\t\t\tbreak;\n\n\t\t\tint[] x1 = new int[n];\n\t\t\tint[] y1 = new int[n];\n\t\t\tint[] x2 = new int[n];\n\t\t\tint[] y2 = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx1[i] = scan.nextInt();\n\t\t\t\ty1[i] = scan.nextInt();\n\t\t\t\tx2[i] = scan.nextInt();\n\t\t\t\ty2[i] = scan.nextInt();\n\t\t\t}\n\t\t\tRects rect = new Rects();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trect.setRect(x1[i], y1[i], x2[i], y2[i]);\n\t\t\t}\n\t\t\tSystem.out.println(rect.area());\n\t\t\tif (r == 1)\n\t\t\t\tcontinue;\n\t\t\tlong side = rect.side();\n\n\t\t\trect = null;\n\t\t\trect = new Rects();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trect.setRect(y1[i], x1[i], y2[i], x2[i]);\n\t\t\t}\n\t\t\tside += rect.side();\n\t\t\tSystem.out.println(side);\n\n\t\t\t// rect.debug();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Vbar {\n\tpublic int y1;\n\tpublic int y2;\n\n\tpublic Vbar(int _y1, int _y2) {\n\t\ty1 = _y1;\n\t\ty2 = _y2;\n\t}\n\n\tpublic long getLength() {\n\t\treturn y2 - y1;\n\t}\n}\n\nclass VbarList {\n\tList<Vbar> bar = new ArrayList<Vbar>();\n\n\tpublic int getSide() {\n\t\treturn bar.size() * 2;\n\t}\n\n\tpublic int getLength() {\n\t\tint len = 0;\n\t\tfor (int i = 0; i < bar.size(); i++)\n\t\t\tlen += bar.get(i).getLength();\n\t\treturn len;\n\t}\n\n\tpublic void setRect(int y1, int y2) {\n\t\tfor (int i = 0; i < bar.size(); i++) {\n\t\t\tif (y2 < bar.get(i).y1) {\n\t\t\t\tbar.add(i, new Vbar(y1, y2));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (y1 <= bar.get(i).y2) {\n\t\t\t\tbar.get(i).y1 = Math.min(bar.get(i).y1, y1);\n\t\t\t\tbar.get(i).y2 = Math.max(bar.get(i).y2, y2);\n\t\t\t\tthis.margeRect(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbar.add(new Vbar(y1, y2));\n\t}\n\n\tprivate void margeRect(int st) {\n\t\tint i = st + 1;\n\t\twhile (i < bar.size()) {\n\t\t\tif (bar.get(st).y2 < bar.get(i).y1)\n\t\t\t\tbreak;\n\t\t\tbar.get(st).y2 = Math.max(bar.get(st).y2, bar.get(i).y2);\n\t\t\tbar.remove(i);\n\t\t}\n\t}\n\n\tpublic void debug(int x) {\n\t\tfor (int i = 0; i < bar.size(); i++)\n\t\t\tSystem.out.println(x + \":\" + i + \" \" + bar.get(i).y1 + \"-\" + bar.get(i).y2);\n\t}\n}\n\nclass Rects {\n\tprivate VbarList[] vb = new VbarList[10000];\n\n\tRects() {\n\t\tfor (int x = 0; x < vb.length; x++)\n\t\t\tvb[x] = new VbarList();\n\t}\n\n\tpublic void debug() {\n\t\tfor (int x = 0; x < vb.length; x++)\n\t\t\tvb[x].debug(x);\n\t}\n\n\tpublic long side() {\n\t\tlong result = 0;\n\t\tfor (int x = 0; x < vb.length; x++)\n\t\t\tresult += vb[x].getSide();\n\t\treturn result;\n\t}\n\n\tpublic long area() {\n\t\tlong result = 0;\n\t\tfor (int x = 0; x < vb.length; x++)\n\t\t\tresult += vb[x].getLength();\n\t\treturn result;\n\t}\n\n\tpublic void setRect(int x1, int y1, int x2, int y2) {\n\t\tfor (int x = x1; x < x2; x++)\n\t\t\tvb[x].setRect(y1, y2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<ArrayList<Integer>> coordinateAll = new ArrayList<ArrayList<Integer>>();\n\t\twhile(true){\n\t\t\tcoordinateAll.clear();\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\t//buf=null;\n\t\t\t\tcoordinateAll.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tArrayList<Integer> temp = new ArrayList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tArrayList<Integer> new_temp =new ArrayList<Integer>();\n\t\t\t\t\t\tnew_temp = (ArrayList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t\t//new_temp=null;\n\t\t\t\t\t}\n\t\t\t\t\t//temp=null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(ArrayList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\t\t\tArrayList<Integer> check0;\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tcheck0 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t\t\t}\n\t\t\t\t\tArrayList<Integer> check1 = coordinateAll.get(i);\n\t\t\t\t\tArrayList<Integer> check2;\n\t\t\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\t\t\tcheck2 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t\t\t}\n\t\t\t\t\tArrayList<Integer>mergeCheck = new ArrayList<Integer>();\n\t\t\t\t\t//= coordinateAll.get(i+1);\n\t\t\t\t\tif(check1!=null){\n\t\t\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\t\t\tif(check2==null){\n\t\t\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\t\t\tif(check0!=null){\n\t\t\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck=null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//circumference = curCal(coordinateAll);\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\n\n// Volume5-0509 Sheets Main5_0509\npublic class Main {\n\n    class Rect {\n        int x0;\n        int y0;\n        int x1;\n        int y1;\n    }\n\n    class Range {\n        Range(int x, int f) {\n            this.x = x;\n            this.f = f;\n        }\n        int x;\n        int f;   // f = 1:start f = -1:end\n    }\n\n\t// メイン return falseでおしまい\n\tboolean main() throws IOException {\n\n\t\tint[] ir = readIntArray();\n\t\tint n = ir[0];\n\t\tint r = ir[1]; // 1面積 2 面積:周長\n\t\tif (n == 0)\n\t\t    return false;\n\n\t\tRect[] rects = new Rect[n];\n        Rect[] rects2 = new Rect[n];\n\t\tSet<Integer> ySet = new TreeSet<Integer>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tir = readIntArray();\n\t\t\trects[i] = new Rect();\n\t\t\trects[i].x0 = ir[0];\n            rects[i].y0 = ir[1];\n            rects[i].x1 = ir[2];\n            rects[i].y1 = ir[3];\n\n            rects2[i] = new Rect();\n            rects2[i].y0 = ir[0];\n            rects2[i].x0 = ir[1];\n            rects2[i].y1 = ir[2];\n            rects2[i].x1 = ir[3];\n\t\t}\n\n        int slen = 0; // 周長\n        int s = 0; // 面積\n\n///\n        {\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n\t\t}\n\t\tInteger[] ya = ySet.toArray(new Integer[0]);\n\t\tArrays.sort(ya);\n\t\tfor(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n\t\t    List<Range> rangeList = new ArrayList<Range>();\n\n\t\t    for(int k = 0; k < n; k++) {\n\t\t        if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n    \t\t        Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n\t\t        }\n\t\t    }\n\t\t    Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n\t\t    int c = 0;\n\t\t    int cx = 0;\n\t\t    for(Range ra : rangeList) {\n\t\t        if (ra.f > 0) {\n\t\t            c++;\n\t\t            if (c == 1) {\n\t\t                cx = ra.x;\n\t\t                slen += h;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            c--;\n\t\t            if (c == 0) {\n\t\t                log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n\t\t                s += (ra.x - cx) * h;\n                        slen += h;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n        }\n\n\t\trects = rects2;\n\t\t///\n\t\t{\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n        }\n        Integer[] ya = ySet.toArray(new Integer[0]);\n        Arrays.sort(ya);\n        for(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n            List<Range> rangeList = new ArrayList<Range>();\n\n            for(int k = 0; k < n; k++) {\n                if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n                    Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n                }\n            }\n            Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n            int c = 0;\n            int cx = 0;\n            for(Range ra : rangeList) {\n                if (ra.f > 0) {\n                    c++;\n                    if (c == 1) {\n                        cx = ra.x;\n                        slen += h;\n                    }\n                }\n                else {\n                    c--;\n                    if (c == 0) {\n                        log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n                        s += (ra.x - cx) * h;\n                        slen += h;\n                    }\n                }\n            }\n        }\n\t\t}\n\n\t\tSystem.out.printf(\"%d\\n\", s/2);\n        if (r == 2) System.out.printf(\"%d\\n\", slen);\n\n\n\t\treturn true; // 正常終了 次へ\n\t}\n\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\n\t\t\t//String inputStr = \"5 1:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"5 2:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"2 2:0 0 8 9: 0 0 9 8:\";\n            String inputStr = \"3 2:2 2 8 8:3 0 4 9:5 0 7 9:\";\n\t\t\tinputStr += \"0 0:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr));\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // 書き捨て\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // コンソールから\n\t\t}\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treader.close();\n\t}\n\n\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // ※※※　どうも突然空行を読むことがある。読み飛ばすとうまくいくらしい。。。。\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<LinkedList<Integer>> coordinateAll = new ArrayList<LinkedList<Integer>>();\n\t\twhile(true){\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\t//buf=null;\n\t\t\t\tcoordinateAll.add(null);\n\t\t\t}\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tLinkedList<Integer> temp = new LinkedList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tLinkedList<Integer> new_temp =new LinkedList<Integer>();\n\t\t\t\t\t\tnew_temp = (LinkedList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tif(judge ==1){\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\t\t\tLinkedList<Integer> check0;\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tcheck0 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer> check1 = coordinateAll.get(i);\n\t\t\t\t\tLinkedList<Integer> check2 = null;\n\t\t\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\t\t\tcheck2 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer>mergeCheck = new LinkedList<Integer>();\n\t\t\t\t\t//= coordinateAll.get(i+1);\n\t\t\t\t\tif(check1!=null){\n\t\t\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\t\t\tif(check2==null){\n\t\t\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\t\t\tif(check0!=null){\n\t\t\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//circumference = curCal(coordinateAll);\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final int MAX_N = 10000;\n\n  // inner classes\n\n  static class Diff {\n    int x1, d1, x2, d2;\n\n    Diff(int x1, int d1, int x2, int d2) {\n      this.x1 = x1;\n      this.d1 = d1;\n      this.x2 = x2;\n      this.d2 = d2;\n    }\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int n = sc.nextInt();\n      int r = sc.nextInt();\n      if ((n | r) == 0) break;\n\n      ArrayList<ArrayList<Diff>> diffs = new ArrayList<ArrayList<Diff>>();\n      for (int i = 0; i < MAX_N + 2; i++)\n        diffs.add(new ArrayList<Diff>());\n\n      int minx = MAX_N + 1, miny = MAX_N + 1;\n      int maxx = 0, maxy = 0;\n\n      for (int i = 0; i < n; i++) {\n        int x1 = sc.nextInt() + 1;\n        int y1 = sc.nextInt();\n        int x2 = sc.nextInt() + 1;\n        int y2 = sc.nextInt();\n\n        if (minx > x1) minx = x1;\n        if (miny > y1) miny = y1;\n        if (maxx < x2) maxx = x2;\n        if (maxy < y2) maxy = y2;\n\n        diffs.get(y1).add(new Diff(x1,  1, x2, -1));\n        diffs.get(y2).add(new Diff(x1, -1, x2,  1));\n      }\n\n      int area = 0;\n      int len = 0;\n\n      int[][] ylines = new int[2][MAX_N + 2];\n      Arrays.fill(ylines[0], 0);\n\n      int prvy = 0;\n      int cury = 1;\n\n      for (int y = miny; y <= maxy; y++) {\n        Arrays.fill(ylines[cury], 0);\n\n        for (Diff df: diffs.get(y)) {\n          ylines[cury][df.x1] += df.d1;\n          ylines[cury][df.x2] += df.d2;\n        }\n\n        int sumx = 0;\n        for (int x = minx; x <= maxx; x++) {\n          sumx += ylines[cury][x];\n          ylines[cury][x] = ylines[prvy][x] + sumx;\n        }\n\n        for (int x = minx; x <= maxx; x++) {\n          if (ylines[cury][x] > 0) {\n            area++;\n            if (ylines[cury][x - 1] == 0) len++;\n            if (ylines[cury][x + 1] == 0) len++;\n            if (ylines[prvy][x] == 0) len++;\n          }\n          else {\n            if (ylines[prvy][x] > 0) len++;\n          }\n        }\n\n        prvy = cury;\n        cury = 1 - cury;\n      }\n\n      System.out.println(area);\n      if (r == 2) System.out.println(len);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Set;\n\n//Sheets\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass E implements Comparable<E>{\n\t\tint id, type, x;\n\t\tpublic E(int id, int type, int x) {\n\t\t\tthis.id = id;\n\t\t\tthis.type = type;\n\t\t\tthis.x = x;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn x-o.x;\n\t\t}\t\t\n\t}\n\t\n\tint[] x1, y1, x2, y2;\n\tint n, r, area, len;\n\tint mask = (1<<16)-1;\n\t\n\tvoid f(){\n//\t\tlong T = System.currentTimeMillis();\n\t\tPriorityQueue<E> q = new PriorityQueue<E>(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tq.add(new E(i, 0, x1[i]));\n\t\t\tq.add(new E(i, 1, x2[i]));\n\t\t}\n\t\tint preX = 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tList<Integer> range = new ArrayList<Integer>();\n\t\twhile(!q.isEmpty()){\n\t\t\tE e = q.poll();\n//\t\t\tSystem.out.println(\"YOKO:\"+range.size()*2*(e.x-preX));\n\t\t\tlen+=range.size()*2*(e.x-preX);\n\t\t\tfor(int m:range){\n\t\t\t\tint s = m>>16, t = m&mask;\n//\t\t\t\tSystem.out.printf(\"[%d, %d]\\n\", s, t);\n\t\t\t\tarea+=(e.x-preX)*(t-s);\n\t\t\t}\n\t\t\tif(e.type==0)set.add(e.id);\n\t\t\telse set.remove(e.id);\n\t\t\tpreX = e.x;\n\t\t\twhile(!q.isEmpty() && q.peek().x==e.x){\n\t\t\t\tE ee = q.poll();\n\t\t\t\tif(ee.type==0)set.add(ee.id);\n\t\t\t\telse set.remove(ee.id);\n\t\t\t}\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tList<Integer> v = new ArrayList<Integer>();\n\t\t\tfor(int i:set)list.add((y1[i]<<16)|y2[i]);\n\t\t\tCollections.sort(list);\n\t\t\tint L = -1, R = -1;\n\t\t\tfor(int m:list){\n\t\t\t\tint s = m>>16, t = m&mask;\n\t\t\t\tif(R < s){\n\t\t\t\t\tif(R!=-1){\n\t\t\t\t\t\tnext.add((L<<16)|R);\n\t\t\t\t\t\tv.add((L<<16)|R);\n\t\t\t\t\t}\n\t\t\t\t\tL = s; R = t;\n\t\t\t\t}\n\t\t\t\telse R = Math.max(R, t);\n\t\t\t}\n\t\t\tif(R!=-1){\n\t\t\t\tnext.add((L<<16)|R);\n\t\t\t\tv.add((L<<16)|R);\n\t\t\t}\n\t\t\tif(r==1){\n\t\t\t\trange = next; continue;\n\t\t\t}\n\t\t\tif(q.isEmpty()){\n\t\t\t\tfor(int m:range){\n\t\t\t\t\tint s = m>>16, t = m&mask;\n\t\t\t\t\tlen+=t-s;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(;;){\n\t\t\t\tboolean con = false;\n\t\t\t\tfor(int i=0;i<v.size()&&!con;i++){\n\t\t\t\t\tint m = v.get(i);\n\t\t\t\t\tint s = m>>16, t = m&mask;\n\t\t\t\t\tfor(int j=0;j<range.size()&&!con;j++){\n\t\t\t\t\t\tint M = range.get(j);\n\t\t\t\t\t\tint a = M>>16, b = M&mask;\n\t\t\t\t\t\tif(b <= s || t <= a)continue;\n\t\t\t\t\t\tif(a <= s && t <= b){\n\t\t\t\t\t\t\tcon = true; v.remove(i); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s < a && b < t){\n\t\t\t\t\t\t\tcon = true; v.remove(i);\n\t\t\t\t\t\t\tv.add((s<<16)|a);\n\t\t\t\t\t\t\tv.add((b<<16)|t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a <= s){\n\t\t\t\t\t\t\tcon = true; v.remove(i); v.add((b<<16)|t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tcon = true; v.remove(i); v.add((s<<16)|a);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!con)break;\n\t\t\t}\n//\t\t\tint sum = 0;\n\t\t\tfor(int m:v){\n\t\t\t\tint s = m>>16, t = m&mask;\n\t\t\t\tlen+=t-s;\n//\t\t\t\tsum+=t-s;\n\t\t\t}\n//\t\t\tSystem.out.println(\"TATE:\"+sum);\n\t\t\trange = next;\n\t\t}\n//\t\tSystem.out.println(System.currentTimeMillis()-T);\n//\t\tSystem.out.println(\"F:\"+F);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tx1 = new int[10000]; y1 = new int[10000]; x2 = new int[10000]; y2 = new int[10000];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); r = sc.nextInt();\n\t\t\tif((n|r)==0)break;\n\t\t\tarea = len = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx1[i] = sc.nextInt(); y1[i] = sc.nextInt();\n\t\t\t\tx2[i] = sc.nextInt(); y2[i] = sc.nextInt();\n\t\t\t}\n\t\t\tf();\n\t\t\tSystem.out.println(area);\n\t\t\tif(r==2)System.out.println(len);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Sheets{\n\t\n\tpublic static void main(String[] args){\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint kindOfProblem = sc.nextInt();\n\t\n\t\tSheet s = new Sheet(10001);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ts.addSheet(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t}\n\t\tsc.close();\n\t\tswitch(kindOfProblem) {\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(s.countTrue());\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(s.countTrue());\n\t\t\t\tSystem.out.println(s.calcLength());\n\t\t}\n\t}\n\t\n}\n\nclass Sheet{\n\tboolean[][] grid;\n\t\n\tSheet(int size){\n\t\tthis.grid = new boolean[size][size];\n\t\tfor(boolean[] row: grid) {\n\t\t\tArrays.fill(row, false);\n\t\t}\n\t}\n\t\n\tvoid addSheet(int x1, int y1, int x2, int y2) {\n\t\tfor(int i = y1; i < y2; i++){\n\t\t\tfor(int j = x1; j < x2; j++) {\n\t\t\t\tthis.grid[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint countTrue() {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < grid.length; i++) {\n\t\t\tfor(int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif(grid[i][j]) result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tint calcLength() {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < grid.length; i++) {\n\t\t\tfor(int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif(grid[i][j]) {\n\t\t\t\t\tif(!check(i, j-1)) result++;\n\t\t\t\t\tif(!check(i-1, j)) result++;\n\t\t\t\t\tif(!check(i+1, j)) result++;\n\t\t\t\t\tif(!check(i, j+1)) result++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tboolean check(int x, int y) {\n\t\tif(0 <= x && x < grid[0].length && 0 <= y && y < grid.length) return grid[x][y];\n\t\telse return false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter;\n\t\tint x1, y1,x2,y2;\n\t\tString[] coordinate = null;\n\t\tArrayList<String> coordinateAll = new ArrayList<String>();\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\tcoordinate = coordinateSet(x1,y1,x2,y2);\n\t\t\t\tfor(String oneCoordinate : coordinate){\n\t\t\t\t\tif(!coordinateAll.contains(oneCoordinate)){\n\t\t\t\t\t\tcoordinateAll.add(oneCoordinate);\n\t\t\t\t\t\tarea_counter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(judge ==1){\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.print(\"\\n\" + area_counter);}\n\t\t\telse{\n\t\t\t\tint cf_counter = Circumference(coordinateAll);\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.print(\"\\n\"+area_counter+\"\\n\"+ cf_counter);\n\t\t\t}\n\t\t}\n\t}\n\tprivate static int Circumference(ArrayList<String> inputSet){//周長を求める\n\t\tint x,y,result=0;\n\t\tfor(String eachInput : inputSet){\n\t\t\tScanner scan = new Scanner(eachInput);\n\t\t\tx = scan.nextInt();\n\t\t\ty = scan.nextInt();\n\t\t\tString checker1,checker2;\n\t\t\t\tfor(int i=-1;i<2;i=i+2){\n\t\t\t\t\tint new_x = x+i;\n\t\t\t\t\tint new_y = y+i;\n\t\t\t\t\tchecker1 = new_x + \" \"+y;\n\t\t\t\t\tif(!inputSet.contains(checker1)){\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t\tchecker2 = x + \" \"+ new_y;\n\t\t\t\t\tif(!inputSet.contains(checker2)){\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tprivate static String[] coordinateSet(int x1,int y1,int x2,int y2){//座標列の出力\n\t\tint count =0;\n\t\tint number = Math.abs(x2-x1)*Math.abs(y2-y1);\n\t\tString[] result = new String[number];\n\t\tfor(int i=x1;i<x2;i++){\n\t\t\tfor(int j=y1;j<y2;j++){\n\t\t\t\tresult[count]=i+\" \"+j;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new File(\"c:\\\\0509-input.txt\"));\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\t\t\tif (n == 0 && r == 0)\n\t\t\t\tbreak;\n\n\t\t\tshort[] x1 = new short[n];\n\t\t\tshort[] y1 = new short[n];\n\t\t\tshort[] x2 = new short[n];\n\t\t\tshort[] y2 = new short[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx1[i] = scan.nextShort();\n\t\t\t\ty1[i] = scan.nextShort();\n\t\t\t\tx2[i] = scan.nextShort();\n\t\t\t\ty2[i] = scan.nextShort();\n\t\t\t}\n\t\t\tRects rect = new Rects();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trect.setRect(x1[i], y1[i], x2[i], y2[i]);\n\t\t\t}\n\t\t\tSystem.out.println(rect.area());\n\t\t\tif (r == 1)\n\t\t\t\tcontinue;\n\t\t\tlong side = rect.side();\n\n\t\t\trect = null;\n\t\t\trect = new Rects();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trect.setRect(y1[i], x1[i], y2[i], x2[i]);\n\t\t\t}\n\t\t\tside += rect.side();\n\t\t\tSystem.out.println(side);\n\n\t\t\t// rect.debug();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Vbar {\n\tpublic short next = -1;\n\tpublic short y1 = -1, y2 = -1;\n\tboolean empty = true;\n}\n\nclass Rects {\n\tprivate Vbar[][] vb = new Vbar[10000][1001];\n\n\tRects() {\n\t\tfor (short x = 0; x < vb.length; x++) {\n\t\t\tvb[x][0] = new Vbar();\n\t\t\tvb[x][0].empty = false;\n\t\t\tfor (int i = 1; i < vb[x].length; i++)\n\t\t\t\tvb[x][i] = new Vbar();\n\t\t}\n\t}\n\n\tpublic long side() {\n\t\tlong result = 0;\n\t\tfor (short x = 0; x < vb.length; x++)\n\t\t\tfor (short i = vb[x][0].next; i > 0; i = vb[x][i].next)\n\t\t\t\tresult += 2;\n\t\treturn result;\n\t}\n\n\tpublic long area() {\n\t\tlong result = 0;\n\t\tfor (short x = 0; x < vb.length; x++)\n\t\t\tfor (short i = vb[x][0].next; i > 0; i = vb[x][i].next)\n\t\t\t\tresult += vb[x][i].y2 - vb[x][i].y1;\n\t\treturn result;\n\t}\n\n\tpublic void debug() {\n\t\tfor (short x = 0; x < vb.length; x++)\n\t\t\tfor (short i = vb[x][0].next; i > 0; i = vb[x][i].next) {\n\t\t\t\tSystem.out.println(x + \"-\" + vb[x][i].y1 + \"-\" + vb[x][i].y2 + \" \" + i + \" \" + vb[x][i].next);\n\t\t\t}\n\n\t}\n\n\tpublic void setRect(short x1, short y1, short x2, short y2) {\n\t\tfor (short x = x1; x < x2; x++) {\n\t\t\tshort cur, pre = 0;\n\t\t\tfor (cur = vb[x][0].next; cur != -1; pre = cur, cur = vb[x][cur].next)\n\t\t\t\tif (y1 <= vb[x][cur].y1)\n\t\t\t\t\tbreak;\n\t\t\tshort me = this.add(cur, pre, x, y1, y2);\n\t\t\tfor (short i = vb[x][me].next; i != -1; i = vb[x][i].next) {\n\t\t\t\tif (vb[x][me].y2 < vb[x][i].y1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (vb[x][me].y2 < vb[x][i].y2)\n\t\t\t\t\tvb[x][me].y2 = vb[x][i].y2;\n\t\t\t\tvb[x][me].next = vb[x][i].next;\n\t\t\t\tvb[x][i].empty = true;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate short add(short cur, short pre, short x, short y1, short y2) {\n\t\tif (vb[x][pre].y2 >= y1) {\n\t\t\tif (vb[x][pre].y2 < y2)\n\t\t\t\tvb[x][pre].y2 = y2;\n\t\t\treturn pre;\n\t\t}\n\t\tfor (short i = 1; i < vb[x].length; i++)\n\t\t\tif (vb[x][i].empty == true) {\n\t\t\t\tvb[x][i].empty = false;\n\t\t\t\tvb[x][i].y1 = y1;\n\t\t\t\tvb[x][i].y2 = y2;\n\t\t\t\tvb[x][i].next = cur;\n\t\t\t\tvb[x][pre].next = i;\n\t\t\t\treturn i;\n\t\t\t}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<LinkedList<Integer>> coordinateAll = new ArrayList<LinkedList<Integer>>();\n\t\twhile(true){\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\t//buf=null;\n\t\t\t\tcoordinateAll.add(new LinkedList<Integer>());\n\t\t\t}\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tLinkedList<Integer> temp = new LinkedList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tLinkedList<Integer> new_temp =new LinkedList<Integer>();\n\t\t\t\t\t\tnew_temp = (LinkedList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t\t//new_temp=null;\n\t\t\t\t\t}\n\t\t\t\t\t//temp=null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\t\t\tLinkedList<Integer> check0;\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tcheck0 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer> check1 = coordinateAll.get(i);\n\t\t\t\t\tLinkedList<Integer> check2;\n\t\t\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\t\t\tcheck2 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer>mergeCheck = new LinkedList<Integer>();\n\t\t\t\t\t//= coordinateAll.get(i+1);\n\t\t\t\t\tif(check1!=null){\n\t\t\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\t\t\tif(check2==null){\n\t\t\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\t\t\tif(check0!=null){\n\t\t\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck=null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> content : coordinateAll){\n\t\t\t\tcontent=null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<LinkedList<Integer>> coordinateAll = new ArrayList<LinkedList<Integer>>();\n\t\twhile(true){\n\t\t\t//LinkedList<Integer> buf = new LinkedList<Integer>();\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\t//buf=null;\n\t\t\t\tcoordinateAll.add(null);\n\t\t\t}\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tLinkedList<Integer> temp = new LinkedList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tLinkedList<Integer> new_temp =new LinkedList<Integer>();\n\t\t\t\t\t\tnew_temp = (LinkedList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\t//int cf_counter = Circumference(coordinateAll);\n\t\t\t\tcircumference = curCal(coordinateAll);\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t}\n\t}\n//周長を求める\n\tprivate static int curCal(ArrayList<LinkedList<Integer>> coordinateAll){\n\t\tint circumference = 0;\n\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\tLinkedList<Integer> check0;\n\t\t\tif(i==0){\n\t\t\t\tcheck0 =null;\n\t\t\t}else{\n\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t}\n\t\t\tLinkedList<Integer> check1 = coordinateAll.get(i);\n\t\t\tLinkedList<Integer> check2 = null;\n\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\tcheck2 =null;\n\t\t\t}else{\n\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t}\n\t\t\tLinkedList<Integer>mergeCheck = new LinkedList<Integer>();\n\t\t\t//= coordinateAll.get(i+1);\n\t\t\tif(check1!=null){\n\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\tif(check2==null){\n\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\tif(check0!=null){\n\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t}\n\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn circumference;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint kindOfProblem = sc.nextInt();\n\t\t\tif(n == 0 && kindOfProblem == 0) break;\n\t\t\tSheet s = new Sheet(10001);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ts.addSheet(sc.nextInt(), sc.nextInt(), sc.nextInt(),\n\t\t\t\t\t\tsc.nextInt());\n\t\t\t}\n\t\t\tswitch(kindOfProblem){\n\t\t\t\tcase 1:\n\t\t\t\t\tSystem.out.println(s.countTrue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tSystem.out.println(s.countTrue());\n\t\t\t\t\tSystem.out.println(s.calcLength());\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\t\n}\n\nclass Sheet{\n\tboolean[][] grid;\n\t\n\tSheet(int size){\n\t\tthis.grid = new boolean[size][size];\n\t\tfor(boolean[] row: grid) {\n\t\t\tArrays.fill(row, false);\n\t\t}\n\t}\n\t\n\tvoid addSheet(int x1, int y1, int x2, int y2) {\n\t\tfor(int i = y1; i < y2; i++){\n\t\t\tfor(int j = x1; j < x2; j++) {\n\t\t\t\tthis.grid[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint countTrue() {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < grid.length; i++) {\n\t\t\tfor(int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif(grid[i][j]) result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tint calcLength() {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < grid.length; i++) {\n\t\t\tfor(int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif(grid[i][j]) {\n\t\t\t\t\tif(!check(i, j-1)) result++;\n\t\t\t\t\tif(!check(i-1, j)) result++;\n\t\t\t\t\tif(!check(i+1, j)) result++;\n\t\t\t\t\tif(!check(i, j+1)) result++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tboolean check(int x, int y) {\n\t\tif(0 <= x && x < grid[0].length && 0 <= y && y < grid.length) return grid[x][y];\n\t\telse return false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.text.DecimalFormat;\nimport java.util.*;\n\npublic class Main {\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<ArrayList<Integer>> coordinateAll = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<Integer>mergeCheck = new ArrayList<Integer>();\n\t\tArrayList<Integer> temp = new ArrayList<Integer>();\n\t\twhile(true){\n\t\t\tcoordinateAll.clear();\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\t//buf=null;\n\t\t\t\tcoordinateAll.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tArrayList<Integer> new_temp =new ArrayList<Integer>();\n\t\t\t\t\t\tnew_temp = (ArrayList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t\t//new_temp=null;\n\t\t\t\t\t}\n\t\t\t\t\t//temp=null;\n\t\t\t\t\ttemp.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(ArrayList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\t\t\tArrayList<Integer> check0;\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tcheck0 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t\t\t}\n\t\t\t\t\tArrayList<Integer> check1 = coordinateAll.get(i);\n\t\t\t\t\tArrayList<Integer> check2;\n\t\t\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\t\t\tcheck2 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//= coordinateAll.get(i+1);\n\t\t\t\t\tif(check1!=null){\n\t\t\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\t\t\tif(check2==null){\n\t\t\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\t\t\tif(check0!=null){\n\t\t\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//circumference = curCal(coordinateAll);\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString line = reader.readLine();\n\t\t\tString[] str1 = line.split(\" \", -1);\n\t\t\tint n = Integer.parseInt(str1[0]);\n\t\t\tint r = Integer.parseInt(str1[1]);\n\t\t\tif(n == 0 && r == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint area = 0;\n\t\t\tint length = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString lines = reader.readLine();\n\t\t\t\tString[] str = lines.split(\" \", -1);\n\t\t\t\tint x1 = Integer.parseInt(str[0]);\n\t\t\t\tint y1 = Integer.parseInt(str[1]);\n\t\t\t\tint x2 = Integer.parseInt(str[2]);\n\t\t\t\tint y2 = Integer.parseInt(str[3]);\n\t\t\t\tarea += (x2 - x1) * (y2 - y1);\n\t\t\t\tif(r == 2){\n\t\t\t\t\tlength += ((x2 - x1) + (y2 - y1)) * 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif(r == 2){\n\t\t\t\tSystem.out.println(length);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\n\n// Volume5-0509 Sheets Main5_0509\npublic class Main {\n\n    class Rect {\n        int x0;\n        int y0;\n        int x1;\n        int y1;\n    }\n\n    class Range {\n        Range(int x, int f) {\n            this.x = x;\n            this.f = f;\n        }\n        int x;\n        int f;   // f = 1:start f = -1:end\n    }\n\n\t// メイン return falseでおしまい\n\tboolean main() throws IOException {\n\n\t\tint[] ir = readIntArray();\n\t\tint n = ir[0];\n\t\tint r = ir[1]; // 1面積 2 面積:周長\n\t\tif (n == 0)\n\t\t    return false;\n\n\t\tRect[] rects = new Rect[n];\n        Rect[] rects2 = new Rect[n];\n\t\tSet<Integer> ySet = new TreeSet<Integer>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tir = readIntArray();\n\t\t\trects[i] = new Rect();\n\t\t\trects[i].x0 = ir[0];\n            rects[i].y0 = ir[1];\n            rects[i].x1 = ir[2];\n            rects[i].y1 = ir[3];\n\n            rects2[i] = new Rect();\n            rects2[i].y0 = ir[0];\n            rects2[i].x0 = ir[1];\n            rects2[i].y1 = ir[2];\n            rects2[i].x1 = ir[3];\n\t\t}\n\n        int slen = 0; // 周長\n        int s = 0; // 面積\n\n///\n        {\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n\t\t}\n\t\tInteger[] ya = ySet.toArray(new Integer[0]);\n\t\tArrays.sort(ya);\n\t\tfor(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n\t\t    List<Range> rangeList = new ArrayList<Range>();\n\n\t\t    for(int k = 0; k < n; k++) {\n\t\t        if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n    \t\t        Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n\t\t        }\n\t\t    }\n\t\t    Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n\t\t    int c = 0;\n\t\t    int cx = 0;\n\t\t    for(Range ra : rangeList) {\n\t\t        if (ra.f > 0) {\n\t\t            c++;\n\t\t            if (c == 1) {\n\t\t                cx = ra.x;\n\t\t                slen += h;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            c--;\n\t\t            if (c == 0) {\n\t\t                log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n\t\t                s += (ra.x - cx) * h;\n                        slen += h;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n        }\n\n        \n        /// xy逆にしてもう一度\n\t\trects = rects2;\n\n\t\t{\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n        }\n        Integer[] ya = ySet.toArray(new Integer[0]);\n        Arrays.sort(ya);\n        for(int i = 0; i < ya.length - 1; i++) {\n            log.printf(\"y=%d\\n\", ya[i]);\n            int h = ya[i + 1] - ya[i];\n            List<Range> rangeList = new ArrayList<Range>();\n\n            for(int k = 0; k < n; k++) {\n                if (rects[k].y0 <= ya[i] && ya[i] < rects[k].y1) {\n                    Range ra0 = new Range(rects[k].x0, 1);\n                    Range ra1 = new Range(rects[k].x1, -1);\n                    rangeList.add(ra0);\n                    rangeList.add(ra1);\n                    log.printf(\"add %d %d\\n\", ra0.x, ra1.x);\n                }\n            }\n            Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n            int c = 0;\n            int cx = 0;\n            for(Range ra : rangeList) {\n                if (ra.f > 0) {\n                    c++;\n                    if (c == 1) {\n                        cx = ra.x;\n                        slen += h;\n                    }\n                }\n                else {\n                    c--;\n                    if (c == 0) {\n                        log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n                        s += (ra.x - cx) * h;\n                        slen += h;\n                    }\n                }\n            }\n        }\n\t\t}\n\n\t\tSystem.out.printf(\"%d\\n\", s/2);\n        if (r == 2) System.out.printf(\"%d\\n\", slen);\n\n\n\t\treturn true; // 正常終了 次へ\n\t}\n\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\n\t\t\t//String inputStr = \"5 1:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"5 2:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"2 2:0 0 8 9: 0 0 9 8:\";\n            String inputStr = \"3 2:2 2 8 8:3 0 4 9:5 0 7 9:\";\n\t\t\tinputStr += \"0 0:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr));\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // 書き捨て\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // コンソールから\n\t\t}\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treader.close();\n\t}\n\n\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // ※※※　どうも突然空行を読むことがある。読み飛ばすとうまくいくらしい。。。。\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<LinkedList<Integer>> coordinateAll = new ArrayList<LinkedList<Integer>>();\n\t\tfor(int i=0;i<10000;i++){\n\t\t\t//buf=null;\n\t\t\tcoordinateAll.add(null);\n\t\t}\n\t\twhile(true){\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tLinkedList<Integer> temp = new LinkedList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tLinkedList<Integer> new_temp =new LinkedList<Integer>();\n\t\t\t\t\t\tnew_temp = (LinkedList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\t\t\tLinkedList<Integer> check0;\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tcheck0 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer> check1 = coordinateAll.get(i);\n\t\t\t\t\tLinkedList<Integer> check2;\n\t\t\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\t\t\tcheck2 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer>mergeCheck = new LinkedList<Integer>();\n\t\t\t\t\t//= coordinateAll.get(i+1);\n\t\t\t\t\tif(check1!=null){\n\t\t\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\t\t\tif(check2==null){\n\t\t\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\t\t\tif(check0!=null){\n\t\t\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck=null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> content : coordinateAll){\n\t\t\t\tcontent=null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint kindOfProblem = sc.nextInt();\n\t\t\tif(n == 0 && kindOfProblem == 0) break;\n\t\t\tint[][] in = new int[n][4];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tin[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSheet s = new Sheet(max(in)+1);\n\t\t\tfor(int[] row: in) {\n\t\t\t\ts.addSheet(row[0], row[1], row[2], row[3]);\n\t\t\t}\n\t\t\tswitch(kindOfProblem){\n\t\t\t\tcase 1:\n\t\t\t\t\tSystem.out.println(s.countTrue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tSystem.out.println(s.countTrue());\n\t\t\t\t\tSystem.out.println(s.calcLength());\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tstatic int max(int[][] array) {\n\t\tint result = 0;\n\t\tfor(int[] row: array) {\n\t\t\tfor(int i : row) if(i > result) result = i;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nclass Sheet{\n\tboolean[][] grid;\n\t\n\tSheet(int size){\n\t\tthis.grid = new boolean[size][size];\n\t\tfor(boolean[] row: grid) {\n\t\t\tArrays.fill(row, false);\n\t\t}\n\t}\n\t\n\tvoid addSheet(int x1, int y1, int x2, int y2) {\n\t\tfor(int i = y1; i < y2; i++){\n\t\t\tfor(int j = x1; j < x2; j++) {\n\t\t\t\tthis.grid[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint countTrue() {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < grid.length; i++) {\n\t\t\tfor(int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif(grid[i][j]) result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tint calcLength() {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < grid.length; i++) {\n\t\t\tfor(int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif(grid[i][j]) {\n\t\t\t\t\tif(!check(i, j-1)) result++;\n\t\t\t\t\tif(!check(i-1, j)) result++;\n\t\t\t\t\tif(!check(i+1, j)) result++;\n\t\t\t\t\tif(!check(i, j+1)) result++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tboolean check(int x, int y) {\n\t\tif(0 <= x && x < grid[0].length && 0 <= y && y < grid.length) return grid[x][y];\n\t\telse return false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\t//@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\tArrayList<LinkedList<Integer>> coordinateAll = new ArrayList<LinkedList<Integer>>();\n\t\tfor(int i=0;i<10000;i++){\n\t\t\t//buf=null;\n\t\t\tcoordinateAll.add(null);\n\t\t}\n\t\twhile(true){\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tLinkedList<Integer> temp = new LinkedList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tLinkedList<Integer> new_temp =new LinkedList<Integer>();\n\t\t\t\t\t\tnew_temp = (LinkedList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\t//coordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\t\t\tLinkedList<Integer> check0;\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tcheck0 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer> check1 = coordinateAll.get(i);\n\t\t\t\t\tLinkedList<Integer> check2;\n\t\t\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\t\t\tcheck2 =null;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<Integer>mergeCheck = new LinkedList<Integer>();\n\t\t\t\t\t//= coordinateAll.get(i+1);\n\t\t\t\t\tif(check1!=null){\n\t\t\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\t\t\tif(check2==null){\n\t\t\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\t\t\tif(check0!=null){\n\t\t\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeCheck=null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> content : coordinateAll){\n\t\t\t\tcontent=null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\n\n// Volume5-0509 Sheets Main5_0509\npublic class Main {\n\n    class Rect {\n        int x0;\n        int y0;\n        int x1;\n        int y1;\n    }\n\n    class Range {\n        Range(int x, int f) {\n            this.x = x;\n            this.f = f;\n        }\n        int x;\n        int f;   // f = 1:start f = -1:end\n    }\n\n\t// メイン return falseでおしまい\n\tboolean main() throws IOException {\n\n\t\tint[] ir = readIntArray();\n\t\tint n = ir[0];\n\t\tint r = ir[1]; // 1面積 2 面積:周長\n\t\tif (n == 0)\n\t\t    return false;\n\n        log.printf(\"n = %d r = %d\\n\", n, r);\n\t\tRect[] rects = new Rect[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tir = readIntArray();\n\t\t\trects[i] = new Rect();\n\t\t\trects[i].x0 = ir[0];\n            rects[i].y0 = ir[1];\n            rects[i].x1 = ir[2];\n            rects[i].y1 = ir[3];\n\t\t}\n\n        int slen = 0; // 周長\n        int s = 0; // 面積\n\n        for(int xy = 0; xy < 2; xy++) {\n            log.printf(\"xy = %d\\n\",  xy);\n            /// xy逆にしてもう一度\n            if (xy != 0) {\n                for(int i = 0; i < n; i++) {\n                    int t;\n                    t = rects[i].x0;\n                    rects[i].x0 = rects[i].y0;\n                    rects[i].y0 = t;\n                    t = rects[i].x1;\n                    rects[i].x1 = rects[i].y1;\n                    rects[i].y1 = t;\n                }\n            }\n\n          Set<Integer> ySet = new TreeSet<Integer>();\n        for(int i = 0; i < n; i++) {\n            ySet.add(rects[i].y0);\n            ySet.add(rects[i].y1);\n\t\t}\n\t\tInteger[] ya = ySet.toArray(new Integer[0]);\n        //System.out.printf(\"ya.length = %d sort\\n\", ya.length);\n\t\tArrays.sort(ya);\n        //System.out.printf(\"ya.length = %d sort end\\n\", ya.length);\n        \n        List<Range> rangeList = new ArrayList<Range>();\n        \n\t\tfor(int i = 0; i < ya.length - 1; i++) {\n            //log.printf(\"y=%d\\n\", ya[i]);\n            int height = ya[i + 1] - ya[i];\n\n\t\t    for(int k = 0; k < n; k++) {\n\t\t        if (rects[k].y0 == ya[i]) { // 上端\n\t\t            rangeList.add(new Range(rects[k].x0, 1));\n\t\t            rangeList.add(new Range(rects[k].x1, -1));\n\t\t        }\n\t\t        else if (rects[k].y1 == ya[i]) { // 下端\n\t\t            for(int j = 0;; j++) {\n\t\t                if (rangeList.get(j).x == rects[k].x0 && rangeList.get(j).f == 1) {\n\t\t                    rangeList.remove(j);\n\t\t                    break;\n\t\t                }\n\t\t            }\n                    for(int j = 0;; j++) {\n                        if (rangeList.get(j).x == rects[k].x1 && rangeList.get(j).f == -1) {\n                            rangeList.remove(j);\n                            break;\n                        }\n                    }\n\t\t        }\n\t\t    }\n\t\t    Collections.sort(rangeList, new Comparator<Range>() {\n                @Override\n                public int compare(Range o1, Range o2) {\n                    if (o1.x == o2.x) {\n                        return o2.f - o1.f;\n                    }\n                    return o1.x - o2.x;\n                }});\n\t\t    int c = 0;\n\t\t    int cx = 0;\n\t\t    for(Range ra : rangeList) {\n\t\t        if (ra.f > 0) {\n\t\t            c++;\n\t\t            if (c == 1) {\n\t\t                cx = ra.x;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            c--;\n\t\t            if (c == 0) {\n\t\t                //log.printf(\"面積=%d\\n\", (ra.x - cx) * h);\n\t\t                s += (ra.x - cx) * height;\n                        slen += height * 2;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n        }\n\n\t\tSystem.out.printf(\"%d\\n\", s/2);\n        if (r == 2) System.out.printf(\"%d\\n\", slen);\n\n\n\t\treturn true; // 正常終了 次へ\n\t}\n\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\n\t\t\t//String inputStr = \"5 1:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            String inputStr = \"5 2:0 0 3 2:1 1 2 5:0 4 6 5:3 3 5 6:5 0 7 6:\";\n            //String inputStr = \"2 2:0 0 8 9: 0 0 9 8:\";\n            //String inputStr = \"3 2:2 2 8 8:3 0 4 9:5 0 7 9:\";\n\t\t\tinputStr += \"0 0:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr));\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // 書き捨て\n//            log = System.out;\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // コンソールから\n//            reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"5_0509in.txt\")));\n\t\t}\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treader.close();\n\t}\n\n\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // ※※※　どうも突然空行を読むことがある。読み飛ばすとうまくいくらしい。。。。\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Plane {\n  public Plane() {\n    plane = new ArrayList<Strip>();\n    for(int i = 0; i < MAX; i++) plane.add(new Strip());\n  }\n\n  public void cover(int x1, int y1, int x2, int y2) {\n    for(int i = x1; i < x2; i++) {\n      plane.get(i).cover(y1, y2);\n    }\n  }\n\n  public int area() {\n    int area = 0;\n    for(Strip s : plane) area += s.area();\n    return area;\n  }\n\n  public int girth() {\n    Strip border = new Strip();\n    Strip prev = border;\n\n    int girth = 0;\n\n    for(Strip s : plane) {\n      girth += s.girth(prev);\n      prev = s;\n    }\n\n    girth += border.girth(prev);\n\n    return girth;\n  }\n\n  private List<Strip> plane;\n  private static final int MAX = 10000;\n}\n\nclass Strip {\n  public void cover(int x, int y) {\n    ListIterator<Range> iter = ranges.listIterator(0);\n    while(iter.hasNext()) {\n      Range r = iter.next();\n\n      int a = r.getStart();\n      int b = r.getEnd();\n\n      if(a <= x && y <= b) return;\n      else if(x <= a && b <= y) iter.remove();\n      else if(a <= x && x <= b) {\n        iter.remove();\n        x = a;\n      }\n      else if(x <= a && a <= y) {\n        iter.remove();\n        y = b;\n      }\n      else if(y < a) {\n        iter.previous();\n        iter.add(new Range(x, y));\n        return;\n      }\n    }\n\n    ranges.add(new Range(x, y));\n  }\n\n  public int area() {\n    int area = 0;\n    for(Range r : ranges) area += r.length();\n    return area;\n  }\n\n  public int girth(Strip left) {\n    int girth = 0;\n\n    for(Range r : ranges) girth += 2;\n\n    int cur = 0;\n\n    while(true) {\n      Range l = left.getNearestRange(cur);\n      Range r = this.getNearestRange(cur);\n\n      if(l == null && r == null) break;\n      else if(l == null) {\n        if(cur < r.getStart()) cur = r.getStart();\n        girth += r.getEnd() - cur;\n        cur = r.getEnd();\n      }\n      else if(r == null) {\n        if(cur < l.getStart()) cur = l.getStart();\n        girth += l.getEnd() - cur;\n        cur = l.getEnd();\n      }\n      else {\n        int ls = l.getStart();\n        int rs = r.getStart();\n        int le = l.getEnd();\n        int re = r.getEnd();\n\n        if(ls <= rs) {\n          cur = Math.max(ls, cur);\n\n          if(le <= rs) {\n            girth += le - cur;\n            cur = le;\n          }\n          else {\n            girth += rs - cur;\n            cur = Math.min(le, re);\n          }\n        }\n        else if(rs <= ls) {\n          cur = Math.max(rs, cur);\n\n          if(re <= ls) {\n            girth += re - cur;\n            cur = re;\n          }\n          else {\n            girth += ls - cur;\n            cur = Math.min(le, re);\n          }\n        }\n      }\n    }\n\n    return girth;\n  }\n\n  private Range getNearestRange(int pos) {\n    for(Range r : ranges) {\n      if(r.getEnd() > pos) return r;\n    }\n\n    return null;\n  }\n\n  private List<Range> ranges = new LinkedList<Range>();\n}\n\nclass Range {\n  public Range(int a, int b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  public int length() {\n    return b - a;\n  }\n\n  public int getStart() {\n    return a;\n  }\n\n  public int getEnd() {\n    return b;\n  }\n\n  private int a;\n  private int b;\n}\n\npublic class Main {\n  private Scanner sc = new Scanner(System.in);\n\n  public void run() {\n    while(sc.hasNextInt()) {\n      int n = sc.nextInt();\n      int r = sc.nextInt();\n\n      if(n == 0 && r == 0) break;\n\n      Plane plane = new Plane();\n      for(int i = 0; i < n; i++) {\n        plane.cover(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n      }\n\n      System.out.println(plane.area());\n\n      if(r == 2) System.out.println(plane.girth());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n\tint MAX = 10005;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), r = sc.nextInt();\n\t\t\tif ((n|r) == 0) break;\n\t\t\tE[] G = new E[MAX];\n\t\t\tfor (int i = 0; i < MAX;i++) G[i] = new E();\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tint x1 = sc.nextInt()+1, y1 = sc.nextInt()+1, x2 = sc.nextInt()+1, y2 = sc.nextInt()+1;\n\t\t\t\tG[y1].add(new P(x1, x2, true));\n\t\t\t\tG[y2].add(new P(x1, x2, false));\n\t\t\t}\n\t\t\tint a = 0, l = 0, t = 1, minx = MAX, maxx = 0;\n\t\t\tint[][] area = new int[2][MAX];\n\t\t\tfor (E e: G) {\n\t\t\t\tfill(area[t], 0);\n\t\t\t\tfor (P p: e) {\n\t\t\t\t\tarea[t][p.x1] += p.c ? 1: -1; area[t][p.x2] += p.c ? -1 : 1;\n\t\t\t\t\tminx = min(minx, p.x1); maxx = max(maxx, p.x2);\n\t\t\t\t}\n\t\t\t\tfor (int i = minx; i <= maxx; i++) {\n\t\t\t\t\tarea[t][i] += area[t][i-1] + area[1-t][i] - area[1-t][i-1];\n\t\t\t\t\tif (area[t][i] > 0) a++;\n\t\t\t\t\tif (((area[t][i] | area[1-t][i]) != 0 ) && area[t][i] * area[1-t][i] == 0) l++;\n\t\t\t\t\tif (((area[t][i] | area[t][i-1]) != 0 ) && area[t][i] * area[t][i-1] == 0) l++;\n\t\t\t\t}\n//\t\t\t\tdebug(area[t]);\n\t\t\t\tt ^= 1;\n\t\t\t}\n\t\t\tSystem.out.println(a);\n\t\t\tif (r == 2) System.out.println(l);\n\t\t}\n\t}\n\t\n\tclass E extends ArrayList<P>{};\n\t\n\tclass P {\n\t\tint x1, x2; boolean c;\n\t\tP(int x1, int x2, boolean c) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.out.println(deepToString(os));\n\t}\n\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static short[][] sp = new short[10002][10002];\n\tprivate static int xmax = 0, ymax = 0, xmin = 10002, ymin = 10002;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tfor (int x = 0; x < 10002; x++)\n\t\t\tfor (int y = 0; y < 10002; y++)\n\t\t\t\tsp[x][y] = 1;\n\n//\t\tScanner scan = new Scanner(System.in);\n\t\t Scanner scan = new Scanner(new File(\"c:\\\\0509-input.txt\"));\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\t\t\tif (n == 0 && r == 0)\n\t\t\t\tbreak;\n\t\t\tint area = 0;\n\t\t\tfor (int x = xmin + 1; x <= xmax; x++)\n\t\t\t\tfor (int y = ymin + 1; y <= ymax; y++)\n\t\t\t\t\tsp[x][y] = 1;\n\t\t\txmax = 0;\n\t\t\tymax = 0;\n\t\t\txmin = 10002;\n\t\t\tymin = 10002;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x1 = scan.nextInt();\n\t\t\t\tint y1 = scan.nextInt();\n\t\t\t\tint x2 = scan.nextInt();\n\t\t\t\tint y2 = scan.nextInt();\n\t\t\t\tarea += setRect(x1, y1, x2, y2);\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif (r == 2)\n\t\t\t\tSystem.out.println(side());\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static int side() {\n\t\tint sideLen = 0;\n\t\tfor (int x = xmin + 1; x <= xmax; x++)\n\t\t\tfor (int y = ymin + 1; y <= ymax; y++)\n\t\t\t\tif (sp[x][y] == 0)\n\t\t\t\t\tsideLen += (sp[x - 1][y] + sp[x][y - 1] + sp[x + 1][y] + sp[x][y + 1]);\n\t\treturn sideLen;\n\t}\n\n\tprivate static int setRect(int x1, int y1, int x2, int y2) {\n\t\tint area = 0;\n\t\tfor (int x = x1 + 1; x <= x2; x++)\n\t\t\tfor (int y = y1 + 1; y <= y2; y++)\n\t\t\t\tif (sp[x][y] == 1) {\n\t\t\t\t\tarea++;\n\t\t\t\t\tsp[x][y] = 0;\n\t\t\t\t}\n\t\tif (xmin > x1)\n\t\t\txmin = x1;\n\t\tif (ymin > y1)\n\t\t\tymin = y1;\n\t\tif (xmax < x2)\n\t\t\txmax = x2;\n\t\tif (ymax < y2)\n\t\t\tymax = y2;\n\t\treturn area;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter,circumference;\n\t\tint x1, y1,x2,y2;\n\t\t//String[] coordinate = new String[10000];\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tArrayList<LinkedList<Integer>> coordinateAll = new ArrayList<LinkedList<Integer>>();\n\t\t\tLinkedList<Integer> buf = new LinkedList<Integer>();\n\t\t\tfor(int i=0;i<10000;i++){\n\t\t\t\tbuf=null;\n\t\t\t\tcoordinateAll.add(buf);\n\t\t\t}\n\t\t\tcircumference=0;\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\t//int y1_index;\n\t\t\t\tfor(int r=x1;r<x2;r++){\n\t\t\t\t\tLinkedList<Integer> temp = new LinkedList<Integer>();\n\t\t\t\t\tif(coordinateAll.get(r)==null){\n\t\t\t\t\t\ttemp.add(y1);\n\t\t\t\t\t\ttemp.add(y2);\n\t\t\t\t\t\tcoordinateAll.set(r, temp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp = coordinateAll.get(r);\n\t\t\t\t\t\t//System.out.print(\"\\n 0 tempは\"+temp);\n\t\t\t\t\t\tLinkedList<Integer> new_temp =new LinkedList<Integer>();\n\t\t\t\t\t\tnew_temp = (LinkedList<Integer>) temp.clone();\n\t\t\t\t\t\tint endJudge =0;\n\t\t\t\t\t\tfor(int j=0;j<=temp.size();j++){\n\t\t\t\t\t\t\tif(endJudge==1){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == temp.size()){\n\t\t\t\t\t\t\t\tnew_temp.add(y1);\n\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(y1<temp.get(j)){\n\t\t\t\t\t\t\t\tif(j%2==0){\n\t\t\t\t\t\t\t\t\tnew_temp.add(j, y1);\n\t\t\t\t\t\t\t\t\ttemp.add(j,y1);\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j;k<=temp.size();k++){\n\n\t\t\t\t\t\t\t\t\t//new_k++;\n\t\t\t\t\t\t\t\t\tif(k==temp.size()){\n\t\t\t\t\t\t\t\t\t\tnew_temp.add(y2);\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else if(y2<temp.get(k)){\n\t\t\t\t\t\t\t\t\t\tif(new_temp.size()%2==1){\n\t\t\t\t\t\t\t\t\t\t\tnew_temp.add(j,y2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tendJudge++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}else{//y2>=temp.get(k)\n\t\t\t\t\t\t\t\t\t\tnew_temp.remove(j);//\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//coordinateAll.remove(r);\n\t\t\t\t\t\tcoordinateAll.set(r,new_temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(LinkedList<Integer> check : coordinateAll){\n\t\t\t\tif(check!=null){\n\t\t\t\t\tfor(int p=0;p<check.size();p=p+2){\n\t\t\t\t\t\tarea_counter +=check.get(p+1)-check.get(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(judge ==1){\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);\n\t\t\t}else{\n\t\t\t\t//int cf_counter = Circumference(coordinateAll);\n\t\t\t\tcircumference = curCal(coordinateAll);\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+circumference);\n\t\t\t}\n\t\t}\n\t}\n//周長を求める\n\tprivate static int curCal(ArrayList<LinkedList<Integer>> coordinateAll){\n\t\tint circumference = 0;\n\t\tfor(int i=0;i<coordinateAll.size();i++){\n\t\t\tLinkedList<Integer> check0;\n\t\t\tif(i==0){\n\t\t\t\tcheck0 =null;\n\t\t\t}else{\n\t\t\t\tcheck0 = coordinateAll.get(i-1);\n\t\t\t}\n\t\t\tLinkedList<Integer> check1 = coordinateAll.get(i);\n\t\t\tLinkedList<Integer> check2 = null;\n\t\t\tif(i==coordinateAll.size()-1){\n\t\t\t\tcheck2 =null;\n\t\t\t}else{\n\t\t\t\tcheck2 = coordinateAll.get(i+1);\n\t\t\t}\n\t\t\tLinkedList<Integer>mergeCheck = new LinkedList<Integer>();\n\t\t\t//= coordinateAll.get(i+1);\n\t\t\tif(check1!=null){\n\t\t\t\tcircumference +=check1.size();//上と下\n\t\t\t\tif(check2==null){\n\t\t\t\t\tfor(int c=0;c<check1.size();c=c+2){\t\n\t\t\t\t\t\tcircumference +=check1.get(c+1)-check1.get(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmergeCheck.addAll(check1);\n\t\t\t\tif(check0!=null){\n\t\t\t\t\tmergeCheck.addAll(check0);\n\t\t\t\t}\n\t\t\t\tCollections.sort(mergeCheck);\n\t\t\t\tfor(int c=0;c<mergeCheck.size();c=c+2){\n\t\t\t\t\tcircumference +=mergeCheck.get(c+1)-mergeCheck.get(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn circumference;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tint[][] matrix;\n\t\tdo {\n\t\t\tint numOfSheet = in.nextInt();\n\t\t\tint probNum = in.nextInt();\n\t\t\tif(numOfSheet == 0 && probNum == 0) break;\n\t\t\t\n\t\t\tint maxX = 0, maxY = 0;\n\t\t\tint[][] data = new int[numOfSheet][4];\n\t\t\tfor(int i=0; i<numOfSheet; i++) {\n\t\t\t\tdata[i][0] = in.nextInt();//x1\n\t\t\t\tdata[i][1] = in.nextInt();//y1\n\t\t\t\tdata[i][2] = in.nextInt();//x2\n\t\t\t\tdata[i][3] = in.nextInt();//y2\n\t\t\t\t\n\t\t\t\tif(data[i][0]>maxX) maxX=data[i][0];\n\t\t\t\tif(data[i][2]>maxX) maxX=data[i][2];\n\t\t\t\tif(data[i][1]>maxY) maxY=data[i][1];\n\t\t\t\tif(data[i][3]>maxY) maxY=data[i][3];\n\t\t\t}\n\t\t\t\n\t\t\tmatrix = new int[maxX+1][maxY+1];\n\t\t\t\n\t\t\tfor(int i=0; i<data.length; i++) {\n\t\t\t\tfor(int j=data[i][0]; j<data[i][2]; j++) {\n\t\t\t\t\tfor(int k=data[i][1]; k<data[i][3]; k++) {\n\t\t\t\t\t\tmatrix[k][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(probNum==1 || probNum==2) {\n\t\t\t\tint area = 0;\n\t\t\t\tfor(int i=0; i<matrix.length; i++) {\n\t\t\t\t\tfor(int j=0; j<matrix[i].length; j++) {\n\t\t\t\t\t\tarea+= matrix[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(area);\n\t\t\t}\n\t\t\tif(probNum==2) {\n\t\t\t\tint length = 0;\n\t\t\t\tfor(int i=0; i<matrix.length; i++) {\n\t\t\t\t\tfor(int j=0; j<matrix[i].length; j++) {\n\t\t\t\t\t\tif(matrix[i][j] == 1) length += getLength(i, j, matrix);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(length);\n\t\t\t}\n\t\t} while(true);\n\t}\n\t\n\tpublic static int getLength(int x, int y, int[][] matrix) {\n\t\tint ret = 0;\n\t\tint n = 0;\n\t\tif(x==0&&y==0) n = matrix[x][y+1] + matrix[x+1][y];\n\t\telse if(x==0&&y==matrix[0].length-1) n = matrix[x][y-1] + matrix[x+1][y];\n\t\telse if(x==matrix.length-1&&y==0) n = matrix[x-1][y] + matrix[x][y+1];\n\t\telse if(x==matrix.length-1&&y==matrix[x].length-1) n = matrix[x][y-1] + matrix[x-1][y];\n\t\telse if(x==0) n = matrix[x][y+1] + matrix[x][y-1] + matrix[x+1][y];\n\t\telse if(x==matrix.length-1) n = matrix[x][y+1] + matrix[x][y-1] + matrix[x-1][y];\n\t\telse if(y==0) n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y+1];\n\t\telse if(y==matrix[x].length-1) n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y-1];\n\t\telse n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y-1] + matrix[x][y+1];\n\t\t\n\t\tswitch(n){\n\t\tcase 1:\n\t\t\tret = 3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Sheet {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tint numOfSheet = in.nextInt();\n\t\tint probNum = in.nextInt();\n\t\tint[][] matrix;\n\t\twhile(!(numOfSheet==0 && probNum==0)) {\n\t\t\tint maxX = 0, maxY = 0;\n\t\t\tint[][] data = new int[numOfSheet][4];\n\t\t\tfor(int i=0; i<numOfSheet; i++) {\n\t\t\t\tdata[i][0] = in.nextInt();//x1\n\t\t\t\tdata[i][1] = in.nextInt();//y1\n\t\t\t\tdata[i][2] = in.nextInt();//x2\n\t\t\t\tdata[i][3] = in.nextInt();//y2\n\t\t\t\t\n\t\t\t\tif(data[i][0]>maxX) maxX=data[i][0];\n\t\t\t\tif(data[i][2]>maxX) maxX=data[i][2];\n\t\t\t\tif(data[i][1]>maxY) maxY=data[i][1];\n\t\t\t\tif(data[i][3]>maxY) maxY=data[i][3];\n\t\t\t}\n\t\t\t\n\t\t\tmatrix = new int[maxX+1][maxY+1];\n\t\t\t\n\t\t\tfor(int i=0; i<data.length; i++) {\n\t\t\t\tfor(int j=data[i][0]; j<data[i][2]; j++) {\n\t\t\t\t\tfor(int k=data[i][1]; k<data[i][3]; k++) {\n\t\t\t\t\t\tmatrix[k][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(probNum==1 || probNum==2) {\n\t\t\t\tint area = 0;\n\t\t\t\tfor(int i=0; i<matrix.length; i++) {\n\t\t\t\t\tfor(int j=0; j<matrix[i].length; j++) {\n\t\t\t\t\t\tarea+= matrix[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(area);\n\t\t\t}\n\t\t\tif(probNum==2) {\n\t\t\t\tint length = 0;\n\t\t\t\tfor(int i=0; i<matrix.length; i++) {\n\t\t\t\t\tfor(int j=0; j<matrix[i].length; j++) {\n\t\t\t\t\t\tif(matrix[i][j] == 1) length += getLength(i, j, matrix);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(length);\n\t\t\t}\n\t\t\tnumOfSheet = in.nextInt();\n\t\t\tprobNum = in.nextInt();\n\t\t}\n\t}\n\t\n\tpublic static int getLength(int x, int y, int[][] matrix) {\n\t\tint ret = 0;\n\t\tint n = 0;\n\t\tif(x==0&&y==0) n = matrix[x][y+1] + matrix[x+1][y];\n\t\telse if(x==0&&y==matrix[0].length-1) n = matrix[x][y-1] + matrix[x+1][y];\n\t\telse if(x==matrix.length-1&&y==0) n = matrix[x-1][y] + matrix[x][y+1];\n\t\telse if(x==matrix.length-1&&y==matrix[x].length-1) n = matrix[x][y-1] + matrix[x-1][y];\n\t\telse if(x==0) n = matrix[x][y+1] + matrix[x][y-1] + matrix[x+1][y];\n\t\telse if(x==matrix.length-1) n = matrix[x][y+1] + matrix[x][y-1] + matrix[x-1][y];\n\t\telse if(y==0) n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y+1];\n\t\telse if(y==matrix[x].length-1) n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y-1];\n\t\telse n = matrix[x-1][y] + matrix[x+1][y] + matrix[x][y-1] + matrix[x][y+1];\n\t\t\n\t\tswitch(n){\n\t\tcase 1:\n\t\t\tret = 3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//Sheets\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R{\n\t\tint x1, x2, type;\n\t\tpublic R(int x1, int x2, int type) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tint n, r, area, len, INF = 1<<28;\n\tint[][] a;\n\tList<R>[] list;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\ta = new int[2][10000];\n\t\tlist = new List[10001];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); r = sc.nextInt();\n\t\t\tif((n|r)==0)break;\n\t\t\tint minx = INF, maxx = -1, miny = INF, maxy = -1;\n\t\t\tarea = len = 0;\n\t\t\tfor(int i=0;i<=10000;i++)list[i] = new ArrayList<R>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\t\tminx = Math.min(minx, x1);\n\t\t\t\tmaxx = Math.max(maxx, x2);\n\t\t\t\tminy = Math.min(miny, y1);\n\t\t\t\tmaxy = Math.max(maxy, y2);\n\t\t\t\tlist[y1].add(new R(x1, x2, 1));\n\t\t\t\tlist[y2].add(new R(x1, x2, -1));\n\t\t\t}\n\t\t\tArrays.fill(a[0], 0);\n\t\t\tint X = 1;\n\t\t\tfor(int y=miny;y<=maxy+1;y++,X=1-X){\n\t\t\t\tfor(int x=minx;x<maxx;x++)a[X][x]=a[1-X][x];\n\t\t\t\tfor(R r:list[y]){\n\t\t\t\t\tfor(int x=r.x1;x<r.x2;x++)a[X][x]+=r.type;\n\t\t\t\t}\n\t\t\t\tfor(int x=minx;x<maxx;x++){\n\t\t\t\t\tif(0 < a[X][x]){\n\t\t\t\t\t\tarea++;\n\t\t\t\t\t\tif(x==0 || a[X][x-1]==0)len++;\n\t\t\t\t\t\tif(x==9999 || a[X][x+1]==0)len++;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[X][x]==0&&0<a[1-X][x] || 0<a[X][x]&&a[1-X][x]==0)len++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif(r==2)System.out.println(len);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tint number, judge,area_counter;\n\t\tint x1, y1,x2,y2;\n\t\tString[] coordinate = null;\n\t\tArrayList<String> coordinateAll = new ArrayList<String>();\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tarea_counter = 0;\n\t\t\tnumber = scan.nextInt();//長方形の数\n\t\t\tjudge = scan.nextInt();//1 or 2\n\t\t\tif(number==0 && judge ==0){\n\t\t\t\tSystem.exit(0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<number;i++){\n\t\t\t\tx1 = scan.nextInt();\n\t\t\t\ty1 = scan.nextInt();\n\t\t\t\tx2 = scan.nextInt();\n\t\t\t\ty2 = scan.nextInt();\n\t\t\t\tcoordinate = coordinateSet(x1,y1,x2,y2);\n\t\t\t\tfor(String oneCoordinate : coordinate){\n\t\t\t\t\tif(!coordinateAll.contains(oneCoordinate)){\n\t\t\t\t\t\tcoordinateAll.add(oneCoordinate);\n\t\t\t\t\t\tarea_counter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(judge ==1){\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter);}\n\t\t\telse{\n\t\t\t\tint cf_counter = Circumference(coordinateAll);\n\t\t\t\tcoordinateAll.clear();\n\t\t\t\tSystem.out.println(area_counter+\"\\n\"+ cf_counter);\n\t\t\t}\n\t\t}\n\t}\n\tprivate static int Circumference(ArrayList<String> inputSet){//周長を求める\n\t\tint x,y,result=0;\n\t\tfor(String eachInput : inputSet){\n\t\t\tScanner scan = new Scanner(eachInput);\n\t\t\tx = scan.nextInt();\n\t\t\ty = scan.nextInt();\n\t\t\tString checker1,checker2;\n\t\t\t\tfor(int i=-1;i<2;i=i+2){\n\t\t\t\t\tint new_x = x+i;\n\t\t\t\t\tint new_y = y+i;\n\t\t\t\t\tchecker1 = new_x + \" \"+y;\n\t\t\t\t\tif(!inputSet.contains(checker1)){\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t\tchecker2 = x + \" \"+ new_y;\n\t\t\t\t\tif(!inputSet.contains(checker2)){\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tprivate static String[] coordinateSet(int x1,int y1,int x2,int y2){//座標列の出力\n\t\tint count =0;\n\t\tint number = Math.abs(x2-x1)*Math.abs(y2-y1);\n\t\tString[] result = new String[number];\n\t\tfor(int i=x1;i<x2;i++){\n\t\t\tfor(int j=y1;j<y2;j++){\n\t\t\t\tresult[count]=i+\" \"+j;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static short[][] sp = new short[10002][10002];\n\tprivate static int xmax = 0, ymax = 0, xmin = 10002, ymin = 10002;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tfor (int x = 0; x < 10002; x++)\n\t\t\tfor (int y = 0; y < 10002; y++)\n\t\t\t\tsp[x][y] = 1;\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new File(\"c:\\\\0509-input.txt\"));\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\t\t\tif (n == 0 && r == 0)\n\t\t\t\tbreak;\n\t\t\tint area = 0;\n\t\t\tfor (int x = xmin + 1; x <= xmax; x++)\n\t\t\t\tfor (int y = ymin + 1; y <= ymax; y++)\n\t\t\t\t\tsp[x][y] = 1;\n\t\t\txmax = 0;\n\t\t\tymax = 0;\n\t\t\txmin = 10002;\n\t\t\tymin = 10002;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x1 = scan.nextInt();\n\t\t\t\tint y1 = scan.nextInt();\n\t\t\t\tint x2 = scan.nextInt();\n\t\t\t\tint y2 = scan.nextInt();\n\t\t\t\tarea += setRect(x1, y1, x2, y2);\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t\tif (r == 2)\n\t\t\t\tSystem.out.println(side());\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static int side() {\n\t\tint sideLen = 0;\n\t\tfor (int x = xmin + 1; x <= xmax; x++)\n\t\t\tfor (int y = ymin + 1; y <= ymax; y++)\n\t\t\t\tif (sp[x][y] == 0)\n\t\t\t\t\tsideLen += (sp[x - 1][y] + sp[x][y - 1] + sp[x + 1][y] + sp[x][y + 1]);\n\t\treturn sideLen;\n\t}\n\n\tprivate static int setRect(int x1, int y1, int x2, int y2) {\n\t\tint area = 0;\n\t\tfor (int x = x1 + 1; x <= x2; x++)\n\t\t\tfor (int y = y1 + 1; y <= y2; y++)\n\t\t\t\tif (sp[x][y] == 1) {\n\t\t\t\t\tarea++;\n\t\t\t\t\tsp[x][y] = 0;\n\t\t\t\t}\n\t\tif (xmin > x1)\n\t\t\txmin = x1;\n\t\tif (ymin > y1)\n\t\t\tymin = y1;\n\t\tif (xmax < x2)\n\t\t\txmax = x2;\n\t\tif (ymax < y2)\n\t\t\tymax = y2;\n\t\treturn area;\n\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                var nr = Console.ReadLine().Split(' ');\n                int n = int.Parse(nr[0]), r = int.Parse(nr[1]);\n                if (n + r == 0) break;\n\n                var sheet = new int[10001 + 2][];\n                for (int i = 0; i < 10001 + 2; i++)\n                    sheet[i] = new int[10001 + 2];\n\n                int minx = 10001, miny = 10001, maxx = 1, maxy = 1;\n\n                while (n-- != 0)\n                {\n                    var xy = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    int x1 = xy[0] + 1, y1 = xy[1] + 1, x2 = xy[2] + 1, y2 = xy[3] + 1;\n                    sheet[x1][y1] += 1;\n                    sheet[x2][y2] += 1;\n                    sheet[x1][y2] -= 1;\n                    sheet[x2][y1] -= 1;\n                    minx = Math.Min(minx, x1);\n                    maxx = Math.Max(maxx, x2);\n                    miny = Math.Min(minx, y1);\n                    maxy = Math.Max(maxx, y2);\n                }\n\n                for (int i = minx; i <= maxx; i++)\n                {\n                    var depth = 0;\n                    for (int j = miny; j <= maxy; j++)\n                    {\n                        depth += sheet[i][j];\n                        sheet[i][j] = depth;\n                    }\n                }\n                for (int j = miny; j <= maxy; j++)\n                {\n                    var depth = 0;\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        depth += sheet[i][j];\n                        sheet[i][j] = depth;\n                    }\n                }\n\n                var count = 0;\n                for (int j = miny; j <= maxy; j++)\n                {\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        if (sheet[i][j] > 0)\n                            count++;\n                    }\n                }\n                Console.WriteLine(count);\n\n                if (r == 2)\n                {\n                    count = 0;\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        for (int j = miny; j <= maxy; j++)\n                        {\n                            if (sheet[i][j] > 0)\n                            {\n                                if (sheet[i - 1][j] == 0)\n                                    count++;\n                                if (sheet[i][j - 1] == 0)\n                                    count++;\n                                if (sheet[i + 1][j] == 0)\n                                    count++;\n                                if (sheet[i][j + 1] == 0)\n                                    count++;\n                            }\n                        }\n                    }\n                    Console.WriteLine(count);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int r = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[,] rects = new int[n,4];\n\t\t  for(int i=0;i<n;i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\trects[i,0] = int.Parse(str2[0]); \n\t\t\trects[i,1] = int.Parse(str2[1]); \n\t\t\trects[i,2] = int.Parse(str2[2]); \n\t\t\trects[i,3] = int.Parse(str2[3]); \n\t\t  }\n\t\t\t\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,r,rects));\n\t\t\n\t\t\n\t\t}\n\n\t}\n  \n  public static string calc(int n, int r, int[,] rects) {\n\tbool[,] area = new bool[10002,10002];\n\t\n\tint r1 = 0;\n\tint r2 = 0;\n\tfor(int i=0;i<rects.GetLength(0);i++){\n\t\tfor(int x=rects[i,0]+1;x<=rects[i,2];x++){\n\t\tfor(int y=rects[i,1]+1;y<=rects[i,3];y++){\n\t\t\tif(area[x,y] == false) {\n\t\t\t  area[x,y] = true;\n\t\t\t  int cnt = -4;\n\t\t\t  if(area[x-1,y] == false) cnt+=2;\n\t\t\t  if(area[x+1,y] == false) cnt+=2;\n\t\t\t  if(area[x,y-1] == false) cnt+=2;\n\t\t\t  if(area[x,y+1] == false) cnt+=2;\n\t\t\t  r1 += cnt;\n\t\t\t  \n\t\t\t  r2++;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn (r==1) ? r2.ToString() : r2.ToString() + \"\\n\" + r1.ToString();\n  }\n  \n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int r = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[,] rects = new int[n,4];\n\t\t  for(int i=0;i<n;i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\trects[i,0] = int.Parse(str2[0]); \n\t\t\trects[i,1] = int.Parse(str2[1]); \n\t\t\trects[i,2] = int.Parse(str2[2]); \n\t\t\trects[i,3] = int.Parse(str2[3]); \n\t\t  }\n\t\t\t\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,r,rects));\n\t\t\n\t\t\n\t\t}\n\n\t}\n  \n  public static string calc(int n, int r, int[,] rects) {\n\tbool[,] area = new bool[10002,10002];\n\t\n\tint r1 = 0;\n\tint r2 = 0;\n\tif(r==1) {\n\t\tfor(int i=0;i<rects.GetLength(0);i++){\n\t\t\tfor(int x=rects[i,0]+1;x<=rects[i,2];x++){\n\t\t\tfor(int y=rects[i,1]+1;y<=rects[i,3];y++){\n\t\t\t\tif(area[x,y] == false) {\n\t\t\t\t  area[x,y] = true;\n\t\t\t\t  \n\t\t\t\t  r2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tif(r==2) {\n\t\tfor(int i=0;i<rects.GetLength(0);i++){\n\t\t\tfor(int x=rects[i,0]+1;x<=rects[i,2];x++){\n\t\t\tfor(int y=rects[i,1]+1;y<=rects[i,3];y++){\n\t\t\t\tif(area[x,y] == false) {\n\t\t\t\t  area[x,y] = true;\n\t\t\t\t  \n\t\t\t\t  int cnt = -4;\n\t\t\t\t  if(area[x-1,y] == false) cnt+=2;\n\t\t\t\t  if(area[x+1,y] == false) cnt+=2;\n\t\t\t\t  if(area[x,y-1] == false) cnt+=2;\n\t\t\t\t  if(area[x,y+1] == false) cnt+=2;\n\t\t\t\t  r1 += cnt;\n\t\t\t\t  \n\t\t\t\t  r2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn r2.ToString() + ((r==2) ? \"\\n\" + r1.ToString() : \"\");\n  }\n  \n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int r = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[][] rects = new int[n][];\n\t\t  for(int i=0;i<n;i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\trects[i] = Array.ConvertAll(str2, new Converter<string,int>(s => int.Parse(s)));\n\t\t  }\n\t\t\t\n\t\t\tint[,] brects = omit(rects);\n\t\t\t\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,r,brects));\n\t\t\n\t\t\n\t\t}\n\n\t}\n  \n  public static int[,] omit(int[][] rects) {\n\tList<int[]> arect = new List<int[]>();\n\tfor(int i=0;i<rects.Length;i++){\n\t\tbool insert = true;\n\t\tforeach(int[] ar in arect){\n\t\t\tif((ar[0] >= rects[i][0]) && (ar[1] >= rects[i][1]) && (rects[i][2] <= ar[2]) && (rects[i][3] <= ar[3])) {\n\t\t\t\tinsert = false;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(insert) arect.Add(rects[i]);\n\t}\n\t\n\t  int[,] brects = new int[arect.Count,4];\n\t  for(int i=0;i<arect.Count;i++) {\n\t\tbrects[i,0] = arect[i][0]; \n\t\tbrects[i,1] = arect[i][1]; \n\t\tbrects[i,2] = arect[i][2]; \n\t\tbrects[i,3] = arect[i][3]; \n\t  }\n\n    return brects;\n  }\n  \n  public static string calc(int n, int r, int[,] rects) {\n\tbool[,] area = new bool[10002,10002];\n\t\n\tint r1 = 0;\n\tint r2 = 0;\n\tif(r==1) {\n\t\tfor(int i=0;i<rects.GetLength(0);i++){\n\t\t\tfor(int x=rects[i,0]+1;x<=rects[i,2];x++){\n\t\t\tfor(int y=rects[i,1]+1;y<=rects[i,3];y++){\n\t\t\t\tif(area[x,y] == false) {\n\t\t\t\t  area[x,y] = true;\n\t\t\t\t  \n\t\t\t\t  r2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tif(r==2) {\n\t\tfor(int i=0;i<rects.GetLength(0);i++){\n\t\t\tfor(int x=rects[i,0]+1;x<=rects[i,2];x++){\n\t\t\tfor(int y=rects[i,1]+1;y<=rects[i,3];y++){\n\t\t\t\tif(area[x,y] == false) {\n\t\t\t\t  area[x,y] = true;\n\t\t\t\t  \n\t\t\t\t  int cnt = -4;\n\t\t\t\t  if(area[x-1,y] == false) cnt+=2;\n\t\t\t\t  if(area[x+1,y] == false) cnt+=2;\n\t\t\t\t  if(area[x,y-1] == false) cnt+=2;\n\t\t\t\t  if(area[x,y+1] == false) cnt+=2;\n\t\t\t\t  r1 += cnt;\n\t\t\t\t  \n\t\t\t\t  r2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn r2.ToString() + ((r==2) ? \"\\n\" + r1.ToString() : \"\");\n  }\n  \n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int r = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[,] rects = new int[n,4];\n\t\t  for(int i=0;i<n;i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\trects[i,0] = int.Parse(str2[0]); \n\t\t\trects[i,1] = int.Parse(str2[1]); \n\t\t\trects[i,2] = int.Parse(str2[2]); \n\t\t\trects[i,3] = int.Parse(str2[3]); \n\t\t  }\n\t\t\t\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,r,rects));\n\t\t\n\t\t\n\t\t}\n\n\t}\n  \n  public static string calc(int n, int r, int[,] rects) {\n\tbool[,] area = new bool[10002,10002];\n\t\n\tint r1 = 0;\n\tint r2 = 0;\n\tfor(int i=0;i<rects.GetLength(0);i++){\n\t\tfor(int x=rects[i,0]+1;x<=rects[i,2];x++){\n\t\tfor(int y=rects[i,1]+1;y<=rects[i,3];y++){\n\t\t\tif(area[x,y] == false) {\n\t\t\t  area[x,y] = true;\n\t\t\t  \n\t\t\t  if(r==2){\n\t\t\t\t  int cnt = -4;\n\t\t\t\t  if(area[x-1,y] == false) cnt+=2;\n\t\t\t\t  if(area[x+1,y] == false) cnt+=2;\n\t\t\t\t  if(area[x,y-1] == false) cnt+=2;\n\t\t\t\t  if(area[x,y+1] == false) cnt+=2;\n\t\t\t\t  r1 += cnt;\n\t\t\t  }\n\t\t\t  \n\t\t\t  r2++;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn (r==1) ? r2.ToString() : r2.ToString() + \"\\n\" + r1.ToString();\n  }\n  \n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int r = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[][] rects = new int[n][];\n\t\t  for(int i=0;i<n;i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\trects[i] = Array.ConvertAll(str2, new Converter<string,int>(s => int.Parse(s)));\n\t\t  }\n\t\t\n\t\t\tint[][] brects = omit(rects);\n\t\t\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,r,brects));\n\t\t\n\t\t\n\t\t}\n\n\t}\n  \n  public static int[][] omit(int[][] rects) {\n\t//Console.WriteLine(\"omit1=\" + rects.Length.ToString());\n\tArray.Sort(rects,\n    (x, y) => ((y[2]-y[0])*(y[3]-y[1])).CompareTo(((x[2]-x[0])*(x[3]-x[1]))));\n\t\n\tList<int[]> arect = new List<int[]>();\n\tforeach(int[] or in rects){\n\t\tbool insert = true;\n\t\tforeach(int[] ar in arect){\n\t\t\tif((ar[0] <= or[0]) && (ar[1] <= or[1]) && (or[2] <= ar[2]) && (or[3] <= ar[3])) {\n\t\t\t\tinsert = false;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(insert) arect.Add(or);\n\t}\n\t//Console.WriteLine(\"omit2=\" + arect.Count.ToString());\n\tList<int[]> brect = new List<int[]>();\n\tforeach(int[] or in arect){\n\t\tint[] br = {or[0], or[1], or[2], or[3]};\n\t\tforeach(int[] ar in brect){\n\t\t\tif((ar[0] <= br[2]) && (br[2] <= ar[2]) && (ar[1] <= br[1]) && (br[3] <= ar[3])) {\n\t\t\t\tbr[2] = ar[0];\n\t\t\t}\n\t\t\tif((br[0] <= ar[2]) && (ar[0] <= br[0]) && (ar[1] <= br[1]) && (br[3] <= ar[3])) {\n\t\t\t\tbr[0] = ar[2];\n\t\t\t}\n\t\t\tif((ar[1] <= br[3]) && (br[3] <= ar[3]) && (ar[0] <= br[0]) && (br[2] <= ar[2])) {\n\t\t\t\tbr[3] = ar[1];\n\t\t\t}\n\t\t\tif((br[1] <= ar[3]) && (ar[1] <= br[1]) && (ar[0] <= br[0]) && (br[2] <= ar[2])) {\n\t\t\t\tbr[1] = ar[3];\n\t\t\t}\n\t\t}\n\t\tif((br[0]<br[2]) && (br[1]<br[3])) brect.Add(br);\n\t}\n\t\n\t\n\t//Console.WriteLine(\"omit3=\" + brect.Count.ToString());\n    return brect.ToArray();\n  }\n  \n  public static string calc(int n, int r, int[][] rects) {\n\tbool[,] area = new bool[10002,10002];\n\t\n\tint r1 = 0;\n\tint r2 = 0;\n\tforeach(int[] or in rects){\n\t\tfor(int x=or[0]+1;x<=or[2];x++){\n\t\tfor(int y=or[1]+1;y<=or[3];y++){\n\t\t\tif(!area[x,y]) {\n\t\t\t  area[x,y] = true;\n\t\t\t  \n\t\t\t  int cnt = -2;\n\t\t\t  if(!area[x-1,y]) cnt++;\n\t\t\t  if(!area[x+1,y]) cnt++;\n\t\t\t  if(!area[x,y-1]) cnt++;\n\t\t\t  if(!area[x,y+1]) cnt++;\n\t\t\t  r1 += 2*cnt;\n\t\t\t  \n\t\t\t  r2++;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn r2.ToString() + ((r==2) ? \"\\n\" + r1.ToString() : \"\");\n  }\n  \n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int r = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[][] rects = new int[n][];\n\t\t  for(int i=0;i<n;i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\trects[i] = Array.ConvertAll(str2, new Converter<string,int>(s => int.Parse(s)));\n\t\t  }\n\t\t\n\t\t\tint[][] brects = omit(rects);\n\t\t\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,r,brects));\n\t\t\n\t\t\n\t\t}\n\n\t}\n  \n  public static int[][] omit(int[][] rects) {\n\tSortedList<int, int[]> srects = new SortedList<int, int[]>();\n\t\n\t\n\t\n\tList<int[]> arect = new List<int[]>();\n\tforeach(int[] or in rects){\n\t\tbool insert = true;\n\t\tforeach(int[] ar in arect){\n\t\t\tif((ar[0] <= or[0]) && (ar[1] <= or[1]) && (or[2] <= ar[2]) && (or[3] <= ar[3])) {\n\t\t\t\tinsert = false;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(insert) arect.Add(or);\n\t}\n\n    return arect.ToArray();\n  }\n  \n  public static string calc(int n, int r, int[][] rects) {\n\tbool[,] area = new bool[10002,10002];\n\t\n\tint r1 = 0;\n\tint r2 = 0;\n\tforeach(int[] or in rects){\n\t\tfor(int x=or[0]+1;x<=or[2];x++){\n\t\tfor(int y=or[1]+1;y<=or[3];y++){\n\t\t\tif(!area[x,y]) {\n\t\t\t  area[x,y] = true;\n\t\t\t  \n\t\t\t  int cnt = -2;\n\t\t\t  if(!area[x-1,y]) cnt++;\n\t\t\t  if(!area[x+1,y]) cnt++;\n\t\t\t  if(!area[x,y-1]) cnt++;\n\t\t\t  if(!area[x,y+1]) cnt++;\n\t\t\t  r1 += 2*cnt;\n\t\t\t  \n\t\t\t  r2++;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn r2.ToString() + ((r==2) ? \"\\n\" + r1.ToString() : \"\");\n  }\n  \n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                var nr = Console.ReadLine().Split(' ');\n                int n = int.Parse(nr[0]), r = int.Parse(nr[1]);\n                if (n + r == 0) break;\n\n                var sheet = new bool[10001 + 2][];\n                for (int i = 0; i < 10001 + 2; i++)\n                    sheet[i] = new bool[10001 + 2];\n\n                int minx = 10001, miny = 10001, maxx = 1, maxy = 1;\n\n                while (n-- != 0)\n                {\n                    var xy = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    int x1 = xy[0], y1 = xy[1], x2 = xy[2], y2 = xy[3];\n                    for (int i = x1; i < x2; i++)\n                    {\n                        for (int j = y1; j < y2; j++)\n                        {\n                            sheet[i + 1][j + 1] = true;\n                        }\n                    }\n                    minx = Math.Min(minx, x1);\n                    maxx = Math.Max(maxx, x2);\n                    miny = Math.Min(minx, y1);\n                    maxy = Math.Max(maxx, y2);\n                }\n\n                var count = 0;\n                for (int i = minx; i <= maxx; i++)\n                    for (int j = miny; j <= maxy; j++)\n                        if (sheet[i][j]) count++;\n                Console.WriteLine(count);\n\n                if (r == 2)\n                {\n                    count = 0;\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        for (int j = miny; j <= maxy; j++)\n                        {\n                            if (sheet[i][j])\n                            {\n                                if (!sheet[i - 1][j])\n                                    count++;\n                                if (!sheet[i][j - 1])\n                                    count++;\n                                if (!sheet[i + 1][j])\n                                    count++;\n                                if (!sheet[i][j + 1])\n                                    count++;\n                            }\n                        }\n                    }\n                    Console.WriteLine(count);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                var nr = Console.ReadLine().Split(' ');\n                int n = int.Parse(nr[0]), r = int.Parse(nr[1]);\n                if (n + r == 0) break;\n\n                var sheet = new bool[10001 + 2][];\n                for (int i = 0; i < 10001 + 2; i++)\n                    sheet[i] = new bool[10001 + 2];\n\n                while (n-- != 0)\n                {\n                    var xy = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    int x1 = xy[0], y1 = xy[1], x2 = xy[2], y2 = xy[3];\n                    for (int i = x1; i < x2; i++)\n                    {\n                        for (int j = y1; j < y2; j++)\n                        {\n                            sheet[i + 1][j + 1] = true;\n                        }\n                    }\n                }\n\n                var count = 0;\n                for (int i = 0; i < 10001 + 2; i++)\n                    for (int j = 0; j < 10001 + 2; j++)\n                        if (sheet[i][j]) count++;\n                Console.WriteLine(count);\n\n                if (r == 2)\n                {\n                    count = 0;\n                    for (int i = 1; i < 10001 + 1; i++)\n                    {\n                        for (int j = 1; j < 10001 + 1; j++)\n                        {\n                            if (sheet[i][j])\n                            {\n                                if (!sheet[i - 1][j])\n                                    count++;\n                                if (!sheet[i][j - 1])\n                                    count++;\n                                if (!sheet[i + 1][j])\n                                    count++;\n                                if (!sheet[i][j + 1])\n                                    count++;\n                            }\n                        }\n                    }\n                    Console.WriteLine(count);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0509\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int r = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[,] rects = new int[n,4];\n\t\t  for(int i=0;i<n;i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\trects[i,0] = int.Parse(str2[0]); \n\t\t\trects[i,1] = int.Parse(str2[1]); \n\t\t\trects[i,2] = int.Parse(str2[2]); \n\t\t\trects[i,3] = int.Parse(str2[3]); \n\t\t  }\n\t\t\t\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,r,rects));\n\t\t\n\t\t\n\t\t}\n\n\t}\n  \n  public static string calc(int n, int r, int[,] rects) {\n\tbool[,] area = new bool[10002,10002];\n\t\n\tint r1 = 0;\n\tint r2 = 0;\n\tfor(int i=0;i<rects.GetLength(0);i++){\n\t\tfor(int x=rects[i,0]+1;x<=rects[i,2];x++){\n\t\tfor(int y=rects[i,1]+1;y<=rects[i,3];y++){\n\t\t\tif(area[x,y] == false) {\n\t\t\t  area[x,y] = true;\n\t\t\t  \n\t\t\t  if(2==2){\n\t\t\t\t  int cnt = -4;\n\t\t\t\t  if(area[x-1,y] == false) cnt+=2;\n\t\t\t\t  if(area[x+1,y] == false) cnt+=2;\n\t\t\t\t  if(area[x,y-1] == false) cnt+=2;\n\t\t\t\t  if(area[x,y+1] == false) cnt+=2;\n\t\t\t\t  r1 += cnt;\n\t\t\t  }\n\t\t\t  \n\t\t\t  r2++;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn (r==1) ? r2.ToString() : r2.ToString() + \"\\n\" + r1.ToString();\n  }\n  \n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                var nr = Console.ReadLine().Split(' ');\n                int n = int.Parse(nr[0]), r = int.Parse(nr[1]);\n                if (n + r == 0) break;\n\n                var sheet = new short[10001 + 2][];\n                for (int i = 0; i < 10001 + 2; i++)\n                    sheet[i] = new short[10001 + 2];\n\n                int minx = 10001, miny = 10001, maxx = 1, maxy = 1;\n\n                while (n-- != 0)\n                {\n                    var xy = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    int x1 = xy[0] + 1, y1 = xy[1] + 1, x2 = xy[2] + 1, y2 = xy[3] + 1;\n                    sheet[x1][y1] += 1;\n                    sheet[x2][y2] += 1;\n                    sheet[x1][y2] -= 1;\n                    sheet[x2][y1] -= 1;\n                    minx = Math.Min(minx, x1);\n                    maxx = Math.Max(maxx, x2);\n                    miny = Math.Min(minx, y1);\n                    maxy = Math.Max(maxx, y2);\n                }\n\n                for (int i = minx; i <= maxx; i++)\n                {\n                    short depth = 0;\n                    for (int j = miny; j <= maxy; j++)\n                    {\n                        depth += sheet[i][j];\n                        sheet[i][j] = depth;\n                    }\n                }\n                for (int j = miny; j <= maxy; j++)\n                {\n                    short depth = 0;\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        depth += sheet[i][j];\n                        sheet[i][j] = depth;\n                    }\n                }\n\n                var count = 0;\n                for (int j = miny; j <= maxy; j++)\n                {\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        if (sheet[i][j] > 0)\n                            count++;\n                    }\n                }\n                Console.WriteLine(count);\n\n                if (r == 2)\n                {\n                    count = 0;\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        for (int j = miny; j <= maxy; j++)\n                        {\n                            if (sheet[i][j] > 0)\n                            {\n                                if (sheet[i - 1][j] == 0)\n                                    count++;\n                                if (sheet[i][j - 1] == 0)\n                                    count++;\n                                if (sheet[i + 1][j] == 0)\n                                    count++;\n                                if (sheet[i][j + 1] == 0)\n                                    count++;\n                            }\n                        }\n                    }\n                    Console.WriteLine(count);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                var nr = Console.ReadLine().Split(' ');\n                int n = int.Parse(nr[0]), r = int.Parse(nr[1]);\n                if (n + r == 0) break;\n\n                var sheet = new short[10001 + 2][];\n                for (int i = 0; i < 10001 + 2; i++)\n                    sheet[i] = new short[10001 + 2];\n\n                int minx = 10001, miny = 10001, maxx = 1, maxy = 1;\n\n                while (n-- != 0)\n                {\n                    var xy = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    int x1 = xy[0] + 1, y1 = xy[1] + 1, x2 = xy[2] + 1, y2 = xy[3] + 1;\n                    sheet[x1][y1] += 1;\n                    sheet[x2][y2] += 1;\n                    sheet[x1][y2] -= 1;\n                    sheet[x2][y1] -= 1;\n                    minx = Math.Min(minx, x1);\n                    maxx = Math.Max(maxx, x2);\n                    miny = Math.Min(minx, y1);\n                    maxy = Math.Max(maxx, y2);\n                }\n\n                for (int i = minx; i <= maxx; i++)\n                {\n                    short depth = 0;\n                    for (int j = miny; j <= maxy; j++)\n                    {\n                        depth += sheet[i][j];\n                        sheet[i][j] = depth;\n                    }\n                }\n                var count = 0;\n                for (int j = miny; j <= maxy; j++)\n                {\n                    short depth = 0;\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        depth += sheet[i][j];\n                        sheet[i][j] = depth;\n                        if (sheet[i][j] > 0)\n                            count++;\n                    }\n                }\n                Console.WriteLine(count);\n\n                if (r == 2)\n                {\n                    count = 0;\n                    for (int i = minx; i <= maxx; i++)\n                    {\n                        for (int j = miny; j <= maxy; j++)\n                        {\n                            if (sheet[i][j] > 0)\n                            {\n                                if (sheet[i - 1][j] == 0)\n                                    count++;\n                                if (sheet[i][j - 1] == 0)\n                                    count++;\n                                if (sheet[i + 1][j] == 0)\n                                    count++;\n                                if (sheet[i][j + 1] == 0)\n                                    count++;\n                            }\n                        }\n                    }\n                    Console.WriteLine(count);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n  puts xmax\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n\n  f = \"0\"*(xmax*ymax)\n  \n  for i in 0..n-1\n    for y in a[1][i]..a[3][i]\n      for x in a[0][i]..a[2][i]\n        f[y*ymax+x] = \"1\"\n      end\n    end\n  end\n\n  puts xmax\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  field = []\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field += [[x,y]]\n      end\n    end\n  end\n  puts field.uniq.size\n  puts 2 if r == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    (field += Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y] == 0)\n          l += 1 if (x==xmax || field[x+1][y] == 0)\n          l += 1 if (y==0 || field[x][y-1] == 0)\n          l += 1 if (y==ymax || field[x][y+1] == 0)\n        end\n      end\n    end\n    puts l\n  end\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if n==0&&r==0\n  \n  cov = []\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1      \n      cov[y] += (x1..x2-1).to_a rescue cov[y] = (x1..x2-1).to_a\n    end\n  end\n  \n  puts cov.map{|covy| covy.uniq}.compact.flatten.size\n  puts 123 if r == 2\n\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  puts a.size\n  puts a.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "def transpose(a,ymax,xmax)\n  Array.new(xmax){|i|\n    str = \"\"\n    for j in 0..ymax-1\n      str += a[j][i]\n    end\n    str\n  }\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           for x in xmin..xmax-1\n             if y>=ymin\n               for i in 0..n-1\n                 inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n                 break if inc\n               end\n               f[x] = \"1\" if inc\n             end\n           end\n           return f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+transpose(f,ymax,xmax)).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  #x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n    xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n\n          for i in 0..n-1\n            inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n             break if inc\n          end\n          inc ? 1 : 0\n                         \n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in y1s[i]..y2s[i]-1\n      for x in x1s[i]..x2s[i]-1\n        f[y][x] = 1\n      end\n    end\n  end\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTree\n\tdef initialize(n, l = 0, r = n-1)\n\t\t@range_min = l\n\t\t@range_max = r\n\t\t@start = 0\n\t\t@between = 0\n\t\t@end = 0\n\t\tif l == r\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(n, l, c)\n\t\t\t@right_child = self.class.new(n, c+1, r)\n\t\tend\n\tend\n\n\tattr_reader :range_min, :range_max\n\n\tdef add_start(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@start |= bits\n\t\telse\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_start(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_start(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_end(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@end |= bits\n\t\telse\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_end(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_end(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_between(x, y, bits)\n\t\treturn if x > y\n\n\t\tif x == @range_min && y == @range_max\n\t\t\t@between |= bits\n\t\telse\n\t\t\tlr = @left_child.range_max\n\t\t\t@left_child.add_between(x, lr < y ? lr : y, bits)\n\t\t\trl = @right_child.range_min\n\t\t\t@right_child.add_between(rl > x ? rl : x, y, bits)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @range_min != @range_max\n\t\t\t@left_child.take(@start, @between, @end)\n\t\t\t@right_child.take(@start, @between, @end)\n\t\tend\n\t\t@star = @between = @end = 0\n\tend\n\n\tdef take(start, between, finish)\n\t\t@start |= start\n\t\t@between |= between\n\t\t@end |= finish\n\tend\n\n\tdef net_start_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @start\n\t\t\tbits -= bits & @end\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_start_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_start_count(x)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef net_end_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @end\n\t\t\tbits -= bits & @start\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse force\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_end_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_end_count(x)\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nones = [0]\n10000.times{\n\tones << ((ones[-1] << 1) | 1)\n}\n\nt = Time.new\n\nloop {\n\tn, r = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\n\ta = (1..n).map{ gets.split.map(&:to_i) }\n\tmax_x = a.map{|_,_,x2,_| x2}.max\n\tmax_y = a.map{|_,_,_,y2| y2}.max\n\tv_st = LazySegmentTree.new(max_x+1)\n\th_st = LazySegmentTree.new(max_y+1)\n\n\ta.each {|x1, y1, x2, y2|\n\t\tbits = ones[y2-y1] << y1\n\t\tv_st.add_start(x1, bits)\n\t\tv_st.add_between(x1+1, x2-1, bits) if x1+1 < x2\n\t\tv_st.add_end(x2, bits)\n\t\tbits = ones[x2-x1] << x1\n\t\th_st.add_start(y1, bits)\n\t\th_st.add_between(y1+1, y2-1, bits) if y1+1 < y2\n\t\th_st.add_end(y2, bits)\n\t}\n\n\tarea = 0\n\tfor x in 0..max_x\n\t\tarea += v_st.net_start_count(x) * (10000-x)\n\t\tarea -= v_st.net_end_count(x) * (10000-x)\n\tend\n\tp area\n\n\tif r == 2\n\t\tlen = 0\n\t\tfor x in 0..max_x\n\t\t\tlen += v_st.net_start_count(x)\n\t\t\tlen += v_st.net_end_count(x)\n\t\tend\n\t\tfor y in 0..max_y\n\t\t\tlen += h_st.net_start_count(y)\n\t\t\tlen += h_st.net_end_count(y)\n\t\tend\n\t\tp len\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n\n  b = a.transpose\n  xmax = b[2].max\n  ymax = b[3].max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n           for i in 0..n-1\n             x1,y1,x2,y2 = a[i]\n             inc = (y1<=y && y<y2 && x1<=x && x<x2)\n             break if inc\n           end\n           inc ? 1 : 0\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  xmax,ymax =100\n  \n  begin\n    f = Array.new(100){|y| Array.new(100){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = a[i]\n          (xmax = x2 ; raise) if xmax<x2\n          (ymax = y2 ; raise) if ymax<y2\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n  rescue\n    f = Array.new(ymax){|y| Array.new(xmax){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = a[i]\n          (xmax = x2 ; raise) if xmax<x2\n          (ymax = y2 ; raise) if ymax<y2\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n  else\n    f\n  end\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi = [] ; yi = [] ; xf = [] ; yf = []\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[1]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1].nil?)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1].nil?) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x].nil?)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x].nil?)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def unify(rg,i,f)\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| \n       if y<ymin\n         Array.new(xmax){0}\n       else\n         Array.new(xmax){|x|\n           val = 0\n           if x>=xmin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      end\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.tranpose\n  \n  puts a.size\n  puts a.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n           for i in 0..n-1\n             inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n             break if inc\n           end\n           inc ? 1 : 0\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        for i in 0..n-1\n          cov = (x1s[i]<=x&&x<x2s[i]&&y1s[i]<=y&&y<y2s[i])\n          break if cov\n        end\n        s += 1 if cov\n      end\n    end\n    puts s\n  end\n\n  if  r == 2\n    f = Array.new(ymax){|y|\n          Array.new(xmax){|x|\n            cov = flase\n            for i in 0..n-1\n              cov = (x1s[i]<=x&&x<x2s[i]&&y1s[i]<=y&&y<y2s[i])\n              break if cov\n            end\n            s += 1 if cov\n            cov ? 1 : 0\n          }\n        }\n     puts s\n     puts (f+f.transpose).inject(0){|sum,arr| sum += (arr.join.split(\"0\")-[\"\"]).size}*2\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTree\n\tdef initialize(n, l = 0, r = n-1)\n\t\t@range_min = l\n\t\t@range_max = r\n\t\t@start = 0\n\t\t@between = 0\n\t\t@end = 0\n\t\tif l == r\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(n, l, c)\n\t\t\t@right_child = self.class.new(n, c+1, r)\n\t\tend\n\tend\n\n\tattr_reader :range_min, :range_max\n\n\tdef add_start(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@start |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_start(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_start(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_end(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@end |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_end(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_end(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_between(x, y, bits)\n\t\treturn if x > y\n\n\t\tif x == @range_min && y == @range_max\n\t\t\t@between |= bits\n\t\telse\n\t\t\tforce\n\t\t\tlr = @left_child.range_max\n\t\t\t@left_child.add_between(x, lr < y ? lr : y, bits)\n\t\t\trl = @right_child.range_min\n\t\t\t@right_child.add_between(rl > x ? rl : x, y, bits)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @range_min != @range_max\n\t\t\t@left_child.take(@start, @between, @end)\n\t\t\t@right_child.take(@start, @between, @end)\n\t\tend\n\t\t@star = @between = @end = 0\n\tend\n\n\tdef take(start, between, finish)\n\t\t@start |= start\n\t\t@between |= between\n\t\t@end |= finish\n\tend\n\n\tdef net_start_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @start\n\t\t\tbits -= bits & @end\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_start_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_start_count(x)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef net_end_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @end\n\t\t\tbits -= bits & @start\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse force\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_end_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_end_count(x)\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nones = [0]\nhead_one = {}\n1000.times{\n\tones << ((ones[-1] << 1) | 1)\n\thead_one[ones[-1]] = head_one.size\n}\n\nt = Time.new\n\nloop {\n\tn, r = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\tv_st = LazySegmentTree.new(10001)\n\th_st = LazySegmentTree.new(10001)\n\n\tn.times {\n\t\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\t\tbits = ones[y2-y1] << y1\n\t\tv_st.add_start(x1, bits)\n\t\tv_st.add_between(x1+1, x2-1, bits) if x1+1 < x2\n\t\tv_st.add_end(x2, bits)\n\t\tbits = ones[x2-x1] << x1\n\t\th_st.add_start(y1, bits)\n\t\th_st.add_between(y1+1, y2-1, bits) if y1+1 < y2\n\t\th_st.add_end(y2, bits)\n\t}\n\n\tarea = 0\n\tfor i in 0..1000\n\t\tarea += v_st.net_start_count(i) * (1000-i)\n\t\tarea -= v_st.net_end_count(i) * (1000-i)\n\tend\n\tp area\n\n\tif r == 2\n\t\tlen = 0\n\t\tfor i in 0..1000\n\t\t\tlen += v_st.net_start_count(i)\n\t\t\tlen += v_st.net_end_count(i)\n\t\t\tlen += h_st.net_start_count(i)\n\t\t\tlen += h_st.net_end_count(i)\n\t\tend\n\t\tp len\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        cov = false\n        for i in 0..n-1\n          cov = (x1s[i]<=x&&x<x2s[i]&&y1s[i]<=y&&y<y2s[i])\n          break if cov\n        end\n        s += 1 if cov\n      end\n    end\n    puts s\n  end\n\n  if  r == 2\n    f = Array.new(ymax){|y|\n          Array.new(xmax){|x|\n            cov = flase\n            for i in 0..n-1\n              cov = (x1s[i]<=x&&x<x2s[i]&&y1s[i]<=y&&y<y2s[i])\n              break if cov\n            end\n            s += 1 if cov\n            cov ? 1 : 0\n          }\n        }\n     puts s\n     puts (f+f.transpose).inject(0){|sum,arr| sum += (arr.join.split(\"0\")-[\"\"]).size}*2\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field =Array.new(1000){Array.new(1000){0}}\n  xi,yi,xf,yf = [],[],[],[]\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  puts s if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if n==0&&r==0\n  \n  cov = []\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1      \n      (cov[y] += (x1..x2-1).to_a) rescue (cov[y] = (x1..x2-1).to_a)\n    end\n  end\n  \n  puts cov.map{|covy| covy.uniq}.compact.flatten.size\n  puts 123 if r == 2\n\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  rectangles = Array.new(n){gets.split(\" \").map{|j| j.to_i}}\n  xmax,ymax = rectangles.zip[3..4].map{|arr| arr.max}\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = rectangles[i]\n    for x in x1..x2-1\n      for y in y1..y2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax-1\n      for y in 0..ymax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1].nil?)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1].nil?) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x].nil?)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x].nil?)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n\n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n\n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n  a = Array.new(ymax){|y|\n    Array.new(xmax){|x|\n      cov = false\n      for i in 0..n-1\n        cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n        break if cov\n      end\n      s += 1 if cov\n      cov ? 1 : 0\n    }\n  }\n\n  puts s\n  puts (a+a.transpose).inject(0){|sum,arr| sum+=(arr.join.split(\"0\")-[\"\"]).size}*2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field = []\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field[y] += [x]\n      end\n      field[y]uniq\n    end\n  end\n  puts field.compact.flatten.size\n  puts 32 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    a = [[]]\n    for i in 0..n-1\n      for y in y1s[i]..y2s[i]-1\n        for x in x1s[i]..x2s[i]-1\n          s += 1 if a[y][x].defined?\n          a[y][x] = 1\n        end\n      end\n    end\n    puts s\n  end\n\n  if  r == 2\n    f = Array.new(ymax){|y|\n          Array.new(xmax){|x|\n            cov = false\n            for i in 0..n-1\n              cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n              break if cov\n            end\n            s += 1 if cov\n            cov ? 1 : 0\n          }\n        }\n     puts s\n     puts (f+f.transpose).inject(0){|sum,arr| sum += (arr.join.split(\"0\")-[\"\"]).size}*2\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n           if x<xmin || y<ymin\n             0\n           else\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             inc ? 1 : 0\n           end\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n        if y<ymin\n          return Array.new(xmax){0}\n        else   \n          return Array.new(xmax){|x|\n           val = 0\n\n           if x>=xmin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n           for i in 0..n-1\n             x1,y1,x2,y2 = a.transpose[i]\n             inc = (y1<=y && y<y2 && x1<=x && x<x2)\n             break if inc\n           end\n           inc ? 1 : 0\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi,yi,xf,yf = [],[],[],[]\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n    xmax = xf[i] if xf[i]>=xf[0]\n    ymax = yf[i] if yf[i]>=yf[0]\n  end\n\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1]==0\n          l+=1 if x==xmax-1||field[y][x+1]==0 \n          l+=1 if y==0||field[y-1][x]==0\n          l+=1 if y==ymax-1||field[y+1][x]==0\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n\n  b = a.transpose\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n           for i in 0..n-1\n             x1,y1,x2,y2 = a[i]\n             inc = (y1<=y && y<y2 && x1<=x && x<x2)\n             break if inc\n           end\n           inc ? 1 : 0\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTree\n\tdef initialize(n, l = 0, r = n-1)\n\t\t@range_min = l\n\t\t@range_max = r\n\t\t@start = 0\n\t\t@between = 0\n\t\t@end = 0\n\t\tif l == r\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(n, l, c)\n\t\t\t@right_child = self.class.new(n, c+1, r)\n\t\tend\n\tend\n\n\tattr_reader :range_min, :range_max\n\n\tdef add_start(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@start |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_start(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_start(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_end(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@end |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_end(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_end(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_between(x, y, bits)\n\t\treturn if x > y\n\n\t\tif x == @range_min && y == @range_max\n\t\t\t@between |= bits\n\t\telse\n\t\t\tforce\n\t\t\tlr = @left_child.range_max\n\t\t\t@left_child.add_between(x, lr < y ? lr : y, bits)\n\t\t\trl = @right_child.range_min\n\t\t\t@right_child.add_between(rl > x ? rl : x, y, bits)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @range_min != @range_max\n\t\t\t@left_child.take(@start, @between, @end)\n\t\t\t@right_child.take(@start, @between, @end)\n\t\tend\n\t\t@star = @between = @end = 0\n\tend\n\n\tdef take(start, between, finish)\n\t\t@start |= start\n\t\t@between |= between\n\t\t@end |= finish\n\tend\n\n\tdef net_start_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @start\n\t\t\tbits -= bits & @end\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_start_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_start_count(x)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef net_end_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @end\n\t\t\tbits -= bits & @start\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse force\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_end_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_end_count(x)\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nones = [0]\n10000.times{\n\tones << ((ones[-1] << 1) | 1)\n}\n\nt = Time.new\n\nloop {\n\tn, r = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\n\ta = (1..n).map{ gets.split.map(&:to_i) }\n\tmax_x = a.map{|_,_,x2,_| x2}.max\n\tmax_y = a.map{|_,_,_,y2| y2}.max\n\tv_st = LazySegmentTree.new(max_x+1)\n\th_st = LazySegmentTree.new(max_y+1)\n\n\ta.each {|x1, y1, x2, y2|\n\t\tbits = ones[y2-y1] << y1\n\t\tv_st.add_start(x1, bits)\n\t\tv_st.add_between(x1+1, x2-1, bits) if x1+1 < x2\n\t\tv_st.add_end(x2, bits)\n\t\tbits = ones[x2-x1] << x1\n\t\th_st.add_start(y1, bits)\n\t\th_st.add_between(y1+1, y2-1, bits) if y1+1 < y2\n\t\th_st.add_end(y2, bits)\n\t}\n\n\tarea = 0\n\tfor x in 0..max_x\n\t\tarea += v_st.net_start_count(x) * (10000-x)\n\t\tarea -= v_st.net_end_count(x) * (10000-x)\n\tend\n\tp area\n\n\tif r == 2\n\t\tlen = 0\n\t\tfor x in 0..max_x\n\t\t\tlen += v_st.net_start_count(x)\n\t\t\tlen += v_st.net_end_count(x)\n\t\tend\n\t\tfor y in 0..max_y\n\t\t\tlen += h_st.net_start_count(y)\n\t\t\tlen += h_st.net_end_count(y)\n\t\tend\n\t\tp len\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n           val = 0\n           if x>=xmin && y>=ymin\n             for i in 0..n-1\n               inc = (y1s[i]..y2s[i]-1).include?(y) && (x1s[i]..x2s[i]-1).include?(x)\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.empty?\n    rg = [i..f]\n  else\n    s = [rg[-1].last,f].max\n    a = Array.new(s){|j|\n      val = 1\n      if j<i || f<j\n        for k in 0..rg.size-1\n          inc = rg[k].include?(j)\n          break if inc\n        end\n        val = (inc ? 1 : 0)\n      end\n      val\n    }\n    a+=[0]\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==1}\n      break if idx.nil?\n      a = a[0..idx-1]\n      idx2 = a.rindex{|x| x==0}\n      rg = [idx2+1..idx1]+rg\n      a = a[0..idx-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]]\n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2\n      xrgs[y] = unite(xrgs[y],x1,x2) rescue xrgs[y] =[x1..x2]\n    end\n    for x in x1..x2\n      yrgs[x] = unite(yrgs[x],y1,y2) rescue yrgs[x] =[y1..y2]\n    end\n  end\n\n  puts xrgs.compact.map{|arr| arr.map{|rng| rng.last-rng.first+1}}.flatten.inject(:+)\n  puts (xrgs+yrgs).compact.map{|arr| arr.size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.nil? || rg.empty?\n    rg = [i..f]\n  else\n    a = []\n    rg << i..f\n    for j in 0..rg.size-1\n      for k in rg[j]\n        a[k] = 0\n      end\n    end\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==0}\n      break if idx1.nil?\n      a = a[0..idx1-1]\n      idx2 = a.rindex{|x| x.nil?}\n      idx2.nil? ? (rg=[0..idx1]+rg ;break) : rg = [idx2+1..idx1]+rg\n      a = a[0..idx2-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]] \n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      xrgs[y] = unite(xrgs[y],x1,x2-1)\n    end\n    for x in x1..x2-1\n      yrgs[x] = unite(yrgs[x],y1,y2-1)\n    end\n  end\n\n  xrgs.compact!\n  yrgs.compact!\n  puts xrgs.flatten.inject(0){|sum,rng| sum += (rng.last-rng.begin+1)}\n  puts (xrgs+yrgs).inject(0){|sum,arr| sum += arr.size}*2 if r==2\n  \nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n      n.times{\n        x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n      }\n    }\n  }\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi,yi,xf,yf = [],[],[],[]\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(100){Array.new(100)}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil? rescue next\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          begin\n            l+=1 if x==0||field[y][x-1].nil?\n          end\n          begin\n            l+=1 if x==xmax-1||field[y][x+1].nil?\n          end\n          begin \n            l+=1 if y==0||field[y-1][x].nil?\n          end\n          begin\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n          end\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field = []\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field[y] += [x]\n      end\n      field[y]uniq\n    end\n  end\n  puts field.compact.flatten.size\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(500){|y| Array.new(500){|x|\n           for i in 0..n-1\n             inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n             break if inc\n           end\n           inc ? 1 : 0\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  rectangles = Array.new(n){|i| gets.split(\" \").map{|j| j.to_i}}\n  xmax, ymax = rectangles.zip[3..4].map{|arr| arr.max}\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = rectangles[i]\n    for x in x1..x2-1\n      for y in y1..y2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax-1\n      for y in 0..ymax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1]==0)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1]==0) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x]==0)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    a = []\n    for i in 0..n-1\n      for y in y1s[i]..y2s[i]-1\n        for x in x1s[i]..x2s[i]-1\n          s += 1 if a[y][x].nil?\n          a[y][x] = 1\n        end\n      end\n    end\n    puts s\n  end\n\n  if  r == 2\n    f = Array.new(ymax){|y|\n          Array.new(xmax){|x|\n            cov = false\n            for i in 0..n-1\n              cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n              break if cov\n            end\n            s += 1 if cov\n            cov ? 1 : 0\n          }\n        }\n     puts s\n     puts (f+f.transpose).inject(0){|sum,arr| sum += (arr.join.split(\"0\")-[\"\"]).size}*2\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    (field = field + Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2-1\n      for y in y1..y2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax-1\n      for y in 0..ymax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1]==0)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1]==0) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x]==0)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "  while str = gets do\n    num, r = str.chomp.split(\" \").map(&:to_i)\n    hash = {}\n    num.times do |n|\n      x1, y1, x2, y2 = gets.chomp.split(\" \").map(&:to_i)\n      (y1..y2).each do |y|\n        hash[y] = [] unless hash.has_key?(y)\n        (x1..x2).each do |x|\n          hash[y] << x unless hash[y].include?(x)\n        end\n      end\n    end\n    area = 0\n    hash.each do |key, val|\n      area += val.length\n    end\n    cir = 0\n    if r == 2\n      hash.each do |key, val|\n        val.each do |v|\n          cir += 1 unless val.include?(val - 1)\n          cir += 1 unless val.include?(val + 1)\n          cir += 1 unless hash.has_key?(key - 1) && hash[key - 1].include?(val)\n          cir += 1 unless hash.has_key?(key + 1) && hash[key + 1].include?(val)\n        end\n      end\n    end\n    puts area\n    puts cir if r == 2\n  end"
  },
  {
    "language": "Ruby",
    "code": "def trsnpose(a)\n  Array.new(a[0].size){|i|\n    str = \"\"\n    for j in 0..a.size-1\n      str += a[j][i]\n    end\n    str\n  end\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           for x in xmin..xmax-1\n             if y>=ymin\n               for i in 0..n-1\n                 inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n                 break if inc\n               end\n               f[x] = \"1\" if inc\n             end\n           end\n           f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+transpose(f)).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0  \n  xi,yi,xf,yf = Array.new(n){gets.split(\" \").map{|j| j.to_i}}.zip\n\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  puts s if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n           val = 0\n\n           if x>=xmin && y>=ymin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "m=Array.new(10001){Array.new(10001){0}}\ndef a;gets.split.map(&:to_i);end\nn,r=a\nn.times{x,y,t,u=a\n(x...t).each{|i|(y...u).each{|j|m[i][j]=1}}}\np m.flatten.count 1\np (0...10000).inject(0){|s,i|s+(0...10000).inject(0){|d,j|d+((m[i][j]==0)?0:(4-m[i-1][j]-m[i+1][j]-m[i][j-1]-m[i][j+1]))}} if r==2"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100)}\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|i| i.to_i}  \n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y].nil?)\n          l += 1 if (x==xmax || field[x+1][y].nil?)\n          l += 1 if (y==0 || field[x][y-1].nil?)\n          l += 1 if (y==ymax || field[x][y+1].nil?)\n        end\n      end\n    end\n    puts l\n  end\n\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "def a;gets.split.map(&:to_i);end\nM=10001\nwhile(n,r=a)!=[0,0]\no=[]\nn.times{x,y,t,u=a\n(x+1..t).each{|i|l=u-y;o[i*M+y+1,l]=[true]*l}}\np o.count true\np o.each_with_index.inject(0){|s,(b,i)|s+(b ?([o[i-1],o[i+1],o[i-M],o[i+M]].count{|o|!o}):0)}if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  rectangles = Array.new(n){gets.split(\" \").map{|j| j.to_i}}\n  xmax,ymax = rectangles.zip[3..4].map{|arr| arr.max}\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = rectangles[i]\n    for x in x1..x2-1\n      for y in y1..y2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax-1\n      for y in 0..ymax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1]==0)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1]==0) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x]==0)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field = Array.new(1000){[]}\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field[y] += [x]\n      end\n      field[y].uniq\n    end\n  end\n  puts field.compact.flatten.size\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if n==0&&r==0\n  \n  cov = []\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1      \n      cov[y] += (x1..x2-1).to_a rescue cov[y] = (x1..x2-1).to_a\n    end\n  end\n  \n  puts cov.map{|covy| covy.uniq}.flatten.compact.size\n  puts 123 if r == 2\n\nend"
  },
  {
    "language": "Ruby",
    "code": "class Line\n  attr_reader :first, :last\n  def initialize first, last\n    @first, @last = first, last\n  end\n\n  # return lines\n  def - other\n    if first >= other.first && last <= other.last\n      # hidden\n      []\n    elsif first < other.first && last > other.last\n      # head & tail\n      [Line.new(first, other.first), Line.new(other.last, last)]\n    elsif first < other.first && last > other.first\n      # head\n      [Line.new(first, other.first)]\n    elsif first < other.last && last > other.last\n      # tail\n      [Line.new(other.last, last)]\n    else\n      # all\n      [self]\n    end\n  end\n\n  # return lines\n  def & other\n    p_first = [first, other.first].max\n    p_last = [last, other.last].min\n    p_first < p_last ? [Line.new(p_first, p_last)] : []\n  end\n\n  def length\n    last - first\n  end\n\n  def cover? i\n    i >= first && i <= last\n  end\nend\n\nclass Rect\n  attr_reader :x1, :y1, :x2, :y2\n  def initialize x1, y1, x2, y2\n    @x1, @y1, @x2, @y2 = x1, y1, x2, y2\n  end\n\n  def area\n    x_line.length * y_line.length\n  end\n\n  # return rects\n  def - other\n    left_right = (x_line - other.x_line).map {|x_s_line|\n      Rect.new(x_s_line.first, y1, x_s_line.last, y2)\n    }.to_a\n\n    up_down = (x_line & other.x_line).flat_map {|x_p_line|\n      (y_line - other.y_line).map {|y_s_line|\n        Rect.new(x_p_line.first, y_s_line.first, x_p_line.last, y_s_line.last)\n      }\n    }.to_a\n\n    left_right.concat(up_down)\n  end\n\n\n  def x_line\n    Line.new x1, x2\n  end\n\n  def y_line\n    Line.new y1, y2\n  end\nend\n\nclass RectWithValidPerimeter\n  attr_reader :rect\n  attr_accessor :left_lines, :right_lines, :up_lines, :down_lines\n\n  def initialize rect\n    @rect = rect\n    @left_lines = [Line.new(rect.y1, rect.y2)]\n    @right_lines = [Line.new(rect.y1, rect.y2)]\n    @up_lines = [Line.new(rect.x1, rect.x2)]\n    @down_lines = [Line.new(rect.x1, rect.x2)]\n  end\n\n  def prune_valid_perimeter! other_rect, remain_when_same_line\n    if other_rect.x_line.cover?(rect.x1) && (!remain_when_same_line || !(other_rect.x1 == rect.x1))\n      #left\n      @left_lines = prune_valid_lines @left_lines, other_rect.y_line\n    end\n    if other_rect.x_line.cover?(rect.x2) && (!remain_when_same_line || !(other_rect.x2 == rect.x2))\n      #right\n      @right_lines = prune_valid_lines @right_lines, other_rect.y_line\n    end\n    if other_rect.y_line.cover?(rect.y1) && (!remain_when_same_line || !(other_rect.y1 == rect.y1))\n      #up\n      @up_lines = prune_valid_lines @up_lines, other_rect.x_line\n    end\n    if other_rect.y_line.cover?(rect.y2) && (!remain_when_same_line || !(other_rect.y2 == rect.y2))\n      #down\n      @down_lines = prune_valid_lines @down_lines, other_rect.x_line\n    end\n  end\n\n  def valid_perimeter\n    [@left_lines, @right_lines, @up_lines, @down_lines]\n      .flat_map {|lines| lines.map(&:length) }\n      .reduce(0, :+)\n  end\n\n  private\n  def prune_valid_lines valid_lines, deleter_line\n    valid_lines.flat_map {|valid_line| valid_line - deleter_line }\n  end\nend\n\ndef calc_area rects\n  extract_unique_rects([], rects.dup)\n    .lazy\n    .map(&:area)\n    .reduce(0, :+)\nend\n\ndef extract_unique_rects fixed_rects, remain_rects\n  return fixed_rects if remain_rects.empty?\n  return extract_unique_rects(\n    fixed_rects.concat(fixed_rects.reduce([remain_rects.pop]) {|parts, fixed_rect|\n      parts.flat_map {|part| part - fixed_rect }\n    }),\n    remain_rects\n  )\nend\n\ndef calc_perimeter rects\n  units = rects.map {|r| RectWithValidPerimeter.new(r) }\n  units.combination(2).each {|(a, b)|\n    a.prune_valid_perimeter! b.rect, true\n    b.prune_valid_perimeter! a.rect, false\n  }\n  units\n    .lazy\n    .map {|u| u.valid_perimeter }\n    .reduce(0, :+)\nend\n\nEnumerator.new {|y|\n  until ((n_r = gets.split(\" \").map(&:to_i)) == [0, 0])\n    y << [[method(:calc_area), method(:calc_perimeter)].take(n_r[1]), n_r[0].times.map { Rect.new(*gets.split(\" \").map(&:to_i)) }]\n  end\n}\n  .flat_map{|(resolvers, rects)| resolvers.map {|r| r[rects] } }\n  .each {|r| puts r }"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if n==0 && r==0\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|i| i.to_i}  \n    (field += Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y] == 0\n      end\n    end\n  end\n  puts s\n  \n  end\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.nil? || rg.empty?\n    rg = [i..f]\n  else\n    a = []\n    for k in i..f\n      a[k] = 0\n    end\n    for j in 0..rg.size-1\n      for k in rg[j]\n        a[k] = 0\n      end\n    end\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==0}\n      break if idx1.nil?\n      a = a[0..idx1-1]\n      idx2 = a.rindex{|x| x.nil?}\n      idx2.nil? ? (rg=[0..idx1]+rg ;break) : rg = [idx2+1..idx1]+rg\n      a = a[0..idx2-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]] \n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      xrgs[y] = unite(xrgs[y],x1,x2-1)\n    end\n    for x in x1..x2-1\n      yrgs[x] = unite(yrgs[x],y1,y2-1)\n    end\n  end\n\n  xrgs.compact!\n  yrgs.compact!\n  puts xrgs.flatten.map{|rng| rng.last-rng.begin+1}.inject(:+)\n  puts (xrgs+yrgs).map{|arr| arr.size}.inject(:+)*2 if r==2\n  \nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(500){|y| Array.new(500){|x|\n           if x<xmin || xmax<x || y<ymin || ymax<y\n             1\n           else\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             inc ? 1 : 0\n           end\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi = [] ; yi = [] ; xf = [] ; yf = []\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in yi[1]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1]==0)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1]==0) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x]==0)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field = Array.new(1000){[]}\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field[y] += [x]\n      end\n      field[y]uniq\n    end\n  end\n  puts field.compact.flatten.size\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100)}\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|i| i.to_i}  \n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y].nil?)\n          l += 1 if (x==xmax || field[x+1][y].nil?)\n          l += 1 if (y==0 || field[x][y-1].nil?)\n          l += 1 if (x==ymax || field[x][y+1].nil?)\n        end\n      end\n    end\n    puts l\n  end\n\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field =Array.new(1000){Array.new(1000){0}}\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  puts s if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  xmax,ymax =100\n  \n  begin\n    f = Array.new(100){|y| Array.new(100){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = a[i]\n          (xmax = x2 ; raise) if xmax<x2\n          (ymax = y2 ; raise) if ymax<y2\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n  rescue\n    f = Array.new(ymax){|y| Array.new(xmax){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = a[i]\n          (xmax = x2 ; raise) if xmax<x2\n          (ymax = y2 ; raise) if ymax<y2\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n  end\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n    xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n\n                        for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n                          inc ? 1 : 0\n           else\n             0\n           end\n           \n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  xmax,ymax = a.transpose[2..3].map{|arr| arr.max}\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(4){gets.split(\" \").map{|i| i.to_i}}\n  a = a.transpose\n  \n  puts a.size\n  puts a.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.nil? || rg.empty?\n    rg = [i..f]\n  else\n    a = []\n    for k in i..f\n      a[k] = 0\n    end\n    for j in 0..rg.size-1\n      for k in rg[j]\n        a[k] = 0\n      end\n    end\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==0}\n      break if idx1.nil?\n      a = a[0..idx1-1]\n      idx2 = a.rindex{|x| x.nil?}\n      idx2.nil? ? (rg=[0..idx1]+rg ;break) : rg = [idx2+1..idx1]+rg\n      a = a[0..idx2-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]] \n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      xrgs[y] = unite(xrgs[y],x1,x2-1)\n    end\n    for x in x1..x2-1\n      yrgs[x] = unite(yrgs[x],y1,y2-1)\n    end\n  end\n\n  xrgs.compact!\n  yrgs.compact!\n  puts xrgs.flatten.inject(0){|sum,rng| sum += (rng.last-rng.begin+1)}\n  puts (xrgs+yrgs).inject(0){|sum,arr| sum += arr.size}*2 if r==2\n  \nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n        if y<ymin\n          return Array.new(xmax){0}\n        else   \n          return Array.new(xmax){|x|\n           val = 0\n\n           if x>=xmin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi = [] ; yi = [] ; xf = [] ; yf = []\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1].nil?\n          l+=1 if x==xmax-1||field[y][x+1].nil? \n          l+=1 if y==0||field[y-1][x].nil?\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi,yi,xf,yf = [],[],[],[]\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1].nil?\n          l+=1 if x==xmax-1||field[y][x+1].nil? \n          l+=1 if y==0||field[y-1][x].nil?\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n    xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n\n                        for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n                          inc ? 1 : 0\n                         \n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  begin\n    f = Array.new(100){|y| Array.new(100){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n  end\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n\n  f = Array.new(ymax){\"0\"*xmax}\n  \n  puts f.size\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field = []\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field[y] += [x]\n      end\n      field[y].uniq\n    end\n  end\n  puts field.compact.flatten.size\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  rectangles = Array.new(n){gets.split(\" \").map{|j| j.to_i}}\n  xmax, ymax = rectangles.zip[3..4].map{|arr| arr.max}\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = rectangles[i]\n    for x in x1..x2-1\n      for y in y1..y2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax-1\n      for y in 0..ymax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1]==0)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1]==0) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x]==0)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.nil? || rg.empty?\n    rg = [i..f]\n  else\n    a = []\n    rg += [i..f]\n    for j in 0..rg.size-1\n      for k in rg[j]\n        a[k] = 0\n      end\n    end\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==0}\n      break if idx1.nil?\n      a = a[0..idx1-1]\n      idx2 = a.rindex{|x| x.nil?}\n      idx2.nil? ? (rg=[0..idx1]+rg ;break) : rg = [idx2+1..idx1]+rg\n      a = a[0..idx2-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]] \n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      xrgs[y] = unite(xrgs[y],x1,x2-1)\n    end\n    for x in x1..x2-1\n      yrgs[x] = unite(yrgs[x],y1,y2-1)\n    end\n  end\n\n  xrgs.compact!\n  yrgs.compact!\n  puts xrgs.flatten.inject(0){|sum,rng| sum += (rng.last-rng.begin+1)}\n  puts (xrgs+yrgs).inject(0){|sum,arr| sum += arr.size}*2 if r==2\n  \nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    (field = field + Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[y][x] = 1 ; s+=1) if field[y][x] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1]==0)\n          x==xmax ? l+=1 : (l+=1 if field[y][x+1]==0) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x]==0)\n          y==ymax ? l+=1 : (l+=1 if field[y+1][x]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(500){|y| Array.new(500){|x|\n           if x<xmin || xmax<x || y<ymin || ymax<y\n             0\n           else\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             inc ? 1 : 0\n           end\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(100){|y| Array.new(100){|x|\n           for i in 0..n-1\n             inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n             break if inc\n           end\n           inc ? 1 : 0\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if n==0 && r==0\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|i| i.to_i}  \n    (field = field+Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field = field.map{|arr| arr = arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y] == 0)\n          l += 1 if (x==xmax || field[x+1][y] == 0)\n          l += 1 if (y==0 || field[x][y-1] == 0)\n          l += 1 if (x==ymax || field[x][y+1] == 0)\n        end\n      end\n    end\n    puts l\n  end\n\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100)}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    ymax = y2 if y2 > ymax\n    xmax = x2 if x2 > xmax\n    for x in x1..x2-1\n      for y in y1..y2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax-1\n      for y in 0..ymax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1].nil?)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1].nil?) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x].nil?)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x].nil?)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           for x in xmin..xmax-1\n             unless y<ymin || ymax<y\n               for i in 0..n-1\n                 inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n                 break if inc\n               end\n               f[x] = \"1\" if inc\n             end\n           end\n           f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\nloop do\n  area = Hash.new{Hash.new}\n\n  n, r = gets.split.map(&:to_i)\n  break if n == 0\n\n  n.times do\n    x1, y1, x2, y2 = gets.split.map(&:to_i)\n    (x1 ... x2).each do |x|\n      (y1 ... y2).each do |y|\n        area[x] = area[x]\n        area[x][y] = true\n      end\n    end\n  end\n\n  puts area.inject(0){|a, b| a + b[1].each_value.count(true)}\n\n  if r == 2\n    res = 0\n    area.each do |x, vx|\n      vx.each do |y, vy|\n        res += 1 unless area[x - 1][y]\n        res += 1 unless area[x + 1][y]\n        res += 1 unless area[x][y - 1]\n        res += 1 unless area[x][y + 1]\n      end\n    end\n    puts res\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n        if y<ymin\n          Array.new(xmax){0}\n        else   \n        Array.new(xmax){|x|\n           val = 0\n\n           if x>=xmin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTree\n\tdef initialize(n, l = 0, r = n-1)\n\t\t@range_min = l\n\t\t@range_max = r\n\t\t@start = 0\n\t\t@between = 0\n\t\t@end = 0\n\t\tif l == r\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(n, l, c)\n\t\t\t@right_child = self.class.new(n, c+1, r)\n\t\tend\n\tend\n\n\tattr_reader :range_min, :range_max\n\n\tdef add_start(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@start |= bits\n\t\telse\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_start(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_start(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_end(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@end |= bits\n\t\telse\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_end(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_end(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_between(x, y, bits)\n\t\treturn if x > y\n\n\t\tif x == @range_min && y == @range_max\n\t\t\t@between |= bits\n\t\telse\n\t\t\tlr = @left_child.range_max\n\t\t\t@left_child.add_between(x, lr < y ? lr : y, bits)\n\t\t\trl = @right_child.range_min\n\t\t\t@right_child.add_between(rl > x ? rl : x, y, bits)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @range_min != @range_max\n\t\t\t@left_child.take(@start, @between, @end)\n\t\t\t@right_child.take(@start, @between, @end)\n\t\tend\n\t\t@star = @between = @end = 0\n\tend\n\n\tdef take(start, between, finish)\n\t\t@start |= start\n\t\t@between |= between\n\t\t@end |= finish\n\tend\n\n\tdef net_start_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @start\n\t\t\tbits -= bits & @end\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_start_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_start_count(x)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef net_end_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @end\n\t\t\tbits -= bits & @start\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse force\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_end_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_end_count(x)\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nones = [0]\n10000.times{\n\tones << ((ones[-1] << 1) | 1)\n}\n\nt = Time.new\n\nloop {\n\tn, r = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\n\ta = (1..n).map{ gets.split.map(&:to_i) }\n\tmax_x = a.map{|_,_,x2,_| x2}.max\n\tmax_y = a.map{|_,_,_,y2| y2}.max\n\tv_st = LazySegmentTree.new(max_x+1)\n\th_st = LazySegmentTree.new(max_y+1)\n\n\ta.each {|x1, y1, x2, y2|\n\t\tbits = ones[y2-y1] << y1\n\t\tv_st.add_start(x1, bits)\n\t\tv_st.add_between(x1+1, x2-1, bits) if x1+1 < x2\n\t\tv_st.add_end(x2, bits)\n\t\tbits = ones[x2-x1] << x1\n\t\th_st.add_start(y1, bits)\n\t\th_st.add_between(y1+1, y2-1, bits) if y1+1 < y2\n\t\th_st.add_end(y2, bits)\n\t}\n\n\tarea = 0\n\tfor x in 0..max_x\n\t\tarea += v_st.net_start_count(x) * (10000-x)\n\t\tarea -= v_st.net_end_count(x) * (10000-x)\n\tend\n\tp area\n\n\tif r == 2\n\t\tlen = 0\n\t\tfor x in 0..max_x\n\t\t\tlen += v_st.net_start_count(x)\n\t\t\tlen += v_st.net_end_count(x)\n\t\tend\n\t\tfor y in 0..max_y\n\t\t\tlen += h_st.net_start_count(y)\n\t\t\tlen += h_st.net_end_count(y)\n\t\tend\n\t\tp len\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| f = \"0\"*xmax\n           unless x<xmin || xmax<x || y<ymin || ymax<y\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             f[x] = \"1\" if inc\n           end\n        }\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           unless x<xmin || xmax<x || y<ymin || ymax<y\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             f[x] = \"1\" if inc\n           end\n           f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if n==0&&r==0\n  \n  cov = [[]]\n  \n  n.times{\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1      \n      (cov[y] += (x1..x2-1).to_a) rescue (cov[y] = (x1..x2-1).to_a)\n      cov[y].uniq\n    end\n  }\n  \n  puts(cov.compact.flatten.size)\n  puts(123) if r == 2\n\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  field = 0\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field += 1\n      end\n    end\n  end\n  puts field\n  puts 2 if r == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n    for i in 0..n-1\n      inc = (a[1][i]<=y && y<a[3][i] && a[0][i]<=x && x<a[2][i])\n      break if inc\n    end\n    inc ? 1 : 0\n    }\n  }\n\n  puts f.size\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  cov = [[]]\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        cov[y] += [x] #rescue cov[y] = [x]\n      end\n      cov[y].uniq\n    end\n  end\n  puts cov.flatten.compact.size\n  puts 300 if r == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi,yi,xf,yf = [],[],[],[]\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  puts s if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTree\n\tdef initialize(n, l = 0, r = n-1)\n\t\t@range_min = l\n\t\t@range_max = r\n\t\t@start = 0\n\t\t@between = 0\n\t\t@end = 0\n\t\tif l == r\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(n, l, c)\n\t\t\t@right_child = self.class.new(n, c+1, r)\n\t\tend\n\tend\n\n\tattr_reader :range_min, :range_max\n\n\tdef add_start(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@start |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_start(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_start(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_end(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@end |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_end(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_end(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_between(x, y, bits)\n\t\treturn if x > y\n\n\t\tif x == @range_min && y == @range_max\n\t\t\t@between |= bits\n\t\telse\n\t\t\tforce\n\t\t\tlr = @left_child.range_max\n\t\t\t@left_child.add_between(x, lr < y ? lr : y, bits)\n\t\t\trl = @right_child.range_min\n\t\t\t@right_child.add_between(rl > x ? rl : x, y, bits)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @range_min != @range_max\n\t\t\t@left_child.take(@start, @between, @end)\n\t\t\t@right_child.take(@start, @between, @end)\n\t\tend\n\t\t@star = @between = @end = 0\n\tend\n\n\tdef take(start, between, finish)\n\t\t@start |= start\n\t\t@between |= between\n\t\t@end |= finish\n\tend\n\n\tdef net_start_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @start\n\t\t\tbits -= bits & @end\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_start_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_start_count(x)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef net_end_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @end\n\t\t\tbits -= bits & @start\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse force\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_end_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_end_count(x)\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nones = [0]\n10000.times{\n\tones << ((ones[-1] << 1) | 1)\n}\n\nt = Time.new\n\nloop {\n\tn, r = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\tv_st = LazySegmentTree.new(10001)\n\th_st = LazySegmentTree.new(10001)\n\n\tn.times {\n\t\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\t\tbits = ones[y2-y1] << y1\n\t\tv_st.add_start(x1, bits)\n\t\tv_st.add_between(x1+1, x2-1, bits) if x1+1 < x2\n\t\tv_st.add_end(x2, bits)\n\t\tbits = ones[x2-x1] << x1\n\t\th_st.add_start(y1, bits)\n\t\th_st.add_between(y1+1, y2-1, bits) if y1+1 < y2\n\t\th_st.add_end(y2, bits)\n\t}\n\n\tarea = 0\n\tfor i in 0..10000\n\t\tarea += v_st.net_start_count(i) * (10000-i)\n\t\tarea -= v_st.net_end_count(i) * (10000-i)\n\tend\n\tp area\n\n\tif r == 2\n\t\tlen = 0\n\t\tfor i in 0..10000\n\t\t\tlen += v_st.net_start_count(i)\n\t\t\tlen += v_st.net_end_count(i)\n\t\t\tlen += h_st.net_start_count(i)\n\t\t\tlen += h_st.net_end_count(i)\n\t\tend\n\t\tp len\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n           for i in 0..n-1\n             x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n             inc = (y1<=y && y<y2 && x1<=x && x<x2)\n             break if inc\n           end\n           inc ? 1 : 0\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.nil? || rg.empty?\n    rg = [i..f]\n  else\n    a = []\n    for k in i..f\n      a[k] = 0\n    end\n    for j in 0..rg.size-1\n      for k in rg[j]\n        a[k] = 0\n      end\n    end\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==0}\n      break if idx1.nil?\n      a = a[0..idx1-1]\n      idx2 = a.rindex{|x| x.nil?}\n      idx2.nil? ? (rg=[0..idx1]+rg ;break) : rg = [idx2+1..idx1]+rg\n      a = a[0..idx2-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]] \n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      xrgs[y] = unite(xrgs[y],x1,x2-1)\n    end\n    for x in x1..x2-1\n      yrgs[x] = unite(yrgs[x],y1,y2-1)\n    end\n  end\n  \n  xrgs.compact!\n  yrgs.compact!\n\n  puts xrgs.map{|arr| arr.map{|rng| rng.last-rng.begin+1}}.flatten.inject(:+)\n  puts (xrgs+yrgs).map{|arr| arr.size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0  \n  a = Array.new(n){gets.split(\" \").map{|j| j.to_i}}.zip\n  xi,yi,xf,yf = a[0],a[1],a[2],a[3]\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  puts s if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if n==0&&r==0\n  \n  cov = []\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1      \n      (cov[y] += (x1..x2-1).to_a) rescue (cov[y] = (x1..x2-1).to_a)\n    end\n  end\n  \n  puts(cov.map{|y| y.uniq}.flatten.compact.size)\n  puts(123) if r == 2\n\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    (field += Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          x==0 ? l+=1 : (l+=1 if field[x-1][y]==0)\n          x==xmax ? l+=1 : (l+=1 if field[x+1][y]==0) \n          y==0 ? l+=1 : (l+=1 if field[x][y-1]==0)\n          y==ymax ? l+=1 : (l+=1 if field[x][y+1]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi = [] ; yi = [] ; xf = [] ; yf = []\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1].nil?\n          l+=1 if x==xmax-1||field[y][x+1].nil? \n          l+=1 if y==0||field[y-1][x].nil?\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n           val = 0\n           if x>=xmin && y>=ymin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n\n  cov = [[]]\n  \n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      cov[y] = (cov[y]+(x1..x2-1).to_a).uniq.sort rescue (x1..x2-1).to_a\n    end\n  end\n \n  puts cov.compact.flatten.size\n\n  puts cov.size if r == 2\nend    "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  f = Array.new(1000){|y| Array.new(1000){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n      n.times{\n        x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      }\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n\n  b = a.transpose\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n           for i in 0..n-1\n             x1,y1,x2,y2 = a[i]\n             inc = (y1<=y && y<y2 && x1<=x && x<x2)\n             break if inc\n           end\n           inc ? 1 : 0\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n\n  f = Array.new(1000){|y| Array.new(1000){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if n==0 && r==0\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|i| i.to_i}  \n    (field += Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr = arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y] == 0)\n          l += 1 if (x==xmax || field[x+1][y] == 0)\n          l += 1 if (y==0 || field[x][y-1] == 0)\n          l += 1 if (x==ymax || field[x][y+1] == 0)\n        end\n      end\n    end\n    puts l\n  end\n\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n    for i in 0..n-1\n      (val = 1; break) if a[1][i]<=y && y<a[3][i] && a[0][i]<=x && x<a[2][i]\n      val = 0\n    end\n    val\n  }\n\n  puts f.size\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  xmax,ymax =100\n  \n  begin\n    f = Array.new(100){|y| Array.new(100){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = a[i]\n          raise if xmax<x2 || ymax<y2\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n  rescue\n    ymax = y2\n    xmax = x2\n    f = Array.new(y2){|y| Array.new(x2){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = a[i]\n          (xmax = x2 ; raise) if xmax<x2\n          (ymax = y2 ; raise) if ymax<y2\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n  end\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n\n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n\n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        cov = false\n        for i in 0..n-1\n          cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n          break if cov\n        end\n        s += 1 if cov\n      end\n    end\n    puts s\n  end\n  \n  if r == 2\n    a = Array.new(ymax){|y|\n      Array.new(xmax){|x|\n        cov = false\n        for i in 0..n-1\n          cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n          break if cov\n        end\n        s += 1 if cov\n        cov ? 1 : 0\n      }\n    }\n  puts s\n  puts (a+a.transpose).inject(0){|sum,arr| sum+=(arr.join.split(\"0\")-[\"\"]).size}*2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        cov = false\n        for i in 0..n-1\n          cov = (x1s[i]<=x&&x<x2s[i]&&y1s[i]<=y&&y<y2s[i])\n          break if cov\n        end\n        s += 1 if cov\n      end\n    end\n    puts s\n  end\n\n  if  r == 2\n    f = Array.new(ymax){|y|\n          Array.new(xmax){|x|\n            cov = flase\n            for i in 0..n-1\n              cov = (x1s[i]<=x&&x<x2s[i]&&y1s[i]<=y&&y<y2s[i])\n              break if cov\n            end\n            s += 1 if cov\n            cov ? 1 : 0\n          }\n        }\n     puts s\n     puts (f+f.transpose).inject(0){|sum,arr| sum += (arr.join.split(\"0\")-[\"\"]).size}*2\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTree\n\tdef initialize(n, l = 0, r = n-1)\n\t\t@range_min = l\n\t\t@range_max = r\n\t\t@start = 0\n\t\t@between = 0\n\t\t@end = 0\n\t\tif l == r\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(n, l, c)\n\t\t\t@right_child = self.class.new(n, c+1, r)\n\t\tend\n\tend\n\n\tattr_reader :range_min, :range_max\n\n\tdef add_start(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@start |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_start(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_start(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_end(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@end |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_end(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_end(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_between(x, y, bits)\n\t\treturn if x > y\n\n\t\tif x == @range_min && y == @range_max\n\t\t\t@between |= bits\n\t\telse\n\t\t\tforce\n\t\t\tlr = @left_child.range_max\n\t\t\t@left_child.add_between(x, lr < y ? lr : y, bits)\n\t\t\trl = @right_child.range_min\n\t\t\t@right_child.add_between(rl > x ? rl : x, y, bits)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @range_min != @range_max\n\t\t\t@left_child.take(@start, @between, @end)\n\t\t\t@right_child.take(@start, @between, @end)\n\t\tend\n\t\t@star = @between = @end = 0\n\tend\n\n\tdef take(start, between, finish)\n\t\t@start |= start\n\t\t@between |= between\n\t\t@end |= finish\n\tend\n\n\tdef net_start_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @start\n\t\t\tbits -= bits & @end\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_start_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_start_count(x)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef net_end_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @end\n\t\t\tbits -= bits & @start\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse force\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_end_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_end_count(x)\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nones = [0]\n10000.times{\n\tones << ((ones[-1] << 1) | 1)\n}\n\nt = Time.new\n\nloop {\n\tn, r = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\tv_st = LazySegmentTree.new(10001)\n\th_st = LazySegmentTree.new(10001)\n\n\tn.times {\n\t\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\t\tbits = ones[y2-y1] << y1\n\t\tv_st.add_start(x1, bits)\n\t\tv_st.add_between(x1+1, x2-1, bits) if x1+1 < x2\n\t\tv_st.add_end(x2, bits)\n\t\tbits = ones[x2-x1] << x1\n\t\th_st.add_start(y1, bits)\n\t\th_st.add_between(y1+1, y2-1, bits) if y1+1 < y2\n\t\th_st.add_end(y2, bits)\n\t}\n\n\tarea = 0\n\tfor i in 0..1000\n\t\tarea += v_st.net_start_count(i) * (1000-i)\n\t\tarea -= v_st.net_end_count(i) * (1000-i)\n\tend\n\tp area\n\n\tif r == 2\n\t\tlen = 0\n\t\tfor i in 0..1000\n\t\t\tlen += v_st.net_start_count(i)\n\t\t\tlen += v_st.net_end_count(i)\n\t\t\tlen += h_st.net_start_count(i)\n\t\t\tlen += h_st.net_end_count(i)\n\t\tend\n\t\tp len\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n\n  f = \"0\"*(xmax*ymax)\n  \n  for i in 0..n-1\n    for y in a[1][i]..a[3][i]-1\n      for x in a[0][i]..a[2][i]-1\n        f[y*ymax+x] = \"1\"\n      end\n    end\n  end\n\n  puts xmax\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n\n  f = Array.new(100){|y| Array.new(100){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  begin\n    f = Array.new(100){|y| Array.new(100){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n  rescue\n    f = Array.new(1000){|y| Array.new(1000){|x|\n        for i in 0..n-1\n          x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n          inc = (y1<=y && y<y2 && x1<=x && x<x2)\n          break if inc\n        end\n        inc ? 1 : 0\n      }\n    }\n\n  end\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  f = Array.new(1000){|y| Array.new(1000){|x|\n    for i in 0..n-1\n      x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n      inc = (y1<=y && y<y2 && x1<=x && x<x2)\n      break if inc\n    end\n    inc ? 1 : 0\n    }\n  }\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.nil? || rg.empty?\n    rg = [i..f]\n  else\n    a = []\n    for k in i..f\n      a[k] = 0\n    end\n    for j in 0..rg.size-1\n      for k in rg[j]\n        a[k] = 0\n      end\n    end\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==0}\n      break if idx1.nil?\n      a = a[0..idx1-1]\n      idx2 = a.rindex{|x| x.nil?}\n      idx2.nil? ? (rg=[0..idx1]+rg ;break) : rg = [idx2+1..idx1]+rg\n      a = a[0..idx2-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]] \n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      xrgs[y] = unite(xrgs[y],x1,x2-1)\n    end\n    for x in x1..x2-1\n      yrgs[x] = unite(yrgs[x],y1,y2-1)\n    end\n  end\n\n  xrgs.compact!\n  yrgs.compact!\n  puts xrgs.compact.flatten.map{|rng| rng.last-rng.begin+1}.inject(:+)\n  puts (xrgs+yrgs).map{|arr| arr.size}.inject(:+)*2 if r==2\n  \nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi,yi,xf,yf = [],[],[],[]\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1]==0\n          l+=1 if x==xmax-1||field[y][x+1]==0 \n          l+=1 if y==0||field[y-1][x]==0\n          l+=1 if y==ymax-1||field[y+1][x]==0\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  cov = [[]]\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        cov[y] += [x] rescue cov[y] = [x]\n      end\n      cov[y].uniq\n    end\n  end\n  puts cov.flatten.compact.size\n  puts 300 if r == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.nil? || rg.empty?\n    rg = [i..f]\n  else\n    a = []\n    for k in i..f\n      a[k] = 0\n    end\n    for j in 0..rg.size-1\n      for k in rg[j]\n        a[k] = 0\n      end\n    end\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==0}\n      break if idx1.nil?\n      a = a[0..idx1-1]\n      idx2 = a.rindex{|x| x.nil?}\n      idx2.nil? ? (rg=[0..idx1]+rg ;break) : rg = [idx2+1..idx1]+rg\n      a = a[0..idx2-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]] \n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      xrgs[y] = unite(xrgs[y],x1,x2-1)\n    end\n    for x in x1..x2-1\n      yrgs[x] = unite(yrgs[x],y1,y2-1)\n    end\n  end\n  \n  puts xrgs.compact.map{|arr| arr.map{|rng| rng.last-rng.begin+1}}.flatten.inject(:+)\n  puts (xrgs+yrgs).compact.map{|arr| arr.size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi = [] ; yi = [] ; xf = [] ; yf = []\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1].nil?)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1].nil?) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x].nil?)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x].nil?)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in y1s[i]..y2s[i]-1\n      for x in x1s[i]..x2s[i]-1\n        f[y][x] = 1\n      end\n    end\n  end\n\n  puts f.map{|arr| (arr.to_s.split(\"nil\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           for x in xmin..xmax\n             unless y<ymin || ymax<y\n               for i in 0..n-1\n                 inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n                 break if inc\n               end\n               f[x] = \"1\" if inc\n             end\n           end\n           f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  cov = [[]]\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      cov[y] = []\n      for x in x1..x2-1\n        cov[y] += [x]\n      end\n      cov[y].uniq\n    end\n  end\n  puts cov.flatten.compact.size\n  puts 300 if r == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi = [] ; yi = [] ; xf = [] ; yf = []\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[1]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1].nil?\n          l+=1 if x==xmax-1||field[y][x+1].nil? \n          l+=1 if y==0||field[y-1][x].nil?\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "$o=Array.new(10001*10001){0}\ndef a;gets.split.map(&:to_i);end\ndef m i,j;$o[i*10001+j];end\nn,r=a\nn.times{x,y,t,u=a\n(x...t).each{|i|(y...u).each{|j|$o[i*10001+j]=1}}}\np $o.count 1\np (0...10000).inject(0){|s,i|s+(0...10000).inject(0){|d,j|d+((m(i,j)==0)?0:(4-m(i-1,j)-m(i+1,j)-m(i,j-1)-m(i,j+1)))}} if r==2"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  \n  xi,yi,xf,yf = Array.new(n){gets.split(\" \").map{|j| j.to_i}}.zip}\n\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  puts s if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if n==0&&r==0\n  \n  cov = [[]]\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1      \n      (cov[y] += (x1..x2-1).to_a) rescue (cov[y] = (x1..x2-1).to_a)\n      cov[y].uniq\n    end\n  end\n  \n  puts(cov.compact.flatten.size)\n  puts(123) if r == 2\n\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n    xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n\n          for i in 0..n-1\n            inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n             break if inc\n          end\n          inc ? 1 : 0\n                         \n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    (field = field + Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          x==0 ? l+=1 : (l+=1 if field[x-1][y]==0)\n          x==xmax ? l+=1 : (l+=1 if field[x+1][y]==0) \n          y==0 ? l+=1 : (l+=1 if field[x][y-1]==0)\n          y==ymax ? l+=1 : (l+=1 if field[x][y+1]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if n==0 && r==0\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|i| i.to_i}  \n    (field += Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y] == 0)\n          l += 1 if (x==xmax || field[x+1][y] == 0)\n          l += 1 if (y==0 || field[x][y-1] == 0)\n          l += 1 if (x==ymax || field[x][y+1] == 0)\n        end\n      end\n    end\n    puts l\n  end\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field[y] += [x]\n      end\n      field[y].uniq\n    end\n  end\n  puts field.compact.flatten.size\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n\n  f = Array.new(1000){|y| Array.new(1000){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  xmax = a.tranpose[2].max\n\n  f = Array.new(100){|y| Array.new(xmax){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi = [] ; yi = [] ; xf = [] ; yf = []\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1].nil?\n          l+=1 if x==xmax-1||field[y][x+1].nil? \n          l+=1 if y==0||field[y-1][x].nil?\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.nil? || rg.empty?\n    rg = [i..f]\n  else\n    a = []\n    for k in i..f\n      a[k] = 0\n    end\n    for j in 0..rg.size-1\n      for k in rg[j]\n        a[k] = 0\n      end\n    end\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==0}\n      break if idx1.nil?\n      a = a[0..idx1-1]\n      idx2 = a.rindex{|x| x.nil?}\n      idx2.nil? ? (rg=[0..idx1]+rg ;break) : rg = [idx2+1..idx1]+rg\n      a = a[0..idx2-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  xrgs = [[]] \n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1\n      xrgs[y] = unite(xrgs[y],x1,x2-1)\n    end\n    for x in x1..x2-1\n      yrgs[x] = unite(yrgs[x],y1,y2-1)\n    end\n  end\n\n  xrgs.compact!\n  yrgs.compact!\n  puts xrgs.flatten.inject(0){|sum,rng| sum += (rng.last-rng.begin+1)}\n  puts (xrgs+yrgs).inject(0){|sum,arr| sum += arr.size}*2 if r==2\n  \nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  xmax,ymax = a.tranpose[2..3].map{|arr| arr.max}\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if n==0&&r==0\n  \n  cov = [[]]\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1      \n      (cov[y] += (x1..x2-1).to_a) rescue (cov[y] = (x1..x2-1).to_a)\n    end\n  end\n  \n  puts(cov.map{|y| y.uniq}.flatten.compact.size)\n  puts(123) if r == 2\n\nend"
  },
  {
    "language": "Ruby",
    "code": "def trsnpose(a,ymax,xmax)\n  Array.new(xmax){|i|\n    str = \"\"\n    for j in 0..ymax-1\n      str += a[j][i]\n    end\n    str\n  }\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           for x in xmin..xmax-1\n             if y>=ymin\n               for i in 0..n-1\n                 inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n                 break if inc\n               end\n               f[x] = \"1\" if inc\n             end\n           end\n           return f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+transpose(f,ymax,xmax)).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n        if y<ymin\n          Array.new(xmax){0}\n        else   \n          Array.new(xmax){|x|\n           val = 0\n\n           if x>=xmin && y>=ymin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n           if x<xmin || xmax<x || y<ymin || ymax<y\n             0\n           else\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             inc ? 1 : 0\n           end\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(4){gets.split(\" \").map{|i| i.to_i}}.transpose\n  \n  puts a.size\n  puts a.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTree\n\tdef initialize(n, l = 0, r = n-1)\n\t\t@range_min = l\n\t\t@range_max = r\n\t\t@start = 0\n\t\t@between = 0\n\t\t@end = 0\n\t\tif l == r\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(n, l, c)\n\t\t\t@right_child = self.class.new(n, c+1, r)\n\t\tend\n\tend\n\n\tattr_reader :range_min, :range_max\n\n\tdef add_start(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@start |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_start(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_start(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_end(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@end |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_end(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_end(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_between(x, y, bits)\n\t\treturn if x > y\n\n\t\tif x == @range_min && y == @range_max\n\t\t\t@between |= bits\n\t\telse\n\t\t\tforce\n\t\t\tlr = @left_child.range_max\n\t\t\t@left_child.add_between(x, lr < y ? lr : y, bits)\n\t\t\trl = @right_child.range_min\n\t\t\t@right_child.add_between(rl > x ? rl : x, y, bits)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @range_min != @range_max\n\t\t\t@left_child.take(@start, @between, @end)\n\t\t\t@right_child.take(@start, @between, @end)\n\t\tend\n\t\t@star = @between = @end = 0\n\tend\n\n\tdef take(start, between, finish)\n\t\t@start |= start\n\t\t@between |= between\n\t\t@end |= finish\n\tend\n\n\tdef net_start_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @start\n\t\t\tbits -= bits & @end\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_start_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_start_count(x)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef net_end_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @end\n\t\t\tbits -= bits & @start\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse force\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_end_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_end_count(x)\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nones = [0]\nhead_one = {}\n1000.times{\n\tones << ((ones[-1] << 1) | 1)\n\thead_one[ones[-1]] = head_one.size\n}\n\nt = Time.new\n\nloop {\n\tn, r = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\tv_st = LazySegmentTree.new(10001)\n\th_st = LazySegmentTree.new(10001)\n\n\tn.times {\n\t\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\t\tbits = ones[y2-y1] << y1\n\t\tv_st.add_start(x1, bits)\n\t\tv_st.add_between(x1+1, x2-1, bits) if x1+1 < x2\n\t\tv_st.add_end(x2, bits)\n\t\tbits = ones[x2-x1] << x1\n\t\th_st.add_start(y1, bits)\n\t\th_st.add_between(y1+1, y2-1, bits) if y1+1 < y2\n\t\th_st.add_end(y2, bits)\n\t}\n\n\tarea = 0\n\tfor i in 0..1000\n\t\tarea += v_st.net_start_count(i) * (1000-i)\n\t\tarea -= v_st.net_end_count(i) * (1000-i)\n\tend\n\tp area\n\n\tif r == 2\n\t\tlen = 0\n\t\tfor i in 0..1000\n\t\t\tlen += v_st.net_start_count(i)\n\t\t\tlen += v_st.net_end_count(i)\n\t\t\tlen += h_st.net_start_count(i)\n\t\t\tlen += h_st.net_end_count(i)\n\t\tend\n\t\tp len\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  f = Array.new(1000){|y| Array.new(1000){|x|\n    for i in 0..n-1\n      x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n      inc = (y1<=y && y<y2 && x1<=x && x<x2)\n      break if inc\n    end\n    inc ? 1 : 0\n    }\n  }\n\n  puts f.size\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n        if y<ymin\n          Array.new(xmax){0}\n        else   \n        Array.new(xmax){|x|\n           val = 0\n\n           if x>=xmin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  field = Array.new(1000)[]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field[y] += [x]\n      end\n      field[y]uniq\n    end\n  end\n  puts field.compact.flatten.size\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if n==0&&r==0\n  \n  cov = [[]]\n  \n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|s| s.to_i}\n    for y in y1..y2-1      \n      (cov[y] += (x1..x2-1).to_a) rescue (cov[y] = (x1..x2-1).to_a)\n      cov[y].uniq\n    end\n  end\n  \n  puts(cov.compact.flatten.size)\n  puts(123) if r == 2\n\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(4){|i| gets.split(\" \").map{|s| s.to_i}}\n  a = a.transpose\n  \n  puts a.size\n  puts a.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "def trsnpose(a)\n  Array.new(a[0].size){|i|\n    str = \"\"\n    for j in 0..a.size-1\n      str += a[j][i]\n    end\n    str\n  }\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           for x in xmin..xmax-1\n             if y>=ymin\n               for i in 0..n-1\n                 inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n                 break if inc\n               end\n               f[x] = \"1\" if inc\n             end\n           end\n           f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+transpose(f)).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts f.size if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n    for i in 0..n-1\n      inc = (a[1][i]<=y && y<a[3][i] && a[0][i]<=x && x<a[2][i])\n      break if inc\n    end\n    inc ? 1 : 0\n  }\n\n  puts f.size\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while str = gets do\n    num, r = str.chomp.split(\" \").map(&:to_i)\n    hash = {}\n    num.times do |n|\n        x1, y1, x2, y2 = gets.chomp.split(\" \").map(&:to_i)\n        (y1..y2 - 1).each do |y|\n            hash[y] = [] unless hash.has_key?(y)\n            (x1..x2 - 1).each do |x|\n                hash[y] << x unless hash[y].include?(x)\n            end\n        end\n    end\n    area = 0\n    hash.each do |key, val|\n        area += val.length\n    end\n    cir = 0\n    if r == 2\n        hash.each do |key, val|\n            val.each do |v|\n                cir += 1 unless val.include?(v - 1)\n                cir += 1 unless val.include?(v + 1)\n                cir += 1 unless hash.has_key?(key - 1) && hash[key - 1].include?(v)\n                cir += 1 unless hash.has_key?(key + 1) && hash[key + 1].include?(v)\n            end\n        end\n    end\n    puts area\n    puts cir if r == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n\n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n\n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        cov = false\n        for i in 0..n-1\n          cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n          break if cov\n        end\n        s += 1 if cov\n      end\n    end\n    puts s\n  end\n  \n  if r == 2\n    a = Array.new(ymax){|y|\n      Array.new(xmax){|x|\n        cov = false\n        for i in 0..n-1\n          cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n          break if cov\n        end\n        s += 1 if cov\n        cov ? 1 : 0\n      }\n    }\n         puts s\n         puts (a+a.transpose).inject(0){|sum,arr| sum+=(arr.join.split(\"0\")-[\"\"]).size}*2\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "def unite(rg,i,f)\n  if rg.empty?\n    rg = [i..f]\n  else\n    s = [rg[-1].last,f].max\n    a = Array.new(s){|j|\n      val = 1\n      if j<i || f<j\n        for k in 0..rg.size-1\n          inc = rg[k].include?(j)\n          break if inc\n        end\n        val = (inc ? 1 : 0)\n      end\n      val\n    }\n    a+=[0]\n    rg = []\n    while true\n      idx1 = a.rindex{|x| x==1}\n      break if idx.nil?\n      a = a[0..idx-1]\n      idx2 = a.rindex{|x| x==0}\n      rg = [idx2+1..idx1]+rg\n      a = a[0..idx-1]\n    end\n  end\n  rg\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  xrgs = [[]]\n  yrgs = [[]]\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = a[i]\n    for y in y1..y2\n      xrgs[y] = unite(xrgs[y],x1,x2) rescue xrgs[y] =[x1..x2]\n    end\n    for x in x1..x2\n      yrgs[x] = unite(yrgs[x],y1,y2) rescue yrgs[x] =[y1..y2]\n    end\n  end\n\n  puts xrgs.compact.map{|arr| arr.map{|rng| rng.last-rng.first+1}}.flatten.inject(:+)\n  puts (xrgs+yrgs).compact.map{|arr| arr.size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n           val = 0\n           if x>=xmin && y>=ymin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc ?\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    a = [[]]\n    for i in 0..n-1\n      for y in y1s[i]..y2s[i]-1\n        for x in x1s[i]..x2s[i]-1\n          s += 1 if a[y][x].nil?\n          a[y][x] = 1\n        end\n      end\n    end\n    puts s\n  end\n\n  if  r == 2\n    f = Array.new(ymax){|y|\n          Array.new(xmax){|x|\n            cov = false\n            for i in 0..n-1\n              cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n              break if cov\n            end\n            s += 1 if cov\n            cov ? 1 : 0\n          }\n        }\n     puts s\n     puts (f+f.transpose).inject(0){|sum,arr| sum += (arr.join.split(\"0\")-[\"\"]).size}*2\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  \n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    (field = field + Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for y in y1..y2-1\n      for x in x1..x2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1]==0)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1]==0) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x]==0)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def trsnpose(a,ymax,xmax)\n  Array.new(xmax){|i|\n    str = \"\"\n    for j in 0..ymax-1\n      str += a[j][i]\n    end\n    str\n  }\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           for x in xmin..xmax-1\n             if y>=ymin\n               for i in 0..n-1\n                 inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n                 break if inc\n               end\n               f[x] = \"1\" if inc\n             end\n           end\n           f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+transpose(f,ymax,xmax)).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100)}\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y].nil?)\n          l += 1 if (x==xmax || field[x+1][y].nil?)\n          l += 1 if (y==0 || field[x][y-1].nil?)\n          l += 1 if (y==ymax || field[x][y+1].nil?)\n        end\n      end\n    end\n    puts l\n  end\n\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    (field += Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y] == 0)\n          l += 1 if (x==xmax || field[x+1][y] == 0)\n          l += 1 if (y==0 || field[x][y-1] == 0)\n          l += 1 if (y==ymax || field[x][y+1] == 0)\n        end\n      end\n    end\n    puts l\n  end\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi,yi,xf,yf = [],[],[],[]\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n    xmax = xf[i] if xf[i]>=xf[0]\n    ymax = yf[i] if yf[i]>=yf[0]\n  end\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1].nil?\n          l+=1 if x==xmax-1||field[y][x+1].nil? \n          l+=1 if y==0||field[y-1][x].nil?\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100)}\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|i| i.to_i}  \n    for x in x1..x2\n      for y in y1..y2\n        (field[x][y] = 1 ; s+=1) if field[x][y].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax\n      for y in 0..ymax\n        if field[x][y] == 1\n          l += 1 if (x==0 || field[x-1][y] == 0)\n          l += 1 if (x==xmax || field[x+1][y] == 0)\n          l += 1 if (y==0 || field[x][y-1] == 0)\n          l += 1 if (x==ymax || field[x][y+1] == 0)\n        end\n      end\n    end\n    puts l\n  end\n\nend\n          \n  \n  "
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi = [] ; yi = [] ; xf = [] ; yf = []\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n  end\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(100){Array.new(100)}\n  \n  for i in 0..n-1\n    for y in yi[1]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1].nil?\n          l+=1 if x==xmax-1||field[y][x+1].nil? \n          l+=1 if y==0||field[y-1][x].nil?\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n\n           if x>=xmin && y>=ymin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             inc ? 1 : 0\n           else\n             0\n           end\n           \n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  \n  a = Array.new(n){gets.split(\" \").map{|j| j.to_i}}.zip\n\n  xi,yi,xf,yf = a[0],a[1],a[2],a[3]\n  xmax,ymax = xf.max,yf.max\n\n  field = Array.new(ymax){Array.new(xmax){0}}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x]==0\n      end\n    end\n  end\n  puts s\n  puts s if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "def unify(rg,i,f)\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| \n       if y<ymin\n         Array.new(xmax){0}\n       else\n         Array.new(xmax){|x|\n           val = 0\n           if x>=xmin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n           }\n           end\n         }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n  \n  field = Array.new(100){Array.new(100){0}}\n  xmax,ymax = 100,100\n  \n  s = 0\n  for i in 1..n\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}  \n    (field = field + Array.new(y2-ymax){Array.new(xmax){0}} ; ymax = y2) if y2 > ymax\n    (field.map!{|arr| arr+Array.new(x2-xmax){0}} ; xmax = x2) if x2 > xmax\n    for x in x1..x2-1\n      for y in y1..y2-1\n        (field[y][x] = 1 ; s+=1) if field[y][x] == 0\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for x in 0..xmax-1\n      for y in 0..ymax-1\n        if field[y][x] == 1\n          x==0 ? l+=1 : (l+=1 if field[y][x-1]==0)\n          x==xmax-1 ? l+=1 : (l+=1 if field[y][x+1]==0) \n          y==0 ? l+=1 : (l+=1 if field[y-1][x]==0)\n          y==ymax-1 ? l+=1 : (l+=1 if field[y+1][x]==0)\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  field = []\n\n  for i in 0..n-1\n    x1,y1,x2,y2 = gets.split(\" \").map{|j| j.to_i}\n    for y in y1..y2-1\n      for x in x1..x2-1\n        field += [x,y]\n      end\n    end\n  end\n  puts field.uniq.size\n  puts 2 if r == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax = x2s.max\n  ymax = y2s.max\n\n  s = 0\n\n  if r == 1\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        cov = false\n        for i in 0..n-1\n          cov = (x1s[i]<=x&&x<x2s[i]&&y1s[i]<=y&&y<y2s[i])\n          break if cov\n        end\n        s += 1 if cov\n      end\n    end\n    puts s\n  end\n\n  if  r == 2\n    f = Array.new(ymax){|y|\n          Array.new(xmax){|x|\n            cov = false\n            for i in 0..n-1\n              cov = (x1s[i]<=x && x<x2s[i] && y1s[i]<=y && y<y2s[i])\n              break if cov\n            end\n            s += 1 if cov\n            cov ? 1 : 0\n          }\n        }\n     puts s\n     puts (f+f.transpose).inject(0){|sum,arr| sum += (arr.join.split(\"0\")-[\"\"]).size}*2\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTree\n\tdef initialize(n, l = 0, r = n-1)\n\t\t@range_min = l\n\t\t@range_max = r\n\t\t@start = 0\n\t\t@between = 0\n\t\t@end = 0\n\t\tif l == r\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(n, l, c)\n\t\t\t@right_child = self.class.new(n, c+1, r)\n\t\tend\n\tend\n\n\tattr_reader :range_min, :range_max\n\n\tdef add_start(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@start |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_start(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_start(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_end(x, bits)\n\t\tif @range_min == @range_max\n\t\t\t@end |= bits\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.add_end(x, bits)\n\t\t\telse\n\t\t\t\t@right_child.add_end(x, bits)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef add_between(x, y, bits)\n\t\treturn if x > y\n\n\t\tif x == @range_min && y == @range_max\n\t\t\t@between |= bits\n\t\telse\n\t\t\tforce\n\t\t\tlr = @left_child.range_max\n\t\t\t@left_child.add_between(x, lr < y ? lr : y, bits)\n\t\t\trl = @right_child.range_min\n\t\t\t@right_child.add_between(rl > x ? rl : x, y, bits)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @range_min != @range_max\n\t\t\t@left_child.take(@start, @between, @end)\n\t\t\t@right_child.take(@start, @between, @end)\n\t\tend\n\t\t@star = @between = @end = 0\n\tend\n\n\tdef take(start, between, finish)\n\t\t@start |= start\n\t\t@between |= between\n\t\t@end |= finish\n\tend\n\n\tdef net_start_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @start\n\t\t\tbits -= bits & @end\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse\n\t\t\tforce\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_start_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_start_count(x)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef net_end_count(x)\n\t\tif @range_min == @range_max\n\t\t\tbits = @end\n\t\t\tbits -= bits & @start\n\t\t\tbits -= bits & @between\n\t\t\tbits.to_s(2).count(\"1\")\n\t\telse force\n\t\t\tif x <= @left_child.range_max\n\t\t\t\t@left_child.net_end_count(x)\n\t\t\telse\n\t\t\t\t@right_child.net_end_count(x)\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nones = [0]\n10000.times{\n\tones << ((ones[-1] << 1) | 1)\n}\n\nt = Time.new\n\nloop {\n\tn, r = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\tv_st = LazySegmentTree.new(10001)\n\th_st = LazySegmentTree.new(10001)\n\n\tn.times {\n\t\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\t\tbits = ones[y2-y1] << y1\n\t\tv_st.add_start(x1, bits)\n\t\tv_st.add_between(x1+1, x2-1, bits) if x1+1 < x2\n\t\tv_st.add_end(x2, bits)\n\t\tbits = ones[x2-x1] << x1\n\t\th_st.add_start(y1, bits)\n\t\th_st.add_between(y1+1, y2-1, bits) if y1+1 < y2\n\t\th_st.add_end(y2, bits)\n\t}\n\n\tarea = 0\n\tfor i in 0..10000\n\t\tarea += v_st.net_start_count(i) * (10000-i)\n\t\tarea -= v_st.net_end_count(i) * (10000-i)\n\tend\n\tp area\n\n\tif r == 2\n\t\tlen = 0\n\t\tfor i in 0..1000\n\t\t\tlen += v_st.net_start_count(i)\n\t\t\tlen += v_st.net_end_count(i)\n\t\t\tlen += h_st.net_start_count(i)\n\t\t\tlen += h_st.net_end_count(i)\n\t\tend\n\t\tp len\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "def trsnpose(a,ymax,xmax)\n  Array.new(xmax){|i|\n    str = \"\"\n    for j in 0..ymax-1\n      str += a[j][i]\n    end\n    str\n  }\nend\n\nwhile true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n           f = \"0\"*xmax\n           for x in xmin..xmax-1\n             if y>=ymin\n               for i in 0..n-1\n                 inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n                 break if inc\n               end\n               f[x] = \"1\" if inc\n             end\n           end\n           return f\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}+transpose(f,ymax,xmax).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  \n  f = Array.new(100){|y| Array.new(100){|x|\n      for i in 0..n-1\n        x1,y1,x2,y2 = a[i]\n        inc = (y1<=y && y<y2 && x1<=x && x<x2)\n        break if inc\n      end\n      inc ? 1 : 0\n    }\n  }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n\n  f = Array.new(ymax){|y| Array.new(xmax){|x|\n    for i in 0..n-1\n      (val = 1; break) if a[1][i]<=y && y<a[3][i] && a[0][i]<=x && x<a[2][i]\n      val = 0\n    end\n    val\n  }\n\n  puts f.size\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y|\n        if y<ymin\n          Array.new(xmax){0}\n        else   \n        Array.new(xmax){|x|\n           val = 0\n\n           if x>=xmin\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             val = 1 if inc\n           end\n           val\n        }\n      }\n\n  puts f.map{|arr| (arr.to_s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  a = Array.new(n){gets.split(\" \").map{|s| s.to_i}}.transpose\n  \n  xmax,ymax = a[2].max,a[3].max\n\n  f = \"0\"*(xmax*ymax)\n  \n  for i in 0..n-1\n    for y in a[1][i]..a[3][i]\n      for x in a[0][i]..a[2][i]\n        f[y*ymax+x-1] = \"1\"\n      end\n    end\n  end\n\n  puts xmax\n  puts ymax if r==2\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|i| i.to_i}\n  break if (n==0 && r==0)\n    \n  s = 0\n  xi,yi,xf,yf = [],[],[],[]\n  for i in 0..n-1\n    xi[i],yi[i],xf[i],yf[i] = gets.split(\" \").map{|j| j.to_i}\n    xmax = xf[i] if xf[i]>=xf[0]\n    ymax = yf[i] if yf[i]>=yf[0]\n  end\n\n  field = Array.new(ymax){Array.new(xmax)}\n  \n  for i in 0..n-1\n    for y in yi[i]..yf[i]-1\n      for x in xi[i]..xf[i]-1\n        (field[y][x] = 1 ; s+=1) if field[y][x].nil?\n      end\n    end\n  end\n  puts s\n  \n  if r == 2\n    l = 0\n    for y in 0..ymax-1\n      for x in 0..xmax-1\n        if field[y][x] == 1\n          l+=1 if x==0||field[y][x-1].nil?\n          l+=1 if x==xmax-1||field[y][x+1].nil? \n          l+=1 if y==0||field[y-1][x].nil?\n          l+=1 if y==ymax-1||field[y+1][x].nil?\n        end\n      end\n    end\n    puts l\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n,r = gets.split(\" \").map{|s| s.to_i}\n  break if (n==0 && r==0)\n  \n  x1s,y1s,x2s,y2s = [],[],[],[]\n\n  for i in 0..n-1\n    x1s[i],y1s[i],x2s[i],y2s[i] = gets.split(\" \").map{|s| s.to_i}\n  end\n  \n  xmin = x1s.min\n  ymin = y1s.min\n  xmax = x2s.max\n  ymax = y2s.max\n\n  f = Array.new(ymax){|y| f = \"0\"*xmax\n           unless x<xmin || xmax<x || y<ymin || ymax<y\n             for i in 0..n-1\n               inc = (y1s[i]<=y && y<y2s[i] && x1s[i]<=x && x<x2s[i])\n               break if inc\n             end\n             f[x] = \"1\" if inc\n           end\n           f\n        }\n      }\n\n  puts f.map{|s| (s.split(\"0\")-[\"\"]).map{|str| str.size}}.inject(:+)\n  puts (f+f.transpose).map{|arr| (arr.to_s.split(\"0\")-[\"\"]).size}.inject(:+)*2 if r==2\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int n, r;\n    while (readf(\"%d %d\\n\", &n, &r), n || r) {\n        int[][] F = new int[][n];\n        int X, Y;\n        bool[] x = new bool[10001],\n               y = new bool[10001];\n        foreach (i; 0 .. n) {\n            int x1, y1, x2, y2; readf(\"%d %d %d %d\\n\", &x1, &y1, &x2, &y2);\n            F[i] = [x1, y1, x2, y2];\n            x[x1] = x[x2] = y[y1] = y[y2] = true;\n            X = max(X, x2);\n            Y = max(Y, y2);\n        }\n        int area = 0;\n        int[] d = new int[10001];\n        foreach (i; 0 .. Y + 1) {\n            if (y[i]) {\n                d[] = 0;\n                foreach (j; 0 .. n) {\n                    if (F[j][1] <= i && i < F[j][3]) {\n                        d[F[j][0]]++;\n                        d[F[j][2]]--;\n                    }\n                }\n            }\n            int c = 0;\n            foreach (j; 0 .. X + 1) {\n                if (d[j]) {\n                    c += d[j];\n                }\n                if (c) area++;\n            }\n        }\n        area.writeln;\n        if (r == 2) {\n            int cir = 0;\n            int c = 0;\n            d[] = 0;\n            foreach (i; 0 .. Y + 1) {\n                if (y[i]) {\n                    d[] = 0;\n                    foreach (j; 0 .. n) {\n                        if (F[j][1] <= i && i < F[j][3]) {\n                            d[F[j][0]]++;\n                            d[F[j][2]]--;\n                        }\n                    }\n                }\n                foreach (j; 0 .. X + 1) {\n                    if (d[j]) {\n                        if (c == 0) cir++;\n                        c += d[j];\n                        if (c == 0) cir++;\n                    }\n                }\n            }\n            d[] = 0;\n            foreach (i; 0 .. X + 1) {\n                if (x[i]) {\n                    d[] = 0;\n                    foreach (j; 0 .. n) {\n                        if (F[j][0] <= i && i < F[j][2]) {\n                            d[F[j][1]]++;\n                            d[F[j][3]]--;\n                        }\n                    }\n                }\n                foreach (j; 0 .. Y + 1) {\n                    if (d[j]) {\n                        if (c == 0) cir++;\n                        c += d[j];\n                        if (c == 0) cir++;\n                    }\n                }\n            }\n            cir.writeln;\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int n, r;\n    while (readf(\"%d %d\\n\", &n, &r), n || r) {\n        int[][] F = new int[][n];\n        int X, Y;\n        foreach (i; 0 .. n) {\n            int x1, y1, x2, y2;\n            readf(\"%d %d %d %d\\n\", &x1, &y1, &x2, &y2);\n            F[i] = [x1, y1, x2, y2];\n            X = max(X, x2);\n            Y = max(Y, y2);\n        }\n        int area = 0;\n        int[] d = new int[10001];\n        foreach (i; 0 .. Y + 1) {\n            foreach (j; 0 .. n) {\n                if (F[j][1] <= i && i < F[j][3]) {\n                    d[F[j][0]]++;\n                    d[F[j][2]]--;\n                }\n            }\n            int c = 0;\n            foreach (j; 0 .. X + 1) {\n                if (d[j] != 0) {\n                    c += d[j];\n                    d[j] = 0;\n                }\n                if (c) area++;\n            }\n        }\n        area.writeln;\n        if (r == 2) {\n            int cir = 0;\n            int c = 0;\n            foreach (i; 0 .. Y + 1) {\n                foreach (j; 0 .. n) {\n                    if (F[j][1] <= i && i < F[j][3]) {\n                        d[F[j][0]]++;\n                        d[F[j][2]]--;\n                    }\n                }\n                foreach (j; 0 .. X + 1) {\n                    if (d[j] != 0) {\n                        if (c == 0) cir++;\n                        c += d[j];\n                        d[j] = 0;\n                        if (c == 0) cir++;\n                    }\n                }\n            }\n            foreach (i; 0 .. X + 1) {\n                foreach (j; 0 .. n) {\n                    if (F[j][0] <= i && i < F[j][2]) {\n                        d[F[j][1]]++;\n                        d[F[j][3]]--;\n                    }\n                }\n                foreach (j; 0 .. Y + 1) {\n                    if (d[j] != 0) {\n                        if (c == 0) cir++;\n                        c += d[j];\n                        d[j] = 0;\n                        if (c == 0) cir++;\n                    }\n                }\n            }\n            cir.writeln;\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int n, r;\n    while (readf(\"%d %d\\n\", &n, &r), n || r) {\n        int X, Y;\n        bool[] ya = new bool[10001],\n               yb = new bool[10001],\n               xa = new bool[10001],\n               xb = new bool[10001];\n        int[][] ys1 = new int[][10001],\n                ys2 = new int[][10001],\n                xs1 = new int[][10001],\n                xs2 = new int[][10001];\n        foreach (i; 0 .. n) {\n            int x1, y1, x2, y2; readf(\"%d %d %d %d\\n\", &x1, &y1, &x2, &y2);\n            xa[x1] = ya[y1] = true;\n            xb[x2] = yb[y2] = true;\n            xs1[y1] ~= [x1, x2];\n            xs2[y2] ~= [x1, x2];\n            ys1[x1] ~= [y1, y2];\n            ys2[x2] ~= [y1, y2];\n            X = max(X, x2);\n            Y = max(Y, y2);\n        }\n        int area = 0;\n        int[] d = new int[10001];\n        foreach (i; 0 .. Y + 1) {\n            if (ya[i]) {\n                for (int j = 0; j < xs1[i].length; j += 2) {\n                    d[xs1[i][j]]++;\n                    d[xs1[i][j + 1]]--;\n                }\n            } \n            if (yb[i]) {\n                for (int j = 0; j < xs2[i].length; j += 2) {\n                    d[xs2[i][j]]--;\n                    d[xs2[i][j + 1]]++;\n                }\n            }\n            int c = 0;\n            foreach (j; 0 .. X + 1) {\n                if (d[j]) {\n                    c += d[j];\n                }\n                if (c) area++;\n            }\n        }\n        area.writeln;\n        if (r == 2) {\n            int cir = 0;\n            int c = 0;\n            d[] = 0;\n            foreach (i; 0 .. Y + 1) {\n                if (ya[i]) {\n                    for (int j = 0; j < xs1[i].length; j += 2) {\n                        d[xs1[i][j]]++;\n                        d[xs1[i][j + 1]]--;\n                    }\n                }\n                if (yb[i]) {\n                    for (int j = 0; j < xs2[i].length; j += 2) {\n                        d[xs2[i][j]]--;\n                        d[xs2[i][j + 1]]++;\n                    }\n                }\n                foreach (j; 0 .. X + 1) {\n                    if (d[j]) {\n                        if (c == 0) cir++;\n                        c += d[j];\n                        if (c == 0) cir++;\n                    }\n                }\n            }\n            d[] = 0;\n            foreach (i; 0 .. X + 1) {\n                if (xa[i]) {\n                    for (int j = 0; j < ys1[i].length; j += 2) {\n                        d[ys1[i][j]]++;\n                        d[ys1[i][j + 1]]--;\n                    }\n                } \n                if (xb[i]) {\n                    for (int j = 0; j < ys2[i].length; j += 2) {\n                        d[ys2[i][j]]--;\n                        d[ys2[i][j + 1]]++;\n                    }\n                }\n                foreach (j; 0 .. Y + 1) {\n                    if (d[j]) {\n                        if (c == 0) cir++;\n                        c += d[j];\n                        if (c == 0) cir++;\n                    }\n                }\n            }\n            cir.writeln;\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport csv\n\narea = np.zeros([10002,10002])\n\nwhile (line=raw_input()):\n\tn, r = map(int, line.split(' '))\n\n\tfor i in xrange(n):\n\t\tline = raw_input()\n\t\tdata = map(int, line.split(' '))\n\t\tarea[data[0]:data[2]+1,data[1]:data[3]+1] = 1\n\t\t\n\tmenseki = len(np.nonzero(area)[0])\n\tprint '{}\\n'.format(menseki)\n\n\tif r == 2:\n\t\ttate = len(np.nonzero(area[:-1,:] - area[1:,:])[0])\n\t\ttate += len(np.nonzero(area[:,:-1] - area[:,1:])[0])\n\t\tprint '{}\\n'.format(tate)"
  },
  {
    "language": "Python",
    "code": "from operator import sub\n\nwhile True:\n    n, r = map(int, input().split())\n    if not n:\n        break\n\n    sheets = sorted(tuple(map(int, input().split())) for _ in range(n))\n    max_y = max(p[3] for p in sheets)\n\n    table_c = [0] * (max_y + 1)\n    table_r = [0] * max_y\n    table_e = 0\n\n    for x1, y1, x2, y2 in sheets:\n        for y in range(y1, y2):\n            rx = table_r[y]\n            if rx < x1 or not rx:\n                table_c[y] += x2 - x1\n                table_r[y] = x2\n                table_e += 2\n            elif rx < x2:\n                table_c[y] += x2 - rx\n                table_r[y] = x2\n\n    print(sum(table_c))\n    if r == 2:\n        print(sum(map(abs, map(sub, table_c, [0] + table_c))) + table_e)"
  },
  {
    "language": "Python",
    "code": "def main():\n  while True:\n    n, r = map(int, input().split())\n    if n == 0:\n      break\n    plst = []\n    minx = miny = 20000\n    maxx = maxy = 0\n    for _ in range(n):\n      x1, y1, x2, y2 = map(int, input().split())\n      minx = min(minx, x1)\n      miny = min(miny, y1)\n      maxx = max(maxx, x2)\n      maxy = max(maxy, y2)\n      plst.append((x1, y1, x2, y2))\n    mp = [[0] * (maxx + 5) for _ in range(maxy + 5)]\n    for x1, y1, x2, y2 in plst:\n      mp[y1 + 1][x1 + 1] += 1\n      mp[y1 + 1][x2 + 1] -= 1\n      mp[y2 + 1][x1 + 1] -= 1\n      mp[y2 + 1][x2 + 1] += 1\n  \n    for line in mp:\n      acc = 0\n      for x in range(maxx + 5):\n        acc += line[x]\n        line[x] = acc\n    for x in range(maxx + 5):\n      acc = 0\n      for y in range(maxy + 5):\n        acc += mp[y][x]\n        mp[y][x] = bool(acc)\n    \n    if r == 1:\n      ans = 0\n      for line in mp:\n        ans += sum(line)\n      print(ans)\n    else:\n      ans1 = ans2 = 0\n      for y in range(1, maxy + 4):\n        for x in range(1, maxx + 4):\n          if mp[y][x]:\n            ans1 += 1\n            ans2 += (4 - mp[y + 1][x] - mp[y - 1][x] - mp[y][x + 1] - mp[y][x - 1])\n      print(ans1, ans2,sep=\"\\n\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "a=3"
  },
  {
    "language": "Python",
    "code": "import csv"
  },
  {
    "language": "Python",
    "code": "while True:\n    n, r = map(int, input().split())\n    if not n:\n        break\n\n    sheets = sorted(tuple(map(int, input().split())) for _ in range(n))\n\n    table_c = [0] * 10001\n    table_r = [0] * 10001\n    table_e = 0\n\n    for x1, y1, x2, y2 in sheets:\n        for y in range(y1, y2):\n            rx = table_r[y]\n            if rx < x1 or not rx:\n                table_c[y] += x2 - x1\n                table_r[y] = x2\n                table_e += 2\n            elif rx < x2:\n                table_c[y] += x2 - rx\n                table_r[y] = x2\n\n    print(sum(table_c))\n    if r == 1:\n        continue\n\n    around = 0\n    prev_w = 0\n    for w in table_c:\n        around += abs(w - prev_w) + table_e\n        prev_w = w\n    around += prev_w\n\n    print(around)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nfield = []\nfor i in range(99):\n\tline = []\n\tfor j in range(99):\n\t\tline.append(0)\n\tfield.append(line)\n\nwhile True:\n\tn, r = map(int, raw_input().split())\n\tif n == 0:\n\t\tbreak\n\telse:\n\t\tfor _ in range(n):\n\t\t\tdata = map(int, raw_input().split())\n\t\t\tx_start = data[0]\n\t\t\ty_start = data[1]\n\t\t\tx_end   = data[2]\n\t\t\ty_end   = data[3]\n\t\t\tfor i in range(x_start, x_end):\n\t\t\t\tfor j in range(y_start, y_end):\n\t\t\t\t\tfield[i][j] = 1\n\t\ts = 0\n\t\tfor i in range(len(field)):\n\t\t\ts += sum(field[i])\n\t\tif r == 1:\n\t\t\tprint(s)"
  },
  {
    "language": "Python",
    "code": "while True:\n    n, r = map(int, input().split())\n    if not n:\n        break\n\n    sheets = sorted(tuple(map(int, input().split())) for _ in range(n))\n\n    table_c = [0] * 10000\n    table_r = [0] * 10000\n    table_e = 0\n\n    for x1, y1, x2, y2 in sheets:\n        for y in range(y1, y2):\n            rx = table_r[y]\n            if rx < x1 or not rx:\n                table_c[y] += x2 - x1\n                table_r[y] = x2\n                table_e += 2\n            elif rx < x2:\n                table_c[y] += x2 - rx\n                table_r[y] = x2\n\n    print(sum(table_c))\n    if r == 1:\n        continue\n\n    around = 0\n    prev_w = 0\n    for w in table_c:\n        around += abs(w - prev_w) + table_e\n        prev_w = w\n    around += prev_w\n\n    print(around)"
  },
  {
    "language": "Python",
    "code": "from numpy import *"
  },
  {
    "language": "Python",
    "code": "from itertools import chain\n\n\nmax_size = 10002\nwhile 1:\n  n, r = (int(i) for i in input().strip().split())\n  if n == r == 0:\n    break\n  flag = False if r == 2 else True\n  sheets = dict()\n  max_size = 0\n\n  for i in range(n):\n    points = tuple(int(i) + 1 for i in input().strip().split())\n    max_size = max(max_size, max(points))\n    sheets[points[0]] = tuple(chain(sheets.get(points[0], ()), ((points[1], 1), (points[3], -1))))\n    sheets[points[2]] = tuple(chain(sheets.get(points[2], ()), ((points[3], 1),( points[1], -1))))\n  max_size += 2\n\n  size, perimeter = 0, 0\n  # dp[0] is left, dp[1] is now vertical line\n  dp0, dp1 = dict(), dict()\n\n  for x in range(0, max_size):\n\n    # put value to each point\n    for i in range(0, len(sheets.get(x, ()))):\n      pos, val = sheets[x][i]\n      dp1[pos] = val + dp1.get(pos, 0)\n\n    # paint '1' to left line, and '-1' to right line\n    for y in range(1, max_size):\n      dp1[y] = dp1.get(y, 0) + dp1.get(y - 1, 0)\n\n    # merge `left' and `now'\n    for y in range(1, max_size):\n      dp1[y] = dp1.get(y, 0) + dp0.get(y, 0)\n\n    # check and add \n    for y in range(1, max_size):\n      # if `now' or `left' equal zero, and another more than zero.\n      up = (dp0.get(y, 0) == 0 and dp1.get(y, 0) > 0) \\\n          or (dp0.get(y, 0) > 0 and dp1.get(y, 0) == 0)\n      # if `now' or `under' equal zero, and another more than zero.\n      left = (dp1.get(y - 1, 0) == 0 and dp1.get(y, 0) > 0) \\\n          or (dp1.get(y - 1, 0) > 0 and dp1.get(y, 0) == 0)\n      # if `now' is more than zero.\n      flag = dp1.get(y, 0) > 0\n\n      perimeter += up + left\n      size += flag\n\n    dp0, dp1 = dp1, dict()\n\n  print(size)\n  if r == 2:\n    print(perimeter)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport csv\n\nwhile 1:\n    line=raw_input()\n    n, r = map(int, line.split(' '))\n    \n    if n == 0 and r == 0:\n        break\n\n    data = []\n    for i in xrange(n):\n        line = raw_input()\n        data.append(map(int, line.split(' ')))\n    \n    data = np.array(data)\n    X = np.max(data[:,2])\n    Y = np.max(data[:,3])\n    \n    area = np.zeros([X,Y])\n    \n    for d in data:\n        area[d[0]:d[2],d[1]:d[3]] = 1\n        \n    menseki = len(np.nonzero(area)[0])\n    print '{}'.format(menseki)\n    \n    area2 = np.zeros([X+2,Y+2])\n    area2[1:-1,1:-1] = area\n\n    if r == 2:\n        tate = len(np.nonzero(area2[:-1,:] - area2[1:,:])[0])\n        tate += len(np.nonzero(area2[:,:-1] - area2[:,1:])[0])\n        print '{}'.format(tate)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport csv\n\narea = np.zeros([10002,10002])\n\nfw = open('output.txt', 'w')\n\nwith open('input.txt') as f:\n\tdata = [line for line in csv.reader(f, delimiter=' ')]\nn, r = data[0]\nfor i in range(1, n+1):\n\tarea[data[i][0]:data[i][2]+1,data[i][1]:data[i][3]+1] = 1\n\t\nmenseki = len(np.nonzero(area)[0])\nfw.write('{}\\n'.format(menseki))\n\nif r == 2:\n\ttate = len(np.nonzero(area[:-1,:] - area[1:,:])[0])\n\ttate += len(np.nonzero(area[:,:-1] - area[:,1:])[0])\n\tfw.write('{}\\n'.format(tate))"
  },
  {
    "language": "Python",
    "code": "\n\nfrom itertools import chain\n\nwith 0 as efafe:\n  max_size = 10002\n  while 1:\n    n, r = (int(i) for i in input().strip().split())\n    if n == r == 0:\n      break\n    flag = False if r == 2 else True\n    sheets = dict()\n    max_size = 0\n\n    for i in range(n):\n      points = tuple(int(i) + 1 for i in input().strip().split())\n      max_size = max(max_size, max(points))\n      sheets[points[0]] = tuple(chain(sheets.get(points[0], ()), ((points[1], 1), (points[3], -1))))\n      sheets[points[2]] = tuple(chain(sheets.get(points[2], ()), ((points[3], 1),( points[1], -1))))\n    max_size += 2\n\n    size, perimeter = 0, 0\n    # dp[0] is left, dp[1] is now vertical line\n    dp0, dp1 = dict(), dict()\n\n    for x in range(0, max_size):\n\n      # put value to each point\n      for i in range(0, len(sheets.get(x, ()))):\n        pos, val = sheets[x][i]\n        dp1[pos] = val + dp1.get(pos, 0)\n\n      # paint '1' to left line, and '-1' to right line\n      for y in range(1, max_size):\n        dp1[y] = dp1.get(y, 0) + dp1.get(y - 1, 0)\n\n      # merge `left' and `now'\n      for y in range(1, max_size):\n        dp1[y] = dp1.get(y, 0) + dp0.get(y, 0)\n\n      # check and add \n      for y in range(1, max_size):\n        # if `now' or `left' equal zero, and another more than zero.\n        up = (dp0.get(y, 0) == 0 and dp1.get(y, 0) > 0) \\\n            or (dp0.get(y, 0) > 0 and dp1.get(y, 0) == 0)\n        # if `now' or `under' equal zero, and another more than zero.\n        left = (dp1.get(y - 1, 0) == 0 and dp1.get(y, 0) > 0) \\\n            or (dp1.get(y - 1, 0) > 0 and dp1.get(y, 0) == 0)\n        # if `now' is more than zero.\n        flag = dp1.get(y, 0) > 0\n\n        perimeter += up + left\n        size += flag\n\n      dp0, dp1 = dp1, dict()\n\n    print(size)\n    if r == 2:\n      print(perimeter)"
  },
  {
    "language": "Python",
    "code": "import numpy as np"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport csv\n\nwhile 1:\n\tline=raw_input()\n\tn, r = map(int, line.split(' '))\n\t\n\tif n == 0:\n\t\tbreak\n\n\tdata = []\n\tfor i in xrange(n):\n\t\tline = raw_input()\n\t\tdata.append(map(int, line.split(' ')))\n\t\n\tdata = np.array(data)\n\tX = np.max(data[:,2])\n\tY = np.max(data[:,3])\n\t\n\tarea = np.zeros([X,Y])\n\t\n\tfor d in data:\n\t\tarea[d[0]:d[2],d[1]:d[3]] = 1\n\t\t\n\tmenseki = len(np.nonzero(area)[0])\n\tprint '{}\\n'.format(menseki)\n\t\n\tarea2 = np.zeros([X+2,Y+2])\n\tarea2[1:-1,1:-1] = area\n\n\tif r == 2:\n\t\ttate = len(np.nonzero(area2[:-1,:] - area2[1:,:])[0])\n\t\ttate += len(np.nonzero(area2[:,:-1] - area2[:,1:])[0])\n\t\tprint '{}\\n'.format(tate)"
  },
  {
    "language": "Python",
    "code": "import numpy\nimport csv\n\nwhile 1:\n\tline=raw_input()\n\tn, r = map(int, line.split(' '))\n\t\n\tif n == 0 and r == 0:\n\t\tbreak\n\n\tdata = []\n\tfor i in xrange(n):\n\t\tline = raw_input()\n\t\tdata.append(map(int, line.split(' ')))\n\t\n\tX = max(map(lambda x:x[2],data))\n\tY = max(map(lambda x:x[3],data))\n\t\n\tarea = [[0 for x in xrange(X+2)] for y in xrange(Y+2)]\n\t\n\tif r == 2:\n\t\tarea1 = [[0 for x in xrange(X+2)] for y in xrange(Y+2)]\n\t\tarea2 = [[0 for x in xrange(X+2)] for y in xrange(Y+2)]\n\t\n\tfor d in data:\n\t\tfor y in xrange(d[1]+1, d[3]+1):\n\t\t\tfor x in xrange(d[0]+1,d[2]+1):\n\t\t\t\tarea[y][x] = 1\n\t\t\t\tif r == 2:\n\t\t\t\t\tarea1[y][x+1] = 1\n\t\t\t\t\tarea2[y+1][x] = 1\n\t\t\t\t\n\tmenseki = 0\n\tfor line in area:\n\t\tmenseki += sum(line)\n\tprint '{}'.format(menseki)\n\t\n\tif r == 2:\n\t\tnagasa = 0\n\t\tfor a, (a1, a2) in zip(area, zip(area1, area2)):\n\t\t\tnagasa += sum([abs(b-b1)+abs(b-b2) for b, (b1, b2) in zip(a, zip(a1,a2))])\n\t\tprint '{}'.format(nagasa)"
  },
  {
    "language": "Python",
    "code": "while True:\n    n, r = map(int, input().split())\n    if not n:\n        break\n\n    sheets = sorted(tuple(map(int, input().split())) for _ in range(n))\n    table = [[0, 0, 0] for _ in range(10001)]\n\n    for x1, y1, x2, y2 in sheets:\n        for y in range(y1, y2):\n            t = table[y]\n            rx = t[1]\n            if not rx or rx < x1:\n                t[0] += x2 - x1\n                t[1] = x2\n                t[2] += 2\n            elif rx < x2:\n                t[0] += x2 - rx\n                t[1] = x2\n\n    print(sum(t[0] for t in table))\n    if r == 1:\n        continue\n\n    around = 0\n    prev_w = 0\n    for y, (w, rx, e) in enumerate(table):\n        around += abs(w - prev_w) + (e if w else 0)\n        prev_w = w\n    around += prev_w\n\n    print(around)"
  },
  {
    "language": "Python",
    "code": "max_size = 10002\nwhile 1:\n  n, r = (int(i) for i in input().strip().split())\n  if n == r == 0:\n    break\n  flag = False if r == 2 else True\n  sheets = dict()\n  max_size = 0\n\n  for i in range(n):\n    points = tuple(int(i) + 1 for i in input().strip().split())\n    max_size = max(max_size, max(points))\n    sheets[points[0]] = tuple(chain(sheets.get(points[0], ()), ((points[1], 1), (points[3], -1))))\n    sheets[points[2]] = tuple(chain(sheets.get(points[2], ()), ((points[3], 1),( points[1], -1))))\n  max_size += 2\n\n  size, perimeter = 0, 0\n  # dp[0] is left, dp[1] is now vertical line\n  dp0, dp1 = dict(), dict()\n\n  for x in range(0, max_size):\n\n    # put value to each point\n    for i in range(0, len(sheets.get(x, ()))):\n      pos, val = sheets[x][i]\n      dp1[pos] = val + dp1.get(pos, 0)\n\n    # paint '1' to left line, and '-1' to right line\n    for y in range(1, max_size):\n      dp1[y] = dp1.get(y, 0) + dp1.get(y - 1, 0)\n\n    # merge `left' and `now'\n    for y in range(1, max_size):\n      dp1[y] = dp1.get(y, 0) + dp0.get(y, 0)\n\n    # check and add \n    for y in range(1, max_size):\n      # if `now' or `left' equal zero, and another more than zero.\n      up = (dp0.get(y, 0) == 0 and dp1.get(y, 0) > 0) \\\n          or (dp0.get(y, 0) > 0 and dp1.get(y, 0) == 0)\n      # if `now' or `under' equal zero, and another more than zero.\n      left = (dp1.get(y - 1, 0) == 0 and dp1.get(y, 0) > 0) \\\n          or (dp1.get(y - 1, 0) > 0 and dp1.get(y, 0) == 0)\n      # if `now' is more than zero.\n      flag = dp1.get(y, 0) > 0\n\n      perimeter += up + left\n      size += flag\n\n    dp0, dp1 = dp1, dict()\n\n  print(size)\n  if r == 2:\n    print(perimeter)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n\ndef readints(line):\n    return map(int, line.split())\n\n\ndef mark(d, p):\n    m = d.get(p, 0)\n    d[p] = m + 1\n\ndef chunker(f):\n    while True:\n        line = f.readline()\n        n, r = readints(line)\n        if n == 0 and r == 0:\n            raise StopIteration\n        tiles = set()\n        v_test = set()\n        h_test = set()\n        for i in range(n): \n            line = f.readline()\n            lbx, lby, rtx, rty = readints(line)\n\n            w = rtx - lbx \n            h = rty - lby\n            for x in range(lbx, rtx): \n                for y in range(lby, rty): \n                    tiles.add((x,y))\n            for x in range(lbx-1, rtx): \n                v_test.add((x, rty-1))\n                v_test.add((x, lby-1))\n            for y in range(lby-1, rty): \n                h_test.add((lbx-1, y))\n                h_test.add((rtx-1, y))\n\n                            \n        area = len(tiles)\n        if r == 1:\n            yield area,\n        elif r == 2:\n            edge = 0\n            for x, y in v_test:\n                p = x, y\n                q = x, y+1\n                if p in tiles and q not in tiles or p not in tiles and q in tiles:\n                    edge += 1\n            for x, y in h_test:\n                p = x, y\n                q = x+1, y\n                if p in tiles and q not in tiles or p not in tiles and q in tiles:\n                    edge += 1\n\n            yield area, edge\n\nimport sys\n\nfor ans in chunker(sys.stdin):\n    if len(ans) == 1:\n        print ans[0]\n    elif len(ans) == 2:\n        print ans[0]\n        print ans[1]\n    else:\n        pass"
  },
  {
    "language": "Python",
    "code": "print '3'"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport csv\n\nwhile 1:\n    line=raw_input()\n    n, r = map(int, line.split(' '))\n    \n    if n == 0:\n        break\n\n    data = []\n    for i in xrange(n):\n        line = raw_input()\n        data.append(map(int, line.split(' ')))\n    \n    data = np.array(data)\n    X = np.max(data[:,2])\n    Y = np.max(data[:,3])\n    \n    area = np.zeros([X,Y])\n    \n    for d in data:\n        area[d[0]:d[2],d[1]:d[3]] = 1\n        \n    menseki = len(np.nonzero(area)[0])\n    print '{}\\n'.format(menseki)\n    \n    area2 = np.zeros([X+2,Y+2])\n    area2[1:-1,1:-1] = area\n\n    if r == 2:\n        tate = len(np.nonzero(area2[:-1,:] - area2[1:,:])[0])\n        tate += len(np.nonzero(area2[:,:-1] - area2[:,1:])[0])\n        print '{}\\n'.format(tate)"
  },
  {
    "language": "Python",
    "code": "while True:\n    n, r = map(int, input().split())\n    if not n:\n        break\n\n    sheets = sorted(tuple(map(int, input().split())) for _ in range(n))\n    max_y = max(p[3] for p in sheets)\n\n    table_c = [0] * max_y\n    table_r = [0] * max_y\n    table_e = 0\n\n    for x1, y1, x2, y2 in sheets:\n        for y in range(y1, y2):\n            rx = table_r[y]\n            if rx < x1 or not rx:\n                table_c[y] += x2 - x1\n                table_r[y] = x2\n                table_e += 2\n            elif rx < x2:\n                table_c[y] += x2 - rx\n                table_r[y] = x2\n\n    print(sum(table_c))\n    if r == 1:\n        continue\n\n    around = table_e\n    prev_w = 0\n    for w in table_c:\n        around += abs(w - prev_w)\n        prev_w = w\n    around += prev_w\n\n    print(around)"
  },
  {
    "language": "Python",
    "code": "while True:\n    n, r = map(int, input().split())\n    if not n:\n        break\n\n    sheets = sorted(tuple(map(int, input().split())) for _ in range(n))\n\n    table_c = [0] * 10001\n    table_r = [0] * 10001\n    table_e = [0] * 10001\n\n    for x1, y1, x2, y2 in sheets:\n        for y in range(y1, y2):\n            rx = table_r[y]\n            if not rx or rx < x1:\n                table_c[y] += x2 - x1\n                table_r[y] = x2\n                table_e[y] += 2\n            elif rx < x2:\n                table_c[y] += x2 - rx\n                table_r[y] = x2\n\n    print(sum(table_c))\n    if r == 1:\n        continue\n\n    around = 0\n    prev_w = 0\n    for y, w in enumerate(table_c):\n        around += abs(w - prev_w) + (table_e[y] if w else 0)\n        prev_w = w\n    around += prev_w\n\n    print(around)"
  },
  {
    "language": "Python",
    "code": "from itertools import chain\n\n\nmax_size = 10002\nwhile 1:\n  n, r = (int(i) for i in input().strip().split())\n  if n == r == 0:\n    break\n  flag = False if r == 2 else True\n  sheets = dict()\n  max_size = 0\n\n  for i in range(n):\n    points = tuple(int(i) + 1 for i in input().strip().split())\n    max_size = max(max_size, max(points))\n    sheets[points[0]] = tuple(chain(sheets.get(points[0], ()), ((points[1], 1), (points[3], -1))))\n    sheets[points[2]] = tuple(chain(sheets.get(points[2], ()), ((points[3], 1),( points[1], -1))))\n  max_size += 2\n\n  size, perimeter = 0, 0\n  # dp[0] is left, dp[1] is now vertical line\n  dp = [dict(), dict()]\n\n  for x in range(0, max_size):\n    dp[1] = dict()\n\n    # put value to each point\n    for i in range(0, len(sheets.get(x, ()))):\n      pos, val = sheets[x][i]\n      dp[1][pos] = val + dp[1].get(pos, 0)\n\n    # paint '1' to left line, and '-1' to right line\n    for y in range(1, max_size):\n      dp[1][y] = dp[1].get(y, 0) + dp[1].get(y - 1, 0)\n\n    # merge `left' and `now'\n    for y in range(1, max_size):\n      dp[1][y] = dp[1].get(y, 0) + dp[0].get(y, 0)\n\n    # check and add \n    for y in range(1, max_size):\n      # if `now' or `left' equal zero, and another more than zero.\n      up = (dp[0].get(y, 0) == 0 and dp[1].get(y, 0) > 0) \\\n          or (dp[0].get(y, 0) > 0 and dp[1].get(y, 0) == 0)\n      # if `now' or `under' equal zero, and another more than zero.\n      left = (dp[1].get(y - 1, 0) == 0 and dp[1].get(y, 0) > 0) \\\n          or (dp[1].get(y - 1, 0) > 0 and dp[1].get(y, 0) == 0)\n      # if `now' is more than zero.\n      flag = dp[1].get(y, 0) > 0\n\n      perimeter += up + left\n      size += flag\n\n    dp = [dp[1], dp[0]]\n\n  print(size)\n  if r == 2:\n    print(perimeter)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport csv\n\nwhile 1:\n    line=raw_input()\n    n, r = map(int, line.split(' '))\n    \n    if n == 0:\n        break\n\n    data = []\n    for i in xrange(n):\n        line = raw_input()\n        data.append(map(int, line.split(' ')))\n    \n    data = np.array(data)\n    X = np.max(data[:,2])\n    Y = np.max(data[:,3])\n    \n    area = np.zeros([X,Y])\n    \n    for d in data:\n        area[d[0]:d[2],d[1]:d[3]] = 1\n        \n    menseki = len(np.nonzero(area)[0])\n    print '{}'.format(menseki)\n    \n    area2 = np.zeros([X+2,Y+2])\n    area2[1:-1,1:-1] = area\n\n    if r == 2:\n        tate = len(np.nonzero(area2[:-1,:] - area2[1:,:])[0])\n        tate += len(np.nonzero(area2[:,:-1] - area2[:,1:])[0])\n        print '{}'.format(tate)"
  },
  {
    "language": "Python",
    "code": "while True:\n    n, r = map(int, input().split())\n    if not n:\n        break\n\n    sheets = sorted(tuple(map(int, input().split())) for _ in range(n))\n\n    table_c = [0] * 10001\n    table_r = [0] * 10001\n    table_e = [0] * 10001\n\n    for x1, y1, x2, y2 in sheets:\n        for y in range(y1, y2):\n            rx = table_r[y]\n            if rx < x1 or not rx:\n                table_c[y] += x2 - x1\n                table_r[y] = x2\n                table_e[y] += 2\n            elif rx < x2:\n                table_c[y] += x2 - rx\n                table_r[y] = x2\n\n    print(sum(table_c))\n    if r == 1:\n        continue\n\n    around = 0\n    prev_w = 0\n    for y, w in enumerate(table_c):\n        around += abs(w - prev_w) + (table_e[y] if w else 0)\n        prev_w = w\n    around += prev_w\n\n    print(around)"
  },
  {
    "language": "Python",
    "code": "import csv\n\nwhile 1:\n\tline=raw_input()\n\tn, r = map(int, line.split(' '))\n\t\n\tif n == 0 and r == 0:\n\t\tbreak\n\n\tdata = []\n\tfor i in xrange(n):\n\t\tline = raw_input()\n\t\tdata.append(map(int, line.split(' ')))\n\t\n\tX = max(map(lambda x:x[2],data))\n\tY = max(map(lambda x:x[3],data))\n\t\n\tarea = [[0 for x in xrange(X+2)] for y in xrange(Y+2)]\n\t\n\tif r == 2:\n\t\tarea1 = [[0 for x in xrange(X+2)] for y in xrange(Y+2)]\n\t\tarea2 = [[0 for x in xrange(X+2)] for y in xrange(Y+2)]\n\t\n\tfor d in data:\n\t\tfor y in xrange(d[1]+1, d[3]+1):\n\t\t\tfor x in xrange(d[0]+1,d[2]+1):\n\t\t\t\tarea[y][x] = 1\n\t\t\t\tif r == 2:\n\t\t\t\t\tarea1[y][x+1] = 1\n\t\t\t\t\tarea2[y+1][x] = 1\n\t\t\t\t\n\tmenseki = 0\n\tfor line in area:\n\t\tmenseki += sum(line)\n\tprint '{}'.format(menseki)\n\t\n\tif r == 2:\n\t\tnagasa = 0\n\t\tfor a, (a1, a2) in zip(area, zip(area1, area2)):\n\t\t\tnagasa += sum([abs(b-b1)+abs(b-b2) for b, (b1, b2) in zip(a, zip(a1,a2))])\n\t\tprint '{}'.format(nagasa)\n\t\"\"\"\n\tarea2 = np.zeros([X+2,Y+2])\n\tarea2[1:-1,1:-1] = area\n\n\tif r == 2:\n\t\ttate = len(np.nonzero(area2[:-1,:] - area2[1:,:])[0])\n\t\ttate += len(np.nonzero(area2[:,:-1] - area2[:,1:])[0])\n\t\tprint '{}'.format(tate)\n\t\"\"\""
  },
  {
    "language": "Python",
    "code": "class All_Column:\n\tdef __init__(self, rec_num):\n\t\tself.rec_num = rec_num\n\t\tself.x_stack = []\n\t\tself.y_stack = [0 for i in range(10002)]\n\t\n\tdef add(self, x, up, down):\n\t\tif self.y_stack[x+1] == 0:\n\t\t\tself.x_stack.append(x)\n\t\t\tself.y_stack[x+1] = One_Column(x, up, down)\n\t\telse:\n\t\t\tself.y_stack[x+1].add(up, down)\n\t\t\t\t\t\n\tdef calc_menseki(self):\n\t\tself.x_stack.sort()\n\t\tmenseki = 0\n\t\tfor i in self.x_stack:\n\t\t\tfor j in range(len(self.y_stack[i+1].up)):\n\t\t\t\t#print(i,j)\n\t\t\t\tmenseki += (self.y_stack[i+1].up[j] - self.y_stack[i+1].down[j])\n\t\t\t#print(\"x: \"+str(i)+\", menseki: \"+str(menseki))\t\n\t\t#print(\"menseki: \"+str(menseki))\n\t\tprint(str(menseki))\n\n\tdef calc_shuui(self):\n\t\tshuui = 0\n\t\tfor i in self.x_stack:\n\t\t\t#print(\"x:\"+str(i)+\", rec num:\"+str(len(self.y_stack[i+1].up)))\n\t\t\tone_shuui = 0\n\t\t\t#print(\"up + down: \"+str((len(self.y_stack[i+1].up) + len(self.y_stack[i+1].down))))\n\t\t\tone_shuui += (len(self.y_stack[i+1].up) + len(self.y_stack[i+1].down))\n\t\t\tfor j in range(len(self.y_stack[i+1].up)):\n\t\t\t\tedge = 2*(self.y_stack[i+1].up[j] - self.y_stack[i+1].down[j])\n\t\t\t\t# subtract edge\n\t\t\t\tfor k in [i,i+2]:\t\n\t\t\t\t\tif self.y_stack[k] != 0:\n\t\t\t\t\t\tfor l in range(len(self.y_stack[k].up)):\n\t\t\t\t\t\t\tif (self.y_stack[k].down[l] <= self.y_stack[i+1].down[j]) and (self.y_stack[k].up[l] < self.y_stack[i+1].up[j]) and (self.y_stack[k].up[l] > self.y_stack[i+1].down[j]):\n\t\t\t\t\t\t\t\t#print(\"pass 1\")\n\t\t\t\t\t\t\t\tedge -= (self.y_stack[k].up[l] - self.y_stack[i+1].down[j])\n\t\t\t\t\t\t\telif (self.y_stack[k].down[l] >= self.y_stack[i+1].down[j]) and (self.y_stack[k].up[l] <= self.y_stack[i+1].up[j]):\t \n\t\t\t\t\t\t\t\t#print(\"pass 2\")\n\t\t\t\t\t\t\t\tedge -= (self.y_stack[k].up[l] - self.y_stack[k].down[l])\n\t\t\t\t\t\t\telif (self.y_stack[k].down[l] > self.y_stack[i+1].down[j]) and (self.y_stack[k].up[l] >= self.y_stack[i+1].up[j]) and (self.y_stack[k].down[l] < self.y_stack[i+1].up[j]):\n\t\t\t\t\t\t\t\t#print(\"pass 3\")\n\t\t\t\t\t\t\t\tedge -= (self.y_stack[i+1].up[j] - self.y_stack[k].down[l])\n\t\t\t\t\t\t\telif (self.y_stack[k].down[l] <= self.y_stack[i+1].down[j]) and (self.y_stack[k].up[l] >= self.y_stack[i+1].up[j]):\n\t\t\t\t\t\t\t\t#print(\"pass 4\")\n\t\t\t\t\t\t\t\tedge -= (self.y_stack[i+1].up[j] - self.y_stack[i+1].down[j]) \n\t\t\t\tone_shuui += edge\n\t\t\t#print(\"one shuui:\"+str(one_shuui))\t\n\n\t\t\tshuui += one_shuui\t\n\t\t#print(\"shuui: \"+str(shuui))\t\t\t\t\t\t\t\n\t\tprint(str(shuui))\n\nclass One_Column:\t\t\n\tdef __init__(self, x, up=None, down=None):\n\t\tself.x = x\n\t\tself.up = [up]\n\t\tself.down = [down]\n\tdef add(self, up, down):\n\t\tappend_flag =True\n\t\tfor i in range(len(self.up)):\n\t\t\tif (down <= self.down[i]) and (up >= self.up[i]):\n\t\t\t\tdel self.down[i]\n\t\t\t\tdel self.up[i]\n\t\t\telif (down < self.down[i]) and (up >= self.down[i]):\n\t\t\t\tself.down[i] = down\n\t\t\t\tappend_flag =False\n\t\t\telif (down <= self.up[i]) and (up > self.up[i]):\n\t\t\t\tself.up[i] = up\n\t\t\t\tappend_flag = False\n\t\t\telif (down >= self.down[i]) and (up <= self.up[i]):\n\t\t\t\tappend_flag = False\t\n\t\tif append_flag:\t\n\t\t\tself.up.append(up)\n\t\t\tself.down.append(down)\n\n\t\tself.up.sort()\n\t\tself.down.sort()\n\n\nflag =False\n#for line in open(\"input.txt\",\"r\"):\nwhile(1):\n\tline = input()\n\tline = line.rstrip(\"\\n\")\n\t#print(line)\n\tline_list = line.split(\" \")  \n\tif(len(line_list) == 2):\n\t\tif flag:\n\t\t\tif option == 1:\n\t\t\t\tall_col.calc_menseki()\n\t\t\telif option == 2: \t\n\t\t\t\tall_col.calc_menseki()\n\t\t\t\tall_col.calc_shuui()\n\t\tif (line_list[0] == \"0\") and (line_list[1] == \"0\"):\n\t\t\tbreak\t\t\t\n\t\tflag = True\t\n\t\tall_col = All_Column(int(line_list[0]))\n\t\toption = int(line_list[1])\n\telif(len(line_list) == 4):\n\t\tfor i in range(int(line_list[0]), int(line_list[2])):\t\t# x1 ~ x2\n\t\t\tall_col.add(int(i), int(line_list[3]), int(line_list[1]))\t# up = y2, down = y1"
  }
]