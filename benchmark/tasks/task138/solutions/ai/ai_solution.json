[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX 10000\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Rectangle;\n\nbool grid[MAX + 1][MAX + 1] = {false};\n\nint main() {\n    FILE *input = fopen(\"input.txt\", \"r\");\n    FILE *output = fopen(\"output.txt\", \"w\");\n    int n, r;\n    fscanf(input, \"%d %d\", &n, &r);\n    Rectangle rects[n];\n    int min_x = MAX, min_y = MAX, max_x = 0, max_y = 0;\n\n    for (int i = 0; i < n; i++) {\n        fscanf(input, \"%d %d %d %d\", &rects[i].x1, &rects[i].y1, &rects[i].x2, &rects[i].y2);\n        if (rects[i].x1 < min_x) min_x = rects[i].x1;\n        if (rects[i].y1 < min_y) min_y = rects[i].y1;\n        if (rects[i].x2 > max_x) max_x = rects[i].x2;\n        if (rects[i].y2 > max_y) max_y = rects[i].y2;\n    }\n\n    int area = 0;\n    for (int i = 0; i < n; i++) {\n        for (int x = rects[i].x1; x < rects[i].x2; x++) {\n            for (int y = rects[i].y1; y < rects[i].y2; y++) {\n                if (!grid[x][y]) {\n                    grid[x][y] = true;\n                    area++;\n                }\n            }\n        }\n    }\n\n    if (r == 1) {\n        fprintf(output, \"%d\\n\", area);\n    } else {\n        int perimeter = 0;\n        for (int x = min_x; x <= max_x; x++) {\n            for (int y = min_y; y <= max_y; y++) {\n                if (grid[x][y]) {\n                    if (x == min_x || !grid[x - 1][y]) perimeter++;\n                    if (x == max_x || !grid[x + 1][y]) perimeter++;\n                    if (y == min_y || !grid[x][y - 1]) perimeter++;\n                    if (y == max_y || !grid[x][y + 1]) perimeter++;\n                }\n            }\n        }\n        fprintf(output, \"%d\\n%d\\n\", area, perimeter);\n    }\n\n    fclose(input);\n    fclose(output);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class RectangleCalculator {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new FileReader(\"input.txt\"));\n        BufferedWriter writer = new BufferedWriter(new FileWriter(\"output.txt\"));\n\n        String[] firstLine = reader.readLine().split(\" \");\n        int n = Integer.parseInt(firstLine[0]);\n        int r = Integer.parseInt(firstLine[1]);\n\n        List<int[]> rectangles = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            String[] line = reader.readLine().split(\" \");\n            int x1 = Integer.parseInt(line[0]);\n            int y1 = Integer.parseInt(line[1]);\n            int x2 = Integer.parseInt(line[2]);\n            int y2 = Integer.parseInt(line[3]);\n            rectangles.add(new int[]{x1, y1, x2, y2});\n        }\n\n        int totalArea = calculateArea(rectangles);\n        \n        if (r == 1) {\n            writer.write(totalArea + \"\\n\");\n        } else if (r == 2) {\n            int perimeter = calculatePerimeter(rectangles);\n            writer.write(totalArea + \"\\n\");\n            writer.write(perimeter + \"\\n\");\n        }\n\n        reader.close();\n        writer.close();\n    }\n\n    private static int calculateArea(List<int[]> rectangles) {\n        TreeSet<Integer> xCoords = new TreeSet<>();\n        TreeSet<Integer> yCoords = new TreeSet<>();\n\n        for (int[] rect : rectangles) {\n            xCoords.add(rect[0]);\n            xCoords.add(rect[2]);\n            yCoords.add(rect[1]);\n            yCoords.add(rect[3]);\n        }\n\n        Integer[] xArray = xCoords.toArray(new Integer[0]);\n        Integer[] yArray = yCoords.toArray(new Integer[0]);\n\n        int totalArea = 0;\n        for (int i = 0; i < xArray.length - 1; i++) {\n            for (int j = 0; j < yArray.length - 1; j++) {\n                int x1 = xArray[i];\n                int x2 = xArray[i + 1];\n                int y1 = yArray[j];\n                int y2 = yArray[j + 1];\n\n                boolean covered = isCovered(x1, y1, x2, y2, rectangles);\n                if (covered) {\n                    totalArea += (x2 - x1) * (y2 - y1);\n                }\n            }\n        }\n\n        return totalArea;\n    }\n\n    private static boolean isCovered(int x1, int y1, int x2, int y2, List<int[]> rectangles) {\n        for (int[] rect : rectangles) {\n            if (x1 >= rect[0] && x2 <= rect[2] && y1 >= rect[1] && y2 <= rect[3]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static int calculatePerimeter(List<int[]> rectangles) {\n        TreeSet<Integer> xCoords = new TreeSet<>();\n        TreeSet<Integer> yCoords = new TreeSet<>();\n\n        for (int[] rect : rectangles) {\n            xCoords.add(rect[0]);\n            xCoords.add(rect[2]);\n            yCoords.add(rect[1]);\n            yCoords.add(rect[3]);\n        }\n\n        Integer[] xArray = xCoords.toArray(new Integer[0]);\n        Integer[] yArray = yCoords.toArray(new Integer[0]);\n\n        int perimeter = 0;\n        for (int i = 0; i < xArray.length - 1; i++) {\n            for (int j = 0; j < yArray.length - 1; j++) {\n                int x1 = xArray[i];\n                int x2 = xArray[i + 1];\n                int y1 = yArray[j];\n                int y2 = yArray[j + 1];\n\n                boolean covered = isCovered(x1, y1, x2, y2, rectangles);\n                if (covered) {\n                    perimeter += 2 * ((x2 - x1) + (y2 - y1));\n                }\n            }\n        }\n\n        return perimeter;\n    }\n}",
    "timestamp": "2025-08-05 18:47:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Event {\n    int x, y1, y2, type;\n    Event(int x, int y1, int y2, int type) : x(x), y1(y1), y2(y2), type(type) {}\n    bool operator<(const Event &e) const {\n        return x < e.x;\n    }\n};\n\nint main() {\n    ifstream fin(\"input.txt\");\n    ofstream fout(\"output.txt\");\n\n    int n, r;\n    fin >> n >> r;\n\n    vector<Event> events;\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        fin >> x1 >> y1 >> x2 >> y2;\n        events.emplace_back(x1, y1, y2, 1);\n        events.emplace_back(x2, y1, y2, -1);\n    }\n    sort(events.begin(), events.end());\n\n    vector<int> active;\n    int area = 0, perimeter = 0;\n    int prev_x = 0;\n\n    for (size_t i = 0; i < events.size(); ) {\n        int current_x = events[i].x;\n        if (!active.empty()) {\n            int delta_x = current_x - prev_x;\n            int total_y = 0;\n            int prev_y = -1;\n            for (int y : active) {\n                if (prev_y == -1) {\n                    prev_y = y;\n                } else {\n                    total_y += y - prev_y;\n                    prev_y = -1;\n                }\n            }\n            area += delta_x * total_y;\n\n            if (r == 2) {\n                perimeter += delta_x * active.size();\n            }\n        }\n\n        while (i < events.size() && events[i].x == current_x) {\n            Event e = events[i];\n            auto it = find(active.begin(), active.end(), e.y1);\n            if (e.type == 1) {\n                if (it == active.end()) {\n                    active.push_back(e.y1);\n                    sort(active.begin(), active.end());\n                }\n                it = find(active.begin(), active.end(), e.y2);\n                if (it == active.end()) {\n                    active.push_back(e.y2);\n                    sort(active.begin(), active.end());\n                }\n            } else {\n                it = find(active.begin(), active.end(), e.y1);\n                if (it != active.end()) {\n                    active.erase(it);\n                }\n                it = find(active.begin(), active.end(), e.y2);\n                if (it != active.end()) {\n                    active.erase(it);\n                }\n            }\n            ++i;\n        }\n\n        if (r == 2 && !active.empty()) {\n            perimeter += 2 * (active.size() / 2);\n        }\n        prev_x = current_x;\n    }\n\n    fout << area << \"\\n\";\n    if (r == 2) {\n        fout << perimeter << \"\\n\";\n    }\n\n    fin.close();\n    fout.close();\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_RECTANGLES 10001\n#define MAX_COORD 10001\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Rectangle;\n\nint grid[MAX_COORD][MAX_COORD];\n\nint calculateArea(Rectangle* rectangles, int n) {\n    memset(grid, 0, sizeof(grid));\n\n    for (int i = 0; i < n; i++) {\n        Rectangle r = rectangles[i];\n        for (int x = r.x1; x < r.x2; x++) {\n            for (int y = r.y1; y < r.y2; y++) {\n                grid[x][y] = 1;\n            }\n        }\n    }\n\n    int area = 0;\n    for (int x = 0; x < MAX_COORD; x++) {\n        for (int y = 0; y < MAX_COORD; y++) {\n            if (grid[x][y]) area++;\n        }\n    }\n\n    return area;\n}\n\nint calculatePerimeter(Rectangle* rectangles, int n) {\n    memset(grid, 0, sizeof(grid));\n\n    for (int i = 0; i < n; i++) {\n        Rectangle r = rectangles[i];\n        for (int x = r.x1; x < r.x2; x++) {\n            grid[x][r.y1] = 1;\n            grid[x][r.y2 - 1] = 1;\n        }\n        for (int y = r.y1; y < r.y2; y++) {\n            grid[r.x1][y] = 1;\n            grid[r.x2 - 1][y] = 1;\n        }\n    }\n\n    int perimeter = 0;\n    for (int x = 0; x < MAX_COORD; x++) {\n        for (int y = 0; y < MAX_COORD; y++) {\n            if (grid[x][y]) perimeter++;\n        }\n    }\n\n    return perimeter;\n}\n\nint main() {\n    FILE *input = fopen(\"input.txt\", \"r\");\n    FILE *output = fopen(\"output.txt\", \"w\");\n\n    int n, r;\n    fscanf(input, \"%d %d\", &n, &r);\n\n    Rectangle rectangles[MAX_RECTANGLES];\n    for (int i = 0; i < n; i++) {\n        fscanf(input, \"%d %d %d %d\", &rectangles[i].x1, &rectangles[i].y1, \n                                     &rectangles[i].x2, &rectangles[i].y2);\n    }\n\n    int area = calculateArea(rectangles, n);\n    fprintf(output, \"%d\\n\", area);\n\n    if (r == 2) {\n        int perimeter = calculatePerimeter(rectangles, n);\n        fprintf(output, \"%d\\n\", perimeter);\n    }\n\n    fclose(input);\n    fclose(output);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Event {\n    int x, y1, y2, type;\n    bool operator<(const Event& other) const {\n        return x < other.x;\n    }\n};\n\nint calculateArea(vector<vector<int>>& rectangles) {\n    vector<Event> events;\n    set<int> ys;\n\n    for (auto& rect : rectangles) {\n        int x1 = rect[0], y1 = rect[1], x2 = rect[2], y2 = rect[3];\n        events.push_back({x1, y1, y2, 1});\n        events.push_back({x2, y1, y2, -1});\n        ys.insert(y1);\n        ys.insert(y2);\n    }\n\n    sort(events.begin(), events.end());\n    vector<int> unique_ys(ys.begin(), ys.end());\n\n    long long area = 0;\n    vector<int> cover(unique_ys.size() - 1, 0);\n\n    for (int i = 0; i < events.size(); i++) {\n        if (i > 0) {\n            int delta = 0;\n            for (int j = 0; j < cover.size(); j++) {\n                if (cover[j] > 0) {\n                    delta += unique_ys[j+1] - unique_ys[j];\n                }\n            }\n            area += delta * (events[i].x - events[i-1].x);\n        }\n\n        int y1_idx = lower_bound(unique_ys.begin(), unique_ys.end(), events[i].y1) - unique_ys.begin();\n        int y2_idx = lower_bound(unique_ys.begin(), unique_ys.end(), events[i].y2) - unique_ys.begin();\n\n        for (int j = y1_idx; j < y2_idx; j++) {\n            cover[j] += events[i].type;\n        }\n    }\n\n    return area;\n}\n\nint calculatePerimeter(vector<vector<int>>& rectangles) {\n    set<pair<int, int>> points;\n    for (auto& rect : rectangles) {\n        int x1 = rect[0], y1 = rect[1], x2 = rect[2], y2 = rect[3];\n        \n        for (int x = x1; x <= x2; x++) {\n            points.insert({x, y1});\n            points.insert({x, y2});\n        }\n        \n        for (int y = y1; y <= y2; y++) {\n            points.insert({x1, y});\n            points.insert({x2, y});\n        }\n    }\n    \n    return points.size();\n}\n\nint main() {\n    ifstream input(\"input.txt\");\n    ofstream output(\"output.txt\");\n\n    int n, r;\n    input >> n >> r;\n\n    vector<vector<int>> rectangles(n, vector<int>(4));\n    for (int i = 0; i < n; i++) {\n        input >> rectangles[i][0] >> rectangles[i][1] >> rectangles[i][2] >> rectangles[i][3];\n    }\n\n    int area = calculateArea(rectangles);\n    output << area << endl;\n\n    if (r == 2) {\n        int perimeter = calculatePerimeter(rectangles);\n        output << perimeter << endl;\n    }\n\n    input.close();\n    output.close();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n        PrintWriter pw = new PrintWriter(new FileWriter(\"output.txt\"));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int r = Integer.parseInt(st.nextToken());\n        \n        boolean[][] grid = new boolean[10001][10001];\n        int area = 0;\n        int perimeter = 0;\n        \n        for (int i = 0; i < n; i++) {\n            st = new StringTokenizer(br.readLine());\n            int x1 = Integer.parseInt(st.nextToken());\n            int y1 = Integer.parseInt(st.nextToken());\n            int x2 = Integer.parseInt(st.nextToken());\n            int y2 = Integer.parseInt(st.nextToken());\n            \n            for (int x = x1; x < x2; x++) {\n                for (int y = y1; y < y2; y++) {\n                    if (!grid[x][y]) {\n                        grid[x][y] = true;\n                        area++;\n                        perimeter += 4;\n                        if (x > 0 && grid[x-1][y]) perimeter -= 2;\n                        if (y > 0 && grid[x][y-1]) perimeter -= 2;\n                        if (x < 10000 && grid[x+1][y]) perimeter -= 2;\n                        if (y < 10000 && grid[x][y+1]) perimeter -= 2;\n                    }\n                }\n            }\n        }\n        \n        if (r == 1) {\n            pw.println(area);\n        } else {\n            pw.println(area);\n            pw.println(perimeter);\n        }\n        pw.close();\n    }\n}",
    "timestamp": "2025-08-05 18:48:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_area_and_perimeter(rectangles, query):\n    MAX_COORD = 10000\n    grid = [[0] * (MAX_COORD + 1) for _ in range(MAX_COORD + 1)]\n    \n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                grid[x][y] = 1\n\n    area = 0\n    perimeter = 0\n\n    dx = [1, -1, 0, 0]\n    dy = [0, 0, 1, -1]\n    \n    for x in range(MAX_COORD):\n        for y in range(MAX_COORD):\n            if grid[x][y] == 1:\n                area += 1\n                for direction in range(4):\n                    nx, ny = x + dx[direction], y + dy[direction]\n                    if nx < 0 or nx >= MAX_COORD or ny < 0 or ny >= MAX_COORD or grid[nx][ny] == 0:\n                        perimeter += 1\n    \n    return (area, perimeter if query == 2 else None)\n\n\ndef main():\n    with open('input.txt', 'r') as f:\n        lines = f.readlines()\n\n    n, r = map(int, lines[0].split())\n    rectangles = [tuple(map(int, line.split())) for line in lines[1:n+1]]\n\n    area, perimeter = calculate_area_and_perimeter(rectangles, r)\n\n    with open('output.txt', 'w') as f:\n        f.write(f\"{area}\\n\")\n        if r == 2 and perimeter is not None:\n            f.write(f\"{perimeter}\\n\")\n    \n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:54:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class RectangleAreaPerimeter {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new FileReader(\"input.txt\"));\n        PrintWriter writer = new PrintWriter(new FileWriter(\"output.txt\"));\n        \n        StringTokenizer st = new StringTokenizer(reader.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int r = Integer.parseInt(st.nextToken());\n\n        boolean[][] plane = new boolean[10001][10001];\n        int area = 0;\n        int perimeter = 0;\n\n        for (int i = 0; i < n; i++) {\n            st = new StringTokenizer(reader.readLine());\n            int x1 = Integer.parseInt(st.nextToken());\n            int y1 = Integer.parseInt(st.nextToken());\n            int x2 = Integer.parseInt(st.nextToken());\n            int y2 = Integer.parseInt(st.nextToken());\n\n            for (int x = x1; x < x2; x++) {\n                for (int y = y1; y < y2; y++) {\n                    if (!plane[x][y]) {\n                        plane[x][y] = true;\n                        area++;\n                    }\n                }\n            }\n        }\n\n        if (r == 2) {\n            for (int x = 0; x <= 10000; x++) {\n                for (int y = 0; y <= 10000; y++) {\n                    if (plane[x][y]) {\n                        if (x == 0 || !plane[x - 1][y]) perimeter++;\n                        if (y == 0 || !plane[x][y - 1]) perimeter++;\n                        if (x == 10000 || !plane[x + 1][y]) perimeter++;\n                        if (y == 10000 || !plane[x][y + 1]) perimeter++;\n                    }\n                }\n            }\n        }\n\n        writer.println(area);\n        if (r == 2) {\n            writer.println(perimeter);\n        }\n        \n        writer.close();\n        reader.close();\n    }\n}",
    "timestamp": "2025-08-13 00:54:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_COORDINATE 10000\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Rectangle;\n\ntypedef struct {\n    int value;\n    int type; // 1 for start, -1 for end\n    int y1;\n    int y2;\n} Event;\n\ntypedef struct {\n    int y1, y2;\n    int count;\n} Interval;\n\nint compare_events(const void *a, const void *b) {\n    Event *eventA = (Event *)a;\n    Event *eventB = (Event *)b;\n    if (eventA->value != eventB->value) {\n        return eventA->value - eventB->value;\n    }\n    return eventA->type - eventB->type;\n}\n\nint compare_intervals(const void *a, const void *b) {\n    Interval *intvlA = (Interval *)a;\n    Interval *intvlB = (Interval *)b;\n    return intvlA->y1 - intvlB->y1;\n}\n\nint calculate_area_perimeter(Rectangle *rectangles, int n, int r, int *perimeter) {\n    Event *events = (Event *)malloc(n * 2 * sizeof(Event));\n    int event_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        events[event_count++] = (Event){rectangles[i].x1, 1, rectangles[i].y1, rectangles[i].y2};\n        events[event_count++] = (Event){rectangles[i].x2, -1, rectangles[i].y1, rectangles[i].y2};\n    }\n\n    qsort(events, event_count, sizeof(Event), compare_events);\n\n    Interval *intervals = (Interval *)malloc(n * 2 * sizeof(Interval));\n    int interval_count = 0;\n    int prev_x = 0;\n    int total_area = 0;\n    *perimeter = 0;\n    int current_perimeter = 0;\n\n    for (int i = 0; i < event_count; i++) {\n        int current_x = events[i].value;\n        if (i > 0) {\n            int width = current_x - prev_x;\n            int height = 0;\n            for (int j = 0; j < interval_count; j++) {\n                if (intervals[j].count > 0) {\n                    height += intervals[j].y2 - intervals[j].y1;\n                }\n            }\n            total_area += width * height;\n            *perimeter += current_perimeter;\n            current_perimeter = 0;\n        }\n\n        int y1 = events[i].y1;\n        int y2 = events[i].y2;\n        int type = events[i].type;\n\n        int j = 0;\n        while (j < interval_count && intervals[j].y1 < y1) j;\n        \n        if (j < interval_count && intervals[j].y1 < y2) { \n            if (intervals[j].count == 1) {\n                current_perimeter -= 2 * (intervals[j].y2 - intervals[j].y1);\n            }\n            intervals[j].count += type;\n            if (intervals[j].count == 1) {\n                current_perimeter += 2 * (intervals[j].y2 - intervals[j].y1);\n            }\n            if (intervals[j].y1 == y1) {\n                while (j < interval_count && intervals[j].y1 < y2) {\n                    if (j + 1 < interval_count && intervals[j + 1].y1 < y2) {\n                        if (intervals[j].count == 1) {\n                            current_perimeter -= 2 * (intervals[j + 1].y1 - intervals[j].y2);\n                        }\n                        intervals[j].count += type;\n                        if (intervals[j].count == 1) {\n                            current_perimeter += 2 * (intervals[j + 1].y1 - intervals[j].y2);\n                        }\n                        intervals[j].y2 = intervals[j + 1].y1;\n                    } else {\n                        if (intervals[j].count == 1) {\n                            current_perimeter -= 2 * (y2 - intervals[j].y2);\n                        }\n                        intervals[j].count += type;\n                        if (intervals[j].count == 1) {\n                            current_perimeter += 2 * (y2 - intervals[j].y2);\n                        }\n                        intervals[j].y2 = y2;\n                    }\n                    j++;\n                }\n            }\n        }\n\n        if (type == 1 && (j == interval_count || intervals[j].y1 != y1)) {\n            intervals[interval_count++] = (Interval){y1, y2, 1};\n            current_perimeter += 2 * (y2 - y1);\n        }\n        \n        qsort(intervals, interval_count, sizeof(Interval), compare_intervals);\n\n        prev_x = current_x;\n    }\n\n    free(events);\n    free(intervals);\n    \n    return total_area;\n}\n\nint main() {\n    FILE *input = fopen(\"input.txt\", \"r\");\n    FILE *output = fopen(\"output.txt\", \"w\");\n\n    int n, r;\n    fscanf(input, \"%d %d\", &n, &r);\n\n    Rectangle *rectangles = (Rectangle *)malloc(n * sizeof(Rectangle));\n    for (int i = 0; i < n; i++) {\n        fscanf(input, \"%d %d %d %d\", &rectangles[i].x1, &rectangles[i].y1, &rectangles[i].x2, &rectangles[i].y2);\n    }\n    \n    int perimeter = 0;\n    int area = calculate_area_perimeter(rectangles, n, r, &perimeter);\n\n    fprintf(output, \"%d\\n\", area);\n    if (r == 2) {\n        fprintf(output, \"%d\\n\", perimeter);\n    }\n\n    free(rectangles);\n    fclose(input);\n    fclose(output);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 00:55:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_area_perimeter(rectangles):\n    coordinates = set()\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                coordinates.add((x, y))\n    return len(coordinates)\n\ndef calculate_perimeter(rectangles):\n    edge_count = {}\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            edge_count[(x, y1)] = edge_count.get((x, y1), 0) + 1\n            edge_count[(x, y2-1)] = edge_count.get((x, y2-1), 0) + 1\n        for y in range(y1, y2):\n            edge_count[(x1, y)] = edge_count.get((x1, y), 0) + 1\n            edge_count[(x2-1, y)] = edge_count.get((x2-1, y), 0) + 1\n    \n    perimeter = sum(1 for count in edge_count.values() if count == 1)\n    return perimeter\n\ndef main():\n    with open('input.txt', 'r') as f:\n        n, r = map(int, f.readline().split())\n        rectangles = []\n        for _ in range(n):\n            x1, y1, x2, y2 = map(int, f.readline().split())\n            rectangles.append((x1, y1, x2, y2))\n    \n    with open('output.txt', 'w') as f:\n        area = calculate_area_perimeter(rectangles)\n        f.write(f\"{area}\\n\")\n        \n        if r == 2:\n            perimeter = calculate_perimeter(rectangles)\n            f.write(f\"{perimeter}\\n\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:55:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input_file = open('input.txt', 'r')\n    output_file = open('output.txt', 'w')\n    \n    lines = input_file.readlines()\n    n, r = map(int, lines[0].strip().split())\n    rectangles = []\n    \n    for line in lines[1:n+1]:\n        x1, y1, x2, y2 = map(int, line.strip().split())\n        rectangles.append((x1, y1, x2, y2))\n    \n    if n == 0:\n        output_file.write(\"0\\n\")\n        if r == 2:\n            output_file.write(\"0\\n\")\n        return\n    \n    # Calculate area\n    events = []\n    for x1, y1, x2, y2 in rectangles:\n        events.append((y1, 1, x1, x2))\n        events.append((y2, -1, x1, x2))\n    events.sort()\n    \n    active_intervals = []\n    area = 0\n    prev_y = None\n    \n    for event in events:\n        y, typ, x1, x2 = event\n        if prev_y is not None and y != prev_y and active_intervals:\n            dy = y - prev_y\n            # Merge active intervals\n            merged = []\n            for interval in sorted(active_intervals):\n                if not merged:\n                    merged.append(interval)\n                else:\n                    last_x1, last_x2 = merged[-1]\n                    current_x1, current_x2 = interval\n                    if current_x1 <= last_x2:\n                        merged[-1] = (last_x1, max(last_x2, current_x2))\n                    else:\n                        merged.append(interval)\n            # Calculate total width\n            total_width = 0\n            for (ix1, ix2) in merged:\n                total_width += ix2 - ix1\n            area += dy * total_width\n        \n        if typ == 1:\n            active_intervals.append((x1, x2))\n        else:\n            active_intervals.remove((x1, x2))\n        \n        prev_y = y\n    \n    output_file.write(f\"{area}\\n\")\n    \n    if r == 2:\n        # Calculate perimeter\n        # Horizontal perimeter\n        h_events = []\n        for x1, y1, x2, y2 in rectangles:\n            h_events.append((y1, 1, x1, x2))\n            h_events.append((y2, -1, x1, x2))\n        h_events.sort()\n        \n        active_h = []\n        h_perimeter = 0\n        prev_h_y = None\n        \n        for event in h_events:\n            y, typ, x1, x2 = event\n            if prev_h_y is not None and y != prev_h_y and active_h:\n                dy = y - prev_h_y\n                # Count the number of active horizontal edges\n                merged = []\n                for interval in sorted(active_h):\n                    if not merged:\n                        merged.append(interval)\n                    else:\n                        last_x1, last_x2 = merged[-1]\n                        current_x1, current_x2 = interval\n                        if current_x1 <= last_x2:\n                            merged[-1] = (last_x1, max(last_x2, current_x2))\n                        else:\n                            merged.append(interval)\n                h_perimeter += 2 * len(merged) * dy\n            \n            if typ == 1:\n                active_h.append((x1, x2))\n            else:\n                active_h.remove((x1, x2))\n            \n            prev_h_y = y\n        \n        # Vertical perimeter\n        v_events = []\n        for x1, y1, x2, y2 in rectangles:\n            v_events.append((x1, 1, y1, y2))\n            v_events.append((x2, -1, y1, y2))\n        v_events.sort()\n        \n        active_v = []\n        v_perimeter = 0\n        prev_v_x = None\n        \n        for event in v_events:\n            x, typ, y1, y2 = event\n            if prev_v_x is not None and x != prev_v_x and active_v:\n                dx = x - prev_v_x\n                # Count the number of active vertical edges\n                merged = []\n                for interval in sorted(active_v):\n                    if not merged:\n                        merged.append(interval)\n                    else:\n                        last_y1, last_y2 = merged[-1]\n                        current_y1, current_y2 = interval\n                        if current_y1 <= last_y2:\n                            merged[-1] = (last_y1, max(last_y2, current_y2))\n                        else:\n                            merged.append(interval)\n                v_perimeter += 2 * len(merged) * dx\n            \n            if typ == 1:\n                active_v.append((y1, y2))\n            else:\n                active_v.remove((y1, y2))\n            \n            prev_v_x = x\n        \n        perimeter = h_perimeter + v_perimeter\n        output_file.write(f\"{perimeter}\\n\")\n    \n    input_file.close()\n    output_file.close()\n\nsolve()",
    "timestamp": "2025-08-13 00:56:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nstruct Event {\n    int x, y1, y2, type;\n    Event(int x, int y1, int y2, int type) : x(x), y1(y1), y2(y2), type(type) {}\n    bool operator<(const Event& e) const {\n        return x < e.x || (x == e.x && type < e.type);\n    }\n};\n\nint main() {\n    std::ifstream inputFile(\"input.txt\");\n    std::ofstream outputFile(\"output.txt\");\n    \n    int n, r;\n    inputFile >> n >> r;\n    \n    std::vector<Event> events;\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        inputFile >> x1 >> y1 >> x2 >> y2;\n        events.emplace_back(x1, y1, y2, 1);\n        events.emplace_back(x2, y1, y2, -1);\n    }\n    \n    std::sort(events.begin(), events.end());\n    \n    std::set<int> active;\n    int prevX = 0, totalArea = 0, totalPerimeter = 0;\n    for (size_t i = 0; i < events.size(); ++i) {\n        int currX = events[i].x;\n        if (!active.empty()) {\n            int length = 0;\n            int prevY = 0;\n            for (const int& y : active) {\n                if (length == 0) {\n                    prevY = y;\n                    length = 1;\n                } else {\n                    totalArea += (currX - prevX) * (y - prevY);\n                    totalPerimeter += 2 * (y - prevY);\n                    prevY = y;\n                }\n            }\n        }\n        if (events[i].type == 1) {\n            active.insert(events[i].y1);\n            active.insert(events[i].y2);\n        } else {\n            active.erase(events[i].y1);\n            active.erase(events[i].y2);\n        }\n        prevX = currX;\n    }\n    \n    outputFile << totalArea << '\\n';\n    if (r == 2) {\n        outputFile << totalPerimeter << '\\n';\n    }\n    \n    inputFile.close();\n    outputFile.close();\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:56:50"
  }
]