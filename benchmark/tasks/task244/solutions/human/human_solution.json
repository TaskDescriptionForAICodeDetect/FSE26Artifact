[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nconst int vmax=380;\nconst int inf=1<<29;\nstruct edge{int to,cap,cost,rev;};\nvector<edge> graph[vmax];\n \nint h[vmax],dist[vmax];\nint pv[vmax],pe[vmax];\ntypedef tuple<int,int> state;\n \nvoid add_edge(int from,int to,int cap,int cost){\n    graph[from].push_back({to,cap,cost,(int)graph[to].size()});\n    graph[to].push_back({from,0,-cost,(int)graph[from].size()-1});\n}\n \nint min_cost_flow(int s,int t,int f,int n){\n    int res=0;\n    fill(h,h+n,0);\n    while(f>0){\n        priority_queue <state,vector<state>,greater<state> > q;\n        fill(dist,dist+n,inf);\n        dist[s]=0;\n        q.push(state(0,s));\n        while(!q.empty()){\n            int cost,v;\n            tie(cost,v)=q.top();q.pop();\n            if(dist[v] < cost) continue;\n            rep(i,graph[v].size()){\n                edge &e=graph[v][i];\n                if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    pv[e.to]=v,pe[e.to]=i;\n                    q.push(state(dist[e.to],e.to));\n                }\n            }\n        }\n        if(dist[t]==inf) return -1;\n        rep(v,n) h[v]+=dist[v];\n \n        int d=f;\n        for(int v=t;v!=s;v=pv[v]) d=min(d,graph[pv[v]][pe[v]].cap);\n        f-=d;res+=d*h[t];\n        for(int v=t;v!=s;v=pv[v]){\n            edge &e=graph[pv[v]][pe[v]];\n            e.cap-=d;\n            graph[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n \nint main(void){\n    for(int n; cin >> n, n;){\n        rep(v, vmax) graph[v].clear();\n\n        rep(loop, n){\n            int a, b, c; cin >> a >> b >> c;\n            a--;\n\n            add_edge(a, b, 1, -c);\n        }\n        rep(i, vmax - 1){\n            add_edge(i, i + 1, 2, 0);\n        }\n\n        cout << -min_cost_flow(0, vmax - 1, 2, vmax) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_start,int arg_end,int arg_value){\n\t\tstart = arg_start;\n\t\tend = arg_end;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn end < arg.end;\n\t};\n\tint start,end,value;\n};\n\nint main(){\n\n\tint N,dp[367][367],tmp_start,tmp_end,tmp_value,max_end;\n\tbool FLG;\n\n\tvector<Info> V;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tV.clear();\n\n\t\tfor(int i = 0; i <= 366; i++){\n\t\t\tfor(int k = 0; k <= 366; k++)dp[i][k] = 0;\n\t\t}\n\n\t\tdp[366][366] = 0;\n\t\tmax_end = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d %d\",&tmp_start,&tmp_end,&tmp_value);\n\t\t\tV.push_back(Info(tmp_start,tmp_end,tmp_value));\n\t\t\tmax_end = max(max_end,tmp_end);\n\t\t}\n\n\t\tsort(V.begin(),V.end());\n\n\t\tfor(int i = 0; i < V.size();i++){\n\n\t\t\tfor(int row = 1; row <= V[i].end+1; row++){\n\t\t\t\tdp[row][V[i].end+1] = max(dp[row][V[i].end+1],dp[row][V[i].start]+V[i].value);\n\t\t\t}\n\n\t\t\tfor(int col = 1; col <= V[i].end;col++){\n\t\t\t\tdp[V[i].end+1][col] = max(dp[V[i].end+1][col],dp[V[i].start][col]+V[i].value);\n\t\t\t}\n\n\t\t\tfor(int row = 1; row <= max_end+1; row++){\n\t\t\t\tfor(int col = V[i].end+2; col <= max_end+1; col++){\n\t\t\t\t\tif(dp[row][col] < dp[row][col-1]){\n\t\t\t\t\t\tdp[row][col] = dp[row][col-1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int col = 1; col <= max_end+1;col++){\n\t\t\t\tfor(int row = V[i].end+2; row <= max_end+1; row++){\n\t\t\t\t\tif(dp[row][col] < dp[row-1][col]){\n\t\t\t\t\t\tdp[row][col] = dp[row-1][col];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dp[max_end+1][max_end+1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1111;\nconst int MAXX = 400;\n\nstruct Application {\n  int s, t, w;\n  bool operator < (const Application &a) const {\n    return s < a.s;\n  }\n};\n\nint N;\nApplication ap[MAXN];\nint dp[MAXX][MAXX];\n\nint main() {\n  while (cin >> N && N) {\n    for (int i = 0; i < N; ++i) {\n      cin >> ap[i].s >> ap[i].t >> ap[i].w;\n    }\n    sort(ap, ap+N);\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < N; ++i) {\n      for (int j = MAXX-1; j >= 0; --j) {\n        for (int k = MAXX-1; k >= 0; --k) {\n          if (j <= ap[i].s) {\n            dp[ap[i].t+1][k] = max(dp[ap[i].t+1][k], dp[j][k] + ap[i].w);\n          }\n          if (k <= ap[i].s) {\n            dp[j][ap[i].t+1] = max(dp[j][ap[i].t+1], dp[j][k] + ap[i].w);\n          }\n        }\n      }\n    }\n    cout << *max_element(dp[0], dp[MAXX]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll inf = 1e14;\n\nclass min_cost_flow{\nprivate:\n    int N;\n    struct edge{int to; ll cap,cost; int rev;};\n    vector<vector<edge>> G;\n    vector<ll> h,dist,prevv,preve;\npublic:\n    min_cost_flow(int n){\n        N = n;\n        G = vector<vector<edge>>(N);\n        h = dist = prevv = preve = vector<ll>(N,0);\n    }\n    void add_edge(int from,int to,ll cap,ll cost){\n        G[from].push_back((edge){to,cap,cost,(int) G[to].size()});\n        G[to].push_back((edge){from,0,-cost,(int) G[from].size()-1});\n    }\n    ll answer(int s,int t,ll f){\n        ll res = 0;\n        fill(h.begin(),h.end(),0);\n        while(f>0){\n            priority_queue<P,vector<P>,greater<P>> Q;\n            fill(dist.begin(),dist.end(),inf);\n            dist[s] = 0;\n            Q.push(P(s,0));\n            while(!Q.empty()){\n                P p = Q.top(); Q.pop();\n                int v = p.second;\n                if(dist[v]<p.first) continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e = G[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        Q.push(P(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(dist[t]==inf) return -1;\n            for(int v=0;v<N;v++) h[v] += dist[v];\n            ll d = f;\n            for(int v=t;v!=s; v=prevv[v]){\n                d = min(d,G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*h[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        min_cost_flow flow(367);\n        for(int i=0;i<N;i++){\n            int l,r,w;\n            cin >> l >> r >> w;\n            flow.add_edge(l,r+1,1,-w);\n        }\n        for(int i=0;i<366;i++) flow.add_edge(i,i+1,2,0);\n        cout << -flow.answer(0,366,2) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nstruct triple {\n    int l,r,w;\n};\n\ntriple a[1000];\nint dp[2][400][400]; // i,j 以降は空いている\nint n;\n\nint solve(){\n    memset(dp,0,sizeof(dp));\n    sort(a,a + n,[](triple const& a,triple const& b){\n            return a.l < b.l;\n        });\n    rep(i,n){\n        auto next=dp[i&1];\n        auto cur=dp[i+1&1];\n        int l=a[i].l,r=a[i].r,w=a[i].w;\n        rep(j,380)rep(k,380){\n            next[j][k]=cur[j][k];\n            if(j) next[j][k]=max(next[j][k],next[j-1][k]);\n            if(k) next[j][k]=max(next[j][k],next[j][k-1]);\n\n            if(j==r) next[j][k]=max(next[j][k],cur[l][k]+w);\n            if(k==r) next[j][k]=max(next[j][k],cur[j][l]+w);\n        }\n    }\n    return max(dp[0][370][370],dp[1][370][370]);\n}\n\nint main(){\n    while (scanf(\"%d\",&n),n){\n        rep(i,n){\n            int l,r,w; scanf(\"%d%d%d\",&l,&r,&w);\n            r++;\n            a[i]={l,r,w};\n        }\n        printf(\"%d\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\ntypedef vector<vvi> vvvi;\nstruct app{\n\tint s,e,w;\n\tbool operator<(const app &other)const{\n\t\treturn e<other.e;\n\t}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<app>a(n);\n\t\tREP(i,n){\n\t\t\tcin>>a[i].s>>a[i].e>>a[i].w;\n\t\t}\n\t\tsort(ALL(a));\n\t\tvvvi dp(366,vvi(366,vi(2)));\n\t\tREP(i,n){\n\t\t\tREP(j,366){\n\t\t\t\tREP(k,366){\n\t\t\t\t\tif(j<a[i].s){\n\t\t\t\t\t\tdp[a[i].e][k][1]=max(dp[a[i].e][k][1],dp[j][k][0]+a[i].w);\n\t\t\t\t\t}\n\t\t\t\t\tif(k<a[i].s){\n\t\t\t\t\t\tdp[j][a[i].e][1]=max(dp[j][a[i].e][1],dp[j][k][0]+a[i].w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j,366){\n\t\t\t\tREP(k,366){\n\t\t\t\t\tif(j>0)dp[j][k][1]=max(dp[j][k][1],dp[j-1][k][1]);\n\t\t\t\t\tif(k>0)dp[j][k][1]=max(dp[j][k][1],dp[j][k-1][1]);\n\t\t\t\t\tdp[j][k][0]=dp[j][k][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tREP(i,366){\n\t\t\tREP(j,366){\n\t\t\t\tREP(k,2){\n\t\t\t\t\tans=max(ans,dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct app{\n  int s,e,c;\n  app(){}\n  app(int s,int e,int c):s(s),e(e),c(c){}\n  bool operator<(const app &a) const{\n    return s==a.s?e<a.e:s<a.s;\n  }\n};\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<app> v;\n    for(int i=0;i<n;i++){\n      int s,e,c;\n      cin>>s>>e>>c;\n      v.push_back(app(s,e,c));\n    }\n    sort(v.begin(),v.end());\n    int dp[2][400][400],ans=0;\n    memset(dp,0,sizeof(dp));\n    for(int i=0;i<(int)v.size();i++){\n      memset(dp[1],0,sizeof(dp[1]));\n      for(int j=0;j<v[i].s;j++){\n\tfor(int k=0;k<400;k++){\n\t  dp[1][j][k]=max(dp[1][j][k],dp[0][j][k]);\n\t  dp[1][k][j]=max(dp[1][k][j],dp[0][k][j]);\n\t  dp[1][v[i].e][k]=max(dp[1][v[i].e][k],dp[0][j][k]+v[i].c);\n\t  dp[1][k][v[i].e]=max(dp[1][k][v[i].e],dp[0][k][j]+v[i].c);\n\t  //cout<<dp[j][k]<<\":\"<<dp[v[i].e][k]<<\" \"<<v[i].e<<\" \"<<k<<\" \"<<j<<endl;\n\t  //cout<<dp[k][j]<<\":\"<<dp[k][v[i].e]<<\" \"<<k<<\" \"<<v[i].e<<\" \"<<j<<endl;\n\t}\n      }\n      for(int j=0;j<400;j++)\n\tfor(int k=0;k<400;k++)\n\t  dp[0][j][k]=max(dp[0][j][k],dp[1][j][k]),ans=max(ans,dp[0][j][k]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N=400,M=1010;\nconst int NN=400,MM=2010;\nconst int INF=2139062143;\nint n,m,k,s,t;\ninline int read(){\n\tint x=0,f=1;char ch;\n\tdo{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');\n\tdo{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n\treturn x*f;\n}\nint last[NN],le;\nvoid cl()\n{\n\tmemset(last,0,sizeof(last));\n\tle=1;\n}\nstruct node{\n\tint u,v,cap,flow,cost,next;\n}edge[MM<<1];\nvoid add(int u,int v,int cap,int cost)\n{\n\tedge[++le].u=u,edge[le].v=v,edge[le].cap=cap,edge[le].cost=cost,edge[le].flow=0,edge[le].next=last[u],last[u]=le;\n\tedge[++le].u=v,edge[le].v=u,edge[le].cap=0,edge[le].cost=-cost,edge[le].flow=0,edge[le].next=last[v],last[v]=le;\n}\nbool vis[NN];\nint d[NN];\nint p[NN];\nqueue<int> q;\nbool spfa()\n{\n\tmemset(d,127,sizeof(d));\n\tq.push(s);\n\tvis[s]=1,d[s]=0,p[s]=0;\n\twhile (!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tvis[u]=0;\n\t\tfor (register int i=last[u];i;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].v;\n\t\t\tif (edge[i].cap>edge[i].flow&&d[v]>d[u]+edge[i].cost)\n\t\t\t{\n\t\t\t\td[v]=d[u]+edge[i].cost;\n\t\t\t\tp[v]=i;\n\t\t\t\tif (!vis[v])\n\t\t\t\t{\n\t\t\t\t\tvis[v]=1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t]!=INF;\n}\nint maxflow,mincost;\nvoid MCMF()\n{\n\tmaxflow=0,mincost=0;\n\twhile (spfa())\n\t{\n\t\tint f=INF,u=t;\n\t\twhile (u!=s)\n\t\tf=min(f,edge[p[u]].cap-edge[p[u]].flow),u=edge[p[u]].u;\n\t\tmincost+=f*d[t];\n\t\tmaxflow+=f;\n\t\tu=t;\n\t\twhile (u!=s)\n\t\tedge[p[u]].flow+=f,edge[p[u]^1].flow-=f,u=edge[p[u]].u;\n\t}\n}\nint main()\n{\n\twhile (scanf(\"%d\",&n)!=EOF&&n)\n\t{\n\t\tcl();\n\t\tint maxday=0;\n\t\ts=0;\n\t\tadd(s,1,2,0);\n\t\tfor (register int i=1;i<=n;++i)\n\t\t{\n\t\t\tint u=read(),v=read(),cost=read();\n\t\t\tmaxday=max(maxday,max(u,v));\n\t\t\tadd(u,v+1,1,-cost);\n\t\t}\n\t\tfor (register int i=1;i<=maxday;++i)\n\t\tadd(i,i+1,2,0);\n\t\tt=maxday+1;\n\t\tMCMF();\n\t\tprintf(\"%d\\n\",-mincost);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_V = 370;\nusing Capacity = int;\nusing Cost = long long;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // テヲツ慊嘉・ツ青妥ィツセツコ\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t テゥツ鳴禿ヲツ慊?ァツ淞ュティツキツッテ」ツ?ォテヲツイツソテ」ツ?」テ」ツ?ヲテァツ崢ョテ、ツクツ?ヲツ敖ッテヲツオツ?」ツ??\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// テヲツオツ?」ツつ古」ツ?淌」ツδ陛」ツδュテ」ツδシ=テ・ツ?ε」ツ??」ツ?ョテ・ツョツケテゥツ??テァツ渉セテ・ツ慊ィテ」ツ?ョテ・ツョツケテゥツ?湘」ツつ津ィツ。ツィテァツ、ツコ\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tPrimalDual pd(370);\n\n\t\tfor(int i = 0; i <= 365; i++) {\n\t\t\tpd.add_edge(i, i + 1, 2, 0);\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, w;\n\t\t\tcin >> x >> y >> w;\n\t\t\tpd.add_edge(x, y + 1, 1, -w);\n\t\t}\n\n\t\tcout << -pd.solve(1, 366, 2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[400][400];\nvector<pair<int,int> > v[400];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<400;i++)v[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tx--;y--;\n\t\t\tv[x].push_back(make_pair(y,z));\n\t\t}\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)\n\t\t\tdp[i][j]=0;\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<365;i++){\n\t\t\tfor(int j=0;j<365;j++){\n\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\tdp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t\t\t\tif(i==j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\t\tdp[v[i][k].first+1][j+1]=max(dp[v[i][k].first+1][j+1],dp[i][j]+v[i][k].second);\n\t\t\t\t\t\tfor(int l=k+1;l<v[i].size();l++){\n\t\t\t\t\t\t\tdp[v[i][k].first+1][v[i][l].first+1]=max(dp[v[i][k].first+1][v[i][l].first+1],dp[i][j]+v[i][k].second+v[i][l].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(i<j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++)dp[v[i][k].first+1][j]=max(dp[v[i][k].first+1][j],dp[i][j]+v[i][k].second);\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k<v[j].size();k++)dp[i][v[j][k].first+1]=max(dp[i][v[j][k].first+1],dp[i][j]+v[j][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)ret=max(ret,dp[i][j]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 1000000007\n\ntypedef pair<int, int> P;\nstruct edge { int to, cap, cost, rev; };\n\nint V = 366;\nvector<edge> G[400];\nint h[400];\nint dist[400];\nint prevv[400], preve[400];\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){ to, cap, cost, (int)G[to].size() });\n    G[to].push_back((edge){ from, 0, -cost, (int)G[from].size() - 1 });\n}\n\n// テヲツオツ?」ツ?崚」ツ?ェテ」ツ??・ツ?エテ・ツ青暗」ツ?ッM\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        priority_queue<P, vector<P>, greater<P> > q;\n        fill(dist, dist + V, M);\n        dist[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty()) {\n            P p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < (int)G[v].size(); ++i) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    q.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == M) return M;\n        for (int v = 0; v < V; ++v)\n            h[v] += dist[v];\n\n        int d = f;\n        for (int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) return 0;\n        for (int i = 0; i < 400; ++i) {\n            G[i].clear();\n            h[i] = 0;\n            dist[i] = 0;\n            prevv[i] = 0;\n            preve[i] = 0;\n        }\n        for (int i = 0; i < V - 1; ++i) {\n            add_edge(i, i + 1, 2, 0);\n        }\n        for (int i = 0; i < n; ++i) {\n            int a, b, w;\n            cin >> a >> b >> w;\n            add_edge(a - 1, b, 1, -w);\n        }\n        cout << -min_cost_flow(0, V - 1, 2) << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nstruct Elm {\n  int l, r, w;\n};\nvoid solve(int n) {\n  vector<Elm> v;\n  for(int i=0;i<n;++i) {\n    int l, r, w; cin >> l >> r >> w;\n    r++;\n    v.push_back({l, r, w});\n  }\n  sort(v.begin(), v.end(), [](Elm e1, Elm e2){return (e1.l == e2.l) ? e1.r < e2.r : e1.l < e2.l;});\n  vvi dp(367, vi(367, 0));\n  for(int i=0;i<n;++i) {\n    int l = v[i].l, r = v[i].r, w = v[i].w;\n    for(int j=366;j>=1;--j) {\n      for(int k=366;k>=1;--k) {\n        if(j <= l) {\n          dp[r][k] = max(dp[r][k], dp[j][k] + w);\n        }\n        if(k <= l) {\n          dp[j][r] = max(dp[j][r], dp[j][k] + w);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for(int i=1;i<367;++i) {\n    for(int j=1;j<367;++j) {\n      ans = max(ans, dp[i][j]);\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[400][400];\nvector<pair<int,int> > v[400];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<400;i++)v[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tx--;y--;\n\t\t\tv[x].push_back(make_pair(y,z));\n\t\t}\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)\n\t\t\tdp[i][j]=0;\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<365;i++){\n\t\t\tfor(int j=0;j<365;j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\t\tdp[v[i][k].first+1][j+1]=max(dp[v[i][k].first+1][j+1],dp[i][j]+v[i][k].second);\n\t\t\t\t\t\tfor(int l=k+1;l<v[i].size();l++){\n\t\t\t\t\t\t\tdp[v[i][k].first+1][v[i][l].first+1]=max(dp[v[i][k].first+1][v[i][l].first+1],dp[i][j]+v[i][k].second+v[i][l].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\t\tdp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t\t\t\t}else if(i<j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++)dp[v[i][k].first+1][j]=max(dp[v[i][k].first+1][j],dp[i][j]+v[i][k].second);\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k<v[j].size();k++)dp[i][v[j][k].first+1]=max(dp[i][v[j][k].first+1],dp[i][j]+v[j][k].second);\n\t\t\t\t\tdp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)ret=max(ret,dp[i][j]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n//verified POJ3680\n#define MAX_V (365+3)\nstruct edge { int to, cap, cost,rev; };\n\nvector<edge> G[MAX_V];\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n//?????????????????????????????????????????´????????????\nvoid shortest_path(int s,vector<int> &d){\n    int v = d.size();\n    rep(i,d.size())d[i]=INF;\n    d[s]=0;\n    rep(loop,v){\n        rep(i,v){\n            for(auto e:G[i]){\n                if(e.cap && d[i]!=INF && d[e.to] > d[i]+e.cost)\n                    d[e.to] = d[i]+e.cost;\n            }\n        }\n    }\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n    vector<int> h(MAX_V);\t//??????????????£???\n    vector<int> dist(MAX_V);// ???????????¢\n    int prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n    int res = 0;\n    shortest_path(s, h);\n    \n    while (f > 0) {\n        // ?????????????????????????????¨??????h?????´??°??????\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        rep(i,dist.size())dist[i]=INF;\n        dist[s] = 0;\n        que.push(pii(0, s));\n        while (!que.empty()) {\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) return -INF;\t//????????\\???????????????\n        \n        for (int v = 0; v < h.size(); v++) h[v] += dist[v];\n        \n        \n        // s-t????????????????????£??????????????????\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        rep(i,MAX_V)G[i].clear();\n        \n        map<pii,vector<int>> mp;\n        rep(i,n){\n            int s,t,c;\n            cin>>s>>t>>c;\n            s--,t;\n            mp[pii(s,t)].pb(c);\n        }\n        for(auto e:mp){\n            sort(all(e.second),greater<int>());\n            rep(i,min(2,(int)e.second.size()))add_edge(e.first.first, e.first.second, 1, -e.second[i]);\n        }\n        int S = 366;\n        int T = S+1;\n        \n        int bef = -1;\n        rep(i,365)add_edge(i,i+1,INF,0);\n        add_edge(S, 0, INF, 0);\n        add_edge(365, T, INF, 0);\n        \n        cout<<-1*min_cost_flow(S, T, 2)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::sort;\nusing std::max;\n\nint dp[367][367];\nstruct apply{\n    int a, b, c;\n}applys[10000];\nbool comp(apply a, apply b){return a.a < b.a;}\n\nint main(){\n    int N;\n    while(scanf(\"%d\", &N) && N){\n        for(int i=0 ; i<=365 ; i++)\n            for(int j=0 ; j<=365 ; j++)\n                dp[i][j] = 0;\n        for(int i=0 ; i<N ; i++){\n            scanf(\"%d %d %d\", &applys[i].a, &applys[i].b, &applys[i].c);\n        }\n        sort(applys, applys+N, comp);\n        int ptr = 0;\n        for(int i=0;i<365;i++){\n            dp[i][i] = max(dp[i][i], dp[i-1][i-1]);\n            while(ptr<N && applys[ptr].a==i){\n                int k = applys[ptr].b+1;\n                int c = applys[ptr].c;\n                for(int j=365;j>=i;j--){\n                    dp[k][j] = max(dp[k][j], dp[i][j]+c);\n                    dp[j][k] = max(dp[j][k], dp[j][i]+c);\n                }\n                ptr++;\n            }\n            for(int j=i;j<=365;j++){\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n                dp[j][i+1] = max(dp[j][i+1], dp[j][i]);\n            }\n        }\n        printf(\"%d\\n\", dp[365][365]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define MAX_N 400\n\nint main(void){\n  int N,S[MAX_N],T[MAX_N],W[MAX_N],dp[MAX_N][MAX_N];\n\n  while(cin >> N,N){\n\n    for(int i=0;i<N;i++){\n      cin >> S[i] >> T[i] >> W[i];\n    }\n\n    for(int i=0;i<N;i++){\n      for(int j=i;j<N;j++){\n\tif(T[i]>T[j]){\n\t  swap(S[i],S[j]);\n\t  swap(T[i],T[j]);\n\t  swap(W[i],W[j]);\n\t}\n      }\n    }\n\n    fill(dp[0],dp[MAX_N],0);\n\n    for(int i=0;i<N;i++){\n      for(int j=365;j>=0;j--){\n\tfor(int k=365;k>=0;k--){\n\t  if(j<S[i])dp[T[i]][k]=max(dp[T[i]][k],dp[j][k]+W[i]);\n\t  if(k<S[i])dp[j][T[i]]=max(dp[j][T[i]],dp[j][k]+W[i]);\n\t}\n      }\n    }\n\n    int ans=0;\n    for(int i=0;i<366;i++){\n      for(int j=0;j<366;j++){\n\tans=max(ans,dp[i][j]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define MAX_V 400\n#define INF (1LL<<55)\nstruct edge{ll to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nll dist[MAX_V];\nll prevv[MAX_V];\nll preve[MAX_V];\n\nvoid add_edge(ll from,ll to,ll cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(ll)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(ll)G[from].size()-1});\n}\n\nll min_cost_flow(int s,int t,ll f){\n  ll res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==INF)continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    ll d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=d*dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nint a,b,c;\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    V=400;\n   \n    for(int i=0;i<357;i++)\n      add_edge(i,i+1,2,0);\n    \n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      add_edge(a,b+1,1,-c);\n    }\n    \n    cout<<-min_cost_flow(0,357,2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\nstatic const int Y = 365;\nstatic const int MAXN = 2*Y+2;\n\ntemplate <class Flow, class Cost>\nstruct node\n{\n  int index;\n  Flow capacity;\n  Cost cost;\n  node(int i, Flow c, Cost d) : index(i), capacity(c), cost(d) {}\n};\n\ntemplate <class Flow, class Cost>\nnode<Flow, Cost> make_node(int i, Flow c, Cost d) { return node<Flow, Cost>(i, c, d); }\n\ntemplate <class Flow, class Cost>\npair<Flow, Cost>\nprimal_dual(const vector<node<Flow, Cost> > *g, int N, int source, int sink, int max_flow)/*{{{*/\n{\n  static Flow capacity[MAXN][MAXN], flow[MAXN][MAXN];\n  static Cost cost[MAXN][MAXN];\n  for (int i = 0; i < N; i++) {\n    fill_n(capacity[i], N, 0);\n    fill_n(flow[i], N, 0);\n    fill_n(cost[i], N, 0);\n  }\n  for (int i = 0; i < N; i++) {\n    for (typename vector<node<Flow, Cost> >::const_iterator it(g[i].begin()); it != g[i].end(); ++it) {\n      if (it->cost <= cost[i][it->index]) {\n        capacity[i][it->index] = it->capacity;\n        cost[i][it->index] = it->cost;\n      }\n    }\n  }\n  pair<Flow, Cost> total;\n  static Cost h[MAXN], dist[MAXN];\n  static int parent[MAXN];\n  for (Flow f = max_flow; f > 0; ) {\n    fill_n(dist, N, 1000000);\n    dist[source] = 0;\n    fill_n(parent, N, -1);\n    priority_queue<pair<Cost,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const Cost c = -q.top().first;\n      q.pop();\n      if (dist[n] < c) {\n        continue;\n      }\n      for (typename vector<node<Flow, Cost> >::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (capacity[n][it->index] - flow[n][it->index] > 0) {\n          const Cost c2 = c + cost[n][it->index] + h[n] - h[it->index];\n          if (c2 < dist[it->index]) {\n            dist[it->index] = c2;\n            parent[it->index] = n;\n            q.push(make_pair(-c2, it->index));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    Flow e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.second += e * cost[parent[i]][i];\n      flow[i][parent[i]] -= e;\n      flow[parent[i]][i] += e;\n    }\n    f -= e;\n    total.first += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n\n  return total;\n}/*}}}*/\nint main()\n{\n  int N;\n  while (scanf(\"%d\", &N) == 1 && N != 0) {\n    static vector<node<int,int> > g[MAXN];\n    for (int i = 0; i < MAXN; i++) {\n      g[i].clear();\n    }\n    static pair<int,int> period[1000];\n    static const int source = 2*Y;\n    static const int sink = 2*Y+1;\n    for (int i = 0; i < N; i++) {\n      int u, v, w;\n      scanf(\"%d %d %d\", &u, &v, &w);\n      --u;  --v;\n      g[source].push_back(make_node(u, 1, 0));\n      g[u].push_back(make_node(v+Y, 1, -w));\n      g[v+Y].push_back(make_node(sink, 1, 0));\n      period[i].first = u;\n      period[i].second = v;\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        if (period[i].second < period[j].first) {\n          g[period[i].second+Y].push_back(make_node(period[j].first, 1, 0));\n        }\n      }\n    }\n\n    printf(\"%d\\n\", -primal_dual(g, MAXN, source, sink, 2).second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 370;\nstruct data{\n  int s,g,r;\n  bool operator < (const data& d) const { return s < d.s;}\n};\nint dp[2][MAX][MAX];\nint N;\nvector<data> V;\n\nvoid init(){\n  V.clear();\n  memset(dp,0,sizeof(dp));\n}\n\nvoid input(){\n  V.resize(N);\n\n  for(int i = 0; i < N; i++)\n    cin >> V[i].s >> V[i].g >> V[i].r;\n}\n\nvoid solve(){\n\n  sort(V.begin(),V.end());\n\n  for(int i = 0; i < N; i++){\n    int now = i%2;\n    int nex = 1-now;\n\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++){\n\tdp[nex][j][k] = max(dp[nex][j][k],dp[now][j][k]);\n\tif(j < V[i].s) dp[nex][V[i].g][k] = max(dp[nex][V[i].g][k],dp[now][j][k]+V[i].r);\n\tif(k < V[i].s) dp[nex][j][V[i].g] = max(dp[nex][j][V[i].g],dp[now][j][k]+V[i].r);\n      }\n  }\n\n  int ans = 0;\n  \n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++) ans = max(ans,dp[N%2][i][j]);\n\n  cout << ans << endl;\n}\n\nint main(){\n  \n  while(cin >> N && N){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[400][400];\nvector<pair<int,int> > v[400];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<400;i++)v[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tx--;y--;\n\t\t\tv[x].push_back(make_pair(y,z));\n\t\t}\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)\n\t\t\tdp[i][j]=0;\n\t\tfor(int i=0;i<365;i++){\n\t\t\tfor(int j=0;j<365;j++){\n\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\tdp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t\t\t\tif(i==j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++)for(int l=k+1;l<v[i].size();l++){\n\t\t\t\t\t\tdp[v[i][k].first+1][v[i][l].first+1]=max(dp[v[i][k].first+1][v[i][l].first+1],dp[i][j]+v[i][k].second+v[i][l].second);\n\t\t\t\t\t}\n\t\t\t\t}else if(i<j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++)dp[v[i][k].first+1][j]=max(dp[v[i][k].first+1][j],dp[i][j]+v[i][k].second);\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k<v[j].size();k++)dp[i][v[j][k].first+1]=max(dp[i][v[j][k].first+1],dp[i][j]+v[j][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)ret=max(ret,dp[i][j]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data{\n  int l,r,c;\n  bool operator < (const data &d) const {\n    return r == d.r ? c > d.c : r < d.r;\n  }\n};\n\nconst int N = 1000;\nconst int M = 365;\ndata v[N];\nint dp[N+1][M+1][M+1];\nint n;\n\nvoid solve(){\n  fill(dp[0][0],dp[n+1][0],0);\n  sort(v,v+n);\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=M;j++){\n      for(int k=0;k<=M;k++){\n        dp[i+1][j][k] = dp[i][j][k];\n      }\n    }\n    \n    for(int j=v[i].r+1;j<=M;j++){\n      for(int k=0;k<=M;k++){\n        dp[i+1][j][k] = max(dp[i+1][j][k], dp[i][v[i].l][k] + v[i].c);\n        dp[i+1][k][j] = max(dp[i+1][k][j], dp[i][k][v[i].l] + v[i].c);\n      }\n    }    \n  }\n\n  cout << dp[n][M][M] << endl;\n}\n\nint main(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> v[i].l >> v[i].r >> v[i].c;\n      v[i].l--; v[i].r--;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint dp[2][370][370];\nstruct info{\n\tint a, b, c;\n} x[1000];\n\nbool check(const info& left, const info& right)\t{\n\tif(left.b < right.b) return true;\n\telse return false;\n}\n\nvoid solve(){\n\trep(u,2) rep(i,370) rep(j,370) dp[u][i][j] = 0;\n\trep(i,n){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tx[i] = (info){a,b,c};\n\t}\n\tsort(x,x+n,check);\n\tint ho = 0, ge = 1;\n\trep(i,n){\n\t\tint a = x[i].a, b = x[i].b, c = x[i].c;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tfor(int k = 0; k < 370; k++){\n\t\t\t\tdp[ge][b][k] = max(dp[ge][b][k],dp[ho][j][k]+c);\n\t\t\t\tdp[ge][k][b] = dp[ge][b][k];\n\t\t\t}\n\t\t}\n\t\trep(j,370) rep(k,370) dp[ho][j][k] = dp[ge][j][k];\n\t\tswap(ho,ge);\n\t}\n\tint ans = 0;\n\trep(u,2) rep(i,370) rep(j,370) ans = max(ans,dp[u][i][j]);\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nstruct P\n{\n  int s,e,cost;\n  P(int s=0,int e=0,int cost=0):s(s),e(e),cost(cost){}\n  bool operator < (const P& p)const\n  {\n    if(s!=p.s)return s < p.s;\n    return e < p.e;\n  } \n};\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      int MAX = 367;\n      //dp[i][j] := テッツシツ妥」ツ?、テ」ツつ?」ツ?ョテゥツδィテ・ツアツ凝」ツ?景テヲツ猟・テ」ツつ?」ツ?ァ2テ」ツ?、テァツ崢ョテ」ツ?ョテゥツδィテ・ツアツ凝」ツ?桂テヲツ猟・テ」ツ?ョテヲツ卍づ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ按ゥテァツ崢?\n      VVI dp(MAX,VI(MAX,0));\n      vector<P> requests(N);\n      rep(i,N)\n\tcin >> requests[i].s >> requests[i].e >> requests[i].cost;\n      sort(requests.begin(),requests.end());\n  \n      rep(k,N)\n\t{\n\t  VVI DP = dp;\n\t  REP(i,1,MAX)\n\t    {\n\t      REP(j,1,MAX)\n\t\t{\n\t\t  if(i == j && j == requests[k].e+1)\n\t\t    {\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     max(dp[requests[k].s][j]+requests[k].cost,\n\t\t\t\t\t dp[i][requests[k].s]+requests[k].cost));\n\t\t    }\n\t\t  else if(j == requests[k].e+1)\n\t\t    {\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     dp[i][requests[k].s]+requests[k].cost);\n\t\t    }\n\t\t  else if(i == requests[k].e+1)\n\t\t    {\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     dp[requests[k].s][j]+requests[k].cost);\n\t\t    }\n\t\t  \n\t\t    DP[i][j] = max(DP[i][j],\n\t\t\t\t   max(DP[i-1][j],DP[i][j-1]));\n\t\t}\n\t    }\n\t  dp = DP;\n\t}\n      cout << dp[MAX-1][MAX-1] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 400\n\nint main(void){\n  int N,S[MAX_N],T[MAX_N],W[MAX_N],dp[MAX_N][MAX_N];\n\n  while(cin >> N,N){\n\n    for(int i=0;i<N;i++){\n      cin >> S[i] >> T[i] >> W[i];\n    }\n\n    for(int i=0;i<N;i++){\n      for(int j=i;j<N;j++){\n\tif(T[i]>T[j]){\n\t  swap(S[i],S[j]);\n\t  swap(T[i],T[j]);\n\t  swap(W[i],W[j]);\n\t}\n      }\n    }\n\n    for(int i=0;i<400;i++)\n      for(int j=0;j<400;j++)\n\tdp[i][j]=0;\n\n    for(int i=0;i<N;i++){\n      for(int j=365;j>=0;j--){\n\tfor(int k=365;k>=0;k--){\n\t  if(j<S[i])dp[T[i]][k]=max(dp[T[i]][k],dp[j][k]+W[i]);\n\t  if(k<S[i])dp[j][T[i]]=max(dp[j][T[i]],dp[j][k]+W[i]);\n\t}\n      }\n    }\n\n    int ans=0;\n    for(int i=0;i<366;i++){\n      for(int j=0;j<366;j++){\n\tans=max(ans,dp[i][j]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntemplate<class T>\nstruct interval{\n\tT a,b,w;\n\tinterval():a(0),b(0){}\n\tinterval(const T &a,const T &b):a(a<b?a:b),b(a<b?b:a){}\n\tbool operator<(const interval &I)const{ return b<I.b || b==I.b && a<I.a; }\n};\n\nconst int V_MAX=1002;\nconst int CAPA_INF=1<<29;\nconst int COST_INF=1<<29;\n\ntemplate<class T,class U>\nstruct edge{\n\tint v,rev;\n\tT capa;\n\tU cost;\n\tT flow;\n};\n\ntemplate<class T,class U>\nvoid add_directed_edge(vector< edge<T,U> > *G,int u,int v,T capa,U cost){\n\tG[u].push_back((edge<T,U>){v,G[v].size()  ,capa, cost,0});\n\tG[v].push_back((edge<T,U>){u,G[u].size()-1,   0,-cost,0});\n}\n\ntemplate<class T,class U>\npair<T,U> augment(int n,vector< edge<T,U> > *G,int s,int t,U *pot,bool fir){\n\tstatic int pre[V_MAX];\n\tstatic U d[V_MAX];\n\trep(u,n) d[u]=(u==s?0:COST_INF);\n\n\tbool ok;\n\tif(fir){\n\t\t// Bellman-Ford\n\t\twhile(1){\n\t\t\tbool end=true;\n\t\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\t\tedge<T,U> &e=G[u][i];\n\t\t\t\tif(e.capa-e.flow>0 && d[u]<COST_INF && d[u]+e.cost<d[e.v]){\n\t\t\t\t\td[e.v]=d[u]+e.cost;\n\t\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\t\tend=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end) break;\n\t\t}\n\t\tok=(d[t]<COST_INF);\n\t}\n\telse{\n\t\t// Dijkstra\n\t\tok=false;\n\t\tpriority_queue< pair<U,int> > Q; Q.push(make_pair(0,s));\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.top().second;\n\t\t\tU cost=-Q.top().first; Q.pop();\n\n\t\t\tif(cost<d[u]) continue;\n\t\t\tif(u==t) ok=true;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tedge<T,U> &e=G[u][i];\n\t\t\t\tU cost2=cost+e.cost+pot[u]-pot[e.v];\n\t\t\t\tif(e.capa-e.flow>0 && cost2<d[e.v]){\n\t\t\t\t\td[e.v]=cost2;\n\t\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\t\tQ.push(make_pair(-cost2,e.v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!ok) return make_pair(0,0);\n\n\tT water=CAPA_INF;\n\tfor(int v=t;v!=s;){\n\t\tedge<T,U> &e1=G[v][pre[v]];\n\t\tedge<T,U> &e2=G[e1.v][e1.rev];\n\t\twater=min(water,e2.capa-e2.flow);\n\t\tv=e1.v;\n\t}\n\n\tU cost=0;\n\tfor(int v=t;v!=s;){\n\t\tedge<T,U> &e1=G[v][pre[v]];\n\t\tedge<T,U> &e2=G[e1.v][e1.rev];\n\t\te1.flow-=water;\n\t\te2.flow+=water;\n\t\tcost+=water*e2.cost;\n\t\tv=e1.v;\n\t}\n\n\trep(u,n) pot[u]+=d[u];\n\n\treturn make_pair(water,cost);\n}\n\ntemplate<class T,class U>\npair<T,U> primal_dual(int n,vector< edge<T,U> > *G,int s,int t){\n\tstatic U pot[V_MAX];\n\trep(u,n) pot[u]=0;\n\n\tT ans1=0;\n\tU ans2=0;\n\tfor(bool fir=true;;fir=false){\n\t\tpair<T,U> tmp=augment(n,G,s,t,pot,fir);\n\t\tif(tmp.first==0) break;\n\t\tans1+=tmp.first;\n\t\tans2+=tmp.second;\n\t}\n\treturn make_pair(ans1,ans2);\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tinterval<int> I[1000];\n\t\trep(i,n) scanf(\"%d%d%d\",&I[i].a,&I[i].b,&I[i].w);\n\n\t\tsort(I,I+n);\n\n\t\tint s=2*n,t=s+1;\n\t\tvector< edge<int,int> > G[2003];\n\t\trep(u,n) for(int v=u+1;v<n;v++) if(I[u].b<I[v].a) {\n\t\t\tadd_directed_edge(G,2*u+1,2*v,1,-I[v].w);\n\t\t}\n\t\trep(u,n){\n\t\t\tadd_directed_edge(G,s,2*u,1,-I[u].w);\n\t\t\tadd_directed_edge(G,2*u,2*u+1,1,0);\n\t\t\tadd_directed_edge(G,2*u+1,t,1,0);\n\t\t}\n\t\tint tt=t+1;\n\t\tadd_directed_edge(G,t,tt,2,0);\n\n\t\tprintf(\"%d\\n\",-primal_dual(2*n+3,G,s,tt).second);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\n#define MAX_V 400\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nconst int INF=0x7fffffff;\n\nstruct edge{int to,cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost)\n{\n\tedge a={to,cap,cost,G[to].size()};\n\tG[from].push_back(a);\n\tedge b={from,0,-cost,G[from].size()-1};\n\tG[to].push_back(b);\n}\n\nint min_cost_flow(int s,int t,int f)\n{\n\tint res=0;\n\twhile(f>0)\n\t{\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update)\n\t\t{\n\t\t\tupdate=false;\n\t\t\tfor(int v=0;v<V;v++)\n\t\t\t{\n\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost;\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF)\n\t\t\treturn -1;\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tint Cnt;\n\tint n,v,f;\n\tfor(;scanf(\"%d\",&Cnt),Cnt;)\n\t{\n\t\tn=366;\n\t\tV=366;\n\t\tfor(int i=0;i<Cnt;i++)\n\t\t{\n\t\t\tint a,b,cost;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&cost);\n\t\t\tadd_edge(a-1,b,1,-cost);\n\t\t}\n\t\tfor(int i=0;i<366;i++)add_edge(i,i+1,2,0);\n\t\tprintf(\"%d\\n\",-min_cost_flow(0,365,2));\n\t\tfor(int i=0;i<366;i++)G[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint const INF = 1e9;\nstruct edge { int to, cap, cost, rev;};\n\nint const V = 366;\ntypedef pair<int,int> Pii;\n\nvector<edge> G[V];\nint h[V], dist[V];\nint prevv[V], preve[V];\n\ninline void add_edge(int from, int to, int cap, int cost){\n  G[from].push_back((edge){to, cap, -cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, cost, (int)G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f){\n  \n  int res = 0;\n  memset(h, 0, sizeof h);\n  \n  while(f > 0){\n    priority_queue<Pii, vector<Pii>, greater<Pii> > pq;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    pq.push(Pii(0, s));\n    while(!pq.empty()){\n      Pii p = pq.top(); pq.pop();\n      int v = p.second;\n      \n      if(dist[v] < p.first) { continue; }\n      \n      rep(i, G[v].size()){\n\tedge &e = G[v][i];\n\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t  dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t  prevv[e.to] = v;\n\t  preve[e.to] = i;\n\t  pq.push(Pii(dist[e.to], e.to));\n\t}\n      }\n    }\n    \n    if(dist[t] == INF) return -1;\n    \n    rep(v, V) h[v] += dist[v];\n    \n    int d = f;\n    for(int v=t; v!=s; v=prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    \n    f -= d;\n    res += d*h[t];\n    \n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  \n  return res;\n}\n\n\nint main() {\n  \n  while(1) {\n    \n    int N; cin >> N; if(N == 0) break;\n    rep(i, V) G[i].clear();\n    rep(i, V-1) add_edge(i, i+1,2,0);\n    rep(i, N) {\n      int a, b, c; cin >> a >> b >> c;\n      add_edge(a-1, b, 1, c);\n    }\n    \n    cout << -min_cost_flow(0, 365, 2) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n//verified POJ3680\n#define MAX_V (400)\nstruct edge { int to, cap, cost,rev; };\n\nvector<edge> G[MAX_V];\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n//?????????????????????????????????????????´????????????\nvoid shortest_path(int s,vector<int> &d){\n    int v = d.size();\n    rep(i,d.size())d[i]=INF;\n    d[s]=0;\n    rep(loop,v){\n        rep(i,v){\n            for(auto e:G[i]){\n                if(e.cap && d[i]!=INF && d[e.to] > d[i]+e.cost)\n                    d[e.to] = d[i]+e.cost;\n            }\n        }\n    }\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n    vector<int> h(MAX_V);\t//??????????????£???\n    vector<int> dist(MAX_V);// ???????????¢\n    int prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n    \n    int res = 0;\n    shortest_path(s, h);\n    \n    while (f > 0) {\n        // ?????????????????????????????¨??????h?????´??°??????\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        rep(i,dist.size())dist[i]=INF;\n        dist[s] = 0;\n        que.push(pii(0, s));\n        while (!que.empty()) {\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) return -INF;\t//????????\\???????????????\n        \n        for (int v = 0; v < h.size(); v++) h[v] += dist[v];\n        \n        \n        // s-t????????????????????£??????????????????\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        rep(i,MAX_V)G[i].clear();\n        rep(i,n){\n            int s,t,c;\n            cin>>s>>t>>c;\n            s--,t;\n            add_edge(s, t, 1, -c);\n        }\n        int S = 366;\n        int T = S+1;\n        add_edge(S, 0, INF, 0);\n        add_edge(365, T, INF, 0);\n        rep(i,365)add_edge(i, i+1, INF, 0);\n        \n        cout<<-1*min_cost_flow(S, T, 2)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight capacity, cost;\n  int rev;\n  Edge(int src, int dst, Weight capacity, Weight cost) :\n    src(src), dst(dst), capacity(capacity), cost(cost) { }\n  Edge(int src, int dst, Weight capacity, Weight cost, int rev) :\n    src(src), dst(dst), capacity(capacity), cost(cost), rev(rev) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, Weight cap, Weight cost) {\n  g[s].push_back(Edge(s,d,cap,cost,g[d].size()));\n  g[d].push_back(Edge(d,s,0,-cost,g[s].size()-1));\n}\n\npair<Weight, Weight> minimumCostFlow3(Graph g, int s, int t) {\n  const int n = g.size();\n  pair<Weight, Weight> total; // (cost, flow)\n  \n  vector<Weight> h(n,INF);\n  h[s] = 0;\n  REP(k, n) REP(i, n) FOR(e,g[i]) if (e->capacity)\n    h[e->dst] = min(h[e->dst], h[e->src] + e->cost);\n  \n  for (int F = INF; F > 0;) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> pv(n,-1), pe(n);\n    priority_queue<Edge> Q;\n    for (Q.push(Edge(-2,s,0,0)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (pv[e.dst] != -1) continue;\n      pv[e.dst] = e.src;\n      pe[e.dst] = e.rev;\n      REP(i, g[e.dst].size()) {\n        Edge &f = g[e.dst][i];\n        if (f.capacity > 0 && d[f.dst] > d[f.src] + f.cost + h[f.src] - h[f.dst]) {\n          d[f.dst] = d[f.src] + f.cost + h[f.src] - h[f.dst];\n          Q.push(Edge(f.src, f.dst, 0, d[f.dst], i));\n        }\n      }\n    }\n    if (pv[t] == -1) break;\n    Weight f = F;\n    for (int u = t; u != s; u = pv[u])\n      f = min(f, g[pv[u]][pe[u]].capacity);\n    if (!f) break;\n    for (int u = t; u != s; u = pv[u]) {\n      total.first += f * g[pv[u]][pe[u]].cost;\n      g[pv[u]][pe[u]].capacity -= f;\n      g[u][g[pv[u]][pe[u]].rev].capacity += f;\n    }\n    F -= f;\n    total.second += f;\n    REP(u,n) if (h[u] != INF) h[u] += d[u];\n  }\n  return total;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    Graph g(367);\n    \n    REP(i, n) {\n      int a, b, w;\n      cin >> a >> b >> w;\n      add_edge(g, a-1, b, 1, -w);\n    }\n    REP(i, 366) {\n      add_edge(g, i, i+1, 2, 0);\n    }\n    cout << -minimumCostFlow3(g, 0, 366).first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\nstatic const int Y = 365;\nstatic const int MAXN = 2*Y+2;\n\ntemplate <class Flow, class Cost>\nstruct edge\n{\n  int index;\n  Flow capacity, flow;\n  Cost cost;\n  int back;\n  edge(int i, Flow c, Cost d, int b) : index(i), capacity(c), flow(0), cost(d), back(b) {}\n};\n\ntemplate <class Flow, class Cost>\nvoid make_edge(vector<edge<Flow, Cost> > *g, int src, int dst, Flow c, Cost d)\n{\n  const int i = g[src].size(), j = g[dst].size();\n  g[src].push_back(edge<Flow, Cost>(dst, c, d, j));\n  g[dst].push_back(edge<Flow, Cost>(src, 0, -d, i));\n}\n\ntemplate <class Flow, class Cost>\npair<Flow, Cost>\nprimal_dual(vector<edge<Flow, Cost> > *g, int N, int source, int sink, int max_flow)/*{{{*/\n{\n  pair<Flow, Cost> total;\n  static Cost h[MAXN], dist[MAXN];\n  static pair<int,int> parent[MAXN];\n  for (Flow f = max_flow; f > 0; ) {\n    fill_n(dist, N, 1000000);\n    dist[source] = 0;\n    fill_n(parent, N, make_pair(-1, -1));\n    priority_queue<pair<Cost,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const Cost c = -q.top().first;\n      q.pop();\n      if (dist[n] < c) {\n        continue;\n      }\n      for (typename vector<edge<Flow, Cost> >::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (it->capacity - it->flow > 0) {\n          const Cost c2 = c + it->cost + h[n] - h[it->index];\n          if (c2 < dist[it->index]) {\n            dist[it->index] = c2;\n            parent[it->index] = make_pair(n, it - g[n].begin());\n            q.push(make_pair(-c2, it->index));\n          }\n        }\n      }\n    }\n    if (parent[sink].first == -1) {\n      break;\n    }\n\n    Flow e = f;\n    for (int i = sink; i != source; i = parent[i].first) {\n      const edge<Flow, Cost>& x = g[parent[i].first][parent[i].second];\n      e = min(e, x.capacity - x.flow);\n    }\n    for (int i = sink; i != source; i = parent[i].first) {\n      edge<Flow, Cost>& x = g[parent[i].first][parent[i].second];\n      total.second += e * x.cost;\n      x.flow += e;\n      g[x.index][x.back].flow -= e;\n    }\n    f -= e;\n    total.first += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n\n  return total;\n}/*}}}*/\n\nint main()\n{\n  int N;\n  while (scanf(\"%d\", &N) == 1 && N != 0) {\n    static vector<edge<int,int> > g[MAXN];\n    for (int i = 0; i < MAXN; i++) {\n      g[i].clear();\n    }\n    for (int i = 0; i < N; i++) {\n      int u, v, w;\n      scanf(\"%d %d %d\", &u, &v, &w);\n      make_edge(g, 2*u-1, 2*v, 1, -w);\n    }\n    for (int i = 0; i < MAXN-1; i++) {\n      make_edge(g, i, i+1, 2, 0);\n    }\n\n    printf(\"%d\\n\", -primal_dual(g, MAXN, 0, MAXN-1, 2).second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct D{\n\tint l, r, d;\n\tbool operator < ( const D &right ) const {\n\t\treturn r < right.r;\n\t}\n};\n\nint n;\nint memo[1001][366][366];\nD d[1000];\n\nvoid dfs(int idx, int i, int j, int sum){\n\tif(memo[idx][i][j] >= sum) return;\n\tmemo[idx][i][j] = sum;\n\tif(idx == n) return;\n\n\tauto p = d[idx];\n\n\t//cout << i << ' ' << j << ' ' << sum << endl;\n\t//cout << p.l << ' ' << p.r << ' ' << p.d << endl;\n\tidx++;\n\tif(p.l >= i){\n\t\tdfs(idx, p.r + 1, j, sum + p.d);\n\t}\n\tif(p.l >= j){\n\t\tdfs(idx, i, p.r + 1, sum + p.d);\n\t}\n\tdfs(idx, i, j, sum);\n}\n\n\nint main(){\n\twhile(cin >> n,n){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\trep(i,n){\n\t\t\tauto& p = d[i];\n\t\t\tcin >> p.l >> p.r >> p.d;\n\t\t\tp.l--; p.r--;\n\t\t}\n\t\tsort(d, d + n);\n\t\tdfs(0, 0, 0, 0);\n\n\t\tint ans = 0;\n\t\trep(i,400){\n\t\t\trep(j,400){\n\t\t\t\tans = max(ans, memo[n][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[366][366][366];\nvector< vector<pair<int, int> > > data;\nint N;\n\nint dfs(int idx, int n1, int n2){\n\tif(idx >= 366) return 0;\n\tif(n1 < idx) n1 = 0;\n\tif(n2 < idx) n2 = 0;\n\tif(dp[idx][n1][n2] != -1) return dp[idx][n1][n2];\n\tint ans = dfs(idx + 1, n1, n2);\n\tif(n1 < idx && n2 < idx){\n\t\tfor(int i = 0; i < data[idx].size(); i++){\n\t\t\tfor(int j = i + 1; j < data[idx].size(); j++){\n\t\t\t\tint n3 = data[idx][i].first;\n\t\t\t\tint n4 = data[idx][j].first;\n\t\t\t\tans = max(ans, dfs(idx + 1, max(n3, n4), min(n3, n4)) + data[idx][i].second + data[idx][j].second);\n\t\t\t}\n\t\t}\n\t}\n\tif(n2 < idx){\n\t\tfor(auto p : data[idx]){\n\t\t\tint n3 = p.first;\n\t\t\tans = max(ans, dfs(idx + 1, max(n1, n3), min(n1, n3)) + p.second);\t\n\t\t}\n\t}\n\t//printf(\"(%d %d %d) = %d\\n\", idx, n1, n2, ans);\n\treturn dp[idx][n1][n2] = ans;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tdata.assign(366, vector<pair<int ,int> >());\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint a, b, w;\n\t\t\tcin >> a >> b >> w;\n\t\t\tdata[a].push_back(pair<int, int>(b, w));\n\t\t}\n\t\tfor(int i = 0; i < 366; i++){\n\t\t\tfor(int j = 0; j < 366; j++){\n\t\t\t\tfor(int k = 0; k < 366; k++){\n\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(1, 0, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define MAX_V 400\n#define INF (1LL<<55)\nstruct edge{ll to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nll dist[MAX_V];\nll prevv[MAX_V];\nll preve[MAX_V];\n\nvoid add_edge(ll from,ll to,ll cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(ll)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(ll)G[from].size()-1});\n}\n\nll min_cost_flow(int s,int t,ll f){\n  ll res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==INF)continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    ll d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=d*dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nll a,b,c;\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    V=400;\n\n\n\n    for(int i=0;i<390;i++){\n      add_edge(i,i+1,2,0);\n    }\n\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      b++;      \n      add_edge(a,b,1,-c);\n    }\n    \n    ll ans=min_cost_flow(0,390,2);\n    cout<<-ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Application{\n  int i, j, w;\n  Application(int i, int j, int w):\n    i(i), j(j), w(w) {}\n};\n\nbool operator<(const Application& a, const Application& b){\n  return a.j != b.j ? a.j < b.j : a.i != b.i ? a.i < b.i : a.w < b.w;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    int s, e, w;\n    vector<Application> V(n,Application(0,0,0));\n    for(int i = 0; i < n; ++i){\n      cin >> s >> e >> w;\n      V[i] = Application(s,e,w);\n    }\n    sort(V.begin(), V.end());\n    int y = 366;\n    vector< vector<int> > DP(y,vector<int>(y,0));\n\n    for(int i = 0; i < n; ++i){\n      vector< vector<int> > DP_(y,vector<int>(y,0));\n      int s = V[i].i, e = V[i].j, w = V[i].w;\n      for(int j = 0; j < y; ++j){\n        for(int k = 0; k < y; ++k){\n          DP_[j][k] = max(DP[j][k], DP_[j][k]);\n          if(j < s) DP_[e][k] = max(DP_[e][k], DP[j][k] + w);\n          if(k < s) DP_[j][e] = max(DP_[j][e], DP[j][k] + w);\n          if(j > 0) DP_[j][k] = max(DP_[j][k], DP_[j-1][k]);\n          if(k > 0) DP_[j][k] = max(DP_[j][k], DP_[j][k-1]);\n        }\n      }\n      DP = DP_;\n      /*\n      cout << \"----------------------------------\" << endl;\n      for(int i = 0; i < 4; ++i){\n        for(int j = 0; j < 4; ++j){\n          printf(\"%02d \", DP[i][j]);\n        }cout << endl;\n      }\n      */\n    }\n    cout << DP[y-1][y-1] << endl;\n\n      \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct edge {int to,cap,cost,rev;};\nconst int MAX_V=366,INF=1e8;\nint V=366;\t\t\t//??£??\\!!\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init(){\n\trep(i,MAX_V) G[i].clear();\n}\nvoid add_edge(int from, int to, int cap, int cost){\n\tedge e1={to,cap,cost,G[to].size()},e2={from,0,-cost,G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nint min_cost_flow(int s, int t, int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\trep(v,V){\n\t\tfor(edge e:G[v]){\n\t\t\tif(e.cap>0) chmin(h[e.to],h[v]+e.cost);\n\t\t}\n\t}\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tinit();\n\t\trep(i,N){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tadd_edge(a-1,b,1,-c);\n\t\t}\n\t\trep(i,365) add_edge(i,i+1,2,0);\n\t\tcout<<-min_cost_flow(0,365,2)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\nstruct Event{\n  int s, e, c;\n  Event() {}\n  Event(int s, int e, int c) :\n    s(s), e(e), c(c) {}\n  bool operator < (const Event& E) const {\n    if(s != E.s) return s < E.s;\n    else         return e < E.e;\n  }\n};\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\nmap<S, int> memo;\nint dfs(int idx, int t1, int t2, vector<Event>& e){\n  if(idx == N) return 0;\n  if(t1 > t2) swap(t1, t2);\n  S state(idx, P(t1, t2));\n  if(memo.count(state)) return memo[state];\n  int res = dfs(idx + 1, t1, t2, e);\n  if(t2 < e[idx].s){\n    res = max(res, e[idx].c + dfs(idx + 1, t1, e[idx].e, e));\n  }else if(t1 < e[idx].s){\n    res = max(res, e[idx].c + dfs(idx + 1, e[idx].e, t2, e));\n  }\n  memo[state] = res;\n  return res;\n}\nint main(){\n  while(cin>>N && N){\n    vector<Event> events(N);\n    REP(i, N){\n      scanf(\"%d %d %d\", &events[i].s, &events[i].e, &events[i].c);\n    }\n    sort(events.begin(), events.end());\n    memo.clear();\n    cout<<dfs(0, 0, 0, events)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<vector<int> > ijw;\n    for(int i=0;i<n;i++){\n      int ii,j,w;\n      cin>>ii>>j>>w;\n      ijw.push_back({ii,j,w});\n    }\n    sort(begin(ijw),end(ijw));\n    int dp[367][367][2]={};\n    for(auto e:ijw){\n      for(int i=1;i<=365;i++){\n\tfor(int j=1;j<=365;j++){\n\t  if(i<=e[0]){\n\t    dp[e[1]+1][j][1]=max(dp[e[1]+1][j][1],dp[i][j][0]+e[2]);\n\t  }\n\t  if(j<=e[0]){\n\t    dp[i][e[1]+1][1]=max(dp[i][e[1]+1][1],dp[i][j][0]+e[2]);\n\t  }\n\t}\n      }\n      for(int i=1;i<=366;i++){\n\tfor(int j=1;j<=366;j++){\n\t  dp[i][j][0]=max(dp[i][j][0],dp[i][j][1]);\n\t}\n      }\n    }\n    cout<<*max_element(dp[0][0],dp[367][0])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=366,INF=1<<30;\nint dp[MAX][MAX],to[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        vector<pair<pair<int,int>,int>> S(N);\n        for(int i=0;i<N;i++){\n            cin>>S[i].fi.fi>>S[i].fi.se>>S[i].se;\n        }\n        sort(all(S),[](auto a,auto b){\n            return a.fi.se<b.fi.se;\n        });\n        \n        memset(dp,0,sizeof(dp));\n        memset(to,0,sizeof(to));\n        \n        for(int i=0;i<N;i++){\n            memset(to,0,sizeof(to));\n            \n            for(int j=0;j<MAX;j++){\n                for(int k=0;k<MAX;k++){\n                    if(j<S[i].fi.fi){\n                        chmax(to[S[i].fi.se][k],dp[j][k]+S[i].se);\n                    }\n                    if(k<S[i].fi.fi){\n                        chmax(to[j][S[i].fi.se],dp[j][k]+S[i].se);\n                    }\n                    chmax(to[j][k],dp[j][k]);\n                }\n            }\n            \n            for(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) dp[j][k]=to[j][k];\n        }\n        \n        int ans=0;\n        \n        for(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) chmax(ans,dp[j][k]);\n        \n        cout<<ans<<\"\\n\";\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 2005\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\n\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint a[MAX_V],b[MAX_V],w[MAX_V];\nvector<P> v;\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    \n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>w[i];\n      v.push_back(P(a[i],i));\n    }\n    sort(v.begin(),v.end());\n\n    int s=n*2,g=s+1;\n    \n    for(int i=0;i<n;i++){\n      add_edge(s,i*2,1,0);\n      add_edge(i*2,i*2+1,1,-w[i]);\n      add_edge(i*2+1,g,1,0);\n\n      for(int j=0;j<v.size();j++){\n\tif(i==v[j].second)continue;\n\tif(b[i]<v[j].first)\n\t  add_edge(i*2+1,v[j].second*2,1,0);\n      }\n    }\n\n    V=g+1;\n\n    cout<<-min_cost_flow(s,g,2)<<endl;\n    \n    for(int i=0;i<V;i++)G[i].clear();\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nmap<tuple<int, int, int>, int > dp;\nvector< vector<pair<int, int> > > data;\nint N;\n\nint dfs(int idx, int n1, int n2){\n\tif(idx >= 366) return 0;\n\tif(n1 < idx) n1 = 0;\n\tif(n2 < idx) n2 = 0;\n\tauto t = tuple<int, int, int>(idx, n1, n2);\n\tif(dp.count(t)) return dp[t];\n\tint ans = dfs(idx + 1, n1, n2);\n\tif(n1 < idx && n2 < idx){\n\t\tfor(int i = 0; i < data[idx].size(); i++){\n\t\t\tfor(int j = i + 1; j < data[idx].size(); j++){\n\t\t\t\tint n3 = data[idx][i].first;\n\t\t\t\tint n4 = data[idx][j].first;\n\t\t\t\tans = max(ans, dfs(idx + 1, max(n3, n4), min(n3, n4)) + data[idx][i].second + data[idx][j].second);\n\t\t\t}\n\t\t}\n\t}\n\tif(n2 < idx){\n\t\tfor(auto p : data[idx]){\n\t\t\tint n3 = p.first;\n\t\t\tans = max(ans, dfs(idx + 1, max(n1, n3), min(n1, n3)) + p.second);\t\n\t\t}\n\t}\n\t//printf(\"(%d %d %d) = %d\\n\", idx, n1, n2, ans);\n\n\treturn dp[t] = ans;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tdata.assign(366, vector<pair<int ,int> >());\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint a, b, w;\n\t\t\tcin >> a >> b >> w;\n\t\t\tdata[a].push_back(pair<int, int>(b, w));\n\t\t}\n\t\tdp.clear();\n\t\tcout << dfs(1, 0, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct edge{\n\tint to,cap,cost,rev;\n\tedge(int a,int b,int c,int d) : to(a),cap(b),cost(c),rev(d) {}\n};\nconst int MAX_V=366,INF=1e8;\nint V=366;\t\t\t//??£??\\!!\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init(){\n\trep(i,MAX_V) G[i].clear();\n}\nvoid add_edge(int from, int to, int cap, int cost){\n\tedge e1=edge(to,cap,cost,G[to].size()),e2=edge(from,0,-cost,G[from].size());\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nint min_cost_flow(int s, int t, int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\trep(v,V){\n\t\tfor(edge e:G[v]){\n\t\t\tif(e.cap>0) chmin(h[e.to],h[v]+e.cost);\n\t\t}\n\t}\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tinit();\n\t\trep(i,N){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tadd_edge(a-1,b,1,-c);\n\t\t}\n\t\trep(i,365) add_edge(i,i+1,2,0);\n\t\tcout<<-min_cost_flow(0,365,2)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nstruct edge { int to, cap, cost, rev;};\nconst int V = 2002;\nvector<edge> G[V];\nint dist[V];\nint prevv[V], preve[V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tedge e1={to, cap, cost, int(G[to].size())};\n    G[from].push_back(e1);\n\tedge e2={from, 0, -cost, int(G[from].size() - 1)};\n    G[to].push_back(e2);\n}\n\nconst int INF=INT_MAX/10;\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    while(f > 0){\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tREP(v,V){\n\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\tREP(i,G[v].size()){\n\t\t\t\t\tedge&e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost;\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INF) {\n\t\t\treturn INF;\n\t\t}\n        \n        int d = f;\n        for(int v = t; v != s; v = prevv[v]){\n            d = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n        f -= d;\n        res += d * dist[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nconst int start=2000,goal=2001,gap=1000;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tREP(i,V){\n\t\t\tG[i].clear();\n\t\t}\n\n\t\tvi s(n),e(n),w(n);\n\t\tREP(i,n){\n\t\t\tcin>>s[i]>>e[i]>>w[i];\n\t\t}\n\t\tREP(i,n){\n\t\t\tadd_edge(start,i,1,0);\n\t\t\tadd_edge(i+gap,goal,1,0);\n\t\t\tadd_edge(i,i+gap,1,-w[i]);\n\t\t\tREP(j,n){\n\t\t\t\tif(e[i]<s[j]){\n\t\t\t\t\tadd_edge(i+gap,j,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=min_cost_flow(start,goal,2);\n\t\tcout<<-ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\n\nstruct edge\n{\n\tint to,cap,cost,rev;\n};\nint nn=505;\nvector<edge>G[505];\nint dist[505];\nint prevv[505],preve[505];\n\nvoid add_edge(int from,int to,int cap,int cost)\n{\n\tG[from].pb((edge){to,cap,cost,G[to].size()});\n\tG[to].pb((edge){from,0,-cost,G[from].size()-1});\n}\n\nint mincost_maxflow(int s,int t,int f)\n{\n\tint res=0;\n\twhile(f>0)\n\t{\n\t\t//このnはフローを流すグラフの頂点数でありもとのグラフの頂点数ではない!!!!!!\n\t\tfill(dist,dist+nn,INF);\n\t\tdist[s]=0;\n\t\tbool upd=true;\n\t\twhile(upd)\n\t\t{\n\t\t\tupd=false;\n\t\t\tfor(int v=0;v<nn;v++)\n\t\t\t{\n\t\t\t\tif(dist[v]==INF) continue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost;\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tupd=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n == 0) return 0;\n\t\trep(i,505) G[i].clear();\n\t\trep(i,n){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\tadd_edge(a,b+1,1,-c);\n\t\t}\n\t\tfor(int i=0;i<400;i++) add_edge(500,i,2,0);\n\t\tfor(int i=0;i<400;i++) add_edge(i,501,2,0);\n\t\tfor(int i=0;i<400;i++) add_edge(i,i+1,2,0);\n\t\tcout << mincost_maxflow(500,501,2)*-1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct D{\n\tint l, r, d;\n\tbool operator < ( const D &right ) const {\n\t\treturn r < right.r;\n\t}\n};\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<D> d(n);\n\t\trep(i,n){\n\t\t\tauto& p = d[i];\n\t\t\tcin >> p.l >> p.r >> p.d;\n\t\t\tp.l--; p.r--;\n\t\t}\n\t\tsort(all(d));\n\n\t\tvector<vector<int>> cur(400, vector<int>(400,0));\n\t\trep(i,n){\n\t\t\tconst auto& p = d[i];\n\t\t\tfor (int j = 365; j >= 0; j--) {\n\t\t\t\tfor (int k = 365; k >= 0; k--) {\n\t\t\t\t\tif(j <= p.l){\n\t\t\t\t\t\tcur[p.r + 1][k] = max(cur[p.r + 1][k], cur[j][k] + p.d);\n\t\t\t\t\t}\n\t\t\t\t\tif(k <= p.l){\n\t\t\t\t\t\tcur[j][p.r + 1] = max(cur[j][p.r + 1], cur[j][k] + p.d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i,400){\n\t\t\trep(j,400){\n\t\t\t\tans = max(ans, cur[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector< pair<int,int> > sche[370];\nint dp[370][370];\n\nint solve(){\n\tfor(int i=0; i<370; i++){\n\t\tfor(int j=0; j<370; j++){\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tdp[1][1] = 0;\n\tfor(int day=1; day<366; day++){\n\t\tfor(int res=day; res<370; res++)if(dp[day][res]>=0){\n\t\t\tdp[day+1][max(day+1,res)] = max(dp[day+1][max(day+1,res)], dp[day][res]);\n\n\t\t\tif(day == res){\n\t\t\t\tfor(int i=0; i<(int)sche[day].size(); i++){\n\t\t\t\t\tint end = sche[day][i].first;\n\t\t\t\t\tdp[day+1][end+1] = max(dp[day+1][end+1], dp[day][res] + sche[day][i].second);\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<(int)sche[day].size(); i++){\n\t\t\t\t\tfor(int j=i+1; j<(int)sche[day].size(); j++){\n\t\t\t\t\t\tint w = sche[day][i].second + sche[day][j].second;\n\t\t\t\t\t\tint d1 = min(sche[day][i].first, sche[day][j].first) + 1, d2 = max(sche[day][i].first, sche[day][j].first) + 1;\n\t\t\t\t\t\tdp[d1][d2] = max(dp[d1][d2], dp[day][res] + w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0; i<(int)sche[day].size(); i++){\n\t\t\t\t\tint end = sche[day][i].first, w = sche[day][i].second;\n\t\t\t\t\tif(res < end + 1){\n\t\t\t\t\t\tdp[res][end+1] = max(dp[res][end+1], dp[day][res] + w);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[end+1][res] = max(dp[end+1][res], dp[day][res] + w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn *max_element(dp[366], dp[366]+370);\n}\n\nint main(){\n\tint N;\n\twhile(scanf(\"%d\",&N),N){\n\t\tfor(int i=0; i<370; i++){\n\t\t\tsche[i].clear();\n\t\t}\n\t\tfor(int i=0; i<N; i++){\n\t\t\tint st, en, we;\n\t\t\tscanf(\"%d%d%d\",&st,&en,&we);\n\t\t\tsche[st].push_back(make_pair(en,we));\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<utility>\nusing namespace std;\n\nstruct S{\n\tint j,w;\n\tS(){}\n\tS(int j,int w):j(j),w(w){}\n\tbool operator<(const S&rhv)const{return j<rhv.j;}\n};\nconst int Y = 365;\ntypedef pair<S,bool>P;\n\nvector<S>v[Y];\nint memo[Y][Y][Y];\nint Solve(int day,int when1,int when2)\n{\n\tif(day >= Y)\n\t\treturn 0;\n\tif(when1 > when2)\n\t\tswap(when1, when2);\n\tint &ref = memo[day][when1][when2];\n\tif(ref >= 0)\n\t\treturn ref;\n\n\tref = Solve(day+1,when1,when2);\n\n\tif(day >= when1)\n\t{\n\t\tfor(int i=0;i<v[day].size();++i)\n\t\t{\n\t\t\tS s=v[day][i];\n\t\t\tref = max(ref, s.w+Solve(day+1,s.j+1,when2));\n\n\t\t\tif(day < when2)continue;\n\t\t\tfor(int j=i+1;j<v[day].size();++j)\n\t\t\t{\n\t\t\t\tS s2=v[day][j];\n\t\t\t\tref = max(ref, s.w+s2.w + Solve(day+1, s.j+1,s2.j+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn ref;\n}\n\nint main()\n{\n\tint n,i,j,w;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tfor(i=0;i<Y;++i)\n\t\t\tv[i].clear();\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&i,&j,&w);\n\t\t\t--i,--j;\n\t\t\tv[i].push_back(S(j,w));\n\t\t}\n\t\tfor(i=0;i<Y;++i)\n\t\t\tsort(v[i].begin(),v[i].end());\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tprintf(\"%d\\n\",Solve(0,0,0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct D{\n\tint l, r, d;\n\tbool operator < ( const D &right ) const {\n\t\treturn r < right.r;\n\t}\n};\n\nint n;\nint memo[1001][367][367];\nD d[1000];\n\nvoid dfs(int idx, int i, int j, int sum){\n\tif(memo[idx][i][j] >= sum) return;\n\tmemo[idx][i][j] = sum;\n\tif(idx == n) return;\n\n\tauto p = d[idx];\n\n\t//cout << i << ' ' << j << ' ' << sum << endl;\n\t//cout << p.l << ' ' << p.r << ' ' << p.d << endl;\n\tidx++;\n\tif(p.l >= i){\n\t\tdfs(idx, p.r + 1, j, sum + p.d);\n\t}\n\tif(p.l >= j){\n\t\tdfs(idx, i, p.r + 1, sum + p.d);\n\t}\n\tdfs(idx, i, j, sum);\n}\n\n\nint main(){\n\twhile(cin >> n,n){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\trep(i,n){\n\t\t\tauto& p = d[i];\n\t\t\tcin >> p.l >> p.r >> p.d;\n\t\t\tp.l--; p.r--;\n\t\t}\n\t\tsort(d, d + n);\n\t\tdfs(0, 0, 0, 0);\n\n\t\tint ans = 0;\n\t\trep(i,367){\n\t\t\trep(j,367){\n\t\t\t\tans = max(ans, memo[n][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nsigned main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvvi dp(366,vi(366,-inf));\n\t\tdp[0][0]=0;\n\t\tvvp G(366);\n\t\trep(i,n){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;\n\t\t\tG[a].pb({b,c});\n\t\t}\n\t\trep(i,366){\n\t\t\trep(k,G[i].size())for(int j=366-1;j>=i;j--){\n\t\t\t\tif(dp[i][j]+inf){\n\t\t\t\t\tint s=G[i][k].first,t=j;\n\t\t\t\t\tif(s>t)swap(s,t);\n\t\t\t\t\tcmax(dp[s][t],dp[i][j]+G[i][k].second);\n\t\t\t\t\tt++;\n\t\t\t\t\tif(t<366)cmax(dp[s][t],dp[i][j]+G[i][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,366){\n\t\t\t\tif(i+1<365&&i!=j)cmax(dp[i+1][j],dp[i][j]);\n\t\t\t\tif(i+1<365&&i==j)cmax(dp[i+1][j+1],dp[i][j]);\n\t\t\t}\n\t\t}\n//\t\trep(i,10){rep(j,6)cout<<\" \"<<dp[i][j];cout<<endl;}\n\t\tint out=-inf;\n\t\trep(i,366)rep(j,366)cmax(out,dp[i][j]);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define per(i, n) for(int i = (int)(n); i >= 0; i--)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nint dp[370][370];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N;\n  while(cin >> N, N) {\n    vector< tuple<int, int, int> > app;\n    rep(i, N) {\n      int a, b, w; cin >> a >> b >> w;\n      app.emplace_back(a, b+1, w);\n    }\n\n    sort(all(app));\n\n    memset(dp, 0, sizeof(dp));\n\n    rep(i, N) {\n      int a, b, w; tie(a, b, w) = app[i];\n      per(j, 370-1) per(k, 370-1) {\n\tif(j <= a) dp[b][k] = max(dp[b][k], dp[j][k] + w);\n\tif(k <= a) dp[j][b] = max(dp[j][b], dp[j][k] + w);\n      }\n    }\n\n    int ans = 0;\n    rep(i, 370) rep(j, 370) ans = max(ans, dp[i][j]);\n\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define MAX_D\t(365)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\n/* classes */\n\nclass Req {\npublic:\n  int d0, d1, w;\n\n  Req(int _d0 = 0, int _d1 = 0, int _w = 0) {\n    d0 = _d0; d1 = _d1; w = _w;\n  }\n\n  bool operator <(const Req& r) const {\n    if (d0 != r.d0) return d0 < r.d0;\n    return d1 < r.d1;\n  }\n};\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    vector<Req> reqs(n);\n    int max_d = 0;\n\n    for (int i = 0; i < n; i++) {\n      cin >> reqs[i].d0 >> reqs[i].d1 >> reqs[i].w;\n      if (max_d < reqs[i].d1) max_d = reqs[i].d1;\n    }\n\n    sort(reqs.begin(), reqs.end());\n\n    int maxws[MAX_D + 1][MAX_D + 1], maxws0[MAX_D + 1][MAX_D + 1];\n    memset(maxws, 0, sizeof(maxws));\n\n    for (int k = 0; k < n; k++) {\n      int d0 = reqs[k].d0;\n      int d1 = reqs[k].d1;\n      int w = reqs[k].w;\n      memcpy(maxws0, maxws, sizeof(maxws));\n\n      for (int i = 1; i <= max_d; i++)\n\tfor (int j = 1; j <= max_d; j++) {\n\t  if (i == j && i == d1) {\n\t    int wi = maxws[d0 - 1][j] + w;\n\t    int wj = maxws[i][d0 - 1] + w;\n\t    if (maxws0[i][j] < wi) maxws0[i][j] = wi;\n\t    if (maxws0[i][j] < wj) maxws0[i][j] = wj;\n\t  }\n\t  else if (i == d1) {\n\t    int wi = maxws[d0 - 1][j] + w;\n\t    if (maxws0[i][j] < wi) maxws0[i][j] = wi;\n\t  }\n\t  else if (j == d1) {\n\t    int wj = maxws[i][d0 - 1] + w;\n\t    if (maxws0[i][j] < wj) maxws0[i][j] = wj;\n\t  }\n\n\t  int wij0 = maxws0[i - 1][j];\n\t  int wij1 = maxws0[i][j - 1];\n\t  if (maxws0[i][j] < wij0) maxws0[i][j] = wij0;\n\t  if (maxws0[i][j] < wij1) maxws0[i][j] = wij1;\n\t}\n\n      memcpy(maxws, maxws0, sizeof(maxws));\n    }\n\n    cout << maxws[max_d][max_d] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int a, b, w;\n    bool operator<(const Data& d) const{\n        return a < d.a;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Data> d(n);\n        for(int i=0; i<n; ++i)\n            cin >> d[i].a >> d[i].b >> d[i].w;\n        sort(d.begin(), d.end());\n\n        vector<vector<int> > dp(366, vector<int>(366, 0));\n        for(int i=0; i<n; ++i){\n            for(int j=365; j>=0; --j){\n                for(int k=365; k>=0; --k){\n                    if(j < d[i].a)\n                        dp[d[i].b][k] = max(dp[d[i].b][k], dp[j][k] + d[i].w);\n                    if(k < d[i].a)\n                        dp[j][d[i].b] = max(dp[j][d[i].b], dp[j][k] + d[i].w);\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<366; ++i){\n            for(int j=0; j<366; ++j){\n                ret = max(ret, dp[i][j]);\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int DPSIZE = 370;\n\nstruct S {\n  int i, j, w;\n  bool operator < (const S &s) const {\n    return j < s.j;\n  }\n};\n\nint N;\nvector<S> V;\nint dp[2][DPSIZE][DPSIZE];\n\nint main() {\n  while(cin >> N && N) {\n    V.clear();\n    for(int i = 0; i < N; ++i) {\n      S s;\n      cin >> s.i >> s.j >> s.w;\n      V.push_back(s);\n    }\n    sort(V.begin(), V.end());\n    fill(dp[0][0], dp[2][0], 0);\n    for(int i = 0; i < N; ++i) {\n      int p = i % 2;\n      int q = 1 - p;\n      for(int a = 0; a < DPSIZE; ++a) {\n        for(int b = 0; b < DPSIZE; ++b) {\n          dp[q][a][b] = dp[p][a][b];\n        }\n      }\n      for(int a = 0; a < DPSIZE; ++a) {\n        for(int b = 0; b < DPSIZE; ++b) {\n          if(a < V[i].i) {\n            dp[q][V[i].j][b] = max(dp[q][V[i].j][b], dp[p][a][b] + V[i].w);\n          }\n          if(b < V[i].i) {\n            dp[q][a][V[i].j] = max(dp[q][a][V[i].j], dp[p][a][b] + V[i].w);\n          }\n        }\n      }\n    }\n    int res = 0;\n    for(int a = 0; a < DPSIZE; ++a) {\n      for(int b = 0; b < DPSIZE; ++b) {\n        res = max(res, dp[N%2][a][b]);\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 2005\n#define INF (1e9)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\n\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nll dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nll min_cost_flow(int s,int t,int f){\n  ll res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint a[MAX_V],b[MAX_V],w[MAX_V];\nvector<P> v;\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    \n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>w[i];\n      v.push_back(P(a[i],i));\n    }\n    sort(v.begin(),v.end());\n\n    int s=n*2,g=s+1;\n    \n    for(int i=0;i<n;i++){\n      add_edge(s,i*2,1,0);\n      add_edge(i*2,i*2+1,1,-w[i]);\n      add_edge(i*2+1,g,1,0);\n\n      for(int j=0;j<v.size();j++){\n\tif(i==v[j].second)continue;\n\tif(b[i]<v[j].first)\n\t  add_edge(i*2+1,v[j].second*2,1,0);\n      }\n    }\n\n    V=g+1;\n\n    cout<<-min_cost_flow(s,g,2)<<endl;\n    \n    for(int i=0;i<V;i++)G[i].clear();\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nstruct T{\n  int s,e,c;\n  T(int _s,int _e,int _c){\n    s = _s; e = _e; c = _c;\n  };\n\n  bool operator < (const T& t)const{\n    return s < t.s;\n  }\n};\n\nconst int MAX_N = 1001;\nconst int DAY = 366;\nint N;\n\nint dp[MAX_N][DAY][DAY];\nvector<T>vec;\n\nvoid input(){\n  for(int i = 0 ; i < N ; i++){\n    int s,e,c;\n    cin >> s >> e >> c;\n    vec.push_back(T(s,e,c));\n  }\n  sort(vec.begin(),vec.end());\n  /*\n  for(int i = 0 ; i < vec.size() ; i++){\n    cout << \"i = \" << i << \" vec[i].s = \" << vec[i].s << endl;\n  }\n  */\n}\n\nvoid init(){\n  vec.clear();\n  for(int i = 0 ; i < MAX_N ; i++){\n    for(int j = 0 ; j < DAY ; j++){\n      for(int k = 0 ; k < DAY ; k++){\n\tdp[i][j][k] = 0;\n      }\n    }\n  }\n}\n\nvoid solve(){\n  init();\n  input();\n\n  int res = 0;\n\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < DAY ; j++){\n      for(int k = 0 ; k < DAY ; k++){\n\tdp[i+1][j][k] = max(dp[i+1][j][k],dp[i][j][k]);\n\tint a,b,c; a = b = c = 0;\n\tif(j < vec[i].s)a = dp[i+1][vec[i].e][k] = max(dp[i+1][vec[i].e][k],dp[i][j][k] + vec[i].c);\n\tif(k < vec[i].s)b = dp[i+1][j][vec[i].e] = max(dp[i+1][j][vec[i].e],dp[i][j][k] + vec[i].c);\n\tres = max(res,max(a,max(b,c)));\n      }\n    }\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> N,N){\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    struct E {\n        int from, to, w;\n        E(int from, int to, int w) : from(from), to(to), w(w) {}\n        bool operator<(const E& e) const {\n            return to < e.to;\n        }\n    };\n\n    int N;\n    vector<E> P;\n    bool input() {\n        cin >> N;\n        if (N == 0) return false;\n        P.clear();\n        for (int i = 0; i < N; i++) {\n            int x, y, w; cin >> x >> y >> w;\n            P.push_back(E(x, y, w));\n        }\n        return true;\n    }\n\n    const int INF = 1<<28;\n    void solve() {\n        sort(P.begin(), P.end());\n        static int dp[2][367][367];\n        memset(dp, 0, sizeof(dp));\n        int ans = 0;\n        for (int i = 0; i < N; i++) {\n            const E& e = P[i];\n            for (int j = 0; j <= 366; j++) {\n                dp[(i + 1) & 1][j][e.to + 1] = max(dp[i & 1][j][e.to + 1], dp[i & 1][j][e.from] + e.w);\n                for (int k = e.to + 2; k <= 366; k++) {\n                    dp[(i + 1) & 1][j][k] = max(dp[(i + 1) & 1][j][e.to + 1], dp[(i + 1) & 1][j][k]);\n                }\n            }\n            for (int j = 0; j <= 366; j++) {\n                dp[(i + 1) & 1][e.to + 1][j] = max(dp[i & 1][e.to + 1][j], dp[i & 1][e.from][j] + e.w);\n                for (int k = e.to + 2; k <= 366; k++) {\n                    dp[(i + 1) & 1][k][j] = max(dp[(i + 1) & 1][e.to + 1][j], dp[(i + 1) & 1][k][j]);\n                }\n            }\n        }\n        cout << dp[(N + 1) & 1][366][366] << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef tuple<int, int , int> T;\nint dp[366][366];\nint dp2[366][366];\nint main() {\nwhile(1){\n\tmemset(dp,0,sizeof(dp));\n\tmemset(dp2,0,sizeof(dp2));\n\tint ret=0;\n\tT in[1000];\n\tint n;\n\tcin >> n;\n\tif(n==0)return 0;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tin[i]=T(b,a,w);\n\t}\n\tsort(in,in+n);\n\tfor(int k=0;k<n;k++){\n\t\tint a=get<1>(in[k]);\n\t\tint b=get<0>(in[k]);\n\t\tint w=get<2>(in[k]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i;j<=b;j++){\n\t\t\t\tif(j<a){\n\t\t\t\t\tdp2[i][b]=max(dp2[i][b],dp[i][j]+w);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[j][b]=max(dp2[j][b],dp[i][j]+w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=b;j++){\n\t\t\tdp[j][b]=max(dp[j][b],dp2[j][b]);\n\t\t\tret=max(ret,dp[j][b]);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\nstatic const int Y = 365;\nstatic const int MAXN = 2*Y+2;\n\ntemplate <class Flow, class Cost>\nstruct edge\n{\n  int index;\n  Flow capacity, flow;\n  Cost cost;\n  int back;\n  edge(int i, Flow c, Cost d, int b) : index(i), capacity(c), flow(0), cost(d), back(b) {}\n};\n\ntemplate <class Flow, class Cost>\nvoid make_edge(vector<edge<Flow, Cost> > *g, int src, int dst, Flow c, Cost d)\n{\n  const int i = g[src].size(), j = g[dst].size();\n  g[src].push_back(edge<Flow, Cost>(dst, c, d, j));\n  g[dst].push_back(edge<Flow, Cost>(src, 0, -d, i));\n}\n\ntemplate <class Flow, class Cost>\npair<Flow, Cost>\nprimal_dual(vector<edge<Flow, Cost> > *g, int N, int source, int sink, int max_flow)/*{{{*/\n{\n  pair<Flow, Cost> total;\n  static Cost h[MAXN], dist[MAXN];\n  static pair<int,int> parent[MAXN];\n  for (Flow f = max_flow; f > 0; ) {\n    fill_n(dist, N, 1000000);\n    dist[source] = 0;\n    fill_n(parent, N, make_pair(-1, -1));\n    priority_queue<pair<Cost,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const Cost c = -q.top().first;\n      q.pop();\n      if (dist[n] < c) {\n        continue;\n      }\n      for (typename vector<edge<Flow, Cost> >::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (it->capacity - it->flow > 0) {\n          const Cost c2 = c + it->cost + h[n] - h[it->index];\n          if (c2 < dist[it->index]) {\n            dist[it->index] = c2;\n            parent[it->index] = make_pair(n, it - g[n].begin());\n            q.push(make_pair(-c2, it->index));\n          }\n        }\n      }\n    }\n    if (parent[sink].first == -1) {\n      break;\n    }\n\n    Flow e = f;\n    for (int i = sink; i != source; i = parent[i].first) {\n      const edge<Flow, Cost>& x = g[parent[i].first][parent[i].second];\n      e = min(e, x.capacity - x.flow);\n    }\n    for (int i = sink; i != source; i = parent[i].first) {\n      edge<Flow, Cost>& x = g[parent[i].first][parent[i].second];\n      total.second += e * x.cost;\n      x.flow += e;\n      g[x.index][x.back].flow -= e;\n    }\n    f -= e;\n    total.first += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n\n  return total;\n}/*}}}*/\n\nint main()\n{\n  int N;\n  while (scanf(\"%d\", &N) == 1 && N != 0) {\n    static vector<edge<int,int> > g[MAXN];\n    for (int i = 0; i < MAXN; i++) {\n      g[i].clear();\n    }\n    static pair<int,int> period[1000];\n    static const int source = 2*Y;\n    static const int sink = 2*Y+1;\n    for (int i = 0; i < N; i++) {\n      int u, v, w;\n      scanf(\"%d %d %d\", &u, &v, &w);\n      --u;  --v;\n      period[i].first = u;\n      period[i].second = v;\n      make_edge(g, source, u, 1, 0);\n      make_edge(g, u, v+Y, 1, -w);\n      make_edge(g, v+Y, sink, 1, 0);\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        if (period[i].second < period[j].first) {\n          make_edge(g, period[i].second+Y, period[j].first, 1, 0);\n        }\n      }\n    }\n\n    printf(\"%d\\n\", -primal_dual(g, MAXN, source, sink, 2).second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<unordered_map>\nusing namespace std;\n\nstruct S{\n\tint j,w;\n\tS(){}\n\tS(int j,int w):j(j),w(w){}\n\tbool operator<(const S&rhv)const{return j<rhv.j;}\n};\nconst int Y = 365;\ntypedef pair<S,bool>P;\n\nvector<S>v[Y];\nunordered_map<int,int>memo;\nint Solve(int day,int when1,int when2)\n{\n\tif(day >= Y)\n\t\treturn 0;\n\tif(when1 > when2)\n\t\tswap(when1, when2);\n\tif(day < when1)\n\t\tday = when1;\n\n\tint key = ((day*Y)+when1)*Y+when2;\n\tauto ite = memo.find(key);\n\tif(ite != memo.end())\n\t\treturn ite->second;\n\n\tint ref = Solve(day+1,when1,when2);\n\tif(day >= when1)\n\t{\n\t\tfor(int i=0;i<v[day].size();++i)\n\t\t{\n\t\t\tS s=v[day][i];\n\t\t\tref = max(ref, s.w+Solve(day+1,s.j+1,when2));\n\t\t\tif(day < when2)continue;\n\t\t\tfor(int j=i+1;j<v[day].size();++j)\n\t\t\t{\n\t\t\t\tS s2=v[day][j];\n\t\t\t\tref = max(ref, s.w+s2.w + Solve(day+1,s.j+1,s2.j+1));\n\t\t\t}\n\t\t}\n\t}\n\n\tmemo[key] = ref;\n\treturn ref;\n}\n\nint main()\n{\n\tint n,i,j,w;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tfor(i=0;i<Y;++i)\n\t\t\tv[i].clear();\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&i,&j,&w);\n\t\t\t--i,--j;\n\t\t\tv[i].push_back(S(j,w));\n\t\t}\n\t\tfor(i=0;i<Y;++i)\n\t\t\tsort(v[i].begin(),v[i].end());\n\t\tmemo.clear();\n\t\tprintf(\"%d\\n\",Solve(0,0,0));\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nvector<array<int, 3> > input;\nmap<array<int, 3>, int> dp;\nint N;\nint dfs(int i, int n1, int n2){\n\tif(i >= N) return 0;\n\tif(n1 < input[i][0]) n1 = 0;\n\tif(n2 < input[i][0]) n2 = 0;\n\tif(dp.count({i, n1, n2})) return dp[{i, n1, n2}];\t\n\tint ans = dfs(i + 1, n1, n2);\n\tint a2 = 0;\n\tif(n1 < input[i][0]){\n\t\tn1 = input[i][1];\n\t\ta2 += input[i][2];\n\t}else if(n2 < input[i][0]){\n\t\tn2 = input[i][1];\n\t\ta2 += input[i][2];\n\t}\n\tans = max(ans, dfs(i + 1, max(n1, n2), min(n1, n2)) + a2);\n\tdp[{i, n1, n2}] = ans;\n\treturn ans;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tinput.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint a, b, w;\n\t\t\tcin >> a >> b >> w;\n\t\t\tinput.push_back({a, b, w});\n\t\t}\n\t\tsort(input.begin(), input.end());\n\t\tdp.clear();\n\t\tcout << dfs(0, 0, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::sort;\nusing std::max;\n\nint dp[400][400];\nstruct apply{\n    int a, b, c;\n}applys[10000];\nbool comp(apply a, apply b){return a.a < b.a;}\n\nint main(){\n    int N;\n    while(scanf(\"%d\", &N) && N){\n        for(int i=0 ; i<=366 ; i++)\n            for(int j=0 ; j<=366 ; j++)\n                dp[i][j] = 0;\n        for(int i=0 ; i<N ; i++){\n            scanf(\"%d %d %d\", &applys[i].a, &applys[i].b, &applys[i].c);\n        }\n        sort(applys, applys+N, comp);\n        int ptr = 0;\n        for(int i=0;i<366;i++){\n            while(ptr<N && applys[ptr].a==i){\n                int k = applys[ptr].b+1;\n                int c = applys[ptr].c;\n                for(int j=366;j>=i;j--){\n                    dp[k][j] = max(dp[k][j], dp[i][j]+c);\n                    dp[j][k] = max(dp[j][k], dp[j][i]+c);\n                }\n                ptr++;\n            }\n            for(int j=i;j<=366;j++){\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n                dp[j][i+1] = max(dp[j][i+1], dp[j][i]);\n            }\n            dp[i+1][i+1] = max(dp[i+1][i+1], dp[i][i+1]);\n        }\n        printf(\"%d\\n\", dp[366][366]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n\nconst int INF = 1e18;\nconst int MAX_D = 365;\nint n,dp[400][400];\n\nvoid solve(){\n\tusing P = pair<int,int>;\n\tvector<P> dat[400];\n\tfor(int i = 0;i < n;i++){\n\t\tint l,r,w;\n\t\tcin >> l >> r >> w;\n\t\tdat[r].emplace_back(l - 1,w);\n\t}\n\tfor(int i = 0;i <= MAX_D;i++){\n\t\tfor(int j = 0;j <= MAX_D;j++){\n\t\t\tdp[i][j] = -INF;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\tfor(int i = 0;i <= MAX_D;i++){\n\t\tfor(int j = 0;j <= MAX_D;j++){\n\t\t\tif(i) chmax(dp[i][j],dp[i - 1][j]);\n\t\t\tif(j) chmax(dp[i][j],dp[i][j - 1]);\n\t\t\tif(i > j){\n\t\t\t\tfor(P p : dat[i]){\n\t\t\t\t\tchmax(dp[i][j],dp[p.first][j] + p.second);\n\t\t\t\t}\n\t\t\t}else if(i < j){\n\t\t\t\tfor(P p : dat[j]){\n\t\t\t\t\tchmax(dp[i][j],dp[i][p.first] + p.second);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int k = 0;k < dat[i].size();k++){\n\t\t\t\t\tfor(int l = k + 1;l < dat[i].size();l++){\n\t\t\t\t\t\tchmax(dp[i][j],dp[dat[i][k].first][dat[i][l].first] + dat[i][k].second + dat[i][l] .second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i = 0;i <= MAX_D;i++){\n\t\tfor(int j = 0;j <= MAX_D;j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tcout << dp[MAX_D][MAX_D] << endl;\n}\n\nsigned main(){\n\twhile(cin >> n,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef int F;\n\nconst int MAXV = 410;\nconst int MAXE = 5005;\nconst F MAXF = 1<<29;\nconst int MAXH = 1<<29;\n\nint last[MAXV], prev[MAXE], to[MAXE], h[MAXV], pv[MAXV], pe[MAXV];\nF cap[MAXE], flow[MAXE], cost[MAXE], d[MAXV];\n\nstruct St { int v; int c; int f; int fe; };\nbool operator<(const St &s, const St &t) {\n    return (s.c != t.c)? s.c>t.c : s.v < t.v;\n}\n\nstruct MinCostFlow {\n    int V, E;\n    MinCostFlow(int n) : V(n), E(0) { memset(last, -1, sizeof(last)); }\n    inline F rcost(const int s, const int e) {\n        return d[s] + cost[e] + h[s] - h[to[e]];\n    }\n\n    void add_edge(int f, int t, F ca, F co) { // from, to, cap, cost\n        to[E] = t; prev[E] = last[f]; last[f] = E;\n        cap[E] = ca; cost[E] = co; flow[E] = 0; E++;\n        to[E] = f; prev[E] = last[t]; last[t] = E;\n        cap[E] = flow[E] = 0; cost[E] = -co; E++;\n    }\n    void calc_potential(int s) {\n        for (int i=0; i<V; ++i) h[i] = MAXH;\n        h[s] = 0;\n        for (int k=0; k<V; ++k)\n            for (int i=0; i<V; ++i)\n                for (int e = last[i]; e != -1; e = prev[e])\n                    if (cap[e] > 0)\n                        h[to[e]] = min(h[to[e]], h[i] + cost[e]);\n    }\n    void init_d() { for (int i=0; i<V; ++i) d[i] = MAXF; }\n\n    pair<F, F> minimum_cost_flow(int s, int t, F max) {\n        F total_flow = 0, total_cost = 0;\n        calc_potential(s);\n        for (F r = max; r > 0; ) {\n            // do dijkstra\n            init_d(); d[s] = 0;\n            memset(pv, -1, sizeof(pv));\n            priority_queue<St> q;\n            for (q.push((St){s,0,s,-1}); !q.empty(); ) {\n                St s = q.top(); q.pop();\n                if (pv[s.v] != -1) continue;\n                pv[s.v] = s.f; pe[s.v] = s.fe;\n                for (int e = last[s.v]; e != -1; e = prev[e]) {\n                    if (cap[e] - flow[e] > 0) {\n                        if (d[to[e]] > rcost(s.v, e)) {\n                            d[to[e]] = rcost(s.v, e);\n                            q.push((St){to[e], d[to[e]], s.v, e});\n                        }\n                    }\n                }\n            }\n\n            if (pv[t] == -1) break;\n            F f = r;\n            for (int u = t; u != s; u = pv[u])\n                f = min(f, cap[pe[u]] - flow[pe[u]]);\n            for (int u = t; u != s; u = pv[u]) {\n                total_cost += f * cost[pe[u]];\n                flow[pe[u]] += f; flow[pe[u]^1] -= f;\n            }\n            r -= f;\n            total_flow += f;\n            for (int u=0; u<V; ++u) if (h[u] != MAXH) h[u] += d[u];\n        }\n        return make_pair(total_cost, total_flow);\n    }\n};\n\nint main() {\n    int n, a, b, w;\n    while(scanf(\"%d\", &n), n) {\n        MinCostFlow mcf(366);\n        for (int i=0; i<n; ++i) {\n            scanf(\"%d %d %d\", &a, &b, &w); a--;\n            mcf.add_edge(a, b, 1, -w);\n        }\n        for (int i=0; i<365; ++i)\n            mcf.add_edge(i, i+1, 2, 0);\n        printf(\"%d\\n\", -(mcf.minimum_cost_flow(0, 365, 2).first));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntemplate<class T>\nstruct interval{\n\tT a,b,w;\n\tinterval():a(0),b(0){}\n\tinterval(const T &a,const T &b):a(a<b?a:b),b(a<b?b:a){}\n\tbool operator<(const interval &I)const{ return b<I.b || b==I.b && a<I.a; }\n};\n\nconst int V_MAX=2003;\nconst int CAPA_INF=1<<29;\nconst int COST_INF=1<<29;\n\ntemplate<class T,class U>\nstruct edge{\n\tint v,rev;\n\tT capa;\n\tU cost;\n\tT flow;\n};\n\ntemplate<class T,class U>\nvoid add_directed_edge(vector< edge<T,U> > *G,int u,int v,T capa,U cost){\n\tG[u].push_back((edge<T,U>){v,G[v].size()  ,capa, cost,0});\n\tG[v].push_back((edge<T,U>){u,G[u].size()-1,   0,-cost,0});\n}\n\ntemplate<class T,class U>\npair<T,U> augment(int n,vector< edge<T,U> > *G,int s,int t,U *pot,bool fir){\n\tstatic int pre[V_MAX];\n\tstatic U d[V_MAX];\n\trep(u,n) d[u]=(u==s?0:COST_INF);\n\n\tbool ok;\n\tif(fir){\n\t\t// Bellman-Ford\n\t\twhile(1){\n\t\t\tbool end=true;\n\t\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\t\tedge<T,U> &e=G[u][i];\n\t\t\t\tif(e.capa-e.flow>0 && d[u]<COST_INF && d[u]+e.cost<d[e.v]){\n\t\t\t\t\td[e.v]=d[u]+e.cost;\n\t\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\t\tend=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end) break;\n\t\t}\n\t\tok=(d[t]<COST_INF);\n\t}\n\telse{\n\t\t// Dijkstra\n\t\tok=false;\n\t\tpriority_queue< pair<U,int> > Q; Q.push(make_pair(0,s));\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.top().second;\n\t\t\tU cost=-Q.top().first; Q.pop();\n\n\t\t\tif(cost<d[u]) continue;\n\t\t\tif(u==t) ok=true;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tedge<T,U> &e=G[u][i];\n\t\t\t\tU cost2=cost+e.cost+pot[u]-pot[e.v];\n\t\t\t\tif(e.capa-e.flow>0 && cost2<d[e.v]){\n\t\t\t\t\td[e.v]=cost2;\n\t\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\t\tQ.push(make_pair(-cost2,e.v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!ok) return make_pair(0,0);\n\n\tT water=CAPA_INF;\n\tfor(int v=t;v!=s;){\n\t\tedge<T,U> &e1=G[v][pre[v]];\n\t\tedge<T,U> &e2=G[e1.v][e1.rev];\n\t\twater=min(water,e2.capa-e2.flow);\n\t\tv=e1.v;\n\t}\n\n\tU cost=0;\n\tfor(int v=t;v!=s;){\n\t\tedge<T,U> &e1=G[v][pre[v]];\n\t\tedge<T,U> &e2=G[e1.v][e1.rev];\n\t\te1.flow-=water;\n\t\te2.flow+=water;\n\t\tcost+=water*e2.cost;\n\t\tv=e1.v;\n\t}\n\n\trep(u,n) pot[u]+=d[u];\n\n\treturn make_pair(water,cost);\n}\n\ntemplate<class T,class U>\npair<T,U> primal_dual(int n,vector< edge<T,U> > *G,int s,int t){\n\tstatic U pot[V_MAX];\n\trep(u,n) pot[u]=0;\n\n\tT ans1=0;\n\tU ans2=0;\n\tfor(bool fir=true;;fir=false){\n\t\tpair<T,U> tmp=augment(n,G,s,t,pot,fir);\n\t\tif(tmp.first==0) break;\n\t\tans1+=tmp.first;\n\t\tans2+=tmp.second;\n\t}\n\treturn make_pair(ans1,ans2);\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tinterval<int> I[1000];\n\t\trep(i,n) scanf(\"%d%d%d\",&I[i].a,&I[i].b,&I[i].w);\n\n\t\tsort(I,I+n);\n\n\t\tint s=0,t=2*n+1;\n\t\tvector< edge<int,int> > G[V_MAX];\n\t\trep(u,n) for(int v=u+1;v<n;v++) if(I[u].b<I[v].a) {\n\t\t\tadd_directed_edge(G,1+2*u+1,1+2*v,1,-I[v].w);\n\t\t}\n\t\trep(u,n){\n\t\t\tadd_directed_edge(G,s,1+2*u,1,-I[u].w);\n\t\t\tadd_directed_edge(G,1+2*u,1+2*u+1,1,0);\n\t\t\tadd_directed_edge(G,1+2*u+1,t,1,0);\n\t\t}\n\t\tint tt=t+1;\n\t\tadd_directed_edge(G,t,tt,2,0);\n\n\t\tprintf(\"%d\\n\",-primal_dual(2*n+3,G,s,tt).second);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight capacity, cost;\n  int rev;\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, Weight cap, Weight cost) {\n  g[s].push_back((Edge){s,d,cap,cost,g[d].size()});\n  g[d].push_back((Edge){d,s,0,-cost,g[s].size()-1});\n}\n\npair<Weight, Weight> minimumCostFlow3(Graph g, int s, int t) {\n  const int n = g.size();\n  pair<Weight, Weight> total; // (cost, flow)\n\n  for (int F = INF; F > 0;) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> pv(n), pe(n);\n    bool update = 1;\n    while(update) {\n      update = 0;\n      REP(i, n) if (d[i] < INF) REP(j, g[i].size()) {\n          Edge &e = g[i][j];\n          if (e.capacity > 0 && d[e.dst] > d[i] + e.cost) {\n            d[e.dst] = d[i] + e.cost;\n            pv[e.dst] = i; pe[e.dst] = j;\n            update = 1;\n          }\n        }\n    }\n    if (d[t] == INF) break;\n    Weight f = F;\n    for (int u = t; u != s; u = pv[u])\n      f = min(f, g[pv[u]][pe[u]].capacity);\n    if (!f) break;\n    for (int u = t; u != s; u = pv[u]) {\n      total.first += f * g[pv[u]][pe[u]].cost;\n      g[pv[u]][pe[u]].capacity -= f;\n      g[u][g[pv[u]][pe[u]].rev].capacity += f;\n    }\n    F -= f;\n    total.second += f;\n  }\n  return total;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    Graph g(367);\n    \n    REP(i, n) {\n      int a, b, w;\n      cin >> a >> b >> w;\n      add_edge(g, a-1, b, 1, -w);\n    }\n    REP(i, 366) {\n      add_edge(g, i, i+1, 2, 0);\n    }\n    cout << -minimumCostFlow3(g, 0, 366).first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 2005\n#define INF (1e9)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\n\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nll dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nll min_cost_flow(int s,int t,int f){\n  ll res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint a[MAX_V],b[MAX_V],w[MAX_V];\nvector<P> v;\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    \n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>w[i];\n      v.push_back(P(a[i],i));\n    }\n    sort(v.begin(),v.end());\n\n    int s=n*2,g=s+1;\n    \n    for(int i=0;i<n;i++){\n      add_edge(s,i*2,1,0);\n      add_edge(i*2,i*2+1,1,-w[i]);\n      add_edge(i*2+1,g,1,0);\n\n      for(int j=0;j<v.size();j++){\n\tif(i==v[j].second)continue;\n\tif(b[i]<v[j].first)\n\t  add_edge(i*2+1,v[j].second*2,1,0);\n      }\n    }\n\n    V=g+1;\n\n    cout<<-min_cost_flow(s,g,2)<<endl;\n    \n    for(int i=0;i<V;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\nstruct Event{\n  int s, e, c;\n  Event() {}\n  Event(int s, int e, int c) :\n    s(s), e(e), c(c) {}\n  bool operator < (const Event& E) const {\n    if(s != E.s) return s < E.s;\n    else         return e < E.e;\n  }\n};\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\nmap<S, int> memo;\nint dfs(int idx, int t1, int t2, vector<Event>& e){\n  if(idx == N) return 0;\n  if(t1 > t2) swap(t1, t2);\n  S state(idx, P(t1, t2));\n  if(memo.count(state)) return memo[state];\n  int res = dfs(idx + 1, t1, t2, e);\n  if(t1 < e[idx].s){\n    res = max(res, e[idx].c + dfs(idx + 1, e[idx].e, t2, e));\n  }\n  if(t2 < e[idx].s){\n    res = max(res, e[idx].c + dfs(idx + 1, t1, e[idx].e, e));\n  }\n  memo[state] = res;\n  return res;\n}\nint main(){\n  while(cin>>N && N){\n    vector<Event> events(N);\n    REP(i, N){\n      scanf(\"%d %d %d\", &events[i].s, &events[i].e, &events[i].c);\n    }\n    sort(events.begin(), events.end());\n    memo.clear();\n    cout<<dfs(0, 0, 0, events)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t]==INF) return -1;\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    PrimalDual p(368);\n    r(i,n){\n      int a,b,c;\n      cin>>a>>b>>c;\n      p.add_edge(a,b+1,1,-c);\n    }\n    r(i,367)p.add_edge(i,i+1,2,0);\n    cout<<-p.flow(0,366,2)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t]==INF) return -1;\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    PrimalDual p(367);\n    r(i,n){\n      int a,b,c;\n      cin>>a>>b>>c;\n      p.add_edge(a,b+1,1,-c);\n    }\n    r(i,367)p.add_edge(i,i+1,2,0);\n    cout<<-p.flow(0,366,2)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntemplate<class T>\nstruct interval{\n\tT a,b,w;\n\tinterval():a(0),b(0){}\n\tinterval(const T &a,const T &b):a(a<b?a:b),b(a<b?b:a){}\n\tbool operator<(const interval &I)const{ return b<I.b || b==I.b && a<I.a; }\n};\n\nconst int V_MAX=2003;\nconst int CAPA_INF=1<<29;\nconst int COST_INF=1<<29;\n\ntemplate<class T,class U>\nstruct edge{\n\tint v,rev;\n\tT capa;\n\tU cost;\n\tT flow;\n};\n\ntemplate<class T,class U>\nvoid add_directed_edge(vector< edge<T,U> > *G,int u,int v,T capa,U cost){\n\tG[u].push_back((edge<T,U>){v,G[v].size()  ,capa, cost,0});\n\tG[v].push_back((edge<T,U>){u,G[u].size()-1,   0,-cost,0});\n}\n\ntemplate<class T,class U>\npair<T,U> augment(int n,vector< edge<T,U> > *G,int s,int t,U *pot,bool fir){\n\tstatic int pre[V_MAX];\n\tstatic U d[V_MAX];\n\trep(u,n) d[u]=(u==s?0:COST_INF);\n\n\tbool ok;\n\tif(fir){\n\t\t// Bellman-Ford\n\t\twhile(1){\n\t\t\tbool end=true;\n\t\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\t\tedge<T,U> &e=G[u][i];\n\t\t\t\tif(e.capa-e.flow>0 && d[u]<COST_INF && d[u]+e.cost<d[e.v]){\n\t\t\t\t\td[e.v]=d[u]+e.cost;\n\t\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\t\tend=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end) break;\n\t\t}\n\t\tok=(d[t]<COST_INF);\n\t}\n\telse{\n\t\t// Dijkstra\n\t\tok=false;\n\t\tpriority_queue< pair<U,int> > Q; Q.push(make_pair(0,s));\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.top().second;\n\t\t\tU cost=-Q.top().first; Q.pop();\n\n\t\t\tif(cost<d[u]) continue;\n\t\t\tif(u==t) ok=true;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tedge<T,U> &e=G[u][i];\n\t\t\t\tU cost2=cost+e.cost+pot[u]-pot[e.v];\n\t\t\t\tif(e.capa-e.flow>0 && cost2<d[e.v]){\n\t\t\t\t\td[e.v]=cost2;\n\t\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\t\tQ.push(make_pair(-cost2,e.v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!ok) return make_pair(0,0);\n\n\tT water=CAPA_INF;\n\tfor(int v=t;v!=s;){\n\t\tedge<T,U> &e1=G[v][pre[v]];\n\t\tedge<T,U> &e2=G[e1.v][e1.rev];\n\t\twater=min(water,e2.capa-e2.flow);\n\t\tv=e1.v;\n\t}\n\n\tU cost=0;\n\tfor(int v=t;v!=s;){\n\t\tedge<T,U> &e1=G[v][pre[v]];\n\t\tedge<T,U> &e2=G[e1.v][e1.rev];\n\t\te1.flow-=water;\n\t\te2.flow+=water;\n\t\tcost+=water*e2.cost;\n\t\tv=e1.v;\n\t}\n\n\trep(u,n) pot[u]+=d[u];\n\n\treturn make_pair(water,cost);\n}\n\ntemplate<class T,class U>\npair<T,U> primal_dual(int n,vector< edge<T,U> > *G,int s,int t){\n\tstatic U pot[V_MAX];\n\trep(u,n) pot[u]=0;\n\n\tT ans1=0;\n\tU ans2=0;\n\tfor(bool fir=true;;fir=false){\n\t\tpair<T,U> tmp=augment(n,G,s,t,pot,fir);\n\t\tif(tmp.first==0) break;\n\t\tans1+=tmp.first;\n\t\tans2+=tmp.second;\n\t}\n\treturn make_pair(ans1,ans2);\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tinterval<int> I[1000];\n\t\trep(i,n) scanf(\"%d%d%d\",&I[i].a,&I[i].b,&I[i].w);\n\n\t\tsort(I,I+n);\n\n\t\tint s=2*n,t=s+1;\n\t\tvector< edge<int,int> > G[V_MAX];\n\t\trep(u,n) for(int v=u+1;v<n;v++) if(I[u].b<I[v].a) {\n\t\t\tadd_directed_edge(G,2*u+1,2*v,1,-I[v].w);\n\t\t}\n\t\trep(u,n){\n\t\t\tadd_directed_edge(G,s,2*u,1,-I[u].w);\n\t\t\tadd_directed_edge(G,2*u,2*u+1,1,0);\n\t\t\tadd_directed_edge(G,2*u+1,t,1,0);\n\t\t}\n\t\tint tt=t+1;\n\t\tadd_directed_edge(G,t,tt,2,0);\n\n\t\tprintf(\"%d\\n\",-primal_dual(2*n+3,G,s,tt).second);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef ll Weight;\ntypedef int Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nvoid add_edge(Graph &g, int from, int to, Flow cap, Weight cost)\n{\n\tg[from].push_back(Edge(from, to, (int)g[to].size(), cap, cost));\n\tg[to].push_back(Edge(to, from, (int)g[from].size() - 1, 0, -cost));\n}\nWeight mincost_flow(Graph &g, int s, int t, Flow f)\n{\n\tconst int n = g.size();\n\tWeight res = 0;\n\tArray dist(n);\n\tvi prevv(n), preve(n);\n\twhile (f > 0)\n\t{\n\t\tREP(i, n) dist[i] = (i == s) ? 0 : INF;\n\t\tbool update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tfor (int v = 0; v < n; v++)\n\t\t\t{\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\tREP(i, g[v].size())\n\t\t\t\t{\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.dest] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1; // cannot flow\n\t\tFlow d = f;\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tGraph g(368);\n\t\tint source = 366, sink = 367;\n\t\tREP(i, 365)\n\t\t{\n\t\t\tadd_edge(g, i, i + 1, 2, 0);\n\t\t}\n\t\tadd_edge(g, source, 0, 2, 0);\n\t\tadd_edge(g, 365, sink, 2, 0);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--;\n\t\t\tadd_edge(g, a, b, 1, -c);\n\t\t}\n\t\tcout << -mincost_flow(g, source, sink, 2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nPP A[1001];\nvoid Max(int &a,int b){a=max(a,b);}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>A[i].f.s>>A[i].f.f>>A[i].s;\n    sort(A,A+n);\n    \n    int dp[2][367][367]={};\n    for(int i=0;i<n;i++){\n      int l=A[i].f.s,r=A[i].f.f+1,c=A[i].s,b=i%2;\n      for(int j=0;j<=366;j++)\n\tfor(int k=0;k<=366;k++){\n\t  Max(dp[!b][j][k],dp[b][j][k]);\n\t  if(j<=l)Max(dp[!b][r][k],dp[b][j][k]+c);\n\t  if(k<=l)Max(dp[!b][j][r],dp[b][j][k]+c);\n\t}\n\n    }\n    int ans=0;  \n    for(int i=0;i<=366;i++)\n      for(int j=0;j<=366;j++)Max(ans,dp[n%2][i][j]);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> PI;\ntypedef pair<PI, int> PPII;\n\nconst int N = 370;\nll dp[N][N];\nll ndp[N][N];\nconst ll inf = 1e15;\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  while (cin >> n && n) {\n    vector<PPII> pool;\n    REP(i, 0, n) {\n      int u, v, w;\n      cin >> u >> v >> w;\n      v++; // [u, v)\n      pool.push_back(PPII(PI(u, v), w));\n    }\n    sort(pool.begin(), pool.end());\n    REP(i, 0, N) {\n      REP(j, 0, N) {\n\tdp[i][j] = -inf;\n\tndp[i][j] = -inf;\n      }\n    }\n    dp[0][0] = 0;\n    REP(i, 0, n) {\n      PPII cur = pool[i];\n      int u = cur.first.first;\n      int v = cur.first.second;\n      ll w = cur.second;\n      REP(j, 0, N) {\n\tll &ma = ndp[v][j];\n\tma = dp[v][j];\n\tREP(k, 0, u + 1) {\n\t  ma = max(ma, dp[k][j] + w); \n\t}\n      }\n      REP(j, 0, N) {\n\tll &ma = ndp[j][v];\n\tma = dp[j][v];\n\tREP(k, 0, u + 1) {\n\t  ma = max(ma, dp[j][k] + w); \n\t}\n      }\n      REP(j, 0, N) {\n\tREP(k, 0, N) {\n\t  dp[j][k] = max(dp[j][k], ndp[j][k]);\n\t}\n      }\n    }\n    ll ma = 0;\n    REP(i, 0, N) {\n      REP(j, 0, N) {\n\tma = max(ma, dp[i][j]);\n      }\n    }\n    cout << ma << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<vector<int> > ijw;\n    for(int i=0;i<n;i++){\n      int ii,j,w;\n      cin>>ii>>j>>w;\n      ijw.push_back({ii,j,w});\n    }\n    sort(begin(ijw),end(ijw));\n    int dp[367][367][2]={};\n    for(auto e:ijw){\n      for(int i=1;i<=366;i++){\n\tfor(int j=1;j<=366;j++){\n\t  if(i<=e[0]){\n\t    dp[e[1]+1][j][1]=max(dp[e[1]+1][j][1],dp[i][j][0]+e[2]);\n\t  }\n\t  if(j<=e[0]){\n\t    dp[i][e[1]+1][1]=max(dp[i][e[1]+1][1],dp[i][j][0]+e[2]);\n\t  }\n\t}\n      }\n      for(int i=1;i<=366;i++){\n\tfor(int j=1;j<=366;j++){\n\t  dp[i][j][0]=max(dp[i][j][0],dp[i][j][1]);\n\t}\n      }\n    }\n    cout<<*max_element(dp[0][0],dp[367][0])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nPP A[1001];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>A[i].f.s>>A[i].f.f>>A[i].s;\n    sort(A,A+n);\n    \n    int dp[2][367][367]={},b=0;\n    for(int i=0;i<n;i++){\n      int l=A[i].f.s,r=A[i].f.f+1,c=A[i].s;\n      for(int j=366;j>=0;j--)\n\tfor(int k=366;k>=0;k--){\n\t  dp[!b][j][k]=max(dp[!b][j][k],dp[b][j][k]);\n\t  if(j<=l)dp[!b][r][k]=max(dp[!b][r][k],dp[b][j][k]+c);\n\t  if(k<=l)dp[!b][j][r]=max(dp[!b][j][r],dp[b][j][k]+c);\n\t}\n      b=!b;\n    }\n    int ans=0;  \n    for(int i=0;i<=366;i++)\n      for(int j=0;j<=366;j++) ans=max(ans,dp[b][i][j]);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef tuple<int, int , int> T;\nint dp[366][366];\nint dp2[366][366];\nint main() {\nwhile(1){\n\tmemset(dp,0,sizeof(dp));\n\tmemset(dp2,0,sizeof(dp2));\n\tint ret=0;\n\tT in[1000];\n\tint n;\n\tcin >> n;\n\tif(n==0)return 0;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\tin[i]=T(b,a,w);\n\t}\n\tsort(in,in+n);\n\tfor(int k=0;k<n;k++){\n\t\tint a=get<1>(in[k]);\n\t\tint b=get<0>(in[k]);\n\t\tint w=get<2>(in[k]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i;j<=b;j++){\n\t\t\t\tif(j<a){\n\t\t\t\t\tdp2[i][b]=max(dp2[i][b],dp[i][j]+w);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[j][b]=max(dp2[j][b],dp[i][j]+w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=b;j++){\n\t\t\tdp[j][b]=max(dp[j][b],dp2[j][b]);\n\t\t\tret=max(ret,dp[j][b]);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\n#define MAX_V 10000\nint V;\n\ntypedef int Weight;\nconst Weight INF = 1000000000;\n\nstruct Edge{\n  int src, dest;\n  int cap, rev;\n  Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight h[MAX_V];                // potential\nWeight dist[MAX_V];             // minimum distance\nint prevv[MAX_V], preve[MAX_V]; // previous vertex and edge\n\nvoid add_edge(Graph &g, int src, int dest, int cap, int weight) {\n  g[src].push_back((Edge){src, dest, cap, (int)g[dest].size(), weight});\n  g[dest].push_back((Edge){dest, src, 0, (int)g[src].size() - 1, -weight});\n}\n\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n  Weight res = 0; V = g.size();\n  memset(h, 0, sizeof(h));\n  typedef pair<Weight, int> P;\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second; \n      if (dist[v] < p.first) continue;\n      REP(i, g[v].size()) {\n        Edge &e = g[v][i];\n        if (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest]) {\n          dist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n          prevv[e.dest] = v;\n          preve[e.dest] = i;\n          que.push(P(dist[e.dest], e.dest));\n        }\n      }\n    }\n    if (dist[t] == INF) return -1;\n    REP(v, V) h[v] += dist[v];\n\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      Edge &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<int> s(n+1);\n    vector<int> e(n+1);\n    vector<int> w(n);\n    Graph g(2*n+3);\n    REP(i,n){\n      cin>>s[i]>>e[i+1]>>w[i];\n      add_edge(g, i*2+1, i*2+2, 1, -w[i]);\n    }\n    s[n]=366;\n    REP(i,n+1){\n      REP(j,n+1){\n        if(e[i] < s[j]){\n          add_edge(g, i*2, j*2+1, 1, 0);\n        }\n      }\n    }\n    add_edge(g, 2*n+2, 0, 2, 0);\n    int v = min_cost_flow(g, 2*n+2, 2*n+1, 2);\n    cout<<-v<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll n;\nll l[1001],r[1001],w[1001];\nvector<ll> rs[400];\nvector<ll> wss[400];\nvector<ll> ids[400];\nll dp[401][1001];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,400){\n      rs[i].clear();\n      wss[i].clear();\n      ids[i].clear();\n    }\n    repl(i,1,n+1){\n      cin>>l[i]>>r[i]>>w[i];\n      l[i]--; r[i]--;\n      r[i]++;\n      rs[l[i]].push_back(r[i]);\n      wss[l[i]].push_back(w[i]);\n      ids[l[i]].push_back(i);\n    }\n    rep(i,401)rep(j,1001)dp[i][j]=-INF;\n    dp[0][0]=0;\n    rep(i,400)rep(j,1001){\n      if(dp[i][j]<0)continue;\n      if(j==0){\n        maxch(dp[i+1][j],dp[i][j]);\n        rep(k,rs[i].size()){\n          maxch(dp[i][ids[i][k]],dp[i][j]+wss[i][k]);\n        }\n      }else{\n        if(r[j]==i+1)maxch(dp[i+1][0],dp[i][j]);\n        else maxch(dp[i+1][j],dp[i][j]);\n        rep(k,rs[i].size()){\n          if(ids[i][k]==j)continue;\n          ll mn=min(r[j],rs[i][k]);\n          ll mx=max(r[j],rs[i][k]);\n          if(mn==mx)maxch(dp[mn][0],dp[i][j]+wss[i][k]);\n          else{\n            maxch(dp[mn][(r[j]==mx?j:ids[i][k])],dp[i][j]+wss[i][k]);\n          }\n        }\n      }\n    }\n    ll res=-INF;\n    rep(i,401)rep(j,1001)maxch(res,dp[i][j]);\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nstruct T{\n  int s,e,c;\n  T(int _s,int _e,int _c){\n    s = _s; e = _e; c = _c;\n  };\n\n  bool operator < (const T& t)const{\n    return s < t.s;\n  }\n};\n\nconst int MAX_N = 1001;\nconst int DAY = 366;\nint N;\n\nint dp[2][DAY][DAY];\nvector<T>vec;\n\nvoid input(){\n  for(int i = 0 ; i < N ; i++){\n    int s,e,c;\n    cin >> s >> e >> c;\n    vec.push_back(T(s,e,c));\n  }\n  sort(vec.begin(),vec.end());\n  /*\n  for(int i = 0 ; i < vec.size() ; i++){\n    cout << \"i = \" << i << \" vec[i].s = \" << vec[i].s << endl;\n  }\n  */\n}\n\nvoid init(){\n  vec.clear();\n  for(int i = 0 ; i < 2 ; i++){\n    for(int j = 0 ; j < DAY ; j++){\n      for(int k = 0 ; k < DAY ; k++){\n\tdp[i][j][k] = 0;\n      }\n    }\n  }\n}\n\nvoid solve(){\n  init();\n  input();\n\n  int res = 0;\n  int now = 0;\n  int next = 1;\n\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < DAY ; j++){\n      for(int k = 0 ; k < DAY ; k++){\n\tdp[next][j][k] = max(dp[next][j][k],dp[now][j][k]);\n\tint a,b,c; a = b = c = 0;\n\tif(j < vec[i].s)a = dp[next][vec[i].e][k] = max(dp[next][vec[i].e][k],dp[now][j][k] + vec[i].c);\n\tif(k < vec[i].s)b = dp[next][j][vec[i].e] = max(dp[next][j][vec[i].e],dp[now][j][k] + vec[i].c);\n\tres = max(res,max(a,max(b,c)));\n      }\n    }\n\n    for(int j = 0 ; j < DAY ; j++){\n      for(int k = 0 ; k < DAY ; k++){\n\tdp[now][j][k] = dp[next][j][k];\n\tdp[next][j][k] = 0;\n      }\n    }\n\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> N,N){\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\ntemplate <typename flow_t, typename cost_t>\nstruct PrimalDual {\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    edge() {}\n    edge(int to, flow_t cap, cost_t cost, int rev) : to(to), cap(cap), cost(cost), rev(rev) {}\n  };\n  const cost_t INF;\n  vector<vector<edge>> G;\n  vector<cost_t> h,dist;\n  vector<int> prevv,preve;\n  PrimalDual(int V) : INF(numeric_limits<cost_t>::max()), G(V) {}\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    G[from].emplace_back(to, cap, cost, G[to].size());\n    G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n  }\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = G.size();\n    cost_t res = 0;\n    using P = pair<cost_t,int>;\n    priority_queue<P, vector<P>, greater<P>> que;\n    h.assign(V,0);\n    prevv.assign(V,-1);\n    preve.assign(V,-1);\n    while (f > 0) {\n      dist.assign(V,INF);\n      dist[s] = 0;\n      que.emplace(0,s);\n      while (!que.empty()) {\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.emplace(dist[e.to], e.to);\n          }\n        }\n      }\n      if (dist[t] == INF) return -1;\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n      flow_t d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int N;\n  while (cin >> N, N) {\n    PrimalDual<int,int> P(400);\n    for (int i = 1; i < 400; i++) {\n      for (int j = i+1; j+1 < 400; j++) {\n        P.add_edge(i,j,2,0);\n      }\n    }\n    REP(i,N) {\n      int s,t,w;\n      cin >> s >> t >> w;\n      P.add_edge(s,t+1,1,-w);\n    }\n    cout << -P.min_cost_flow(1,370,2) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 400\n#define INF (1<<26)\nstruct edge{int to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V];\nint preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==INF)continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=d*dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nint a,b,c;\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    V=400;\n   \n    for(int i=0;i<356;i++)\n      add_edge(i,i+1,2,0);\n    \n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      add_edge(a,b+1,1,-c);\n    }\n    \n    cout<<-min_cost_flow(0,356,2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nstruct P\n{\n  int s,e,cost;\n  P(int s=0,int e=0,int cost=0):s(s),e(e),cost(cost){}\n  bool operator < (const P& p)const\n  {\n    if(s!=p.s)return s < p.s;\n    return e < p.e;\n  } \n};\n\nvoid printVP(vector<P> vec)\n{\n  cout << \"printVP------\" << endl;\n  rep(i,vec.size())\n    cout<< \"(\" << vec[i].s << \",\" << vec[i].e << \",\" << vec[i].cost << \") \";\n  cout << endl;\n}\n\nvoid printVVI(VVI G)\n{\n  cout << \"printVVI ------ \"<< endl;\n  rep(i,G.size())\n    {\n      rep(j,G[i].size())\n\t{\n\t  if(G[i][j] == 0)cout << \"    0 \";\n\t  else cout << string(5-(log10(G[i][j])+1),' ') << G[i][j] << \" \"; \n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      int MAX = 367;\n      //dp[i][j] := テッツシツ妥」ツ?、テ」ツつ?」ツ?ョテゥツδィテ・ツアツ凝」ツ?景テヲツ猟・テ」ツつ?」ツ?ァ2テ」ツ?、テァツ崢ョテ」ツ?ョテゥツδィテ・ツアツ凝」ツ?桂テヲツ猟・テ」ツ?ョテヲツ卍づ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ按ゥテァツ崢?\n      VVI dp(MAX,VI(MAX,0));\n      vector<P> requests(N);\n      rep(i,N)\n\tcin >> requests[i].s >> requests[i].e >> requests[i].cost;\n      sort(requests.begin(),requests.end());\n      //printVP(requests);\n  \n      rep(k,N)\n\t{\n\t  VVI DP = dp;\n\t  REP(i,1,MAX)\n\t    {\n\t      REP(j,1,MAX)\n\t\t{\n\t\t  if(i == j && j == requests[k].e+1)\n\t\t    {\n\t\t      assert(requests[k].s-1 >= 0);\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     max(dp[requests[k].s][j]+requests[k].cost,\n\t\t\t\t\t dp[i][requests[k].s]+requests[k].cost));\n\t\t    }\n\t\t  else if(j == requests[k].e+1)\n\t\t    {\n\t\t      assert(requests[k].s-1 >= 0);\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     dp[i][requests[k].s]+requests[k].cost);\n\t\t    }\n\t\t  else if(i == requests[k].e+1)\n\t\t    {\n\t\t      assert(requests[k].s-1 >= 0);\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     dp[requests[k].s][j]+requests[k].cost);\n\t\t    }\n\t\t  \n\t\t    DP[i][j] = max(DP[i][j],\n\t\t\t\t   max(DP[i-1][j],DP[i][j-1]));\n\t\t}\n\t    }\n\t  dp = DP;\n\t  //cout << \"k = \" << k << endl;\n\t  //printVVI(dp);\n\t}\n      cout << dp[MAX-1][MAX-1] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight capacity, cost;\n  Edge(int src, int dst, Weight capacity, Weight cost) :\n    src(src), dst(dst), capacity(capacity), cost(cost) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, Weight cap, Weight cost) {\n  g[s].push_back(Edge(s,d,cap,cost));\n  g[d].push_back(Edge(d,s,0,-cost));\n}\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n// Bellman-Ford\npair<Weight, Weight> minimumCostFlow2(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  REP(u,n) FOR(e,g[u]) {\n    capacity[e->src][e->dst] += e->capacity;\n    cost[e->src][e->dst] += e->cost;\n  }\n  pair<Weight, Weight> total; // (cost, flow)\n  vector<Weight> h(n);\n\n  for (Weight F = INF; F > 0; ) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> p(n, -1);\n    REP(k, n) REP(i, n) FOR(e,g[i]) if (RESIDUE(e->src, e->dst)) {\n      if (d[e->dst] > d[e->src] + RCOST(e->src, e->dst)) {\n        d[e->dst] = d[e->src] + RCOST(e->src, e->dst);\n        p[e->dst] = e->src;\n      }\n    }\n    if (p[t] == -1) break;\n    Weight f = F;\n    for (int u = t; u != s; u = p[u])\n      f = min(f, RESIDUE(p[u], u));\n//    cout << \"f = \" << f << endl;\n    for (int u = t; u != s; u = p[u]) {\n      total.first += f * cost[p[u]][u];\n      // cout << f * cost[p[u]][u] << endl;\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    REP(u, n) h[u] += d[u];\n  }\n  return total;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    Graph g(367);\n    \n    REP(i, n) {\n      int a, b, w;\n      cin >> a >> b >> w;\n      add_edge(g, a-1, b, 1, -w);\n    }\n    REP(i, 366)\n      add_edge(g, i, i+1, 2, 0);    \n    cout << -minimumCostFlow2(g, 0, 366).first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n#define MP make_pair\n#define FF first\n#define SS second\n\nconst int MAX = 370;\nconst int INF = 1e9;\nint dp[2][MAX][MAX];\nint main(){\n  int N;\n  while(cin>>N,N){\n\tvector<pair<PII,int>> xs(N);\n\tfor(int i=0;i<N;++i)\n\t  cin >> xs[i].FF.FF >> xs[i].FF.SS >> xs[i].SS;\n\tsort(xs.begin(), xs.end());\n\n\tfill((int*)dp, (int*)dp+2*MAX*MAX, -INF);\n\tint crt = 0, nxt = 1;\n\tdp[crt][0][0] = 0;\n\tfor(int i=0;i<N;++i){\n\t  for(int k=0;k<MAX;++k)\n\t\tfor(int j=0;j<MAX;++j)\n\t\t  dp[nxt][k][j] = dp[crt][k][j];\n\n\t  for(int b=0;b<MAX;++b)\n\t\tfor(int j=0;j<xs[i].FF.FF;++j)\n\t\t  dp[nxt][xs[i].FF.SS][b] = max(dp[nxt][xs[i].FF.SS][b], dp[crt][j][b]+xs[i].SS);\n\t  for(int a=0;a<MAX;++a)\n\t\tfor(int j=0;j<xs[i].FF.FF;++j)\n\t\t  dp[nxt][a][xs[i].FF.SS] = max(dp[nxt][a][xs[i].FF.SS], dp[crt][a][j]+xs[i].SS);\n\t  swap(crt, nxt);\n\t}\n\n\tint ans = 0;\n\tfor(int i=0;i<MAX;++i)\n\t  for(int j=0;j<MAX;++j)\n\t\tans = max(ans, dp[crt][i][j]);\n\tcout << ans << endl;\n\t/*\n\tfor(int i=0;i<10;++i){\n\t  for(int j=0;j<10;++j)cout<<dp[i][j]<<\" \";\n\t  cout<<endl;\n\t}\n\t*/\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<vector<int> > ijw;\n    for(int i=0;i<n;i++){\n      int ii,j,w;\n      cin>>ii>>j>>w;\nif(j>365)return 1;\n      ijw.push_back({ii,j,w});\n    }\n    sort(begin(ijw),end(ijw));\n    int dp[367][367][2]={};\n    for(auto e:ijw){\n      for(int i=1;i<=365;i++){\n\tfor(int j=1;j<=365;j++){\n\t  if(i<=e[0]){\n\t    dp[e[1]+1][j][1]=max(dp[e[1]+1][j][1],dp[i][j][0]+e[2]);\n\t  }\n\t  if(j<=e[0]){\n\t    dp[i][e[1]+1][1]=max(dp[i][e[1]+1][1],dp[i][j][0]+e[2]);\n\t  }\n\t}\n      }\n      for(int i=1;i<=365;i++){\n\tfor(int j=1;j<=365;j++){\n\t  dp[i][j][0]=max(dp[i][j][0],dp[i][j][1]);\n\t}\n      }\n    }\n    cout<<*max_element(dp[0][0],dp[367][0])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll MOD=1000000007;\nconst ll E=1e18;\n\nconst ll MX=1100;\nll dp[MX][MX]={};\n\n\nint main(){\n  ll n;\n  while(cin>>n){\n    if(n==0){return 0;}\n    vector<pair<pll,ll>> A(n);\n    for(auto &I:A){cin>>I.F.F>>I.F.S>>I.S;}\n    sort(A.begin(),A.end(),[](pair<pll,ll> a,pair<pll,ll> b){return a.F.S==b.F.S?a.F.F<b.F.F:a.F.S<b.F.S;});\n    //for(auto &I:A){cout<<I.F.F<<I.F.S<<I.S<<endl;}\n    for(int i=0;i<=n;i++){\n      for(int t=0;t<=n;t++){\n\tdp[i][t]=0;\n      }\n    }\n  \n    for(int i=0;i<=n;i++){\n      for(int t=0;t<=i;t++){\n        if(i!=0){dp[i][t]=max(dp[i][t],dp[i-1][t]);}\n\tif(t!=0){dp[i][t]=max(dp[i][t],dp[i][t-1]);}\n\tif(i!=0 && t!=0){dp[i][t]=max(dp[i][t],dp[i-1][t-1]);}\n\tfor(int j=i;j<n;j++){\n\t  auto I=A[j];\n\t  if(i==0 || I.F.F>A[i-1].F.S){dp[j+1][t]=max(dp[j+1][t],dp[i][t]+I.S);}\n\t  if(t==0 || I.F.F>A[t-1].F.S){dp[j+1][i]=max(dp[j+1][i],dp[i][t]+I.S);}\n\t}\n\t//\tcout<<dp[i][t]<<\" \";\n      }\n      //cout<<endl;\n    }\n    cout<<dp[n][n]<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint dp[2][366][366];\nint n;\nvector<pair<pii,int> > scd;\n\nint main(){\n\n  while(cin>>n&&n){\n    scd.clear();\n    for(int i=0;i<n;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      scd.push_back(make_pair(pii(a,b),c));\n    }\n    sort(scd.begin(),scd.end());\n    for(int i=n;i>=0;i--){\n      int cur=i%2;\n      int nxt=(i+1)%2;\n      for(int j=0;j<366;j++){\n\tfor(int k=0;k<366;k++){\n\t  int res=0;\n\t  if(i==n)res=0;\n\t  else{\n\t    if(scd[i].first.first>j)\n\t      res=max(res,dp[nxt][scd[i].first.second][k]\n\t\t      +scd[i].second);\n\t    if(scd[i].first.first>k)\n\t      res=max(res,dp[nxt][j][scd[i].first.second]\n\t\t      +scd[i].second);\n\t    res=max(res,dp[nxt][j][k]);\n\t  }\n\t  dp[cur][j][k]=res;\n\t}\n      }\n    }\n    cout<<dp[0][0][0]<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nstruct P\n{\n  int s,e,cost;\n  P(int s=0,int e=0,int cost=0):s(s),e(e),cost(cost){}\n  bool operator < (const P& p)const\n  {\n    if(s!=p.s)return s < p.s;\n    return e < p.e;\n  } \n};\n\nvoid printVP(vector<P> vec)\n{\n  cout << \"printVP------\" << endl;\n  rep(i,vec.size())\n    cout<< \"(\" << vec[i].s << \",\" << vec[i].e << \",\" << vec[i].cost << \") \";\n  cout << endl;\n}\n\nvoid printVVI(VVI G)\n{\n  cout << \"printVVI ------ \"<< endl;\n  rep(i,G.size())\n    {\n      rep(j,G[i].size())\n\t{\n\t  if(G[i][j] == 0)cout << \"    0 \";\n\t  else cout << string(5-(log10(G[i][j])+1),' ') << G[i][j] << \" \"; \n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      int MAX = 367;\n      //dp[i][j] := １つめの部屋がi日めで2つ目の部屋がj日の時の最大利益\n      VVI dp(MAX,VI(MAX,0));\n      vector<P> requests(N);\n      rep(i,N)\n\tcin >> requests[i].s >> requests[i].e >> requests[i].cost;\n      sort(requests.begin(),requests.end());\n      //printVP(requests);\n  \n      rep(k,N)\n\t{\n\t  VVI DP = dp;\n\t  REP(i,1,MAX)\n\t    {\n\t      REP(j,1,MAX)\n\t\t{\n\t\t  if(i == j && j == requests[k].e+1)\n\t\t    {\n\t\t      assert(requests[k].s-1 >= 0);\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     max(dp[requests[k].s][j]+requests[k].cost,\n\t\t\t\t\t dp[i][requests[k].s]+requests[k].cost));\n\t\t    }\n\t\t  else if(j == requests[k].e+1)\n\t\t    {\n\t\t      assert(requests[k].s-1 >= 0);\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     dp[i][requests[k].s]+requests[k].cost);\n\t\t    }\n\t\t  else if(i == requests[k].e+1)\n\t\t    {\n\t\t      assert(requests[k].s-1 >= 0);\n\t\t      DP[i][j] = max(DP[i][j],\n\t\t\t\t     dp[requests[k].s][j]+requests[k].cost);\n\t\t    }\n\t\t  \n\t\t    DP[i][j] = max(DP[i][j],\n\t\t\t\t   max(DP[i-1][j],DP[i][j-1]));\n\t\t}\n\t    }\n\t  dp = DP;\n\t  //cout << \"k = \" << k << endl;\n\t  //printVVI(dp);\n\t}\n      cout << dp[MAX-1][MAX-1] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing std::max;\nusing std::vector;\n\nstruct apply{\n    int time, w, no;\n    apply(int _t, int _w, int _no): time(_t), w(_w), no(_no){}\n};\nvector<apply> vec[400];\n\nbool used[1000];\nint use[1000];\nint prev[400];\nint dp[400];\n\nint run_dp(){\n    dp[0] = 0;\n    for(int i=1;i<=366;i++){\n        dp[i] = 0;\n        use[i] = 0;\n        prev[i] = 0;\n    }\n    for(int i=1;i<=366;i++){\n        if(dp[i-1] > dp[i]){\n            prev[i] = i-1;\n            use[i] = 0;\n            dp[i] = dp[i-1];\n        }\n        for(int j=0;j<vec[i].size();j++){\n            int no = vec[i][j].no;\n            if(used[no]) continue;\n            int t = vec[i][j].time;\n            int price = vec[i][j].w;\n            if(dp[i]+price > dp[t]){\n                dp[t] = dp[i]+price;\n                use[t] = no;\n                prev[t] = i;\n            }\n        }\n    }\n    int cur = 366;\n    while(cur>=1){\n        used[use[cur]] = true;\n        cur = prev[cur];\n    }\n    return dp[366];\n}\n\nint main(){\n    while(true){\n        int book;\n        scanf(\"%d\", &book);\n        if(book == 0) break;\n        for(int i=0;i<=366;i++){\n            vec[i].clear();\n            dp[i]=0;\n        }\n        for(int i=1;i<=book;i++){\n            int a, b, c;\n            scanf(\"%d %d %d\", &a, &b, &c); b++;\n            vec[a].push_back(apply(b, c, i));\n            used[i] = false;\n        }\n        int a = run_dp();\n        int b = run_dp();\n        printf(\"%d\\n\", a+b);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nconstexpr int N = 365;\nconstexpr int INF = 1 << 30;\n\nbool solve() {\n    int m;\n    std::cin >> m;\n    if (m == 0) return false;\n\n    std::vector<std::tuple<int, int, int>> ts(m);\n    for (auto& t : ts) {\n        int l, r, c;\n        std::cin >> l >> r >> c;\n        t = std::make_tuple(--l, r, c);\n    }\n    std::sort(ts.begin(), ts.end());\n\n    auto dp = vec(N + 1, vec(N + 1, 0));\n\n    for (auto t : ts) {\n        int l, r, c;\n        std::tie(l, r, c) = t;\n\n        for (int i = N; i >= 0; --i) {\n            dp[i][r] = std::max(dp[i][r], dp[i][l] + c);\n            dp[r][i] = std::max(dp[r][i], dp[l][i] + c);\n        }\n\n        for (int i = 0; i <= N; ++i) {\n            for (int j = 0; j <= N; ++j) {\n                if (i + 1 <= N) dp[i + 1][j] = std::max(dp[i + 1][j], dp[i][j]);\n                if (j + 1 <= N) dp[i][j + 1] = std::max(dp[i][j + 1], dp[i][j]);\n            }\n        }\n    }\n\n    std::cout << dp[N][N] << \"\\n\";\n\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nclass Edge{\n\tpublic:\n\t\tint to, cost;\n\t\tEdge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\ntypedef vector<vector<Edge>> AdjList;\nvector<pair<int, int>> pre;\nvector<int> dis;\n\nbool bellmanFord(AdjList g, int n, int s, vector<vector<bool>>& used) { // nは頂点数、sは開始頂点\n\tpre = vector<pair<int,int>>(n, make_pair(-1,-1));\n\tdis = vector<int>(n, -1);\n\tdis[s] = 0; // 開始点の距離は0\n\trep(i,n){\n\t\trep(v,n){\n\t\t\trep(k,g[v].size()){\n\t\t\t\tif(used[v][k]) continue;\n\t\t\t\tEdge e = g[v][k];\n\t\t\t\tif (dis[v] != -1 && dis[e.to] < dis[v] + e.cost) {\n\t\t\t\t\tdis[e.to] = dis[v] + e.cost;\n\t\t\t\t\tpre[e.to] = make_pair(v,k);\n\t\t\t\t\tif (i == n - 1) return true; // n回目にも更新があるなら負の閉路が存在\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tAdjList g(366);\n\t\trep(i,365){\n\t\t\tg[i].emplace_back(Edge(i + 1, 0));\n\t\t}\n\t\trep(i,n){\n\t\t\tint l, r, d;\n\t\t\tcin >> l >> r >> d;\n\t\t\tl--; \n\t\t\tg[l].emplace_back(Edge(r, d));\n\t\t}\n\n\t\tvector<vector<bool>> used(400, vector<bool>(400,0));\n\t\tbellmanFord(g, 366, 0, used);\n\n\t\tint ans = dis.back();\n\n\t\tint pos = 365;\n\t\twhile(pre[pos].first != -1){\n\t\t\t//cout << pos << ' ' << pre[pos].second << endl;\n\t\t\tif(pre[pos].second != 0){\n\t\t\t\t//cout << pos << ' ' << pre[pos].first << ' ' << pre[pos].second << endl;\n\t\t\t\tused[pre[pos].first][pre[pos].second] = true;\n\t\t\t}\n\t\t\tpos = pre[pos].first;\n\t\t}\n\n\t\tbellmanFord(g, 366, 0, used);\n\t\tcout << ans + dis.back() << endl;\n\t\t//pos = 365;\n\t\t//while(pre[pos].first != -1){\n\t\t//\t//cout << pos << ' ' << pre[pos].second << endl;\n\t\t//\tif(pre[pos].second != 0){\n\t\t//\t\tcout << pos << ' ' << pre[pos].first << ' ' << pre[pos].second << endl;\n\t\t//\t\tused[pos][pre[pos].second] = true;\n\t\t//\t}\n\t\t//\tpos = pre[pos].first;\n\t\t//}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        const int DAYS = 365;\n\n        vector<int> l(n), r(n), w(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> l[i] >> r[i] >> w[i];\n            --l[i], --r[i];\n        }\n\n        vector<int> ord(n);\n        iota(ord.begin(), ord.end(), 0);\n        sort(ord.begin(), ord.end(), [&](int i,int j){\n                return r[i] < r[j];\n                });\n\n        auto dp = make_v<int>(2,DAYS+1,DAYS+1);\n\n        for (int i = 0; i < n; ++i) {\n            int id = ord[i];\n            for (int j = 0; j <= DAYS; ++j) {\n                for (int k = 0; k <= DAYS; ++k) {\n                    chmax(dp[i+1 & 1][j][k], dp[i & 1][j][k]);\n                    if (j <= l[id]) {\n                        chmax(dp[i+1 & 1][r[id]+1][k], dp[i & 1][j][k] + w[id]);\n                    }\n                    if (k <= l[id]) {\n                        chmax(dp[i+1 & 1][j][r[id]+1], dp[i & 1][j][k] + w[id]);\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        for (int j = 0; j <= DAYS; ++j) {\n            for (int k = 0; k <= DAYS; ++k) {\n                chmax(ans, dp[n & 1][j][k]);\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n//verified POJ3680\n#define MAX_V (365+2)\nstruct edge { int to, cap, cost,rev; };\n\nvector<edge> G[MAX_V];\n\n// fromテ」ツ?凝」ツつ液oテ」ツ?クテ・ツ青妥」ツ?凝」ツ??・ツョツケテゥツ?縦apテ」ツ??」ツつウテ」ツつケテ」ツδ?ostテ」ツ?ョティツセツコテ」ツつ津」ツつッテ」ツつ凖」ツδゥテ」ツδ陛」ツ?ォティツソツステ・ツ環?」ツ?凖」ツつ?\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n//テ」ツつウテ」ツつケテ」ツδ暗」ツ?古ィツイツ?」ツ?ョティツセツコテ」ツ?古・ツ青ォテ」ツ?セテ」ツつ古」ツ?ェテ」ツ??・ツ?エテ・ツ青暗」ツ?ッテ、ツクツ催ィツヲツ?\nvoid shortest_path(int s,vector<int> &d){\n    int v = d.size();\n    rep(i,d.size())d[i]=INF;\n    d[s]=0;\n    rep(loop,v){\n        rep(i,v){\n            for(auto e:G[i]){\n                if(e.cap && d[i]!=INF && d[e.to] > d[i]+e.cost)\n                    d[e.to] = d[i]+e.cost;\n            }\n        }\n    }\n}\n\n\n// sテ」ツ?凝」ツつ液テ」ツ?クテ」ツ?ョテヲツオツ?ゥツ?叔テ」ツ?ョテヲツ慊?・ツーツ湘ィツイツサテァツ板ィテヲツオツ?」ツつ津ヲツアツづ」ツつ?」ツつ?\n// テヲツオツ?」ツ?崚」ツ?ェテ」ツ??・ツ?エテ・ツ青暗」ツ?ッ-1テ」ツつ津ィツソツ氾」ツ??\nint min_cost_flow(int s, int t, int f) {\n    vector<int> h(MAX_V);\t//テ」ツδ敕」ツδ?」ツδウテ」ツつキテ」ツδ」テ」ツδォ\n    vector<int> dist(MAX_V);// テヲツ慊?ァツ淞ュティツキツ敕ゥツ崢「\n    int prevv[MAX_V], preve[MAX_V];// テァツ崢エテ・ツ可催」ツ?ョテゥツ?づァツつケテ」ツ?ィティツセツコ\n\n    int res = 0;\n    shortest_path(s, h);\n    \n    while (f > 0) {\n        // テ」ツつソテ」ツつ凖」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ陛」ツつ津ァツ板ィテ」ツ??」ツ?ヲhテ」ツつ津ヲツ崢エテヲツ鳴ーテ」ツ?凖」ツつ?\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        rep(i,dist.size())dist[i]=INF;\n        dist[s] = 0;\n        que.push(pii(0, s));\n        while (!que.empty()) {\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) return -INF;\t//テ」ツ?禿」ツつ古、ツサツ・テ、ツクツ甘ヲツオツ?」ツ?崚」ツ?ェテ」ツ??\n        \n        for (int v = 0; v < h.size(); v++) h[v] += dist[v];\n        \n        \n        // s-tテゥツ鳴禿ヲツ慊?ァツ淞ュティツキツッテ」ツ?ォテヲツイツソテ」ツ?」テ」ツ?ヲテァツ崢ョテ、ツクツ?ヲツ敖ッテヲツオツ?」ツ??\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        rep(i,MAX_V)G[i].clear();\n        rep(i,n){\n            int s,t,c;\n            cin>>s>>t>>c;\n            s--,t;\n            add_edge(s, t, 1, -c);\n        }\n        int S = 365;\n        int T = S+1;\n        add_edge(S, 0, INF, 0);\n        add_edge(364, T, INF, 0);\n        rep(i,365-1)add_edge(i, i+1, INF, 0);\n        \n        cout<<-1*min_cost_flow(S, T, 2)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight capacity, cost;\n  int rev;\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, Weight cap, Weight cost) {\n  g[s].push_back((Edge){s,d,cap,cost,g[d].size()});\n  g[d].push_back((Edge){d,s,0,-cost,g[s].size()-1});\n}\n\n// Bellman-Ford\npair<Weight, Weight> minimumCostFlow3(Graph g, int s, int t) {\n  const int n = g.size();\n  pair<Weight, Weight> total; // (cost, flow)\n\n  for (int F = INF; F > 0;) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> pv(n), pe(n);\n    REP(k, n) REP(i, n) if (d[i] < INF) REP(j, g[i].size()) {\n      Edge &e = g[i][j];\n      if (e.capacity == 0) continue;\n      if (d[e.dst] > d[i] + e.cost) {\n        d[e.dst] = d[i] + e.cost;\n        pv[e.dst] = i; pe[e.dst] = j;\n      }\n    }\n    if (d[t] == INF) break;\n    Weight f = F;\n    for (int u = t; u != s; u = pv[u]) {\n      f = min(f, g[pv[u]][pe[u]].capacity);\n    }\n    if (!f) break;\n    for (int u = t; u != s; u = pv[u]) {\n      total.first += f * g[pv[u]][pe[u]].cost;\n      // cout << f * cost[p[u]][u] << endl;\n      g[pv[u]][pe[u]].capacity -= f;\n      g[u][g[pv[u]][pe[u]].rev].capacity += f;\n    }\n    F -= f;\n    total.second += f;\n  }\n  return total;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    Graph g(367);\n    \n    REP(i, n) {\n      int a, b, w;\n      cin >> a >> b >> w;\n      add_edge(g, a-1, b, 1, -w);\n    }\n    REP(i, 366) {\n      add_edge(g, i, i+1, 2, 0);\n    }\n    cout << -minimumCostFlow3(g, 0, 366).first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::sort;\nusing std::max;\n\nint dp[366][366];\nstruct apply{\n    int a, b, c;\n}applys[10000];\nbool comp(apply a, apply b){return a.a < b.a;}\n\nint main(){\n    int N;\n    while(scanf(\"%d\", &N) && N){\n        for(int i=0 ; i<=365 ; i++)\n            for(int j=0 ; j<=365 ; j++)\n                dp[i][j] = 0;\n        for(int i=0 ; i<N ; i++){\n            scanf(\"%d %d %d\", &applys[i].a, &applys[i].b, &applys[i].c);\n        }\n        sort(applys, applys+N, comp);\n        int ptr = 0;\n        for(int i=0;i<365;i++){\n            dp[i][i] = max(dp[i][i], dp[i-1][i-1]);\n            while(ptr<N && applys[ptr].a==i){\n                int k = applys[ptr].b+1;\n                int c = applys[ptr].c;\n                for(int j=365;j>=i;j--){\n                    dp[k][j] = max(dp[k][j], dp[i][j]+c);\n                    dp[j][k] = max(dp[j][k], dp[j][i]+c);\n                }\n                ptr++;\n            }\n            for(int j=i;j<=365;j++){\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n                dp[j][i+1] = max(dp[j][i+1], dp[j][i]);\n            }\n        }\n        printf(\"%d\\n\", dp[365][365]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_start,int arg_end,int arg_value){\n\t\tstart = arg_start;\n\t\tend = arg_end;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn end < arg.end;\n\t\t//return start < arg.start;\n\t};\n\tint start,end,value;\n};\n\nint main(){\n\n\tint N,dp[367][367],tmp_start,tmp_end,tmp_value;\n\tbool FLG;\n\n\tvector<Info> V;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tV.clear();\n\n\t\tfor(int i = 0; i <= 366; i++){\n\t\t\tfor(int k = 0; k <= 366; k++)dp[i][k] = 0;\n\t\t}\n\n\t\tdp[366][366] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d %d\",&tmp_start,&tmp_end,&tmp_value);\n\t\t\tV.push_back(Info(tmp_start,tmp_end,tmp_value));\n\t\t}\n\n\t\tsort(V.begin(),V.end());\n\n\t\tfor(int i = 0; i < V.size();i++){\n\n\t\t\tfor(int row = 1; row <= V[i].end+1; row++){\n\t\t\t\tdp[row][V[i].end+1] = max(dp[row][V[i].end+1],dp[row][V[i].start]+V[i].value);\n\t\t\t}\n\n\t\t\tfor(int col = 1; col <= V[i].end;col++){\n\t\t\t\tdp[V[i].end+1][col] = max(dp[V[i].end+1][col],dp[V[i].start][col]+V[i].value);\n\t\t\t}\n\n\t\t\tfor(int row = 1; row <= 366; row++){\n\t\t\t\tfor(int col = V[i].end+2; col <= 366; col++){\n\t\t\t\t\tif(dp[row][col] < dp[row][col-1]){\n\t\t\t\t\t\tdp[row][col] = dp[row][col-1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int col = 1; col <= 366;col++){\n\t\t\t\tfor(int row = V[i].end+2; row <= 366; row++){\n\t\t\t\t\tif(dp[row][col] < dp[row-1][col]){\n\t\t\t\t\t\tdp[row][col] = dp[row-1][col];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dp[366][366]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 1000000007\n\ntypedef pair<int, int> P;\nstruct edge { int to, cap, cost, rev; };\n\nint V = 366;\nvector<edge> G[400];\nint h[400];\nint dist[400];\nint prevv[400], preve[400];\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){ to, cap, cost, (int)G[to].size() });\n    G[to].push_back((edge){ from, 0, -cost, (int)G[from].size() - 1 });\n}\n\n// ??????????????´??????M\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        priority_queue<P, vector<P>, greater<P> > q;\n        fill(dist, dist + V, M);\n        dist[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty()) {\n            P p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < (int)G[v].size(); ++i) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    q.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == M) return M;\n        for (int v = 0; v < V; ++v)\n            h[v] += dist[v];\n\n        int d = f;\n        for (int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) return 0;\n        for (int i = 0; i < 400; ++i) {\n            G[i].clear();\n            h[i] = 0;\n            dist[i] = 0;\n            prevv[i] = 0;\n            preve[i] = 0;\n        }\n        for (int i = 0; i < V - 1; ++i) {\n            add_edge(i, i + 1, 2, 0);\n        }\n        for (int i = 0; i < n; ++i) {\n            int a, b, w;\n            cin >> a >> b >> w;\n            add_edge(a - 1, b, 1, -w);\n        }\n        cout << -min_cost_flow(0, V - 1, 2) << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<vector<int> > ijw;\n    for(int i=0;i<n;i++){\n      int ii,j,w;\n      cin>>ii>>j>>w;\n      ijw.push_back({ii,j,w});\n    }\n    sort(begin(ijw),end(ijw));\n    int dp[367][367][2]={};\n    for(auto e:ijw){\n      for(int i=1;i<=365;i++){\n\tfor(int j=1;j<=365;j++){\n\t  if(i<=e[0]){\n\t    dp[e[1]+1][j][1]=max(dp[e[1]+1][j][1],dp[i][j][0]+e[2]);\n\t  }\n\t  if(j<=e[0]){\n\t    dp[i][e[1]+1][1]=max(dp[i][e[1]+1][1],dp[i][j][0]+e[2]);\n\t  }\n\t}\n      }\n      for(int i=1;i<=365;i++){\n\tfor(int j=1;j<=365;j++){\n\t  dp[i][j][0]=max(dp[i][j][0],dp[i][j][1]);\n\t}\n      }\n    }\n    cout<<*max_element(dp[0][0],dp[367][0])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint dp[2][405][405];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    VVI v;\n    REP(i, n) {\n      int l, r, w;\n      cin >> l >> r >> w;\n      v.PB({r, l, w});\n    }\n\n    sort(ALL(v));\n\n    memset(dp, -1, sizeof(dp));\n    int cur = 0, nxt = 1;\n    dp[cur][0][0] = 0;\n    REP(i, n) {\n      REP(j, 366) REP(k, 366) {\n        if(dp[cur][j][k] == -1) continue;\n        // cout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n        int l = v[i][1], r = v[i][0], w = v[i][2];\n        // iを使う\n        if(l > j) {\n          int nj = l <= k ? k : j;\n          chmax(dp[nxt][nj][r], dp[cur][j][k] + w);\n        }\n        // iを使わない\n        chmax(dp[nxt][j][k], dp[cur][j][k]);\n      }\n      // curとnxtをうまくやるやつ\n      swap(cur, nxt);\n      REP(j, 366) REP(k, 366) dp[nxt][j][k] = -1;\n    }\n\n    int ans = 0;\n    REP(i, 366) REP(k, 366) chmax(ans, dp[cur][i][k]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_V = 366;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // テヲツ慊嘉・ツ青妥ィツセツコ\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t テゥツ鳴禿ヲツ慊?ァツ淞ュティツキツッテ」ツ?ォテヲツイツソテ」ツ?」テ」ツ?ヲテァツ崢ョテ、ツクツ?ヲツ敖ッテヲツオツ?」ツ??\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// テヲツオツ?」ツつ古」ツ?淌」ツδ陛」ツδュテ」ツδシ=テ・ツ?ε」ツ??」ツ?ョテ・ツョツケテゥツ??テァツ渉セテ・ツ慊ィテ」ツ?ョテ・ツョツケテゥツ?湘」ツつ津ィツ。ツィテァツ、ツコ\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tPrimalDual pd(366);\n\n\t\tfor(int i = 0; i < 365; i++) {\n\t\t\tpd.add_edge(i, i + 1, 2, 0);\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, w;\n\t\t\tcin >> x >> y >> w;\n\t\t\tpd.add_edge(x, y + 1, 1, -w);\n\t\t}\n\n\t\tcout << -pd.solve(1, 365, 2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nusing edge=struct {int to,cap,cost,rev;};\nusing G=vector<vector<edge>>;\nconst int inf=1<<29;\n\nvoid add_edge(G &graph,int a,int b,int c,int d){\n\tgraph[a].push_back({b,c,d,int(graph[b].size())});\n\tgraph[b].push_back({a,0,-d,int(graph[a].size()-1)});\n}\n\nint min_cost_flow(G &graph,int s,int t,int f){\n\tint res=0;\n\twhile(f){\n\t\tint n=graph.size(),update;\n\t\tvector<int> dist(n,inf),pv(n,0),pe(n,0);\n\t\tdist[s]=0;\n\n\t\trep(loop,n){\n\t\t\tupdate=false;\n\t\t\trep(v,n)rep(i,graph[v].size()){\n\t\t\t\tedge &e=graph[v][i];\n\t\t\t\tif(e.cap>0 && chmin(dist[e.to],dist[v]+e.cost)){\n\t\t\t\t\tpv[e.to]=v,pe[e.to]=i;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\n\t\tif(dist[t]==inf) return -1;\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=pv[v]) chmin(d,graph[pv[v]][pe[v]].cap);\n\t\tf-=d,res+=d*dist[t];\n\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tedge &e=graph[pv[v]][pe[v]];\n\t\t\te.cap-=d;\n\t\t\tgraph[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tconst int all=366;\n\t\tG graph(all);\n\n\t\trep(i,all-1) add_edge(graph,i,i+1,2,0); \n\n\t\trep(i,n){\n\t\t\tint s,t,w;\n\t\t\tcin >> s >> t >> w;\n\t\t\ts--;\n\t\t\tadd_edge(graph,s,t,1,-w);\n\t\t}\n\n\t\tcout << -min_cost_flow(graph,0,all-1,2) << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<vector<int> > ijw;\n    for(int i=0;i<n;i++){\n      int ii,j,w;\n      cin>>ii>>j>>w;\n      ijw.push_back({ii,j,w});\n    }\n    sort(begin(ijw),end(ijw));\n    int dp[367][367][2]={};\n    for(auto e:ijw){\n      for(int i=1;i<=365;i++){\n\tfor(int j=1;j<=365;j++){\n\t  if(i<=e[0]){\n\t    dp[e[1]+1][j][1]=max(dp[e[1]+1][j][1],dp[i][j][0]+e[2]);\n\t  }\n\t  if(j<=e[0]){\n\t    dp[i][e[1]+1][1]=max(dp[i][e[1]+1][1],dp[i][j][0]+e[2]);\n\t  }\n\t}\n      }\n      for(int i=1;i<=365;i++){\n\tfor(int j=1;j<=365;j++){\n\t  dp[i][j][0]=max(dp[i][j][0],dp[i][j][1]);\n\t}\n      }\n    }\n    cout<<*max_element(dp[0][0],dp[367][0])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t]==INF) return -1;\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    PrimalDual p(365);\n    r(i,n){\n      int a,b,c;\n      cin>>a>>b>>c; a--; b--;\n      p.add_edge(a,b+1,1,-c);\n    }\n    r(i,364)p.add_edge(i,i+1,2,0);\n    cout<<-p.flow(0,364,2)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//内積、 dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積、cross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//線分と点の距離\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//線分の交差判定\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\n//線分の交点\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//線分と線分の距離\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//円と円の交点\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\n\nint dp[400][400];\nvoid solve(){\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) return;\n        REP(q, 400) {\n            REP(j, 400) {\n                dp[q][j] = 0;\n            }\n        }\n        dp[0][0] = 0;\n        vector<tuple<int, int, int>> inputs;\n        REP(i, n) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            inputs.push_back(make_tuple(a, b, c));\n        }\n        sort(ALL(inputs));\n        reverse(ALL(inputs));\n        for (int i = 1; i <= 365; ++i) {\n            while (inputs.empty() == false && get<0>(inputs.back()) == i) {\n                for (int q = 366; q >= i; --q) {\n                    dp[q][get<1>(inputs.back()) + 1] = max(dp[q][get<1>(inputs.back()) + 1], dp[q][i] + get<2>(inputs.back()));\n                    dp[get<1>(inputs.back()) + 1][q] = max(dp[get<1>(inputs.back()) + 1][q], dp[i][q] + get<2>(inputs.back()));\n                }\n                inputs.pop_back();\n            }\n            dp[i + 1][i + 1] = max(dp[i + 1][i + 1], dp[i][i]);\n            for (int q = i + 1; q <= 366; ++q) {\n                dp[i + 1][q] = max(dp[i][q], dp[i + 1][q]);\n                dp[q][i + 1] = max(dp[q][i + 1], dp[q][i]);\n            }\n        }\n        cout << dp[366][366] << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define DAY 365\n\nint dp[2][DAY + 1][DAY + 1];\nvector< vector<pair<int, int> > > data;\nint N;\n/*\nint dfs(int idx, int n1, int n2){\n\tif(idx >= 366) return 0;\n\tif(n1 < idx) n1 = 0;\n\tif(n2 < idx) n2 = 0;\n\tif(dp[idx][n1][n2] != -1) return dp[idx][n1][n2];\n\tint ans = dfs(idx + 1, n1, n2);\n\tif(n1 < idx && n2 < idx){\n\t\tfor(int i = 0; i < data[idx].size(); i++){\n\t\t\tfor(int j = i + 1; j < data[idx].size(); j++){\n\t\t\t\tint n3 = data[idx][i].first;\n\t\t\t\tint n4 = data[idx][j].first;\n\t\t\t\tans = max(ans, dfs(idx + 1, max(n3, n4), min(n3, n4)) + data[idx][i].second + data[idx][j].second);\n\t\t\t}\n\t\t}\n\t}\n\tif(n2 < idx){\n\t\tfor(auto p : data[idx]){\n\t\t\tint n3 = p.first;\n\t\t\tans = max(ans, dfs(idx + 1, max(n1, n3), min(n1, n3)) + p.second);  \n\t\t}\n\t}\n\t//printf(\"(%d %d %d) = %d\\n\", idx, n1, n2, ans);\n\treturn dp[idx][n1][n2] = ans;\n}\n*/\n\nint main(){\n\twhile(cin >> N, N){\n\t\tdata.assign(366, vector<pair<int ,int> >());\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint a, b, w;\n\t\t\tcin >> a >> b >> w;\n\t\t\tdata[a].push_back(pair<int, int>(b, w));\n\t\t}\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tfor(int j = 0; j < 366; j++){\n\t\t\t\tfor(int k = 0; k < 366; k++){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = DAY;  i > 0; i--){\n\t\t\tfor(int j = 0; j <= DAY; j++){\n\t\t\t\tfor(int k = 0; k <= DAY; k++){\n\t\t\t\t\tint idx = i;\n\t\t\t\t\tint n1 = j;\n\t\t\t\t\tint n2 = k;\n\t\t\t\t\tif(n1 < idx) n1 = 0;\n\t\t\t\t\tif(n2 < idx) n2 = 0;\n\t\t\t\t\tint ci = idx % 2;\t\n\n\t\t\t\t\tint ans = dp[ci][n1][n2];\n\t\t\t\t\tif(n1 < idx && n2 < idx){\n\t\t\t\t\t\tfor(int i = 0; i < data[idx].size(); i++){\n\t\t\t\t\t\t\tfor(int j = i + 1; j < data[idx].size(); j++){\n\t\t\t\t\t\t\t\tint n3 = data[idx][i].first;\n\t\t\t\t\t\t\t\tint n4 = data[idx][j].first;\n\t\t\t\t\t\t\t\tans = max(ans, dp[ci][max(n3, n4)][min(n3, n4)] + data[idx][i].second + data[idx][j].second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n2 < idx){\n\t\t\t\t\t\tfor(auto p : data[idx]){\n\t\t\t\t\t\t\tint n3 = p.first;\n\t\t\t\t\t\t\tans = max(ans, dp[ci][max(n1, n3)][min(n1, n3)] + p.second);  \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[(i+1)&1][j][k] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[0][0][0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<PI, int> PPII;\n\nconst int N = 400;\nll dp[N][N];\nll ndp[N][N];\nconst ll inf = 1e15;\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  while (cin >> n && n) {\n    vector<PPII> pool;\n    REP(i, 0, n) {\n      int u, v, w;\n      cin >> u >> v >> w;\n      v++; // [u, v)\n      pool.push_back(PPII(PI(u, v), w));\n    }\n    sort(pool.begin(), pool.end());\n    REP(i, 0, N) {\n      REP(j, 0, N) {\n\tdp[i][j] = -inf;\n\tndp[i][j] = -inf;\n      }\n    }\n    dp[0][0] = 0;\n    REP(i, 0, n) {\n      PPII cur = pool[i];\n      int u = cur.first.first;\n      int v = cur.first.second;\n      ll w = cur.second;\n      REP(j, 0, N) {\n\tll &ma = ndp[v][j];\n\tma = dp[v][j];\n\tREP(k, 0, u + 1) {\n\t  ma = max(ma, dp[k][j] + w); \n\t}\n      }\n      REP(j, 0, N) {\n\tll &ma = ndp[j][v];\n\tma = dp[j][v];\n\tREP(k, 0, u + 1) {\n\t  ma = max(ma, dp[j][k] + w); \n\t}\n      }\n      REP(j, 0, N) {\n\tREP(k, 0, N) {\n\t  dp[j][k] = max(dp[j][k], ndp[j][k]);\n\t}\n      }\n    }\n    ll ma = 0;\n    REP(i, 0, N) {\n      REP(j, 0, N) {\n\tma = max(ma, dp[i][j]);\n      }\n    }\n    cout << ma << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Primal_Dual\n{\n  typedef pair< int, int > Pi;\n  \n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int > potential, min_cost, prevv, preve;\n  \n  Primal_Dual(int V):graph(V){}\n  \n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge){to, cap, cost, (int)graph[to].size()});\n    graph[to].push_back((edge){from, 0, -cost, (int)graph[from].size() - 1});\n  }\n  \n  int min_cost_flow(int s, int t, int f)\n  {\n    int V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n  \n    while(f > 0){\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n  \n      while(!que.empty()){\n        Pi p = que.top(); que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++){\n          edge& e = graph[p.second][i];\n          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost){\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]){\n        addflow = min( addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]){\n        edge& e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    Primal_Dual FlowGraph(367);\n    for(int i = 0; i < N; i++) {\n      int x, y, w;\n      cin >> x >> y >> w;\n      FlowGraph.add_edge(x, y + 1, 1, -w);\n    }\n    for(int i = 0; i < 366; i++) {\n      FlowGraph.add_edge(i, i + 1, INF, 0); \n    }\n    cout << -FlowGraph.min_cost_flow(0, 366, 2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  while (1){\n    int n;\n    cin >> n;\n    if (n == 0){\n      break;\n    }\n    vector<tuple<int, int, int>> r(n);\n    for (int i = 0; i < n; i++){\n      int L, R, w;\n      cin >> L >> R >> w;\n      L--;\n      r[i] = make_tuple(R, L, w);\n    }\n    sort(r.begin(), r.end());\n    vector<vector<int>> dp(366, vector<int>(366, 0));\n    for (int i = 0; i < n; i++){\n      int R = get<0>(r[i]);\n      int L = get<1>(r[i]);\n      int w = get<2>(r[i]);\n      vector<vector<int>> dp2 = dp;\n      for (int j = 0; j < 366; j++){\n        dp2[R][j] = max(dp2[R][j], dp[L][j] + w);\n        dp2[j][R] = max(dp2[j][R], dp[j][L] + w);\n      }\n      for (int j = 0; j < 366; j++){\n        for (int k = 0; k < 366; k++){\n          if (j > 0){\n            dp2[j][k] = max(dp2[j][k], dp2[j - 1][k]);\n          }\n          if (k > 0){\n            dp2[j][k] = max(dp2[j][k], dp2[j][k - 1]);\n          }\n        }\n      }\n      swap(dp, dp2);\n    }\n    cout << dp[365][365] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nclass MinCostFlow{\n  \n  typedef pair<int, int> P;\n  class edge{\n  public:\n    int to, cap, cost, rev;\n    edge(){}\n    edge(int to, int cap, int cost, int rev) : to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  int infinity;\n  int SIZE;\n  vector<int> dist;\n  vector<int> h;\n  vector<int> prevv;\n  vector<int> preve;\n  vector<vector<edge> > G;\npublic:\n  MinCostFlow(int V) : SIZE(V),dist(vector<int>(V)),h(vector<int>(V)),\n\t\t       prevv(vector<int>(V)), preve(vector<int> (V)), \n\t\t       G(vector<vector<edge> >(V)){ \n    infinity = 1000 * 1000 * 1000 + 7;\n  }\n  void add_edge(int from, int to, int cap, int cost){\n    G[from].push_back(edge(to, cap, cost, G[to].size()));\n    G[to].push_back(edge(from, 0, -cost, G[from].size()-1));\n  }\n  void init(int size = 0){\n    if(size > 0){\n      dist.resize(size);\n      h.resize(size);\n      prevv.resize(size);\n      preve.resize(size);\n      G.resize(size);\n    }\n    for(int i = 0; i < (int)G.size(); i++) G[i].clear();\n  }\n  \n  int min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h.begin(), h.end(), 0);\n    while(f > 0){\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist.begin(), dist.end(), infinity);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while(!que.empty()){\n\tP p = que.top(); que.pop();\n\tint v  = p.second;\n\tif(dist[v] < p.first) continue;\n\tfor(int i =  0; i < (int)G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    que.push(P(dist[e.to], e.to));\n\t  }\n\t}\n      }\n      \n      if(dist[t] == infinity) return -1;\n      for(int v = 0; v < SIZE; v++) h[v] += dist[v];\n      \n      int d = f;\n      for(int v = t; v != s; v = prevv[v]){\n\td = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for(int v = t; v != s; v = prevv[v]){\n\tedge &e = G[prevv[v]][preve[v]];\n\te.cap -= d;\n\tG[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n\nint main(){\n  int n;\n  while(cin >> n && n){\n\n    const int year = 365;\n    int s = 0;\n    int t = year + 2;;\n    MinCostFlow mfc(t + 1);\n\n    REP2(i, 1, year + 1) mfc.add_edge(i, i + 1, INF, 0);\n    mfc.add_edge(s, 1, 2, 0);\n    mfc.add_edge(year + 1, t, 2, 0);\n    int ans = 0;\n    \n    REP(i, n){\n      int a, b, w;\n      cin >> a >> b >> w;\n      b++;\n      \n      ans += w;\n      mfc.add_edge(b, a, 1, w);\n      mfc.add_edge(s, b, 1, 0);\n      mfc.add_edge(a, t, 1, 0);\n    }\n    cout << ans - mfc.min_cost_flow(s, t, 2 + n) << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define REP(i,n) for(li i=0;i<(li)(n);i++)\ntypedef int64_t li;\nconst li VMAX = 4096, INF = 1000000000;\ntypedef pair<li, li> P;\ntypedef pair<P, li> Tuple;\n\nstruct edge { li to, cap, cost, rev; };\n\nvector<edge> G[VMAX];\nli dist[VMAX];\nli prevv[VMAX], preve[VMAX];\nli V;\n\nvoid init() {\n  REP(i, V) {\n    G[i].clear();\n    dist[i] = INF;\n    prevv[i] = preve[i] = 0;\n  }\n}\n\nTuple T(li begin, li end, li cost) {\n  return Tuple(P(begin, end), -cost);\n}\n\nvoid add_edge(li from, li to, li cap, li cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\nli min_cost_flow(li s, li t, li f) {\n  li res = 0;\n  while (f > 0) {\n    fill(dist, dist + V, INF) ;\n    dist[s] = 0;\n    bool update = true;\n\n    while (update) {\n      update = false;\n      REP(v, V) {\n        if (dist[v] == INF) continue;\n        REP(i, G[v].size()) {\n          edge &e = G[v][i];\n          if (e.cap > 0 and dist[e.to] > dist[v] + e.cost) {\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n\n    if (dist[t] == INF) {\n      return -1;\n    }\n\n    li d = f;\n    for (li v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * dist[t];\n    for (li v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap  += d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  li n;\n  while (cin >> n and n) {\n    V = 2 * n + 3;\n    init();\n    vector<Tuple> events;\n    REP(k, n) {\n      li i, j, w;\n      cin >> i >> j >> w;\n      events.push_back(T(i, j, w));\n    }\n\n    const int SOURCE = 0, SINK = 2, BEGIN = 1;\n\n    add_edge(SOURCE, BEGIN, 2, 0);\n    add_edge(BEGIN, SINK, 2, 0);\n    \n    REP(i, events.size()) {\n      add_edge(BEGIN, 2 * i + 3, 1, 0);\n      add_edge(2 * i + 4, SINK, 1, 0);\n      add_edge(2 * i + 3, 2 * i + 4, 1, events[i].second);\n    }\n\n    REP(i, events.size()) {\n      REP(j, events.size()) {\n        li end = events[i].first.second;\n        li begin = events[j].first.first;\n        if (end < begin) {\n          add_edge(2 * i + 4, 2 * j + 3, 1, 0);\n        }\n      }\n    }\n\n\n    li min = -min_cost_flow(SOURCE, SINK, 2);\n    cout << min << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst int MAX_V = 2100;\nint V; //????????°\nstruct edge { int to, cap, cost, rev; };\nvector<edge> G[MAX_V];\nint dist[MAX_V]; //???????????¢\nint prevv[MAX_V], preve[MAX_V];\nvoid add_edge(int from, int to, int cap, int cost) { // from->to????????????cap,?????????cost???????????????\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n// s??????t????????????f???????°??????¨???????±??????? ??????????????´??????-1\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\twhile(f > 0) {\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update) {\n\t\t\tupdate = false;\n\t\t\tfor (int v = 0; v < V; ++v){\n\t\t\t\tif(dist[v] == INF)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); ++i){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF) return -1;\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void) {\n\twhile(1) {\n\t\tint n; scanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tint start = 2 * n, goal = 2 * n + 1;\n\t\tint l[1010], r[1010], w[1010];\n\t\trep(i, n) scanf(\"%d %d %d\", &l[i], &r[i], &w[i]);\n\t\trep(i, MAX_V) G[i].clear();\n\n\t\n\t\trep(i, n) add_edge(start, 2 * i, 1, 0);\n\t\trep(i, n) add_edge(2 * i + 1, goal, 1, 0);\n\t\trep(i, n) add_edge(2 * i, 2 * i + 1, 1, -w[i]);\n\t\trep(i, n)rep(j, n){\n\t\t\tif(i == j) continue;\n\t\t\tif(r[i] < l[j]) add_edge(2 * i + 1, 2 * j, 1, 0);\n\t\t}\n\t\t// printf(\"k\\n\");\n\t\tV = 2 * n + 2;\n\t\n\n\t\t/*\n\t\trep(i, 365) add_edge(i, i + 1, 2, 0);\n\t\trep(i, n) add_edge(l[i] - 1, r[i], 1, -w[i]);\n\t\tV = 366;\n\t\tint re = min_cost_flow(0, 365, 2);\n\t\tprintf(\"%d\\n\", -re);\n\t\t*/\n\t\t\n\t\tint ret = min_cost_flow(start, goal, 2);\n\t\tprintf(\"%d\\n\", -ret);\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[400][400];\nvector<pair<int,int> > v[400];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<400;i++)v[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tx--;y--;\n\t\t\tv[x].push_back(make_pair(y,z));\n\t\t}\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)\n\t\t\tdp[i][j]=-1111111111;\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<365;i++){\n\t\t\tfor(int j=0;j<365;j++){\n\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\tdp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t\t\t\tif(i==j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++)for(int l=k+1;l<v[i].size();l++){\n\t\t\t\t\t\tdp[v[i][k].first+1][v[i][l].first+1]=max(dp[v[i][k].first+1][v[i][l].first+1],dp[i][j]+v[i][k].second+v[i][l].second);\n\t\t\t\t\t}\n\t\t\t\t}else if(i<j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++)dp[v[i][k].first+1][j]=max(dp[v[i][k].first+1][j],dp[i][j]+v[i][k].second);\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k<v[j].size();k++)dp[i][v[j][k].first+1]=max(dp[i][v[j][k].first+1],dp[i][j]+v[j][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)ret=max(ret,dp[i][j]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nvector<array<int, 3> > input;\nmap<array<int, 3>, int> dp;\nint N;\nint dfs(int i, int n1, int n2){\n\tif(i >= N) return 0;\n\tif(n1 < input[i][0]){\n\t\tn1 = 0;\n\t}\n\tif(n2 < input[i][0]){ \n\t\tn2 = 0;\n\t}\n\tif(dp.count({i, n1, n2})){\n\t\treturn dp[{i, n1, n2}];\t\n\t}\n\tint ans = dfs(i + 1, n1, n2);\n\tint a2 = 0;\n\tint nn1 = n1;\n\tint nn2 = n2;\n\tif(nn1 < input[i][0]){\n\t\tnn1 = input[i][1];\n\t\ta2 += input[i][2];\n\t}else if(nn2 < input[i][0]){\n\t\tnn2 = input[i][1];\n\t\ta2 += input[i][2];\n\t}\n\tans = max(ans, dfs(i + 1, max(nn1, nn2), min(nn1, nn2)) + a2);\n\tdp[{i, n1, n2}] = ans;\n\treturn ans;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tinput.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint a, b, w;\n\t\t\tcin >> a >> b >> w;\n\t\t\tinput.push_back({a, b, w});\n\t\t}\n\t\tsort(input.begin(), input.end());\n\t\tdp.clear();\n\t\tcout << dfs(0, 0, 0) << endl;\n\t\tcout << dp.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int n; cin >> n&&n;) {\n\t\tMinimumCostFlow mcf(365 + 1);\n\t\trep(i, 0, 365) {\n\t\t\tmcf.addArc(i, i + 1, 2, 0);\n\t\t}\n\t\trep(i, 0, n) {\n\t\t\tint a, b, w; cin >> a >> b >> w;\n\t\t\ta--;\n\t\t\tmcf.addArc(a, b, 1, -w);\n\t\t}\n\t\tcout << -mcf.minimumCostFlow(0, 365, 2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n//verified POJ3680\n#define MAX_V (365+3)\nstruct edge { int to, cap, cost,rev; };\n\nvector<edge> G[MAX_V];\n\n// fromテ」ツ?凝」ツつ液oテ」ツ?クテ・ツ青妥」ツ?凝」ツ??・ツョツケテゥツ?縦apテ」ツ??」ツつウテ」ツつケテ」ツδ?ostテ」ツ?ョティツセツコテ」ツつ津」ツつッテ」ツつ凖」ツδゥテ」ツδ陛」ツ?ォティツソツステ・ツ環?」ツ?凖」ツつ?\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n//テ」ツつウテ」ツつケテ」ツδ暗」ツ?古ィツイツ?」ツ?ョティツセツコテ」ツ?古・ツ青ォテ」ツ?セテ」ツつ古」ツ?ェテ」ツ??・ツ?エテ・ツ青暗」ツ?ッテ、ツクツ催ィツヲツ?\nvoid shortest_path(int s,vector<int> &d){\n    int v = d.size();\n    rep(i,d.size())d[i]=INF;\n    d[s]=0;\n    rep(loop,v){\n        rep(i,v){\n            for(auto e:G[i]){\n                if(e.cap && d[i]!=INF && d[e.to] > d[i]+e.cost)\n                    d[e.to] = d[i]+e.cost;\n            }\n        }\n    }\n}\n\n\n// sテ」ツ?凝」ツつ液テ」ツ?クテ」ツ?ョテヲツオツ?ゥツ?叔テ」ツ?ョテヲツ慊?・ツーツ湘ィツイツサテァツ板ィテヲツオツ?」ツつ津ヲツアツづ」ツつ?」ツつ?\n// テヲツオツ?」ツ?崚」ツ?ェテ」ツ??・ツ?エテ・ツ青暗」ツ?ッ-1テ」ツつ津ィツソツ氾」ツ??\nint min_cost_flow(int s, int t, int f) {\n    vector<int> h(MAX_V);\t//テ」ツδ敕」ツδ?」ツδウテ」ツつキテ」ツδ」テ」ツδォ\n    vector<int> dist(MAX_V);// テヲツ慊?ァツ淞ュティツキツ敕ゥツ崢「\n    int prevv[MAX_V], preve[MAX_V];// テァツ崢エテ・ツ可催」ツ?ョテゥツ?づァツつケテ」ツ?ィティツセツコ\n\n    int res = 0;\n    shortest_path(s, h);\n    \n    while (f > 0) {\n        // テ」ツつソテ」ツつ凖」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ陛」ツつ津ァツ板ィテ」ツ??」ツ?ヲhテ」ツつ津ヲツ崢エテヲツ鳴ーテ」ツ?凖」ツつ?\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        rep(i,dist.size())dist[i]=INF;\n        dist[s] = 0;\n        que.push(pii(0, s));\n        while (!que.empty()) {\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) return -INF;\t//テ」ツ?禿」ツつ古、ツサツ・テ、ツクツ甘ヲツオツ?」ツ?崚」ツ?ェテ」ツ??\n        \n        for (int v = 0; v < h.size(); v++) h[v] += dist[v];\n        \n        \n        // s-tテゥツ鳴禿ヲツ慊?ァツ淞ュティツキツッテ」ツ?ォテヲツイツソテ」ツ?」テ」ツ?ヲテァツ崢ョテ、ツクツ?ヲツ敖ッテヲツオツ?」ツ??\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        rep(i,MAX_V)G[i].clear();\n        \n        map<pii,vector<int>> mp;\n        set<int> st;\n        rep(i,n){\n            int s,t,c;\n            cin>>s>>t>>c;\n            s--,t;\n            st.insert(s);\n            st.insert(t);\n            mp[pii(s,t)].pb(c);\n        }\n        for(auto e:mp){\n            sort(all(e.second),greater<int>());\n            rep(i,min(2,(int)e.second.size()))add_edge(e.first.first, e.first.second, 1, -e.second[i]);\n        }\n        int S = 366;\n        int T = S+1;\n        \n        int bef = -1;\n        for(auto it = st.begin();it!=st.end();it++){\n            if(it==st.begin()){\n                bef = *it;\n            }else{\n                add_edge(bef,*it,INF,0);\n                bef = *it;\n            }\n        }\n        auto it = st.begin();\n        add_edge(S, *it, INF, 0);\n        \n        it = st.end();\n        add_edge(*(--it), T, INF, 0);\n        \n        cout<<-1*min_cost_flow(S, T, 2)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct Data{\n    int st,gt,w;\n    Data(int st, int gt, int w) : st(st),gt(gt),w(w){}\n};\n\nbool operator < (const Data &e, const Data &f){\n    return e.st < f.st;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<vector<ll>> dp(400,vector<ll>(400,0)),tmp(400,vector<ll>(400,0));\n        vector<Data> v;\n        for(int i=0;i<n;i++){\n            int st,gt,w;cin>>st>>gt>>w;\n            v.push_back(Data(st,gt,w));\n        }\n        sort(v.begin(),v.end());\n        for(int i=0;i<n;i++){\n            int st=v[i].st,gt=v[i].gt,w=v[i].w;\n            for(int j=365;j>=1;j--){\n                ll ma=0;\n                for(int k=0;k<=st-1;k++) ma=max(ma,dp[k][j]);\n                tmp[gt][j]=max(dp[gt][j],ma+w);\n                ma=0;\n                for(int k=0;k<=st-1;k++) ma=max(ma,dp[j][k]);\n                dp[j][gt]=max(dp[j][gt],ma+w);\n            }\n            for(int j=1;j<=365;j++){\n                dp[gt][j]=max(dp[gt][j],tmp[gt][j]);\n            }\n        }\n        ll res=0;\n        for(int i=0;i<400;i++)for(int j=0;j<400;j++) res=max(res,dp[i][j]);\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dp[366][365];\nint dp2[366];\nint x[1000], y[1000], c[1000];\nvoid init() {\n\trep(i, 366) {\n\t\tdp2[i] = 0;\n\t\trep(j, 365) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tinit();\n\t\tvector<P> v[365];\n\t\trep(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> c[i];\n\t\t\tx[i]--; y[i]--;\n\t\t\tv[x[i]].push_back({ y[i],c[i] });\n\t\t}\n\t\trep(i, 365) {\n\t\t\tdp2[i + 1] = max(dp2[i + 1], dp2[i]);\n\t\t\trep(j, v[i].size()) {\n\t\t\t\tif (i == v[i][j].first)dp2[i + 1] = max(dp2[i + 1], dp2[i] + v[i][j].second);\n\t\t\t\tdp[i+1][v[i][j].first] = max(dp[i+1][v[i][j].first] , dp2[i] + v[i][j].second);\n\t\t\t}\n\t\t\trep(j, v[i].size()) {\n\t\t\t\tRep(k,j+1, v[i].size()) {\n\t\t\t\t\tint sum = dp2[i]+v[i][j].second + v[i][k].second;\n\t\t\t\t\tint to = min(v[i][j].first + 1, v[i][k].first + 1), las = max(v[i][j].first, v[i][k].first);\n\n\t\t\t\t\tif (to > las)dp2[to] = max(dp2[to], sum);\n\t\t\t\t\tdp[to][las] = max(dp[to][las], sum);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRep(j, i, 365) {\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n\t\t\t\trep(k, v[i].size()) {\n\t\t\t\t\tint to = min(j+1, v[i][k].first+1), las = max(j, v[i][k].first);\n\t\t\t\t\tif (to > las) {\n\t\t\t\t\t\tdp2[to] = max(dp2[to], dp[i][j] + v[i][k].second);\n\t\t\t\t\t}\n\t\t\t\t\tdp[to][las] = max(dp[to][las], dp[i][j] + v[i][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp2[i + 1] = max(dp2[i + 1], dp[i][i]);\n\t\t}\n\t\tcout << dp2[365] << endl;\n\t}\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 2005\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\n\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint a[MAX_V],b[MAX_V],w[MAX_V];\nvector<P> v;\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    \n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>w[i];\n      v.push_back(P(a[i],i));\n    }\n    sort(v.begin(),v.end());\n\n    int s=n*2,g=s+1;\n    \n    for(int i=0;i<n;i++){\n      add_edge(s,i*2,1,0);\n      add_edge(i*2,i*2+1,1,-w[i]);\n      add_edge(i*2+1,g,1,0);\n\n      for(int j=0;j<v.size();j++){\n\tif(i==v[j].second)continue;\n\tif(b[i]<v[j].first)\n\t  add_edge(i*2+1,v[j].second*2,1,0);\n      }\n    }\n\n    V=g+1;\n\n    cout<<-min_cost_flow(s,g,2)<<endl;\n    \n    for(int i=0;i<V;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight capacity, cost;\n  Edge(int src, int dst, Weight capacity, Weight cost) :\n    src(src), dst(dst), capacity(capacity), cost(cost) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, Weight cap, Weight cost) {\n  g[s].push_back(Edge(s,d,cap,cost));\n  g[d].push_back(Edge(d,s,0,-cost));\n}\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n// Bellman-Ford\npair<Weight, Weight> minimumCostFlow2(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  REP(u,n) FOR(e,g[u]) {\n    capacity[e->src][e->dst] += e->capacity;\n    cost[e->src][e->dst] += e->cost;\n  }\n  pair<Weight, Weight> total; // (cost, flow)\n  vector<Weight> h(n);\n\n  for (Weight F = INF; F > 0; ) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> p(n, -1);\n    REP(k, n) REP(i, n) FOR(e,g[i]) if (RESIDUE(e->src, e->dst)) {\n      if (d[e->dst] > d[e->src] + RCOST(e->src, e->dst)) {\n        d[e->dst] = d[e->src] + RCOST(e->src, e->dst);\n        p[e->dst] = e->src;\n      }\n    }\n    if (p[t] == -1) break;\n    Weight f = F;\n    for (int u = t; u != s; u = p[u])\n      f = min(f, RESIDUE(p[u], u));\n//    cout << \"f = \" << f << endl;\n    for (int u = t; u != s; u = p[u]) {\n      total.first += f * cost[p[u]][u];\n      // cout << f * cost[p[u]][u] << endl;\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    REP(u, n) h[u] += d[u];\n  }\n  return total;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    Graph g(367);\n\n    vector<bool> f(367);\n    REP(i, n) {\n      int a, b, w;\n      cin >> a >> b >> w;\n      if (a==b) f[a-1] = 1;\n      add_edge(g, a-1, b, 1, -w);\n    }\n    REP(i, 366) {\n      if (!f[i])\n        add_edge(g, i, i+1, 2, 0);\n    }\n    cout << -minimumCostFlow2(g, 0, 366).first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\n// const int inf = 1ll << 60;\nconst int INF = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// const int INF = 99999999;\nconst int MAX_COST = 1000000;\n\nstruct edge { int to, cap, cost, rev; };\n\nconst int V = 367;\nconst int MAX_V = V;\nconst int F = 2;\nconst int s = 0;\nconst int t = 366;\nint E;\nvector<edge> G[MAX_V];\nint h[MAX_V];                   // potential\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // privious vertex, edge\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// get min cost flow from s to t\n// if we cannot flow f, then return -1\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        // update h by dijkstra\n        priority_queue<Pii, vector<Pii>, greater<Pii>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(Pii(0, s));\n        while (!que.empty()) {\n            Pii p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            rep(i, G[v].size()) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(Pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // no more flow\n            return -1;\n        }\n        rep(v, V) h[v] += dist[v];\n\n        // flow as much as possible along the minimum path from s to t\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, (int)G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> E, E) {\n        rep(i, V) {\n            G[i].clear();\n        }\n        rep(i, V - 1) {\n            add_edge(i, i + 1, 2, MAX_COST);\n        }\n\n        rep(i, E) {\n            int u, v, w;\n            cin >> u >> v >> w;\n            add_edge(u, v + 1, 1, (v + 1 - u) * MAX_COST - w);\n        }\n\n        cout << F * (V - 1) * MAX_COST - min_cost_flow(0, V - 1, F) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\n#define MAX_V 1000\n\nstruct edge{\n\tlong long int to, cap, cost, rev; // 行き先、容量、逆辺\n};\n\nvector<edge> G[MAX_V] = {};\nlong long int dist[MAX_V]; // 最短距離\nint prevv[MAX_V], preve[MAX_V]; // 直前の頂点と辺\n\n// from から to へ向かう容量 cap の辺を張る\nvoid add_edge(long long int from, long long int to, long long int cap, long long int cost){\n\tG[from].push_back((edge){to, cap, cost, G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, G[from].size() - 1}); // 有向辺\n}\n\n// s から t への流量 f の最小費用流を求める( V は頂点数)\nlong long int min_cost_flow(int s, int t, int f, int V){\n\t\n\tlong long int res = 0;\n\t\n\twhile(f > 0){\n\t\t\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\tif(dist[v] == INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tlong long int d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\t\n\tint V = 365, E, F = 2;\n\t\n\twhile(true){\n\t\t\n\t\tcin >> E;\n\t\tif(E == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tint num1, num2, cap = 1, cost;\n\t\t\tcin >> num1 >> num2 >> cost;\n\t\t\tadd_edge(num1 - 1, num2, cap, -cost);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tadd_edge(i, i + 1, 10, 0);\n\t\t}\n\t\t\n\t\tcout << -min_cost_flow(0, V, F, V + 1) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint N;\nint dp[2][370][370];\n\nstruct Seg {\n    Seg() {}\n    Seg(int a, int b, int c) : l(a), r(b), cost(c) {}\n    int l, r, cost;\n    bool operator<(const Seg &s) const {\n        return r < s.r;\n    }\n};\n\nint main() {\n    while(cin >> N, N) {\n        memset(dp, -1, sizeof(dp));\n        vector<Seg> segs(N);\n        for(int i=0; i<N; i++) {\n            int l, r, cost; cin >> l >> r >> cost;\n            segs[i] = Seg{l, r, cost};\n        }\n        sort(segs.begin(), segs.end());\n\n        int ans = 0, lim = 0;\n        dp[0][0][0] = 0;\n        for(int i=0; i<N; i++) {\n            int cur = i % 2, nxt = 1 - cur;\n            \n            for(int j=0; j<=lim; j++) {\n                int r = segs[i].r, m1 = -1, m2 = -1;\n                for(int k=0; k<=lim; k++) {\n                    if(k < segs[i].l) {\n                        m1 = max(m1, dp[cur][k][j]);\n                        m2 = max(m2, dp[cur][j][k]);\n                    }\n\n                    // do not apply\n                    dp[nxt][j][k] = max(dp[nxt][j][k], dp[cur][j][k]);\n                    dp[nxt][k][j] = max(dp[nxt][k][j], dp[cur][k][j]);\n                }\n\n                // use 1st room\n                if(m1 != -1) {\n                    dp[nxt][r][j] = max(dp[nxt][r][j], m1 + segs[i].cost);\n                    ans = max(ans, dp[nxt][r][j]);\n                }\n\n                // use 2nd room\n                if(m2 != -1) {\n                    dp[nxt][j][r] = max(dp[nxt][j][r], m2 + segs[i].cost);\n                    ans = max(ans, dp[nxt][j][r]);\n                }\n            }\n            for(int j=0; j<=365; j++) {\n                for(int k=0; k<=365; k++) {\n                    dp[cur][j][k] = -1;\n                }\n            }\n            lim = max(lim, segs[i].r);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_V = 370;\nusing Capacity = int;\nusing Cost = long long;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tPrimalDual pd(370);\n\n\t\tfor(int i = 0; i <= 365; i++) {\n\t\t\tpd.add_edge(i, i + 1, 2, 0);\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, w;\n\t\t\tcin >> x >> y >> w;\n\t\t\tpd.add_edge(x, y + 1, 1, -w);\n\t\t}\n\n\t\tcout << -pd.solve(1, 366, 2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nusing ll = long long;\n\nint dp[2][400][400];\n\nstruct Res {\n    int l, r, c;\n    Res(int l, int r, int c) : l(l), r(r), c(c) {}\n    bool operator<(const Res &rhs) {\n        if (r == rhs.r)\n            return l < rhs.l;\n        else\n            return r < rhs.r;\n    }\n};\n\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    vector<Res> v;\n    REP(i, N) {\n        int l, r, c;\n        cin >> l >> r >> c;\n        l--;\n        v.push_back({l, r, c});\n    }\n    REP(i, 2) REP(j, 400) REP(k, 400) dp[i][j][k] = 0;\n    sort(all(v));\n    REP(i, N) {\n        int now = i % 2;\n        int nxt = (i + 1) % 2;\n        REP(j, 400) REP(k, 400) dp[nxt][j][k] = 0;\n        REP(j, 366) REP(k, 366) {\n            dp[nxt][j][k] = max(dp[nxt][j][k], dp[now][j][k]);\n            if (v[i].l >= j) {\n                dp[nxt][v[i].r][k] = max(dp[nxt][v[i].r][k], dp[now][j][k] + v[i].c);\n            }\n            if (v[i].l >= k) {\n                dp[nxt][j][v[i].r] = max(dp[nxt][j][v[i].r], dp[now][j][k] + v[i].c);\n            }\n        }\n    }\n    int ans = 0;\n    REP(i, 2) REP(j, 400) REP(k, 400) ans = max(ans, dp[i][j][k]);\n    cout << ans << endl;\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Edge{\npublic:\n\tint to,cap,cost,rev;\n\tEdge(int to,int cap,int cost,int rev){\n\t\tthis->to=to; this->cap=cap; this->cost=cost; this->rev=rev;\n\t}\n};\n\nconst int V=367,INF=1<<28;\nvector<Edge> G[V];\nint dist[V],prevv[V],preve[V];\n\nint minCostFlow(int s,int t,int f) {\n\tint ret=0;\n\twhile(f>0){\n\t\tfill(begin(dist), end(dist), INF);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(int v=0; v<V; ++v){\n\t\t\t\tif(dist[v]==INF)\tcontinue;\n\t\t\t\tfor(int i=0; i<G[v].size(); ++i){\n\t\t\t\t\tEdge e = G[v][i];\n\t\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n\t\t\t\t\t\tdist[e.to]= dist[v]+e.cost;\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF)\treturn -1;\n\t\tint d=f;\n\t\tfor(int v=t; v!=s; v=prevv[v])\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\tf-=d;\n\t\tret += d*dist[t];\n\t\tfor(int v=t; v!=s; v=prevv[v]){\n\t\t\tEdge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid addEdge(int from,int to,int cap,int cost){\n\tG[from].push_back(Edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(Edge(from, 0, -cost, G[from].size()-1));\n}\n\nint solve(int N){\n\tfill(begin(G), end(G), vector<Edge>());\n\tfill(begin(dist), end(dist), INF);\n\tfill(begin(prevv), end(prevv), 0);\n\tfill(begin(preve), end(preve), 0);\n\tfor(int i=1; i<V; ++i)\taddEdge(i-1, i, 2, 0);\n\tint a,b,c;\n\tfor(int i=0; i<N; ++i){\n\t\tcin>>a>>b>>c;\n\t\taddEdge(a, b+1, 1, -c);\n\t}\n\tint ret = minCostFlow(0, V-1, 2);\n\treturn -ret;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N, N)\tcout<< solve(N) <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 400;\n\nint main(void){\n  int N,S[MAX_N],T[MAX_N],W[MAX_N],dp[MAX_N][MAX_N];\n\n  while(cin >> N,N){\n\n    for(int i=0;i<N;i++){\n      cin >> S[i] >> T[i] >> W[i];\n    }\n\n    for(int i=0;i<N;i++){\n      for(int j=i;j<N;j++){\n\tif(T[i]>T[j]){\n\t  swap(S[i],S[j]);\n\t  swap(T[i],T[j]);\n\t  swap(W[i],W[j]);\n\t}\n      }\n    }\n\n    fill(dp[0],dp[367],0);\n\n    for(int i=0;i<N;i++){\n      for(int j=365;j>=0;j--){\n\tfor(int k=365;k>=0;k--){\n\t  if(j<S[i])dp[T[i]][k]=max(dp[T[i]][k],dp[j][k]+W[i]);\n\t  if(k<S[i])dp[j][T[i]]=max(dp[j][T[i]],dp[j][k]+W[i]);\n\t}\n      }\n    }\n\n    int ans=0;\n    for(int i=0;i<366;i++){\n      for(int j=0;j<366;j++){\n\tans=max(ans,dp[i][j]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 550\n#define INF 1e8\n\nstruct edge{\n  int to,cap,cost,rev;\n  edge(int to,int cap,int cost,int rev) :\n    to(to),cap(cap),cost(cost),rev(rev) {}\n};\n\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(edge(to,cap,cost,G[to].size()));\n  G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  while(f > 0){\n    fill(dist,dist+MAX_V,INF);\n    dist[s] = 0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v = 0 ; v < MAX_V ; v++){\n        if(dist[v] == INF) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n          edge &e = G[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    \n    if(dist[t] == INF){\n      return -1;\n    }\n    \n    int d = f;\n    for(int v = t ; v != s ; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * dist[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    for(int i = 0 ; i < MAX_V ; i++){\n      G[i].clear();\n    }\n    int a,b,w;\n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> w;\n      add_edge(a-1,b,1,-w);\n    }\n    for(int i = 0 ; i < 365 ; i++){\n      add_edge(i,i+1,2,0);\n    }\n    cout << -min_cost_flow(0,365,2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct edge {\n    int to, cap, cost, rev;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, int cap, int cost) {\n    g[from].push_back(edge{to, cap, cost, (int)g[to].size()});\n    g[to].push_back(edge{from, 0, -cost, (int)g[from].size()-1});\n}\n\nint min_cost_flow(graph& g, int s, int t, int f) {\n    constexpr int INF = 1e9;\n    int res = 0;\n    const int N = g.size();\n    vector<int> h(N);\n    vector<int> dist(N);\n    vector<int> prevv(N), preve(N);\n    while(f > 0) {\n        priority_queue<pii, vector<pii>, greater<pii>> que;\n        fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n        que.push(make_pair(0, s));\n        while(!que.empty()) {\n            pii p = que.top();\n            que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) {\n                continue;\n            }\n            for(int i=0; i<g[v].size(); ++i) {\n                edge& e = g[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t] == INF) {\n            return -1;\n        }\n        for(int v=0; v<N; ++v) {\n            h[v] += dist[v];\n        }\n        int d = f;\n        for(int v=t; v!=s; v=prevv[v]) {\n            d = min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d*h[t];\n        for(int v=t; v!=s; v=prevv[v]) {\n            edge& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        graph g(366);\n        for(int i=0; i<365; ++i) {\n            add_edge(g, i, i+1, 2, 0);\n        }\n        for(int i=0; i<N; ++i) {\n            int s, t, w;\n            cin >> s >> t >> w;\n            add_edge(g, s-1, t, 1, -w);\n        }\n        cout << -min_cost_flow(g, 0, 365, 2) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\n// const int inf = 1ll << 60;\nconst int INF = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// const int INF = 99999999;\nconst int MAX_COST = 1000000;\n\nstruct edge { int to, cap, cost, rev; };\n\nconst int V = 367;\nconst int MAX_V = V;\nconst int F = 2;\nconst int s = 0;\nconst int t = 366;\nint E;\nvector<edge> G[MAX_V];\nint h[MAX_V];                   // potential\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // privious vertex, edge\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// get min cost flow from s to t\n// if we cannot flow f, then return -1\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        // update h by dijkstra\n        priority_queue<Pii, vector<Pii>, greater<Pii>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(Pii(0, s));\n        while (!que.empty()) {\n            Pii p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            rep(i, G[v].size()) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(Pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // no more flow\n            return -1;\n        }\n        rep(v, V) h[v] += dist[v];\n\n        // flow as much as possible along the minimum path from s to t\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, (int)G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> E, E) {\n        rep(i, V) {\n            G[i].clear();\n        }\n        rep(i, V - 1) {\n            add_edge(i, i + 1, 2, MAX_COST);\n        }\n\n        rep(i, E) {\n            int u, v, w;\n            cin >> u >> v >> w;\n            add_edge(u, v + 1, 1, (v + 1 - u) * MAX_COST - w);\n        }\n\n        cout << F * (V - 1) * MAX_COST - min_cost_flow(0, V - 1, F) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi bs(n),es(n),ws(n);\n\t\trep(i,n) cin>>bs[i]>>es[i]>>ws[i],bs[i]--;\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return es[i]<es[j];});\n\t\t\n\t\tconst int N=365;\n\t\tvvi dp1(N+1,vi(N+1)),dp2;\n\t\tfor(int k:is){\n\t\t\tdp2=dp1;\n\t\t\trep(i,N+1) repi(j,es[k],N+1) dp2[i][j]=max(dp2[i][j],dp1[i][bs[k]]+ws[k]);\n\t\t\trep(i,N+1) repi(j,es[k],N+1) dp2[j][i]=max(dp2[j][i],dp1[bs[k]][i]+ws[k]);\n\t\t\tswap(dp1,dp2);\n\t\t}\n\t\tcout<<dp1[N][N]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct MinCostFlow{\n  typedef int Weight;\n  struct Edge{\n    int src, dst;\n    Weight cap, cost;\n    int rev;\n    Edge(int src, int dst, Weight cap, Weight cost, int rev=-1):\n      src(src), dst(dst), cap(cap), cost(cost), rev(rev) {}\n  };\n  typedef vector<Edge> Node;\n  typedef vector<Node> Graph;\n  Graph G;\n\n  MinCostFlow(int N) : G(N) {} //頂点数Nのグラフを作る\n  void add_edge(int src, int dst, Weight cap, Weight cost){\n    G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n    G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n  }\n  //sからtへfを流した時の最小費用を返す O(VE + FVlogE)\n  Weight flow(int s, int t, Weight f){\n    typedef pair<Weight, int> P;\n    Weight res = 0;\n    int V = G.size();\n    vector<Weight> h(V, 0);\n    vector<int> prevv(V);\n    vector<int> preve(V);\n    if(s == t) return 0;\n    //負の辺が存在するときは最初の最短路計算をベルマンフォードで行う。\n    //2回目からポテンシャルを使うことでコストが0以上であることが保証される\n    //のでダイクストラを使う。\n    //負の辺がないときは、ベルマンフォードを使う必要はない。\n    bool start = true; \n    while(f > 0){\n      vector<Weight> dist(V, INF);\n      //ベルマンフォード\n      if(start){\n        start = false;\n        bool update = true;\n        dist[s] = 0;\n        while(update){\n          update = false;\n          REP(v, V){\n            if(dist[v] == INF) continue;\n            REP(i, G[v].size()){\n              Edge& e = G[v][i];\n              if(e.cap > 0 && dist[e.dst] > dist[v] + e.cost){\n                dist[e.dst] = dist[v] + e.cost;\n                prevv[e.dst] = v;\n                preve[e.dst] = i;\n                update = true;\n              }\n            }\n          }\n        }\n      //ダイクストラ\n      }else{\n        priority_queue<P, vector<P>, greater<P> > que;\n        dist[s] = 0;\n        que.push(P(0, s));\n        while(!que.empty()){\n          P p = que.top(); que.pop();\n          int v = p.second;\n          if(dist[v] < p.first) continue;\n          REP(i, G[v].size()){\n            Edge& e = G[v][i];\n            if(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]){\n              dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n              prevv[e.dst] = v;\n              preve[e.dst] = i;\n              que.push(P(dist[e.dst], e.dst));\n            }\n          }\n        }\n      }\n      if(dist[t] == INF) return -INF; //fのフローを流せないとき\n      REP(v, V) h[v] += dist[v];\n\n      Weight d = f;\n      for(int v = t; v != s; v = prevv[v]){\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for(int v = t; v != s; v = prevv[v]){\n        Edge& e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\nint main(){\n  int N;\n  while(cin>>N && N){\n    MinCostFlow G(366);\n    REP(i, N){\n      int a, b, c;\n      cin>>a>>b>>c;\n      G.add_edge(a - 1, b, 1, -c);\n    }\n    REP(i, 365){\n      G.add_edge(i, i + 1, 2, 0);\n    }\n    cout<<-G.flow(0, 365, 2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nusing tp = tuple<int, int, int>;\n\nint n;\ntp a[1000];\nint dp[1000][366][366];\n\nint calc(int i, int j, int k)\n{\n\tif (i == n) return 0;\n\tint &res = dp[i][j][k];\n\tif (~res) return res;\n\t\n\tint x, y, z;\n\ttie(x, y, z) = a[i];\n\n\tchmax(res, calc(i + 1, j, k));\n\tif (x >= j) chmax(res, z + calc(i + 1, y, k));\n\tif (x >= k) chmax(res, z + calc(i + 1, j, y));\n\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\ta[i] = tie(--x, y, z);\n\t\t}\n\t\tsort(a, a + n);\n\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tcout << calc(0, 0, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef int weight;\ntypedef pair<weight, int> P;\nconstexpr weight EPS = 1e-8;\n\nclass edge {\npublic:\n\tint to;\n\tint cap;\n\tweight cost;\n\tint rev;\n\tedge(int to_, int cap_, weight cost_, int rev_):to(to_), cap(cap_), cost(cost_), rev(rev_){};\n};\n\nvector<vector<edge> > G;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n}\n\nvoid add_edge(int from, int to, int cap, weight cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nweight min_cost_flow(int s, int t, int f) {\n\tconst int n = G.size();\n\tweight res = 0;\n\tvector<int> prevv(n), preve(n);\n\tvector<weight> h(n, 0);\n\twhile(f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<weight> dist(n, INT_MAX);\n\t\tdist[s] = 0;\n\t\tque.push({0, s});\n\t\twhile(!que.empty()) {\n\t\t\tconst int d = que.top().first;\n\t\t\tconst int v = que.top().second;\n\t\t\tque.pop();\n\n\t\t\tif(dist[v] < d) continue;\n\n\t\t\tfor(unsigned i = 0; i < G[v].size(); ++i) {\n\t\t\t\tconst edge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > d + e.cost + h[v] - h[e.to] + EPS) {\n\t\t\t\t\tdist[e.to] = d + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INT_MAX) return -1;\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nconstexpr int NUMBER_OF_DAYS = 365;\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tinit(NUMBER_OF_DAYS + 1);\n\t\tfor(int i = 0; i < NUMBER_OF_DAYS; ++i) {\n\t\t\tadd_edge(i, i + 1, 2, 0);\n\t\t}\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint l, r, w;\n\t\t\tcin >> l >> r >> w;\n\t\t\tadd_edge(l - 1, r, 1, -w);\n\t\t}\n\n\t\tcout << -min_cost_flow(0, NUMBER_OF_DAYS, 2) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data{\n  int l,r,c;\n  bool operator < (const data &d) const {\n    return r == d.r ? c > d.c : r < d.r;\n  }\n};\n\nconst int N = 1000;\nconst int M = 365;\ndata v[N];\nint dp[2][M+1][M+1];\nint n;\n\nvoid solve(){\n  fill(dp[0][0],dp[2][0],0);\n  sort(v,v+n);\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=M;j++){\n      for(int k=0;k<=M;k++){\n        dp[0][j][k] = dp[1][j][k];\n      }\n    }\n    \n    for(int j=v[i].r+1;j<=M;j++){\n      for(int k=0;k<=M;k++){\n        dp[1][j][k] = max(dp[1][j][k], dp[0][v[i].l][k] + v[i].c);\n        dp[1][k][j] = max(dp[1][k][j], dp[0][k][v[i].l] + v[i].c);\n      }\n    }    \n  }\n\n  cout << dp[1][M][M] << endl;\n}\n\nint main(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> v[i].l >> v[i].r >> v[i].c;\n      v[i].l--; v[i].r--;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 100000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\nint n;\nvector<edge> G[370];\nconst int S = 0, T = 366;\nint prevv[370], preve[350];\n\nvoid add_edge(int s, int t, int cap, int cost)\n{\n\tG[s].push_back( edge(t, cap, cost, G[t].size()) );\n\tG[t].push_back( edge(s, 0, -cost, G[s].size()-1) );\n}\n\nvoid BellmanFord()\n{\n\tint dist[370];\n\tfor(int i = S; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0;\n\tprevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = S; i <= T; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\tfor(int i = S; i <= T; i++) G[i].clear();\n\t\tfor(int i = S; i < T; i++) add_edge(i, i+1, inf, 0);\n\t\t\n\t\tint ii, jj, ww;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> ii >> jj >> ww;\n\t\t\tadd_edge(ii, jj+1, 1, -ww);\n\t\t}\n\t\t\n\t\tint F = 2, ans = 0;\n\t\twhile(F > 0){\n\t\t\tBellmanFord();\n\t\t\t\n\t\t\tint flow = F;\n\t\t\tint p = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\t\n\t\t\tp = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tans += G[prevv[p]][preve[p]].cost * flow;\n\t\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\tF -= flow;\n\t\t}\n\t\tcout << -ans << endl;\n\t}\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef long long ll;\n\nstruct triple {\n    ll l, r, w;\n};\n\ntriple a[1000];\n// i,j 以降は空いている\nll dp[2][400][400];\nint n;\n\nll solve(){\n    memset(dp, 0, sizeof(dp));\n    sort(a, a + n, [](triple const& a, triple const& b){\n        return a.l < b.l;\n    });\n    rep(i, n){\n        auto next = dp[i & 1];\n        auto cur = dp[(i + 1) & 1];\n        int l = a[i].l;\n        int r = a[i].r;\n        int w = a[i].w;\n        rep(j, 380){\n            rep(k, 380){\n                next[j][k] = cur[j][k];\n                if (j != 0){\n                    next[j][k] = max(next[j][k], next[j - 1][k]);\n                }\n                if (k != 0){\n                    next[j][k] = max(next[j][k], next[j][k - 1]);\n                }\n                if (j == r){\n                    next[j][k] = max(next[j][k], cur[l][k] + w);\n                }\n                if (k == r){\n                    next[j][k] = max(next[j][k], cur[j][l] + w);\n                }\n            }\n        }\n    }\n    return max(dp[0][370][370], dp[1][370][370]);\n}\n\nint main(){\n    while (cin >> n && n){\n        rep(i, n){\n            ll l, r, w; cin >> l >> r >> w;\n            r++;\n            a[i] = { l, r, w };\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct D{\n\tint l, r, d;\n\tbool operator < ( const D &right ) const {\n\t\treturn r < right.r;\n\t}\n};\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<D> d(n);\n\t\trep(i,n){\n\t\t\tauto& p = d[i];\n\t\t\tcin >> p.l >> p.r >> p.d;\n\t\t\tp.l--; p.r--;\n\t\t}\n\t\tsort(all(d));\n\n\t\tvector<vector<int>> cur(400, vector<int>(400,0));\n\t\trep(i,n){\n\t\t\tconst auto& p = d[i];\n\t\t\tfor (int j = 365; j >= 0; j--) {\n\t\t\t\tfor (int k = 365; k >= 0; k--) {\n\t\t\t\t\tif(j <= p.l){\n\t\t\t\t\t\tcur[p.r + 1][k] = max(cur[p.r + 1][k], cur[j][k] + p.d);\n\t\t\t\t\t}else if(k <= p.l){\n\t\t\t\t\t\tcur[j][p.r + 1] = max(cur[j][p.r + 1], cur[j][k] + p.d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i,400){\n\t\t\trep(j,400){\n\t\t\t\tans = max(ans, cur[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem1246 : Concert Hall Scheduling**/\nconst int MAX_V = 1000;\n\nclass Flow {\npublic:\n\tstruct edge { int to, cap, rev, cost;};\n\tvector<edge> G[MAX_V];\n\tbool used[MAX_V];\n\tint V;\n\t\n\tint dist[MAX_V];\n\tint prevv[MAX_V], preve[MAX_V];\n\t\n\tFlow() {V=MAX_V;}\n\tFlow(int v) {\n\t\tV = v;\n\t}\n\t\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size(), 0});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size()-1, 0});\n\t}\n\t\n\tvoid add_edge_with_cost(int from, int to, int cap, int cost) {\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size(), cost});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size()-1, -cost});\n\t}\n\t\n\t// 最大流\n\tint dfs(int v, int t, int f) {\n\t\tif (v==t) return f;\n\t\tused[v] = true;\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (!used[e.to] && e.cap>0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d>0) {\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif (f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\t\n\t// 最小費用流\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res=0;\n\t\twhile (f>0) {\n\t\t\tfill(dist, dist+V, INF);\n\t\t\tdist[s]=0;\n\t\t\tbool update=true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v=0; v<V; v++) {\n\t\t\t\t\tif (dist[v]==INF) continue;\n\t\t\t\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif (e.cap>0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (dist[t] == INF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tint d=f;\n\t\t\tfor (int v=t; v!=s; v=prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*dist[t];\n\t\t\tfor (int v=t; v!=s; v=prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tFlow F(366);\n\t\t\n\t\trep(i, 365) {\n\t\t\tF.add_edge_with_cost(i, i+1, 2, 0);\n\t\t}\n\t\t\n\t\trep(i, N) {\n\t\t\tint a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tF.add_edge_with_cost(a-1, b, 1, -c);\n\t\t}\n\t\t\n\t\tcout << -F.min_cost_flow(0, 365, 2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[400][400];\nvector<pair<int,int> > v[400];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<400;i++)v[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tx--;y--;\n\t\t\tv[x].push_back(make_pair(y,z));\n\t\t}\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)\n\t\t\tdp[i][j]=-1111111111;\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<365;i++){\n\t\t\tfor(int j=0;j<365;j++){\n\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\tdp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t\t\t\tif(i==j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\t\tdp[v[i][k].first+1][j]=max(dp[v[i][k].first+1][j],dp[i][j]+v[i][k].second);\n\t\t\t\t\t\tfor(int l=k+1;l<v[i].size();l++){\n\t\t\t\t\t\t\tdp[v[i][k].first+1][v[i][l].first+1]=max(dp[v[i][k].first+1][v[i][l].first+1],dp[i][j]+v[i][k].second+v[i][l].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(i<j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++)dp[v[i][k].first+1][j]=max(dp[v[i][k].first+1][j],dp[i][j]+v[i][k].second);\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k<v[j].size();k++)dp[i][v[j][k].first+1]=max(dp[i][v[j][k].first+1],dp[i][j]+v[j][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)ret=max(ret,dp[i][j]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Flow = int;\nusing Cost = int;\nclass PrimalDual {\npublic:\n  struct Edge {\n    int d;\n    Flow c, f;\n    Cost w;\n    int r;\n    Edge(int d, Flow c, Flow f, Cost w, int r) : d(d), c(c), f(f), w(w), r(r) {}\n  };\n\n  int n;\n  vector<vector<Edge>> g;\n  PrimalDual(int n) : n(n), g(n) {}\n\n  void addEdge(int src, int dst, Flow cap, Cost cost) { // 有向辺\n    int rsrc = g[dst].size();\n    int rdst = g[src].size();\n    g[src].emplace_back(dst, cap, 0, cost, rsrc);\n    g[dst].emplace_back(src, cap, cap, -cost, rdst);\n  }\n\n  template<Cost inf = numeric_limits<Cost>::max() / 8> Cost solve(int s, int t, Flow f) {\n    Cost res = 0;\n    vector<Cost> h(n), dist(n);\n    vector<int> prevv(n), preve(n);\n\n    using state = pair<Cost, int>;\n    priority_queue<state, vector<state>, greater<state>> q;\n    fill(h.begin(), h.end(), 0);\n    while (f > 0) {\n      fill(dist.begin(), dist.end(), inf);\n      dist[s] = 0;\n      q.emplace(0, s);\n      while (q.size()) {\n        Cost cd;\n        int v;\n        tie(cd, v) = q.top();\n        q.pop();\n        if (dist[v] < cd) continue;\n        for (int i = 0; i < g[v].size(); ++i) {\n          const Edge &e = g[v][i];\n          if (residue(e) == 0) continue;\n          if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n            dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n            prevv[e.d] = v;\n            preve[e.d] = i;\n            q.emplace(dist[e.d], e.d);\n          }\n        }\n      }\n\n      if (dist[t] == inf) return -1;\n\n      for (int i = 0; i < n; ++i) h[i] += dist[i];\n      Flow d = f;\n      for (int v = t; v != s; v = prevv[v]) cmin(d, residue(g[prevv[v]][preve[v]]));\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        Edge &e = g[prevv[v]][preve[v]];\n        e.f += d;\n        g[v][e.r].f -= d;\n      }\n    }\n    return res;\n  }\n\n  Flow residue(const Edge &e) { return e.c - e.f; }\n};\n\nmain {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    PrimalDual pd(366);\n    rep(i, 365) pd.addEdge(i, i + 1, 2, 0);\n    rep(i, n) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      pd.addEdge(a - 1, b, 1, -c);\n    }\n    cout << -pd.solve(0, 365, 2) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define MAXCH(a, b) (a = max(a, b))\nusing namespace std;\ntypedef long long ll;\n\nstruct data {\n  ll fi, se, w;\n  bool operator<(const data &d) const {\n    return se < d.se;\n  }\n};\n\nint main(void) {\n  ll N;\n  while(cin >> N, N) {\n    vector<data> P(N);\n    REP(i, 0, N) cin >> P[i].fi >> P[i].se >> P[i].w, P[i].fi--;\n\n    sort(P.begin(), P.end());\n\n    vector<vector<ll>> dp(366, vector<ll>(366, 0));\n    REP(k, 0, N) {\n      for(ll i = 365; i >= 0; i--) for(ll j = 365; j >= 0; j--) {\n        if(i <= P[k].fi) MAXCH(dp[P[k].se][j], dp[i][j] + P[k].w);\n        if(j <= P[k].fi) MAXCH(dp[i][P[k].se], dp[i][j] + P[k].w);\n      }\n    }\n\n    ll ans = 0;\n    REP(i, 0, 366) REP(j, 0, 366) ans = max(ans, dp[i][j]);\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[400][400];\nvector<pair<int,int> > v[400];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<400;i++)v[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tx--;y--;\n\t\t\tv[x].push_back(make_pair(y,z));\n\t\t}\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)\n\t\t\tdp[i][j]=0;\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<370;i++){\n\t\t\tfor(int j=i;j<370;j++){\n\t\t\t\tdp[i+1][max(i+1,j)]=max(dp[i+1][max(i+1,j)],dp[i][j]);\n\t\t\t\tif(i==j){\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\t\tdp[i+1][v[i][k].first+1]=max(dp[i+1][v[i][k].first+1],dp[i][j]+v[i][k].second);\n\t\t\t\t\t\tfor(int l=k+1;l<v[i].size();l++){\n\t\t\t\t\t\t\tint L=min(v[i][k].first+1,v[i][l].first+1);\n\t\t\t\t\t\t\tint R=max(v[i][k].first+1,v[i][l].first+1);\n\t\t\t\t\t\t\tdp[L][R]=max(dp[L][R],dp[i][j]+v[i][k].second+v[i][l].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\t\tdp[min(j,v[i][k].first+1)][max(j,v[i][k].first+1)]=max(dp[min(j,v[i][k].first+1)][max(j,v[i][k].first+1)],dp[i][j]+v[i][k].second);\n\t\t\t\t\t}\n\t\t\t\t//\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<400;i++)for(int j=0;j<400;j++)ret=max(ret,dp[i][j]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define chmax(a,b) (a=max(a,b))\nusing namespace std;\n\nstruct apply{\n  int l,r,p;\n  apply(int a=0, int b=0, int c=0):l(a),r(b),p(c){}\n  bool operator<(const apply x)const{return l<x.l;}\n};\n\nint dp[400][400];\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<apply> s(n);\n    rep(i,n){\n      int l,r,p;\n      cin >> l >> r >> p; l--; r--;\n      s[i] = apply(l,r,p);\n    }\n    sort(s.begin(),s.end());\n\n    memset(dp,0,sizeof(dp));\n    int id = 0;\n    rep(i,365){\n      while(id<n && s[id].l == i){\n\tint r = s[id].r, p = s[id].p;\n\tfor(int j=365;j>=i;j--){\n\t  if(j<r+1){\n\t    chmax(dp[j][r+1],dp[i][j]+p);\n\t  }else{\n\t    chmax(dp[r+1][j],dp[i][j]+p);\n\t  }\n\t}\n\tid++;\n      }\n\n      chmax(dp[i+1][i+1],dp[i][i]);\n      for(int j=i+1;j<=365;j++)chmax(dp[i+1][j],dp[i][j]);\n    }\n    cout << dp[365][365] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct edge {\n    int to, cap, cost, rev;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, int cap, int cost) {\n    g[from].push_back(edge{to, cap, cost, (int)g[to].size()});\n    g[to].push_back(edge{from, 0, -cost, (int)g[from].size()-1});\n}\n\nint min_cost_flow(graph& g, int s, int t, int f) {\n    constexpr int INF = 1e9;\n    int res = 0;\n    const int N = g.size();\n    vector<int> h(N);\n    vector<int> dist(N);\n    vector<int> prevv(N), preve(N);\n    while(f > 0) {\n        priority_queue<pii, vector<pii>, greater<pii>> que;\n        fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n        que.push(make_pair(0, s));\n        while(!que.empty()) {\n            pii p = que.top();\n            que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) {\n                continue;\n            }\n            for(int i=0; i<g[v].size(); ++i) {\n                edge& e = g[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t] == INF) {\n            return -1;\n        }\n        for(int v=0; v<N; ++v) {\n            h[v] += dist[v];\n        }\n        int d = f;\n        for(int v=t; v!=s; v=prevv[v]) {\n            d = min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d*h[t];\n        for(int v=t; v!=s; v=prevv[v]) {\n            edge& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        graph g(366);\n        for(int i=0; i<365; ++i) {\n            add_edge(g, i, i+1, 2, 0);\n        }\n        for(int i=0; i<N; ++i) {\n            int s, t, w;\n            cin >> s >> t >> w;\n            add_edge(g, s-1, t, 1, -w);\n        }\n        cout << -min_cost_flow(g, 0, 365, 2) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef int Weight;\nstruct Edge{\n  int src, dst;\n  Weight cap, cost;\n  int rev;\n  Edge(int src, int dst, Weight cap, Weight cost, int rev=-1):\n    src(src), dst(dst), cap(cap), cost(cost), rev(rev) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\n\nvoid add_edge(Graph& G, int src, int dst, Weight cap, Weight cost){\n  G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n  G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n}\n\nWeight min_cost_flow(Graph& G, int s, int t, Weight f){\n  typedef pair<Weight, int> P;\n  Weight res = 0;\n  int V = G.size();\n  vector<Weight> h(V, 0);\n  vector<int> prevv(V);\n  vector<int> preve(V);\n  if(s == t) return 0;\n  bool start = true;\n  while(f > 0){\n    vector<Weight> dist(V, INF);\n    if(start){\n      start = false;\n      bool update = true;\n      dist[s] = 0;\n      while(update){\n        update = false;\n        REP(v, V){\n          if(dist[v] == INF) continue;\n          REP(i, G[v].size()){\n            Edge& e = G[v][i];\n            if(e.cap > 0 && dist[e.dst] > dist[v] + e.cost){\n              dist[e.dst] = dist[v] + e.cost;\n              prevv[e.dst] = v;\n              preve[e.dst] = i;\n              update = true;\n            }\n          }\n        }\n      }\n    }else{\n      priority_queue<P, vector<P>, greater<P> > que;\n      dist[s] = 0;\n      que.push(P(0, s));\n      while(!que.empty()){\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(dist[v] < p.first) continue;\n        REP(i, G[v].size()){\n          Edge& e = G[v][i];\n          if(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]){\n            dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n            prevv[e.dst] = v;\n            preve[e.dst] = i;\n            que.push(P(dist[e.dst], e.dst));\n          }\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    REP(v, V) h[v] += dist[v];\n\n    Weight d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      Edge& e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    Graph G(366);\n    REP(i, N){\n      int a, b, c;\n      cin>>a>>b>>c;\n      add_edge(G, a - 1, b, 1, -c);\n    }\n    REP(i, 365){\n      add_edge(G, i, i + 1, 2, 0);\n    }\n    cout<<-min_cost_flow(G, 0, 365, 2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct edge{\n\tint to, cost, cap, rev;\n\tedge(int to, int cost, int cap, int rev)\n\t\t:to(to),cost(cost),cap(cap),rev(rev){}\n\tedge(){}\n};\n\nint min_cost_flow(int s, int g, int f, vector<vector<edge> > &adj){\n\tint n = adj.size();\n\tint res = 0;\n\twhile(f > 0){\n\t\tvector<int> prevv(n), preve(n);\n\t\tvector<int> mincost(n, inf);\n\t\tmincost[s] = 0;\n\t\twhile(1){\n\t\t\tbool update = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(mincost[i] == inf) continue;\n\t\t\t\tfor(int j=0; j<(int)adj[i].size(); j++){\n\t\t\t\t\tedge &e = adj[i][j];\n\t\t\t\t\tif(e.cap>0 && mincost[i] +e.cost < mincost[e.to]){\n\t\t\t\t\t\tmincost[e.to] = mincost[i] +e.cost;\n\t\t\t\t\t\tprevv[e.to] = i;\n\t\t\t\t\t\tpreve[e.to] = j;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\t\tif(mincost[g] == inf){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tint d = f;\n\t\tfor(int v=g; v!=s; v=prevv[v]){\n\t\t\td = min(d, adj[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*mincost[g];\n\t\tfor(int v=g; v!=s; v=prevv[v]){\n\t\t\tedge &e = adj[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tadj[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<edge> > adj(366);\n\t\tfor(int i=0; i<365; i++){\n\t\t\tadj[i].push_back(edge(i+1, 0, 2, adj[i+1].size()));\n\t\t\tadj[i+1].push_back(edge(i, 0, 0, adj[i].size()-1));\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a,b,w;\n\t\t\tcin >> a >> b >> w;\n\t\t\ta--; b--;\n\t\t\tadj[a].push_back(edge(b+1, -w, 1, adj[b+1].size()));\n\t\t\tadj[b+1].push_back(edge(a, w, 0, adj[a].size()-1));\n\t\t}\n\t\tcout << -min_cost_flow(0, 365, 2, adj) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nPP A[1001];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>A[i].f.s>>A[i].f.f>>A[i].s;\n    sort(A,A+n);\n    \n    int dp[367][367]={};\n    for(int i=0;i<n;i++){\n      int l=A[i].f.s,r=A[i].f.f+1,c=A[i].s;\n      for(int j=365;j>=0;j--)\n\tfor(int k=365;k>=0;k--){\n\t  if(j<=l)dp[r][k]=max(dp[r][k],dp[j][k]+c);\n\t  if(k<=l)dp[j][r]=max(dp[j][r],dp[j][k]+c);\n\t}\n    }\n    int ans=0;  \n    for(int i=0;i<=366;i++)\n      for(int j=0;j<=366;j++) ans=max(ans,dp[i][j]);\n    cout <<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_V = 370;\nusing Capacity = int;\nusing Cost = long long;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tPrimalDual pd(370);\n\n\t\tfor(int i = 0; i < 365; i++) {\n\t\t\tpd.add_edge(i, i + 1, 2, 0);\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, w;\n\t\t\tcin >> x >> y >> w;\n\t\t\tpd.add_edge(x, y + 1, 1, -w);\n\t\t}\n\n\t\tcout << -pd.solve(1, 365, 2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Minimum Cost Flow O(FE log V)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nstruct MCF{\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tT cost;\n\t};\n\tvector<vector<edge> >G;\n\tvector<T>h,d;\n\tvector<int>pv,pe;\n\tMCF(int n_=0):G(n_),h(n_,0),d(n_),pv(n_),pe(n_){}\n\tvoid add_edge(int from,int to,int cap,T cost)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap,cost});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0,-cost});\n\t}\n\tT min_cost_flow(int s,int t,int f)//ans or -1\n\t{\n\t\tT ret=0;\n\t\twhile(f>0)\n\t\t{\n\t\t\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\t\t\tfill(d.begin(),d.end(),numeric_limits<T>::max());\n\t\t\td[s]=0;\n\t\t\tP.push(make_pair(0,s));\n\t\t\twhile(!P.empty())\n\t\t\t{\n\t\t\t\tpair<T,int>p=P.top();P.pop();\n\t\t\t\tif(d[p.second]<p.first)continue;\n\t\t\t\tfor(int i=0;i<G[p.second].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge&e=G[p.second][i];\n\t\t\t\t\tif(e.cap>0&&d[e.to]>d[p.second]+e.cost+h[p.second]-h[e.to])\n\t\t\t\t\t{\n\t\t\t\t\t\td[e.to]=d[p.second]+e.cost+h[p.second]-h[e.to];\n\t\t\t\t\t\tpv[e.to]=p.second;\n\t\t\t\t\t\tpe[e.to]=i;\n\t\t\t\t\t\tP.push(make_pair(d[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[t]==numeric_limits<T>::max())return -1;\n\t\t\tfor(int u=0;u<G.size();u++)h[u]+=d[u];\n\t\t\tint d=f;\n\t\t\tfor(int u=t;u!=s;u=pv[u])d=min(d,G[pv[u]][pe[u]].cap);\n\t\t\tf-=d;\n\t\t\tret+=d*h[t];\n\t\t\tfor(int u=t;u!=s;u=pv[u])\n\t\t\t{\n\t\t\t\tG[pv[u]][pe[u]].cap-=d;\n\t\t\t\tG[u][G[pv[u]][pe[u]].rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\nmain()\n{\n\tint N;\n\twhile(cin>>N,N)\n\t{\n\t\tMCF<int>mf(366);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint L,R,M;cin>>L>>R>>M;\n\t\t\tmf.add_edge(L-1,R,1,-M);\n\t\t}\n\t\tfor(int i=0;i<365;i++)mf.add_edge(i,i+1,2,0);\n\t\tcout<<-mf.min_cost_flow(0,365,2)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> p;\n\nint dp[400][400];\n\nint main()\n{\n    int n;\n    while(scanf(\" %d\", &n),n)\n    {\n        vector<p> a(n);\n        rep(i,n)\n        {\n            int x,y,w;\n            scanf(\" %d %d %d\", &x, &y, &w);\n            a[i] = p(pi(x,y),w);\n        }\n        sort(all(a));\n\n        memset(dp,0,sizeof(dp));\n        rep(i,n)\n        {\n            int start = a[i].fi.fi;\n            int end = a[i].fi.se;\n            int w = a[i].se;\n\n            for(int x=365; x>0; --x)for(int y=x; y>0; --y)\n            {\n                if(start<y) continue;\n\n                int min_v = min(end+1,x), max_v = max(end+1,x);\n                dp[min_v][max_v] = max(dp[min_v][max_v], dp[y][x]+w);\n            }\n        }\n\n        int ans=0;\n        rep(i,400)rep(j,400) ans=max(ans,dp[i][j]);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n\ntypedef tuple<int, int, int> tup;\ntypedef long long ll;\n\nbool comp(tup a, tup b)\n{\n\treturn get<0>(a) < get<0>(b);\n}\n\nint N;\nvector<tup> app;\n\nll dp[366][366];\nll dp2[366][366];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\tapp.clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\tapp.push_back(tup(a, b, c));\n\t\t}\n\t\tsort(app.begin(), app.end(), comp);\n\n\t\trep(i, 0, 366) rep(j, 0, 366) dp[i][j] = 0;\n\n\t\tfor (auto p : app)\n\t\t{\n\t\t\tint a = get<0>(p) - 1;\n\t\t\tint b = get<1>(p);\n\t\t\tint c = get<2>(p);\n\n\t\t\trep(i, 0, 366) rep(j, 0, 366) dp2[i][j] = dp[i][j];\n\n\t\t\trrep(i, 365, 0) if (0 <= dp[a][i]) dp2[b][i] = max(dp2[b][i], dp[a][i] + c);\n\t\t\trrep(i, 365, 0) if (0 <= dp[i][a]) dp2[i][b] = max(dp2[i][b], dp[i][a] + c);\n\n\t\t\trep(i, 0, 366) rep(j, 0, 366)\n\t\t\t{\n\t\t\t\tif (i != 365) dp2[i + 1][j] = max(dp2[i + 1][j], dp2[i][j]);\n\t\t\t\tif (j != 365) dp2[i][j + 1] = max(dp2[i][j + 1], dp2[i][j]);\n\t\t\t\tif (i != 365 && j != 365) dp2[i + 1][j + 1] = max(dp2[i + 1][j + 1], dp2[i][j]);\n\t\t\t}\n\n\t\t\tswap(dp, dp2);\n\t\t}\n\n\t\t\n\t\t//rep(i, 0, 366) rep(j, 0, 366) printf(\"[%d,%d] = %lld\\n\", i, j, dp[i][j]);\n\t\tcout << dp[365][365] << endl;\n\n\t\t//return 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 400\n#define INF (1<<26)\nstruct edge{int to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V];\nint preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==INF)continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=d*dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nint a,b,c;\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    V=400;\n   \n    for(int i=0;i<357;i++)\n      add_edge(i,i+1,2,0);\n    \n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      add_edge(a,b+1,1,-c);\n    }\n    \n    cout<<-min_cost_flow(0,357,2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define DAY 365\n\nvector< vector<pair<int, int> > > data;\nint dp[2][DAY + 1][DAY + 1];\nint N;\nint main(){\n\twhile(cin >> N, N){\n\n\t\tdata.assign(DAY + 1, vector<pair<int ,int> >());\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint a, b, w;\n\t\t\tcin >> a >> b >> w;\n\t\t\tdata[a].push_back(pair<int, int>(b, w));\n\t\t}\n\t\tfor(int i = 0; i <= 1; i++){\n\t\t\tfor(int j = 0; j <= DAY; j++){\n\t\t\t\tfor(int k = 0; k <= DAY; k++){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= DAY; i++){\n\t\t\tint ci = i % 2;\n\t\t\tint pi = (i + 1) % 2;\n\t\t\tfor(int j = i; j <= DAY; j++){\n\t\t\t\tdp[ci][j][0] = max(dp[pi][j][0], dp[pi][j][i - 1]);\n\t\t\t}\n\t\t\tdp[ci][0][0] = max(dp[pi][0][0], max(dp[pi][i - 1][i - 1], dp[pi][i][0]));\n\t\t\t\n\t\t\tfor(int j = i; j <= DAY; j++){\n\t\t\t\tfor(int k = i; k <= j; k++){\n\t\t\t\t\tdp[ci][j][k] = dp[pi][j][k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j = 0;  j < data[i].size(); j++){\n\t\t\t\tfor(int k = j + 1; k < data[i].size(); k++){\n\t\t\t\t\tint n3 = data[i][j].first;\n\t\t\t\t\tint n4 = data[i][k].first;\n\t\t\t\t\tif(n3 < n4) swap(n3, n4);\n\t\t\t\t\tdp[ci][n3][n4] = max(dp[ci][n3][n4], dp[ci][0][0] + data[i][j].second + data[i][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto p : data[i]){\n\t\t\t\tint n3 = p.first;\n\t\t\t\tfor(int j = i; j < n3; j++){\n\t\t\t\t\tdp[ci][n3][j] = max(dp[ci][n3][j], dp[ci][j][0] + p.second);\n\t\t\t\t}\n\t\t\t\tfor(int j = n3; j <= DAY; j++){\n\t\t\t\t\tdp[ci][j][n3] = max(dp[ci][j][n3], dp[ci][j][0] + p.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << max(dp[1][0][0], max(dp[1][DAY][0], dp[1][DAY][DAY])) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\ntypedef ll PD_Type;\nconst PD_Type PD_INF = INF;\nstruct Primal_Dual\n{\n    typedef pair< PD_Type, int > pii;\n    \n    struct edge\n    {\n        int to, rev;\n        PD_Type    cap, cost;\n        edge() {}\n        edge(int to, PD_Type cap, PD_Type cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n        \n    };\n    vector< vector< edge > > graph;\n    vector< int > prevv, preve;\n    vector< PD_Type > potential, min_cost;\n    Primal_Dual(int V) : graph(V) {}\n    \n    void add_edge(int from, int to, PD_Type cap, PD_Type cost)\n    {\n        graph[from].push_back(edge(to, cap, cost, (int)graph[to].size()));\n        graph[to].push_back(edge(from, 0, -cost, (int)graph[from].size() - 1));\n    }\n    \n    PD_Type min_cost_flow(int s, int t, int f)\n    {\n        int V = (int)graph.size();\n        PD_Type ret = 0;\n        priority_queue< pii, vector< pii >, greater< pii > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n        \n        while (f > 0) {\n            min_cost.assign(V, PD_INF);\n            que.push(pii(0, s));\n            min_cost[s] = 0;\n            \n            while (!que.empty()) {\n                pii p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < (int)graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    PD_Type nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second; preve[e.to] = i;\n                        que.push(pii(min_cost[e.to], e.to));\n                    }\n                }\n            }\n            if (min_cost[t] == PD_INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            PD_Type addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n};\nint n;\nll solve(){\n    ll res = 0;\n    vector<int> from(n),to(n),w(n);\n    for(int i = 0; i < n;i++) cin >> from[i] >> to[i] >> w[i];\n    int S = 0,T = 365;\n    Primal_Dual PD(366);\n    for(int i = 0; i < 365;i++){\n        PD.add_edge(i,i+1,2,0);\n    }\n    for(int i = 0; i < n;i++){\n        PD.add_edge(from[i]-1,to[i],1,-w[i]);\n    }\n    res = -PD.min_cost_flow(S, T, 2);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> n,n){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<pair<int,int>,int> P;\n\nbool match[1001];\nint n;\nvector<P> schedules;\nint dp[1001][400];\npair<int,int> prv[1001][400];\n\n\nint calc(){\n    for(int i = 0; i < 1001; i++)for(int j = 0; j < 400; j++)prv[i][j].first=prv[i][j].second=0;\n    //  évfÜÅÝÄA»ÝÌúÜÅÉ¾çêéÅåàz\n    memset(dp,0,sizeof(dp));\n    for(int i = 0; i < n; i++){\n        for(int day=0;day<=366;day++){\n            // ú»\n            dp[i+1][day]=dp[i][day];\n            prv[i+1][day]=prv[i][day];\n            if(day!=0){\n                if(dp[i+1][day]<dp[i+1][day-1]){\n                    prv[i+1][day]=prv[i+1][day-1];\n                    dp[i+1][day]=dp[i+1][day-1];\n                }\n            }\n            // ¿å¤ÇIíèÌÆ±ëÆêv·éêAXV\n            if(!match[i]&&day==schedules[i].first.second+1){\n                if(dp[i+1][day]<dp[i][schedules[i].first.first]+schedules[i].second){\n                    // OÌêði[µÄ¨­\n                    prv[i+1][day]=make_pair(i,schedules[i].first.first);\n                    dp[i+1][day]=dp[i][schedules[i].first.first]+schedules[i].second;\n                }\n            }\n        }\n    }\n    pair<int,int> cp=prv[n][366];\n    while(1){\n        if(cp.first==0&&cp.second==0)break;\n        match[cp.first]=true;\n        cp=prv[cp.first][cp.second];\n    }\n    return dp[n][366];    \n}\n\nint main(){\n\n    while(cin>>n&&n!=0){\n        schedules.clear();\n        for(int i = 0; i < n; i++){\n            P p;\n            cin>>p.first.first>>p.first.second>>p.second;\n            schedules.push_back(p);\n        }\n        sort(schedules.begin(),schedules.end());\n        memset(match,0,sizeof(match));\n        int sum=calc()+calc();\n        cout<<sum<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define MAX_V 400\n#define INF (1LL<<55)\nstruct edge{ll to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nll dist[MAX_V];\nll prevv[MAX_V];\nll preve[MAX_V];\n\nvoid add_edge(ll from,ll to,ll cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(ll)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(ll)G[from].size()-1});\n}\n\nll min_cost_flow(int s,int t,ll f){\n  ll res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==INF)continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    ll d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=d*dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nll a,b,c;\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    V=400;\n   \n    for(int i=0;i<357;i++)\n      add_edge(i,i+1,2,0);\n    \n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      add_edge(a,b+1,1,-c);\n    }\n    \n    cout<<-min_cost_flow(0,357,2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<utility>\nusing namespace std;\n\nstruct S{\n\tint j,w;\n\tS(){}\n\tS(int j,int w):j(j),w(w){}\n\tbool operator<(const S&rhv)const{return j<rhv.j;}\n};\nconst int Y = 366;\ntypedef pair<S,bool>P;\n\nint memo[Y];\nint memo2[Y];\nvector<P>v[Y];\nint Solve2(int now)\n{\n\tif(now >= Y)\n\t\treturn 0;\n\tint &ref = memo2[now];\n\tif(ref >= 0)\n\t\treturn ref;\n\tref = Solve2(now+1);\n\tfor(int i=0; i<v[now].size(); ++i)\n\t{\n\t\tif(v[now][i].second)\n\t\t\tcontinue;\n\t\tconst S &s = v[now][i].first;\n\t\tref = max(ref, s.w+Solve2(s.j+1));\n\t}\n\treturn ref;\n}\nint Solve(int now)\n{\n\tif(now >= Y)\n\t{\n\t\tmemset(memo2,-1,sizeof(memo2));\n\t\treturn Solve2(1);\n\t}\n\tint &ref = memo[now];\n\tif(ref >= 0)\n\t\treturn ref;\n\tref = Solve(now+1);\n\tfor(int i=now+1; i<Y; ++i)\n\t\tmemo[i]=-1;\n\tfor(int i=0; i<v[now].size(); ++i)\n\t{\n\t\tif(v[now][i].second)\n\t\t\tcontinue;\n\t\tv[now][i].second = true;\n\t\tconst S &s = v[now][i].first;\n\t\tref = max(ref, s.w+Solve(s.j+1));\n\t\tv[now][i].second = false;\n\t}\n\treturn ref;\n}\nint main()\n{\n\tint n,i,j,w;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tfor(i=0;i<Y;++i)\n\t\t\tv[i].clear();\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&i,&j,&w);\n\t\t\tv[i].push_back(P(S(j,w),false));\n\t\t}\n\t\tfor(i=0;i<Y;++i)\n\t\t\tsort(v[i].begin(),v[i].end());\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tprintf(\"%d\\n\",Solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 400;\n\nint main(void){\n  int N,S[MAX_N],T[MAX_N],W[MAX_N],dp[MAX_N][MAX_N];\n\n  while(cin >> N,N){\n\n    for(int i=0;i<N;i++){\n      cin >> S[i] >> T[i] >> W[i];\n    }\n\n    for(int i=0;i<N;i++){\n      for(int j=i;j<N;j++){\n\tif(T[i]>T[j]){\n\t  swap(S[i],S[j]);\n\t  swap(T[i],T[j]);\n\t  swap(W[i],W[j]);\n\t}\n      }\n    }\n\n    fill(dp[0],dp[MAX_N],0);\n\n    for(int i=0;i<N;i++){\n      for(int j=365;j>=0;j--){\n\tfor(int k=365;k>=0;k--){\n\t  if(j<S[i])dp[T[i]][k]=max(dp[T[i]][k],dp[j][k]+W[i]);\n\t  if(k<S[i])dp[j][T[i]]=max(dp[j][T[i]],dp[j][k]+W[i]);\n\t}\n      }\n    }\n\n    int ans=0;\n    for(int i=0;i<366;i++){\n      for(int j=0;j<366;j++){\n\tans=max(ans,dp[i][j]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<pair<int,int>,int> P;\n\nint dp[1001][400];\npair<int,int> prv[1001][400];\nbool match[1001];\nint n;\nvector<P> schedules;\n\nint calc(){\n    //  évfÜÅÝÄA»ÝÌúÜÅÉ¾çêéÅåàz\n    memset(dp,0,sizeof(dp));\n    for(int i = 0; i < n; i++){\n        for(int day=0;day<=366;day++){\n            // ú»\n            dp[i+1][day]=dp[i][day];\n            prv[i+1][day]=prv[i][day];\n            if(day!=0){\n                if(dp[i+1][day]<dp[i+1][day-1]){\n                    prv[i+1][day]=prv[i+1][day-1];\n                    dp[i+1][day]=dp[i+1][day-1];\n                }\n            }\n            // ¿å¤ÇIíèÌÆ±ëÆêv·éêAXV\n            if(!match[i]&&day==schedules[i].first.second+1){\n                if(dp[i+1][day]<dp[i][schedules[i].first.first]+schedules[i].second){\n                    // OÌêði[µÄ¨­\n                    prv[i+1][day]=make_pair(i,schedules[i].first.first);\n                    dp[i+1][day]=dp[i][schedules[i].first.first]+schedules[i].second;\n                }\n            }\n        }\n    }\n    //cout<<dp[n][366]<<endl;\n    pair<int,int> cp=prv[n][366];\n    while(1){\n        if(cp.first==0&&cp.second==0)break;\n        //cout<<cp.first<<\" \"<<cp.second<<endl;\n        match[cp.first]=true;\n        cp=prv[cp.first][cp.second];\n    }\n    return dp[n][366];    \n}\n\nint main(){\n\n    while(cin>>n&&n!=0){\n        schedules.clear();\n        for(int i = 0; i < n; i++){\n            P p;\n            cin>>p.first.first>>p.first.second>>p.second;\n            schedules.push_back(p);\n        }\n        sort(schedules.begin(),schedules.end());\n        memset(match,0,sizeof(match));\n        int sum=calc()+calc();\n        cout<<sum<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\n\n//\n// Minimum Cost Maximum Flow (Tomizawa, Edmonds-Karp's successive shortest path)\n//\n// Description:\n//   Given a directed graph G = (V,E) with nonnegative capacity c and cost w.\n//   The algorithm find a maximum s-t flow of G with minimum cost.\n// \n// Algorithm:\n//   Tomizawa (1971), and Edmonds and Karp (1972)'s \n//   successive shortest path algorithm,\n//   which is also known as the primal-dual method.\n//\n// Complexity:\n//   O(F m log n), where F is the amount of maximum flow.\n// \n// References:\n//   N. Tomizawa (1971):\n//   On some techniques useful for solution of transportation network problems.\n//   Networks, vol. pp. 173-194.\n//\n//   J. Edmonds and R.M. Karp (1972):\n//   Theoretical improvements in algorithmic efficiency for network flow problems.\n//   Journal of ACM, vol. 19, pp. 248-264.\n//\n// Historical Note:\n//   The successive shortest path type algorithm was developped\n//   independently by Jewell (1958), Iri (1960), and Busacker and Gowen (1961).\n//   Later, Tomizawa (1971), and Edmonds and Karp (1972) independently \n//   suggested to use vertex potential in shortest path algorithm.\n// \n\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define TEST(s) if (!(s)) { cout << __LINE__ << \" \" << #s << endl; exit(-1); }\n\nconst long long INF = 99999999;\nstruct graph {\n  typedef LL flow_type;\n  typedef LL cost_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    cost_type cost;\n    size_t rev;\n  };\n  vector<edge> edges;\n  void add_edge(int src, int dst, flow_type cap, cost_type cost) {\n    adj[src].push_back({src, dst, cap, 0, cost, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, -cost, adj[src].size()-1});\n  }\n  int n;\n  vector<vector<edge>> adj;\n  graph(int n) : n(n), adj(n) { }\n\n  pair<flow_type, cost_type> min_cost_max_flow(int s, int t) {\n    flow_type flow = 0;\n    cost_type cost = 0;\n\n    for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n\n    vector<cost_type> p(n, 0);\n\n    auto rcost = [&](edge e) { return e.cost + p[e.src] - p[e.dst]; };\n    for (int iter = 0; ; ++iter) {\n      vector<int> prev(n, -1); prev[s] = 0;\n      vector<cost_type> dist(n, INF); dist[s] = 0;\n      if (iter == 0) { // use Bellman-Ford to remove negative cost edges\n        vector<int> count(n); count[s] = 1;\n        queue<int> que; \n        for (que.push(s); !que.empty(); ) {\n          int u = que.front(); que.pop();\n          count[u] = -count[u];\n          for (auto &e: adj[u]) {\n            if (e.capacity > e.flow && dist[e.dst] > dist[e.src] + rcost(e)) {\n              dist[e.dst] = dist[e.src] + rcost(e);\n              prev[e.dst] = e.rev;\n              if (count[e.dst] <= 0) {\n                count[e.dst] = -count[e.dst] + 1;\n                que.push(e.dst);\n              }\n            }\n          }\n        }\n      } else { // use Dijkstra \n        typedef pair<cost_type, int> node;\n        priority_queue<node, vector<node>, greater<node>> que;\n        que.push({0, s});\n        while (!que.empty()) {\n          node a = que.top(); que.pop();\n          if (a.snd == t) break;\n          if (dist[a.snd] > a.fst) continue;\n          for (auto e: adj[a.snd]) {\n            if (e.capacity > e.flow && dist[e.dst] > a.fst + rcost(e)) {\n              dist[e.dst] = dist[e.src] + rcost(e);\n              prev[e.dst] = e.rev;\n              que.push({dist[e.dst], e.dst});\n            }\n          }\n        }\n      }\n      if (prev[t] == -1) break;\n\n      for (int u = 0; u < n; ++u) {\n        if (dist[u] != INF) {\n          p[u] += dist[u] - dist[t];\n        }\n        /*if (dist[u] < dist[t]) {\n          p[u] += dist[u] - dist[t];\n        }*/\n        //printf(\"p[%d]: %lld\\n\", u, p[u]);\n      }\n\n      function<flow_type(int,flow_type)> augment = [&](int u, flow_type cur) {\n        if (u == s) return cur;\n        edge &r = adj[u][prev[u]], &e = adj[r.dst][r.rev];\n        flow_type f = augment(e.src, min(e.capacity - e.flow, cur));\n        e.flow += f; r.flow -= f;\n        return f;\n      };\n      flow_type f = augment(t, INF);\n      flow += f;\n      cost += f * (p[t] - p[s]);\n    }\n    return {flow, cost};\n  }\n};\n\nint N;\nint L[1145];\nint R[1145];\nLL W[1145];\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) return 0;\n\n    graph G(2*N + 10);\n    rep(i, N) {\n      scanf(\"%d%d%lld\", &L[i], &R[i], &W[i]);\n      R[i]++;\n    }\n\n    int P = N*2;\n    int Q = N*2 + 1;\n    int T = N*2 + 2;\n    G.add_edge(P, Q, 2, 0);\n    LL ans = 0;\n    rep(i, N) {\n      G.add_edge(Q, i*2, 1, 0);\n      G.add_edge(i*2+1, T, 1, 0);\n      G.add_edge(i*2, i*2+1, 1, -W[i]);\n      //G.add_edge(i*2+1, i*2, 1, W[i]);\n      ans += W[i];\n      rep(j, N) {\n        if (i == j) continue;\n        if (R[i] > L[j]) continue;\n\n        G.add_edge(i*2+1, j*2, 1, 0);\n      }\n    }\n    printf(\"%lld\\n\", -G.min_cost_max_flow(P, T).second);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\nusing namespace std;\n\nint main()\n{\n  int a,b,c,n;\n\n  while(1){\n    cin>>n;\n    vector<pair<pair<int,int>,int> > vpp;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      vpp.push_back(mp(mp(a,b),c));\n    }\n    sort(vpp.begin(),vpp.end());\n\n    int dp[400][400]={};\n    for(int i=0;i<400;i++)for(int j=0;j<400;j++)dp[i][j]=-1;\n\n    dp[0][0]=0;\n    for(int i=0;i<n;i++){\n      for(int j=365;j>=0;j--){\n\tfor(int k=0;k<vpp[i].f.f;k++){\n\t  if(dp[j][k]!=-1)\n\t    dp[j][vpp[i].f.s]=max(dp[j][vpp[i].f.s],dp[j][k]+vpp[i].s);\n\t  if(dp[k][j]!=-1)\n\t    dp[vpp[i].f.s][j]=max(dp[vpp[i].f.s][j],dp[k][j]+vpp[i].s);\n\t}\n      }\n    }\n    int ans=0;\n    for(int i=0;i<=365;i++)\n      for(int j=0;j<=365;j++)ans=max(ans,dp[i][j]);\n\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 100000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\nint n;\nvector<edge> G[370];\nconst int S = 0, T = 366;\nint prevv[370], preve[370];\n\nvoid add_edge(int s, int t, int cap, int cost)\n{\n\tG[s].push_back( edge(t, cap, cost, G[t].size()) );\n\tG[t].push_back( edge(s, 0, -cost, G[s].size()-1) );\n}\n\nvoid BellmanFord()\n{\n\tint dist[370];\n\tfor(int i = S; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0;\n\tprevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = S; i <= T; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\tfor(int i = S; i <= T; i++) G[i].clear();\n\t\tfor(int i = S; i < T; i++) add_edge(i, i+1, inf, 0);\n\t\t\n\t\tint ii, jj, ww;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> ii >> jj >> ww;\n\t\t\tadd_edge(ii, jj+1, 1, -ww);\n\t\t}\n\t\t\n\t\tint F = 2, ans = 0;\n\t\twhile(F > 0){\n\t\t\tBellmanFord();\n\t\t\t\n\t\t\tint flow = F;\n\t\t\tint p = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\t\n\t\t\tp = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tans += G[prevv[p]][preve[p]].cost * flow;\n\t\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\tF -= flow;\n\t\t}\n\t\tcout << -ans << endl;\n\t}\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <random>\n#include <complex>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint dp[2][400][400];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n){\n\t\tvector<tuple<int, int, int>> v;\n\t\trep(i, n){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv.push_back(MT(b, a, c));\n\t\t}\n\t\tsort(ALL(v));\n\t\tMEMSET(dp, 0);\n\t\tint cur = 0, nxt = 1;\n\t\trep(i, n){\n\t\t\tint a, b, c;\n\t\t\ttie(b, a, c) = v[i];\n\t\t\trep(j, 400) rep(k, 400){\n\t\t\t\tdp[nxt][j][k] = max(dp[nxt][j][k], dp[cur][j][k]);\n\t\t\t\tif (j < a) dp[nxt][b][k] = max(dp[nxt][b][k], dp[cur][j][k] + c);\n\t\t\t\tif (k < a) dp[nxt][j][b] = max(dp[nxt][j][b], dp[cur][j][k] + c);\n\t\t\t}\n\t\t\tswap(cur, nxt);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 400)rep(j, 400) ans = max(ans, dp[cur][i][j]);\n\t\tcout << ans << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    struct E {\n        int from, to, w;\n        E(int from, int to, int w) : from(from), to(to), w(w) {}\n        bool operator<(const E& e) const {\n            if (from == e.from) {\n                return to < e.to;\n            }\n            return from < e.from;\n        }\n    };\n\n    int N;\n    vector<E> P;\n    bool input() {\n        cin >> N;\n        if (N == 0) return false;\n        P.clear();\n        for (int i = 0; i < N; i++) {\n            int x, y, w; cin >> x >> y >> w;\n            P.push_back(E(x, y, w));\n        }\n        return true;\n    }\n\n    const int INF = 1<<28;\n    void solve() {\n        sort(P.begin(), P.end());\n        static int dp[2][367][367];\n        memset(dp, 0, sizeof(dp));\n        int ans = 0;\n        for (int i = 0; i < N; i++) {\n            const E& e = P[i];\n            for (int j = 0; j <= 366; j++) for (int k = 0; k <= 366; k++) {\n                dp[(i + 1) & 1][j][k] = dp[i & 1][j][k];\n            }\n            for (int j = 0; j <= 366; j++) {\n                dp[(i + 1) & 1][j][e.to + 1] = max(dp[i & 1][j][e.to + 1], dp[i & 1][j][e.from] + e.w);\n                int c = dp[(i + 1) & 1][j][e.to + 1];\n                for (int k = e.to + 1; k <= 366; k++) {\n                    c = max(c, dp[(i + 1) & 1][j][k]);\n                    dp[(i + 1) & 1][j][k] = c;\n                }\n            }\n            for (int j = 0; j <= 366; j++) {\n                dp[(i + 1) & 1][e.to + 1][j] = max(dp[i & 1][e.to + 1][j], dp[i & 1][e.from][j] + e.w);\n                int c = dp[(i + 1) & 1][j][e.to + 1];\n                for (int k = e.to + 1; k <= 366; k++) {\n                    c = max(c, dp[(i + 1) & 1][k][j]);\n                    dp[(i + 1) & 1][k][j] = c;\n                }\n            }\n        }\n        cout << dp[(N + 1) & 1][366][366] << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_V 550\n#define INF 1e8\n \nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev) :\n\tto(to),cap(cap),cost(cost),rev(rev) {}\n};\n \nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n \nint min_cost_flow(int s,int t,int f){\n    int res = 0;\n    while(f > 0){\n\tfill(dist,dist+MAX_V,INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update){\n\t    update = false;\n\t    for(int v = 0 ; v < MAX_V ; v++){\n\t\tif(dist[v] == INF) continue;\n\t\tfor(int i = 0 ; i < (int)G[v].size() ; i++){\n\t\t    edge &e = G[v][i];\n\t\t    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t    }\n\t\t}\n\t    }\n\t}\n     \n\tif(dist[t] == INF){\n\t    return -1;\n\t}\n     \n\tint d = f;\n\tfor(int v = t ; v != s ; v = prevv[v]){\n\t    d = min(d,G[prevv[v]][preve[v]].cap);\n\t}\n\tf -= d;\n\tres += d * dist[t];\n\tfor(int v = t ; v != s ; v = prevv[v]){\n\t    edge &e = G[prevv[v]][preve[v]];\n\t    e.cap -= d;\n\t    G[v][e.rev].cap += d;\n\t}\n    }\n    return res;\n}\n \nint main(){\n    int N;\n    while(cin >> N, N){\n\tfor(int i = 0 ; i < MAX_V ; i++){\n\t    G[i].clear();\n\t}\n\tint a,b,w;\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> a >> b >> w;\n\t    add_edge(a-1,b,1,-w);\n\t}\n\tfor(int i = 0 ; i < 365 ; i++){\n\t    add_edge(i,i+1,2,0);\n\t}\n\tcout << -min_cost_flow(0,365,2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 100000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\nint n;\nvector<edge> G[370];\nconst int S = 0, T = 366;\nint prevv[370], preve[350];\n\nvoid add_edge(int s, int t, int cap, int cost)\n{\n\tG[s].push_back( edge(t, cap, cost, G[t].size()) );\n\tG[t].push_back( edge(s, 0, -cost, G[s].size()-1) );\n}\n\nvoid BellmanFord()\n{\n\tint dist[370];\n\tfor(int i = S; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0;\n\tprevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = S; i <= T; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\tfor(int i = S; i <= T; i++) G[i].clear();\n\t\tfor(int i = S; i < T; i++) add_edge(i, i+1, inf, 0);\n\t\t\n\t\tint ii, jj, ww;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> ii >> jj >> ww;\n\t\t\tadd_edge(ii, jj+1, 1, -ww);\n\t\t}\n\t\t\n\t\tint F = 2, ans = 0;\n\t\twhile(F > 0){\n\t\t\tBellmanFord();\n\t\t\t\n\t\t\tint flow = F;\n\t\t\tint p = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\t\n\t\t\tp = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tans += G[prevv[p]][preve[p]].cost * flow;\n\t\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\tF -= flow;\n\t\t}\n\t\tcout << -ans << endl;\n\t}\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst int MX=1000;\n\nint n,s[MX],t[MX],p[MX];\npair<int,pi> in[MX];\nint dp[366][366];\n\nint main()\n{\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\trep(i,n)scanf(\"%d%d%d\",&in[i].first,&in[i].second.first,&in[i].second.second);\n\t\tsort(in,in+n);\n\t\trep(i,n)s[i]=in[i].first,t[i]=in[i].second.first,p[i]=in[i].second.second;\n\t\t\n\t\trep(i,366)rep(j,366)dp[i][j]=0;\n\t\t\n\t\trep(i,n)\n\t\t{\n\t\t\tfor(int k=365;k>=0;k--)for(int j=s[i]-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tdp[t[i]][k]=max(dp[t[i]][k],dp[j][k]+p[i]);\n\t\t\t\tdp[k][t[i]]=max(dp[k][t[i]],dp[k][j]+p[i]);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,366)rep(j,366)ans=max(ans,dp[i][j]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst int MX=1000;\n\nint n,s[MX],t[MX],p[MX];\npair<int,pi> in[MX];\nint dp[2][366][366];\n\nint main()\n{\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\trep(i,n)scanf(\"%d%d%d\",&in[i].first,&in[i].second.first,&in[i].second.second);\n\t\tsort(in,in+n);\n\t\trep(i,n)s[i]=in[i].first,t[i]=in[i].second.first,p[i]=in[i].second.second;\n\t\t\n\t\trep(i,366)rep(j,366)dp[0][i][j]=0;\n\t\t\n\t\tint cur=0,next=1;\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,366)rep(k,366)dp[next][j][k]=dp[cur][j][k];\n\t\t\trep(j,s[i])rep(k,366)\n\t\t\t{\n\t\t\t\tdp[next][t[i]][k]=max(dp[next][t[i]][k],dp[cur][j][k]+p[i]);\n\t\t\t\tdp[next][k][t[i]]=max(dp[next][k][t[i]],dp[cur][k][j]+p[i]);\n\t\t\t}\n\t\t\tswap(cur,next);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,366)rep(j,366)ans=max(ans,dp[cur][i][j]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int YEAR=365;\n\nstruct Req{\n    int i,j,w;\n};\n\nvoid cmax(int &lhs,int rhs){\n    lhs=max(lhs,rhs);\n}\nint solve(int n){\n    vector<vector<Req>> req(YEAR);\n    for(int k=0;k<n;k++){\n        int i,j,w;\n        cin>>i>>j>>w;\n        i--;\n        req[i].push_back({i,j,w});\n    } \n    vector<vector<int>> dp(YEAR+1,vector<int>(YEAR+1));\n    for(int i=0;i<=YEAR;i++){\n        for(int j=0;j<=YEAR;j++){\n            if(i==YEAR && j==YEAR) continue;\n            if(i<j){\n                for(auto &r:req[i]){\n                    cmax(dp[r.j][j],dp[i][j]+r.w);\n                }\n                cmax(dp[i+1][j],dp[i][j]);\n            }\n            else if(j<i){\n                for(auto &r:req[j]){\n                    cmax(dp[i][r.j],dp[i][j]+r.w);\n                }\n                cmax(dp[i][j+1],dp[i][j]);\n            }\n            else{\n                assert(i<YEAR && j<YEAR);\n                for(int ki=0;ki<req[i].size();ki++){\n                    for(int kj=ki+1;kj<req[j].size();kj++){\n                        cmax(dp[req[i][ki].j][req[j][kj].j],dp[i][j]+req[i][ki].w+req[j][kj].w);                        \n                    }\n                }        \n                for(auto &r:req[i]){\n                    cmax(dp[r.j][j+1],dp[i][j]+r.w);\n                }\n                for(auto &r:req[j]){\n                    cmax(dp[i+1][r.j],dp[i][j]+r.w);\n                }\n                cmax(dp[i+1][j+1],dp[i][j]);    \n            }\n        }\n    }\n    return dp[YEAR][YEAR];\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int IINF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nconst int MAX_V = 367;\nstruct edge {\n\tint to, cap, cost, rev;\n};\nint V = MAX_V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].pb((edge){to, cap, cost, G[to].size()});\n\tG[to].pb((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tint prevv[MAX_V] = {}, preve[MAX_V] = {};\n\twhile(f > 0) {\n\t\tfill(dist, dist + V, IINF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update) {\n\t\t\tupdate = false;\n\t\t\tREP(v, V) {\n\t\t\t\tif(dist[v] == IINF) continue;\n\t\t\t\tREP(i, G[v].size()) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == IINF)\n\t\t\treturn -1;\n\t\tint d = f;\n\t\tfor(int v= t; v != s; v = prevv[v])\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v= t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\twhile(cin >> n, n) {\n\t\tREP(i, MAX_V) {\n\t\t\tG[i].clear();\n\t\t\tdist[i] = 0;\n\t\t}\n\t\tREP(i, n) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tadd_edge(a-1, b, 1, -c);\n\t\t}\n\t\tREP(i, 365)\n\t\t\tadd_edge(i, i+1, 2, 0);\n\t\tcout << -min_cost_flow(0, 365, 2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define MAX_N 400\n\nint main(void){\n  int N,S[MAX_N],T[MAX_N],W[MAX_N],dp[MAX_N][MAX_N];\n\n  while(cin >> N,N){\n\n    for(int i=0;i<N;i++){\n      cin >> S[i] >> T[i] >> W[i];\n    }\n\n    for(int i=0;i<N;i++){\n      for(int j=i;j<N;j++){\n\tif(T[i]>T[j]){\n\t  swap(S[i],S[j]);\n\t  swap(T[i],T[j]);\n\t  swap(W[i],W[j]);\n\t}\n      }\n    }\n\n    for(int i=0;i<400;i++)\n      for(int j=0;j<400;j++)\n\tdp[i][j]=0;\n\n    for(int i=0;i<N;i++){\n      for(int j=365;j>=0;j--){\n\tfor(int k=365;k>=0;k--){\n\t  if(j<S[i])dp[T[i]][k]=max(dp[T[i]][k],dp[j][k]+W[i]);\n\t  if(k<S[i])dp[j][T[i]]=max(dp[j][T[i]],dp[j][k]+W[i]);\n\t}\n      }\n    }\n\n    int ans=0;\n    for(int i=0;i<366;i++){\n      for(int j=0;j<366;j++){\n\tans=max(ans,dp[i][j]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nPP A[1001];\nvoid Max(int &a,int b){a=max(a,b);}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>A[i].f.s>>A[i].f.f>>A[i].s;\n    sort(A,A+n);\n    \n    int dp[2][367][367]={};\n    for(int i=0;i<n;i++){\n      int l=A[i].f.s,r=A[i].f.f+1,c=A[i].s,b=i%2;\n      for(int j=0;j<=366;j++)\n\tfor(int k=0;k<=366;k++){\n\t  Max(dp[!b][j][k],dp[b][j][k]);\n\t  if(j<=l)Max(dp[!b][r][k],dp[b][j][k]+c);\n\t  if(k<=l)Max(dp[!b][j][r],dp[b][j][k]+c);\n\t}\n\n    }\n    int ans=0;  \n    for(int i=0;i<=366;i++)\n      for(int j=0;j<=366;j++)Max(ans,dp[n%2][i][j]);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nusing tp = tuple<int, int, int>;\n\nint n;\ntp a[1000];\nint dp[2][366][366];\n\n/* MLE tsurai.\nint calc(int i, int j, int k)\n{\n\tif (i == n) return 0;\n\tint &res = dp[i][j][k];\n\tif (~res) return res;\n\t\n\tint x, y, z;\n\ttie(x, y, z) = a[i];\n\n\tchmax(res, calc(i + 1, j, k));\n\tif (x >= j) chmax(res, z + calc(i + 1, y, k));\n\tif (x >= k) chmax(res, z + calc(i + 1, j, y));\n\n\treturn res;\n}\n*/\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\ta[i] = tie(--x, y, z);\n\t\t}\n\t\tsort(a, a + n);\n\t\t\n\t\t/* memoka saiki shitai.\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tcout << calc(0, 0, 0) << endl;\n\t\t*/\n\t\t\n\t\t// kanashimi.\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, n){\n\t\t\tint src = i & 1, dst = ~i & 1;\n\t\t\tmemset(dp[dst], 0, sizeof(dp[dst]));\n\t\t\tint x, y, z;\n\t\t\ttie(x, y, z) = a[i];\n\t\t\trep(j, x + 1) rep(k, 366){\n\t\t\t\tchmax(dp[dst][y][k], dp[src][j][k] + z);\n\t\t\t\tchmax(dp[dst][k][y], dp[src][k][j] + z);\n\t\t\t}\n\t\t\trep(j, 366) rep(k, 366){\n\t\t\t\tchmax(dp[dst][j][k], dp[src][j][k]);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\trep(i, 366) rep(j, 366){\n\t\t\tchmax(res, dp[n & 1][i][j]);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct D{\n\tint l, r, d;\n\tbool operator < ( const D &right ) const {\n\t\treturn r < right.r;\n\t}\n};\n\nint n;\nint memo[1001][367][367];\nD d[1000];\n\nvoid dfs(int idx, int i, int j, int sum){\n\tif(memo[idx][i][j] >= sum) return;\n\tmemo[idx][i][j] = sum;\n\tif(idx == n) return;\n\n\tauto p = d[idx];\n\n\t//cout << i << ' ' << j << ' ' << sum << endl;\n\t//cout << p.l << ' ' << p.r << ' ' << p.d << endl;\n\tidx++;\n\tif(p.l >= i){\n\t\tdfs(idx, p.r + 1, j, sum + p.d);\n\t}\n\tif(p.l >= j){\n\t\tdfs(idx, i, p.r + 1, sum + p.d);\n\t}\n\tdfs(idx, i, j, sum);\n}\n\n\nint main(){\n\twhile(cin >> n,n){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\trep(i,n){\n\t\t\tauto& p = d[i];\n\t\t\tcin >> p.l >> p.r >> p.d;\n\t\t\tp.l--; p.r--;\n\t\t}\n\t\tsort(d, d + n);\n\t\tdfs(0, 0, 0, 0);\n\n\t\tint ans = 0;\n\t\trep(i,400){\n\t\t\trep(j,400){\n\t\t\t\tans = max(ans, memo[n][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <functional>\n#define INF 2e9\n#define MAX_V 10000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct edge{\n\tint to,cap,cost,rev;\n\tedge(int tt=0,int ca=0,int co=0,int re=0){\n\t\tto=tt;\n\t\tcap=ca;\n\t\tcost=co;\n\t\trev=re;\n\t}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint preve[MAX_V],prevv[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back(edge(to,cap,cost,G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n\tll res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(que.size()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first)continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF)return -1;\n\t\tfor(int v=0;v<V;v++){\n\t\t\th[v]+=dist[v];\n\t\t}\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct data{\n\tint f,t,p;\n\tdata(int ff=0,int tt=0,int pp=0){\n\t\tf=ff;\n\t\tt=tt;\n\t\tp=pp;\n\t}\n};\n\nint n;\ndata dat[1001];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tV=n*2+4;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tint res=0;\n\t\tint S=n*2,T=n*2+1,s=n*2+2,t=n*2+3;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d\",&dat[i].f,&dat[i].t,&dat[i].p);\n\t\t\tres+=dat[i].p;\n\t\t\tadd_edge(i*2+1,i*2,1,dat[i].p);\n\t\t\tadd_edge(S,i*2+1,1,0);\n\t\t\tadd_edge(i*2,T,1,0);\n\t\t}\n\t\tadd_edge(S,s,2,0);\n\t\tadd_edge(t,T,2,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tadd_edge(s,i*2,1,0);\n\t\t\tadd_edge(i*2+1,t,1,0);\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(dat[i].t<dat[j].f){\n\t\t\t\t\tadd_edge(i*2+1,j*2,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res-min_cost_flow(S,T,2+n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\ntypedef pair<l_l, ll> lll;\nll N;\nvector<lll> v;\nll dp[366][366];\n\nvoid solve() {\n    for(int i = 0; i <= 365; i++) {\n        for(int j = 0; j <= 365; j++) {\n            dp[i][j] = -1e18;\n        }\n    }\n    dp[0][0] = 0;\n    v.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> v[i].first.first >> v[i].first.second >> v[i].second;\n    }\n    sort(v.begin(), v.end());\n    for(auto now : v) {\n        for(int i = 365; i >= 0; i--) {\n            for(int j = i; j >= 0; j--) {\n                if(i < now.first.first) {\n                    int newi = now.first.second;\n                    int newj = j;\n                    if(newi < newj) swap(newi, newj);\n                    chmax(dp[newi][newj], dp[i][j] + now.second);\n                }\n                if(j < now.first.first) {\n                    int newj = now.first.second;\n                    int newi = i;\n                    if(newi < newj) swap(newi, newj);\n                    chmax(dp[newi][newj], dp[i][j] + now.second);\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    for(int i = 0; i <= 365; i++) {\n        for(int j = 0; j <= 365; j++) {\n            chmax(ans, dp[i][j]);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\nconst long long int INF = 9223372036854775807;\n\ntypedef long long int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight capacity;\n\tWeight cost;\n\tEdge(int src, int dst, Weight acap, Weight acost) :\n\t\tsrc(src), dst(dst), capacity(acap), cost(acost) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.cost > f.cost;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n\n//グラフは有向で逆辺は無いものとする．\n\n//Graph &ag\n//有向で，任意の辺(u, v, capacity, cost) に対して逆辺(u, v, 0, -cost) があるグラフ．この条件を満たす上で単純グラフでなければならない．\n//int s, int t\n//フローの始点と終点．\n//戻り値\n//費用と流せた流量の対．\npair<Weight, Weight> minimumCostFlow(const Graph &ag, int s, int t) {\n\n\t//check　単純グラフになっているか？\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, 0, -ag[i][j].cost));\n\t\t\t}\n\t\t}\n\t}\n\tconst int n = g.size();\n\tMatrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) {\n\t\tcapacity[e->src][e->dst] += e->capacity;\n\t\tcost[e->src][e->dst] += e->cost;\n\t}\n\tpair<Weight, Weight> total; // (cost, flow)\n\tvector<Weight> h(n);\n\n\tfor (Weight F = INF; F > 0; ) { // residual flow\n\t\tvector<Weight> d(n, INF); d[s] = 0;\n\t\tvector<int> p(n, -1);\n\t\tpriority_queue<Edge> Q; // \"e < f\" <=> \"e.cost > f.cost\"\n\t\tfor (Q.push(Edge(-2, s, 0, 0)); !Q.empty(); ) {\n\t\t\tEdge e = Q.top(); Q.pop();\n\t\t\tif (p[e.dst] != -1) continue;\n\t\t\tp[e.dst] = e.src;\n\t\t\tFOR(f, g[e.dst]) if (RESIDUE(f->src, f->dst) > 0) {\n\t\t\t\tif (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n\t\t\t\t\td[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n\t\t\t\t\tQ.push(Edge(f->src, f->dst, 0, d[f->dst]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p[t] == -1) break;\n\n\t\tWeight f = F;\n\t\tfor (int u = t; u != s; u = p[u])\n\t\t\tf = min(f, RESIDUE(p[u], u));\n\t\tfor (int u = t; u != s; u = p[u]) {\n\t\t\ttotal.first += f * cost[p[u]][u];\n\t\t\tflow[p[u]][u] += f; flow[u][p[u]] -= f;\n\t\t}\n\t\tF -= f;\n\t\ttotal.second += f;\n\t\tREP(u, n) h[u] += d[u];\n\t}\n\treturn total;\n}\n\n\nint main() {\n\tconst long long int max_day = 1000000;\n\twhile (1) {\n\t\tGraph g(1400);\n\t\tint n; cin >> n;\n\t\tconst int start = 367;\n\t\tconst int goal = 368;\n\t\tg[start].push_back(Edge(start, 0, 2, 0));\n\t\tg[365].push_back(Edge(365, goal, 2, 0));\n\t\tfor (int i = 0; i < 365; ++i) {\n\t\t\tg[i].push_back(Edge(i, i + 1, 2, max_day));\n\t\t}\n\t\tif (!n)break;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong long int ai, j, w; cin >> ai >> j >> w;\n\t\t\tlong long int money = max_day*(j - ai + 1) - w;\n\t\t\tg[ai - 1].push_back(Edge(ai - 1, 400+i, 1, 0));\n\t\t\tg[400 + i].push_back(Edge(400 + i, j, 1, money));\n\t\t}\n\t\tlong long int ans = max_day *2* 365 - minimumCostFlow(g, start, goal).first;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> p;\n\nint dp[400][400];\n\nint main()\n{\n    int n;\n    while(scanf(\" %d\", &n),n)\n    {\n        vector<p> a(n);\n        rep(i,n)\n        {\n            int x,y,w;\n            scanf(\" %d %d %d\", &x, &y, &w);\n            a[i] = p(pi(x,y),w);\n        }\n        sort(all(a));\n\n        memset(dp,0,sizeof(dp));\n        rep(i,n)\n        {\n            int start = a[i].fi.fi;\n            int end = a[i].fi.se;\n            int w = a[i].se;\n\n            for(int x=366; x>0; --x)for(int y=x; y>0; --y)\n            {\n                if(start<y) continue;\n\n                int min_v = min(end+1,x), max_v = max(end+1,x);\n                dp[min_v][max_v] = max(dp[min_v][max_v], dp[y][x]+w);\n            }\n        }\n\n        int ans=0;\n        rep(i,400)rep(j,400) ans=max(ans,dp[i][j]);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1246: Concert Hall Scheduling\n// 2017.11.8 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX(a,b) ((a)>=(b)?(a):(b))\ntypedef struct { int i, j, w; } T;\nT tbl[1002];\nint dp[366][366];\n\nint cmp(T *a, T *b) { return a->i - b->i; }\n\nint main()\n{\n\tint n, i, j, k, ans;\n\tint min, max;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmin = 365, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", &j, &k, &tbl[i].w);\n\t\t\tif (j < min) min = j;\n\t\t\tif (k > max) max = k;\n\t\t\ttbl[i].i = j, tbl[i].j = k;\n\t\t}\n\t\tqsort(tbl, n, sizeof(T), cmp);\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[0][min] = 0;\n\t\tfor (i = 0; i < n; i++) for (k = max; k >= 0; k--) {\n\t        for (j = tbl[i].i - 1; j >= 0; j--) {\n\t\t\t\tif (dp[k][j] >= 0) dp[k][tbl[i].j] = MAX(dp[k][tbl[i].j], dp[k][j]+tbl[i].w);\n\t\t\t    if (dp[j][k] >= 0) dp[tbl[i].j][k] = MAX(dp[tbl[i].j][k], dp[j][k]+tbl[i].w);\n\t\t\t}\n\t\t}\n    \n\t\tans = 0;\n\t\tfor (i = min; i <= max; i++) for(j = min; j <= max; j++)\n\t\t\tif (dp[i][j] > ans) ans = dp[i][j];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1246: Concert Hall Scheduling\n// 2017.11.8 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX(a,b) ((a)>=(b)?(a):(b))\ntypedef struct { int i, j, w; } T;\nT tbl[1002];\nint dp[366][366];\n\nint cmp(T *a, T *b) { return a->i - b->i; }\n\nint main()\n{\n\tint n, i, j, k, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d%d\", &tbl[i].i, &tbl[i].j, &tbl[i].w);\n\t\tqsort(tbl, n, sizeof(T), cmp);\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[0][0] = 0;\n\t\tfor (i = 0; i < n; i++) for (k = 365; k >= 0; k--) {\n\t        for (j = tbl[i].i - 1; j >= 0; j--) {\n\t\t\t\tif (dp[k][j] >= 0) dp[k][tbl[i].j] = MAX(dp[k][tbl[i].j], dp[k][j]+tbl[i].w);\n\t\t\t    if (dp[j][k] >= 0) dp[tbl[i].j][k] = MAX(dp[tbl[i].j][k], dp[j][k]+tbl[i].w);\n\t\t\t}\n\t\t}\n    \n\t\tans = 0;\n\t\tfor (i = 0; i <= 365; i++) for(j = 0; j <= 365; j++)\n\t\t\tif (dp[i][j] > ans) ans = dp[i][j];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1246: Concert Hall Scheduling\n// 2017.11.8 bal4u@uu\n// 2018.4.21\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define INF 0x10101010\n#define MAX 400\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE *edge[MAX]; int hi[MAX], lim[MAX];\nint  V;             // 頂点数\nint  dist[MAX], prevv[MAX], preve[MAX];\n\nvoid check_lim(int a)\n{\n\tif (hi[a] < lim[a]) return;\n\tif (lim[a] == 0) {\n\t\tlim[a] = 16, hi[a] = 0;\n\t\tedge[a] = malloc(sizeof(EDGE) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tint k = lim[a];\n\t\tif (k > 512) k = 512;\n\t\tlim[a] += k;\n\t\tedge[a] = realloc(edge[a], sizeof(EDGE) *lim[a]);\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *e;\n\n\tcheck_lim(from), check_lim(to);\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = cap, e->cost = cost, e->rev = t; \n\te = &edge[to][t], e->to = from, e->cap = 0, e->cost = -cost, e->rev = f;\n}\n\nint minCostFlow(int S, int T, int F)\n{\n\tint i, v, nv, t, nt, update, ret;\n\tEDGE *e;\n\n\tret = 0;\n  \n\twhile (F > 0) {\n\t\tmemset(dist, INF, V << 2);\n\t\tdist[S] = 0;\n\t\tdo {\n\t\t\tupdate = 0;\n\t\t\tfor (v = 0; v < V; v++) {\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\te = &edge[v][i];\n\t\t\t\t\tif (e->cap <= 0) continue;\n\t\t\t\t\tnv = e->to;\n\t\t\t\t\tnt = dist[v] + e->cost;\n\t\t\t\t\tif (dist[nv] > nt) {\n\t\t\t\t\t\tdist[nv] = nt, prevv[nv] = v, preve[e->to] = i;\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (update);\n\n\t\tif (dist[T] == INF) return -1;\n\n\t\tt = F;\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\te = &edge[prevv[v]][preve[v]];\n\t\t\tif (t > e->cap) t = e->cap;\n\t\t}\n\t\tF -= t;\n\n\t\tret += t * dist[T];\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\te = &edge[prevv[v]][preve[v]];\n\t\t\te->cap -= t;\n\t\t\tedge[v][e->rev].cap += t;\n\t\t}\n\t}\n\treturn ret;\n}\n \n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, j, k, w;\n\tint source, sink;\n\n\twhile (n = in()) {\n\t\tsource = 0, sink = 365;\n\t\tV = sink+1;\n\t\tmemset(hi, 0, V<<2), memset(lim, 0, V<<2);\n\t\tfor (k = 0; k < n; k++) {\n\t\t\ti = in(), j = in(), w = in();\n\t\t\tadd_edge(i-1, j, 1, -w);\n\t\t}\n\t\tfor (i = 0; i < 365; i++) add_edge(i, i+1, 2, 0);\n\t\tprintf(\"%d\\n\", -minCostFlow(source, sink, 2));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1240 start\n\t//1300 cording end\n\t//1303 sample matched MLE\n\t//1309 modified change  boolean []  to StringBuilder MLE\n\t//1316 modi close\n\tint INF = 1 << 24;\n\t\n\tclass C implements Comparable<C>{\n\t\tint now1, now2, cost;\n\t\tStringBuilder used;\n\n\t\tpublic C(int now1, int now2, int cost, StringBuilder used) {\n\t\t\tthis.now1 = now1;\n\t\t\tthis.now2 = now2;\n\t\t\tthis.cost = cost;\n\t\t\tthis.used = used;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(this.cost < o.cost) return -1;\n\t\t\tif(this.cost > o.cost) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] start = new int[n];\n\t\t\tint [] end = new int[n];\n\t\t\tint [] cost = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstart[i] = sc.nextInt();\n\t\t\t\tend[i] = sc.nextInt();\n\t\t\t\tcost[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.C>();\n\t\t\tStringBuilder startused = new StringBuilder();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstartused.append(\"0\");\n\t\t\t}\n\t\t\t\n\t\t\topen.add(new C(0, 0, 0,startused));\n\t\t\tint [][] close = new int[366][366];\n\t\t\tint ans = -1;\n\t\t\tint len = 366;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tans = Math.max(ans, now.cost);\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(now.used.charAt(i) == '1') continue;\n\t\t\t\t\t\n\t\t\t\t\tif(now.now1 < start[i]){\n\t\t\t\t\t\tint nextnow = end[i];\n\t\t\t\t\t\tint nextcost = now.cost + cost[i];\n\t\t\t\t\t\tif(close[nextnow][now.now2] >= nextcost){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tStringBuilder next = new StringBuilder(now.used.toString());\n\t\t\t\t\t\tnext.setCharAt(i, '1');\n\t\t\t\t\t\topen.add(new C(nextnow, now.now2, nextcost, next));\n\t\t\t\t\t\t//close[nextnow][now.now2] = nextcost;\n\t\t\t\t\t\tfor(int j = nextnow ; j < len; j++){\n\t\t\t\t\t\t\tfor(int k = 0 ; k < len; k++){\n\t\t\t\t\t\t\t\tclose[j][k] = Math.max(close[j][k], nextcost);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(now.now2 < start[i]){\n\t\t\t\t\t\tint nextnow = end[i];\n\t\t\t\t\t\tint nextcost = now.cost + cost[i];\n\t\t\t\t\t\tif(close[now.now1][nextnow] >= nextcost){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tStringBuilder next = new StringBuilder(now.used.toString());\n\t\t\t\t\t\tnext.setCharAt(i, '1');\n\t\t\t\t\t\topen.add(new C(now.now1, nextnow, nextcost, next));\n\t\t\t\t\t\t//close[now.now1][nextnow] = nextcost;\n\t\t\t\t\t\tfor(int j = 0 ; j < len; j++){\n\t\t\t\t\t\t\tfor(int k = nextcost ; k < len; k++){\n\t\t\t\t\t\t\t\tclose[j][k] = Math.max(close[j][k], nextcost);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass App implements Comparable<App> {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\n\t\tApp(int from, int to, int w) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tpublic int compareTo(App s) {\n\t\t\tif (from != s.from) return from - s.from;\n\t\t\tif (to != s.to) return to - s.to;\n\t\t\treturn w - s.w;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + from + \" \" + to + \" \" + w;\n\t\t}\n\t}\n\t\n\tint MAX = 400;\n\tint[][][] dp = new int[2][MAX][MAX];\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\n\t\t\tApp[] app = new App[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tapp[i] = new App(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(app);\n\t\t\t\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\tArrays.fill(dp[i][j], 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint to = app[i].to;\n\t\t\t\tint cur = i % 2, next = (i + 1) % 2;\n\t\t\t\tfor (int f2 = 0; f2 < MAX; f2++) {\n\t\t\t\t\tfor (int f1 = 0; f1 < MAX; f1++) {\n\t\t\t\t\t\tif (f1 <= app[i].from) {\n\t\t\t\t\t\t\tdp[next][to+1][f2] = Math.max(dp[next][to+1][f2], dp[cur][f1][f2] + app[i].w);\n\t\t\t\t\t\t\tdp[next][f2][to+1] = Math.max(dp[next][f2][to+1], dp[cur][f2][f1] + app[i].w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[next][f1][f2] = Math.max(dp[next][f1][f2], dp[cur][f1][f2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\tres = Math.max(res, dp[n%2][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t\t\n\t\t\t/*\n\t\t\tArrays.fill(dp, 0);\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrays.fill(id, -1);\n\t\t\tArrays.fill(used, false);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int f = 0; f <= app[i].from; f++) {\n\t\t\t\t\tfor (int t = app[i].to + 1; t <= 365; t++) {\n\t\t\t\t\t\tif (dp[t] < dp[f] + app[i].w) {\n\t\t\t\t\t\t\tdp[t] = dp[f] + app[i].w;\n\t\t\t\t\t\t\tprev[t] = f;\n\t\t\t\t\t\t\tid[t] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint idx = -1, max = 0;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tif (max < dp[i]) {\n\t\t\t\t\tmax = dp[i];\n\t\t\t\t\tidx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = dp[idx];\n\t\t\twhile (id[idx] != -1) {\n\t\t\t\tused[id[idx]] = true;\n\t\t\t\tidx = prev[idx];\n\t\t\t}\n\n\t\t\tArrays.fill(dp, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (used[i]) continue;\n\t\t\t\tfor (int f = 0; f <= app[i].from; f++) {\n\t\t\t\t\tfor (int t = app[i].to + 1; t <= 365; t++) {\n\t\t\t\t\t\tdp[t] = Math.max(dp[f] + app[i].w, dp[t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t}\n\t\t\tres += max;\n\t\t\tSystem.out.println(res);\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Concert Hall Scheduling\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t, e;\n\t\tpublic R(int s, int t, int e) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.e = e;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.s-s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i] = new R(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tArrays.sort(r);\n\t\t\tint[][] dp = new int[367][367];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint[][] next = new int[367][367];\n\t\t\t\tfor(int j=365;j>0;j--)for(int k=365;k>0;k--){\n\t\t\t\t\tint max = dp[j][k];\n\t\t\t\t\tif(j<=r[i].s)max = Math.max(max, r[i].e+dp[r[i].t+1][k]);\n\t\t\t\t\tif(k<=r[i].s)max = Math.max(max, r[i].e+dp[j][r[i].t+1]);\n\t\t\t\t\tnext[j][k] = max;\n\t\t\t\t}\n\t\t\t\tdp = next;\n\t\t\t}\n//\t\t\tfor(int j=M;j>0;j--)for(int k=M;k>0;k--){\n//\t\t\t\tint max = Math.max(dp[j][k+1], dp[j+1][k]);\n//\t\t\t\tfor(R v:r[j]){\n//\t\t\t\t\tmax = Math.max(max, dp[v.t+1][k]+v.e);\n//\t\t\t\t}\n//\t\t\t\tfor(R v:r[k]){\n//\t\t\t\t\tmax = Math.max(max, dp[j][v.t+1]+v.e);\n//\t\t\t\t}\n//\t\t\t\tdp[j][k] = max;\n//\t\t\t}\n\t\t\tSystem.out.println(dp[1][1]);\n//\t\t\tfor(;;){\n//\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n//\t\t\t\tif((a|b)==0)break;\n//\t\t\t\tSystem.out.println(\"dp[\"+a+\"][\"+b+\"] DP:\" + dp[a][b]);\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass App implements Comparable<App> {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\n\t\tApp(int from, int to, int w) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tpublic int compareTo(App s) {\n\t\t\tif (from != s.from) return from - s.from;\n\t\t\tif (to != s.to) return to - s.to;\n\t\t\treturn w - s.w;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + from + \" \" + to + \" \" + w;\n\t\t}\n\t}\n\t\n\tint[] dp = new int[400];\n\tint[] prev = new int[400];\n\tint[] id = new int[400];\n\tboolean[] used = new boolean[2000];\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\n\t\t\tApp[] app = new App[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tapp[i] = new App(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(app);\n\t\t\t\n\t\t\tArrays.fill(dp, 0);\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrays.fill(id, -1);\n\t\t\tArrays.fill(used, false);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int f = 0; f <= app[i].from; f++) {\n\t\t\t\t\tfor (int t = app[i].to + 1; t < 365; t++) {\n\t\t\t\t\t\tif (dp[t] < dp[f] + app[i].w) {\n\t\t\t\t\t\t\tdp[t] = dp[f] + app[i].w;\n\t\t\t\t\t\t\tprev[t] = f;\n\t\t\t\t\t\t\tid[t] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint idx = -1, max = 0;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tif (max < dp[i]) {\n\t\t\t\t\tmax = dp[i];\n\t\t\t\t\tidx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = dp[idx];\n\t\t\twhile (id[idx] != -1) {\n\t\t\t\tused[id[idx]] = true;\n\t\t\t\tidx = prev[idx];\n\t\t\t}\n\n\t\t\tArrays.fill(dp, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (used[i]) continue;\n\t\t\t\tfor (int f = 0; f <= app[i].from; f++) {\n\t\t\t\t\tfor (int t = app[i].to + 1; t < 365; t++) {\n\t\t\t\t\t\tdp[t] = Math.max(dp[f] + app[i].w, dp[t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t}\n\t\t\tres += max;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Concert Hall Scheduling\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t, c;\n\t\tpublic R(int s, int t, int c) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t-o.t;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][][] dp = new int[2][366][366];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i]=new R(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tArrays.sort(r);\n\t\t\tint x = 0;\n\t\t\tfor(int i=0;i<2;i++)for(int j=0;j<366;j++)for(int k=0;k<366;k++)dp[i][j][k]=0;\n\t\t\tfor(int i=0;i<n;i++,x=1-x)for(int j=1;j<366;j++)for(int k=1;k<366;k++){\n\t\t\t\tint max = Math.max(dp[1-x][j][k], Math.max(dp[x][j-1][k], dp[x][j][k-1]));\n\t\t\t\tif(r[i].t==j)max = Math.max(max, dp[1-x][r[i].s-1][k]+r[i].c);\n\t\t\t\tif(r[i].t==k)max = Math.max(max, dp[1-x][j][r[i].s-1]+r[i].c);\n\t\t\t\tdp[x][j][k] = max;\n\t\t\t}\n\t\t\tSystem.out.println(dp[1-x][365][365]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1240 start\n\t//1300 cording end\n\t//1303 sample matched MLE\n\t//1309 modified change  boolean []  to StringBuilder\n\tint INF = 1 << 24;\n\t\n\tclass C implements Comparable<C>{\n\t\tint now1, now2, cost;\n\t\tStringBuilder used;\n\n\t\tpublic C(int now1, int now2, int cost, StringBuilder used) {\n\t\t\tthis.now1 = now1;\n\t\t\tthis.now2 = now2;\n\t\t\tthis.cost = cost;\n\t\t\tthis.used = used;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(this.cost < o.cost) return -1;\n\t\t\tif(this.cost > o.cost) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] start = new int[n];\n\t\t\tint [] end = new int[n];\n\t\t\tint [] cost = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstart[i] = sc.nextInt();\n\t\t\t\tend[i] = sc.nextInt();\n\t\t\t\tcost[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.C>();\n\t\t\tStringBuilder startused = new StringBuilder();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstartused.append(\"0\");\n\t\t\t}\n\t\t\t\n\t\t\topen.add(new C(0, 0, 0,startused));\n\t\t\tint [][] close = new int[366][366];\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tans = Math.max(ans, now.cost);\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(now.used.charAt(i) == '1') continue;\n\t\t\t\t\t\n\t\t\t\t\tif(now.now1 < start[i]){\n\t\t\t\t\t\tint nextnow = end[i];\n\t\t\t\t\t\tint nextcost = now.cost + cost[i];\n\t\t\t\t\t\tif(close[nextnow][now.now2] >= nextcost){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tStringBuilder next = new StringBuilder(now.used.toString());\n\t\t\t\t\t\tnext.setCharAt(i, '1');\n\t\t\t\t\t\topen.add(new C(nextnow, now.now2, nextcost, next));\n\t\t\t\t\t\tclose[nextnow][now.now2] = nextcost;\n\t\t\t\t\t}\n\t\t\t\t\telse if(now.now2 < start[i]){\n\t\t\t\t\t\tint nextnow = end[i];\n\t\t\t\t\t\tint nextcost = now.cost + cost[i];\n\t\t\t\t\t\tif(close[now.now1][nextnow] >= nextcost){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tStringBuilder next = new StringBuilder(now.used.toString());\n\t\t\t\t\t\tnext.setCharAt(i, '1');\n\t\t\t\t\t\topen.add(new C(now.now1, nextnow, nextcost, next));\n\t\t\t\t\t\tclose[now.now1][nextnow] = nextcost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tint INF = 1 << 24;\n\tclass MCF{\n\t\tArrayList<ArrayList<Edge>> G;\n\t\t\n\t\tclass Edge {\n\t\t\tint to, cap, cost;\n\t\t\tint rev;\n\n\t\t\tpublic Edge(int to, int cap, int cost, int rev) {\n\t\t\t\tthis.to = to;this.cap = cap;this.cost = cost; this.rev = rev;\n\t\t\t}\n\t\t}\n\t\tMCF(int v){\n\t\t\tG = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i = 0; i < v; i++){\n\t\t\t\tG.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate void addEdge(int from, int to, int cap, int cost){\n\t\t\tG.get(from).add(new Edge(to, cap, cost, G.get(to).size()));\n\t\t\tG.get(to).add(new Edge(from, 0, -cost, G.get(from).size() - 1));\n\t\t}\n\n\t\tprivate int minCostFlow(int s, int t, int f) {\n\t\t\tint V = G.size();\n\t\t\tint [] dist = new int[V], prevv = new int[V], preve = new int[V];\n\t\t\tint res = 0;\n\t\t\twhile(f > 0){\n\t\t\t\tArrays.fill(dist, INF);\n\t\t\t\tdist[s] = 0;\n\t\t\t\tboolean update = true;\n\t\t\t\twhile(update) {\n\t\t\t\t\tupdate = false;\n\t\t\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\t\t\tif(dist[v] == INF) continue;\n\t\t\t\t\t\tfor(int i = 0 ; i < G.get(v).size(); i++){\n\t\t\t\t\t\t\tEdge  e = G.get(v).get(i);\n\t\t\t\t\t\t\tif(e.cap > 0 && dist[e.to]> dist[v] + e.cost ){\n\t\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\t\tpreve[e.to] = i; \n\t\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dist[t] == INF) return -1;\n\t\t\t\t\n\t\t\t\tint d = f;\n\t\t\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\t\t\td = Math.min(d, G.get(prevv[v]).get(preve[v]).cap);\n\t\t\t\t}\n\t\t\t\tf -= d;\n\t\t\t\tres += d * dist[t];\n\t\t\t\tfor(int v = t; v!= s; v = prevv[v]){\n\t\t\t\t\tEdge e =G.get(prevv[v]).get(preve[v]);\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG.get(v).get(e.rev).cap += d;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] start = new int[n];\n\t\t\tint [] end = new int[n];\n\t\t\tint [] cost = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstart[i] = sc.nextInt() - 1;\n\t\t\t\tend[i] = sc.nextInt();\n\t\t\t\tcost[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint v = 366;\n\t\t\tMCF mcf = new MCF(v);\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tmcf.addEdge(start[i], end[i], 1, -cost[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < v-1; i++){\n\t\t\t\tmcf.addEdge(i, i + 1, 2, 0);\n\t\t\t}\n\t\t\t\n\t\t\tint res = mcf.minCostFlow(0,v-1, 2);\n\t\t\tSystem.out.println(-res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1240 start\n\t//1300 cording end\n\t//1303 sample matched\n\tint INF = 1 << 24;\n\t\n\tclass C implements Comparable<C>{\n\t\tint now1, now2, cost;\n\t\tboolean [] used;\n\n\t\tpublic C(int now1, int now2, int cost, boolean [] used) {\n\t\t\tthis.now1 = now1;\n\t\t\tthis.now2 = now2;\n\t\t\tthis.cost = cost;\n\t\t\tthis.used = used;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(this.cost < o.cost) return -1;\n\t\t\tif(this.cost > o.cost) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] start = new int[n];\n\t\t\tint [] end = new int[n];\n\t\t\tint [] cost = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstart[i] = sc.nextInt();\n\t\t\t\tend[i] = sc.nextInt();\n\t\t\t\tcost[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.C>();\n\t\t\topen.add(new C(0, 0, 0, new boolean[n]));\n\t\t\tint [][] close = new int[366][366];\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tans = Math.max(ans, now.cost);\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(now.used[i]) continue;\n\t\t\t\t\t\n\t\t\t\t\tif(now.now1 < start[i]){\n\t\t\t\t\t\tint nextnow = end[i];\n\t\t\t\t\t\tint nextcost = now.cost + cost[i];\n\t\t\t\t\t\tif(close[nextnow][now.now2] >= nextcost){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboolean [] next = Arrays.copyOf(now.used, n);\n\t\t\t\t\t\tnext[i] = true;\n\t\t\t\t\t\topen.add(new C(nextnow, now.now2, nextcost, next));\n\t\t\t\t\t\tclose[nextnow][now.now2] = nextcost;\n\t\t\t\t\t}\n\t\t\t\t\telse if(now.now2 < start[i]){\n\t\t\t\t\t\tint nextnow = end[i];\n\t\t\t\t\t\tint nextcost = now.cost + cost[i];\n\t\t\t\t\t\tif(close[now.now1][nextnow] >= nextcost){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboolean [] next = Arrays.copyOf(now.used, n);\n\t\t\t\t\t\tnext[i] = true;\n\t\t\t\t\t\topen.add(new C(now.now1, nextnow, nextcost, next));\n\t\t\t\t\t\tclose[now.now1][nextnow] = nextcost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Concert Hall Scheduling\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t, e;\n\t\tpublic R(int s, int t, int e) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.e = e;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.s!=s?o.s-s:o.t-t;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i] = new R(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tArrays.sort(r);\n\t\t\tint[][] dp = new int[367][367];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint[][] next = new int[367][367];\n\t\t\t\tfor(int j=365;j>0;j--)for(int k=365;k>0;k--){\n\t\t\t\t\tint max = Math.max(dp[j][k], Math.max(next[j][k+1], next[j+1][k]));\n\t\t\t\t\tif(j==r[i].s)max = Math.max(max, r[i].e+dp[r[i].t+1][k]);\n\t\t\t\t\tif(k==r[i].s)max = Math.max(max, r[i].e+dp[j][r[i].t+1]);\n\t\t\t\t\tnext[j][k] = max;\n\t\t\t\t}\n\t\t\t\tdp = next;\n\t\t\t}\n\t\t\tSystem.out.println(dp[1][1]);\n//\t\t\tfor(;;){\n//\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n//\t\t\t\tif((a|b)==0)break;\n//\t\t\t\tSystem.out.println(\"dp[\"+a+\"][\"+b+\"] DP:\" + dp[a][b]);\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Concert Hall Scheduling\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t, e;\n\t\tpublic R(int s, int t, int e) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.e = e;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.t!=t?o.t-t:o.s-s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i] = new R(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tArrays.sort(r);\n\t\t\tint[][] dp = new int[367][367];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint[][] next = new int[367][367];\n\t\t\t\tfor(int j=365;j>0;j--)for(int k=365;k>0;k--){\n\t\t\t\t\tint max = Math.max(dp[j][k], Math.max(next[j][k+1], next[j+1][k]));\n\t\t\t\t\tif(j<=r[i].s)max = Math.max(max, r[i].e+dp[r[i].t+1][k]);\n\t\t\t\t\tif(k<=r[i].s)max = Math.max(max, r[i].e+dp[j][r[i].t+1]);\n\t\t\t\t\tnext[j][k] = max;\n\t\t\t\t}\n\t\t\t\tdp = next;\n\t\t\t}\n\t\t\tSystem.out.println(dp[1][1]);\n//\t\t\tfor(;;){\n//\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n//\t\t\t\tif((a|b)==0)break;\n//\t\t\t\tSystem.out.println(\"dp[\"+a+\"][\"+b+\"] DP:\" + dp[a][b]);\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass App implements Comparable<App> {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\n\t\tApp(int from, int to, int w) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tpublic int compareTo(App s) {\n\t\t\tif (from != s.from) return from - s.from;\n\t\t\tif (to != s.to) return to - s.to;\n\t\t\treturn w - s.w;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + from + \" \" + to + \" \" + w;\n\t\t}\n\t}\n\t\n\tint[] dp = new int[400];\n\tint[] prev = new int[400];\n\tint[] id = new int[400];\n\tboolean[] used = new boolean[400];\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\n\t\t\tApp[] app = new App[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tapp[i] = new App(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(app);\n\t\t\t\n\t\t\tArrays.fill(dp, 0);\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrays.fill(id, -1);\n\t\t\tArrays.fill(used, false);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int f = 0; f <= app[i].from; f++) {\n\t\t\t\t\tfor (int t = app[i].to + 1; t < 365; t++) {\n\t\t\t\t\t\tif (dp[t] < dp[f] + app[i].w) {\n\t\t\t\t\t\t\tdp[t] = dp[f] + app[i].w;\n\t\t\t\t\t\t\tprev[t] = f;\n\t\t\t\t\t\t\tid[t] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint idx = -1, max = 0;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tif (max < dp[i]) {\n\t\t\t\t\tmax = dp[i];\n\t\t\t\t\tidx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = dp[idx];\n\t\t\twhile (id[idx] != -1) {\n\t\t\t\tused[id[idx]] = true;\n\t\t\t\tidx = prev[idx];\n\t\t\t}\n\n\t\t\tArrays.fill(dp, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (used[i]) continue;\n\t\t\t\tfor (int f = 0; f <= app[i].from; f++) {\n\t\t\t\t\tfor (int t = app[i].to + 1; t < 365; t++) {\n\t\t\t\t\t\tdp[t] = Math.max(dp[f] + app[i].w, dp[t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t}\n\t\t\tres += max;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1730 start\n\tint INF = 1 << 24;\n\tArrayList<ArrayList<Edge>> G;\n\t\n\tclass Edge {\n\t\tint to, cap, cost;\n\t\tint rev;\n\n\t\tpublic Edge(int to, int cap, int cost, int rev) {\n\t\t\tthis.to = to;this.cap = cap;this.cost = cost; this.rev = rev;\n\t\t}\n\t}\n\t\n\tclass S implements Comparable<S>{\n\t\tint start, end, cost;\n\n\t\tpublic S(int start, int end, int cost) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(S o) {\n\t\t\tif(this.end < o.end) return -1;\n\t\t\tif(this.end > o.end) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tS [] data = new S[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = new S(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tint [] start = new int[n];\n\t\t\tint [] end = new int[n];\n\t\t\tint [] cost = new int[n];\n\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\tset.add(0);\n\t\t\tset.add(365);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstart[i] = data[i].start - 1;\n\t\t\t\tend[i] = data[i].end;\n\t\t\t\tset.add(start[i]); set.add(end[i]);\n\t\t\t\tcost[i] = data[i].cost;\n\t\t\t}\n\t\t\t\n\t\t\t//G[][]をつくる\n\t\t\tG = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i = 0 ; i <= 365; i++){\n\t\t\t\tG.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\t\n\t\t\t//マイナスのコストがある辺を加える\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\taddEdge(start[i], end[i], 1, -cost[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 365; i++){\n\t\t\t\taddEdge(i, i + 1, 2, 0);\n\t\t\t}\n\t\t\t\n\t\t\tint res = minCostFlow(0,365, 2);\n\t\t\tSystem.out.println(-res);\n\t\t}\n\t}\n\t\n\t//SHAKYO\n\tprivate void addEdge(int from, int to, int cap, int cost){\n\t\tG.get(from).add(new Edge(to, cap, cost, G.get(to).size()));\n\t\tG.get(to).add(new Edge(from, 0, -cost, G.get(from).size()));\n\t}\n\n\t//SHAKYO\n\tprivate int minCostFlow(int s, int t, int f) {\n\t\tint V = G.size();\n\t\tint [] dist = new int[V];\n\t\tint [] prevv = new int[V];\n\t\tint [] preve = new int[V];\n\t\t\n\t\tint res = 0;\n\t\twhile(f > 0){\n\t\t\t//ベルマン\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[s] = 0;\n\t\t\tboolean update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\t\tif(dist[v] == INF) continue;\n\t\t\t\t\tfor(int i = 0 ; i < G.get(v).size(); i++){\n\t\t\t\t\t\tEdge  e = G.get(v).get(i);\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to]> dist[v] + e.cost ){\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i; \n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dist[t] == INF){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\t\td = Math.min(d, G.get(prevv[v]).get(preve[v]).cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor(int v = t; v!= s; v = prevv[v]){\n\t\t\t\tEdge e =G.get(prevv[v]).get(preve[v]);\n\t\t\t\te.cap -= d;\n\t\t\t\tG.get(v).get(e.rev).cap += d;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1730 start\n\tint INF = 1 << 24;\n\tArrayList<ArrayList<Edge>> G;\n\t\n\tclass Edge {\n\t\tint to, cap, cost;\n\t\tint rev;\n\n\t\tpublic Edge(int to, int cap, int cost, int rev) {\n\t\t\tthis.to = to;this.cap = cap;this.cost = cost; this.rev = rev;\n\t\t}\n\t}\n\t\n\tclass S implements Comparable<S>{\n\t\tint start, end, cost;\n\n\t\tpublic S(int start, int end, int cost) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(S o) {\n\t\t\tif(this.end < o.end) return -1;\n\t\t\tif(this.end > o.end) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tS [] data = new S[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = new S(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tint [] start = new int[n];\n\t\t\tint [] end = new int[n];\n\t\t\tint [] cost = new int[n];\n\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\tset.add(0);\n\t\t\tset.add(366);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstart[i] = data[i].start - 1;\n\t\t\t\tend[i] = data[i].end;\n\t\t\t\tset.add(start[i]); set.add(end[i]);\n\t\t\t\tcost[i] = data[i].cost;\n\t\t\t}\n\t\t\t\n\t\t\t//G[][]をつくる\n\t\t\tG = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i = 0 ; i <= 366; i++){\n\t\t\t\tG.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\t\n\t\t\t//マイナスのコストがある辺を加える\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\taddEdge(start[i], end[i], 1, -cost[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 366; i++){\n\t\t\t\taddEdge(i, i + 1, 2, 0);\n\t\t\t}\n\t\t\t\n\t\t\tint res = minCostFlow(0,366, 2);\n\t\t\tSystem.out.println(-res);\n\t\t}\n\t}\n\t\n\t//SHAKYO\n\tprivate void addEdge(int from, int to, int cap, int cost){\n\t\tG.get(from).add(new Edge(to, cap, cost, G.get(to).size()));\n\t\tG.get(to).add(new Edge(from, 0, -cost, G.get(from).size() - 1));\n\t}\n\n\t//SHAKYO\n\tprivate int minCostFlow(int s, int t, int f) {\n\t\tint V = G.size();\n\t\tint [] dist = new int[V];\n\t\tint [] prevv = new int[V];\n\t\tint [] preve = new int[V];\n\t\t\n\t\tint res = 0;\n\t\twhile(f > 0){\n\t\t\t//ベルマン\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[s] = 0;\n\t\t\tboolean update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\t\tif(dist[v] == INF) continue;\n\t\t\t\t\tfor(int i = 0 ; i < G.get(v).size(); i++){\n\t\t\t\t\t\tEdge  e = G.get(v).get(i);\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to]> dist[v] + e.cost ){\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i; \n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dist[t] == INF){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\t\td = Math.min(d, G.get(prevv[v]).get(preve[v]).cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor(int v = t; v!= s; v = prevv[v]){\n\t\t\t\tEdge e =G.get(prevv[v]).get(preve[v]);\n\t\t\t\te.cap -= d;\n\t\t\t\tG.get(v).get(e.rev).cap += d;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1730 start\n\tint INF = 1 << 24;\n\tArrayList<ArrayList<Edge>> G;\n\t\n\tclass Edge {\n\t\tint to, cap, cost;\n\t\tint rev;\n\n\t\tpublic Edge(int to, int cap, int cost, int rev) {\n\t\t\tthis.to = to;this.cap = cap;this.cost = cost; this.rev = rev;\n\t\t}\n\t}\n\t\n\tclass S implements Comparable<S>{\n\t\tint start, end, cost;\n\n\t\tpublic S(int start, int end, int cost) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(S o) {\n\t\t\tif(this.end < o.end) return -1;\n\t\t\tif(this.end > o.end) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tS [] data = new S[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = new S(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tint [] start = new int[n];\n\t\t\tint [] end = new int[n];\n\t\t\tint [] cost = new int[n];\n\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\tset.add(0);\n\t\t\tset.add(366);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstart[i] = data[i].start - 1;\n\t\t\t\tend[i] = data[i].end;\n\t\t\t\tset.add(start[i]); set.add(end[i]);\n\t\t\t\tcost[i] = data[i].cost;\n\t\t\t}\n\t\t\t\n\t\t\t//G[][]をつくる\n\t\t\tG = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i = 0 ; i <= 366; i++){\n\t\t\t\tG.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\t\n\t\t\t//マイナスのコストがある辺を加える\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\taddEdge(start[i], end[i], 1, -cost[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 366; i++){\n\t\t\t\taddEdge(i, i + 1, 2, 0);\n\t\t\t}\n\t\t\t\n\t\t\tint res = minCostFlow(0,366, 2);\n\t\t\tSystem.out.println(-res);\n\t\t}\n\t}\n\t\n\t//SHAKYO\n\tprivate void addEdge(int from, int to, int cap, int cost){\n\t\tG.get(from).add(new Edge(to, cap, cost, G.get(to).size()));\n\t\tG.get(to).add(new Edge(from, 0, -cost, G.get(from).size()));\n\t}\n\n\t//SHAKYO\n\tprivate int minCostFlow(int s, int t, int f) {\n\t\tint V = G.size();\n\t\tint [] dist = new int[V];\n\t\tint [] prevv = new int[V];\n\t\tint [] preve = new int[V];\n\t\t\n\t\tint res = 0;\n\t\twhile(f > 0){\n\t\t\t//ベルマン\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[s] = 0;\n\t\t\tboolean update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\t\tif(dist[v] == INF) continue;\n\t\t\t\t\tfor(int i = 0 ; i < G.get(v).size(); i++){\n\t\t\t\t\t\tEdge  e = G.get(v).get(i);\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to]> dist[v] + e.cost ){\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i; \n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dist[t] == INF){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\t\td = Math.min(d, G.get(prevv[v]).get(preve[v]).cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor(int v = t; v!= s; v = prevv[v]){\n\t\t\t\tEdge e =G.get(prevv[v]).get(preve[v]);\n\t\t\t\te.cap -= d;\n\t\t\t\tG.get(v).get(e.rev).cap += d;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass App implements Comparable<App> {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\n\t\tApp(int from, int to, int w) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tpublic int compareTo(App s) {\n\t\t\tif (from != s.from) return from - s.from;\n\t\t\tif (to != s.to) return to - s.to;\n\t\t\treturn w - s.w;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + from + \" \" + to + \" \" + w;\n\t\t}\n\t}\n\t\n\tint[] dp = new int[400];\n\tint[] prev = new int[400];\n\tint[] id = new int[400];\n\tboolean[] used = new boolean[2000];\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\n\t\t\tApp[] app = new App[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tapp[i] = new App(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(app);\n\t\t\t\n\t\t\tArrays.fill(dp, 0);\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrays.fill(id, -1);\n\t\t\tArrays.fill(used, false);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int f = 0; f <= app[i].from; f++) {\n\t\t\t\t\tfor (int t = app[i].to + 1; t <= 365; t++) {\n\t\t\t\t\t\tif (dp[t] < dp[f] + app[i].w) {\n\t\t\t\t\t\t\tdp[t] = dp[f] + app[i].w;\n\t\t\t\t\t\t\tprev[t] = f;\n\t\t\t\t\t\t\tid[t] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint idx = -1, max = 0;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tif (max < dp[i]) {\n\t\t\t\t\tmax = dp[i];\n\t\t\t\t\tidx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = dp[idx];\n\t\t\twhile (id[idx] != -1) {\n\t\t\t\tused[id[idx]] = true;\n\t\t\t\tidx = prev[idx];\n\t\t\t}\n\n\t\t\tArrays.fill(dp, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (used[i]) continue;\n\t\t\t\tfor (int f = 0; f <= app[i].from; f++) {\n\t\t\t\t\tfor (int t = app[i].to + 1; t <= 365; t++) {\n\t\t\t\t\t\tdp[t] = Math.max(dp[f] + app[i].w, dp[t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t}\n\t\t\tres += max;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\n\npublic class Main {\n\tint N;\n\tclass State{\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\t\tpublic State(int a, int b, int c){\n\t\t\tthis.c = c;\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + a;\n\t\t\tresult = prime * result + b;\n\t\t\tresult = prime * result + c;\n\t\t\treturn result;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif(this == obj) return true;\n\t\t\tif(obj == null) return false;\n\t\t\tif(getClass() != obj.getClass()) return false;\n\t\t\tState other = (State)obj;\n\t\t\tif(!getOuterType().equals(other.getOuterType())) return false;\n\t\t\tif(a != other.a) return false;\n\t\t\tif(b != other.b) return false;\n\t\t\tif(c != other.c) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tHashMap<State, Integer> dp = new HashMap<>();\n\tHashMap<Integer, ArrayList<State>> input = new HashMap<>();\n\tpublic int dfs(int idx, int n1, int n2){\n\t\tif(idx >= 366) return 0;\n\t\tif(n1 < idx) n1 = 0;\n\t\tif(n2 < idx) n2 = 0;\n\t\tState t = new State(idx, n1, n2);\n\t\tif(dp.containsKey(t)) return dp.get(t);\n\t\tint ans = dfs(idx + 1, n1, n2);\n\t\tArrayList<State> data = input.get(idx);\n\t\tif(data != null){\n\t\t\tif(n1 < idx && n2 < idx){\n\t\t\t\tfor(int i = 0; i < data.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < data.size(); j++){\n\t\t\t\t\t\tint n3 = data.get(i).b;\n\t\t\t\t\t\tint n4 = data.get(j).b;\n\t\t\t\t\t\tans = Math.max(ans, dfs(idx + 1, Math.max(n3, n4), Math.min(n3, n4)) + data.get(i).c + data.get(j).c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n2 < idx){\n\t\t\t\tfor(State p : data){\n\t\t\t\t\tint n3 = p.b;\n\t\t\t\t\tans = Math.max(ans, dfs(idx + 1, Math.max(n1, n3), Math.min(n1, n3)) + p.c);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"(%d %d %d) = %d\\n\", idx, n1, n2, ans);\n\n\t\tdp.put(t,  ans);\n\t\treturn ans;\n\t\t\n\t}\n\t\n\tpublic void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tN = sc.nextInt();\n\t\t\tif(N == 0) break;\n\t\t\tinput.clear();\n\t\t\tdp.clear();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tState s = new State(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t\tif(!input.containsKey(s.a)){\n\t\t\t\t\tinput.put(s.a, new ArrayList<>());\n\t\t\t\t}\n\t\t\t\tinput.get(s.a).add(s);\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(1, 0, 0));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1240 start\n\t//1300 cording end\n\t//1303 sample matched MLE\n\t//1309 modified change  boolean []  to StringBuilder MLE\n\t//1316 modi close MLE\n\t//1322 modi add sort process\n\tint INF = 1 << 24;\n\t\n\tclass C implements Comparable<C>{\n\t\tint now1, now2, cost;\n\t\tStringBuilder used;\n\n\t\tpublic C(int now1, int now2, int cost, StringBuilder used) {\n\t\t\tthis.now1 = now1;\n\t\t\tthis.now2 = now2;\n\t\t\tthis.cost = cost;\n\t\t\tthis.used = used;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(this.cost < o.cost) return -1;\n\t\t\tif(this.cost > o.cost) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t//S is initial of sort !!!\n\tclass S implements Comparable<S>{\n\t\tint start, end, cost;\n\n\t\tpublic S(int start, int end, int cost) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(S o) {\n\t\t\tif(this.end < o.end) return -1;\n\t\t\tif(this.end > o.end) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tS [] data = new S[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = new S(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tint [] start = new int[n];\n\t\t\tint [] end = new int[n];\n\t\t\tint [] cost = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstart[i] = data[i].start;\n\t\t\t\tend[i] = data[i].end;\n\t\t\t\tcost[i] = data[i].cost;\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.C>();\n\t\t\tStringBuilder startused = new StringBuilder();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstartused.append(\"0\");\n\t\t\t}\n\t\t\t\n\t\t\topen.add(new C(0, 0, 0,startused));\n\t\t\tint [][] close = new int[366][366];\n\t\t\tint ans = -1;\n\t\t\tint len = 366;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tans = Math.max(ans, now.cost);\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(now.used.charAt(i) == '1') continue;\n\t\t\t\t\t\n\t\t\t\t\tif(now.now1 < start[i]){\n\t\t\t\t\t\tint nextnow = end[i];\n\t\t\t\t\t\tint nextcost = now.cost + cost[i];\n\t\t\t\t\t\tif(close[nextnow][now.now2] >= nextcost){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tStringBuilder next = new StringBuilder(now.used.toString());\n\t\t\t\t\t\tnext.setCharAt(i, '1');\n\t\t\t\t\t\topen.add(new C(nextnow, now.now2, nextcost, next));\n\t\t\t\t\t\t//close[nextnow][now.now2] = nextcost;\n\t\t\t\t\t\tfor(int j = nextnow ; j < len; j++){\n\t\t\t\t\t\t\tfor(int k = 0 ; k < len; k++){\n\t\t\t\t\t\t\t\tclose[j][k] = Math.max(close[j][k], nextcost);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(now.now2 < start[i]){\n\t\t\t\t\t\tint nextnow = end[i];\n\t\t\t\t\t\tint nextcost = now.cost + cost[i];\n\t\t\t\t\t\tif(close[now.now1][nextnow] >= nextcost){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tStringBuilder next = new StringBuilder(now.used.toString());\n\t\t\t\t\t\tnext.setCharAt(i, '1');\n\t\t\t\t\t\topen.add(new C(now.now1, nextnow, nextcost, next));\n\t\t\t\t\t\t//close[now.now1][nextnow] = nextcost;\n\t\t\t\t\t\tfor(int j = 0 ; j < len; j++){\n\t\t\t\t\t\t\tfor(int k = nextcost ; k < len; k++){\n\t\t\t\t\t\t\t\tclose[j][k] = Math.max(close[j][k], nextcost);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Concert Hall Scheduling\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t, e;\n\t\tpublic R(int s, int t, int e) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.e = e;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.s!=s?o.s-s:o.t-t;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i] = new R(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tArrays.sort(r);\n\t\t\tint[][] dp = new int[367][367];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint[][] next = new int[367][367];\n\t\t\t\tfor(int j=365;j>0;j--)for(int k=365;k>0;k--){\n\t\t\t\t\tint max = dp[j][k];\n\t\t\t\t\tif(j<=r[i].s)max = Math.max(max, r[i].e+dp[r[i].t+1][k]);\n\t\t\t\t\tif(k<=r[i].s)max = Math.max(max, r[i].e+dp[j][r[i].t+1]);\n\t\t\t\t\tnext[j][k] = max;\n\t\t\t\t}\n\t\t\t\tdp = next;\n\t\t\t}\n//\t\t\tfor(int j=M;j>0;j--)for(int k=M;k>0;k--){\n//\t\t\t\tint max = Math.max(dp[j][k+1], dp[j+1][k]);\n//\t\t\t\tfor(R v:r[j]){\n//\t\t\t\t\tmax = Math.max(max, dp[v.t+1][k]+v.e);\n//\t\t\t\t}\n//\t\t\t\tfor(R v:r[k]){\n//\t\t\t\t\tmax = Math.max(max, dp[j][v.t+1]+v.e);\n//\t\t\t\t}\n//\t\t\t\tdp[j][k] = max;\n//\t\t\t}\n\t\t\tSystem.out.println(dp[1][1]);\n//\t\t\tfor(;;){\n//\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n//\t\t\t\tif((a|b)==0)break;\n//\t\t\t\tSystem.out.println(\"dp[\"+a+\"][\"+b+\"] DP:\" + dp[a][b]);\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      while (true) {\n        int N = in.nextInt();\n        if (N == 0) break;\n\n        int INF = (int) 1e6;\n        MinimumCostFlow flow = new MinimumCostFlow(366);\n        for (int i = 0; i < N; i++) {\n          int u = in.nextInt() - 1, v = in.nextInt() - 1, w = in.nextInt();\n          flow.addEdge(u, v + 1, 1, INF * (v + 1 - u) - w);\n        }\n        for (int i = 0; i < 365; i++) {\n          flow.addEdge(i, i + 1, 2, INF);\n        }\n        out.println(INF * 2 * 365 - flow.run(0, 365, 2));\n      }\n    }\n  }\n\n  static class MinimumCostFlow {\n    class Edge {\n      int to, rev;\n      long cap, cost;\n      Edge(int to, long cap, long cost, int rev) {\n        this.to = to;\n        this.cap = cap;\n        this.cost = cost;\n        this.rev = rev;\n      }\n    }\n\n    private static final long INF = Long.MAX_VALUE / 2;\n    private ArrayList<ArrayList<Edge>> G;\n    private int V;\n    long[] potential;\n    long[] dist;\n    int[] prevV, prevE;\n\n    MinimumCostFlow(int V) {\n      this.V = V;\n      G = new ArrayList<>(V);\n      for (int i = 0; i < V; i++) G.add(new ArrayList<Edge>());\n      potential = new long[V];\n      dist = new long[V];\n      prevE = new int[V];\n      prevV = new int[V];\n    }\n\n    void addEdge(int from, int to, long cap, long cost) {\n      G.get(from).add(new Edge(to, cap, cost, G.get(to).size()));\n      G.get(to).add(new Edge(from, 0, -cost, G.get(from).size() - 1));\n    }\n\n    long run(int s, int t, long flow) {\n      long cost = 0;\n      Arrays.fill(potential, 0);\n      while (flow > 0) {\n        PriorityQueue<long[]> queue = new PriorityQueue<>(new Comparator<long[]>() {\n          @Override\n          public int compare(long[] o1, long[] o2) {\n            return Long.compare(o1[0], o2[0]);\n          }\n        });\n        Arrays.fill(dist, INF);\n        dist[s] = 0;\n        queue.add(new long[]{0, s});\n        while (!queue.isEmpty()) {\n          long[] p = queue.poll();\n          int v = (int) p[1];\n          if (dist[v] < p[0]) continue;\n          for (int i = 0; i < G.get(v).size(); i++) {\n            Edge e = G.get(v).get(i);\n            int u = e.to;\n            if (e.cap > 0 && dist[u] > dist[v] + e.cost + potential[v] - potential[u]) {\n              dist[u] = dist[v] + e.cost + potential[v] - potential[u];\n              prevV[u] = v;\n              prevE[u] = i;\n              queue.add(new long[]{dist[u], u});\n            }\n          }\n        }\n        if (dist[t] == INF) return -1;\n        for (int v = 0; v < V; v++) potential[v] += dist[v];\n\n        long d = flow;\n        for (int v = t; v != s; v = prevV[v]) d = Math.min(d, G.get(prevV[v]).get(prevE[v]).cap);\n        flow -= d;\n        cost += d * potential[t];\n        for (int v = t; v != s; v = prevV[v]) {\n          Edge e = G.get(prevV[v]).get(prevE[v]);\n          e.cap -= d;\n          G.get(v).get(e.rev).cap += d;\n        }\n      }\n      return cost;\n    }\n  }\n\n  // Template\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  reqs = []\n  max_d = 0\n  n.times do\n    d0, d1, w = gets.split.map(&:to_i)\n    max_d = d1 if max_d < d1\n    reqs << [d0, d1, w]\n  end\n  #reqs.sort!\n\n  maxws = (max_d + 1).times.map{(max_d + 1).times.map{0}}\n\n  reqs.sort.each do |d0, d1, w|\n    maxws0 = maxws.map{|ws| ws.clone}\n\n    for i in (1..max_d)\n      for j in (1..max_d)\n        if i == j && i == d1\n          wi = maxws[d0 - 1][j] + w\n          wj = maxws[i][d0 - 1] + w\n          maxws0[i][j] = wi if maxws0[i][j] < wi\n          maxws0[i][j] = wj if maxws0[i][j] < wj\n        elsif i == d1\n          wi = maxws[d0 - 1][j] + w\n          maxws0[i][j] = wi if maxws0[i][j] < wi\n        elsif j == d1\n          wj = maxws[i][d0 - 1] + w\n          maxws0[i][j] = wj if maxws0[i][j] < wj\n        end\n\n        wij0 = maxws0[i - 1][j]\n        wij1 = maxws0[i][j - 1]\n        maxws0[i][j] = wij0 if maxws0[i][j] < wij0\n        maxws0[i][j] = wij1 if maxws0[i][j] < wij1\n      end\n    end\n\n    maxws = maxws0\n  end\n\n  puts maxws[max_d][max_d]\nend"
  },
  {
    "language": "Ruby",
    "code": "Y = 365\nloop do\n    n = gets.to_i\n    break if n == 0\n\n    a = (0..Y).map { [0] * (Y+1) }\n    input = (1..n).map { gets.split.map(&:to_i) }.sort_by {|_, j, _| j}\n    input.each do |i, j, w|\n        b = (0..Y).map { [0] * (Y+1) }\n        (0..Y).each do |k|\n            (0..k).each do |l|\n                candidates = [a[k][l]]\n                if k >= j\n                    x, y = i - 1, l\n                    x, y = y, x if y > x\n                    candidates << a[x][y] + w\n                end\n                if l >= j\n                    candidates << a[k][i-1] + w\n                end\n                b[k][l] = candidates.max\n            end\n        end\n        a = b\n    end\n    p a[-1][-1]\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n = gets.to_i\n    break if n == 0\n\n    applications = (1..n).map do\n        gets.split.map(&:to_i)\n    end \n    applications.sort_by!{|i, j, w| [j, i]} \n\n    hash = {[0, 0] => 0}\n    applications.each do |i, j, w|\n        next_hash = Hash.new(0)\n        hash.each do |(a, b), profit|\n            next_hash[[a, b]] = profit if profit > next_hash[[a, b]] \n            if a < i \n                t = [j, b].sort\n                next_hash[t] = profit + w if profit + w > next_hash[t]\n            end\n            if b < i \n                t = [a, j].sort\n                next_hash[t] = profit + w if profit + w > next_hash[t]\n            end\n        end\n        hash = next_hash\n    end \n    p hash.values.max\nend"
  },
  {
    "language": "Ruby",
    "code": "Y = 365\nloop do\n    n = gets.to_i\n    break if n == 0\n\n    a = (0..Y).map {|i| [0] * (i+1) }\n    input = (1..n).map { gets.split.map(&:to_i) }.sort_by {|_, j, _| j}\n    input.each do |i, j, w|\n        b = (0..Y).map { [0] * (Y+1) }\n        (0..Y).each do |k|\n            (0..k).each do |l|\n                max = a[k][l]\n                if k >= j\n                    x, y = i - 1, l\n                    x, y = y, x if y > x\n                    m = a[x][y] + w\n                    max = m if m > max\n                end\n                if l >= j\n                    m = a[k][i-1] + w\n                    max = m if m > max\n                end\n                b[k][l] = max\n            end\n        end\n        a = b\n    end\n    p a[-1][-1]\nend"
  },
  {
    "language": "Ruby",
    "code": "Y = 365\nloop do\n    n = gets.to_i\n    break if n == 0\n\n    a = (0..Y).map { [0] * (Y+1) }\n    input = (1..n).map { gets.split.map(&:to_i) }.sort_by {|_, j, _| j}\n    input.each do |i, j, w|\n        b = (0..Y).map { [0] * (Y+1) }\n        (0..Y).each do |k|\n            (0..k).each do |l|\n                candidates = [a[k][l]]\n                if k >= j\n                    x, y = i - 1, l\n                    x, y = y, x if y > x\n                    candidates << a[x][y] + w\n                end\n                if l >= j\n                    candidates << a[k][i-1] + w\n                end\n                b[k][l] = candidates.max\n            end\n        end\n        a = b\n    end\n    p a[-1][-1]\nend"
  },
  {
    "language": "Python",
    "code": "while 1:\n    N = int(input())\n    if N == 0:\n        break\n    P = [list(map(int, input().split())) for i in range(N)]\n    M = 366\n    E = [[] for i in range(M)]\n    dp = [[0]*(M+1) for i in range(M+1)]\n    for t, (i, j, w) in enumerate(P):\n        E[i-1].append((t, j, w))\n    for i in range(M):\n        Ei = E[i]\n        for j in range(i, M):\n            dp[i+1][j+1] = max(dp[i+1][j+1], dp[i+1][j], dp[i][j+1])\n        for j in range(M-1, i, -1):\n            v = dp[i+1][j+1]\n            for _, k, w in Ei:\n                if k < j:\n                    dp[k+1][j+1] = max(dp[k+1][j+1], v + w)\n                else:\n                    dp[j+1][k+1] = max(dp[j+1][k+1], v + w)\n        v = dp[i+1][i+1]\n        for t1, k1, w1 in Ei:\n            dp[i+1][k1+1] = max(dp[i+1][k1+1], v + w1)\n            for t2, k2, w2 in Ei:\n                if t1 <= t2:\n                    break\n                if k1 < k2:\n                    dp[k1+1][k2+1] = max(dp[k1+1][k2+1], v + w1 + w2)\n                else:\n                    dp[k2+1][k1+1] = max(dp[k2+1][k1+1], v + w1 + w2)\n    print(max(max(dpi) for dpi in dp))\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass Edge():\n    def __init__(self,t,f,r,ca,co):\n        self.to = t\n        self.fron = f\n        self.rev = r\n        self.cap = ca\n        self.cost = co\n\nclass MinCostFlow():\n    size = 0\n    graph = []\n\n    def __init__(self, s):\n        self.size = s\n        self.graph = [[] for _ in range(s)]\n\n    def add_edge(self, f, t, ca, co):\n        self.graph[f].append(Edge(t, f, len(self.graph[t]), ca, co))\n        self.graph[t].append(Edge(f, t, len(self.graph[f])-1, 0, -co))\n\n    def min_path(self, s, t):\n        dist = [inf] * self.size\n        route = [None] * self.size\n        que = collections.deque()\n        inq = [False] * self.size\n        dist[s] = 0\n        que.append(s)\n        inq[s] = True\n        while que:\n            u = que.popleft()\n            inq[u] = False\n            for e in self.graph[u]:\n                if e.cap == 0:\n                    continue\n                v = e.to\n                if dist[v] > dist[u] + e.cost:\n                    dist[v] = dist[u] + e.cost\n                    route[v] = e\n                    if not inq[v]:\n                        que.append(v)\n                        inq[v] = True\n\n        if dist[t] == inf:\n            return inf\n\n        flow = inf\n        v = t\n        while v != s:\n            e = route[v]\n            if flow > e.cap:\n                flow = e.cap\n            v = e.fron\n\n        c = 0\n        v = t\n        while v != s:\n            e = route[v]\n            e.cap -= flow\n            self.graph[e.to][e.rev].cap += flow\n            c += e.cost * flow\n            v = e.fron\n\n        return dist[t]\n\n    def calc_min_cost_flow(self, s, t, flow):\n        total_cost = 0\n        for i in range(flow):\n            c = self.min_path(s, t)\n            if c == inf:\n                return c\n            total_cost += c\n\n        return total_cost\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = sorted([LI() for _ in range(n)], key=lambda x: [x[1], x[0], -x[2]])\n        mcf = MinCostFlow(368)\n        s = 366\n        t = 367\n        for i in range(1,366):\n            mcf.add_edge(i-1,i,2,0)\n        for i,j,w in a:\n            mcf.add_edge(i-1,j,1,-w)\n        mcf.add_edge(s,0,2,0)\n        mcf.add_edge(365,t,2,0)\n\n        res = mcf.calc_min_cost_flow(s, t, 2)\n        return -res\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass MinCostFlow:\n    class Edge:\n        def __init__(self, to, cap, rev, cost):\n            self.to, self.cap, self.rev, self.cost = to, cap, rev, cost\n\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, fr, to, cap, cost):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to]), cost))\n        self.E[to].append(self.Edge(fr, 0, len(self.E[fr])-1, -cost))\n\n    def run(self, source, sink, f, INF=10**5):\n        res = 0\n        h, prevv, preve = [0] * self.V, [0] * self.V, [0] * self.V\n        while (f > 0):\n            pque = []\n            dist = [INF] * self.V\n            dist[source] = 0\n            heapq.heappush(pque, (0, source))\n            while pque:\n                cost, v = heapq.heappop(pque)\n                cost = -cost\n                if dist[v] < cost:\n                    continue\n                for i, e in enumerate(self.E[v]):\n                    if e.cap > 0 and dist[v] - h[e.to] < dist[e.to] - e.cost - h[v]:\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prevv[e.to], preve[e.to] = v, i\n                        heapq.heappush(pque, (-dist[e.to], e.to))\n            if dist[sink] == INF:\n                return -1\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d, v = f, sink\n            while v != source:\n                d = min(d, self.E[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n            f -= d\n            res += d * h[sink]\n            v = sink\n            while v != source:\n                self.E[prevv[v]][preve[v]].cap -= d\n                self.E[v][self.E[prevv[v]][preve[v]].rev].cap += d\n                v = prevv[v]\n        return res\n\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    V = 366\n    mcf = MinCostFlow(V)\n    for i in range(V - 1):\n        mcf.add_edge(i, i + 1, 2, 0)\n    for _ in range(N):\n        s, t, c = map(int, input().split())\n        mcf.add_edge(s - 1, t, 1, -c)\n    print(-mcf.run(0, V - 1, 2, 10 ** 9))"
  },
  {
    "language": "Python",
    "code": "import heapq\n\n\nclass MinCostFlow:\n    class Edge:\n        def __init__(self, to, cap, rev, cost):\n            self.to, self.cap, self.rev, self.cost = to, cap, rev, cost\n\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, fr, to, cap, cost):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to]), cost))\n        self.E[to].append(self.Edge(fr, 0, len(self.E[fr])-1, -cost))\n\n    def run(self, source, sink, f, INF=10**5):\n        res = 0\n        h, prevv, preve = [0] * self.V, [0] * self.V, [0] * self.V\n        while (f > 0):\n            pque = []\n            dist = [INF] * self.V\n            dist[source] = 0\n            heapq.heappush(pque, (0, source))\n            while pque:\n                cost, v = heapq.heappop(pque)\n                cost = -cost\n                if dist[v] < cost:\n                    continue\n                for i, e in enumerate(self.E[v]):\n                    if e.cap > 0 and dist[v] - h[e.to] < dist[e.to] - e.cost - h[v]:\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prevv[e.to], preve[e.to] = v, i\n                        heapq.heappush(pque, (-dist[e.to], e.to))\n            if dist[sink] == INF:\n                return -1\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d, v = f, sink\n            while v != source:\n                d = min(d, self.E[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n            f -= d\n            res += d * h[sink]\n            v = sink\n            while v != source:\n                self.E[prevv[v]][preve[v]].cap -= d\n                self.E[v][self.E[prevv[v]][preve[v]].rev].cap += d\n                v = prevv[v]\n        return res\n\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    V = 366\n    mcf = MinCostFlow(V)\n    for i in range(V - 1):\n        mcf.add_edge(i, i + 1, 2, 0)\n    for _ in range(N):\n        s, t, c = map(int, input().split())\n        mcf.add_edge(s - 1, t, 1, -c)\n    print(-mcf.run(0, V - 1, 2, 10 ** 9))"
  },
  {
    "language": "Python",
    "code": "import heapq\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass MinCostFlow:\n    class Edge:\n        def __init__(self, to, cap, rev, cost):\n            self.to, self.cap, self.rev, self.cost = to, cap, rev, cost\n\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, fr, to, cap, cost):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to]), cost))\n        self.E[to].append(self.Edge(fr, 0, len(self.E[fr])-1, -cost))\n\n    def run(self, source, sink, f, INF=10**5):\n        res = 0\n        h, prevv, preve = [0] * self.V, [0] * self.V, [0] * self.V\n        while (f > 0):\n            pque = []\n            dist = [INF] * self.V\n            dist[source] = 0\n            heapq.heappush(pque, (0, source))\n            while pque:\n                cost, v = heapq.heappop(pque)\n                cost = -cost\n                if dist[v] < cost:\n                    continue\n                for i, e in enumerate(self.E[v]):\n                    if e.cap > 0 and dist[v] - h[e.to] < dist[e.to] - e.cost - h[v]:\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prevv[e.to], preve[e.to] = v, i\n                        heapq.heappush(pque, (-dist[e.to], e.to))\n            if dist[sink] == INF:\n                return -1\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d, v = f, sink\n            while v != source:\n                d = min(d, self.E[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n            f -= d\n            res += d * h[sink]\n            v = sink\n            while v != source:\n                self.E[prevv[v]][preve[v]].cap -= d\n                self.E[v][self.E[prevv[v]][preve[v]].rev].cap += d\n                v = prevv[v]\n        return res\n\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    V = 366\n    mcf = MinCostFlow(V)\n    for i in range(V - 1):\n        mcf.add_edge(i, i + 1, 2, 0)\n    for _ in range(N):\n        s, t, c = map(int, input().split())\n        mcf.add_edge(s - 1, t, 1, -c)\n    print(-mcf.run(0, V - 1, 2, 10 ** 9))"
  }
]