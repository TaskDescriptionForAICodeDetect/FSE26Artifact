[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n    int price;\n} Application;\n\nint compare(const void *a, const void *b) {\n    Application *app1 = (Application *)a;\n    Application *app2 = (Application *)b;\n    return app1->end - app2->end;\n}\n\nint findNonOverlapping(Application apps[], int index) {\n    for (int i = index - 1; i >= 0; i--) {\n        if (apps[i].end < apps[index].start) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint maxIncome(Application apps[], int n) {\n    qsort(apps, n, sizeof(Application), compare);\n    int *dp = (int *)malloc(n * sizeof(int));\n    dp[0] = apps[0].price;\n\n    for (int i = 1; i < n; i++) {\n        int current = apps[i].price;\n        int l = findNonOverlapping(apps, i);\n        if (l != -1) {\n            current += dp[l];\n        }\n        dp[i] = (current > dp[i-1]) ? current : dp[i-1];\n    }\n\n    int result = dp[n-1];\n    free(dp);\n    return result;\n}\n\nint maxTwoRoomIncome(Application apps[], int n) {\n    qsort(apps, n, sizeof(Application), compare);\n    int *dp = (int *)malloc(n * sizeof(int));\n    int *dp2 = (int *)malloc(n * sizeof(int));\n    dp[0] = apps[0].price;\n    dp2[0] = apps[0].price;\n\n    for (int i = 1; i < n; i++) {\n        int current = apps[i].price;\n        int l = findNonOverlapping(apps, i);\n        if (l != -1) {\n            current += dp[l];\n        }\n        dp[i] = (current > dp[i-1]) ? current : dp[i-1];\n    }\n\n    for (int i = 1; i < n; i++) {\n        int max_current = 0;\n        for (int j = i; j >= 0; j--) {\n            int current = apps[j].price;\n            int l = findNonOverlapping(apps, j);\n            if (l != -1) {\n                current += dp[l];\n            }\n            if (current > max_current) {\n                max_current = current;\n            }\n        }\n        dp2[i] = (max_current > dp2[i-1]) ? max_current : dp2[i-1];\n    }\n\n    int result = dp2[n-1];\n    free(dp);\n    free(dp2);\n    return result;\n}\n\nint main() {\n    int m;\n    while (scanf(\"%d\", &m) != EOF) {\n        Application *apps = (Application *)malloc(m * sizeof(Application));\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &apps[i].start, &apps[i].end, &apps[i].price);\n        }\n        printf(\"%d\\n\", maxTwoRoomIncome(apps, m));\n        free(apps);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:15:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConcertHallOptimization {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            List<Concert> concerts = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                int price = scanner.nextInt();\n                concerts.add(new Concert(start, end, price));\n            }\n            \n            System.out.println(maxIncome(concerts));\n        }\n        \n        scanner.close();\n    }\n    \n    static int maxIncome(List<Concert> concerts) {\n        Collections.sort(concerts, (a, b) -> a.end - b.end);\n        int[] dp = new int[concerts.size() + 1];\n        \n        for (int i = 0; i < concerts.size(); i++) {\n            int currentPrice = concerts.get(i).price;\n            int prevCompatibleIndex = binarySearch(concerts, i);\n            \n            dp[i + 1] = Math.max(\n                dp[i], \n                (prevCompatibleIndex >= 0 ? dp[prevCompatibleIndex + 1] : 0) + currentPrice\n            );\n        }\n        \n        return dp[concerts.size()];\n    }\n    \n    static int binarySearch(List<Concert> concerts, int currentIndex) {\n        Concert current = concerts.get(currentIndex);\n        int low = 0, high = currentIndex - 1;\n        \n        while (low <= high) {\n            int mid = (low + high) / 2;\n            Concert midConcert = concerts.get(mid);\n            \n            if (midConcert.end <= current.start) {\n                if (mid == high || concerts.get(mid + 1).end > current.start) {\n                    return mid;\n                }\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n    \n    static class Concert {\n        int start, end, price;\n        \n        Concert(int start, int end, int price) {\n            this.start = start;\n            this.end = end;\n            this.price = price;\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:15:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Application {\n    int start, end, price;\n};\n\nbool compareEnd(const Application &a, const Application &b) {\n    return a.end < b.end;\n}\n\nint findLastNonConflict(const vector<Application> &apps, int index) {\n    int low = 0, high = index - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (apps[mid].end < apps[index].start) {\n            if (apps[mid + 1].end < apps[index].start) {\n                low = mid + 1;\n            } else {\n                return mid;\n            }\n        } else {\n            high = mid - 1;\n        }\n    }\n    return -1;\n}\n\nint maximizeIncome(vector<Application> &apps) {\n    sort(apps.begin(), apps.end(), compareEnd);\n    int n = apps.size();\n    vector<int> dp(n);\n    dp[0] = apps[0].price;\n    for (int i = 1; i < n; ++i) {\n        int incl = apps[i].price;\n        int l = findLastNonConflict(apps, i);\n        if (l != -1) {\n            incl += dp[l];\n        }\n        dp[i] = max(incl, dp[i - 1]);\n    }\n    return dp[n - 1];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int datasets;\n    cin >> datasets;\n    while (datasets--) {\n        int n;\n        cin >> n;\n        vector<Application> apps(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> apps[i].start >> apps[i].end >> apps[i].price;\n        }\n        vector<Application> room1, room2;\n        int maxIncome = 0;\n        for (int mask = 0; mask < (1 << n); ++mask) {\n            room1.clear();\n            room2.clear();\n            for (int i = 0; i < n; ++i) {\n                if (mask & (1 << i)) {\n                    room1.push_back(apps[i]);\n                } else {\n                    room2.push_back(apps[i]);\n                }\n            }\n            int income1 = maximizeIncome(room1);\n            int income2 = maximizeIncome(room2);\n            if (income1 + income2 > maxIncome) {\n                maxIncome = income1 + income2;\n            }\n        }\n        cout << maxIncome << '\\n';\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:16:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_APPS 1000\n\ntypedef struct {\n    int start;\n    int end;\n    int price;\n} Application;\n\nint compare(const void* a, const void* b) {\n    return ((Application*)a)->end - ((Application*)b)->end;\n}\n\nint find_max_income(Application* apps, int n) {\n    qsort(apps, n, sizeof(Application), compare);\n    \n    int dp[2][365 * 2 + 1] = {0};\n    \n    for (int i = 0; i < n; i++) {\n        dp[0][i + 1] = dp[0][i];\n        dp[1][i + 1] = dp[1][i];\n        \n        int prev0 = -1, prev1 = -1;\n        for (int j = i - 1; j >= 0; j--) {\n            if (apps[j].end < apps[i].start) {\n                if (prev0 == -1) prev0 = j;\n                if (prev1 == -1) prev1 = j;\n                break;\n            }\n        }\n        \n        int income0 = (prev0 == -1) ? apps[i].price : dp[0][prev0 + 1] + apps[i].price;\n        int income1 = (prev1 == -1) ? apps[i].price : dp[1][prev1 + 1] + apps[i].price;\n        \n        if (income0 > dp[0][i]) dp[0][i + 1] = income0;\n        if (income1 > dp[1][i]) dp[1][i + 1] = income1;\n    }\n    \n    return (dp[0][n] > dp[1][n]) ? dp[0][n] : dp[1][n];\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    for (int d = 0; d < datasets; d++) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        Application apps[MAX_APPS];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &apps[i].start, &apps[i].end, &apps[i].price);\n        }\n        \n        int max_income = find_max_income(apps, n);\n        printf(\"%d\\n\", max_income);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:16:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_DAYS = 365;\n\nstruct Concert {\n    int start, end, price;\n};\n\nint maxIncome(vector<Concert>& concerts) {\n    int n = concerts.size();\n    vector<vector<int>> dp(MAX_DAYS + 1, vector<int>(3, 0));\n\n    sort(concerts.begin(), concerts.end(), [](const Concert& a, const Concert& b) {\n        return a.end < b.end;\n    });\n\n    for (const Concert& concert : concerts) {\n        for (int day = 1; day <= MAX_DAYS; day++) {\n            dp[day][0] = max(dp[day-1][0], max(dp[day-1][1], dp[day-1][2]));\n            \n            if (concert.start >= day) {\n                dp[concert.end][1] = max(dp[concert.end][1], \n                    max(dp[concert.start-1][0], max(dp[concert.start-1][1], dp[concert.start-1][2])) + concert.price);\n                \n                dp[concert.end][2] = max(dp[concert.end][2], \n                    max(dp[concert.start-1][0], max(dp[concert.start-1][1], dp[concert.start-1][2])) + concert.price);\n            }\n        }\n    }\n\n    return max({dp[MAX_DAYS][0], dp[MAX_DAYS][1], dp[MAX_DAYS][2]});\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    while (datasets--) {\n        int n;\n        cin >> n;\n        \n        vector<Concert> concerts(n);\n        for (int i = 0; i < n; i++) {\n            cin >> concerts[i].start >> concerts[i].end >> concerts[i].price;\n        }\n\n        cout << maxIncome(concerts) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Application {\n    int start, end, price;\n\n    public Application(int start, int end, int price) {\n        this.start = start;\n        this.end = end;\n        this.price = price;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            List<Application> apps = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                int price = scanner.nextInt();\n                apps.add(new Application(start, end, price));\n            }\n            Collections.sort(apps, (a, b) -> a.end - b.end);\n            int maxDay = apps.get(apps.size() - 1).end;\n            int[] dp = new int[maxDay + 1];\n            int index = 0;\n            for (int day = 1; day <= maxDay; day++) {\n                dp[day] = dp[day - 1];\n                while (index < apps.size() && apps.get(index).end == day) {\n                    Application app = apps.get(index);\n                    if (app.start > 0) {\n                        dp[day] = Math.max(dp[day], dp[app.start - 1] + app.price);\n                    } else {\n                        dp[day] = Math.max(dp[day], app.price);\n                    }\n                    index++;\n                }\n            }\n            int[] dp2 = new int[maxDay + 1];\n            index = 0;\n            int maxIncome = 0;\n            for (int day = 1; day <= maxDay; day++) {\n                dp2[day] = dp2[day - 1];\n                while (index < apps.size() && apps.get(index).end == day) {\n                    Application app = apps.get(index);\n                    if (app.start > 0) {\n                        dp2[day] = Math.max(dp2[day], dp[app.start - 1] + app.price);\n                    } else {\n                        dp2[day] = Math.max(dp2[day], app.price);\n                    }\n                    index++;\n                }\n                maxIncome = Math.max(maxIncome, dp2[day] + dp[maxDay]);\n            }\n            System.out.println(maxIncome);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:17:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_income(applications):\n    def knapSack(apps, room):\n        dp = [[0] * (365 + 1) for _ in range(len(apps) + 1)]\n        for i in range(1, len(apps) + 1):\n            for curr_day in range(365 + 1):\n                app_start, app_end, app_value = apps[i - 1]\n                if room == 1:\n                    if curr_day > app_end:\n                        if curr_day <= app_end + room:\n                            dp[i][curr_day] = max(dp[i - 1][curr_day], \n                                                  dp[i - 1][max(curr_day - (app_end - app_start + 1), 0)] + app_value)\n                        else:\n                            dp[i][curr_day] = dp[i - 1][curr_day]\n                    else:\n                        dp[i][curr_day] = dp[i - 1][curr_day]\n                else:\n                    dp[i][curr_day] = dp[i - 1][curr_day]\n        return max(max(row) for row in dp)\n\n    return max(knapSack(applications, 1), knapSack(applications, 2))\n\nimport sys\n\ndef parse_input():\n    lines = sys.stdin.readlines()\n    results = []\n    for i in range(0, len(lines), 1):\n        num_applications = int(lines[i].strip())\n        applications = []\n        for j in range(num_applications):\n            start, end, value = map(int, lines[i + j + 1].strip().split())\n            applications.append((start, end, value))\n        results.append(max_income(applications))\n    return results\n\nif __name__ == '__main__':\n    for result in parse_input():\n        print(result)",
    "timestamp": "2025-08-13 03:16:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ConcertHallMaxIncome {\n\n    static class Application {\n        int start, end, price;\n\n        Application(int start, int end, int price) {\n            this.start = start;\n            this.end = end;\n            this.price = price;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int datasetCount = sc.nextInt();\n        \n        while (datasetCount-- > 0) {\n            int n = sc.nextInt();\n            Application[] apps = new Application[n];\n\n            for (int i = 0; i < n; i++) {\n                int start = sc.nextInt();\n                int end = sc.nextInt();\n                int price = sc.nextInt();\n                apps[i] = new Application(start, end, price);\n            }\n            \n            System.out.println(maxIncome(apps));\n        }\n        \n        sc.close();\n    }\n\n    private static int maxIncome(Application[] apps) {\n        Comparator<Application> comparator = (a, b) -> a.end - b.end;\n        Arrays.sort(apps, comparator);\n        return findMaxIncome(apps);\n    }\n\n    private static int findMaxIncome(Application[] apps) {\n        int n = apps.length;\n        int[] dp1 = new int[n];\n        int[] dp2 = new int[n];\n        \n        dp1[0] = apps[0].price;\n        dp2[0] = apps[0].price;\n\n        for (int i = 1; i < n; i++) {\n            int includePrice1 = apps[i].price;\n            int includePrice2 = apps[i].price;\n\n            for (int j = i - 1; j >= 0; j--) {\n                if (apps[j].end <= apps[i].start) {\n                    includePrice1 += dp1[j];\n                    includePrice2 += dp2[j];\n                    break;\n                }\n            }\n            dp1[i] = Math.max(dp1[i - 1], includePrice1);\n            dp2[i] = Math.max(dp2[i - 1], includePrice2);\n        }\n        \n        return Math.max(dp1[n - 1], dp2[n - 1]);\n    }\n}",
    "timestamp": "2025-08-13 03:16:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n\ntypedef struct {\n    int start;\n    int end;\n    int price;\n} Application;\n\nint maxIncome(Application applications[], int n) {\n    int dp[2][365] = {0};\n    for (int k = 0; k < n; k++) {\n        for (int room = 1; room >= 0; room--) { \n            for (int day = 364; day >= applications[k].end; day--) {\n                dp[room][day] = dp[room][day] > dp[room][day - 1] ? dp[room][day] : dp[room][day - 1];\n                int prevIncome = day > applications[k].end ? dp[room][applications[k].end] : 0;\n                dp[room][day] = dp[room][day] > prevIncome + applications[k].price ? dp[room][day] : prevIncome + applications[k].price;\n                int otherRoom = (room + 1) % 2;\n                dp[room][day] = dp[room][day] > dp[otherRoom][day] ? dp[room][day] : dp[otherRoom][day];\n            }\n        }\n    }\n    return dp[0][364] > dp[1][364] ? dp[0][364] : dp[1][364];\n}\n\nint main() {\n    int numDatasets, n;\n    scanf(\"%d\", &numDatasets);\n    while (numDatasets--) {\n        scanf(\"%d\", &n);\n        Application applications[MAX_N];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &applications[i].start, &applications[i].end, &applications[i].price);\n            applications[i].end--;\n        }\n        printf(\"%d\\n\", maxIncome(applications, n));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 03:17:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_concert_hall_scheduling(applications):\n    # Sort applications by end time\n    applications.sort(key=lambda x: x[1])\n    \n    # Find maximum compatible income for 2 rooms\n    def max_compatible_income(room_apps):\n        if not room_apps:\n            return 0\n        \n        dp = [0] * (len(room_apps) + 1)\n        \n        for i in range(1, len(room_apps) + 1):\n            current_income = room_apps[i-1][2]\n            prev_compatible = 0\n            \n            for j in range(i-1, 0, -1):\n                if room_apps[j-1][1] < room_apps[i-1][0]:\n                    prev_compatible = dp[j]\n                    break\n            \n            dp[i] = max(dp[i-1], prev_compatible + current_income)\n        \n        return dp[-1]\n    \n    # Compute maximum income for two identical rooms\n    def max_room_income(apps):\n        # Try all possible splits of applications between rooms\n        max_income = 0\n        for mask in range(1 << len(apps)):\n            room1_apps = []\n            room2_apps = []\n            \n            for i, app in enumerate(apps):\n                if mask & (1 << i):\n                    room1_apps.append(app)\n                else:\n                    room2_apps.append(app)\n            \n            # Ensure no overlapping applications in each room\n            room1_apps.sort(key=lambda x: x[1])\n            room2_apps.sort(key=lambda x: x[1])\n            \n            room1_max = max_compatible_income(room1_apps)\n            room2_max = max_compatible_income(room2_apps)\n            \n            max_income = max(max_income, room1_max + room2_max)\n        \n        return max_income\n    \n    return max_room_income(applications)\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        applications = []\n        \n        for _ in range(N):\n            i, j, w = map(int, input().split())\n            applications.append((i, j, w))\n        \n        print(solve_concert_hall_scheduling(applications))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:17:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        N = int(input[ptr])\n        ptr += 1\n        applications = []\n        for _ in range(N):\n            i = int(input[ptr])\n            j = int(input[ptr+1])\n            w = int(input[ptr+2])\n            applications.append((i, j, w))\n            ptr += 3\n        \n        applications.sort(key=lambda x: x[1])\n        \n        # Binary search to find the last non-overlapping application\n        def find_last_non_overlapping(start, end, target):\n            low = 0\n            high = end\n            res = -1\n            while low <= high:\n                mid = (low + high) // 2\n                if applications[mid][1] < target:\n                    res = mid\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return res\n        \n        # DP for one room\n        dp = [0] * N\n        dp[0] = applications[0][2]\n        for i in range(1, N):\n            current_i, current_j, current_w = applications[i]\n            last = find_last_non_overlapping(0, i-1, current_i)\n            if last != -1:\n                current_w += dp[last]\n            dp[i] = max(dp[i-1], current_w)\n        \n        # Now, we need to find two disjoint sets of intervals with maximum sum\n        # We can use another DP to track the best two non-overlapping sets\n        dp2 = [0] * N\n        if N < 2:\n            print(dp[-1])\n            continue\n        \n        dp2[1] = applications[0][2] + applications[1][2] if applications[0][1] < applications[1][0] else max(applications[0][2], applications[1][2])\n        for i in range(2, N):\n            current_i, current_j, current_w = applications[i]\n            last = find_last_non_overlapping(0, i-1, current_i)\n            # Option 1: Don't take current interval in either room\n            option1 = dp2[i-1]\n            # Option 2: Take current interval in one room, find best for the other room before current_i\n            option2 = dp[i-1] + current_w\n            # Option 3: Take current interval in one room, and another non-overlapping in the other room\n            option3 = 0\n            if last != -1:\n                option3 = dp2[last] + current_w\n            dp2[i] = max(option1, option2, option3)\n        \n        print(dp2[-1])\n\nsolve()",
    "timestamp": "2025-08-13 03:18:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Application {\n    int start;\n    int end;\n    int price;\n};\n\nbool compareApplications(const Application &a, const Application &b) {\n    return a.end < b.end;\n}\n\nint maxIncomeForRoom(const std::vector<Application> &applications) {\n    std::vector<int> dp(applications.size(), 0);\n    \n    dp[0] = applications[0].price;\n    \n    for (int i = 1; i < applications.size(); i++) {\n        int incl = applications[i].price;\n        int l = -1;\n        \n        for (int j = i - 1; j >= 0; j--) {\n            if (applications[j].end <= applications[i].start) {\n                l = j;\n                break;\n            }\n        }\n        \n        if (l != -1) {\n            incl += dp[l];\n        }\n        \n        dp[i] = std::max(incl, dp[i - 1]);\n    }\n    \n    return dp.back();\n}\n\nint main() {\n    int numDatasets;\n    std::cin >> numDatasets;\n    \n    while (numDatasets--) {\n        int numApplications;\n        std::cin >> numApplications;\n        \n        std::vector<Application> applications(numApplications);\n        \n        for (int i = 0; i < numApplications; i++) {\n            std::cin >> applications[i].start >> applications[i].end >> applications[i].price;\n        }\n        \n        std::sort(applications.begin(), applications.end(), compareApplications);\n        \n        int maxIncomeRoom1 = maxIncomeForRoom(applications);\n        int maxIncomeRoom2 = maxIncomeForRoom(applications);\n        \n        std::cout << (maxIncomeRoom1 + maxIncomeRoom2) << std::endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:10:48"
  }
]