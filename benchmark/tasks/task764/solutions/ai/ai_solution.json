[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nlong long modInverse(long long a, long long m) {\n    long long m0 = m;\n    long long y = 0, x = 1;\n    \n    if (m == 1) return 0;\n    \n    while (a > 1) {\n        long long q = a / m;\n        long long t = m;\n        \n        m = a % m;\n        a = t;\n        t = y;\n        \n        y = x - q * y;\n        x = t;\n    }\n    \n    if (x < 0) x += m0;\n    \n    return x;\n}\n\nint main() {\n    int N, A, B, C;\n    scanf(\"%d %d %d %d\", &N, &A, &B, &C);\n    \n    long long MOD = 1000000007;\n    long long p = 0, q = 0;\n    \n    // Probability fractions as percentages\n    double pA = A / 100.0;\n    double pB = B / 100.0;\n    double pC = C / 100.0;\n    \n    // Expected games calculation\n    if (pA + pB + pC == 1.0) {\n        double expected = 0;\n        \n        for (int takahashi = 0; takahashi < N; takahashi++) {\n            for (int aoki = 0; aoki < N; aoki++) {\n                double prob = pow(pA, takahashi) * pow(pB, aoki) * pow(pC, 0);\n                expected += (takahashi + aoki + 1) * prob;\n            }\n        }\n        \n        // Convert to fraction representation\n        long long denominator = 100;\n        for (int i = 0; i < N * 2; i++) {\n            denominator *= 100;\n        }\n        \n        long long numerator = (long long)(expected * denominator);\n        \n        // Simplify fraction\n        long long g = gcd(numerator, denominator);\n        p = numerator / g;\n        q = denominator / g;\n    }\n    \n    // Compute modular inverse\n    long long result = (p * modInverse(q, MOD)) % MOD;\n    \n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n#define MAX_N 100000\n\nlong long inv(long long a, long long mod) {\n    long long b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b;\n        long long tmp = a; a = b; b = tmp;\n        u -= t * v;\n        tmp = u; u = v; v = tmp;\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\nint main() {\n    int N;\n    long long A, B, C;\n    scanf(\"%d %lld %lld %lld\", &N, &A, &B, &C);\n    \n    long long inv100 = inv(100, MOD);\n    long long a = A * inv100 % MOD;\n    long long b = B * inv100 % MOD;\n    long long c = C * inv100 % MOD;\n    long long inv_ab = inv((a + b) % MOD, MOD);\n    long long a_ab = a * inv_ab % MOD;\n    long long b_ab = b * inv_ab % MOD;\n    \n    long long pow_a_ab[MAX_N * 2 + 1];\n    long long pow_b_ab[MAX_N * 2 + 1];\n    long long fact[MAX_N * 2 + 1];\n    long long inv_fact[MAX_N * 2 + 1];\n    \n    pow_a_ab[0] = 1;\n    pow_b_ab[0] = 1;\n    for (int i = 1; i <= 2 * N; i++) {\n        pow_a_ab[i] = pow_a_ab[i - 1] * a_ab % MOD;\n        pow_b_ab[i] = pow_b_ab[i - 1] * b_ab % MOD;\n    }\n    \n    fact[0] = 1;\n    for (int i = 1; i <= 2 * N; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    \n    inv_fact[2 * N] = inv(fact[2 * N], MOD);\n    for (int i = 2 * N - 1; i >= 0; i--) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n    \n    long long inv_1_c = inv((1 - c + MOD) % MOD, MOD);\n    \n    long long res = 0;\n    for (int k = 0; k < N; k++) {\n        long long comb = fact[N + k - 1] * inv_fact[N - 1] % MOD;\n        comb = comb * inv_fact[k] % MOD;\n        long long term = comb * pow_a_ab[N] % MOD;\n        term = term * pow_b_ab[k] % MOD;\n        res = (res + term * (N + k)) % MOD;\n    }\n    for (int k = 0; k < N; k++) {\n        long long comb = fact[N + k - 1] * inv_fact[N - 1] % MOD;\n        comb = comb * inv_fact[k] % MOD;\n        long long term = comb * pow_b_ab[N] % MOD;\n        term = term * pow_a_ab[k] % MOD;\n        res = (res + term * (N + k)) % MOD;\n    }\n    res = res * inv_1_c % MOD;\n    printf(\"%lld\\n\", res);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modinv(long long a, long long mod) {\n    long long b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\nint main() {\n    int N, A, B, C;\n    cin >> N >> A >> B >> C;\n\n    long long inv100 = modinv(100, MOD);\n    long long a = A * inv100 % MOD;\n    long long b = B * inv100 % MOD;\n    long long c = C * inv100 % MOD;\n    long long inv_ab = modinv((a + b) % MOD, MOD);\n    long long a_prime = a * inv_ab % MOD;\n    long long b_prime = b * inv_ab % MOD;\n\n    vector<long long> dp_a(N + 1), dp_b(N + 1);\n    vector<long long> pow_a(N + 1), pow_b(N + 1);\n    vector<long long> fact(2 * N + 1), inv_fact(2 * N + 1);\n\n    fact[0] = 1;\n    for (int i = 1; i <= 2 * N; ++i) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    inv_fact[2 * N] = modinv(fact[2 * N], MOD);\n    for (int i = 2 * N - 1; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n\n    pow_a[0] = pow_b[0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        pow_a[i] = pow_a[i - 1] * a_prime % MOD;\n        pow_b[i] = pow_b[i - 1] * b_prime % MOD;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        dp_a[N] = (dp_a[N] + fact[N - 1 + i] * inv_fact[N - 1] % MOD * inv_fact[i] % MOD * pow_a[N] % MOD * pow_b[i] % MOD * (N + i)) % MOD;\n        dp_b[N] = (dp_b[N] + fact[N - 1 + i] * inv_fact[N - 1] % MOD * inv_fact[i] % MOD * pow_b[N] % MOD * pow_a[i] % MOD * (N + i)) % MOD;\n    }\n\n    for (int k = N - 1; k >= 0; --k) {\n        dp_a[k] = (a_prime * (1 + (k + 1 < N ? dp_a[k + 1] : 0)) + b_prime * (1 + (k < N ? dp_b[k] : 0))) % MOD;\n        dp_b[k] = (b_prime * (1 + (k + 1 < N ? dp_b[k + 1] : 0)) + a_prime * (1 + (k < N ? dp_a[k] : 0))) % MOD;\n    }\n\n    long long inv_s = modinv((1 - c + MOD) % MOD, MOD);\n    long long ans = inv_s * (1 + (a + b) % MOD * inv_ab % MOD * dp_a[0] % MOD) % MOD;\n\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = (int) 1e9 + 7;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        int C = sc.nextInt();\n        \n        long inv100 = modInverse(100);\n        long a = (A * inv100) % MOD;\n        long b = (B * inv100) % MOD;\n        long c = (C * inv100) % MOD;\n        \n        long inv1c = modInverse((1 - c + MOD) % MOD);\n        long inv1c2 = (inv1c * inv1c) % MOD;\n        \n        long[] fact = new long[2 * N + 1];\n        long[] invFact = new long[2 * N + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= 2 * N; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        invFact[2 * N] = modInverse(fact[2 * N]);\n        for (int i = 2 * N - 1; i >= 0; i--) {\n            invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n        }\n        \n        long res = 0;\n        for (int k = 0; k < N; k++) {\n            long comb = fact[N - 1 + k] * invFact[k] % MOD;\n            comb = comb * invFact[N - 1] % MOD;\n            \n            long powA = pow(a, N);\n            long powB = pow(b, k);\n            long term1 = powA * powB % MOD;\n            term1 = term1 * (N + k) % MOD;\n            term1 = term1 * comb % MOD;\n            \n            powA = pow(a, k);\n            powB = pow(b, N);\n            long term2 = powA * powB % MOD;\n            term2 = term2 * (N + k) % MOD;\n            term2 = term2 * comb % MOD;\n            \n            res = (res + term1 + term2) % MOD;\n        }\n        \n        res = res * inv1c2 % MOD;\n        System.out.println(res);\n    }\n    \n    static long pow(long a, long b) {\n        long res = 1;\n        a %= MOD;\n        while (b > 0) {\n            if ((b & 1) != 0) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n    \n    static long modInverse(long a) {\n        return pow(a, MOD - 2);\n    }\n}",
    "timestamp": "2025-08-05 22:52:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        int C = sc.nextInt();\n\n        double[][][] dp = new double[N + 1][N + 1][2];\n        dp[0][0][0] = 1.0;\n\n        for (int x = 0; x <= N; x++) {\n            for (int y = 0; y <= N; y++) {\n                if (x == N || y == N) continue;\n                \n                dp[x + 1][y][0] += dp[x][y][0] * A / 100.0;\n                dp[x][y + 1][0] += dp[x][y][0] * B / 100.0;\n                dp[x][y][1] += dp[x][y][0] * C / 100.0;\n                \n                dp[x + 1][y][1] += dp[x][y][1] * A / 100.0;\n                dp[x][y + 1][1] += dp[x][y][1] * B / 100.0;\n            }\n        }\n\n        double expected = 0;\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                expected += (dp[x][y][0] + dp[x][y][1]) * (x + y + 1);\n            }\n        }\n\n        long P = (long) (expected * 100);\n        long Q = 100L;\n        long g = gcd(P, Q);\n        P /= g;\n        Q /= g;\n\n        long R = modInverse(Q, MOD);\n        long result = (P * R) % MOD;\n        System.out.println(result);\n    }\n\n    static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static long modInverse(long a, long m) {\n        long m0 = m;\n        long y = 0, x = 1;\n        if (m == 1) return 0;\n        while (a > 1) {\n            long q = a / m;\n            long t = m;\n            m = a % m;\n            a = t;\n            t = y;\n            y = x - q * y;\n            x = t;\n        }\n        return x < 0 ? x + m0 : x;\n    }\n}",
    "timestamp": "2025-08-05 22:52:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modInverse(long long a, long long m) {\n    long long m0 = m;\n    long long y = 0, x = 1;\n    if (m == 1) return 0;\n    while (a > 1) {\n        long long q = a / m;\n        long long t = m;\n        m = a % m, a = t;\n        t = y;\n        y = x - q * y;\n        x = t;\n    }\n    if (x < 0) x += m0;\n    return x;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    int A, B, C;\n    cin >> A >> B >> C;\n    \n    vector<vector<double>> dp(N*2+1, vector<double>(N*2+1, 0.0));\n    dp[0][0] = 1.0;\n    \n    for (int i = 0; i < 2*N; i++) {\n        for (int j = 0; j <= i; j++) {\n            int k = i - j;\n            if (j >= N || k >= N) continue;\n            \n            double p_win = A / 100.0;\n            double p_lose = B / 100.0;\n            double p_draw = C / 100.0;\n            \n            dp[j+1][k] += dp[j][k] * p_win;\n            dp[j][k+1] += dp[j][k] * p_lose;\n            dp[j][k] += dp[j][k] * p_draw;\n        }\n    }\n    \n    double expected_games = 0.0;\n    for (int j = 0; j < N; j++) {\n        for (int k = 0; k < N; k++) {\n            expected_games += (j + k + 1) * (dp[j+N][k] + dp[j][k+N]);\n        }\n    }\n    \n    long long P = llround(expected_games * 100 * 100);\n    long long Q = 100 * 100;\n    \n    long long g = __gcd(P, Q);\n    P /= g;\n    Q /= g;\n    \n    long long R = (P * modInverse(Q, MOD)) % MOD;\n    \n    cout << R << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    gcd, x, y = extended_gcd(b, a % b)\n    return gcd, y, x - (a // b) * y\n\ndef mod_inverse(a, m):\n    gcd, x, y = extended_gcd(a, m)\n    if gcd != 1:\n        return None\n    return x % m\n\ndef expected_games_to_win(N, A, B, C):\n    MOD = 10**9 + 7\n    p = A / 100.0\n    q = B / 100.0\n    r = C / 100.0\n    assert abs(p + q + r - 1.0) < 1e-9\n\n    def expected_games(x, y):\n        if x == N:\n            return 0\n        if y == N:\n            return 0\n        return (1 + p * expected_games(x + 1, y) +\n                q * expected_games(x, y + 1) +\n                r * expected_games(x, y))\n    \n    prob_win = 1 - r\n    expected_ratio = (N * (2 - prob_win) - 1) / (prob_win - 1)\n    \n    P, Q = expected_ratio.as_integer_ratio()\n\n    # Finding the multiplicative inverse of Q under modulus\n    Q_inv = mod_inverse(Q, MOD)\n    R = (P * Q_inv) % MOD\n    return R\n\n# Example usage:\nN = 3\nA = 50\nB = 30\nC = 20\nprint(expected_games_to_win(N, A, B, C))",
    "timestamp": "2025-08-13 12:42:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GameSimulation {\n    private static final int MOD = (int) (1e9 + 7);\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n        scanner.close();\n\n        long totalProb = A + B + C;\n        long winProb = A + B;\n        long loseProb = B;\n\n        long[] dpTakahashi = new long[N + 1];\n        long[] dpAoki = new long[N + 1];\n        long[] sum = new long[2 * N + 1];\n\n        dpTakahashi[0] = 1;\n        sum[0] = 1;\n\n        for (int g = 1; g <= 2 * N; g++) {\n            for (int tWins = Math.min(g, N); tWins >= 0; tWins--) {\n                int aWins = g - tWins;\n                if (aWins > N) continue;\n\n                if (tWins > 0) {\n                    dpTakahashi[tWins] = (dpTakahashi[tWins] + dpTakahashi[tWins - 1] * A) % MOD;\n                }\n                if (aWins > 0) {\n                    dpTakahashi[tWins] = (dpTakahashi[tWins] + dpAoki[tWins] * C) % MOD;\n                }\n                dpAoki[tWins] = (sum[g - 1] - (tWins == 0 ? 0 : sum[g - 1 - tWins])) * B % MOD * modInverse(totalProb) % MOD;\n            }\n            sum[g] = (sum[g - 1] + dpTakahashi[Math.min(g, N)]) % MOD;\n        }\n\n        long expectedGames = dpTakahashi[N] * modInverse(winProb) % MOD;\n        expectedGames = expectedGames * totalProb % MOD;\n\n        System.out.println(expectedGames);\n    }\n\n    private static long modInverse(long a) {\n        return modPow(a, MOD - 2, MOD);\n    }\n\n    private static long modPow(long base, long exp, long mod) {\n        long result = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = result * base % mod;\n            }\n            base = base * base % mod;\n            exp >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 12:42:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nlong long modInverse(long long a, long long m) {\n    long long m0 = m, t, q;\n    long long x0 = 0, x1 = 1;\n    if (m == 1) return 0;\n    while (a > 1) {\n        q = a / m;\n        t = m; \n        m = a % m, a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0) x1 += m0; \n    return x1;\n}\n\nlong long gcd(long long a, long long b) {\n    while (b) {\n        long long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nint main() {\n    int N;\n    int A, B, C;\n    scanf(\"%d %d %d %d\", &N, &A, &B, &C);\n\n    double p_takahashi = A / 100.0;\n    double p_aoki = B / 100.0;\n    double p_draw = C / 100.0;\n\n    double p_win = p_takahashi + p_aoki;\n    double expected_games = N / (p_win);\n    \n    long long P = (long long) (expected_games * 1000000); \n    long long Q = 1000000;\n    \n    long long common_gcd = gcd(P, Q);\n    P /= common_gcd;\n    Q /= common_gcd;\n\n    long long R = (P * modInverse(Q, MOD)) % MOD;\n    printf(\"%lld\\n\", R);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:42:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function modInverse(a, m) {\n    let m0 = m, t, q;\n    let x0 = 0, x1 = 1;\n\n    if (m === 1) return 0;\n\n    while (a > 1) {\n        q = Math.floor(a / m);\n        t = m;\n        m = a % m;\n        a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\nfunction calculateR(N, A, B, C) {\n    const MOD = 1000000007;\n\n    let a = A / 100;\n    let b = B / 100;\n    let c = C / 100;\n\n    if (a + b + c !== 1) {\n        throw new Error(\"Probabilities should sum to 1.\");\n    }\n\n    let p1 = a * Math.pow(c, N - 1);\n    let p2 = b * Math.pow(c, N - 1);\n    let E = (N - p1 - p2) / (a + b);\n\n    let P = Math.round(E * 1000000); // Using large number to avoid floating precision issue\n    let Q = 1000000;\n\n    let G = gcd(P, Q);\n    P /= G;\n    Q /= G;\n\n    let modInvQ = modInverse(Q, MOD);\n    let R = (P * modInvQ) % MOD;\n\n    return R;\n}\n\nfunction gcd(a, b) {\n    while (b !== 0) {\n        [a, b] = [b, a % b];\n    }\n    return a;\n}\n\n// Call function with arguments N, A, B, C, for example:\n// console.log(calculateR(5, 40, 40, 20));",
    "timestamp": "2025-08-13 12:42:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(N, A, B, C):\n    MOD = 10**9 + 7\n    total_prob = A + B + C\n    \n    # Probability of game not ending\n    draw_prob = C / total_prob\n    takahashi_prob = A / total_prob\n    aoki_prob = B / total_prob\n    \n    # Expected number of games using geometric series\n    if draw_prob == 1:\n        return 0\n    \n    expected_games = 1\n    p = takahashi_prob + aoki_prob\n    expected_games = N / p\n    \n    # Find coprime representation\n    numerator = int(expected_games * N)\n    denominator = 1\n    \n    # Simplify fraction\n    g = gcd(numerator, denominator)\n    P = numerator // g\n    Q = denominator // g\n    \n    # Calculate modular multiplicative inverse\n    def mod_inverse(x, m):\n        def egcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                g, y, x = egcd(b % a, a)\n                return (g, x - (b // a) * y, y)\n        \n        g, x, _ = egcd(x, m)\n        if g != 1:\n            raise Exception('Modular inverse does not exist')\n        else:\n            return x % m\n    \n    R = (P * mod_inverse(Q, MOD)) % MOD\n    return R\n\n# Read input\nN, A, B, C = map(int, input().split())\n\n# Print result\nprint(solve(N, A, B, C))",
    "timestamp": "2025-08-13 12:43:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A, B, C) {\n    const MOD = 1e9 + 7;\n    const a = A / 100;\n    const b = B / 100;\n    const c = C / 100;\n    \n    let dp = new Array(N + 1).fill(0).map(() => new Array(N + 1).fill(0));\n    dp[0][0] = 1;\n    \n    for (let i = 0; i <= N; i++) {\n        for (let j = 0; j <= N; j++) {\n            if (i === N || j === N) continue;\n            \n            dp[i + 1][j] += dp[i][j] * a;\n            dp[i][j + 1] += dp[i][j] * b;\n            dp[i][j] = dp[i][j] * c;\n        }\n    }\n    \n    let expected = 0;\n    for (let total = 2 * N - 1; total >= 0; total--) {\n        for (let i = Math.max(0, total - N + 1); i <= Math.min(total, N); i++) {\n            let j = total - i;\n            if (j > N) continue;\n            expected += (i < N && j < N) ? dp[i][j] * (total + 1) : 0;\n        }\n    }\n    \n    let gcd = (a, b) => b === 0 ? a : gcd(b, a % b);\n    \n    let P = Math.round(expected * 1e6);\n    let Q = Math.round(1e6);\n    let g = gcd(P, Q);\n    P /= g;\n    Q /= g;\n    \n    return P * modInverse(Q, MOD) % MOD;\n}\n\nfunction modInverse(a, m) {\n    let [x, y] = extendedGCD(a, m);\n    return ((x % m) + m) % m;\n}\n\nfunction extendedGCD(a, b) {\n    if (b === 0) return [1, 0];\n    let [x, y] = extendedGCD(b, a % b);\n    return [y, x - Math.floor(a / b) * y];\n}",
    "timestamp": "2025-08-13 12:43:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef modinv(x, mod):\n    return pow(x, mod-2, mod)\n\ndef solve():\n    N, A, B, C = map(int, sys.stdin.readline().split())\n    inv100 = modinv(100, MOD)\n    a = A * inv100 % MOD\n    b = B * inv100 % MOD\n    c = C * inv100 % MOD\n    inv_ab = modinv((a + b) % MOD, MOD)\n    a = a * inv_ab % MOD\n    b = b * inv_ab % MOD\n    \n    # Precompute powers of (a + b) up to 2N\n    max_pow = 2 * N\n    pow_ab = [1] * (max_pow + 1)\n    for i in range(1, max_pow + 1):\n        pow_ab[i] = pow_ab[i-1] * (a + b) % MOD\n    \n    # Precompute factorial and inverse factorial up to 2N\n    fact = [1] * (max_pow + 1)\n    inv_fact = [1] * (max_pow + 1)\n    for i in range(1, max_pow + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_pow] = modinv(fact[max_pow], MOD)\n    for i in range(max_pow - 1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    def comb(n, k):\n        if n < 0 or k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    inv_1_minus_c = modinv((1 - c) % MOD, MOD)\n    \n    res = 0\n    for k in range(N, 2 * N):\n        term = comb(k - 1, N - 1) * (pow(a, N, MOD) * pow(b, k - N, MOD) + pow(a, k - N, MOD) * pow(b, N, MOD)) % MOD\n        term = term * k % MOD\n        res = (res + term) % MOD\n    \n    res = res * modinv((1 - c) % MOD, MOD) % MOD\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 12:43:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction modInverse(a, mod) {\n    let m = mod;\n    let y = 0, x = 1;\n    if (mod === 1) return 0;\n    while (a > 1) {\n        let q = Math.floor(a / mod);\n        let t = mod;\n        mod = a % mod;\n        a = t;\n        t = y;\n        y = x - q * y;\n        x = t;\n    }\n    if (x < 0) x += m;\n    return x;\n}\n\nfunction solve() {\n    const [N, A, B, C] = readLine().split(' ').map(Number);\n    const inv100 = modInverse(100, MOD);\n    const a = A * inv100 % MOD;\n    const b = B * inv100 % MOD;\n    const c = C * inv100 % MOD;\n    const invAB = modInverse((a + b) % MOD, MOD);\n    const s = (a + b) % MOD;\n    const invS = modInverse(s, MOD);\n    \n    let res = 0;\n    const comb = Array(2 * N).fill(0).map(() => Array(2 * N).fill(0));\n    comb[0][0] = 1;\n    for (let i = 1; i < 2 * N; i++) {\n        comb[i][0] = 1;\n        for (let j = 1; j <= i; j++) {\n            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n        }\n    }\n    \n    let powA = Array(2 * N).fill(1);\n    let powB = Array(2 * N).fill(1);\n    for (let i = 1; i < 2 * N; i++) {\n        powA[i] = powA[i-1] * a % MOD;\n        powB[i] = powB[i-1] * b % MOD;\n    }\n    \n    for (let k = 0; k < N; k++) {\n        let m = N + k;\n        let term = comb[m - 1][k] * powA[N] % MOD;\n        term = term * powB[k] % MOD;\n        term = term * m % MOD;\n        res = (res + term) % MOD;\n        \n        term = comb[m - 1][k] * powB[N] % MOD;\n        term = term * powA[k] % MOD;\n        term = term * m % MOD;\n        res = (res + term) % MOD;\n    }\n    \n    const inv1MinusC = modInverse((1 - c + MOD) % MOD, MOD);\n    res = res * inv1MinusC % MOD * inv1MinusC % MOD;\n    \n    console.log(res);\n}\n\nfunction readLine() {\n    // Replace this with actual input reading logic in your environment\n    return require('fs').readFileSync(0, 'utf8').trim();\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:43:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\n// Function to calculate the modular inverse using Fermat's Little Theorem\nint modInverse(int a, int m) {\n    int result = 1, base = a, exponent = m - 2;\n    while (exponent) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % m;\n        }\n        base = (base * base) % m;\n        exponent /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int N;\n    double A, B, C;\n    cin >> N >> A >> B >> C;\n\n    // Convert probabilites from percentage to decimal\n    A /= 100;\n    B /= 100;\n    C /= 100;\n\n    vector<vector<double>> dp(N + 1, vector<double>(N + 1, 0.0));\n    dp[0][0] = 1.0 / (1 - C);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            double p = dp[i][j];\n            dp[i + 1][j] += p * A;\n            dp[i][j + 1] += p * B;\n            dp[i][j] += p * C;\n        }\n    }\n\n    double expectedGames = 0.0;\n    for (int i = 1; i <= N; ++i) {\n        expectedGames += dp[N][i] + dp[i][N];\n    }\n\n    // Convert expectedGames to fraction P/Q\n    long long P = static_cast<long long>(expectedGames * 1e9 + 0.5);\n    long long Q = 1e9;\n    \n    int gcdPQ = __gcd(P, Q);\n    P /= gcdPQ;\n    Q /= gcdPQ;\n    \n    int R = (P * modInverse(Q, MOD)) % MOD;\n    cout << R << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:36:02"
  }
]