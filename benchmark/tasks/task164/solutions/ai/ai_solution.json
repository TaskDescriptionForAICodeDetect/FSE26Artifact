[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int to;\n    int time;\n} Edge;\n\ntypedef struct {\n    int room;\n    int time;\n    int cold_time;\n} State;\n\nEdge **adj;\nint *adj_size;\nint *temp;\nint N, M, X;\nint **dist;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid dijkstra() {\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <= X; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n    dist[1][X] = 0;\n\n    State *heap = (State *)malloc((N * (X + 1) + 1) * sizeof(State));\n    int heap_size = 0;\n\n    heap[heap_size++] = (State){1, 0, X};\n\n    while (heap_size > 0) {\n        State current = heap[0];\n        heap[0] = heap[--heap_size];\n        int i = 0;\n        while (1) {\n            int left = 2 * i + 1;\n            int right = 2 * i + 2;\n            int smallest = i;\n            if (left < heap_size && (heap[left].time < heap[smallest].time || \n                (heap[left].time == heap[smallest].time && heap[left].cold_time > heap[smallest].cold_time))) {\n                smallest = left;\n            }\n            if (right < heap_size && (heap[right].time < heap[smallest].time || \n                (heap[right].time == heap[smallest].time && heap[right].cold_time > heap[smallest].cold_time))) {\n                smallest = right;\n            }\n            if (smallest == i) break;\n            State temp = heap[i];\n            heap[i] = heap[smallest];\n            heap[smallest] = temp;\n            i = smallest;\n        }\n\n        int u = current.room;\n        int current_time = current.time;\n        int cold_time = current.cold_time;\n\n        if (current_time > dist[u][cold_time]) continue;\n\n        for (int i = 0; i < adj_size[u]; i++) {\n            Edge e = adj[u][i];\n            int v = e.to;\n            int new_time = current_time + e.time;\n            int new_cold_time = cold_time;\n\n            if (temp[u] == 1) { // too cold\n                new_cold_time = X;\n            } else if (temp[u] == 3) { // too hot\n                if (cold_time > 0) continue;\n            }\n\n            if (new_cold_time > 0) {\n                new_cold_time--;\n            }\n\n            if (new_time < dist[v][new_cold_time]) {\n                dist[v][new_cold_time] = new_time;\n                heap[heap_size++] = (State){v, new_time, new_cold_time};\n                int j = heap_size - 1;\n                while (j > 0) {\n                    int parent = (j - 1) / 2;\n                    if (heap[parent].time < heap[j].time || \n                        (heap[parent].time == heap[j].time && heap[parent].cold_time >= heap[j].cold_time)) break;\n                    State temp = heap[j];\n                    heap[j] = heap[parent];\n                    heap[parent] = temp;\n                    j = parent;\n                }\n            }\n        }\n    }\n    free(heap);\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &X);\n    temp = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &temp[i]);\n    }\n\n    adj = (Edge **)malloc((N + 1) * sizeof(Edge *));\n    adj_size = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        adj[i] = (Edge *)malloc(M * sizeof(Edge));\n        adj_size[i] = 0;\n    }\n\n    for (int i = 0; i < M; i++) {\n        int a, b, t;\n        scanf(\"%d %d %d\", &a, &b, &t);\n        adj[a][adj_size[a]++] = (Edge){b, t};\n        adj[b][adj_size[b]++] = (Edge){a, t};\n    }\n\n    dist = (int **)malloc((N + 1) * sizeof(int *));\n    for (int i = 1; i <= N; i++) {\n        dist[i] = (int *)malloc((X + 1) * sizeof(int));\n    }\n\n    dijkstra();\n\n    int result = INT_MAX;\n    for (int i = 0; i <= X; i++) {\n        result = min(result, dist[N][i]);\n    }\n\n    if (result == INT_MAX) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n\n    for (int i = 1; i <= N; i++) {\n        free(adj[i]);\n        free(dist[i]);\n    }\n    free(adj);\n    free(adj_size);\n    free(temp);\n    free(dist);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:52:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SnakeJOIEscape {\n    static class Room {\n        int temp;\n        List<Edge> corridors;\n        \n        Room() {\n            corridors = new ArrayList<>();\n        }\n    }\n    \n    static class Edge {\n        int dest;\n        int time;\n        \n        Edge(int dest, int time) {\n            this.dest = dest;\n            this.time = time;\n        }\n    }\n    \n    static class State {\n        int room;\n        int time;\n        int lastColdTime;\n        int lastHotTime;\n        \n        State(int room, int time, int lastColdTime, int lastHotTime) {\n            this.room = room;\n            this.time = time;\n            this.lastColdTime = lastColdTime;\n            this.lastHotTime = lastHotTime;\n        }\n    }\n    \n    public static int findMinEscapeTime(int N, int M, int X, Room[] rooms) {\n        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> a.time - b.time);\n        boolean[][][] visited = new boolean[N+1][2][2];\n        \n        pq.offer(new State(1, 0, 0, Integer.MAX_VALUE));\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.room == N) {\n                return curr.time;\n            }\n            \n            if (visited[curr.room][curr.lastColdTime == 0 ? 0 : 1][curr.lastHotTime == 0 ? 0 : 1]) {\n                continue;\n            }\n            \n            visited[curr.room][curr.lastColdTime == 0 ? 0 : 1][curr.lastHotTime == 0 ? 0 : 1] = true;\n            \n            for (Edge edge : rooms[curr.room].corridors) {\n                int nextRoom = edge.dest;\n                int nextTime = curr.time + edge.time;\n                \n                if (rooms[nextRoom].temp == 0 && \n                    (curr.lastHotTime != Integer.MAX_VALUE && nextTime - curr.lastHotTime < X)) {\n                    continue;\n                }\n                \n                if (rooms[nextRoom].temp == 2 && \n                    (curr.lastColdTime != Integer.MAX_VALUE && nextTime - curr.lastColdTime < X)) {\n                    continue;\n                }\n                \n                int nextLastColdTime = (rooms[nextRoom].temp == 0) ? nextTime : curr.lastColdTime;\n                int nextLastHotTime = (rooms[nextRoom].temp == 2) ? nextTime : curr.lastHotTime;\n                \n                pq.offer(new State(nextRoom, nextTime, nextLastColdTime, nextLastHotTime));\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int X = scanner.nextInt();\n        \n        Room[] rooms = new Room[N+1];\n        for (int i = 1; i <= N; i++) {\n            rooms[i] = new Room();\n            rooms[i].temp = scanner.nextInt();\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int t = scanner.nextInt();\n            \n            rooms[a].corridors.add(new Edge(b, t));\n            rooms[b].corridors.add(new Edge(a, t));\n        }\n        \n        int result = findMinEscapeTime(N, M, X, rooms);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:53:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int time;\n};\n\nstruct State {\n    int room;\n    int time;\n    int last_temp; // 0: cold, 1: comfortable, 2: hot\n    bool operator>(const State& other) const {\n        return time > other.time;\n    }\n};\n\nint main() {\n    int N, M, X;\n    cin >> N >> M >> X;\n    vector<int> temp(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> temp[i];\n    }\n    vector<vector<Edge>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int a, b, t;\n        cin >> a >> b >> t;\n        adj[a].push_back({b, t});\n        adj[b].push_back({a, t});\n    }\n\n    priority_queue<State, vector<State>, greater<State>> pq;\n    vector<vector<int>> dist(N + 1, vector<int>(3, INT_MAX));\n    dist[1][0] = 0;\n    pq.push({1, 0, 0});\n\n    int answer = -1;\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        if (current.room == N) {\n            answer = current.time;\n            break;\n        }\n        if (current.time > dist[current.room][current.last_temp]) {\n            continue;\n        }\n        for (const Edge& edge : adj[current.room]) {\n            int next_room = edge.to;\n            int next_time = current.time + edge.time;\n            int next_temp = temp[next_room];\n            bool invalid = false;\n            if ((current.last_temp == 0 && next_temp == 2 && next_time < X) ||\n                (current.last_temp == 2 && next_temp == 0 && next_time < X)) {\n                invalid = true;\n            }\n            if (!invalid && next_time < dist[next_room][next_temp]) {\n                dist[next_room][next_temp] = next_time;\n                pq.push({next_room, next_time, next_temp});\n            }\n        }\n    }\n    cout << answer << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:53:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_ROOMS 1001\n#define MAX_CORRIDORS 5001\n\ntypedef struct {\n    int dest;\n    int time;\n} Corridor;\n\ntypedef struct {\n    int room;\n    int time;\n    int temp_state;\n} QueueNode;\n\nCorridor graph[MAX_ROOMS][MAX_CORRIDORS];\nint corridor_count[MAX_ROOMS];\nint room_temp[MAX_ROOMS];\nint N, M, X;\n\nint dijkstra() {\n    bool visited[MAX_ROOMS][3] = {false};\n    int dist[MAX_ROOMS][3];\n    \n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j < 3; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n    \n    dist[1][0] = 0;\n    \n    QueueNode queue[MAX_ROOMS * 3];\n    int front = 0, rear = 0;\n    \n    queue[rear++] = (QueueNode){1, 0, 0};\n    \n    while (front < rear) {\n        QueueNode current = queue[front++];\n        \n        if (visited[current.room][current.temp_state]) continue;\n        visited[current.room][current.temp_state] = true;\n        \n        if (current.room == N) return current.time;\n        \n        for (int i = 0; i < corridor_count[current.room]; i++) {\n            Corridor next_corridor = graph[current.room][i];\n            int next_room = next_corridor.dest;\n            int travel_time = next_corridor.time;\n            int next_temp_state = room_temp[next_room];\n            \n            if (current.temp_state == 1 && next_temp_state == 2 && current.time + travel_time < X) continue;\n            if (current.temp_state == 2 && next_temp_state == 1 && current.time + travel_time < X) continue;\n            \n            int new_time = current.time + travel_time;\n            \n            if (new_time < dist[next_room][next_temp_state]) {\n                dist[next_room][next_temp_state] = new_time;\n                queue[rear++] = (QueueNode){next_room, new_time, next_temp_state};\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &X);\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &room_temp[i]);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int a, b, t;\n        scanf(\"%d %d %d\", &a, &b, &t);\n        \n        graph[a][corridor_count[a]].dest = b;\n        graph[a][corridor_count[a]].time = t;\n        corridor_count[a]++;\n        \n        graph[b][corridor_count[b]].dest = a;\n        graph[b][corridor_count[b]].time = t;\n        corridor_count[b]++;\n    }\n    \n    int result = dijkstra();\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:53:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int room;\n    int time;\n    int lastColdTime;\n    int lastHotTime;\n};\n\nint solve(int N, int M, int X, vector<vector<pair<int, int>>>& graph, vector<int>& temperatures) {\n    vector<vector<int>> minTime(N + 1, vector<int>(8, INT_MAX));\n    queue<State> q;\n    \n    q.push({1, 0, -X, -X});\n    minTime[1][0] = 0;\n    \n    while (!q.empty()) {\n        State curr = q.front();\n        q.pop();\n        \n        if (curr.room == N) return curr.time;\n        \n        for (auto& [nextRoom, travelTime] : graph[curr.room]) {\n            int newTime = curr.time + travelTime;\n            int newState = 0;\n            \n            if (temperatures[nextRoom] == 0) newState |= 1;\n            if (temperatures[nextRoom] == 2) newState |= 2;\n            \n            if (temperatures[curr.room] == 0 && temperatures[nextRoom] == 2 && newTime < curr.lastColdTime + X) continue;\n            if (temperatures[curr.room] == 2 && temperatures[nextRoom] == 0 && newTime < curr.lastHotTime + X) continue;\n            \n            int lastColdTime = (temperatures[nextRoom] == 0) ? newTime : curr.lastColdTime;\n            int lastHotTime = (temperatures[nextRoom] == 2) ? newTime : curr.lastHotTime;\n            \n            if (newTime < minTime[nextRoom][newState]) {\n                minTime[nextRoom][newState] = newTime;\n                q.push({nextRoom, newTime, lastColdTime, lastHotTime});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int N, M, X;\n    cin >> N >> M >> X;\n    \n    vector<int> temperatures(N + 1);\n    for (int i = 1; i <= N; i++) cin >> temperatures[i];\n    \n    vector<vector<pair<int, int>>> graph(N + 1);\n    for (int i = 0; i < M; i++) {\n        int a, b, t;\n        cin >> a >> b >> t;\n        graph[a].push_back({b, t});\n        graph[b].push_back({a, t});\n    }\n    \n    int result = solve(N, M, X, graph, temperatures);\n    cout << (result == -1 ? -1 : result) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:53:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Edge {\n        int to, time;\n        Edge(int to, int time) {\n            this.to = to;\n            this.time = to;\n        }\n    }\n\n    static class State implements Comparable<State> {\n        int room;\n        long time;\n        int lastTemp; // 0: cold, 1: comfortable, 2: hot\n        State(int room, long time, int lastTemp) {\n            this.room = room;\n            this.time = time;\n            this.lastTemp = lastTemp;\n        }\n        @Override\n        public int compareTo(State other) {\n            return Long.compare(this.time, other.time);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split(\" \");\n        int N = Integer.parseInt(line[0]);\n        int M = Integer.parseInt(line[1]);\n        int X = Integer.parseInt(line[2]);\n\n        int[] temp = new int[N + 1];\n        line = br.readLine().split(\" \");\n        for (int i = 1; i <= N; i++) {\n            temp[i] = Integer.parseInt(line[i - 1]);\n        }\n\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            line = br.readLine().split(\" \");\n            int a = Integer.parseInt(line[0]);\n            int b = Integer.parseInt(line[1]);\n            int t = Integer.parseInt(line[2]);\n            adj.get(a).add(new Edge(b, t));\n            adj.get(b).add(new Edge(a, t));\n        }\n\n        long[][][] dist = new long[N + 1][3][2];\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j < 3; j++) {\n                Arrays.fill(dist[i][j], Long.MAX_VALUE);\n            }\n        }\n\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        dist[1][0][0] = 0;\n        pq.add(new State(1, 0, 0));\n\n        long res = Long.MAX_VALUE;\n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            int u = curr.room;\n            long time = curr.time;\n            int lastTemp = curr.lastTemp;\n\n            if (u == N) {\n                res = Math.min(res, time);\n                continue;\n            }\n\n            if (time > dist[u][lastTemp][temp[u] == 0 ? 0 : (temp[u] == 2 ? 1 : 0)]) {\n                continue;\n            }\n\n            for (Edge e : adj.get(u)) {\n                int v = e.to;\n                int newTemp = temp[v];\n                long newTime = time + e.time;\n                int newLastTemp = lastTemp;\n\n                if (newTemp == 0) {\n                    if (lastTemp == 2 && newTime < X) {\n                        continue;\n                    }\n                    newLastTemp = 0;\n                } else if (newTemp == 2) {\n                    if (lastTemp == 0 && newTime < X) {\n                        continue;\n                    }\n                    newLastTemp = 2;\n                } else {\n                    newLastTemp = lastTemp;\n                }\n\n                int tempKey = newLastTemp;\n                if (newTime < dist[v][tempKey][newTemp == 0 ? 0 : (newTemp == 2 ? 1 : 0)]) {\n                    dist[v][tempKey][newTemp == 0 ? 0 : (newTemp == 2 ? 1 : 0)] = newTime;\n                    pq.add(new State(v, newTime, tempKey));\n                }\n            }\n        }\n\n        System.out.println(res == Long.MAX_VALUE ? -1 : res);\n    }\n}",
    "timestamp": "2025-08-05 18:54:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef escape_time(N, M, corridors, room_temperatures, X):\n    graph = [[] for _ in range(N+1)]\n    \n    for u, v, t in corridors:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n    \n    # Dijkstra's algorithm\n    pq = [(0, 1)]  # (current_time, current_room)\n    min_time = [float('inf')] * (N + 1)\n    min_time[1] = 0\n    \n    while pq:\n        current_time, current_room = heapq.heappop(pq)\n        \n        if current_room == N:\n            return current_time\n        \n        if current_time > min_time[current_room]:\n            continue\n        \n        for neighbor, travel_time in graph[current_room]:\n            new_time = current_time + travel_time\n            \n            if room_temperatures[current_room] != room_temperatures[neighbor]:\n                # Check if temperatures are too hot and too cold:\n                if (room_temperatures[current_room] == \"hot\" and room_temperatures[neighbor] == \"cold\") or (room_temperatures[current_room] == \"cold\" and room_temperatures[neighbor] == \"hot\"):\n                    new_time += X\n            \n            if new_time < min_time[neighbor]:\n                min_time[neighbor] = new_time\n                heapq.heappush(pq, (new_time, neighbor))\n    \n    return -1\n\n# Example usage:\nN = 5\nM = 6\ncorridors = [\n    (1, 2, 3),\n    (1, 3, 1),\n    (2, 3, 1),\n    (2, 4, 4),\n    (3, 5, 5),\n    (4, 5, 1)\n]\nroom_temperatures = {\n    1: \"cold\",\n    2: \"comfortable\",\n    3: \"comfortable\",\n    4: \"hot\",\n    5: \"comfortable\"\n}\nX = 5\n\nprint(escape_time(N, M, corridors, room_temperatures, X))",
    "timestamp": "2025-08-13 01:21:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SnakeEscape {\n\n    static class Corridor {\n        int to, time;\n        public Corridor(int to, int time) {\n            this.to = to;\n            this.time = time;\n        }\n    }\n\n    static class State {\n        int room, time, lastRoomType;\n        public State(int room, int time, int lastRoomType) {\n            this.room = room;\n            this.time = time;\n            this.lastRoomType = lastRoomType;\n        }\n    }\n\n    public static int snakeEscape(int N, int M, int[] roomTypes, int X, int[][] corridors) {\n        List<List<Corridor>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) graph.add(new ArrayList<>());\n        \n        for (int[] corridor : corridors) {\n            int u = corridor[0], v = corridor[1], time = corridor[2];\n            graph.get(u).add(new Corridor(v, time));\n            graph.get(v).add(new Corridor(u, time));\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingInt(s -> s.time));\n        int[][] minTime = new int[N + 1][3];\n        for (int[] row : minTime) Arrays.fill(row, Integer.MAX_VALUE);\n        minTime[1][0] = 0; // Starting room is too cold\n        \n        pq.offer(new State(1, 0, 0));\n        \n        while (!pq.isEmpty()) {\n            State state = pq.poll();\n            int room = state.room;\n            int currentTime = state.time;\n            int lastRoomType = state.lastRoomType;\n            \n            if (room == N) return currentTime;\n            if (currentTime > minTime[room][lastRoomType]) continue;\n\n            for (Corridor corridor : graph.get(room)) {\n                int nextRoom = corridor.to;\n                int nextTime = currentTime + corridor.time;\n                int nextRoomType = roomTypes[nextRoom - 1];\n\n                if ((lastRoomType == 0 && nextRoomType == 2 && nextTime < X) || \n                    (lastRoomType == 2 && nextRoomType == 0 && nextTime < X)) {\n                    continue;\n                }\n\n                if (nextTime < minTime[nextRoom][nextRoomType]) {\n                    minTime[nextRoom][nextRoomType] = nextTime;\n                    pq.offer(new State(nextRoom, nextTime, nextRoomType));\n                }\n            }\n        }\n        \n        return -1; // Cannot reach room N\n    }\n}",
    "timestamp": "2025-08-13 01:22:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int to;\n    int time;\n} Corridor;\n\ntypedef struct {\n    int temp;\n    int corridorCount;\n    Corridor *corridors;\n} Room;\n\ntypedef struct {\n    int room;\n    int time;\n    int lastTemp;\n} State;\n\ntypedef struct {\n    State data[10000];\n    int front;\n    int rear;\n} Queue;\n\nvoid enqueue(Queue *queue, int room, int time, int lastTemp) {\n    queue->data[queue->rear].room = room;\n    queue->data[queue->rear].time = time;\n    queue->data[queue->rear].lastTemp = lastTemp;\n    queue->rear = (queue->rear + 1) % 10000;\n}\n\nState dequeue(Queue *queue) {\n    State state = queue->data[queue->front];\n    queue->front = (queue->front + 1) % 10000;\n    return state;\n}\n\nbool isQueueEmpty(Queue *queue) {\n    return queue->front == queue->rear;\n}\n\nint minEscapeTime(int N, int M, int X, Room rooms[]) {\n    int minTime[N + 1];\n    for (int i = 1; i <= N; ++i)\n        minTime[i] = INT_MAX;\n    \n    minTime[1] = 0;\n\n    Queue queue = { .front = 0, .rear = 0 };\n    enqueue(&queue, 1, 0, rooms[1].temp);\n\n    while (!isQueueEmpty(&queue)) {\n        State current = dequeue(&queue);\n        int currentRoom = current.room;\n        int currentTime = current.time;\n        int lastTemp = current.lastTemp;\n\n        if (currentRoom == N) return currentTime;\n\n        for (int i = 0; i < rooms[currentRoom].corridorCount; ++i) {\n            int nextRoom = rooms[currentRoom].corridors[i].to;\n            int travelTime = rooms[currentRoom].corridors[i].time;\n            int nextTemp = rooms[nextRoom].temp;\n            int nextTime = currentTime + travelTime;\n\n            if (lastTemp != nextTemp || nextTime >= X) {\n                if (nextTime < minTime[nextRoom]) {\n                    minTime[nextRoom] = nextTime;\n                    enqueue(&queue, nextRoom, nextTime, nextTemp);\n                }\n            }\n        }\n    }\n\n    return -1; // Should not reach here if there's a valid path\n}\n\nint main() {\n    int N, M, X;\n    scanf(\"%d %d %d\", &N, &M, &X);\n\n    Room rooms[N + 1];\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%d\", &rooms[i].temp);\n        rooms[i].corridorCount = 0;\n        rooms[i].corridors = malloc(M * sizeof(Corridor));\n    }\n\n    for (int i = 0; i < M; ++i) {\n        int u, v, t;\n        scanf(\"%d %d %d\", &u, &v, &t);\n        rooms[u].corridors[rooms[u].corridorCount++] = (Corridor){ v, t };\n        rooms[v].corridors[rooms[v].corridorCount++] = (Corridor){ u, t };\n    }\n\n    int result = minEscapeTime(N, M, X, rooms);\n    \n    printf(\"%d\\n\", result);\n\n    for (int i = 1; i <= N; ++i) {\n        free(rooms[i].corridors);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:22:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\nfrom math import inf\n\ndef solve_mansion_escape(N, M, corridors, room_temps, X):\n    graph = [[] for _ in range(N+1)]\n    for a, b, t in corridors:\n        graph[a].append((b, t))\n        graph[b].append((a, t))\n\n    # State: (time, room, last_cold_time, last_hot_time)\n    pq = [(0, 1, 0, inf)]\n    visited = set()\n\n    while pq:\n        time, room, last_cold_time, last_hot_time = heappop(pq)\n\n        if room == N:\n            return time\n\n        state = (room, last_cold_time, last_hot_time)\n        if state in visited:\n            continue\n        visited.add(state)\n\n        for next_room, travel_time in graph[room]:\n            next_time = time + travel_time\n            next_cold_time = last_cold_time\n            next_hot_time = last_hot_time\n\n            if room_temps[room] == 'cold':\n                next_cold_time = time\n            elif room_temps[room] == 'hot':\n                next_hot_time = time\n\n            if room_temps[next_room] == 'hot' and last_cold_time + X > next_time:\n                continue\n            if room_temps[next_room] == 'cold' and last_hot_time + X > next_time:\n                continue\n\n            heappush(pq, (next_time, next_room, next_cold_time, next_hot_time))\n\n    return -1\n\n# Example usage\nN, M, X = map(int, input().split())\ncorridors = [list(map(int, input().split())) for _ in range(M)]\nroom_temps = [''] + list(input().split())\n\nresult = solve_mansion_escape(N, M, corridors, room_temps, X)\nprint(result)",
    "timestamp": "2025-08-13 01:22:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    X = int(data[idx])\n    idx += 1\n    \n    temp = [0] * (N + 1)\n    for i in range(1, N + 1):\n        t = int(data[idx])\n        idx += 1\n        temp[i] = t  # 1: cold, 2: comfortable, 3: hot\n    \n    adj = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n    \n    INF = float('inf')\n    # dist[node][state] where state is 0: normal, 1: just left cold, 2: just left hot\n    dist = [[INF] * 3 for _ in range(N + 1)]\n    dist[1][0] = 0\n    heap = []\n    heapq.heappush(heap, (0, 1, 0))\n    \n    while heap:\n        current_time, u, state = heapq.heappop(heap)\n        if u == N:\n            print(current_time)\n            return\n        if current_time > dist[u][state]:\n            continue\n        for (v, cost) in adj[u]:\n            new_time = current_time + cost\n            new_state = 0\n            if temp[u] == 1 and temp[v] == 3:\n                continue\n            if temp[u] == 3 and temp[v] == 1:\n                continue\n            if state == 1 and temp[v] == 3:\n                if new_time < X:\n                    continue\n                else:\n                    new_state = 0\n            elif state == 2 and temp[v] == 1:\n                if new_time < X:\n                    continue\n                else:\n                    new_state = 0\n            else:\n                if temp[v] == 1:\n                    new_state = 1\n                elif temp[v] == 3:\n                    new_state = 2\n                else:\n                    new_state = 0\n            if new_time < dist[v][new_state]:\n                dist[v][new_state] = new_time\n                heapq.heappush(heap, (new_time, v, new_state))\n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 01:22:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits.h>\n\nusing namespace std;\n\nstruct Edge {\n    int to, time;\n};\n\nstruct State {\n    int room, time, temp;\n    bool operator>(const State& other) const {\n        return time > other.time;\n    }\n};\n\nint main() {\n    int N, M, X;\n    cin >> N >> M >> X;\n    \n    vector<vector<Edge>> adj(N + 1);\n    vector<int> temperature(N + 1);\n    \n    for (int i = 1; i <= N; ++i) {\n        cin >> temperature[i];  // 0=too cold, 1=comfortable, 2=too hot\n    }\n    \n    for (int i = 0; i < M; ++i) {\n        int u, v, t;\n        cin >> u >> v >> t;\n        adj[u].push_back({v, t});\n        adj[v].push_back({u, t});\n    }\n    \n    priority_queue<State, vector<State>, greater<State>> pq;\n    vector<vector<int>> dist(N + 1, vector<int>(3, INT_MAX));\n    \n    pq.push({1, 0, 0});\n    dist[1][0] = 0;\n    \n    while (!pq.empty()) {\n        State cur = pq.top();\n        pq.pop();\n        \n        if (cur.room == N) {\n            cout << cur.time << endl;\n            return 0;\n        }\n        \n        if (cur.time > dist[cur.room][cur.temp]) continue;\n        \n        for (const Edge& edge : adj[cur.room]) {\n            int next_temp = temperature[edge.to];\n            int time_to_next = cur.time + edge.time;\n            \n            if ((cur.temp == 0 && next_temp == 2 && time_to_next <= X) ||\n                (cur.temp == 2 && next_temp == 0 && time_to_next <= X)) {\n                continue;\n            }\n            \n            if (time_to_next < dist[edge.to][next_temp]) {\n                dist[edge.to][next_temp] = time_to_next;\n                pq.push({edge.to, time_to_next, next_temp});\n            }\n        }\n    }\n    \n    cout << -1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:59:50"
  }
]