[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n)cin>>t[i];\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        if (d[v][type][tim] < dist) continue;\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 1) {\n                u = e.to, ntype = type, ntim = min(x, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = type, ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n\n    int ans = inf;\n\n    rep(i, 2) rep(j, 205) ans = min(ans, d[n-1][i][j]);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{ int to,cost; };\nstruct state{\n  int cost,pos,last;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n \nint N,M,X;\nvector<edge> G[10000];\nint t[10000];\n \nint D[10000][401];\nint* d[10000];\n \nint main(){\n  scanf(\"%d %d %d\",&N,&M,&X);\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&t[i]);\n  }\n  for(int i=0;i<M;i++){\n    int a,b,c;\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--,b--;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n \n  fill(D[0],D[10000],1e9);\n  for(int i=0;i<N;i++){\n    d[i]=&D[i][200];\n  }\n   \n \n  priority_queue< state > Q;\n   \n  d[0][-X]=0;\n  Q.push( (state){0,0,-X} );\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n     \n    if(s.pos==N-1){\n      printf(\"%d\\n\",s.cost);\n      break;\n    }\n     \n    if(s.cost > d[s.pos][s.last])continue;\n     \n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      state next=s;\n      next.pos=e.to;\n      next.cost+=e.cost;\n      if(next.last<0)next.last=min(0,next.last+e.cost);\n      if(next.last>0)next.last=max(0,next.last-e.cost);\n \n      if(next.last>0&&t[e.to]==0)continue;\n      if(next.last<0&&t[e.to]==2)continue;\n \n      if(t[e.to]==0)next.last=-X;\n      if(t[e.to]==2)next.last=X;\n \n      if( d[next.pos][next.last] > next.cost ){\n        d[next.pos][next.last]=next.cost;\n        Q.push( next );\n      }\n    }\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1<<25;//1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nstruct state {\n  int v, cost, rt, te;\n  state(){}\n  state(int v, int cost, int rt, int te):v(v), cost(cost), rt(rt), te(te){}\n  bool operator < (const state& r) const {\n    return cost > r.cost;\n  }\n};\n\nint N, M, X;\nint T[10010];\n\nvector<edge> G[10010];\nint mincost[2][202][10010];\n\nint dijkstra()\n{\n  rep(i, 2) rep(j, 202) rep(k, 10010) mincost[i][j][k] = inf;\n  priority_queue<state> que;\n  que.emplace(0, 0, 0, 0);\n  mincost[0][0][0] = 0;\n  while(!que.empty()) {\n    state s = que.top(); que.pop();\n    if(s.v == N-1) return s.cost;\n    if(s.cost > mincost[s.rt/2][s.te][s.v]) continue;\n    for(edge& e : G[s.v]) {\n      if(abs(s.rt - T[e.to]) == 2 && s.te + e.cost < X) continue;\n      int nrt = s.rt, nte = max(s.te + e.cost, X);\n      if(T[e.to] != 1) nrt = T[e.to], nte = 0;\n      if(s.cost + e.cost < mincost[nrt/2][nte][e.to]) {\n\tmincost[nrt/2][nte][e.to] = s.cost + e.cost;\n\tque.emplace(e.to, s.cost + e.cost, nrt, nte);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> X;\n  rep(i, N) cin >> T[i];\n  rep(i, M) {\n    int A, B, D;\n    cin >> A >> B >> D; A--, B--;\n    G[A].emplace_back(B, D);\n    G[B].emplace_back(A, D);\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n\nusing namespace std;\ntypedef pair<int, pair<int, pair<int, int>>> P;\n\nstruct Edge {\n\tint to, cost;\n\tEdge() = default;\n\tEdge(int t, int c) {\n\t\tto = t, cost = c;\n\t}\n};\n\nint temp[10000];\n\nint N, M, X;\nvector<vector<Edge>> edge;\n\nint d[10000][3][200 + 1];\n\nint djk(int s, int e) {\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < 3; j++)for (int k = 0; k <= X; k++)d[i][j][k] = 100000007;\n\td[s][0][X] = 0;\n\tpriority_queue < P, vector<P>, greater<P>> pq;\n\tpq.push(P(0, make_pair(s, make_pair(0, X))));\n\twhile (pq.size()) {\n\t\tauto tmp = pq.top(); pq.pop();\n\t\tif (tmp.first > d[tmp.second.first][tmp.second.second.first][tmp.second.second.second])continue;\n\t\t//cout << tmp.first << \" \" << tmp.second.first << \" \" << tmp.second.second.first << \" \" << tmp.second.second.second << endl;\n\n\t\tfor (int i = 0; i < edge[tmp.second.first].size(); i++) {\n\t\t\tauto& tonext = edge[tmp.second.first][i];\n\n\t\t\t//cout << i << \"A\" << edge[tmp.second.first][i].to << \" \" << edge[tmp.second.first][i].cost << endl;\n\n\t\t\tif (tmp.second.second.first == 0) {\n\t\t\t\tif (temp[tonext.to] == 2) {\n\t\t\t\t\tif (tmp.second.second.second - tonext.cost <= 0) {\n\t\t\t\t\t\t//????????±\n\t\t\t\t\t\tif (d[tonext.to][2][X] > d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost) {\n\t\t\t\t\t\t\td[tonext.to][2][X] = d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost;\n\t\t\t\t\t\t\tpq.push(P(d[tonext.to][2][X], make_pair(tonext.to, make_pair(2, X))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (temp[tonext.to] == 0) {\n\t\t\t\t\t//?????????\n\t\t\t\t\tif (d[tonext.to][0][X] > d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost) {\n\t\t\t\t\t\td[tonext.to][0][X] = d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost;\n\t\t\t\t\t\tpq.push(P(d[tonext.to][0][X], make_pair(tonext.to, make_pair(0, X))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//????????????\n\t\t\t\t\tif (d[tonext.to][0][max(tmp.second.second.second - tonext.cost, 0)] > d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost) {\n\t\t\t\t\t\td[tonext.to][0][max(tmp.second.second.second - tonext.cost, 0)] = d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost;\n\t\t\t\t\t\tpq.push(P(d[tonext.to][0][max(tmp.second.second.second - tonext.cost, 0)],\n\t\t\t\t\t\t\tmake_pair(tonext.to, make_pair(0, max(tmp.second.second.second - tonext.cost, 0)))));\n\t\t\t\t\t}\n\t\t\t\t\t//cout << d[tonext.to][0][max(tmp.second.second.second - tonext.cost, 0)] << \" \" << tonext.to << \" 1 \" << max(tmp.second.second.second - tonext.cost, 0) << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tmp.second.second.first == 2) {\n\t\t\t\tif (temp[tonext.to] == 0) {\n\t\t\t\t\tif (tmp.second.second.second - tonext.cost <= 0) {\n\t\t\t\t\t\t//??±??????\n\t\t\t\t\t\tif (d[tonext.to][0][X] > d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost) {\n\t\t\t\t\t\t\td[tonext.to][0][X] = d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost;\n\t\t\t\t\t\t\tpq.push(P(d[tonext.to][0][X], make_pair(tonext.to, make_pair(0, X))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (temp[tonext.to] == 2) {\n\t\t\t\t\t//??±?????±\n\t\t\t\t\tif (d[tonext.to][2][X] > d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost) {\n\t\t\t\t\t\td[tonext.to][2][X] = d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost;\n\t\t\t\t\t\tpq.push(P(d[tonext.to][2][X], make_pair(tonext.to, make_pair(2, X))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//??±?????????\n\t\t\t\t\tif (d[tonext.to][2][max(tmp.second.second.second - tonext.cost, 0)] > d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost) {\n\t\t\t\t\t\td[tonext.to][2][max(tmp.second.second.second - tonext.cost, 0)] = d[tmp.second.first][tmp.second.second.first][tmp.second.second.second] + tonext.cost;\n\t\t\t\t\t\tpq.push(P(d[tonext.to][2][max(tmp.second.second.second - tonext.cost, 0)],\n\t\t\t\t\t\t\tmake_pair(tonext.to, make_pair(2, max(tmp.second.second.second - tonext.cost, 0)))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint ans = 1000000007;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j <= X; j++) {\n\t\t\tans = min(ans, d[e][i][j]);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> N >> M >> X;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> temp[i];\n\t}\n\tedge.resize(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c; a--, b--;\n\t\tedge[a].push_back(Edge(b, c));\n\t\tedge[b].push_back(Edge(a, c));\n\t}\n\tcout << djk(0, N - 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <stdint.h>\n \n#define in std::cin\n#define out std::cout\n \n#include <queue>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <iterator>\n \nusing COST_T = int32_t;\nconstexpr uint32_t N_MAX = 10000;\nconstexpr COST_T INF = 10000 * 400 + 1000;//std::numeric_limits<double>::infinity()\n \n#if defined(_MSC_VER) && defined(_DEBUG)\n                                          //static_assert(false, \"???????????????§???????????????????????????¨???????????????\");\n#endif\n \nstruct edge {\n    uint32_t to;\n    COST_T cost;\n    edge() {}\n    edge(uint32_t to_, COST_T cost_)\n        :to(to_), cost(cost_) {}\n};\nstd::vector<edge> graph[N_MAX];\n \nint32_t N, M, X;\nint32_t T[N_MAX];\n \n//??????????????????\nCOST_T D[N_MAX][201][2];\nvoid Dijkstra(uint32_t s)\n{\n    using P = std::pair<COST_T, uint64_t>;//cost pos\n    std::priority_queue<P, std::vector<P>, std::greater<>> que;\n    for(auto&arr2:D)for (auto&arr1 : arr2)for (auto&i : arr1)i=INF;\n \n    D[s][X][0] = 0;\n    que.emplace(0, ((uint64_t)(s)<<16)|(X<<8));\n    while (!que.empty())\n    {\n        auto p = que.top(); que.pop();\n        const auto nowpos = p.second >> 16;\n        int32_t ntime = (p.second >> 8) & 0b1111'1111;\n        int32_t ishot = p.second & 0b1111'1111;\n        const auto& nowcost = p.first;\n \n        if (D[nowpos][ntime][ishot] < nowcost) { continue; }\n        //printf(\"%d,%d,%d,%d\\n\", nowpos, ntime, ishot, D[nowpos][ntime][ishot]);\n        //for (int32_t to = 0; to < N; ++to)\n        //{\n        //  auto cost = nowcost + graph[nowpos][to];\n        //  if (cost < D[to]) {\n        //      D[to] = cost;\n        //      que.emplace(D[to], to);\n        //  }\n        //}\n \n        for (const auto& e : graph[nowpos])\n        {\n            auto cost = nowcost + e.cost;\n            auto time = std::max<int32_t>(0, ntime - e.cost);\n            if (time <= 0 || !((T[e.to] == 2 && !ishot) || (T[e.to] == 0 && ishot))) {\n                auto nextishot = ishot;\n                if (T[e.to] == 2) {\n                    time = X;\n                    nextishot = 1;\n                }\n                else if (T[e.to] == 0) {\n                    time = X;\n                    nextishot = 0;\n                }\n                else if (ntime <= 0) {\n                    nextishot = 0;\n                }\n                if (cost < D[e.to][time][nextishot]) {\n                    D[e.to][time][nextishot] = cost;\n                    que.emplace(cost, ((int64_t)(e.to) << 16) | (time << 8) | nextishot);\n                }\n            }\n        }\n \n    }\n}\n \n#if 0\nuint32_t DP[10000][201][2];\n//???´????????????§??????¨??????????????????\nuint32_t func(int pos, int wait, int type/*0??????,1???±???*/)\n{\n    if (pos == N - 1) { return 0; }\n    if (T[pos] != 1) {\n        //?\\??????????¨??±?\n        wait = X;\n        if (T[pos] == 0) {\n            type = 0;\n        }\n        else {\n            type = 1;\n        }\n    }\n    else if (wait == 0) {\n        type = 0;\n    }\n \n    if (DP[pos][wait][type] != 0) { return DP[pos][wait][type]; }\n    DP[pos][wait][type] = INF;\n    uint32_t mincost = INF;\n    for (const auto& e : graph[pos])\n    {\n        if (e.cost < wait) {\n            //???°??¢?????????????§??????\n            if (T[e.to] == 0 && type == 1) {\n                continue;\n            }\n            if (T[e.to] == 2 && type == 0) {\n                continue;\n            }\n        }\n        mincost = std::min(mincost, func(e.to, std::max(0, wait - e.cost), type) + e.cost);\n    }\n    return DP[pos][wait][type] = mincost;\n}\n#endif\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n \n    in >> N >> M >> X;\n    for (size_t i = 0; i < N; ++i) {\n        in >> T[i];\n    }\n    for (size_t i = 0; i < M; ++i) {\n        int a, b, j;\n        in >> a >> b >> j; --a; --b;\n        graph[a].emplace_back(b, j);\n        graph[b].emplace_back(a, j);\n    }\n    Dijkstra(0);\n    int32_t res = INF;\n    for (size_t i = 0; i <= X; ++i)\n    {\n        res = std::min(res, D[N - 1][i][0]);\n        res = std::min(res, D[N - 1][i][1]);\n    }\n    out << res << endl;\n \n    return 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define mp make_pair\n#define INF 1e+9\nusing namespace std;\n\nstruct edge{ int to,cost; };\ntypedef pair<int,int> PP;\ntypedef pair<int,PP> P;\n\nint main(){\n\tint n,m,x,t[10000];\n\tvector<edge> G[10000];\n\tint d[10000][401];\n\tcin >> n >> m >> x;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j <= 400;j++) d[i][j] = INF;\n\t}\n\td[0][(t[0] - 1) * x + 200] = 0;\n\tfor(int i = 0;i < n;i++) cin >> t[i];\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c; a--;b--;\n\t\tG[a].push_back({b,c});\n\t\tG[b].push_back({a,c});\n\t}\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(mp(0,mp(0,(t[0] - 1) * x)));\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint cost = p.first,v = p.second.first,nowt = p.second.second;\n\t\tif(d[v][nowt + 200] < cost) continue;\n\t\t//cout << v << \" \" << nowt << \" \" << cost << endl;\n\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\tedge e = G[v][i];\n\t\t\tint next = nowt;\n\t\t\tif(nowt < 0) next = min(0,nowt + e.cost);\n\t\t\telse if(nowt > 0) next = max(0,nowt - e.cost);\n\t\t\tif((next < 0 && t[e.to] == 2) || (next > 0 && t[e.to] == 0)) continue;\n\t\t\tif(t[e.to] == 2) next = x;\n\t\t\telse if(t[e.to] == 0) next = -x;\n\t\t\tif(d[e.to][next + 200] > d[v][nowt + 200] + e.cost){\n\t\t\t\td[e.to][next + 200] = d[v][nowt + 200] + e.cost;\n\t\t\t\t//cout << e.to << \" \" << d[e.to][next + 200] << endl;\n\t\t\t\tque.push(mp(d[e.to][next + 200],mp(e.to,next)));\n\t\t\t}\n\t\t}\n\t}\n\tint mi = INF;\n\tfor(int i = 0;i <= 400;i++) mi = min(mi,d[n - 1][i]);\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_set>\n#include <set>\n\nusing namespace std;\n\n#define INF (1e9)\n\ntypedef pair<int, int> P;\n\nstruct Q {\n    int time;\n    int togo;\n    int status;\n    int room;\n    Q() {}\n    Q(int a,int b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    int X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n        --T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        to[a-1].push_back(P(d,b-1));\n        to[b-1].push_back(P(d,a-1));\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    vector<int> time(N,INF);\n    unordered_set<int> check;\n//    set<pair<int,int> > deb;\n\n    q.push(Q(0,X,0,0)); // time, togo, status(-1=cold,0=normal,1=hot), room\n    time[0]=0;\n    int cnt=0; // for debug\n    while(!q.empty()) {\n        Q now=q.top(); q.pop();\n        if(check.count(now.room)!=0) continue;\n        if(now.room==N-1) {\n            time[now.room]=now.time;\n            break;\n        }\n        for(auto nxt : to[now.room]) {\n            if(check.count(nxt.second)!=0) continue;\n            int nxt_togo=max(0,now.togo-nxt.first);\n            if(nxt_togo==0) {\n                if(T[nxt.second]==0 && time[nxt.second]>now.time+nxt.first) {\n                    time[nxt.second]=now.time+nxt.first;\n                    q.push(Q(now.time+nxt.first,0,0,nxt.second));\n                } else if(time[nxt.second]>now.time+nxt.first) {\n                    time[nxt.second]=now.time+nxt.first;\n                    q.push(Q(now.time+nxt.first,X,0,nxt.second));\n                }\n            } else if(T[nxt.second]==0) {\n                q.push(Q(now.time+nxt.first,nxt_togo,now.status,nxt.second));\n            } else if(T[nxt.second]==T[now.room] || T[nxt.second]==now.status) {\n                if(time[nxt.second]>now.time+nxt.first) {\n                    time[nxt.second]=now.time+nxt.first;\n                    q.push(Q(now.time+nxt.first,X,0,nxt.second));\n                }\n            }\n\n        }\n    }\n    // cout << \"visited\" << endl;\n    // for(auto x : deb) {\n    //     cout << x.first << \" \" << x.second << endl;\n    // }\n    // cout << \"time\" << endl;\n    cout << time[N-1] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\ntypedef pair<mp,mp> mmp;\n\nint main(){\n\nll n,m,x;\ncin>>n>>m>>x;\nvector<int> t(n);\nvector<vector<mp> > g(n);\nfor(ll i=0;i<n;i++)cin>>t[i];\nfor(ll i=0;i<m;i++){\n\tll a,b,d;\n\tcin>>a>>b>>d;\n\ta--,b--;\n\tg[a].push_back( mp(d,b) );\n\tg[b].push_back( mp(d,a) );\n}\npriority_queue<mmp , vector<mmp> ,greater<mmp> > q;\nq.push( mmp(mp(0,x),mp(0,0) ) );\nvector<vector<vector<bool> > > used(n,vector<vector<bool>  >(3,vector<bool> (x+1,true) ) );\nwhile(!q.empty()){\n\tmmp now = q.top();\n\tq.pop();\n\tll type = now.second.first;\n\tll nn = now.second.second;\n\tll nr = now.first.second;\n\tll nt = now.first.first;\n\t//cout<<type<<' '<<nr<<nn<<' '<<nt<<endl;\n\tif(nn == n-1) {\n\t//\tcout<<\"ok\"<<n<<' '<<nn<<endl;\n\t\tcout<<nt<<endl;\n\t\tbreak;\n\t}\n\t//cout<<\"kkk\"<<endl;\n\tif(!used[nn][type][nr]) continue;\n\t//cout<<nn<<' '<<nt<<' '<<nr<<endl;\n\t//cout<<nn<<endl;\n\tused[nn][type][nr] = false;\n\tfor(ll i=0;i<g[nn].size();i++){\n\t\tll cost = g[nn][i].first;\n\t\tll next = g[nn][i].second;\n\t\tll nexttype = t[next];\n\t\tll nextr = max( (ll) 0,nr - cost);\n\t\tif(nextr != 0  && t[next] != 1 && t[next] != type){\n\t\t\t//q.push(mmp( mp(nt+x,x),mp(nexttype,next) ));\n\t\t\tcontinue;\n\t\t}\n\t\tif(nexttype != 1 ) nextr = x;\n\t\tif(nexttype == 1 && nextr != 0) {\n\t\t\tnexttype = type;\n\t\t}\n\t//\tcout<<\"ok2\"<<nn<<' '<<next<<endl;\n\t\tq.push( mmp( mp( nt+cost , nextr ), mp( nexttype,next )  ) );\n\t\t\n\t}\n}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10000][3][201];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost, 0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 10010\n\nvector<pair<int,int> > way[SIZE];\n\nbool visited[SIZE][3][201];\n\nint main(){\n  int n,m,x,t[SIZE],a,b,d;\n\n  scanf(\"%d%d%d\",&n,&m,&x);\n\n  for(int i=0;i<n;i++) scanf(\"%d\",t+i);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",&a,&b,&d);\n    a--;\n    b--;\n    way[a].push_back({b,d});\n    way[b].push_back({a,d});\n  }\n\n  // {{cost, now},{last_t, time}}\n  priority_queue<pair<pair<int,int>,pair<int,int> > > pq;\n  \n  pq.push({{0,0},{t[0],0}});\n\n  while(pq.size()){\n    pair<pair<int,int>,pair<int,int> > p = pq.top();\n    pq.pop();\n    \n    int cost = p.first.first;\n    int now = p.first.second;\n    int last_t = p.second.first;\n    int time = p.second.second;\n    \n    if(visited[now][last_t][time]) continue;\n    visited[now][last_t][time] = true;\n\n    if(now == n-1){\n      printf(\"%d\\n\",-cost);\n      return 0;\n    }\n    \n    for(int i=0;i<way[now].size();i++){\n      int to = way[now][i].first;\n      int d = way[now][i].second;\n\n      if(last_t == 1 || time + d >= x){\n        pq.push({{cost-d, to},{t[to],0}});\n      }else{\n        if(last_t == t[to]){\n          pq.push({{cost-d, to},{t[to],0}});\n        }\n        if(t[to] == 1){\n          pq.push({{cost-d, to},{last_t,time+d}});\n        }\n      }\n    }\n  }\n  \n  puts(\"-1\");\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n){\n        cin>>t[i];\n        if (t[i]==2)t[i]=1;\n        else if (t[i]==1)t[i]=2;\n    }\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        if (d[v][type][tim] < dist) continue;\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 2) {\n                u = e.to, ntype = type, ntim = min(x, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = type, ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{ int to,cost; };\nstruct state{\n  int cost,pos,last;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nint N,M,X;\nvector<edge> G[10000];\nint t[10000];\n\nint D[10000][401];\nint* d[10000];\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&X);\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&t[i]);\n  }\n  for(int i=0;i<M;i++){\n    int a,b,c;\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--,b--;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n\n  fill(D[0],D[10000],1e9);\n  for(int i=0;i<N;i++){\n    d[i]=&D[i][200];\n  }\n  \n\n  priority_queue< state > Q;\n  \n  d[0][-X]=0;\n  Q.push( (state){0,0,-X} );\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    \n    if(s.pos==N-1){\n      printf(\"%d\\n\",s.cost);\n      break;\n    }\n    \n    if(s.cost > d[s.pos][s.last])continue;\n    \n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      state next=s;\n      next.pos=e.to;\n      next.cost+=e.cost;\n      if(next.last<0)next.last=min(0,next.last+e.cost);\n      if(next.last>0)next.last=max(0,next.last-e.cost);\n\n      if(next.last>0&&t[e.to]==0)continue;\n      if(next.last<0&&t[e.to]==2)continue;\n\n      if(t[e.to]==0)next.last=-X;\n      if(t[e.to]==2)next.last=X;\n\n      if( d[next.pos][next.last] > next.cost ){\n        d[next.pos][next.last]=next.cost;\n        Q.push( next );\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define INF (1000000000000000000LL)\n\ntypedef pair<long long, int> P;\n\nstruct Q {\n    long long time;\n    long long togo;\n    int status;\n    int room;\n    Q() {}\n    Q(long long a,long long b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    long long X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n        --T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        to[a-1].push_back(P((long long)d,b-1));\n        to[b-1].push_back(P((long long)d,a-1));\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    vector<long long> time(N,INF);\n//    unordered_map<int,long long> um;\n\n    q.push(Q(0LL,X,-1,0));\n\n    while(true) {\n        Q now=q.top(); q.pop();\n        if(T[now.room]!=0 && time[now.room]<now.time) continue;\n        time[now.room]=now.time;\n        if(now.room==N-1) break;\n        for(auto nxt : to[now.room]) {\n            if(T[nxt.second]!=0 && time[nxt.second]<now.time+nxt.first) continue;\n\n            if(T[nxt.second]==0 && (T[now.room]==0 || time[nxt.second]>now.time+nxt.first)) {\n                time[nxt.second]=now.time+nxt.first;\n                q.push(Q(now.time+nxt.first,max(0LL,now.togo-nxt.first),now.status,nxt.second));\n            } else if(T[nxt.second]==now.status || nxt.first>=now.togo) {\n                time[nxt.second]=now.time+nxt.first;\n                q.push(Q(time[nxt.second],X,T[nxt.second],nxt.second));\n            }\n        }\n    }\n\n    cout << time[N-1] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define INF (1000000000)\n\ntypedef pair<int, int> P;\n\nstruct Q {\n    int time;\n    int togo;\n    int status;\n    int room;\n    Q() {}\n    Q(int a,int b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    int X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n        --T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        if(T[a-1]*T[b-1]>=0 || d>=X) {\n            to[a-1].push_back(P(d,b-1));\n            to[b-1].push_back(P(d,a-1));\n        }\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    vector<int> time(N,INF);\n//    unordered_map<int,int> um;\n\n    q.push(Q(0,X,0,0));\n    int cnt=0;\n    while(!q.empty()) {\n        Q now=q.top(); q.pop();\n        ++cnt;\n        if(now.status==0 && time[now.room]<=now.time) continue;\n        if(now.status==0) time[now.room]=now.time;\n        if(now.room==N-1) {\n            time[N-1]=now.time;\n            break;\n        }\n        for(auto nxt : to[now.room]) {\n            if(time[nxt.second]<=now.time+nxt.first) continue;\n\n            int nxt_togo=now.togo-nxt.first;\n\n            if(nxt_togo<=0) {\n                if(T[nxt.second]==0) q.push(Q(now.time+nxt.first,0,0,nxt.second));\n                else q.push(Q(now.time+nxt.first,X,0,nxt.second));\n            } else {\n                if(T[nxt.second]==0) {\n                    q.push(Q(now.time+nxt.first,nxt_togo,now.status+T[now.room],nxt.second));\n                } else if(now.status==T[nxt.second]) {\n                    q.push(Q(now.time+nxt.first,X,0,nxt.second));\n                }\n            }\n        }\n    }\n\n    cout << time[N-1] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define INF (1000000000000000000LL)\n\ntypedef pair<long long, int> P;\ntypedef pair<long long, long long> PP;\n\nstruct Q {\n    long long time;\n    long long togo;\n    int status;\n    int room;\n    Q() {}\n    Q(long long a,long long b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    long long X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n        --T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        if(T[a-1]*T[b-1]==-1 && d<X) continue;\n        to[a-1].push_back(P((long long)d,b-1));\n        to[b-1].push_back(P((long long)d,a-1));\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    vector<PP> time(N);\n//    unordered_map<int,long long> um;\n    for(int i=0; i<N; ++i) time[i]=PP(INF,X); // time, togo\n\n    q.push(Q(0LL,X,-1,0));\n\n    while(true) {\n        Q now=q.top(); q.pop();\n        if(T[now.room]!=0 && time[now.room].first<now.time) continue;\n        time[now.room]=PP(now.time,now.togo);\n        if(now.room==N-1) break;\n        for(auto nxt : to[now.room]) {\n            if(T[nxt.second]==0) {\n                if(time[nxt.second].second==0 && time[nxt.second].first<=nxt.first+now.time) continue;\n                q.push(Q(nxt.first+now.time,max(0LL,now.togo-nxt.first),now.status,nxt.second));\n            } else if(T[nxt.second]*now.status==1) {\n                if(time[nxt.second].first<=nxt.first+now.time) continue;\n                q.push(Q(nxt.first+now.time,X,T[nxt.second],nxt.second));\n            } else {\n                if(time[nxt.second].first<=nxt.first+now.time || now.togo>nxt.first) continue;\n                q.push(Q(nxt.first+now.time,X,T[nxt.second],nxt.second));\n            }\n        }\n    }\n\n    cout << time[N-1].first << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tCOLD,\n\tMID,\n\tHOT,\n};\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_sum_time,int arg_rest,Type arg_pre_type){\n\t\tnode_id = arg_node_id;\n\t\tsum_time = arg_sum_time;\n\t\trest = arg_rest;\n\t\tpre_type = arg_pre_type;\n\t}\n\tint node_id,sum_time,rest;\n\tType pre_type;\n};\n\nstruct Data{\n\tData(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nint dp[3][10000][201];\nType room_info[10000],type_array[3] = {COLD,MID,HOT};\n\n\nint main(){\n\n\tint N,M,X;\n\tscanf(\"%d %d %d\",&N,&M,&X);\n\n\tint tmp;\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\troom_info[i] = type_array[tmp];\n\t}\n\n\tvector<Data> V[N];\n\n\tint from,to,cost;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&cost);\n\t\tfrom--;\n\t\tto--;\n\t\tV[from].push_back(Data(to,cost));\n\t\tV[to].push_back(Data(from,cost));\n\t}\n\n\tfor(int i = 0; i <= N-1; i++){\n\t\tfor(int k = 0; k <= X; k++){\n\t\t\tdp[COLD][i][k] = BIG_NUM;\n\t\t\tdp[MID][i][k] = BIG_NUM;\n\t\t\tdp[HOT][i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\tdp[COLD][0][X] = 0;\n\tQ.push(Info(0,0,X,COLD));\n\n\tint ans = BIG_NUM,next_node,next_rest;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().node_id == N-1){\n\t\t\tans = min(ans,Q.front().sum_time);\n\t\t\tQ.pop();\n\t\t}else if(Q.front().sum_time > dp[Q.front().pre_type][Q.front().node_id][Q.front().rest]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.front().node_id].size(); i++){\n\t\t\t\tnext_node = V[Q.front().node_id][i].to;\n\n\t\t\t\tif(room_info[next_node] == MID){\n\t\t\t\t\tnext_rest = max(0,Q.front().rest-V[Q.front().node_id][i].cost);\n\n\t\t\t\t\tif(next_rest > 0){\n\n\t\t\t\t\t\tif(dp[Q.front().pre_type][next_node][next_rest] > Q.front().sum_time+V[Q.front().node_id][i].cost){\n\t\t\t\t\t\t\tdp[Q.front().pre_type][next_node][next_rest] = Q.front().sum_time+V[Q.front().node_id][i].cost;\n\t\t\t\t\t\t\tQ.push(Info(next_node,dp[Q.front().pre_type][next_node][next_rest],next_rest,Q.front().pre_type));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //next_rest == 0\n\t\t\t\t\t\tif(dp[MID][next_node][0] > Q.front().sum_time+V[Q.front().node_id][i].cost){\n\t\t\t\t\t\t\tdp[MID][next_node][0] = Q.front().sum_time+V[Q.front().node_id][i].cost;\n\t\t\t\t\t\t\tQ.push(Info(next_node,dp[MID][next_node][0],0,MID));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\tif(Q.front().pre_type == MID){\n\t\t\t\t\t\tif(dp[room_info[next_node]][next_node][X] > Q.front().sum_time+V[Q.front().node_id][i].cost){\n\t\t\t\t\t\t\tdp[room_info[next_node]][next_node][X] = Q.front().sum_time+V[Q.front().node_id][i].cost;\n\t\t\t\t\t\t\tQ.push(Info(next_node,dp[room_info[next_node]][next_node][X],X,room_info[next_node]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(Q.front().pre_type == room_info[next_node]){\n\t\t\t\t\t\t\tif(dp[room_info[next_node]][next_node][X] > Q.front().sum_time+V[Q.front().node_id][i].cost){\n\t\t\t\t\t\t\t\tdp[room_info[next_node]][next_node][X] = Q.front().sum_time+V[Q.front().node_id][i].cost;\n\t\t\t\t\t\t\t\tQ.push(Info(next_node,dp[room_info[next_node]][next_node][X],X,room_info[next_node]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{ //Q.front().pre_type != room_info[next_node]\n\t\t\t\t\t\t\tif(V[Q.front().node_id][i].cost < Q.front().rest)continue;\n\n\t\t\t\t\t\t\tif(dp[room_info[next_node]][next_node][X] > Q.front().sum_time+V[Q.front().node_id][i].cost){\n\t\t\t\t\t\t\t\tdp[room_info[next_node]][next_node][X] = Q.front().sum_time+V[Q.front().node_id][i].cost;\n\t\t\t\t\t\t\t\tQ.push(Info(next_node,dp[room_info[next_node]][next_node][X],X,room_info[next_node]));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10000][3][201];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%lld\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tfor (int x = 0; x < a; x++) {\n\t\tfor (int y = 0; y < c; y++) {\n\t\t\tmincost[x][0][y] = mincost[x][1][y] = mincost[x][2][y] = LLONG_MAX / 3;\n\t\t}\n\t}\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = LLONG_MAX / 3;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 10001\n#define INF 1e9\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n,m,X,C[N];\nvector<P> G[N];\n\nint D[N][201][3];\nbool used[N][201][3];\n\nint dijkstra(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<201;j++)\n      for(int k=0;k<3;k++) D[i][j][k]=INF;\n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(P(0,0),P(0,0)));\n  D[0][0][0]=0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int cost=t.f.f,pos=t.f.s;\n    int x=t.s.f,sta=t.s.s;\n    if(pos==n-1) return cost;\n    if(D[pos][x][sta]<cost) continue;\n    used[pos][x][sta]=1;\n    for(int i=0;i<G[pos].size();i++){\n      int ncost=G[pos][i].s+cost;\n      int npos=G[pos][i].f;\n      int nx=min(X,x+G[pos][i].s);\n      int nsta=C[npos];\n      if(abs(sta-nsta)==2){\n\tif(nx<X) continue;\n\tnx=0;\n      }\n      if(nsta==1) nsta=sta;\n      else if(nsta==sta) nx=0;\n      if(D[npos][nx][nsta]<=ncost)continue;\n      if(used[npos][nx][nsta])continue;\n      Q.push(PP(P(ncost,npos),P(nx,nsta)));\n      D[npos][nx][nsta]=ncost;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  cin>>n>>m>>X;\n  for(int i=0;i<n;i++) cin>>C[i];\n\n  for(int i=0,a,b,d;i<m;i++){\n    cin>>a>>b>>d;\n    a--,b--;\n    G[a].push_back(P(b,d));\n    G[b].push_back(P(a,d));\n  }\n  cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\n#define int long long\nconst int INF = 100100100100100LL;\n\nusing namespace std;\n\nvector<int> dijk(int s, int v, const vector<vector<pair<int, int> > > &adjlist){\n\n    priority_queue<pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    while(!wait.empty()){\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n\n    return result;\n}\n\nsigned main(){\n\n    int n, m, x; cin >> n >> m >> x;\n    vector<int> t(n);\n    for(int i = 0; i < n; i++){\n        cin >> t[i];\n        if(t[i] == 1) t[i] = 0;\n        else if(t[i] == 0) t[i] = 1;\n        else t[i] = 2;\n    }\n    // toGraph[n][x][state]\n    vector<vector<vector<int> > > toGraph(n, vector<vector<int> > (x + 1, vector<int> (3)));\n    int num = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= x; j++){\n            for(int k = 0; k < 3; k++){\n                toGraph[i][j][k] = num;\n                num++;   \n            }\n        }\n    }\n\n    vector<vector<pair<int, int> > > g(num);\n    for(int i = 0; i < m; i++){\n        int a, b, c; cin >> a >> b >> c;\n        a--;\n        b--;\n        int cost = c;\n        for(int z = 0; z < 2; z++){\n\n            // a -> b\n            int curNode = a;\n            for(int curState = 0; curState < 3; curState++){\n                // TODO 矛盾あるかも\n                if(t[curNode] != 0 && curState != t[curNode]) continue;\n                for(int curX = 0; curX <= x; curX++){\n                    int nextNode = b;\n                    int nextState;\n                    int nextX;\n\n                    if(curState == 0){\n                        if(t[nextNode] == 0){\n                            nextState = 0;\n                            nextX = 0;\n                        }else{\n                            nextState = t[nextNode];\n                            nextX = x;\n                        }\n\n                    }else{\n                        if(t[curNode] != 0 && curX != x) continue;\n                        if(t[nextNode] == 0){\n                            nextState = curState;\n                            nextX = max(0LL, curX - cost);\n                            if(nextX == 0) nextState = 0;\n                        }else if(t[nextNode] == curState){\n                            nextState = curState;\n                            nextX = x;\n                        }else{\n                            nextX = max(0LL, curX - cost);\n                            if(nextX != 0) continue;\n                            nextX = x;\n                            nextState = t[nextNode];\n                        }\n                    }\n\n                    int cur = toGraph[curNode][curX][curState];\n                    int next = toGraph[nextNode][nextX][nextState];\n          //          cerr << \"(\" << curNode + 1 << \",\" << curState << \",\" << curX << \")  --->>>   (\" << nextNode + 1 << \",\" << nextState << \",\" << nextX << \")    :   \" << cost << endl; \n                    g[cur].push_back({cost, next});\n                }\n            }\n\n            swap(a, b);\n        }\n    }\n\n    int S = toGraph[0][x][1];\n    vector<int> result = dijk(S, num, g);\n    /*\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= x; j++){\n            for(int k = 0; k < 3; k++){\n                int G = toGraph[i][j][k];\n                cout << i + 1 << \" \" << k << \" \" << j << \" \" << result[G] << endl;\n            }\n        }\n    }*/\n\n\n    int ans = INF;\n    for(int j = 0; j <= x; j++){\n        for(int k = 0; k < 3; k++){\n            int G = toGraph[n - 1][j][k];\n            ans = min(ans, result[G]);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cmath>\n#include<set>\n#include<random>\n#include<map>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define F first\n#define S second\nconst long long mod = 1000000007;\nconst long long inf = 1145141919810;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\nstruct edge {int to, cost;};\nvector<edge>G[10007];\nint t[10007],d[3][10007][201];\n\nvoid dijk(int s, int x) {\n\trep(i, 3)\n\t\trep(j, 10005)\n\t\trep(k,201)d[i][j][k] = inf;\n\td[0][s][0] = 0;\n\tpriority_queue<PP, vector<PP>, greater<PP>>Q;\n\tQ.push(PP(P(0, s), P(0, t[s])));\n\twhile (Q.size()) {\n\t\tPP p = Q.top();\n\t\tint v = p.first.second;\n\t\tQ.pop();\n\t\tif (d[p.second.second][v][p.second.first] < p.F.F)continue;\n\t\trep(i, G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (p.second.second == 0) {\n\t\t\t\tif (t[e.to] == 0) {\n\t\t\t\t\tif (d[0][e.to][0] > d[p.second.second][v][p.second.first] + e.cost) {\n\t\t\t\t\t\td[0][e.to][0] = d[p.second.second][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[0][e.to][0], e.to), P(0, 0)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (t[e.to] == 1) {\n\t\t\t\t\tint ld = min(x, e.cost + p.second.first);\n\t\t\t\t\tif (d[0][e.to][ld] > d[p.second.second][v][p.second.first] + e.cost) {\n\t\t\t\t\t\td[0][e.to][ld] = d[p.second.second][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[0][e.to][ld], e.to), P(min(x, e.cost + p.second.F), 0)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint ld = p.second.first + e.cost;\n\t\t\t\t\tld = min(ld, x);\n\t\t\t\t\tif (d[2][e.to][0] > d[0][v][p.second.first] + e.cost&&ld == x) {\n\t\t\t\t\t\td[2][e.to][0] = d[0][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[2][e.to][0], e.to), P(0, 2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t[e.to] == 2) {\n\t\t\t\t\tif (d[2][e.to][0] > d[2][v][p.second.first] + e.cost) {\n\t\t\t\t\t\td[2][e.to][0] = d[2][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[2][e.to][0], e.to), P(0, 2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (t[e.to] == 1) {\n\t\t\t\t\tint ld = min(x, e.cost + p.second.first);\n\t\t\t\t\tif (d[2][e.to][ld] > d[2][v][p.second.first] + e.cost) {\n\t\t\t\t\t\td[2][e.to][ld] = d[2][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[2][e.to][ld], e.to), P(min(x, e.cost + p.second.F), 2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint ld = p.second.first + e.cost;\n\t\t\t\t\tld = min(ld, x);\n\t\t\t\t\tif (d[0][e.to][0] > d[2][v][p.second.first] + e.cost&&ld == x) {\n\t\t\t\t\t\td[0][e.to][0] = d[2][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[0][e.to][0], e.to), P(0, 0)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tint n, m, x; cin >> n >> m >> x;\n\trep(i, n)cin >> t[i];\n\trep(j, n) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--, b--;\n\t\tG[a].push_back({ b,c });\n\t\tG[b].push_back({ a,c });\n\t}\n\tdijk(0, x); \n\tint ans = inf;\n\trep(i, 3)\n\t\trep(j, 201)ans = min(ans, d[i][n-1][j]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct H {\n\tint x, y;\n};\nstruct P {\n\tint pos, cost, deg, time;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\n//---------------------------------------------------\n//+++++++++++++++++++++++++++++++++++++++++++++++++++\nint n, m, x;\nint a[10001][3][201];\nint b[10001];\nvector<B>e[20000];\nsigned main() {\n\tcin >> n >> m >> x;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> b[i];\n\tfor (int i = 0; i < m; i++) {\n\t\tint u1, u2, u3;\n\t\tcin >> u1 >> u2 >> u3;\n\t\te[u1].push_back(B{ u2,u3 });\n\t\te[u2].push_back(B{ u1,u3 });\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tfor (int z = 0; z < 201; z++)\n\t\t\t\ta[i][j][z] = inf;\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\tp.push(P{ 1,0,0,0 });\n\ta[1][0][0] = 0;\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop();\n\t\tfor (int i = 0; i < e[t.pos].size(); i++) {\n\t\t\tif (b[e[t.pos][i].to] == 0) {\n\t\t\t\tif (t.deg == 0) {\n\t\t\t\t\tif (a[e[t.pos][i].to][0][0] > t.cost + e[t.pos][i].cost) {\n\t\t\t\t\t\ta[e[t.pos][i].to][0][0] = t.cost + e[t.pos][i].cost;\n\t\t\t\t\t\tp.push(P{ e[t.pos][i].to,t.cost + e[t.pos][i].cost,0,0 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (t.deg == 2 && t.time+e[t.pos][i].cost >= x) {\n\t\t\t\t\tif (a[e[t.pos][i].to][0][0] > t.cost + e[t.pos][i].cost) {\n\t\t\t\t\t\ta[e[t.pos][i].to][0][0] = t.cost + e[t.pos][i].cost;\n\t\t\t\t\t\tp.push(P{ e[t.pos][i].to,t.cost + e[t.pos][i].cost ,0,0 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (b[e[t.pos][i].to] == 1) {\n\t\t\t\tif (t.deg == 0) {\n\t\t\t\t\tif (a[e[t.pos][i].to][0][min(x, t.time + e[t.pos][i].cost)] > t.cost + e[t.pos][i].cost) {\n\t\t\t\t\t\ta[e[t.pos][i].to][0][min(x, t.time + e[t.pos][i].cost)] = t.cost + e[t.pos][i].cost;\n\t\t\t\t\t\tp.push(P{ e[t.pos][i].to,t.cost + e[t.pos][i].cost,0,min(x, t.time + e[t.pos][i].cost) });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (t.deg == 2) {\n\t\t\t\t\tif (a[e[t.pos][i].to][2][min(x, t.time + e[t.pos][i].cost)] > t.cost + e[t.pos][i].cost) {\n\t\t\t\t\t\ta[e[t.pos][i].to][2][min(x, t.time + e[t.pos][i].cost)] = t.cost + e[t.pos][i].cost;\n\t\t\t\t\t\tp.push(P{ e[t.pos][i].to,t.cost + e[t.pos][i].cost,2,min(x,t.time + e[t.pos][i].cost) });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t.deg == 0 &&t.time+ e[t.pos][i].cost >= x) {\n\t\t\t\t\tif (a[e[t.pos][i].to][2][0] > t.cost + e[t.pos][i].cost) {\n\t\t\t\t\t\ta[e[t.pos][i].to][2][0] = t.cost + e[t.pos][i].cost;\n\t\t\t\t\t\tp.push(P{ e[t.pos][i].to,t.cost + e[t.pos][i].cost,2,0 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (t.deg == 2) {\n\t\t\t\t\tif (a[e[t.pos][i].to][2][0] > t.cost + e[t.pos][i].cost) {\n\t\t\t\t\t\ta[e[t.pos][i].to][2][0] = t.cost + e[t.pos][i].cost;\n\t\t\t\t\t\tp.push(P{ e[t.pos][i].to,t.cost + e[t.pos][i].cost,2,0 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = inf;\n\tfor (int j = 0; j < 3; j++) {\n\t\tfor (int i = 0; i < 201; i++)\n\t\t\tans = min(ans, a[n][j][i]);\n\t}\n\tcout << ans << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 112000000012345678LL\n\nusing P = pair<long,int>;\n// cost, idx\n\nint t[10005];\n\nlong d[200*2*10005];\nvector<P> vec[200*2*10005];\n\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  rep(i,n) cin>>t[i];\n\n  rep(_,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    rep(__,2){\n      int ai = a*2*x, bi = b*2*x;\n      if(t[b]==1){\n        if(t[a]!=1){\n          // [0,2] -> 1\n          if(t[a]==2) bi += x;\n          vec[ai].pb(mp(c, bi + max(0, x-c)));\n        }\n        else {\n          // 1 -> 1\n          vec[ai].pb(mp(c, bi));\n          repl(i,1,x){\n            vec[ai+i].pb(mp(c, bi + max(0, i-c)));\n            vec[ai+x+i].pb(mp(c, bi + x + max(0, i-c) ));\n          }\n        }\n      }\n      else if(t[a] == t[b]){\n        // 0 -> 0, 2 -> 2\n        vec[ai].pb(mp(c, bi));\n      }\n      else if(t[a]==1){\n        // 1 -> 2, 1 -> 0\n        if(t[b]==2) ai += x;\n        rep(i,x) vec[ai + i].pb(mp(c, bi));\n\n        ai = a*2*x;\n        if(t[b]==0) ai += x;\n        rep(i,min(c+1,x)) vec[ai + i].pb(mp(c, bi));\n      }\n      else {\n        // 0->2, 2->0\n        if(t[a]==2) ai += x;\n        else bi += x;\n        if(x <= c) vec[ai].pb(mp(c, bi));\n      }\n\n      swap(a,b);\n    } // make edges\n  }\n\n  rep(i,n) if(t[i]==1){\n    int ai = 2*i*x;\n    vec[ai].pb(mp(0,ai+x));\n    vec[ai+x].pb(mp(0,ai));\n  }\n\n  priority_queue<P, vector<P>, greater<P>> pq;\n  fill(d, d + 2*x*n, INF);\n  d[0] = 0;\n  pq.push(mp(0,0));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    if(d[p.se] < p.fi) continue;\n    for(auto to : vec[p.se]){\n      long nd = p.fi + to.fi;\n      int ni = to.se;\n      if(d[ni] > nd){\n        pq.push(mp(nd,ni));\n        d[ni] = nd;\n      }\n    }\n  }\n\n  long ans = INF;\n  rep(i,2*x) ans = min(ans, d[(n-1)*2*x + i]);\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n// WA?¨????\n// mp(cost, idx)?????????????????´?????§???????????????fi??¨se???????????£???\n// t[i]==1 ????????????x????????????????????£???"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = 10000000;\n\nint n,m,x;\nint room[10000];\nvector<PII> pass[10000]; // [from] = (cost, to)\n\nstruct state{\n\tint d, p, d2;\n\tbool cold;\n\tbool operator<(const state& a) const {\n\t\treturn d == a.d ? d2 > a.d2 : d < a.d;\n\t}\n};\n\n// ????????????????????¨?±?i????????£??¨????????????????????§??\\?????????????????????????????¨?±??????????h?????¨?±???????\n//?????????????????¢????????????distc[h][i]\nint distc[2][10000];\n\nint main() {\n\tcin>>n>>m>>x;\n\tREP(i,n)cin >> room[i];\n\tREP(i,m){\n\t\tint a,b,d;\n\t\tcin >> a >> b >> d;\n\t\ta--;b--;\n\t\tpass[a].push_back(MP(d,b));\n\t\tpass[b].push_back(MP(d,a));\n\t}\n\tREP(i,n){\n\t\tauto& v = pass[i];\n\t\tSORT(v);\n\t\tUNIQUE(v);\n\t}\n\n\tpriority_queue<state> q;\n\tq.push((state){0,0,0,true});\n\n\tint dist[n];\n\tREP(i,n)dist[i]=INF;\n\tdist[0]=0;\n\n\twhile(!q.empty()){\n\t\tstate s = q.top();q.pop();\n\t\tEACH(i,pass[s.p]){\n\t\t\tint d = (*i).first,p = (*i).second;\n\t\t\tint nd = s.d + d;\n\t\t\tint nd2 = s.d2 + d;\n\t\t\tif(room[p]==1){\n\t\t\t\t// ?????¢???????????????????????????\n\t\t\t\t// ????????????d2?????´??°??§??????????????????\n\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\tdistc[s.cold][p] = nd2;\n\t\t\t\t\tq.push((state){nd, p, nd2, s.cold});\n\t\t\t\t}else if(distc[s.cold][p] < x){\n\t\t\t\t\tdistc[s.cold][p] = nd2;\n\t\t\t\t\tq.push((state){nd, p, nd2, s.cold});\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// cold????????¢????????????d2???????????????d???????????????d2=0???????????´??°\n\t\t\t\t// cold????????¢??????????????????d????????????d2=0\n\t\t\t\tif(s.cold == !!room[p]){ // ?????¢\n\t\t\t\t\tif(nd2 < x)continue; // ??\\???????????????\n\t\t\t\t\t// ??\\???????????????d2=0????????§??????????????´??????????????¨\n\t\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\t\tq.push((state){nd, p, 0, !room[p]});\n\t\t\t\t\t}\n\t\t\t\t}else{ // ?????¢?????????\n\t\t\t\t\t// ??\\???????????§?????????????????´??????????????¨\n\t\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\t\tq.push((state){nd, p, 0, !room[p]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[n-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge { int to, cost; };\nstruct state {\n\tint pos, cost, pt, rem;\n\t// position, cost, previous t (0 or 2), rem\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint N, M, X, a, b, c;\nint main() {\n\tcin >> N >> M >> X;\n\tvector<int> T(N);\n\tfor (int i = 0; i < N; i++) cin >> T[i];\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b >> c; a--, b--;\n\t\tG[a].push_back(edge{ b, c });\n\t\tG[b].push_back(edge{ a, c });\n\t}\n\tvector<vector<vector<int> > > dist(N, vector<vector<int> >(X + 1, vector<int>(2, 999999999))); dist[0][X][0] = 0;\n\tpriority_queue<state> que; que.push(state{ 0, 0, 0, X });\n\twhile (!que.empty()) {\n\t\tstate s = que.top(); que.pop();\n\t\tfor (edge e : G[s.pos]) {\n\t\t\tint r = max(s.rem - e.cost, 0), p = s.pt;\n\t\t\tif (r > 0 && ((s.pt << 1) ^ T[e.to]) == 2) continue;\n\t\t\tif (T[e.to] != 1) r = X, p = T[e.to] >> 1;\n\t\t\tif (dist[e.to][r][p] > dist[s.pos][s.rem][s.pt] + e.cost) {\n\t\t\t\tdist[e.to][r][p] = dist[s.pos][s.rem][s.pt] + e.cost;\n\t\t\t\tque.push(state{ e.to, -dist[e.to][r][p], p, r });\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 999999999;\n\tfor (int i = 0; i <= X; i++) {\n\t\tret = min(ret, min(dist[N - 1][i][0], dist[N - 1][i][1]));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, d;\n    Corridor(int target, int d): target(target), d(d) {}\n};\n\nstruct Room {\npublic:\n    int id, t;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int t): id(id), t(t) {}\n};\n\nstruct State {\n    int id, time, t, d;\n    State(int id, int time, int t, int d): id(id), time(time), t(t), d(d) {};\n    bool operator < (const State &s) const {\n        return time > s.time;\n    }\n};\n\nint N, M, X;\nRoom rooms[MAX + 1];\nint min_time[MAX + 1][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX + 1; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[1][0][0] = 0;\n    PQ.push(State(1, 0, COLD, 0));\n    int ans = INT_MAX;\n    while(!PQ.empty()) {\n        State s = PQ.top();\n        PQ.pop();\n        if(s.id == N) {\n            ans = min(ans, s.time);\n            continue;\n        }\n        if(s.time > ans) break;\n        for(auto c: rooms[s.id].edge) {\n            if(abs(s.t - rooms[c.target].t) > 1 && s.d + c.d < X) continue;\n            if(rooms[c.target].t == CONFORTABLE) {\n                if(min_time[c.target][s.t / 2][min(X, s.d + c.d)] < s.time + c.d) continue;\n                min_time[c.target][s.t / 2][min(X, s.d + c.d)] = s.time + c.d;\n                PQ.push(State(c.target, s.time + c.d, s.t, min(X, s.d + c.d)));\n            } else {\n                if(min_time[c.target][rooms[c.target].t / 2][0] < s.time + c.d) continue;\n                min_time[c.target][rooms[c.target].t / 2][0] = s.time + c.d;\n                PQ.push(State(c.target, s.time + c.d, rooms[c.target].t, 0));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int t, a, b, d;\n    scanf(\"%d %d %d\", &N, &M, &X);\n\n    for (int i = 1; i < N + 1; i++) {\n        scanf(\"%d\", &t);\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &a, &b, &d);\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nstruct state {\n  int v, cost, rt, te;\n  state(){}\n  state(int v, int cost, int rt, int te):v(v), cost(cost), rt(rt), te(te){}\n  bool operator < (const state& r) const {\n    return cost > r.cost;\n  }\n};\n\nint N, M, X;\nint T[10010];\n\nvector<edge> G[10010];\nint mincost[3][202][10010];\n\nint dijkstra()\n{\n  rep(i, 3) rep(j, 202) rep(k, 10010) mincost[i][j][k] = inf;\n  priority_queue<state> que;\n  que.emplace(0, 0, T[0], 0);\n  mincost[T[0]][0][0] = 0;\n  while(!que.empty()) {\n    state s = que.top(); que.pop();\n    if(s.v == N-1) return s.cost;\n    if(s.cost > mincost[s.rt][s.te][s.v]) continue;\n    for(edge& e : G[s.v]) {\n      if(abs(s.rt - T[e.to]) == 2 && s.te + e.cost < X) continue;\n      int nrt = s.rt, nte = s.te + e.cost;\n      if(T[e.to] != 1) nrt = T[e.to], nte = 0;\n      if(s.cost + e.cost < mincost[nrt][nte][e.to]) {\n\tmincost[nrt][nte][e.to] = s.cost + e.cost;\n\tque.emplace(e.to, s.cost + e.cost, nrt, nte);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> X;\n  rep(i, N) cin >> T[i];\n  rep(i, M) {\n    int A, B, D;\n    cin >> A >> B >> D; A--, B--;\n    G[A].emplace_back(B, D);\n    G[B].emplace_back(A, D);\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct edge{int to,cost;};\nstruct State\n{\n    int pos,rem,temp;\n    bool operator<(const State &r) const {\n        if(pos == r.pos)\n        {\n            if(rem == r.rem) return temp<r.temp;\n            else return rem<r.rem;\n        }\n        else return pos<r.pos;\n    }\n};\n\nusing P = pair<int,State>;\n\nconst int V=10000;\nconst int INF=123456789;\n\nvector<edge> G[V];\nint d[V][201][3];\n\nint main()\n{\n    int N,M,X;\n    scanf(\" %d %d %d\", &N, &M, &X);\n    vector<int> T(N);\n    rep(i,N) scanf(\" %d\", &T[i]);\n    rep(i,M)\n    {\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n    fill_n((int*)d, V*201*3, INF);\n    d[0][X][0] = 0;\n    priority_queue<P,vector<P>,greater<P>> pq;\n    pq.push(P(0,{0,X,0}));\n    while(!pq.empty())\n    {\n        P p = pq.top();\n        pq.pop();\n        State s = p.se;\n        if(p.fi>d[s.pos][s.rem][s.temp]) continue;\n\n        for(const auto &e:G[s.pos])\n        {\n            int nr = max(0, s.rem-e.cost);\n            int nt = s.temp;\n            if(nr==0) nt=1;\n\n            if(T[e.to]!=1)\n            {\n                int ban = (T[e.to]==0)?2:0;\n                if(nt==ban) continue;\n                nr = X;\n                nt = T[e.to];\n            }\n\n            if(d[e.to][nr][nt] > d[s.pos][s.rem][s.temp]+e.cost)\n            {\n                d[e.to][nr][nt] = d[s.pos][s.rem][s.temp]+e.cost;\n                pq.push(P(d[e.to][nr][nt],{e.to,nr,nt}));\n            }\n        }\n    }\n\n    int ans=INF;\n    rep(i,3)rep(j,X+1) ans = min(ans,d[N-1][j][i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 112000000056789LL\n\nusing P = pair<long,int>;\n// cost, idx\n\nint t[100005];\n\nlong d[200*2*100005];\nvector<P> vec[200*2*100005];\n\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  rep(i,n) cin>>t[i];\n\n  rep(i,n*2*x) vec[i] = vector<P>();\n\n  // t=1 ???????????????\n\n  rep(_,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    rep(__,2){\n      int ai = a*2*x, bi = b*2*x;\n      if(t[b]==1){\n        if(t[a]!=1){\n          // [0,2] -> 1\n          if(t[a]==2) bi += x;\n          vec[ai].pb(mp(c, bi + max(0, x-c)));\n        }\n        else {\n          // 1 -> 1\n          vec[ai].pb(mp(bi, c));\n          repl(i,1,x){\n            vec[ai+i].pb(mp(c, bi + max(0, i-c)));\n            vec[ai+x+i].pb(mp(c, bi + ((i-c>0)?(x+i-c):0) ));\n          }\n        }\n      }\n      else if(t[a] == t[b]){\n        // 0 -> 0, 2 -> 2\n        vec[ai].pb(mp(c, bi));\n      }\n      else if(t[a]==1){\n        // 1 -> 2, 1 -> 0\n        vec[ai].pb(mp(c, bi));\n\n        if(t[b]==2) ai += x;\n        repl(i,1,x) vec[ai + i].pb(mp(c, bi));\n\n        ai = a*2*x;\n        if(t[b]==0) ai += x;\n        repl(i,1,min(c+1,x)) vec[ai + i].pb(mp(c, bi));\n      }\n      else {\n        // 0->2, 2->0\n        if(t[a]==2) ai += x;\n        else bi += x;\n        if(x <= c) vec[ai].pb(mp(c, bi));\n      }\n\n      swap(a,b);\n    } // make edges\n  }\n\n  priority_queue<P, vector<P>, greater<P>> pq;\n  fill(d, d + 2*x*n, INF);\n  d[0] = 0;\n  pq.push(mp(0,0));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    if(d[p.se] < p.fi) continue;\n    for(auto to : vec[p.se]){\n      long nd = p.fi + to.fi;\n      int ni = to.se;\n      if(d[ni] > nd){\n        pq.push(mp(nd,ni));\n        d[ni] = nd;\n      }\n    }\n  }\n\n  long ans = INF;\n  rep(i,2*x) ans = min(ans, d[(n-1)*2*x + i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl;\n#define LINE cout << \"line : \" << __LINE__ << endl;\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nll dist[10010][610];\t//time from start to room_i and after j_min left prev room\n\nstruct Edge{ int to, cost; };\nvector<Edge> es[10010];\ntemplate<typename T> T chmax(T& a, const T& b){return a = max(a, b);}\ntemplate<typename T> T chmin(T& a, const T& b){return a = min(a, b);}\n\nint main(){\n\tint n, m, x;\n\tcin >> n >> m >> x;\n\tvi t(n);\n\trep(i, n) cin >> t[i];\n\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tb--;\n\t\tes[a].pb({b, c});\n\t\tes[b].pb({a, c});\n\t}\n\n\tconst int Base = 203;\n\trep(i, 10010) rep(j, 610) dist[i][j] = 1e18;\n\tauto dijkstra = [&] {\n\t\ttypedef pair<pair<long, int>, pii> P;\t//cost from time prv_state:0->hot, 1->normal, 2->cool\n\t\tpriority_queue<P,vector<P>,greater<P> > q;\n\t\tq.push({{0LL, 0}, {x, t[0]}});\n\t\tdist[0][0] = 0LL;\n\t\twhile(!q.empty()) {\n\t\t\tP p = q.top();\tq.pop();\n\t\t\tll cost = p.fi.fi;\n\t\t\tint from = p.fi.se, time = p.se.fi, ps = p.se.se;\n\t\t\t//dump(cost);dump(from);dump(time);dump(ps);\n\t\t\tif(cost > dist[from][time+ps*Base]) continue;\n\t\t\tfor(auto& e : es[from]) {\n\t\t\t\tint to = e.to;\n\t\t\t\tll ncst = cost + e.cost;\n\t\t\t\tif(ps != t[to] && t[to] != 1 && time > 0) continue;\n\t\t\t\tint ntime, nstate;\n\t\t\t\tif(t[to] == 1) {\n\t\t\t\t\tntime = (ps == 1 ? 0 : max(0, time - e.cost));\n\t\t\t\t\tnstate = (ntime == 0 ? 1: ps);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tntime = max(0, x - e.cost);\n\t\t\t\t\tnstate = ntime == 0 ? 1 : t[to];\n\t\t\t\t}\n\t\t\t\tif(ncst < dist[to][ntime+nstate*Base]) {\n\t\t\t\t\tdist[to][ntime+nstate*Base] = ncst;\n\t\t\t\t\tq.push({{ncst, to}, {ntime, nstate}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tdijkstra();\n\tll ans = 1e18;\n\trep(j, 610) chmin(ans, dist[n-1][j]);\n\tcout << ans << endl;\n\t// #ifdef DEBUG_MODE\n\t// //DEBUG_2D\n\t// for(int i = n-1; i < n; i++) {\n\t// \tfor(int j = 0; j < 610; j++) if(dist[i][j] == 1e18) cout <<\"  \"; else printf(\"%3d\",dist[i][j]);\n\t// \tprintf(\"\\n\");\n\t// }\n\t// #endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl;\n#define LINE cout << \"line : \" << __LINE__ << endl;\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nll dist[10010][610];\t//time from start to room_i and after j_min left prev room\n\nstruct Edge{ int to, cost; };\nvector<Edge> es[10010];\ntemplate<typename T> T chmax(T& a, const T& b){return a = max(a, b);}\ntemplate<typename T> T chmin(T& a, const T& b){return a = min(a, b);}\n\nint main(){\n\tint n, m, x;\n\tcin >> n >> m >> x;\n\tvi t(n);\n\trep(i, n) cin >> t[i];\n\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tb--;\n\t\tes[a].pb({b, c});\n\t\tes[b].pb({a, c});\n\t}\n\n\tconst int Base = 203;\n\trep(i, 10010) rep(j, 610) dist[i][j] = 1e18;\n\tauto dijkstra = [&] {\n\t\ttypedef pair<pair<long, int>, pii> P;\t//cost from time prv_state:0->hot, 1->normal, 2->cool\n\t\tpriority_queue<P,vector<P>,greater<P> > q;\n\t\tq.push({{0LL, 0}, {x, t[0]}});\n\t\tdist[0][0] = 0LL;\n\t\twhile(!q.empty()) {\n\t\t\tP p = q.top();\tq.pop();\n\t\t\tll cost = p.fi.fi;\n\t\t\tint from = p.fi.se, time = p.se.fi, ps = p.se.se;\n\t\t\t//dump(cost);dump(from);dump(time);dump(ps);\n\t\t\tif(cost > dist[from][time+ps*Base]) continue;\n\t\t\tfor(auto& e : es[from]) {\n\t\t\t\tint to = e.to;\n\t\t\t\tll ncst = cost + e.cost;\n\t\t\t\tif(ps != 1 && ps != t[to] && t[to] != 1 && time - e.cost > 0) continue;\n\t\t\t\tint ntime, nstate;\n\t\t\t\tif(t[to] == 1) {\n\t\t\t\t\tntime = (ps == 1 ? 0 : max(0, time - e.cost));\n\t\t\t\t\tnstate = (ntime == 0 ? 1: ps);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tntime = x;\n\t\t\t\t\tnstate = ntime == 0 ? 1 : t[to];\n\t\t\t\t}\n\t\t\t\tif(ncst < dist[to][ntime+nstate*Base]) {\n\t\t\t\t\tdist[to][ntime+nstate*Base] = ncst;\n\t\t\t\t\tq.push({{ncst, to}, {ntime, nstate}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tdijkstra();\n\tll ans = 1e18;\n\trep(j, 610) chmin(ans, dist[n-1][j]);\n\tcout << ans << endl;\n\t// #ifdef DEBUG_MODE\n\t// //DEBUG_2D\n\t// for(int i = n-1; i < n; i++) {\n\t// \tfor(int j = 0; j < 610; j++) if(dist[i][j] == 1e18) cout <<\"  \"; else printf(\"%3d\",dist[i][j]);\n\t// \tprintf(\"\\n\");\n\t// }\n\t// #endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 112000000012345678LL\n\nusing P = pair<long,int>;\n// cost, idx\n\nint t[10005];\n\nlong d[200*2*10005];\nvector<P> vec[200*2*10005];\n\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  rep(i,n) cin>>t[i];\n\n  rep(_,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    rep(__,2){\n      int ai = a*2*x, bi = b*2*x;\n      if(t[b]==1){\n        if(t[a]!=1){\n          // [0,2] -> 1\n          if(t[a]==2) bi += x;\n          vec[ai].pb(mp(c, bi + max(0, x-c)));\n        }\n        else {\n          // 1 -> 1\n          vec[ai].pb(mp(c, bi));\n          repl(i,1,x){\n            vec[ai+i].pb(mp(c, bi + max(0, i-c)));\n            vec[ai+x+i].pb(mp(c, bi + ((i-c>0)?(x+i-c):0) ));\n          }\n        }\n      }\n      else if(t[a] == t[b]){\n        // 0 -> 0, 2 -> 2\n        vec[ai].pb(mp(c, bi));\n      }\n      else if(t[a]==1){\n        // 1 -> 2, 1 -> 0\n        vec[ai].pb(mp(c, bi));\n\n        if(t[b]==2) ai += x;\n        repl(i,1,x) vec[ai + i].pb(mp(c, bi));\n\n        ai = a*2*x;\n        if(t[b]==0) ai += x;\n        repl(i,1,min(c+1,x)) vec[ai + i].pb(mp(c, bi));\n      }\n      else {\n        // 0->2, 2->0\n        if(t[a]==2) ai += x;\n        else bi += x;\n        if(x <= c) vec[ai].pb(mp(c, bi));\n      }\n\n      swap(a,b);\n    } // make edges\n  }\n\n  priority_queue<P, vector<P>, greater<P>> pq;\n  fill(d, d + 2*x*n, INF);\n  d[0] = 0;\n  pq.push(mp(0,0));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    if(d[p.se] < p.fi) continue;\n    for(auto to : vec[p.se]){\n      long nd = p.fi + to.fi;\n      int ni = to.se;\n      if(d[ni] > nd){\n        pq.push(mp(nd,ni));\n        d[ni] = nd;\n      }\n    }\n  }\n\n  long ans = INF;\n  rep(i,2*x) ans = min(ans, d[(n-1)*2*x + i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\nconst int INF = 1000000000;\nstruct edge { int to, cost; };\n\nint n, m, x, a, b, di, t[100000];\n\nvector<edge> G[100000];\nint d[100000][401];\n\nint dijkstra() {\n  const int maxX = x * 2 + 1;\n  const int maxPlus = x; // 1 ~ maxPlus => hot / maxPlus + 1 ~ maxX - 1 => cold\n  for (int i = 0; i < n; i++) for (int j = 0; j < maxX; j++) d[i][j] = INF;\n  int num = x + 1;\n  d[0][num] = 0;\n  priority_queue<Q, vector<Q>, greater<Q> > que;\n  que.push(Q(0, P(0, num)));\n  while (!que.empty()) {\n    Q q = que.top(); que.pop();\n    int cost = q.first, from = q.second.first;\n    num = q.second.second;\n    if (d[from][num] < cost) continue;\n    if (d[from][0] < cost) continue;\n    for (int i = 0; i < G[from].size(); i++) {\n      edge e = G[from][i];\n      int to = e.to, newcost = cost + e.cost, newnum = num;\n      if (d[to][0] <= newcost) continue;\n      if (newnum > 0 && newnum <= maxPlus) newnum = max(0, newnum - e.cost);\n      if (maxPlus < newnum) {\n        newnum = newnum + e.cost;\n        if (newnum >= maxX) newnum = 0;\n      }\n      if (newnum != 0) {\n        if (t[to] == 1 && newnum > maxPlus) continue;\n        if (t[to] == -1 && newnum <= maxPlus) continue;\n      }\n      if (t[to] == 1) newnum = x;\n      if (t[to] == -1) newnum = x + 1;\n      if (d[to][newnum] <= newcost) continue;\n      d[to][newnum] = newcost;\n      que.push(Q(newcost, P(to, newnum)));\n    }\n  }\n  int ans = INF;\n  for (int i = 0; i < maxX; i++) ans = min(ans, d[n - 1][i]);\n  return ans;\n}\n\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &x);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &t[i]), t[i]--;\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &a, &b, &di);\n    a--; b--;\n    edge e1, e2;\n    e1.to = b, e2.to = a;\n    e1.cost = e2.cost = di;\n    G[a].push_back(e1);\n    G[b].push_back(e2);\n  }\n  printf(\"%d\\n\", dijkstra());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, cost;\n    Corridor(int target, int cost): target(target), cost(cost) {}\n};\n\nstruct Room {\npublic:\n    int id, type;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int type): id(id), type(type) {}\n};\n\nstruct State {\n    int id, time, prev_type, d;\n    State(int id, int time, int prev_type, int d): id(id), time(time), prev_type(prev_type), d(d) {}\n    bool operator < (const State &s) const {\n        return time > s.time;\n    };\n};\n\nint N, M, X;\nRoom rooms[MAX];\nint min_time[MAX][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[0][0][0] = 0;\n    PQ.push(State(0, 0, COLD, 0));\n    int ans = INT_MAX, next_time, next_type, next_d;\n    while(!PQ.empty()) {\n        if(PQ.top().id == N - 1) {\n            ans = min(ans, PQ.top().time);\n            PQ.pop();\n            continue;\n        }\n        if(PQ.top().time > ans) break;\n        for(auto c: rooms[PQ.top().id].edge) {\n            next_d = min(X, PQ.top().d + c.cost);\n            next_time = PQ.top().time + c.cost;\n            if(abs(PQ.top().prev_type - rooms[c.target].type) > 1 && next_d < X) continue;\n            if(rooms[c.target].type == CONFORTABLE) {\n                next_type = PQ.top().prev_type;\n                if(min_time[c.target][next_type / 2][next_d] <= next_time) continue;\n                min_time[c.target][next_type / 2][next_d] = next_time;\n                PQ.push(State(c.target, next_time, next_type, next_d));\n            } else {\n                next_type = rooms[c.target].type;\n                if(min_time[c.target][next_type / 2][0] <= next_time) continue;\n                min_time[c.target][next_type / 2][0] = next_time;\n                PQ.push(State(c.target, next_time, next_type, 0));\n            }\n        }\n        PQ.pop();\n    }\n    return ans;\n}\n\nint main() {\n    int t, a, b, d;\n    scanf(\"%d %d %d\", &N, &M, &X);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &t);\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &a, &b, &d);\n        a--;\n        b--;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n){\n        cin>>t[i];\n        if (t[i]==1)t[i]=2;\n        else if (t[i]==2)t[i]=1;\n    }\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        if (d[v][type][tim] < dist) continue;\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 2) {\n                u = e.to, ntype = type, ntim = min(x, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = t[e.to], ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, cost;\n    Corridor(int target, int cost): target(target), cost(cost) {}\n};\n\nstruct Room {\npublic:\n    int id, type;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int type): id(id), type(type) {}\n};\n\nstruct State {\n    int id, time, prev_type, d;\n    State() {};\n    State(int id, int time, int prev_type, int d): id(id), time(time), prev_type(prev_type), d(d) {};\n    bool operator < (const State &s) const {\n        return time > s.time;\n    }\n};\n\nint N, M, X;\nRoom rooms[MAX];\nint min_time[MAX][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[0][0][0] = 0;\n    PQ.push(State(0, 0, COLD, 0));\n    int ans = INT_MAX, next_time, next_d;\n    State s;\n    while(!PQ.empty()) {\n        s = PQ.top();\n        PQ.pop();\n        if(s.id == N - 1) {\n            ans = min(ans, s.time);\n            continue;\n        }\n        if(s.time > ans) break;\n        for(auto c: rooms[s.id].edge) {\n            next_d = min(X, s.d + c.cost);\n            next_time = s.time + c.cost;\n            if(abs(s.prev_type - rooms[c.target].type) > 1 && next_d < X) continue;\n            if(rooms[c.target].type == CONFORTABLE) {\n                if(min_time[c.target][s.prev_type / 2][next_d] < next_time) continue;\n                min_time[c.target][s.prev_type / 2][next_d] = next_time;\n                PQ.push(State(c.target, next_time, s.prev_type, next_d));\n            } else {\n                if(min_time[c.target][rooms[c.target].type / 2][0] < next_time) continue;\n                min_time[c.target][rooms[c.target].type / 2][0] = next_time;\n                PQ.push(State(c.target, next_time, rooms[c.target].type, 0));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int t, a, b, d;\n    scanf(\"%d %d %d\", &N, &M, &X);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &t);\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &a, &b, &d);\n        a--;\n        b--;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = 10000000;\n\nint n,m,x;\nint room[10000];\nvector<PII> pass[10000]; // [from] = (cost, to)\n\nstruct state{\n\tint d, p, d2;\n\tbool cold;\n\tbool operator<(const state& a) const {\n\t\treturn d == a.d ? d2 > a.d2 : d < a.d;\n\t}\n};\n\n// ????????????????????¨?±?i????????£??¨????????????????????§??\\?????????????????????????????¨?±??????????h?????¨?±???????\n//?????????????????¢????????????distc[h][i]\nint distc[2][10000];\n\nint main() {\n\tcin>>n>>m>>x;\n\tREP(i,n)cin >> room[i];\n\tREP(i,m){\n\t\tint a,b,d;\n\t\tcin >> a >> b >> d;\n\t\ta--;b--;\n\t\tpass[a].push_back(MP(d,b));\n\t\tpass[b].push_back(MP(d,a));\n\t}\n\tREP(i,n){\n\t\tSORT(pass[i]);\n\t\tUNIQUE(pass[i]);\n\t}\n\n\tpriority_queue<state> q;\n\tq.push((state){0,0,0,true});\n\n\tint dist[n];\n\tREP(i,n)dist[i]=INF;\n\tdist[0]=0;\n\n\twhile(!q.empty()){\n\t\tstate s = q.top();q.pop();\n\t\tEACH(i,pass[s.p]){\n\t\t\tint d = (*i).first,p = (*i).second;\n\t\t\tint nd = s.d + d;\n\t\t\tint nd2 = s.d2 + d;\n\t\t\tif(room[p]==1){\n\t\t\t\t// ?????¢???????????????????????????\n\t\t\t\t// ????????????d2?????´??°??§??????????????????\n\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\tdistc[s.cold][p] = nd2;\n\t\t\t\t\tq.push((state){nd, p, nd2, s.cold});\n\t\t\t\t}else if(distc[s.cold][p] < x){\n\t\t\t\t\tdistc[s.cold][p] = nd2;\n\t\t\t\t\tq.push((state){nd, p, nd2, s.cold});\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// cold????????¢????????????d2???????????????d???????????????d2=0???????????´??°\n\t\t\t\t// cold????????¢??????????????????d????????????d2=0\n\t\t\t\tif(s.cold == !!room[p]){ // ?????¢\n\t\t\t\t\tif(nd2 < x)continue; // ??\\???????????????\n\t\t\t\t\t// ??\\???????????????d2=0????????§??????????????´??????????????¨\n\t\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\t\tq.push((state){nd, p, 0, !room[p]});\n\t\t\t\t\t}\n\t\t\t\t}else{ // ?????¢?????????\n\t\t\t\t\t// ??\\???????????§?????????????????´??????????????¨\n\t\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\t\tq.push((state){nd, p, 0, !room[p]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[n-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<list>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<functional>\n#include<queue>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10010];\nvector<P>rinsetu[10010];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10010][4][301];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost,0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < c; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, cost;\n    Corridor(int target, int cost): target(target), cost(cost) {}\n};\n\nstruct Room {\npublic:\n    int id, type;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int type): id(id), type(type) {}\n};\n\nstruct State {\n    int id, time, prev_type, d;\n    State() {};\n    State(int id, int time, int prev_type, int d): id(id), time(time), prev_type(prev_type), d(d) {};\n    bool operator < (const State &s) const {\n        return time > s.time;\n    }\n};\n\nint N, M, X;\nRoom rooms[MAX];\nint min_time[MAX][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[0][0][0] = 0;\n    PQ.push(State(0, 0, COLD, 0));\n    int ans = INT_MAX, next_time, next_d;\n    State s;\n    while(!PQ.empty()) {\n        s = PQ.top();\n        PQ.pop();\n        if(s.id == N - 1) {\n            ans = min(ans, s.time);\n            continue;\n        }\n        if(s.time > ans) break;\n        for(auto c: rooms[s.id].edge) {\n            next_d = min(X, s.d + c.cost);\n            next_time = s.time + c.cost;\n            if(abs(s.prev_type - rooms[c.target].type) > 1 && next_d < X) continue;\n            if(rooms[c.target].type == CONFORTABLE) {\n                if(min_time[c.target][s.prev_type / 2][next_d] < next_time) continue;\n                min_time[c.target][s.prev_type / 2][next_d] = next_time;\n                PQ.push(State(c.target, next_time, s.prev_type, next_d));\n            } else {\n                if(min_time[c.target][rooms[c.target].type / 2][0] < next_time) continue;\n                min_time[c.target][rooms[c.target].type / 2][0] = next_time;\n                PQ.push(State(c.target, next_time, rooms[c.target].type, 0));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cout << sizeof(min_time) << endl;\n    cout << sizeof(rooms) << endl;\n    int t, a, b, d;\n    scanf(\"%d %d %d\", &N, &M, &X);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &t);\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &a, &b, &d);\n        a--;\n        b--;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n    cout << sizeof(min_time) << endl;\n    cout << sizeof(rooms) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint t[10000];\nvector<P>E[10000];\nint d[10000][201][201];//cold,hot\n\nstruct st {\n\tint u, c, a, b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint n, m, x; scanf(\"%d%d%d\", &n, &m, &x);\n\trep(i, n)scanf(\"%d\", &t[i]);\n\trep(i, m) {\n\t\tint a, b, d; scanf(\"%d%d%d\", &a, &b, &d); a--; b--;\n\t\tE[a].push_back(P(d, b)); E[b].push_back(P(d, a));\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\td[0][0][x] = 0; que.push({ 0,0,0,x });\n\twhile (!que.empty()) {\n\t\tst s = que.top(); que.pop();\n\t\tif (d[s.u][s.a][s.b] != s.c)continue;\n\t\tfor (P v : E[s.u]) {\n\t\t\tint a = min(x, s.a + v.first), b = min(x, s.b + v.first);\n\t\t\tif (t[v.second] == 0) {\n\t\t\t\tif (b < x)continue;\n\t\t\t\ta = 0;\n\t\t\t}\n\t\t\tif (t[v.second] == 2) {\n\t\t\t\tif (a < x)continue;\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t\tif (d[v.second][a][b] > s.c + v.first) {\n\t\t\t\td[v.second][a][b] = s.c + v.first;\n\t\t\t\tque.push({ v.second, d[v.second][a][b],a,b });\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, x + 1)rep(j, x + 1) {\n\t\tMin = min(Min, d[n - 1][i][j]);\n\t}\n\tprintf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\nvoid mmin(int &a, int b) { a = min(a, b); }\nvoid mmax(int &a, int b) { a = max(a, b); }\nvoid sor(vel &v) { sort(v.begin(), v.end()); }\nint zero() { return 0; }\nvoid swap(vel &que, vel &pos, int i, int j) {\n\tint x = que[i];\n\tint y = que[j];\n\tpos[x] = j; pos[y] = i;\n\tque[i] = y; que[j] = x;\n}\nvoid down(vel &que, vel &pos, vel &va, int n) {\n\tint i = 1;\n\twhile (i * 2 <= n) {\n\t\tif (i * 2 == n) {\n\t\t\tswap(que, pos, i, 2 * i);\n\t\t\ti = 2 * i;\n\t\t}\n\t\telse {\n\t\t\tif (va[que[2 * i]] < va[que[2 * i + 1]]) {\n\t\t\t\tswap(que, pos, i, 2 * i);\n\t\t\t\ti = 2 * i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(que, pos, i, 2 * i + 1);\n\t\t\t\ti = 2 * i + 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid up(vel &que, vel &pos, vel &va, int i) {\n\twhile (i > 1) {\n\t\tint j = i / 2;\n\t\tif (va[que[i]] < va[que[j]]) {\n\t\t\tswap(que, pos, j, i);\n\t\t\ti = j;\n\t\t}\n\t\telse i = 0;\n\t}\n}\nsigned main() {\n\tint n, m, x;\n\tcin >> n >> m >> x;\n\tvel fr(m);\n\tvel to(m);\n\tvel cos(m);\n\tvel ko(n);\n\tvel te(n);\n\tfor (int i = 0; i < n; i++) { cin >> te[i]; }\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> fr[i] >> to[i] >> cos[i];\n\t\tfr[i]--; to[i]--;\n\t\tko[fr[i]]++; ko[to[i]]++;\n\t}\n\tvvel way(n); vel cou(n, 0);\n\tfor (int i = 0; i < n; i++) { way[i] = vel(ko[i]); }\n\tvvel wac = way;\n\tfor (int i = 0; i < m; i++) {\n\t\tway[fr[i]][cou[fr[i]]] = to[i];\n\t\tway[to[i]][cou[to[i]]] = fr[i];\n\t\twac[fr[i]][cou[fr[i]]] = cos[i];\n\t\twac[to[i]][cou[to[i]]] = cos[i];\n\t\tcou[fr[i]]++; cou[to[i]]++;\n\t}\n\tint var = n * (x + 1) * 3;//n,3,x+1\n\tint ma = var * 200 + 1;\n\tint fl = 0;\n\tvel que(var + 1);\n\tvel pos(var);\n\tfor (int i = 0; i < var; i++) {\n\t\tque[i + 1] = i; pos[i] = i + 1;\n\t}\n\tvel va(var, ma);\n\tvel dij(var, ma);\n\tdij[0] = 0; int ans;\n\twhile (fl == 0) {\n\t\tint fr1 = que[1];\n\t\tva[fr1] = ma;\n\t\tint po1 = fr1 / (3 * x + 3);\n\t\tint tm1 = fr1 % (3 * x + 3);\n\t\tint te1 = tm1 / (x + 1);\n\t\tint mi1 = tm1 % (x + 1);\n\t\tif (po1 == n - 1) fl = 1; ans = dij[fr1];\n\t\tdown(que, pos, va, var);\n\t\tfor (int nu = 0; nu < ko[po1]; nu++) {\n\t\t\tint po2 = way[po1][nu];\n\t\t\tint ok = 0;\n\t\t\tint nmi = min(mi1 + wac[po1][nu], x);\n\t\t\tif (te[po2] == 1) {\n\t\t\t\tint to1 = po2 * (3 * x + 3) + te1 * (x + 1) + nmi;\n\t\t\t\tif (dij[to1] > dij[fr1] + wac[po1][nu]) {\n\t\t\t\t\tdij[to1] = dij[fr1] + wac[po1][nu];\n\t\t\t\t\tva[to1] = dij[to1];\n\t\t\t\t\tup(que, pos, va, pos[to1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (nmi >= x or te[po2] == te1) {\n\t\t\t\tint to1 = po2 * (3 * x + 3) + te[po2] * (x + 1);\n\t\t\t\tif (dij[to1] > dij[fr1] + wac[po1][nu]) {\n\t\t\t\t\tdij[to1] = dij[fr1] + wac[po1][nu];\n\t\t\t\t\tva[to1] = dij[to1];\n\t\t\t\t\tup(que, pos, va, pos[to1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//[??????, ????????¶???(0????????????, 1????????????), ????????????(0???X)]?????¶?´??????¶???????????§??????????????????????????§?????????\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <functional>\n#define int long long\nusing namespace std;\n\nint n, m, x;\nint t[10000];\nvector<int> et[10000];\nvector<int> ec[10000];\n\nint dp[10000][2][201];\n\nvoid input() {\n\tint i, j;\n\t\n\tcin >> n >> m >> x;\n\tfor (i = 0; i < n; i++) { cin >> t[i]; }\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tcin >> a >> b >> d;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tec[a].push_back(d);\n\t\tet[b].push_back(a);\n\t\tec[b].push_back(d);\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j <= x; j++) {\n\t\t\tdp[i][0][j] = 1145141919893810;\n\t\t\tdp[i][1][j] = 1145141919893810;\n\t\t}\n\t}\n}\n\ntypedef tuple<int, int, int, int> T;\t//cost, vertex, state, rem_time\npriority_queue<T, vector<T>, greater<T> > que;\n\nvoid dijkstra() {\n\tque.push(T(0, 0, 0, x));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.top();\n\t\tque.pop();\n\t\t\n\t\tint cst   = get<0>(now);\n\t\tint pos   = get<1>(now);\n\t\tint state = get<2>(now);\n\t\tint timer = get<3>(now);\n\t\t\n\t\tif (dp[pos][state][timer] <= cst) {\n\t\t\tcontinue;\n\t\t}\n\t\tdp[pos][state][timer] = cst;\n\t\t\n\t\tfor (int i = 0; i < et[pos].size(); i++) {\n\t\t\tint v = et[pos][i];\n\t\t\tint d = ec[pos][i];\n\t\t\t\n\t\t\tif (t[v] == 1) {\t//??????\n\t\t\t\tque.push(T(cst + d, v, state, max(0LL, timer - d)));\n\t\t\t}\n\t\t\telse if (t[v] / 2 == state) {\t//????????°?¢? (??????????????¨??°?¢??????????)\n\t\t\t\tque.push(T(cst + d, v, state, x));\n\t\t\t}\n\t\t\telse {\t//??°?¢???????\n\t\t\t\tif (d < timer) continue;\n\t\t\t\tque.push(T(cst + d, v, !state, x));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tinput();\n\tdijkstra();\n\t\n\tint ans = 1145141919893810;\n\tfor (int i = 0; i <= x; i++) {\n\t\tans = min(ans, dp[n-1][0][i]);\n\t\tans = min(ans, dp[n-1][1][i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<list>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<functional>\n#include<queue>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10010];\nvector<P>rinsetu[10010];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10010][4][301];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tfor (int x = 0; x < a; x++) {\n\t\tfor (int y = 0; y < 3; y++) {\n\t\t\tfor (int z = 0; z < c; z++) {\n\t\t\t\tmincost[x][y][z] = 1 << 29;\n\t\t\t}\n\t\t}\n\t}\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < c; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-7)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tint x;\n                                        \tint y,z,w;\n                                        \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\nunsigned int randxor()\n{\n    static unsigned int x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned int t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\npriority_queue<pa4,vector<pa4>,greater<pa4>> pq;\nint dis[10001][2][202];\nvector<pa> G[10200];\nint t[10200];\n\n  signed main(){\n  \t              cin.tie(0);\n    \t\tios::sync_with_stdio(false);\n\nint n,m,x;\n  \tcin>>n>>m>>x;\n\n  for(int i=0;i<10001;i++)for(int j=0;j<2;j++)for(int k=0;k<202;k++)dis[i][j][k]=-1;\n  \tfor(int i=1;i<=n;i++)cin>>t[i];\n  \tfor(int i=0;i<m;i++){\n  \t\tint y,yy,yyy;\n  \t\tcin>>y>>yy>>yyy;\n  \t\tG[y].pb(mp(yy,yyy));\n  \t\tG[yy].pb(mp(y,yyy));\n  \t}\n  \t\tpq.push({0,1,0,0});\n  \t\n  \t// 0 samui\n  \t// 1 atui\n  \t\n  \twhile(1){\n  \t\tpa4 z=pq.top();\n  \t\tpq.pop();\n  \t\tif(dis[z.y][z.z][z.w]>=0) continue;\n  \t\tdis[z.y][z.z][z.w]=z.x;\n  \t//\tcout<<z.y<<\" \"<<z.z<<\" \"<<z.w<<\"   \"<<z.x<<endl;\n  \t\tif(z.y==n){\n  \t\tcout<<z.x<<endl;\n  \t\t\treturn 0;\n  \t\t}\n  \t\t\n  \t\tfor(auto v:G[z.y]){\n  \t\t\tif(t[v.first]==0){\n  \t\t\t\tif(z.z==0){\n  \t\t\t\t\t\tpq.push({z.x+v.second,v.first,0,0});\n  \t\t\t\t}\n  \t\t\t\telse{\n  \t\t\t\t\tif(z.w+v.second>=x)pq.push({z.x+v.second,v.first,0,0}); \n  \t\t\t\t}\n  \t\t\t\t\n  \t\t\t}\n  \t\t\telse if(t[v.first]==2){\n  \t\t\t\tif(z.z==1){\n  \t\t\t\t\t\tpq.push({z.x+v.second,v.first,1,0});\n  \t\t\t\t}\n  \t\t\t\telse{\n  \t\t\t\t\tif(z.w+v.second>=x)pq.push({z.x+v.second,v.first,1,0}); \n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse{\n  \t\t\t\t{\n  \t\t\t\t\t\t\tpq.push({z.x+v.second,v.first,z.z,min(x,z.w+v.second)});\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t\n  \t\t}\n  \t\t\n  \t}\n  \t\n  \t\n  \treturn 0;\n                }\n                \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n){\n        cin>>t[i];\n        if (t[i]==2)t[i]=1;\n        else if (t[i]==1)t[i]=2;\n    }\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (d[v][type][tim] < dist) continue;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 2) {\n                u = e.to, ntype = type, ntim = min(x, tim+e.cost);\n            } else {\n                if (t[v] != t[e.to] && tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define INF (1000000000000000000LL)\n\ntypedef pair<long long, int> P;\n\nstruct Q {\n    long long time;\n    long long togo;\n    int status;\n    int room;\n    Q() {}\n    Q(long long a,long long b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    long long X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n        --T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        to[a-1].push_back(P((long long)d,b-1));\n        to[b-1].push_back(P((long long)d,a-1));\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    vector<long long> time(N,INF);\n//    unordered_map<int,long long> um;\n\n    q.push(Q(0LL,X,-1,0));\n\n    while(true) {\n        Q now=q.top(); q.pop();\n        if(T[now.room]!=0 && time[now.room]<now.time) continue;\n        time[now.room]=now.time;\n        if(now.room==N-1) break;\n        for(auto nxt : to[now.room]) {\n            if(T[nxt.second]!=0 && time[nxt.second]<now.time+nxt.first) continue;\n\n            if(T[nxt.second]==0) {\n//                um[nxt.second]=min(um[nxt.second],now.time+nxt.first);\n                q.push(Q(now.time+nxt.first,max(0LL,now.togo-nxt.first),now.status,nxt.second));\n            } else if(T[nxt.second]==now.status || nxt.first>=now.togo) {\n                time[nxt.second]=now.time+nxt.first;\n                q.push(Q(time[nxt.second],X,T[nxt.second],nxt.second));\n            }\n        }\n    }\n\n    cout << time[N-1] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nstruct edge {\n    int to, weight;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N, M, X;\n    cin >> N >> M >> X;\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n    }\n    graph g(N);\n    for(int i=0; i<M; ++i) {\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--; b--;\n        g[a].push_back((edge){b, d});\n        g[b].push_back((edge){a, d});\n    }\n    \n    using state = tuple<int, int, int, int>;\n    vector<vector<vector<int>>> d(N, vector<vector<int>>(3, vector<int>(X+1, INF)));\n    d[0][0][X] = 0;\n    priority_queue<state, vector<state>, greater<state>> que;\n    que.push(make_tuple(0, 0, 0, X));\n    while(!que.empty()) {\n        int cd, v, t, x;\n        tie(cd, v, t, x) = que.top();\n        que.pop();\n        if(d[v][t][x] < cd) {\n            continue;\n        }\n        for(auto& e : g[v]) {\n            int nx = (T[e.to] == 1 ? max(0, x - e.weight) : X);\n            if(T[e.to] == 1 && d[e.to][t][nx] > d[v][t][x] + e.weight) {\n                d[e.to][t][nx] = d[v][t][x] + e.weight;\n                que.push(make_tuple(d[e.to][t][nx], e.to, t, nx));\n            } else if(T[e.to] != 1 && (T[e.to] != t && x <= e.weight || T[e.to] == t)) {\n                if(d[e.to][T[e.to]][nx] > d[v][t][x] + e.weight) {\n                    d[e.to][T[e.to]][nx] = d[v][t][x] + e.weight;\n                    que.push(make_tuple(d[e.to][T[e.to]][nx], e.to, T[e.to], nx));\n                }\n            }\n        }\n    }\n    int res = INF;\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<X+1; ++j) {\n            res = min(res, d[N-1][i][j]);\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint T[10000];\nstruct edge {\n\tint to, d;\n};\n\nvector<edge> G[10000];\n\nint dist[10000][3][210];\n\nstruct S {\n\tint v, hot, rem, d;\n\tbool operator <(const S& x) const {\n\t\treturn d > x.d;\n\t}\n};\n\nint rec(S s) {\n\treturn dist[s.v][s.hot][s.rem];\n}\n\nvoid save(S s) {\n\tdist[s.v][s.hot][s.rem] = s.d;\n}\n\nconst int COLD = 0;\nconst int GOOD = 1;\nconst int HOT = 2;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, X;\n\tcin >> N >> M >> X;\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor(int i = 0; i < M; i++) {\n\t\tint a, b, d;\n\t\tcin >> a >> b >> d;\n\t\ta--, b--;\n\t\tG[a].push_back({ b, d });\n\t\tG[b].push_back({ a, d });\n\t}\n\n\tconst int INF = 1 << 25;\n\tfill((int*)begin(dist), (int*)end(dist), INF);\n\tdist[0][COLD][X] = 0;\n\tpriority_queue<S> q;\n\tq.push({ 0, COLD, X, 0 });\n\twhile(q.size()) {\n\t\tS s = q.top();\n\t\tq.pop();\n\t\t//cerr << \"s.v : \" << s.v << \", s.hot : \" << s.hot << \", s.rem : \" << s.rem << endl;\n\t\tif(s.v == N - 1) {\n\t\t\tcout << s.d << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(auto e : G[s.v]) {\n\t\t\tint nrem = max(s.rem - e.d, 0);\n\t\t\tif(s.hot == HOT && T[e.to] == COLD && nrem > 0) continue;\n\t\t\tif(s.hot == COLD && T[e.to] == HOT && nrem > 0) continue;\n\t\t\tif(T[e.to] != GOOD) nrem = X;\n\t\t\tint nt = T[e.to] == GOOD ? s.hot : T[e.to];\n\t\t\tS ns = { e.to, nt, nrem, s.d + e.d };\n\t\t\tif(rec(ns) > ns.d) {\n\t\t\t\t//cerr << \"\\t\" << \"ns.v : \" << ns.v << \", ns.hot : \" << ns.hot << \", ns.rem : \" << ns.rem << endl;\n\t\t\t\tsave(ns);\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cassert>\n#include<cstring>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge { int dst,w; };\nstruct Data {\n  int cur, w, type, x;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w > data.w;\n    if( x != data.x ) return x > data.x;\n    if( type != data.type ) return type > data.type;\n    return cur > data.cur;\n  }\n};\nint V,E,X;\n\n#define MAX_V 10010\nvector<Edge> G[MAX_V];\nvector<int> state;\nint mini[MAX_V][3][210];\n\nvoid compute() {\n  rep(i,V) rep(j,3) rep(k,210) mini[i][j][k] = INT_MAX;\n  mini[0][0][X] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0,0,X});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      int dst = e.dst;\n      int nx  = max(data.x - e.w,0);\n      if( nx && state[dst] != 1 && state[dst] != data.type ) continue;\n      if( nx && state[dst] == data.type ) {\n\tnx = X;\n\tif( mini[dst][data.type][nx] > data.w + e.w ) {\n\t  mini[dst][data.type][nx] = data.w + e.w;\n\t  Q.push((Data){dst,data.w+e.w,data.type,nx});\n\t}\n      } else if( nx && state[dst] == 1 ) {\n\tif( mini[dst][data.type][nx] > data.w + e.w ) {\n\t  mini[dst][data.type][nx] = data.w + e.w;\n\t  Q.push((Data){dst,data.w+e.w,data.type,nx});\n\t}\n      } else if( state[dst] == 1 ) {\n\tassert( nx == 0 );\n\tif( mini[dst][data.type][nx] > data.w + e.w ) {\n\t  mini[dst][data.type][nx] = data.w + e.w;\n\t  Q.push((Data){dst,data.w+e.w,data.type,nx});\n\t}\n      } else {\n\tint type = ( ( data.type == 0 ) ? 2 : 0 );\n\tnx = X;\n\tif( mini[dst][type][nx] > data.w + e.w ) {\n\t  mini[dst][type][nx] = data.w + e.w;\n\t  Q.push((Data){dst,data.w+e.w,type,nx});\n\t}\n      }\n    }\n  }\n  int ans = INT_MAX;\n  rep(j,3) rep(k,210) ans = min(ans,mini[V-1][j][k]);\n  cout << ans << endl;\n}\n\nint main() {\n  cin >> V >> E >> X;\n  state.resize(V);\n  rep(i,V) cin >> state[i];\n  rep(i,E) {\n    int s,t,c;\n    cin >> s >> t >> c;\n    --s, --t;\n    G[s].push_back((Edge){t,c});\n    G[t].push_back((Edge){s,c});\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define COLD 0\n#define HOT 1\n#define SUITABLE 2\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,P>Snake;\nconst int INF=1<<30;\nint n,m,limit;\nint min_cost[2][205][10005];\nint temperature[10005];\nvector<P>node[10005];\npriority_queue<Snake,vector<Snake>,greater<Snake> >pq;\nint main(){\n  cin>>n>>m>>limit;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<=limit;j++){\n      for(int k=0;k<=n;k++){\n\tmin_cost[i][j][k]=INF;\n\tif(k==1){\n\t  min_cost[i][j][k]=0;\n\t}\n      }\n    }\n  }\n  \n  for(int i=1;i<=n;i++){\n    int data;\n    cin>>data;\n    if(data==0){\n      temperature[i]=COLD;\n    }else if(data==1){\n      temperature[i]=SUITABLE;\n    }else if(data==2){\n      temperature[i]=HOT;\n    }\n  }\n  for(int i=0;i<m;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    node[a].push_back(P(b,c));\n    node[b].push_back(P(a,c));\n  }\n\n  pq.push(Snake(P(0,1),P(COLD,limit)));\n  while(!pq.empty()){\n    Snake now=pq.top();pq.pop();\n    int cost=now.first.first;\n    int pos=now.first.second;\n    int thermo=now.second.first;\n    int times=now.second.second;\n    for(int i=0;i<node[pos].size();i++){\n      int next=node[pos][i].first;\n      int ncost=node[pos][i].second;\n      int n_thermo=temperature[next];\n      int n_times=max(times-ncost,0);\n      if(n_thermo==SUITABLE){\n\tif(cost+ncost<min_cost[thermo][n_times][next]){\n\t  min_cost[thermo][n_times][next]=cost+ncost;\n\t  pq.push(Snake(P(cost+ncost,next),P(thermo,n_times)));\n\t}\n      }else if(thermo==n_thermo){\n\tif(cost+ncost<min_cost[thermo][limit][next]){\n\t  min_cost[thermo][limit][next]=cost+ncost;\n\t  pq.push(Snake(P(cost+ncost,next),P(n_thermo,limit)));\n\t}\n      }else if(n_times==0){\n\tif(cost+ncost<min_cost[thermo][limit][next]){\n\t  min_cost[thermo][limit][next]=cost+ncost;\n\t  pq.push(Snake(P(cost+ncost,next),P(n_thermo,limit)));\n\t}\n      }\n    }\n  }\n  \n  int minimum=INF;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<=limit;j++){\n      minimum=min(min_cost[i][j][n],minimum);\n    }\n  }\n  cout<<minimum<<endl;\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <bitset>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <list>\n#include <deque>\nusing namespace std;\n#define INF 10000000\n#define LLINF 100000000000000\ntypedef pair<int, int> P;\ntypedef pair<int, P> P2;\ntypedef pair<int, P2> P3;\ntypedef long long ll;\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define VSORT(v) sort(v.begin(), v.end());\n#define fi first\n#define se second\n#define out(x) cout << x << endl;\nint dx[] = { 1, 0, -1, 0 }, dy[] = { 0,1,0,-1 };\nll MOD = 1000000007;\nstruct edge {\n\tll from, to, cost;\n};\n\nint n, m, x;\nvector<P>es[20005];\nint t[10005] = { 0 };\nint dp[10005][3][205] = { 0 };\n\nint main() {\n\tcin >> n >> m >> x;\n\trep(i, n) cin >> t[i];\n\trep(i, m) {\n\t\tint a, b, d;\n\t\tcin >> a >> b >> d;\n\t\ta--; b--;\n\t\tes[a].pb(P(b, d));\n\t\tes[b].pb(P(a, d));\n\t}\n\trep(i, n) {\n\t\trep(j, 3) {\n\t\t\trep(k, 205) {\n\t\t\t\tdp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tpriority_queue<P3, vector<P3>, greater<P3>> que;\n\tque.push(P3(0, P2(0, P(0, 0))));\n\twhile (!que.empty()) {\n\t\tP3 p3 = que.top();\n\t\tque.pop();\n\t\tint nc = p3.first;\n\t\tP2 p2 = p3.second;\n\t\tint v = p2.first;\n\t\tP p = p2.second;\n\t\tint lt = p.first;\n\t\tint td = p.second;\n\t\tif (nc > dp[v][lt][td]) continue;\n\t\tfor (int u = 0; u < es[v].size(); u++) {\n\t\t\tint to = es[v][u].first;\n\t\t\tint cost = es[v][u].second;\n\t\t\tint tmp = dp[v][lt][td] + cost;\n\t\t\tif (t[to] == 1) {\n\t\t\t\tint ntd = td + cost;\n\t\t\t\tif (td + cost > x) {\n\t\t\t\t\tntd = x;\n\t\t\t\t}\n\t\t\t\tif (dp[to][lt][ntd] > tmp) {\n\t\t\t\t\tdp[to][lt][ntd] = tmp;\n\t\t\t\t\tque.push(P3(tmp, P2(to, P(lt, ntd))));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[to] == 0) {\n\t\t\t\tif (lt == 0) {\n\t\t\t\t\tif (dp[to][0][0] > tmp) {\n\t\t\t\t\t\tdp[to][0][0] = tmp;\n\t\t\t\t\t\tque.push(P3(tmp, P2(to, P(0, 0))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (td + cost >= x) {\n\t\t\t\t\t\tif (dp[to][0][0] > tmp) {\n\t\t\t\t\t\t\tdp[to][0][0] = tmp;\n\t\t\t\t\t\t\tque.push(P3(tmp, P2(to, P(0, 0))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[to] == 2) {\n\t\t\t\tif (lt == 2) {\n\t\t\t\t\tif (dp[to][2][0] > tmp) {\n\t\t\t\t\t\tdp[to][2][0] = tmp;\n\t\t\t\t\t\tque.push(P3(tmp, P2(to, P(2, 0))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (td + cost >= x) {\n\t\t\t\t\t\tif (dp[to][2][0] > tmp) {\n\t\t\t\t\t\t\tdp[to][2][0] = tmp;\n\t\t\t\t\t\t\tque.push(P3(tmp, P2(to, P(2, 0))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j <= x; j++) {\n\t\t\tres = min(res, dp[n - 1][i][j]);\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<list>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<functional>\n#include<queue>\n#define int long long\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10000][3][201];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%lld\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tfor (int x = 0; x < a; x++) {\n\t\tfor (int y = 0; y < c; y++) {\n\t\t\tmincost[x][0][y] = mincost[x][1][y] = mincost[x][2][y] = LLONG_MAX / 3;\n\t\t}\n\t}\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = LLONG_MAX / 3;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10000][3][201];//??¨?±?????????????????????????\nsigned main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%lld\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tfor (int x = 0; x < a; x++) {\n\t\tfor (int y = 0; y < c; y++) {\n\t\t\tmincost[x][0][y] = mincost[x][1][y] = mincost[x][2][y] = LLONG_MAX / 3;\n\t\t}\n\t}\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = LLONG_MAX / 3;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, d;\n    Corridor() {};\n    Corridor(int target, int d): target(target), d(d) {}\n};\n\nstruct Room {\npublic:\n    int id, t;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int t): id(id), t(t) {}\n};\n\nstruct State {\n    int id, time, t, d;\n    State(int id, int time, int t, int d): id(id), time(time), t(t), d(d) {};\n    bool operator < (const State &s) const {\n        return time > s.time;\n    }\n};\n\nint N, M, X;\nRoom rooms[MAX + 1];\nint min_time[MAX + 1][2][201];\n\nvoid dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX + 1; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[1][0][0] = 0;\n    PQ.push(State(1, 0, COLD, 0));\n    while(!PQ.empty()) {\n        State s = PQ.top();\n        PQ.pop();\n        for(auto c: rooms[s.id].edge) {\n            if(abs(s.t - rooms[c.target].t) > 1 && s.d + c.d < X) continue;\n            if(rooms[c.target].t == CONFORTABLE) {\n                if(min_time[c.target][s.t / 2][min(X, s.d + c.d)] < s.time + c.d) continue;\n                min_time[c.target][s.t / 2][min(X, s.d + c.d)] = s.time + c.d;\n                PQ.push(State(c.target, s.time + c.d, s.t, min(X, s.d + c.d)));\n            } else {\n                if(min_time[c.target][rooms[c.target].t / 2][0] < s.time + c.d) continue;\n                min_time[c.target][rooms[c.target].t / 2][0] = s.time + c.d;\n                PQ.push(State(c.target, s.time + c.d, rooms[c.target].t, 0));\n            }\n        }\n    }\n}\n\nint main() {\n    int t, a, b, d;\n    cin >> N >> M >> X;\n\n    for (int i = 1; i < N + 1; i++) {\n        cin >> t;\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b >> d;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    dijkstra();\n\n    int time = INT_MAX;\n    for (int j = 0; j < 2; j++) {\n        for (int k = 0; k < 201; k++) time = min(time, min_time[N][j][k]);\n    }\n    cout << time << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct edge {\n    ll u,v,c;\n    edge(ll u = 0, ll v = 0, ll c = 0) :u(u), v(v), c(c) {}\n};\nll solve(){\n    ll res = 0;\n    ll N,M,X; cin >> N >> M >> X;\n    vector<ll> T(N); for(auto& in:T) cin >> in;\n    vector<vector<edge>> G(N);\n    for(int i = 0; i < M;i++){\n        ll A,B,D; cin >> A >> B >> D;\n        A--; B--;\n        G[A].push_back(edge(A,B,D));\n        G[B].push_back(edge(B,A,D));\n    }\n    vector<vector<vector<ll>>> dist(N,vector<vector<ll>>(3,vector<ll>(X+1,LINF)));\n    dist[0][0][0] = 0;\n    using Items = tuple<ll,ll,ll>;\n    queue<Items> q;\n    q.push(Items(0,0,0));\n    while(q.size()){\n        ll n,s,x; tie(n,s,x) = q.front(); q.pop();\n        for(auto e:G[n]){\n            if(x + e.c < X){\n                if(s == 0 && T[e.v] == 2) continue;\n                if(s == 2 && T[e.v] == 0) continue;\n                \n                if(T[e.v] == 1){\n                    if(dist[e.v][s][x+e.c] > dist[e.u][s][x] + e.c){\n                        dist[e.v][s][x+e.c] = dist[e.u][s][x] + e.c;\n                        q.push(Items(e.v,s,x+e.c));\n                    }\n                }\n                if(T[e.v] == s){\n                    if(dist[e.v][s][x+e.c] > dist[e.u][s][x] + e.c){\n                        dist[e.v][s][x+e.c] = dist[e.u][s][x] + e.c;\n                        q.push(Items(e.v,s,0));\n                    }\n                }\n            }else{\n                if(T[e.v] == 1){\n                    if(dist[e.v][T[e.v]][X] > dist[e.u][s][x] + e.c){\n                        dist[e.v][T[e.v]][x+e.c] = dist[e.u][s][x] + e.c;\n                        q.push(Items(e.v,T[e.v],X));\n                    }\n                }else{\n                    if(dist[e.v][T[e.v]][0] > dist[e.u][s][x] + e.c){\n                        dist[e.v][T[e.v]][0] = dist[e.u][s][x] + e.c;\n                        q.push(Items(e.v,T[e.v],0));\n                    }\n                }\n            }\n        }\n    }\n    \n    res = LINF;\n    res = min({\n        *min_element(dist[N-1][0].begin(),dist[N-1][0].end()),\n        *min_element(dist[N-1][1].begin(), dist[N-1][1].end()),\n        *min_element(dist[N-1][2].begin(), dist[N-1][2].end())\n    });\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct edge {\n    ll u,v,c;\n    edge(ll u = 0, ll v = 0, ll c = 0) :u(u), v(v), c(c) {}\n};\nll solve(){\n    ll res = 0;\n    ll N,M,X; cin >> N >> M >> X;\n    vector<ll> T(N); for(auto& in:T) cin >> in;\n    vector<vector<edge>> G(N);\n    for(int i = 0; i < M;i++){\n        ll A,B,D; cin >> A >> B >> D;\n        A--; B--;\n        G[A].push_back(edge(A,B,D));\n        G[B].push_back(edge(B,A,D));\n    }\n    vector<vector<vector<ll>>> dist(N,vector<vector<ll>>(3,vector<ll>(X+1,LINF)));\n    dist[0][0][0] = 0;\n    using Items = tuple<ll,ll,ll>;\n    queue<Items> q;\n    q.push(Items(0,0,0));\n    while(q.size()){\n        ll n,s,x; tie(n,s,x) = q.front(); q.pop();\n        for(auto e:G[n]){\n            if(x + e.c < X){\n                if(s == 0 && T[e.v] == 2) continue;\n                if(s == 2 && T[e.v] == 0) continue;\n                \n                if(T[e.v] == 1){\n                    if(dist[e.v][s][x+e.c] > dist[e.u][s][x] + e.c){\n                        dist[e.v][s][x+e.c] = dist[e.u][s][x] + e.c;\n                        q.push(Items(e.v,s,x+e.c));\n                    }\n                }\n                if(T[e.v] == s){\n                    if(dist[e.v][s][x+e.c] > dist[e.u][s][x] + e.c){\n                        dist[e.v][s][x+e.c] = dist[e.u][s][x] + e.c;\n                        q.push(Items(e.v,s,0));\n                    }\n                }\n            }else{\n                if(T[e.v] == 1){\n                    if(dist[e.v][T[e.v]][X] > dist[e.u][s][x] + e.c){\n                        dist[e.v][T[e.v]][x+e.c] = dist[e.u][s][x] + e.c;\n                        q.push(Items(e.v,T[e.v],X));\n                    }\n                }else{\n                    if(dist[e.v][T[e.v]][0] > dist[e.u][s][x] + e.c){\n                        dist[e.v][T[e.v]][0] = dist[e.u][s][x] + e.c;\n                        q.push(Items(e.v,T[e.v],0));\n                    }\n                }\n            }\n        }\n    }\n    \n    res = LINF;\n    for(int i = 0; i <= X;i++){\n        res = min({res,dist[N-1][0][i],dist[N-1][1][i],dist[N-1][2][i]});\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n#define ALL(a)  a.begin(),a.end()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing LL = long long; template<class T> using V = vector<T>;\n\nLL dist[10004][210][3];\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint N, M, X; cin >> N >> M >> X;\n\tV<int>T(N);\n\tFOR(i, 0, N) {\n\t\tcin >> T[i];\n\t}\n\tV<int>A(M), B(M), D(M);\n\tusing PII = pair<int, int>;\n\tV<V<PII>>G(N);\n\tFOR(i, 0, M) {\n\t\tint a, b, d;\n\t\tcin >> a >> b >> d;\n\t\ta--, b--;\n\t\tG[a].push_back({ b,d });\n\t\tG[b].push_back({ a,d });\n\t}\n\tconst LL LINF = 1e18;\n\tfill(**dist, **dist + 10004 * 210 * 3, LINF);\n\tdist[0][X][0] = 0;\n\t// 残り[X)分はダメ\n\tusing tp = tuple<int, int, int, int>;\n\tpriority_queue<tp, V<tp>, greater<tp>>q;\n\tq.push(tp( 0,0,X,0 ));\n\twhile (!q.empty()) {\n\t\t// 道を何度も使うことは許可されている\n\t\tint d, v, left, t;\n\t\ttie(d, v, left, t) = q.top(); q.pop();\n\t\tif (dist[v][left][t] < d)continue;\n\t\tfor (const auto &nxeg : G[v]) {\n\t\t\tint nx = nxeg.first;\n\t\t\tint cost = nxeg.second;\n\t\t\tif (t == 0 && T[nx] == 2) {// 変化\n\t\t\t\tif (cost >= left) {\n\t\t\t\t\tif (dist[nx][X][2] > d + cost) {\n\t\t\t\t\t\tdist[nx][X][2] = d + cost;\n\t\t\t\t\t\tq.push(tp(d + cost,nx,X,2 ));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == 2 && T[nx] == 0) {// 変化\n\t\t\t\tif (cost >= left) {\n\t\t\t\t\tif (dist[nx][X][0] > d + cost) {\n\t\t\t\t\t\tdist[nx][X][0] = d + cost;\n\t\t\t\t\t\tq.push(tp( d + cost,nx,X,0 ));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 同じか平常からの変化でXになる\n\t\t\tif (T[nx] != 1) {// left to X\n\t\t\t\tif ((t != 1 && T[nx] == t) || (t == 1 && T[nx] != 1)) {\n\t\t\t\t\tif (dist[nx][X][T[nx]] > d + cost) {\n\t\t\t\t\t\tdist[nx][X][T[nx]] = d + cost;\n\t\t\t\t\t\tq.push(tp(d + cost,nx,X,T[nx] ));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// to ふつう 状態は維持\n\t\t\tif (T[nx] == 1) {\n\t\t\t\tint nt = t;\n\t\t\t\tif (cost >= left)nt = 1;\n\t\t\t\tint nleft = max(0, left - cost);\n\t\t\t\tif (dist[nx][nleft][nt] > d + cost) {\n\t\t\t\t\tdist[nx][nleft][nt] = d + cost;\n\t\t\t\t\tq.push(tp( d + cost,nx,nleft,nt ));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\tLL ans = LINF;\n\tFOR(i, 0, 201)FOR(j, 0, 3) {\n\t\tans = min(ans, dist[N - 1][i][j]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, cost;\n    Corridor(int target, int cost): target(target), cost(cost) {}\n};\n\nstruct Room {\npublic:\n    int id, type;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int type): id(id), type(type) {}\n};\n\nstruct State {\n    int id, time, prev_type, d;\n    State(int id, int time, int prev_type, int d): id(id), time(time), prev_type(prev_type), d(d) {};\n    bool operator < (const State &s) const {\n        return time > s.time;\n    }\n};\n\nint N, M, X;\nRoom rooms[MAX];\nint min_time[MAX][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[0][0][0] = 0;\n    PQ.push(State(0, 0, COLD, 0));\n    int ans = INT_MAX, next_time, next_d;\n    while(!PQ.empty()) {\n        State s = PQ.top();\n        PQ.pop();\n        if(s.id == N - 1) {\n            ans = min(ans, s.time);\n            continue;\n        }\n        if(s.time > ans) break;\n        for(auto c: rooms[s.id].edge) {\n            next_d = min(X, s.d + c.cost);\n            next_time = s.time + c.cost;\n            if(abs(s.prev_type - rooms[c.target].type) > 1 && next_d < X) continue;\n            if(rooms[c.target].type == CONFORTABLE) {\n                if(min_time[c.target][s.prev_type / 2][next_d] < next_time) continue;\n                min_time[c.target][s.prev_type / 2][next_d] = next_time;\n                PQ.push(State(c.target, next_time, s.prev_type, next_d));\n            } else {\n                if(min_time[c.target][rooms[c.target].type / 2][0] < next_time) continue;\n                min_time[c.target][rooms[c.target].type / 2][0] = next_time;\n                PQ.push(State(c.target, next_time, rooms[c.target].type, 0));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int t, a, b, d;\n    scanf(\"%d %d %d\", &N, &M, &X);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &t);\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &a, &b, &d);\n        a--;\n        b--;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n){\n        cin>>t[i];\n        if (t[i]==2)t[i]=1;\n        else if (t[i]==1)t[i]=2;\n    }\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (d[v][type][tim] < dist) continue;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        for (edge &e : G[v]) {\n            if (t[e.to] == 2) {\n                int ntim = min(x, tim+e.cost);\n                if (d[e.to][type][ntim] > d[v][type][tim] + e.cost) {\n                    d[e.to][type][ntim] = d[v][type][tim] + e.cost;\n                    q.push(P(d[e.to][type][ntim], data(e.to, type, ntim)));\n                }\n            } else {\n                if (type != t[e.to] && tim + e.cost < x) continue;\n                if (d[e.to][t[e.to]][0] > d[v][type][tim] + e.cost) {\n                    d[e.to][t[e.to]][0] = d[v][type][tim] + e.cost;\n                    q.push(P(d[e.to][t[e.to]][0], data(e.to,t[e.to],0)));\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, d;\n    Corridor() {};\n    Corridor(int target, int d): target(target), d(d) {}\n};\n\nstruct Room {\npublic:\n    int id, t;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int t): id(id), t(t) {}\n};\n\nstruct State {\n    int id, time, t, d;\n    State(int id, int time, int t, int d): id(id), time(time), t(t), d(d) {};\n    bool operator < (const State &s) const {\n        return time > s.time;\n    }\n};\n\nint N, M, X;\nRoom rooms[MAX + 1];\nint min_time[MAX + 1][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX + 1; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[1][0][0] = 0;\n    PQ.push(State(1, 0, COLD, 0));\n    int ans = INT_MAX;\n    while(!PQ.empty()) {\n        State s = PQ.top();\n        PQ.pop();\n        if(s.id == N) {\n            ans = min(ans, s.time);\n            continue;\n        }\n        for(auto c: rooms[s.id].edge) {\n            if(abs(s.t - rooms[c.target].t) > 1 && s.d + c.d < X) continue;\n            if(rooms[c.target].t == CONFORTABLE) {\n                if(min_time[c.target][s.t / 2][min(X, s.d + c.d)] < s.time + c.d) continue;\n                min_time[c.target][s.t / 2][min(X, s.d + c.d)] = s.time + c.d;\n                PQ.push(State(c.target, s.time + c.d, s.t, min(X, s.d + c.d)));\n            } else {\n                if(min_time[c.target][rooms[c.target].t / 2][0] < s.time + c.d) continue;\n                min_time[c.target][rooms[c.target].t / 2][0] = s.time + c.d;\n                PQ.push(State(c.target, s.time + c.d, rooms[c.target].t, 0));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int t, a, b, d;\n    cin >> N >> M >> X;\n\n    for (int i = 1; i < N + 1; i++) {\n        cin >> t;\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b >> d;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{\n  int p,d,c,h;\n  st(){}\n  st(int p,int d,int c,int h):p(p),d(d),c(c),h(h){}\n  bool operator<(const st& a) const{\n    return d>a.d;\n  }\n};\nstruct edge{\n  int to,cost;\n  edge(){}\n  edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> G[10001];\nint dp[10001][201][201];\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  int s[n];\n  for(int i=0;i<n;i++) cin>>s[i];\n  for(int i=0;i<m;i++){\n    int a,b,d;\n    cin>>a>>b>>d;\n    a--;b--;\n    G[a].push_back(edge(b,d));\n    G[b].push_back(edge(a,d));\n  }\n  memset(dp,-1,sizeof(dp));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<functional>\n#include<queue>\nusing namespace std;\nclass road{\npublic:\n    int to,distance;\n    road(int a,int b):to(a),distance(b){\n        \n    }\n};\nclass player{\npublic:\n    int time;\n    int k;\n    int place;\n    player(int a,int b,int c):time(a),k(b),place(c){\n        \n    }\n};\nclass room{\npublic:\n    bool used;\n    int k;\n    vector<road> rouka;\n    room():used(false){\n        \n    }\n};\nbool operator<(const player &a,const player &b){\n    return a.time<b.time;\n}\nbool operator>(const player &a,const player &b){\n    return a.time>b.time;\n}\nint main(){\n    int N,M,X;\n    cin>>N>>M>>X;\n    room *map;\n    map= new room[N+1];\n    for(int i=1;i<N+1;++i) {\n        cin>>map[i].k;\n        --map[i].k;\n    }\n    int a,b,c;\n    for(int i=0;i<M;++i){\n        cin>>a>>b>>c;\n        map[a].rouka.push_back(road(b,c));\n        map[b].rouka.push_back(road(a,c));\n    }\n    priority_queue<player,vector<player>,greater<player> >que;\n    que.push(player(0,0,1));\n    while(true){\n        player dummy=que.top();que.pop();\n        if(dummy.place==N){\n            cout<<dummy.time<<endl;\n            break;\n        }\n        if(map[dummy.place].used){\n            continue;\n        }\n        if(dummy.k==0){\n            map[dummy.place].used=true;\n        }\n        if(map[dummy.place].k!=0){\n            map[dummy.place].used=true;\n            dummy.k=map[dummy.place].k*X;\n        }\n        for(vector<road>::iterator p=map[dummy.place].rouka.begin(),fi=map[dummy.place].rouka.end();p!=fi;++p){\n            if(map[p->to].used)continue;\n            int nk=(dummy.k>0)?max(dummy.k-p->distance,0):min(dummy.k+p->distance,0);\n            if(map[p->to].k*nk>=0){\n                que.push(player(dummy.time+p->distance,nk,p->to));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//const int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\n\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(const int t, const int c) {\n\t\tto = t, cost = c;\n\t\treturn;\n\t}\n};\n\nstruct Node {\n\tint dis, node, flag, turn;\n\tNode(const int d, const int n, const int f, const int t) {\n\t\tdis = d, node = n, flag = f, turn = t;\n\t\treturn;\n\t}\n\tbool operator<(const Node&n)const {\n\t\treturn dis > n.dis;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tvector<int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tvector<vector<Edge>>edge(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R >> H;\n\t\tL--, R--;\n\t\tedge[L].push_back(Edge(R, H));\n\t\tedge[R].push_back(Edge(L, H));\n\t}\n\tvector<vector<vector<long long int>>>dis(N, vector<vector<long long int>>(3, vector<long long int>(K + 1, MOD*MOD)));\n\tdis[0][2][K] = 0;\n\tpriority_queue<Node>PQ;\n\tPQ.push(Node(0, 0, 2, K));\n\twhile (!PQ.empty()) {\n\t\tauto box = PQ.top();\n\t\tPQ.pop();\n\t\tfor (auto i : edge[box.node]) {\n\t\t\tif (v[i.to] == box.flag&&box.turn > i.cost)continue;\n\t\t\tif (v[i.to] == 0) {\n\t\t\t\tif (dis[i.to][2][K] > box.dis + i.cost) {\n\t\t\t\t\tdis[i.to][2][K] = box.dis + i.cost;\n\t\t\t\t\tPQ.push(Node(dis[i.to][2][K], i.to, 2, K));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (v[i.to] == 2) {\n\t\t\t\tif (dis[i.to][0][K] > box.dis + i.cost) {\n\t\t\t\t\tdis[i.to][0][K] = box.dis + i.cost;\n\t\t\t\t\tPQ.push(Node(dis[i.to][0][K], i.to, 0, K));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (box.turn <= i.cost) {\n\t\t\t\t\tif (dis[i.to][1][0] > box.dis + i.cost) {\n\t\t\t\t\t\tdis[i.to][1][0] = box.dis + i.cost;\n\t\t\t\t\t\tPQ.push(Node(dis[i.to][1][0], i.to, 1, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (dis[i.to][box.flag][box.turn - i.cost] > box.dis + i.cost) {\n\t\t\t\t\t\tdis[i.to][box.flag][box.turn - i.cost] = box.dis + i.cost;\n\t\t\t\t\t\tPQ.push(Node(dis[i.to][box.flag][box.turn - i.cost], i.to, box.flag, box.turn - i.cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//for (int i = 0; i < N; i++)for (int j = 0; j < 3; j++)for (int k = 0; k <= K; k++)if(dis[i][j][k]!=MOD*MOD)cout << i << \" \" << j << \" \" << k << \" \" << dis[i][j][k] << endl;\n\tlong long int ans = MOD * MOD;\n\tfor (auto i : dis.back())for (auto j : i)ans = min(ans, j);\n\tif (ans == MOD * MOD)ans = -1;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<functional>\n#include<queue>\nusing namespace std;\nint inf=(1<<31)-1;\nclass road{\npublic:\n    int to,distance;\n    road(int a,int b):to(a),distance(b){\n        \n    }\n};\nclass player{\npublic:\n    int time;\n    int k;\n    int place;\n    player(int a,int b,int c):time(a),k(b),place(c){\n        \n    }\n};\nclass room{\npublic:\n    int mk;\n    int k;\n    vector<road> rouka;\n    room():mk(inf){\n        \n    }\n};\nbool operator<(const player &a,const player &b){\n    return a.time<b.time;\n}\nbool operator>(const player &a,const player &b){\n    return a.time>b.time;\n}\nint main(){\n    int N,M,X;\n    cin>>N>>M>>X;\n    room *map;\n    map= new room[N+1];\n    for(int i=1;i<N+1;++i) {\n        cin>>map[i].k;\n        --map[i].k;\n    }\n    int a,b,c;\n    for(int i=0;i<M;++i){\n        cin>>a>>b>>c;\n        map[a].rouka.push_back(road(b,c));\n        map[b].rouka.push_back(road(a,c));\n    }\n    priority_queue<player,vector<player>,greater<player> >que;\n    que.push(player(0,0,1));\n    while(true){\n        player dummy=que.top();que.pop();\n        if(dummy.place==N){\n            cout<<dummy.time<<endl;\n            break;\n        }\n        if(map[dummy.place].k!=0){\n            dummy.k=map[dummy.place].k*X;\n        }\n        if(map[dummy.place].mk<=abs(dummy.k)){\n            continue;\n        }else{\n            map[dummy.place].mk=abs(dummy.k);\n        }\n        for(vector<road>::iterator p=map[dummy.place].rouka.begin(),fi=map[dummy.place].rouka.end();p!=fi;++p){\n            int nk=(dummy.k>0)?max(dummy.k-p->distance,0):min(dummy.k+p->distance,0);\n            if(map[p->to].mk<=abs(nk))continue;\n            if(map[p->to].k*nk>=0){\n                que.push(player(dummy.time+p->distance,nk,p->to));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nint N, M, X;\nvector<pii> g[11234];\nint t[11234];\nint dp[11234][420];\n\nint main() {\n\tcin >> N >> M >> X;\n\tREP(i, N) scanf(\"%d\", t + i);\n\tREP(i, M) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, d));\n\t\tg[b].push_back(pii(a, d));\n\t}\n\t\n\tpriority_queue<pip, vector<pip>, greater<pip> > pq; // time, (pos, past)\n\tfill(dp[0], dp[N], INF);\n\tif (t[0] != 2) pq.push(pip(0, pii(0, 0))); dp[0][0] = 0;\n\tif (t[0] != 0) pq.push(pip(0, pii(0, 210))); dp[0][210] = 0;\n\t\n\twhile (!pq.empty()) {\n\t\tint cost = pq.top().fi, u = pq.top().se.fi, p = pq.top().se.se;\n\t\tpq.pop();\n\t\t\n\t\tif (dp[u][p] < cost) continue;\n\t\t\n\t\tREP(i, g[u].size()) {\n\t\t\tint v = g[u][i].fi;\n\t\t\tint nextc = cost + g[u][i].se;\n\t\t\tint nextp = -1;\n\t\t\t\n\t\t\tif (t[v] == 0) {\n\t\t\t\tif (p <= 200) nextp = 0;\n\t\t\t\tif (t[u] == 1 && p + g[u][i].se >= 210 + X) nextp = 0;\n\t\t\t\tif (t[u] == 2 && g[u][i].se >= X) nextp = 0;\n\t\t\t}\n\t\t\telse if (t[v] == 1) {\n\t\t\t\tint ma = p <= 200 ? X : 210 + X;\n\t\t\t\tnextp = min(ma, p + g[u][i].se);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (p >= 210) nextp = 210;\n\t\t\t\tif (t[u] == 1 && p <= 200 && p + g[u][i].se >= X) nextp = 210;\n\t\t\t\tif (t[u] == 0 && g[u][i].se >= X) nextp = 210;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextp == -1) continue;\n\t\t\tif (chmin(dp[v][nextp], nextc)) pq.push(pip(nextc, pii(v, nextp)));\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tREP(i, 411) chmin(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum {LOW, GOOD, HIGH, NAUGHT};\n\nusing V = tuple<int, int, int>;         // elapsed time, body heat, room id\nstruct E {int from, to, weight;};\nusing Graph = vector<vector<E>>;\n\nusing Node = tuple<int, int, int, int>; // cost & Vertex\n\nconst Node NIL(-1, -1, NAUGHT, -1);\n\nint main() {\n  int N, M, X;\n  cin >> N >> M >> X;\n\n  vector<int> T(N);\n  for(auto& i: T) cin >> i;\n\n  Graph G(N);\n  for(auto i = 0; i < M; ++i) {\n    int A, B, D;\n    cin >> A >> B >> D;\n    --A; --B;\n    G[A].push_back({A, B, D});\n    G[B].push_back({B, A, D});\n  }\n\n  auto next = [&](int cost, int time, int heat, int room, E e) {\n    if(T[e.to] != GOOD && T[e.to] != heat && time + e.weight < X) return NIL;\n    if(T[e.to] != GOOD) return Node(cost + e.weight, 0, T[e.to], e.to);\n    else                return Node(cost + e.weight, min(time + e.weight, X), heat, e.to);\n  };\n\n  map<V, int> d;\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, 0, LOW, 0);\n  while(!q.empty()) {\n    int cost, time, heat, room;\n    tie(cost, time, heat, room) = q.top();\n    q.pop();\n    if(d.count(V(time, heat, room))) continue;\n    d[V(time, heat, room)] = cost;\n    if(room == N-1) {cout << cost << endl; return 0;}\n    for(auto e: G[room]) {\n      int c, t, h, r;\n      tie(c, t, h, r) = next(cost, time, heat, room, e);\n      if(h == NAUGHT) continue;\n      if(d.count(V(t, h, r))) continue;\n      q.emplace(c, t, h, r);\n    }\n  }\n\n  assert(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef pair<pint,pint> ppi;\nint t[10001];\nvector<pint> vp[10001];\nint d[10001][201][3];\nint INF=1000100010;\nint n,x;\nint dijkstra(int st){\n    priority_queue<ppi,vector<ppi>,greater<ppi> > pq;\n    rep(i,n)rep(j,201)rep(k,3) d[i][j][k]=INF;\n    d[st][0][0]=0;\n    pq.push({{0,st},{0,0}});\n    while(!pq.empty()){\n        ppi pi=pq.top();pq.pop();\n        int ti=pi.first.second;\n        int di=pi.first.first;\n        pint ui=pi.second;\n        if(d[ti][ui.second][ui.first]<di) continue;\n        for(auto it:vp[ti]){\n            if(t[it.second]==1){\n                int nx=min(x,ui.second+it.first);\n                if(d[it.second][nx][ui.first]>di+it.first){\n                    d[it.second][nx][ui.first]=di+it.first;\n                    pq.push({{d[it.second][nx][ui.first],it.second},{ui.first,nx}});\n                }\n            }\n            else{\n                if(t[it.second]==ui.first||ui.second+it.first>=x){\n                    if(d[it.second][0][t[it.second]]>di+it.first){\n                        d[it.second][0][t[it.second]]=di+it.first;\n                        pq.push({{d[it.second][0][t[it.second]],it.second},{t[it.second],0}});\n                    }\n                }\n            }\n        }\n    }\n}\nint main(){\n    int m;\n    cin>>n>>m>>x;\n    rep(i,n) cin>>t[i];\n    int sr,dt,ds;\n    rep(i,m){\n        cin>>sr>>dt>>ds;\n        --sr,--dt;\n        vp[sr].pb(ds,dt);\n        vp[dt].pb(ds,sr);\n    }\n    dijkstra(0);\n    int mn=1000100010;\n    rep(i,201)rep(j,3) mn=min(mn,d[n-1][i][j]);\n    cout<<mn<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef long long int64;\nconst int64 INF = 1LL << 59;\n  \nstruct edge\n{\n  int to, cost;\n};\nstruct node\n{\n  int now, time, type;\n};\n  \nint N, M, X, T[10000];\nvector< edge > g[10000];\nint64 min_cost[10000][202][3];\n  \nint bfs()\n{\n  queue< node > qs[202];\n  fill_n(**min_cost, 10000 * 202 * 3, INF);\n  qs[0].emplace((node){0, 0, 1});\n  min_cost[0][0][1] = 0;\n    \n  for(int t = 0; true; t++) {\n    auto& que = qs[t % 202];\n    while(!que.empty()) {\n      const node p = que.front();\n      que.pop();\n      if(t != min_cost[p.now][p.time][p.type]) continue;\n      if(p.now == N - 1) return(t);\n      for(auto e : g[p.now]) {\n        node q = (node){e.to, p.time, p.type};\n        if(q.type + T[e.to] == 3) {\n          if(q.time + e.cost < X) continue;\n          q.time = 0;\n          q.type = T[e.to];\n        } else if(q.type == T[e.to]) {\n          q.time = 0;\n        } else {\n          q.time = min(X, q.time + e.cost);\n        }\n        if(t + e.cost >= min_cost[q.now][q.time][q.type]) continue;\n        min_cost[q.now][q.time][q.type] = t + e.cost;\n        qs[(t + e.cost) % 202].push(q);\n      }\n    }\n  }\n}\n  \nint main()\n{   \n  scanf(\"%d %d %d\", &N, &M, &X);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &T[i]);\n    if(T[i] == 0) T[i] = 1;\n    else if(T[i] == 1) T[i] = 0;\n  }\n  for(int i = 0; i < M; i++) {\n    int A, B, D;\n    scanf(\"%d %d %d\", &A, &B, &D);\n    --A, --B;\n    g[A].emplace_back((edge){B, D});\n    g[B].emplace_back((edge){A, D});\n  }\n  printf(\"%d\\n\", bfs());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n){\n        cin>>t[i];\n        if (t[i]==2)t[i]=1;\n        else if (t[i]==1)t[i]=2;\n    }\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (d[v][type][tim] < dist) continue;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 2) {\n                u = e.to, ntype = type, ntim = min(x, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = t[e.to], ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n){\n        cin>>t[i];\n        if (t[i]==1)t[i]=2;\n        else if (t[i]==2)t[i]=1;\n    }\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (d[v][type][tim] < dist) continue;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        for (edge &e : G[v]) {\n            if (t[e.to] == 2) {\n                int ntim = min(x, tim+e.cost);\n                if (d[e.to][type][ntim] > d[v][type][tim] + e.cost) {\n                    d[e.to][type][ntim] = d[v][type][tim] + e.cost;\n                    q.push(P(d[e.to][type][ntim], data(e.to, type, ntim)));\n                }\n            } else {\n                if (type != t[e.to] && tim + e.cost < x) continue;\n                if (d[e.to][t[e.to]][0] > d[v][type][tim] + e.cost) {\n                    d[e.to][t[e.to]][0] = d[v][type][tim] + e.cost;\n                    q.push(P(d[e.to][t[e.to]][0], data(e.to,t[e.to],0)));\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//[??????, ????????¶???(0????????????, 1????????????), ????????????(0???X)]?????¶?´??????¶???????????§??????????????????????????§?????????\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <functional>\n#define int long long\nusing namespace std;\n\nint n, m, x;\nint t[10000];\nvector<int> et[10000];\nvector<int> ec[10000];\n\nint dp[10000][2][201];\n\nvoid input() {\n\tint i, j;\n\t\n\tcin >> n >> m >> x;\n\tfor (i = 0; i < n; i++) { cin >> t[i]; }\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tcin >> a >> b >> d;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tec[a].push_back(d);\n\t\tet[b].push_back(a);\n\t\tec[b].push_back(d);\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j <= x; j++) {\n\t\t\tdp[i][0][j] = 1145141919893810;\n\t\t\tdp[i][1][j] = 1145141919893810;\n\t\t}\n\t}\n}\n\ntypedef tuple<int, int, int, int> T;\t//cost, vertex, state, rem_time\npriority_queue<T, vector<T>, greater<T> > que;\n\nvoid dijkstra() {\n\tque.push(T(0, 0, 0, x));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.top();\n\t\tque.pop();\n\t\t\n\t\tint cst   = get<0>(now);\n\t\tint pos   = get<1>(now);\n\t\tint state = get<2>(now);\n\t\tint timer = get<3>(now);\n\t\t\n\t\tif (dp[pos][state][timer] <= cst) {\n\t\t\tcontinue;\n\t\t}\n\t\tdp[pos][state][timer] = cst;\n\t\t\n\t\tfor (int i = 0; i < et[pos].size(); i++) {\n\t\t\tint v = et[pos][i];\n\t\t\tint d = ec[pos][i];\n\t\t\t\n\t\t\tif (t[v] == 1) {\t//??????\n\t\t\t\tque.push(T(cst + d, v, state, max(0LL, timer - d)));\n\t\t\t}\n\t\t\telse if (t[v] / 2 == state) {\t//????????°?¢? (??????????????¨??°?¢??????????)\n\t\t\t\tque.push(T(cst + d, v, state, x));\n\t\t\t}\n\t\t\telse {\t//??°?¢???????\n\t\t\t\tif (d < timer) continue;\n\t\t\t\tque.push(T(cst + d, v, !state, x));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tinput();\n\tdijkstra();\n\t\n\tint ans = 1145141919893810;\n\tfor (int i = 0; i <= x; i++) {\n\t\tans = min(ans, dp[n-1][0][i]);\n\t\tans = min(ans, dp[n-1][1][i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint t[10000];\nvector<P>E[10000];\nint d[10000][3][201];\n\nstruct st {\n\tint u, c, i, a;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint n, m, x; scanf(\"%d%d%d\", &n, &m, &x);\n\trep(i, n)scanf(\"%d\", &t[i]);\n\trep(i, m) {\n\t\tint a, b, d; scanf(\"%d%d%d\", &a, &b, &d); a--; b--;\n\t\tE[a].push_back(P(d, b)); E[b].push_back(P(d, a));\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\td[0][0][0] = 0; que.push({ 0,0,0,0 });\n\twhile (!que.empty()) {\n\t\tst s = que.top(); que.pop();\n\t\tif (d[s.u][s.i][s.a] != s.c)continue;\n\t\tfor (P v : E[s.u]) {\n\t\t\tint a = min(x, s.a + v.first), k = t[v.second];\n\t\t\tif (abs(s.i - t[v.second]) == 2) {\n\t\t\t\tif (a < x)continue;\n\t\t\t}\n\t\t\tif (k == 1)k = s.i;\n\t\t\telse a = 0;\n\t\t\tif (d[v.second][k][a] > s.c + v.first) {\n\t\t\t\td[v.second][k][a] = s.c + v.first;\n\t\t\t\tque.push({ v.second, d[v.second][k][a],k,a });\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, 3)rep(j, x + 1) {\n\t\tMin = min(Min, d[n - 1][i][j]);\n\t}\n\tprintf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n    Edge() {}\n    Edge(int to, int cost) : to{to}, cost{cost} {}\n};\n\nconstexpr int MAX = 10000;\nconstexpr int MAX_T = 200;\nconstexpr int INF = (1 << 29);\n\nvector<Edge> G[MAX];\n\nstruct State {\n    int w, v, t, n;\n    State() {}\n    State(int w, int v, int t, int n) : w{w}, v{v}, t{t}, n{n} {}\n\n    bool operator < (const State& s) const {\n        return w > s.w;\n    }\n};\n\nint d[MAX][MAX_T + 1][3];\n\nint dijkstra(int N, int X, const vector<int>& T)\n{\n    priority_queue<State> pq;\n    pq.push(State(0, 0, 0, 0));\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= X; j++) {\n            for (int k = 0; k < 3; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n\n    d[0][0][0] = 0;\n\n    while (!pq.empty()) {\n        State st = pq.top(); pq.pop();\n        int v = st.v, t = st.t, n = st.n;\n\n        if (d[v][t][n] < st.w) continue;\n        \n        if (v == N - 1) {\n            return d[v][t][n];\n        }\n        \n        for (const auto& e : G[v]) {\n            int nt = min(X, t + e.cost);\n            int ncost = d[v][t][n] + e.cost;\n            if (T[e.to] == n) {\n                if (ncost < d[e.to][0][n]) {\n                    d[e.to][0][n] = ncost;\n                    pq.push(State(d[e.to][0][n], e.to, 0, n));\n                }\n            } else {\n                if (T[e.to] == 1) {\n                    if (ncost < d[e.to][nt][n]) {\n                        d[e.to][nt][n] = ncost;\n                        pq.push(State(d[e.to][nt][n], e.to, nt, n));\n                    }\n                } else {\n                    if (nt != X) continue;\n                    if (ncost < d[e.to][0][T[e.to]]) {\n                        d[e.to][0][T[e.to]] = ncost;\n                        pq.push(State(d[e.to][0][T[e.to]], e.to, 0, T[e.to]));\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N, M, X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for (int i = 0; i < N; i++) {\n        cin >> T[i];\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int A, B, D;\n        cin >> A >> B >> D;\n        A--; B--;\n        G[A].emplace_back(B, D);\n        G[B].emplace_back(A, D);\n    }\n    cout << dijkstra(N, X, T) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cmath>\n#include<set>\n#include<random>\n#include<map>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define F first\n#define S second\nconst long long mod = 1000000007;\nconst long long inf = 1145141919810;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\nstruct edge {int to, cost;};\nvector<edge>G[10007];\nint t[10007],d[3][10007][201];\n\nvoid dijk(int s, int x) {\n\trep(i, 3)\n\t\trep(j, 10005)\n\t\trep(k,201)d[i][j][k] = inf;\n\td[0][s][0] = 0;\n\tpriority_queue<PP, vector<PP>, greater<PP>>Q;\n\tQ.push(PP(P(0, s), P(0, t[s])));\n\twhile (Q.size()) {\n\t\tPP p = Q.top();\n\t\tint v = p.first.second;\n\t\tQ.pop();\n\t\tif (d[p.second.second][v][p.second.first] < p.F.F)continue;\n\t\trep(i, G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (p.second.second == 0) {\n\t\t\t\tif (t[e.to] == 0) {\n\t\t\t\t\tif (d[0][e.to][0] > d[0][v][p.second.first] + e.cost) {\n\t\t\t\t\t\td[0][e.to][0] = d[0][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[0][e.to][0], e.to), P(0, 0)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (t[e.to] == 1) {\n\t\t\t\t\tint ld = min(x, e.cost + p.second.first);\n\t\t\t\t\tif (d[0][e.to][ld] > d[0][v][p.second.first] + e.cost) {\n\t\t\t\t\t\td[0][e.to][ld] = d[0][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[0][e.to][ld], e.to), P(ld, 0)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint ld =min(x, p.second.first + e.cost);\n\t\t\t\t\tif (d[2][e.to][0] > d[0][v][p.second.first] + e.cost&&ld == x) {\n\t\t\t\t\t\td[2][e.to][0] = d[0][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[2][e.to][0], e.to), P(0, 2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif (t[e.to] == 2) {\n\t\t\t\t\tif (d[2][e.to][0] > d[2][v][p.second.first] + e.cost) {\n\t\t\t\t\t\td[2][e.to][0] = d[2][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[2][e.to][0], e.to), P(0, 2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (t[e.to] == 1) {\n\t\t\t\t\tint ld = min(x, e.cost + p.second.first);\n\t\t\t\t\tif (d[2][e.to][ld] > d[2][v][p.second.first] + e.cost) {\n\t\t\t\t\t\td[2][e.to][ld] = d[2][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[2][e.to][ld], e.to), P(ld, 2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint ld = min(x,p.second.first + e.cost);\n\t\t\t\t\tif (d[0][e.to][0] > d[2][v][p.second.first] + e.cost&&ld == x) {\n\t\t\t\t\t\td[0][e.to][0] = d[2][v][p.second.first] + e.cost;\n\t\t\t\t\t\tQ.push(PP(P(d[0][e.to][0], e.to), P(0, 0)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tint n, m, x; cin >> n >> m >> x;\n\trep(i, n)cin >> t[i];\n\trep(j, m) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--, b--;\n\t\tG[a].push_back({ b,c });\n\t\tG[b].push_back({ a,c });\n\t}\n\tdijk(0, x); \n\tint ans = inf;\n\trep(i, 3)\n\t\trep(j, 201)ans = min(ans, d[i][n-1][j]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct edge {\n    ll u,v,c;\n    edge(ll u = 0, ll v = 0, ll c = 0) :u(u), v(v), c(c) {}\n};\nll solve(){\n    ll res = 0;\n    ll N,M,X; cin >> N >> M >> X;\n    vector<ll> T(N); for(auto& in:T) cin >> in;\n    vector<vector<edge>> G(N);\n    for(int i = 0; i < M;i++){\n        ll A,B,D; cin >> A >> B >> D;\n        A--; B--;\n        G[A].push_back(edge(A,B,D));\n        G[B].push_back(edge(B,A,D));\n    }\n    vector<vector<vector<ll>>> dist(N,vector<vector<ll>>(3,vector<ll>(X+1,LINF)));\n    dist[0][0][0] = 0;\n    using Items = tuple<ll,ll,ll>;\n    queue<Items> q;\n    q.push(Items(0,0,0));\n    while(q.size()){\n        ll n, f, x; tie(n, f, x) = q.front(); q.pop();\n        for (auto e : G[n]) {\n            if (x + e.c < X) {\n                if (f == 0 && T[e.v] == 2) continue;\n                if (f == 2 && T[e.v] == 0) continue;\n                \n                if (T[e.v] == 1) {\n                    if (dist[e.v][f][x + e.c] > dist[e.u][f][x] + e.c) {\n                        dist[e.v][f][x + e.c] = dist[e.u][f][x] + e.c;\n                        q.push(Items(e.v, f, x + e.c));\n                    }\n                }\n                if (T[e.v] == f) {\n                    if (dist[e.v][f][0] > dist[e.u][f][x] + e.c) {\n                        dist[e.v][f][0] = dist[e.u][f][x] + e.c;\n                        q.push(Items(e.v, f, 0));\n                    }\n                }\n                \n            }\n            else {\n                if (T[e.v] == 1) {\n                    if (dist[e.v][T[e.v]][X] > dist[e.u][f][x] + e.c) {\n                        dist[e.v][T[e.v]][X] = dist[e.u][f][x] + e.c;\n                        q.push(Items(e.v, T[e.v], X));\n                    }\n                }\n                else {\n                    if (dist[e.v][T[e.v]][0] > dist[e.u][f][x] + e.c) {\n                        dist[e.v][T[e.v]][0] = dist[e.u][f][x] + e.c;\n                        q.push(Items(e.v, T[e.v], 0));\n                    }\n                }\n            }\n        }\n   }\n    \n    res = LINF;\n    for(int i = 0; i <= X;i++){\n        res = min({res,dist[N-1][0][i],dist[N-1][1][i],dist[N-1][2][i]});\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{\n  int p,d,c,h;\n  st(){}\n  st(int p,int d,int c,int h):p(p),d(d),c(c),h(h){}\n  bool operator<(const st& a) const{\n    return d<a.d;\n  }\n};\nstruct edge{\n  int to,cost;\n  edge(){}\n  edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> G[11111];\nint dp[10001][201][201];\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  int s[n];\n  for(int i=0;i<n;i++) cin>>s[i];\n  for(int i=0;i<m;i++){\n    int a,b,d;\n    cin>>a>>b>>d;\n    a--;b--;\n    G[a].push_back(edge(b,d));\n    G[b].push_back(edge(a,d));\n  }\n  memset(dp,-1,sizeof(dp));\n  priority_queue<st> q;\n  q.push(st(0,0,x,0));\n  while(!q.empty()){\n    st t=q.top();q.pop();\n    if(~dp[t.p][t.c][t.h]&&dp[t.p][t.c][t.h]<t.d) continue;\n    dp[t.p][t.c][t.h]=t.d;\n    for(int i=0;i<(int)G[t.p].size();i++){\n      int v=G[t.p][i].to,u=G[t.p][i].cost;\n      int c=max(0,t.c-u),h=max(0,t.h-u);\n      if(~dp[v][c][h]&&dp[v][c][h]<t.d+u) continue;\n      if(s[v]==0){\n\tif(h>0) continue;\n\tq.push(st(v,t.d+u,x,h));\n      }\n      if(s[v]==1){\n\tq.push(st(v,t.d+u,c,h));\n      }\n      if(s[v]==2){\n      \tif(c>0) continue;\n\tq.push(st(v,t.d+u,c,x));\n      }\n    }\n  }\n\n  int ans=-1;\n  for(int i=0;i<=x;i++){\n    for(int j=0;j<=x;j++){\n      if(dp[n-1][i][j]<0) continue;\n      if(ans<0||dp[n-1][i][j]<ans) ans=dp[n-1][i][j];\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, int> P;\ntypedef pair<int, int> PP;\ntypedef pair<P, PP> PPP;\nstatic const ll INF = 1LL << 60;\n\nstruct edge{\n\tint to; ll cost;\n};\nclass Graph{\n\tpublic:\n\tvector<vector<edge> > adj;\n\tGraph(int V){\n\t\tadj.resize(V);\n\t}\n\tvoid add_edge(int s, edge e){\n\t\tadj[s].push_back(e);\n\t}\n\tvector<vector<vector<ll> > > dijkstra(int s, vector<int> &T, int &X){\n\t\tpriority_queue<PPP, vector<PPP> , greater<PPP> > pqa;\n\t\tvector<vector<vector<ll> > >  dist(2, vector<vector<ll> >(X + 1, vector<ll>(adj.size(), INF)));\n\t\tdist[0][0][s] = 0;\n\t\tpqa.push(PPP(P(dist[0][0][s], s), PP(0, 0)));\n\t\twhile(!pqa.empty()){\n\t\t\tPPP pp = pqa.top(); pqa.pop();\n\t\t\tint u = pp.first.second;\n\t\t\tPP c = pp.second;\n\t\t\tif(dist[c.first][c.second][u] < pp.first.first) continue;\n\t\t\tfor(int v = 0; v < adj[u].size(); v++){\n\t\t\t\tedge e = adj[u][v];\n\t\t\t\tif((c.first == 0 && T[e.to] == 2) || (c.first == 1 && T[e.to] == 0)){\n\t\t\t\t\tif(c.second + e.cost < X) continue;\n\t\t\t\t}\n\t\t\t\tint b, d;\n\t\t\t\tif(T[e.to] == 0){\n\t\t\t\t\tb = 0;\n\t\t\t\t\td = 0;\n\t\t\t\t}else if(T[e.to] == 2){\n\t\t\t\t\tb = 1;\n\t\t\t\t\td = 0;\n\t\t\t\t}else{\n\t\t\t\t\tb = c.first;\n\t\t\t\t\td = min(X, (int)(c.second + e.cost));\n\t\t\t\t}\n\t\t\t\tif(dist[b][d][e.to] > dist[c.first][c.second][u] + e.cost){\n\t\t\t\t\tdist[b][d][e.to] = dist[c.first][c.second][u] + e.cost;\n\t\t\t\t\tpqa.push(PPP(P(dist[b][d][e.to], e.to), PP(b, d)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n};\n\nint main(){\n\tint N, M, X;\n\tcin >> N >> M >> X;\n\tvector<int> T(N);\n\tfor(int i = 0; i < N; i++) cin >> T[i];\n\tGraph G(N);\n\tfor(int i = 0; i < M; i++){\n\t\tint A, B, D;\n\t\tcin >> A >> B >> D;\n\t\tA--; B--;\n\t\tG.add_edge(A, (edge){B, D});\n\t\tG.add_edge(B, (edge){A, D});\n\t}\n\tvector<vector<vector<ll> > > dist = G.dijkstra(0, T, X);\n\tll res = INF;\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int j = 0; j <= X; j++){\n\t\t\tres = min(res, dist[i][j][N - 1]);\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <stdint.h>\n\n#define in std::cin\n#define out std::cout\n\n#include <queue>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <iterator>\n\nusing COST_T = int32_t;\nconstexpr uint32_t N_MAX = 10000;\nconstexpr COST_T INF = 10000 * 400 + 1000;//std::numeric_limits<double>::infinity()\n\n#if defined(_MSC_VER) && defined(_DEBUG)\n\t\t\t\t\t\t\t\t\t\t  //static_assert(false, \"??????????????§??????????????????????????¨???????????????\");\n#endif\n\nstruct edge {\n\tuint32_t to;\n\tCOST_T cost;\n\tedge() {}\n\tedge(uint32_t to_, COST_T cost_)\n\t\t:to(to_), cost(cost_) {}\n};\nstd::vector<edge> graph[N_MAX];\n\nint32_t N, M, X;\nint32_t T[N_MAX];\n\n//??????????????????\nCOST_T D[N_MAX][201][2];\nvoid Dijkstra(uint32_t s)\n{\n\tusing P = std::pair<COST_T, uint64_t>;//cost pos\n\tstd::priority_queue<P, std::vector<P>, std::greater<>> que;\n\tfor(auto&arr2:D)for (auto&arr1 : arr2)for (auto&i : arr1)i=INF;\n\n\tD[s][X][0] = 0;\n\tque.emplace(0, ((uint64_t)(s)<<16)|(X<<8));\n\twhile (!que.empty())\n\t{\n\t\tauto p = que.top(); que.pop();\n\t\tconst auto nowpos = p.second >> 16;\n\t\tint32_t ntime = (p.second >> 8) & 0b1111'1111;\n\t\tint32_t ishot = p.second & 0b1111'1111;\n\t\tconst auto& nowcost = p.first;\n\n\t\tif (D[nowpos][ntime][ishot] < nowcost) { continue; }\n\t\t//printf(\"%d,%d,%d,%d\\n\", nowpos, ntime, ishot, D[nowpos][ntime][ishot]);\n\t\t//for (int32_t to = 0; to < N; ++to)\n\t\t//{\n\t\t//\tauto cost = nowcost + graph[nowpos][to];\n\t\t//\tif (cost < D[to]) {\n\t\t//\t\tD[to] = cost;\n\t\t//\t\tque.emplace(D[to], to);\n\t\t//\t}\n\t\t//}\n\n\t\tfor (const auto& e : graph[nowpos])\n\t\t{\n\t\t\tauto cost = nowcost + e.cost;\n\t\t\tauto time = std::max<int32_t>(0, ntime - e.cost);\n\t\t\tif (time <= 0 || !((T[e.to] == 2 && !ishot) || (T[e.to] == 0 && ishot))) {\n\t\t\t\tauto nextishot = ishot;\n\t\t\t\tif (T[e.to] == 2) {\n\t\t\t\t\ttime = X;\n\t\t\t\t\tnextishot = 1;\n\t\t\t\t}\n\t\t\t\telse if (T[e.to] == 0) {\n\t\t\t\t\ttime = X;\n\t\t\t\t\tnextishot = 0;\n\t\t\t\t}\n\t\t\t\telse if (ntime <= 0) {\n\t\t\t\t\tnextishot = 0;\n\t\t\t\t}\n\t\t\t\tif (cost < D[e.to][time][nextishot]) {\n\t\t\t\t\tD[e.to][time][nextishot] = cost;\n\t\t\t\t\tque.emplace(cost, ((int64_t)(e.to) << 16) | (time << 8) | nextishot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n#if 0\nuint32_t DP[10000][201][2];\n//??´???????????§?????¨??????????????????\nuint32_t func(int pos, int wait, int type/*0??????,1??±???*/)\n{\n\tif (pos == N - 1) { return 0; }\n\tif (T[pos] != 1) {\n\t\t//?\\?????????¨?±?\n\t\twait = X;\n\t\tif (T[pos] == 0) {\n\t\t\ttype = 0;\n\t\t}\n\t\telse {\n\t\t\ttype = 1;\n\t\t}\n\t}\n\telse if (wait == 0) {\n\t\ttype = 0;\n\t}\n\n\tif (DP[pos][wait][type] != 0) { return DP[pos][wait][type]; }\n\tDP[pos][wait][type] = INF;\n\tuint32_t mincost = INF;\n\tfor (const auto& e : graph[pos])\n\t{\n\t\tif (e.cost < wait) {\n\t\t\t//??°?¢????????????§??????\n\t\t\tif (T[e.to] == 0 && type == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (T[e.to] == 2 && type == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tmincost = std::min(mincost, func(e.to, std::max(0, wait - e.cost), type) + e.cost);\n\t}\n\treturn DP[pos][wait][type] = mincost;\n}\n#endif\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N >> M >> X;\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tin >> T[i];\n\t}\n\tfor (size_t i = 0; i < M; ++i) {\n\t\tint a, b, j;\n\t\tin >> a >> b >> j; --a; --b;\n\t\tgraph[a].emplace_back(b, j);\n\t\tgraph[b].emplace_back(a, j);\n\t}\n\tDijkstra(0);\n\tint32_t res = INF;\n\tfor (size_t i = 0; i <= X; ++i)\n\t{\n\t\tres = std::min(res, D[N - 1][i][0]);\n\t\tres = std::min(res, D[N - 1][i][1]);\n\t}\n\tout << res << endl;\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, cost;\n    Corridor(int target, int cost): target(target), cost(cost) {}\n};\n\nstruct Room {\npublic:\n    int id, type;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int type): id(id), type(type) {}\n};\n\nstruct State {\n    int id, time, prev_type, d;\n    State() {};\n    State(int id, int time, int prev_type, int d): id(id), time(time), prev_type(prev_type), d(d) {};\n    bool operator < (const State &s) const {\n        return time > s.time;\n    }\n};\n\nint N, M, X;\nRoom rooms[MAX];\nint min_time[MAX][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[0][0][0] = 0;\n    PQ.push(State(0, 0, COLD, 0));\n    int ans = INT_MAX, next_time, next_d;\n    State s;\n    while(!PQ.empty()) {\n        s = PQ.top();\n        PQ.pop();\n        if(s.id == N - 1) {\n            ans = min(ans, s.time);\n            continue;\n        }\n        if(s.time > ans) break;\n        for(auto c: rooms[s.id].edge) {\n            next_d = min(X, s.d + c.cost);\n            next_time = s.time + c.cost;\n            if(abs(s.prev_type - rooms[c.target].type) > 1 && next_d < X) continue;\n            if(rooms[c.target].type == CONFORTABLE) {\n                if(min_time[c.target][s.prev_type / 2][next_d] < next_time) continue;\n                min_time[c.target][s.prev_type / 2][next_d] = next_time;\n                PQ.push(State(c.target, next_time, s.prev_type, next_d));\n            } else {\n                if(min_time[c.target][rooms[c.target].type / 2][0] < next_time) continue;\n                min_time[c.target][rooms[c.target].type / 2][0] = next_time;\n                PQ.push(State(c.target, next_time, rooms[c.target].type, 0));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cout << sizeof(min_time) << endl;\n    cout << sizeof(rooms) << endl;\n    int t, a, b, d;\n    scanf(\"%d %d %d\", &N, &M, &X);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &t);\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &a, &b, &d);\n        a--;\n        b--;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n    cout << sizeof(min_time) << endl;\n    cout << sizeof(rooms) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<ll, ll> pii;\ntypedef pair<ll,pii> piii;\n#define mp make_pair\nint d[10001][2][501];\nsigned main(){\n    rep(i,10001)rep(j,2)rep(k,501)d[i][j][k]=INF*INF;\n    int n,m,x; cin>>n>>m>>x;\n    vector<vector<pii>>edge(n,vector<pii>());\n    vector<int>t(n); rep(i,n)cin>>t[i];\n    rep(i,m){\n        int to,from,cost;\n        cin>>to>>from>>cost;\n        --to;--from;\n        edge[to].push_back(mp(from,cost));\n        edge[from].push_back(mp(to,cost));\n    }\n    priority_queue<piii,vector<piii>,greater<piii>>que;\n    que.push(mp(0,mp(0,0)));\n    d[0][1][0]=0;\n    int ans=INF*INF;\n    while(!que.empty()){\n        piii tp=que.top();\n        que.pop();\n        int vnow=tp.second.first;\n        int _time=tp.first;\n        int _tmos=tp.second.second;\n        if(vnow==n-1){\n            ans=_time;\n            break;\n        }\n        int it=0;\n        if(_tmos>=0)it=1;\n        if(d[vnow][it][abs(_tmos)]<_time)continue;\n        rep(i,edge[vnow].size()){\n            int tmos=_tmos;\n            pii  yebi=edge[vnow][i];\n            int next=yebi.first;\n            int ncost=yebi.second;\n            if(t[vnow]==1){\n                if(tmos<0)tmos=min((ll)0,tmos+ncost);\n                else if(tmos>0)tmos=max((ll)0,tmos-ncost);\n            }else if(t[vnow]==0){\n                tmos=min((ll)0,tmos+ncost-x);\n                \n            }else if(t[vnow]==2){\n                tmos=max((ll)0,tmos-ncost+x);\n            }\n            if(tmos>0&&t[next]==0)continue;\n            if(tmos<0&&t[next]==2)continue;\n            int ni=0;\n            if(tmos>=0)ni=1;\n            if(d[next][ni][abs(tmos)]>_time+ncost){\n                que.push(mp(_time+ncost,mp(next,tmos)));\n                d[next][ni][abs(tmos)]=_time+ncost;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\ntypedef pair< int,int > PII;\ntypedef pair< int,pair<int,int> > PPII;\ntypedef pair< int,pair<int,pair<int, int> > > PPPII;\n\nstruct edge{\n    int to,cost;\n    edge(){}\n    edge(int p1,int p2){\n        to=p1;\n        cost=p2;\n    }\n};\n\ntypedef pair<int,int> PII;\nvector<edge> G[10005];\nint dist[10005][205][5];\nint A[20005];\nint N,M,X;\n\n\nvoid dijkstra(int s){\n    priority_queue<PPPII,vector<PPPII>,greater<PPPII> > que;\n    for(int i=0;i<10005;++i)for(int j=0;j<=200;++j)for(int k=0;k<3;++k)dist[i][j][k]=INF;\n    dist[s][0][A[s]]=0;\n    que.push(PPPII(0,PPII(s,PII(0,A[s]))));\n    while(!que.empty()){\n        PPPII p = que.top();\n        que.pop();\n        int v=p.second.first;\n        int time=p.second.second.first;\n        int hot=p.second.second.second;\n        if(dist[v][time][hot]<p.first)continue;\n        for(int i=0;i<G[v].size();i++){\n            edge e = G[v][i];\n            int ntime,nhot;\n            if(A[e.to]==0){\n                if(hot==2){\n                    if(time+e.cost<X)continue;\n                    else {\n                        ntime=0;\n                        nhot=A[e.to];\n                        if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                            dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                            que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                        }\n                    }\n                }\n                if(hot==0){\n                    ntime=0;\n                    nhot=A[e.to];\n                    if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                        dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                        que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                    }\n                }\n            }\n            else if(A[e.to]==2){\n                if(hot==0){\n                    if(time+e.cost<X)continue;\n                    else {\n                        ntime=0;\n                        nhot=A[e.to];\n                        if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                            dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                            que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                        }\n                    }\n                }\n                if(hot==2){\n                    ntime=0;\n                    nhot=A[e.to];\n                    if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                        dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                        que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                    }\n                }\n            }\n\n            else if(A[e.to]==1){\n                ntime=time+e.cost;\n                nhot=hot;\n                if(ntime>=X)ntime=200;\n                if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                    dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                    que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                }\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin>>N>>M>>X;\n    for(int i=0;i<N;++i)cin>>A[i];\n    for(int i=0;i<M;++i){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;\n        b--;\n        G[a].PB(edge(b,c));\n        G[b].PB(edge(a,c));\n    }\n    dijkstra(0);\n    int ans=INF;\n    for(int i=0;i<=200;++i){\n        for(int j=0;j<3;++j){\n            ans=min(ans,dist[N-1][i][j]);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>     \n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <cassert>\n#define INF 2000000\n#define MOD 1000000007\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define mk make_pair\n#define en endl\n#define RE return 0\n//#define int ll\n#define P pair<int,int>\nusing namespace std;\nint dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0};\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\nint lcm(int a,int b){if(a==0){return b;} return a/gcd(a,b)*b;}    \n\nint temp[10005];\nvector<P> G[10005];  // to, dis\nmap<P,bool> mp;\n#define pp pair<int, P>\nint an[10005][405];\n\nsigned main(){\n\tint n,m,x; cin>>n>>m>>x;\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tcin>>temp[i];\n\t\tif(temp[i]==0) temp[i]=0;\n\t\telse if(temp[i]==1) temp[i]=x;\n\t\telse temp[i]=2*x;\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tint a,b,c; cin>>a>>b>>c;\n\t\tG[a].push_back(mk(b,c));\n\t\tG[b].push_back(mk(a,c));\n\t}\n\t\n\tpriority_queue<pp, vector<pp>, greater<pp> > que; // dis now temp\n\tque.push(mk(0,mk(1,temp[1])));\n\t\n\tfor(int i=0; i<10001; i++) for(int j=0; j<=401; j++) an[i][j]=INF;\n\tan[1][temp[1]]=0;\n\twhile(!que.empty()){\n\t\tint d=que.top().first, now=que.top().second.first, tem=que.top().second.second; que.pop();\n\t\tif(now==n){\n\t\t\tcout<<d<<en;\n\t\t\tRE;\n\t\t}\n\t\tif(an[now][tem]<d) continue;\n\t\tfor(int i=0; i<G[now].size(); i++){\n\t\t\tint to=G[now][i].first, dis=G[now][i].second;\n\t\t\tint t=temp[to];\n\t\t\tint j;\n\t\t\tif(t==0 || t==2*x){\n\t\t\t\tif(abs(t-tem)<=x+dis) j=t;\n\t\t\t\telse continue;\n\t\t\t}else{\n\t\t\t\tif(tem==x) j=x;\n\t\t\t\telse if(tem<x) j=(tem+dis>x) ? x:tem+dis;\n\t\t\t\telse j=(tem-dis<x) ? x:tem-dis; \n\t\t\t}\n\t\t\tif(an[to][j]<=d+dis) continue;\n\t\t\telse an[to][j]=d+dis;\n\t\t\tque.push(mk(d+dis, mk(to, j)));\n\t\t}\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 112000000012345678LL\n\nusing P = pair<long,int>;\n// cost, idx\n\nint t[10005];\n\nlong d[200*2*10005];\nvector<P> vec[200*2*10005];\n\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  rep(i,n) cin>>t[i];\n\n  rep(_,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    rep(__,2){\n      int ai = a*2*x, bi = b*2*x;\n      if(t[b]==1){\n        if(t[a]!=1){\n          // [0,2] -> 1\n          if(t[a]==2 && x-c>0) bi += x;\n          vec[ai].pb(mp(c, bi + max(0, x-c)));\n        }\n        else {\n          // 1 -> 1\n          vec[ai].pb(mp(c, bi));\n          repl(i,1,x){\n            vec[ai+i].pb(mp(c, bi + max(0, i-c)));\n            vec[ai+x+i].pb(mp(c, bi + ((i-c>0)?(x+i-c):0) ));\n          }\n        }\n      }\n      else if(t[a] == t[b]){\n        // 0 -> 0, 2 -> 2\n        vec[ai].pb(mp(c, bi));\n      }\n      else if(t[a]==1){\n        // 1 -> 2, 1 -> 0\n        vec[ai].pb(mp(c, bi));\n\n        if(t[b]==2) ai += x;\n        repl(i,1,x) vec[ai + i].pb(mp(c, bi));\n\n        ai = a*2*x;\n        if(t[b]==0) ai += x;\n        repl(i,1,min(c+1,x)) vec[ai + i].pb(mp(c, bi));\n      }\n      else {\n        // 0->2, 2->0\n        if(t[a]==2) ai += x;\n        else bi += x;\n        if(x <= c) vec[ai].pb(mp(c, bi));\n      }\n\n      swap(a,b);\n    } // make edges\n  }\n\n  priority_queue<P, vector<P>, greater<P>> pq;\n  fill(d, d + 2*x*n, INF);\n  d[0] = 0;\n  pq.push(mp(0,0));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    if(d[p.se] < p.fi) continue;\n    for(auto to : vec[p.se]){\n      long nd = p.fi + to.fi;\n      int ni = to.se;\n      if(d[ni] > nd){\n        pq.push(mp(nd,ni));\n        d[ni] = nd;\n      }\n    }\n  }\n\n  long ans = INF;\n  rep(i,2*x) ans = min(ans, d[(n-1)*2*x + i]);\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n// WA?¨????\n// mp(cost, idx)?????????????????´?????§???????????????fi??¨se???????????£???\n//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = vector<V<T>>;\ntemplate <typename T> using VVV = vector<VV<T>>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll INF = (1LL<<60);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m, x;\n  cin >> n >> m >> x;\n  V<int> t(n);\n  REP(i, n) cin >> t[i];\n  VV<PII> g(n);\n  REP(i, m) {\n    int a, b, d;\n    cin >> a >> b >> d, a--, b--;\n    g[a].PB({b, d});\n    g[b].PB({a, d});\n  }\n\n  // d[i][j][k] = (頂点iを最後に通ってtypeKを通ってからj分経った)\n  VVV<int> d(n, VV<int>(x+1, V<int>(2, INF)));\n  d[0][0][0] = 0;\n  priority_queue<V<int>, VV<int>, greater<V<int>>> que;\n  que.push({d[0][0][0], 0, 0, 0});\n\n  while(que.size()) {\n    V<int> v = que.top(); que.pop();\n    int cost = v[0], ver = v[1], time = v[2], type = v[3];\n    if(d[ver][time][type] < cost) continue;\n    // cout << v << endl;\n    for(auto i: g[ver]) {\n      if((type == 0 && t[i.first] == 2 && time+i.second < x)\n        || (type == 1 && t[i.first] == 0 && time+i.second < x)) continue;\n\n      int ntype;\n      int ntime;\n      if(t[i.first]==0 || t[i.first]==2) ntime = 0;\n      else ntime = min(x, time+i.second);\n      if(t[i.first]==0) ntype=0;\n      else if(t[i.first]==1) ntype=type;\n      else if(t[i.first]==2) ntype=1;\n\n      if(d[i.first][ntime][ntype] > d[ver][time][type] + i.second) {\n        d[i.first][ntime][ntype] = d[ver][time][type] + i.second;\n        que.push({d[i.first][ntime][ntype], i.first, ntime, ntype});\n      }\n    }\n  }\n\n  int ans = INF;\n  REP(i, x+1) REP(j, 2) chmin(ans, d[n-1][i][j]);\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* Karen {{{\n ___  ____\n|_  ||_  _|\n  | |_/ /    ,--.   _ .--.  .---.  _ .--.\n  |  __'.   `'_\\ : [ `/'`\\]/ /__\\\\[ `.-. |\n _| |  \\ \\_ // | |, | |    | \\__., | | | |\n|____||____|\\'-;__/[___]    '.__.'[___||__]\n}}} */\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define pb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) v.begin(), v.end()\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define reps(i, a, n) for (int i = (a); i < (int)(n); ++i)\n#define rrep(i, n) for (int i = 1; i <= (int)(n); ++i)\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ninline bool inside(int y,int x,int H,int W){return(y>=0&&x>=0&&y<H&&x<W);}\ninline int in() {int x; std::cin >> x; return x;}\n\nconst int mod = 1e9 + 7;\nconst int inf = 1e18 + 9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\nstruct edge\n{\n  edge() {}\n  edge(int a, int b) { to = a; cost = b; }\n  int to, cost;\n};\n\nint n, m, x;\nint t[10000];\nvector<edge> G[10000];\n\nint d[10000][512];\n\nvoid dijkstra()\n{\n  priority_queue<PP, vector<PP>, greater<PP>> q;\n  rep(i, n) rep(j, 512) d[i][j] = inf;\n  q.push(PP(0, P(0, -x)));\n  d[0][0] = 0;\n\n        int cnt = 0;\n  while (!q.empty()){\n    PP p = q.top(); q.pop();\n    int v = p.se.fi;\n                int T = p.se.se;\n\n    for (int i = 0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if (T + e.cost < 0 && t[e.to] == 2) continue;\n      if (T - e.cost > 0 && t[e.to] == 0) continue;\n\n      int temp;\n      if (t[e.to] == 2){\n        temp = x;\n      } else if (t[e.to] == 0){\n        temp = -x;\n      } else {\n        if (T > 0){\n          temp = max(T - e.cost, 0ll);\n                                } else {\n          temp = min(T + e.cost, 0ll);\n        }\n      }\n\n      if (d[e.to][temp + x] > d[v][T + x] + e.cost){\n        d[e.to][temp + x] = d[v][T + x] + e.cost;\n        q.push(PP(d[e.to][temp + x], P(e.to, temp)));\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin >> n >> m >> x;\n  rep(i, n) cin >> t[i];\n\n  rep(i, m){\n    int a = in() - 1, b = in() - 1, c = in();\n    G[a].pb(edge(b, c));\n    G[b].pb(edge(a, c));\n  }\n\n  dijkstra();\n\n  int ans = inf;\n  rep(j, 512) ans = min(ans, d[n - 1][j]);\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma warning(disable:4996)\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10010];\nvector<P>rinsetu[10010];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10010][4][301];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost,0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i <= c; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n){\n        cin>>t[i];\n        if (t[i]==1)t[i]=2;\n        else if (t[i]==2)t[i]=1;\n    }\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (d[v][type][tim] < dist) continue;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 2) {\n                u = e.to, ntype = type, ntim = min(x, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = t[e.to], ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define INF (1000000000)\n\ntypedef pair<int, int> P;\n\nstruct Q {\n    int time;\n    int togo;\n    int status;\n    int room;\n    Q() {}\n    Q(int a,int b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    int X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n        --T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        if(T[a-1]*T[b-1]>=0 || d>=X) {\n            to[a-1].push_back(P(d,b-1));\n            to[b-1].push_back(P(d,a-1));\n        }\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    vector<int> time(N,INF);\n//    unordered_map<int,int> um;\n\n    q.push(Q(0,X,0,0));\n    time[0]=0;\n    while(true) {\n        Q now=q.top(); q.pop();\n        if(now.status==0 && time[now.room]<now.time) continue;\n        if(now.room==N-1) {\n            time[N-1]=now.time;\n            break;\n        }\n        for(auto nxt : to[now.room]) {\n            if(time[nxt.second]<=now.time+nxt.first) continue;\n\n            int nxt_togo=now.togo-nxt.first;\n\n            if(nxt_togo<=0) {\n                time[nxt.second]=now.time+nxt.first;\n                if(T[nxt.second]==0) q.push(Q(now.time+nxt.first,0LL,0,nxt.second));\n                else q.push(Q(now.time+nxt.first,X,0,nxt.second));\n            } else {\n                if(T[nxt.second]==0) {\n                    q.push(Q(now.time+nxt.first,nxt_togo,now.status,nxt.second));\n                } else if(now.status==T[nxt.second]) {\n                    time[nxt.second]=now.time+nxt.first;\n                    q.push(Q(now.time+nxt.first,X,0,nxt.second));\n                }\n            }\n        }\n    }\n\n    cout << time[N-1] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1<<25;//1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nstruct state {\n  int v, cost, rt, te;\n  state(){}\n  state(int v, int cost, int rt, int te):v(v), cost(cost), rt(rt), te(te){}\n  bool operator < (const state& r) const {\n    return cost > r.cost;\n  }\n};\n\nint N, M, X;\nint T[10010];\n\nvector<edge> G[10010];\nint mincost[2][202][10010];\n\nint dijkstra()\n{\n  rep(i, 2) rep(j, 202) rep(k, 10010) mincost[i][j][k] = inf;\n  priority_queue<state> que;\n  que.emplace(0, 0, 0, 0);\n  mincost[0][0][0] = 0;\n  while(!que.empty()) {\n    state s = que.top(); que.pop();\n    if(s.v == N-1) return s.cost;\n    if(s.cost > mincost[s.rt/2][s.te][s.v]) continue;\n    for(edge& e : G[s.v]) {\n      if(abs(s.rt - T[e.to]) == 2 && s.te + e.cost < X) continue;\n      int nrt = s.rt, nte = min(s.te + e.cost, X);\n      if(T[e.to] != 1) nrt = T[e.to], nte = 0;\n      if(s.cost + e.cost < mincost[nrt/2][nte][e.to]) {\n\tmincost[nrt/2][nte][e.to] = s.cost + e.cost;\n\tque.emplace(e.to, s.cost + e.cost, nrt, nte);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> X;\n  rep(i, N) cin >> T[i];\n  rep(i, M) {\n    int A, B, D;\n    cin >> A >> B >> D; A--, B--;\n    G[A].emplace_back(B, D);\n    G[B].emplace_back(A, D);\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n\nconst int inf = 1e9;\n\nint sum[25][100010];\nint cnt[25];\nint dp[1<<22];\n\nsigned main()\n{\n    int n, m; cin >> n >> m;\n\n    rep(i, n) {\n        int a; cin >> a;\n        --a;\n        sum[a][i+1]++;\n        cnt[a]++;\n    }\n\n    rep(i, m) {\n        rep(j, n) {\n            sum[i][j+1] += sum[i][j];\n        }\n    }\n\n    fill_n(dp, 1<<22, inf);\n\n    dp[0] = 0;\n\n    rep(bit, 1 << m) {\n        rep(i, m) {\n            if (!(bit & (1 << i))) {\n                int pos = 0;\n                rep(j, m) if (bit & 1 << j) pos += cnt[j];\n\n                int v = cnt[i] - sum[i][pos + cnt[i]] + sum[i][pos];\n\n                dp[bit | 1 << i] = min(dp[bit | 1 << i], dp[bit] + v);\n            }\n        }\n    }\n\n    cout << dp[(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n)cin>>t[i];\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (d[v][type][tim] < dist) continue;\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 1) {\n                u = e.to, ntype = type, ntim = min(200, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = type, ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n\n    int ans = inf;\n\n    rep(i, 2) rep(j, 205) ans = min(ans, d[n-1][i][j]);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint main(){\n    int n, m, x;\n    cin >> n >> m >> x;\n    vector<int> t(n);\n    for(int i = 0; i < n; i++)  cin >> t[i];\n    vector<pair<int,int>> v[n];\n    for(int i = 0; i < m; i++){\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--, b--;\n        v[a].push_back({b, d});\n        v[b].push_back({a, d});\n    }\n    vector<vector<int>> dp(n, vector<int>(401, 1<<30));\n    priority_queue<pair<int, pair<int,int>>> pq;\n    pq.push({-0, {0, -x}});\n    while(!pq.empty()){\n        auto p = pq.top();  pq.pop();\n        int cost = -p.first, pos = p.second.first, tmp = p.second.second;\n        if(dp[pos][tmp+200] <= cost)    continue;\n        dp[pos][tmp+200] = cost;\n        for(pair<int,int> q : v[pos]){\n            int next = q.first, ntmp = tmp, ncost = cost + q.second;\n            if(tmp < 0){\n                if(tmp+q.second < 0 && t[next]==2)  continue;\n                ntmp = min(0, tmp+q.second);\n            }else if(tmp > 0){\n                if(tmp-q.second > 0 && t[next]==0)  continue;\n                ntmp = max(0, tmp-q.second);\n            }\n            if(t[next] == 2)    ntmp = x;\n            if(t[next] == 0)    ntmp = -x;\n            if(ncost < dp[next][ntmp+200])  pq.push({-ncost, {next, ntmp}});\n        }\n    }\n    int ans = 1<<30;\n    for(int tmp = 0; tmp < 401; tmp++)  ans = min(ans, dp[n-1][tmp]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n\n#define in std::cin\n#define out std::cout\n\n#include <queue>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <iterator>\n\nusing COST_T = int32_t;\nconstexpr uint32_t N_MAX = 10000;\nconstexpr COST_T INF = 10000 * 400 + 1000;//std::numeric_limits<double>::infinity()\n\n#if defined(_MSC_VER) && defined(_DEBUG)\n\t\t\t\t\t\t\t\t\t\t  //static_assert(false, \"??????????????§??????????????????????????¨???????????????\");\n#endif\n\nstruct edge {\n\tuint32_t to;\n\tCOST_T cost;\n\tedge() {}\n\tedge(uint32_t to_, COST_T cost_)\n\t\t:to(to_), cost(cost_) {}\n};\nstd::vector<edge> graph[N_MAX];\n\nint32_t N, M, X;\nint32_t T[N_MAX];\n\n//??????????????????\nCOST_T D[N_MAX][201][2];\nvoid Dijkstra(uint32_t s)\n{\n\tusing P = std::pair<COST_T, uint64_t>;//cost pos\n\tstd::priority_queue<P, std::vector<P>, std::greater<>> que;\n\tfor(auto&arr2:D)for (auto&arr1 : arr2)for (auto&i : arr1)i=INF;\n\n\tD[s][X][0] = 0;\n\tque.emplace(0, ((uint64_t)(s)<<16)|(X<<8));\n\twhile (!que.empty())\n\t{\n\t\tauto p = que.top(); que.pop();\n\t\tconst auto nowpos = p.second >> 16;\n\t\tint32_t ntime = (p.second >> 8) & 0b1111'1111;\n\t\tint32_t ishot = p.second & 0b1111'1111;\n\t\tconst auto& nowcost = p.first;\n\n\t\tif (D[nowpos][ntime][ishot] < nowcost) { continue; }\n\t\t//printf(\"%d,%d,%d,%d\\n\", nowpos, ntime, ishot, D[nowpos][ntime][ishot]);\n\t\t//for (int32_t to = 0; to < N; ++to)\n\t\t//{\n\t\t//\tauto cost = nowcost + graph[nowpos][to];\n\t\t//\tif (cost < D[to]) {\n\t\t//\t\tD[to] = cost;\n\t\t//\t\tque.emplace(D[to], to);\n\t\t//\t}\n\t\t//}\n\n\t\tfor (const auto& e : graph[nowpos])\n\t\t{\n\t\t\tauto cost = nowcost + e.cost;\n\t\t\tauto time = std::max<int32_t>(0, ntime - e.cost);\n\t\t\tif (time <= 0 || !((T[e.to] == 2 && !ishot) || (T[e.to] == 0 && ishot))) {\n\t\t\t\tauto nextishot = ishot;\n\t\t\t\tif (T[e.to] == 2) {\n\t\t\t\t\ttime = X;\n\t\t\t\t\tnextishot = 1;\n\t\t\t\t}\n\t\t\t\telse if (T[e.to] == 0) {\n\t\t\t\t\ttime = X;\n\t\t\t\t\tnextishot = 0;\n\t\t\t\t}\n\t\t\t\telse if (ntime <= 0) {\n\t\t\t\t\tnextishot = 0;\n\t\t\t\t}\n\t\t\t\tif (cost < D[e.to][time][nextishot]) {\n\t\t\t\t\tD[e.to][time][nextishot] = cost;\n\t\t\t\t\tque.emplace(cost, ((int64_t)(e.to) << 16) | (time << 8) | nextishot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n#if 0\nuint32_t DP[10000][201][2];\n//??´???????????§?????¨??????????????????\nuint32_t func(int pos, int wait, int type/*0??????,1??±???*/)\n{\n\tif (pos == N - 1) { return 0; }\n\tif (T[pos] != 1) {\n\t\t//?\\?????????¨?±?\n\t\twait = X;\n\t\tif (T[pos] == 0) {\n\t\t\ttype = 0;\n\t\t}\n\t\telse {\n\t\t\ttype = 1;\n\t\t}\n\t}\n\telse if (wait == 0) {\n\t\ttype = 0;\n\t}\n\n\tif (DP[pos][wait][type] != 0) { return DP[pos][wait][type]; }\n\tDP[pos][wait][type] = INF;\n\tuint32_t mincost = INF;\n\tfor (const auto& e : graph[pos])\n\t{\n\t\tif (e.cost < wait) {\n\t\t\t//??°?¢????????????§??????\n\t\t\tif (T[e.to] == 0 && type == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (T[e.to] == 2 && type == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tmincost = std::min(mincost, func(e.to, std::max(0, wait - e.cost), type) + e.cost);\n\t}\n\treturn DP[pos][wait][type] = mincost;\n}\n#endif\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N >> M >> X;\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tin >> T[i];\n\t}\n\tfor (size_t i = 0; i < M; ++i) {\n\t\tint a, b, j;\n\t\tin >> a >> b >> j; --a; --b;\n\t\tgraph[a].emplace_back(b, j);\n\t\tgraph[b].emplace_back(a, j);\n\t}\n\tDijkstra(0);\n\tint32_t res = INF;\n\tfor (size_t i = 0; i <= X; ++i)\n\t{\n\t\tres = std::min(res, D[N - 1][i][0]);\n\t\tres = std::min(res, D[N - 1][i][1]);\n\t}\n\tout << res << endl;\n\n\treturn 0;\n}\n#endif\n#if 0\n//??????????????????\nCOST_T D[N_MAX];\nvoid Dijkstra(uint32_t s)\n{\n\tusing P = std::pair<COST_T, uint32_t>;//cost pos\n\tstd::priority_queue<P, std::vector<P>, std::greater<>> que;\n\tstd::fill(std::begin(D), std::end(D), INF);\n\n\tD[s] = 0;\n\tque.emplace(0, s);\n\twhile (!que.empty())\n\t{\n\t\tauto p = que.top(); que.pop();\n\t\tconst auto& nowpos = p.second;\n\t\tconst auto& nowcost = p.first;\n\t\tif (D[nowpos] < nowcost) { continue; }\n\n\t\t//for (int32_t to = 0; to < N; ++to)\n\t\t//{\n\t\t//\tauto cost = nowcost + graph[nowpos][to];\n\t\t//\tif (cost < D[to]) {\n\t\t//\t\tD[to] = cost;\n\t\t//\t\tque.emplace(D[to], to);\n\t\t//\t}\n\t\t//}\n\n\t\tfor (const auto& e : graph[nowpos])\n\t\t{\n\t\t\tauto cost = nowcost + e.cost;\n\t\t\tif (cost < D[e.to]) {\n\t\t\t\tD[e.to] = cost;\n\t\t\t\tque.emplace(cost, e.to);\n\t\t\t}\n\t\t}\n\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n){\n        cin>>t[i];\n        if (t[i]==2)t[i]=1;\n        else if (t[i]==1)t[i]=2;\n    }\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (d[v][type][tim] < dist) continue;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        //for (edge &e : G[v]) {\n        //    int u, ntype, ntim;\n        //    if (t[e.to] == 2) {\n        //        u = e.to, ntype = type, ntim = min(x, tim+e.cost);\n        //    } else {\n        //        if (t[v] != t[e.to] && tim + e.cost < x) continue;\n        //        u = e.to, ntype = t[e.to], ntim = 0;\n        //    }\n\n        //    if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n        //        d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n        //        q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n        //    }\n        //}\n        for (edge &e : G[v]) {\n            if (t[e.to] == 2) {\n                int ntim = min(x, tim+e.cost);\n                if (d[e.to][type][ntim] > d[v][type][tim] + e.cost) {\n                    d[e.to][type][ntim] = d[v][type][tim] + e.cost;\n                    q.push(P(d[e.to][type][ntim], data(e.to, type, ntim)));\n                }\n            } else {\n                if (type != t[e.to] && tim + e.cost < x) continue;\n                if (d[e.to][t[e.to]][0] > d[v][type][tim] + e.cost) {\n                    d[e.to][t[e.to]][0] = d[v][type][tim] + e.cost;\n                    q.push(P(d[e.to][t[e.to]][0], data(e.to,t[e.to],0)));\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntypedef tuple<int,int,int,int>latte;\n\nint N,M,X;\nint T[10000];\n\nconst int INF=1001001001001001001ll;\nint dist[10000][201][2];\n\nvpint G[10000];\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&N,&M,&X);\n    rep(i,N){\n        scanf(\"%lld\",&T[i]);\n        if(T[i]==1)T[i]=2;\n        else if(T[i]==2)T[i]=1;\n    }\n    rep(i,M){\n        int a,b,c;\n        scanf(\"%lld%lld%lld\",&a,&b,&c);\n        a--;b--;\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n    fill_n(**dist,10000*201*2,INF);\n    priority_queue<latte,vector<latte>,greater<latte>>que;\n    que.push(make_tuple(0,0,0,0));\n    dist[0][0][0]=0;\n    while(que.size()){\n        int d,v,x,t;\n        tie(d,v,x,t)=que.top();\n        que.pop();\n        if(dist[v][x][t]<d)continue;\n\n        if(v==N-1){\n            cout<<d<<endl;\n            return 0;\n        }\n\n        for(auto &e:G[v]){\n            if(T[e.fi]==2){\n                int nx=min(X,x+e.se);\n                if(dist[e.fi][nx][t]<=d+e.se)continue;\n                dist[e.fi][nx][t]=d+e.se;\n                que.push(make_tuple(dist[e.fi][nx][t],e.fi,nx,t));\n            }\n            else{\n                if(T[e.fi]!=t&&x+e.se<X)continue;\n                if(dist[e.fi][0][T[e.fi]]<=d+e.se)continue;\n                dist[e.fi][0][T[e.fi]]=d+e.se;\n                que.push(make_tuple(dist[e.fi][0][T[e.fi]],e.fi,0,T[e.fi]));\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10000][3][201];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost, 0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nconstexpr int X = 200, Y = X * 2 + 1;\n\nint enc(int v, int t) {\n    return v * Y + t;\n}\n\nconstexpr int INF = 1 << 30;\n\nvoid solve() {\n    int n, m, x;\n    std::cin >> n >> m >> x;\n\n    std::vector<int> ts(n);\n    for (auto& t : ts) std::cin >> t;\n\n    int nn = n * Y;\n    std::vector<std::vector<std::pair<int, int>>> graph(nn);\n    while (m--) {\n        int u, v, d;\n        std::cin >> u >> v >> d;\n        --u, --v;\n\n        for (int i = 0; i < 2; ++i) {\n            for (int t = 0; t < Y; ++t) {\n                int nt = (t >= X ? std::max(X, t - d) : std::min(X, t + d));\n\n                if (ts[v] == 1) {\n                    graph[enc(u, t)].emplace_back(enc(v, nt), d);\n                } else if (ts[v] == 0) {\n                    if (nt > X) continue;\n                    graph[enc(u, t)].emplace_back(enc(v, X - x), d);\n                } else {\n                    if (nt < X) continue;\n                    graph[enc(u, t)].emplace_back(enc(v, X + x), d);\n                }\n            }\n\n            std::swap(u, v);\n        }\n    }\n\n    int r = enc(0, X - x);\n    std::vector<int> dist(nn, INF);\n    dist[r] = 0;\n\n    MinHeap<std::pair<int, int>> que;\n    que.emplace(0, r);\n\n    while (!que.empty()) {\n        int d, v;\n        std::tie(d, v) = que.top();\n        que.pop();\n        if (dist[v] > d) continue;\n\n        for (auto p : graph[v]) {\n            int u, c;\n            std::tie(u, c) = p;\n            if (dist[u] <= dist[v] + c) continue;\n\n            dist[u] = dist[v] + c;\n            que.emplace(dist[u], u);\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < Y; ++t) {\n        ans = std::min(ans, dist[enc(n - 1, t)]);\n    }\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<list>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<functional>\n#include<queue>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10010];\nvector<P>rinsetu[10010];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10010][4][301];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost, 0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<list>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<functional>\n#include<queue>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10010][5][300];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfill(mincost[i][j], mincost[i][j] + c, 1 << 29);\n\t\t}\n\t}\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint t[10000];\nvector<P>E[10000];\nint d[10000][3][201];\n\nstruct st {\n\tint u, c, i, a;\n};\nbool operator<(const st&a, const st&b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint n, m, x; scanf(\"%d%d%d\", &n, &m, &x);\n\trep(i, n)scanf(\"%d\", &t[i]);\n\trep(i, m) {\n\t\tint a, b, d; scanf(\"%d%d%d\", &a, &b, &d); a--; b--;\n\t\tE[a].push_back(P(d, b)); E[b].push_back(P(d, a));\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\td[0][0][0] = 0; que.push({ 0,0,0,0 });\n\twhile (!que.empty()) {\n\t\tst s = que.top(); que.pop();\n\t\tif (d[s.u][s.i][s.a] != s.c)continue;\n\t\tfor (P v : E[s.u]) {\n\t\t\tint a = min(x, s.a + v.first), k = t[v.second];\n\t\t\tif (abs(s.i - t[v.second]) == 2) {\n\t\t\t\tif (a < x)continue;\n\t\t\t}\n\t\t\tif (k == 1)k = s.i;\n\t\t\telse a = 0;\n\t\t\tif (d[v.second][k][a] > s.c + v.first) {\n\t\t\t\td[v.second][k][a] = s.c + v.first;\n\t\t\t\tque.push({ v.second, d[v.second][k][a],k,a });\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, 3)rep(j, x + 1) {\n\t\tMin = min(Min, d[n - 1][i][j]);\n\t}\n\tprintf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<functional>\n#include<queue>\nusing namespace std;\nclass road{\npublic:\n    int to,distance;\n    road(int a,int b):to(a),distance(b){\n        \n    }\n};\nclass player{\npublic:\n    int time;\n    int k;\n    int place;\n    player(int a,int b,int c):time(a),k(b),place(c){\n        \n    }\n};\nclass room{\npublic:\n    bool used;\n    int k;\n    vector<road> rouka;\n    room():used(false){\n        \n    }\n};\nbool operator<(const player &a,const player &b){\n    return a.time<b.time;\n}\nbool operator>(const player &a,const player &b){\n    return a.time>b.time;\n}\nint main(){\n    int N,M,X;\n    cin>>N>>M>>X;\n    room *map;\n    map= new room[N+1];\n    for(int i=1;i<N+1;++i) {\n        cin>>map[i].k;\n        --map[i].k;\n    }\n    int a,b,c;\n    for(int i=0;i<M;++i){\n        cin>>a>>b>>c;\n        map[a].rouka.push_back(road(b,c));\n        map[b].rouka.push_back(road(a,c));\n    }\n    priority_queue<player,vector<player>,greater<player> >que;\n    que.push(player(0,0,1));\n    while(true){\n        player dummy=que.top();que.pop();\n        if(dummy.place==N){\n            cout<<dummy.time<<endl;\n            break;\n        }\n        if(map[dummy.place].used){\n            continue;\n        }\n        if(dummy.k==0){\n            map[dummy.place].used=true;\n        }\n        if(map[dummy.place].k!=0){\n            map[dummy.place].used=true;\n            dummy.k=map[dummy.place].k*X;\n        }\n        for(vector<road>::iterator p=map[dummy.place].rouka.begin(),fi=map[dummy.place].rouka.end();p!=fi;++p){\n            int nk=(dummy.k>0)?max(dummy.k-p->distance,0):min(dummy.k+p->distance,0);\n            if(map[p->to].k*nk>=0){\n                que.push(player(dummy.time+p->distance,nk,p->to));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 1e9;\n\nstruct E{\n  E(int to, int cost): to(to), cost(cost){}\n  int to, cost;\n};\n\nint n, m, x;\nint t[10000];\nvector<E> g[10000 * 401];\nint d[10000 * 401];\n\nint id(int i, int j){\n  return i * 401 + j;\n}\n\nvoid add_edge(int a, int b, int c){\n  if(t[a] == 1){\n    if(t[b] == 1){\n      rep(i, x){\n        g[id(a, i)].push_back(E(id(b, i + c < x ? i + c : 400), c));\n        g[id(a, i + 200)].push_back(E(id(b, i + c < x ? i + c + 200 : 400), c));\n      }\n      g[id(a, 400)].push_back(E(id(b, 400), c));\n    }\n    if(t[b] == 0){\n      rep(i, x){\n        g[id(a, i)].push_back(E(id(b, 0), c));\n      }\n      for(int i = x - c; i < x; ++i){\n        g[id(a, i + 200)].push_back(E(id(b, 0), c));\n      }\n      g[id(a, 400)].push_back(E(id(b, 0), c));\n    }\n    if(t[b] == 2){\n      for(int i = x - c; i < x; ++i){\n        g[id(a, i)].push_back(E(id(b, 200), c));\n      }\n      rep(i, x){\n        g[id(a, i + 200)].push_back(E(id(b, 200), c));\n      }\n      g[id(a, 400)].push_back(E(id(b, 200), c));\n    }\n  }\n  if(t[a] == 0){\n    if(t[b] == 1){\n      g[id(a, 0)].push_back(E(id(b, c < x ? c : 400), c));\n    }\n    if(t[b] == 0){\n      g[id(a, 0)].push_back(E(id(b, 0), c));\n    }\n    if(t[b] == 2 && c >= x){\n      g[id(a, 0)].push_back(E(id(b, 200), c));\n    }\n  }\n  if(t[a] == 2){\n    if(t[b] == 1){\n      g[id(a, 200)].push_back(E(id(b, c < x ? c + 200 : 400), c));\n    }\n    if(t[b] == 0 && c >= x){\n      g[id(a, 200)].push_back(E(id(b, 0), c));\n    }\n    if(t[b] == 2){\n      g[id(a, 200)].push_back(E(id(b, 200), c));\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d%d%d\", &n, &m, &x);\n  rep(i, n){\n    scanf(\"%d\", &t[i]);\n  }\n  rep(z, m){\n    int a, b, c;\n    scanf(\"%d%d%d\", &a, &b, &c);\n    --a;\n    --b;\n    add_edge(a, b, c);\n    add_edge(b, a, c);\n  }\n  fill_n(d, 10000 * 401, inf);\n  priority_queue<P> q;\n  d[id(0, 0)] = 0;\n  q.push(P(0, id(0, 0)));\n  while(!q.empty()){\n    P v = q.top();\n    q.pop();\n    if(v.first < d[v.second]){\n      continue;\n    }\n    for(vector<E>::iterator it = g[v.second].begin(); it != g[v.second].end(); ++it){\n      if(d[it->to] > d[v.second] + it->cost){\n        d[it->to] = d[v.second] + it->cost;\n        q.push(P(d[it->to], it->to));\n      }\n    }\n  }\n  int ans = inf;\n  rep(i, 401){\n    ans = min(d[id(n - 1, i)], ans);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<vector>\nusing namespace std;\nlong long dist[12000][210][2];\nlong long T[12000], n, m, p;\nvector<pair<long long, long long>>X[12000];\nvector<tuple<long long, long long, long long, long long>>Y[12000][210][2];//[to, cost, minute, heya]\npriority_queue<pair<long long, tuple<long long, long long, long long>>, vector<pair<long long, tuple<long long, long long, long long>>>, greater<pair<long long, tuple<long long, long long, long long>>>> Q;\nint main() {\n\tcin >> n >> m >> p;\n\tfor (int i = 1; i <= n; i++)cin >> T[i];\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tX[a].push_back(make_pair(b, c));\n\t\tX[b].push_back(make_pair(a, c));\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= p; j++) {\n\t\t\tfor (int k = 0; k < X[i].size(); k++) {\n\t\t\t\tlong long to = X[i][k].first, cost = X[i][k].second;\n\t\t\t\tlong long H2 = T[to];\n\t\t\t\tif (H2 == 0) {\n\t\t\t\t\tY[i][j][0].push_back(make_tuple(to, cost, 0, 0));\n\t\t\t\t\tif (j + cost >= p)Y[i][j][1].push_back(make_tuple(to, cost, 0, 0));\n\t\t\t\t}\n\t\t\t\tif (H2 == 1) {\n\t\t\t\t\tY[i][j][0].push_back(make_tuple(to, cost, min(p, j + cost), 0));\n\t\t\t\t\tY[i][j][1].push_back(make_tuple(to, cost, min(p, j + cost), 1));\n\t\t\t\t}\n\t\t\t\tif (H2 == 2) {\n\t\t\t\t\tif (j + cost >= p)Y[i][j][0].push_back(make_tuple(to, cost, 0, 1));\n\t\t\t\t\tY[i][j][1].push_back(make_tuple(to, cost, 0, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tQ.push(make_pair(0, make_tuple(1, 0, 0)));\n\tfor (int i = 0; i < 12000; i++) {\n\t\tfor (int j = 0; j < 210; j++) {\n\t\t\tdist[i][j][0] = 1LL << 60; dist[i][j][1] = 1LL << 60;\n\t\t}\n\t}\n\tdist[1][0][0] = 0; Q.push(make_pair(0, make_tuple(1, 0, 0)));\n\twhile (!Q.empty()) {\n\t\tlong long a1 = get<0>(Q.top().second), a2 = get<1>(Q.top().second), a3 = get<2>(Q.top().second); Q.pop();\n\t\tfor (int i = 0; i < Y[a1][a2][a3].size(); i++) {\n\t\t\tint to1 = get<0>(Y[a1][a2][a3][i]), to2 = get<2>(Y[a1][a2][a3][i]), to3 = get<3>(Y[a1][a2][a3][i]);\n\t\t\tint cost4 = get<1>(Y[a1][a2][a3][i]);\n\t\t\tif (dist[to1][to2][to3] > dist[a1][a2][a3] + cost4) {\n\t\t\t\tdist[to1][to2][to3] = dist[a1][a2][a3] + cost4;\n\t\t\t\tQ.push(make_pair(dist[to1][to2][to3], make_tuple(to1, to2, to3)));\n\t\t\t}\n\t\t}\n\t}\n\tlong long minx = 1LL << 60;\n\tfor (int i = 0; i <= p; i++) { minx = min(minx, min(dist[n][i][0], dist[n][i][1])); }\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 58u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nclass Edge {\npublic:\n    int no = 0;\n    int from = 0;\n    int to = 0;\n    long long weight = 0;\n\n    Edge(int no, int from, int to, long long weight) : no(no), from(from), to(to), weight(weight) {\n    }\n\n};\n\nclass Graph {\npublic:\n    const int N;\n    std::vector<std::vector<Edge>> graph;\n    Graph(int N) : N(N) {\n        this->graph.resize(N);\n    }\n\n    void add_undirected_edge(int no, const int u, const int v, const long long w) {\n        this->graph.at(u).emplace_back(Edge(no, u, v, w));\n        this->graph.at(v).emplace_back(Edge(no, v, u, w));\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    LL N, M, X;\n    cin >> N >> M >> X;\n\n    auto T = make_v<LL>(N);\n    FOR(i, 0, N) {\n        cin >> T[i];\n    }\n\n    Graph graph(N);\n    FOR(i, 0, M) {\n        LL A, B, D;\n        cin >> A >> B >> D;\n        A--; B--;\n        graph.add_undirected_edge(i, A, B, D);\n    }\n\n    auto used = make_v<bool>(N, X + 10, 3);\n\n    // time, wait, from, node\n    priority_queue<tuple<LL, LL, int, int>, vector<tuple<LL, LL, int, int>>, greater<tuple<LL, LL, int, int>>> que;\n    que.emplace(make_tuple(0, X, T[0], 0));\n\n    while (not que.empty()) {\n        LL time, wait, from, u;\n        tie(time, wait, from, u) = que.top(); que.pop();\n\n        if (used[u][wait][from]) {\n            continue;\n        }\n        used[u][wait][from] = true;\n\n        if (u == N - 1) {\n            print(time);\n            return 0;\n        }\n\n        FOE(e, graph.graph[u]) {\n            int v = e.to;\n\n            // 無条件でいける\n            if (T[u] == T[v] or T[v] == 1) {\n                if (T[v] == 1) {\n                    LL new_wait = max(0ll, wait - e.weight);\n                    if (not used[v][new_wait][from]) {\n                        que.emplace(make_tuple(time + e.weight, new_wait, from, v));\n                    }\n                }\n                else {\n                    if (not used[v][X][T[v]]) {\n                        que.emplace(make_tuple(time + e.weight, X, T[v], v));\n                    }\n                }\n            }\n\n            // 条件付きでいける\n            else if (T[u] == 1) {\n                if (wait <= e.weight) {\n                    if (not used[v][X][T[v]]) {\n                        que.emplace(make_tuple(time + e.weight, X, T[v], v));\n                    }\n                }\n                else {\n                    if (T[v] == from) {\n                        if (not used[v][X][T[v]]) {\n                            que.emplace(make_tuple(time + e.weight, X, T[v], v));\n                        }\n                    }\n                }\n            }\n            else {\n                if (e.weight >= X) {\n                    if (not used[v][X][T[v]]) {\n                        que.emplace(make_tuple(time + e.weight, X, T[v], v));\n                    }\n                }\n            }\n\n        }\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, d;\n    Corridor() {};\n    Corridor(int target, int d): target(target), d(d) {}\n};\n\nstruct Room {\npublic:\n    int id, t;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int t): id(id), t(t) {}\n};\n\nstruct State {\n    int id, time, t, d;\n    State(int id, int time, int t, int d): id(id), time(time), t(t), d(d) {};\n    bool operator < (const State &s) const {\n        return time > s.time;\n    }\n};\n\nint N, M, X;\nRoom rooms[MAX + 1];\nint min_time[MAX + 1][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX + 1; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[1][0][0] = 0;\n    PQ.push(State(1, 0, COLD, 0));\n    int ans = INT_MAX;\n    while(!PQ.empty()) {\n        State s = PQ.top();\n        PQ.pop();\n        if(s.id == N) {\n            ans = min(ans, s.time);\n            continue;\n        }\n        if(s.time > ans) break;\n        for(auto c: rooms[s.id].edge) {\n            if(abs(s.t - rooms[c.target].t) > 1 && s.d + c.d < X) continue;\n            if(rooms[c.target].t == CONFORTABLE) {\n                if(min_time[c.target][s.t / 2][min(X, s.d + c.d)] < s.time + c.d) continue;\n                min_time[c.target][s.t / 2][min(X, s.d + c.d)] = s.time + c.d;\n                PQ.push(State(c.target, s.time + c.d, s.t, min(X, s.d + c.d)));\n            } else {\n                if(min_time[c.target][rooms[c.target].t / 2][0] < s.time + c.d) continue;\n                min_time[c.target][rooms[c.target].t / 2][0] = s.time + c.d;\n                PQ.push(State(c.target, s.time + c.d, rooms[c.target].t, 0));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int t, a, b, d;\n    cin >> N >> M >> X;\n\n    for (int i = 1; i < N + 1; i++) {\n        cin >> t;\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b >> d;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n)cin>>t[i];\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (d[v][type][tim] < dist) continue;\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 1) {\n                u = e.to, ntype = type, ntim = min(200, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = type, ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n\n    int ans = inf;\n\n    rep(i, 2) rep(j, 205) ans = min(ans, d[n-1][i][j]);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nstruct edge {\n    int to, weight;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N, M, X;\n    cin >> N >> M >> X;\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n    }\n    graph g(N);\n    for(int i=0; i<M; ++i) {\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--; b--;\n        g[a].push_back((edge){b, d});\n        g[b].push_back((edge){a, d});\n    }\n    \n    using state = tuple<int, int, int, int>;\n    vector<vector<vector<int>>> d(N, vector<vector<int>>(3, vector<int>(X+1, INF)));\n    d[0][0][X] = 0;\n    priority_queue<state, vector<state>, greater<state>> que;\n    que.push(make_tuple(0, 0, 0, X));\n    while(!que.empty()) {\n        int cd, v, t, x;\n        tie(cd, v, t, x) = que.top();\n        que.pop();\n        if(d[v][t][x] < cd) {\n            continue;\n        }\n        for(auto& e : g[v]) {\n            int nx = (T[e.to] == 1 ? max(0, x - e.weight) : X);\n            if(T[e.to] == 1 && d[e.to][t][nx] > d[v][t][x] + e.weight) {\n                d[e.to][t][nx] = d[v][t][x] + e.weight;\n                que.push(make_tuple(d[e.to][t][nx], e.to, t, nx));\n            } else if(T[e.to] != 1 && (T[e.to] != t && x <= e.weight || T[e.to] == t)) {\n                if(d[e.to][T[e.to]][nx] > d[v][t][x] + e.weight) {\n                    d[e.to][T[e.to]][nx] = d[v][t][x] + e.weight;\n                    que.push(make_tuple(d[e.to][T[e.to]][nx], e.to, T[e.to], nx));\n                }\n            }\n        }\n    }\n    int res = INF;\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<X+1; ++j) {\n            res = min(res, d[N-1][i][j]);\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint d[11111][3][201];\nint main() {\n  int n,m,k;\n  cin >> n >> m >> k;\n  int a[n];\n  for(int i=0; i<n; i++) cin >> a[i];\n  vector<P> v[m];\n  for(int i=0; i<m; i++) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    x--,y--;\n    v[x].push_back(P(y,z));\n    v[y].push_back(P(x,z));\n  }\n  priority_queue<PP,vector<PP>,greater<PP> > que;\n  que.push(PP(P(0,0),P(a[0],0)));\n  for(int i=0;i<n;i++)for(int j=0;j<3;j++)for(int l=0;l<=k;l++)d[i][j][l]=1<<29;\n  d[0][a[0]][0]=0;\n  int ans=1<<29;\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    int c=p.first.first,x=p.first.second,s=p.second.first,t=p.second.second;\n    if(x==n-1) {\n      ans=c;\n      break;\n    }\n    if(d[x][s][t]<c) continue;\n    for(int i=0; i<v[x].size(); i++) {\n      int y=v[x][i].first,cc=v[x][i].second;\n      int tt=min(k,t+cc),ss=s;\n      if(abs(s-a[y])==2&&tt!=k) continue;\n      if(a[y]!=1) tt=0,ss=a[y];\n      if(d[y][ss][tt]>d[x][s][t]+cc) {\n        d[y][ss][tt]=d[x][s][t]+cc;\n        que.push(PP(P(d[y][ss][tt],y),P(ss,tt)));\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n, m, x;\n    cin >> n >> m >> x;\n    vector<int> v(n);\n    for (auto &&i : v) scanf(\"%d\", &i);\n    using P = pair<int, int>;\n    int N = n*2*(x+1);\n    vector<vector<P>> G(N);\n    for (int i = 0; i < m; ++i) {\n        int a, b, d;\n        scanf(\"%d %d %d\", &a, &b, &d);\n        a--; b--;\n        G[a].emplace_back(b, d);\n        G[b].emplace_back(a, d);\n    }\n    auto f = [&x](int i, int j, int k){\n        return i*2*(x+1) + j*(x+1) + k;\n    };\n\n    vector<int> d(N, INF<int>);\n    priority_queue<P, vector<P>, greater<>> Q;\n    d[f(0, 0, x)] = 0;\n    Q.emplace(0, f(0, 0, x));\n    while(!Q.empty()){\n        int cost, i;\n        tie(cost, i) = Q.top(); Q.pop();\n        int a = i/(2*(x+1)), b = (i/(x+1)) & 1, c = i % (x+1);\n        if(d[i] < cost) continue;\n        auto update = [&](int x, int p) -> void{\n            if(d[x] <= p) return;\n            d[x] = p;\n            Q.emplace(d[x], x);\n        };\n        for (auto &&e : G[a]) {\n            int to, val; tie(to, val) = e;\n            if(v[to] == 1){\n                update(f(to, b, max(0, c-val)), cost+val);\n            }else if(v[to] == 0) {\n                if(b == 0 || max(0, c-val) == 0) update(f(to, 0, x), cost+val);\n            }else {\n                if(b == 1 || max(0, c-val) == 0) update(f(to, 1, x), cost+val);\n            }\n        }\n    }\n    int ans = INF<int>;\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j <= x; ++j) {\n            ans = min(ans, d[f(n-1, i, j)]);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10010];\nvector<P>rinsetu[10010];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10010][4][301];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost, 0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1<<25;//1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nstruct state {\n  int v, cost, rt, te;\n  state(){}\n  state(int v, int cost, int rt, int te):v(v), cost(cost), rt(rt), te(te){}\n  bool operator < (const state& r) const {\n    return cost > r.cost;\n  }\n};\n\nint N, M, X;\nint T[10010];\n\nvector<edge> G[10010];\nint mincost[2][202][10010];\n\nint dijkstra()\n{\n  rep(i, 2) rep(j, 202) rep(k, 10010) mincost[i][j][k] = inf;\n  priority_queue<state> que;\n  que.emplace(0, 0, 0, 0);\n  mincost[0][0][0] = 0;\n  while(!que.empty()) {\n    state s = que.top(); que.pop();\n    if(s.v == N-1) return s.cost;\n    if(s.cost > mincost[s.rt/2][s.te][s.v]) continue;\n    for(edge& e : G[s.v]) {\n      if(abs(s.rt - T[e.to]) == 2 && s.te + e.cost < X) continue;\n      int nrt = s.rt, nte = s.te + e.cost;\n      if(T[e.to] != 1) nrt = T[e.to], nte = 0;\n      if(s.cost + e.cost < mincost[nrt/2][nte][e.to]) {\n\tmincost[nrt/2][nte][e.to] = s.cost + e.cost;\n\tque.emplace(e.to, s.cost + e.cost, nrt, nte);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> X;\n  rep(i, N) cin >> T[i];\n  rep(i, M) {\n    int A, B, D;\n    cin >> A >> B >> D; A--, B--;\n    G[A].emplace_back(B, D);\n    G[B].emplace_back(A, D);\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tCOLD,\n\tMID,\n\tHOT,\n};\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_sum_time,int arg_rest,Type arg_pre_type){\n\t\tnode_id = arg_node_id;\n\t\tsum_time = arg_sum_time;\n\t\trest = arg_rest;\n\t\tpre_type = arg_pre_type;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_time > arg.sum_time;\n\t};\n\tint node_id,sum_time,rest;\n\tType pre_type;\n};\n\nstruct Data{\n\tData(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nint dp[3][10000][201];\nType room_info[10000],type_array[3] = {COLD,MID,HOT};\n\n\nint main(){\n\n\tint N,M,X;\n\tscanf(\"%d %d %d\",&N,&M,&X);\n\n\tint tmp;\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\troom_info[i] = type_array[tmp];\n\t}\n\n\tvector<Data> V[N];\n\n\tint from,to,cost;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&cost);\n\t\tfrom--;\n\t\tto--;\n\t\tV[from].push_back(Data(to,cost));\n\t\tV[to].push_back(Data(from,cost));\n\t}\n\n\tfor(int i = 0; i <= N-1; i++){\n\t\tfor(int k = 0; k <= X; k++){\n\t\t\tdp[COLD][i][k] = BIG_NUM;\n\t\t\tdp[MID][i][k] = BIG_NUM;\n\t\t\tdp[HOT][i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tdp[COLD][0][X] = 0;\n\tQ.push(Info(0,0,X,COLD));\n\n\tint ans = BIG_NUM,next_node,next_rest;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == N-1){\n\t\t\tans = min(ans,Q.top().sum_time);\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_time > dp[Q.top().pre_type][Q.top().node_id][Q.top().rest]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = V[Q.top().node_id][i].to;\n\n\t\t\t\tif(room_info[next_node] == MID){\n\t\t\t\t\tnext_rest = max(0,Q.top().rest-V[Q.top().node_id][i].cost);\n\n\t\t\t\t\tif(next_rest > 0){\n\n\t\t\t\t\t\tif(dp[Q.top().pre_type][next_node][next_rest] > Q.top().sum_time+V[Q.top().node_id][i].cost){\n\t\t\t\t\t\t\tdp[Q.top().pre_type][next_node][next_rest] = Q.top().sum_time+V[Q.top().node_id][i].cost;\n\t\t\t\t\t\t\tQ.push(Info(next_node,dp[Q.top().pre_type][next_node][next_rest],next_rest,Q.top().pre_type));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //next_rest == 0\n\t\t\t\t\t\tif(dp[MID][next_node][0] > Q.top().sum_time+V[Q.top().node_id][i].cost){\n\t\t\t\t\t\t\tdp[MID][next_node][0] = Q.top().sum_time+V[Q.top().node_id][i].cost;\n\t\t\t\t\t\t\tQ.push(Info(next_node,dp[MID][next_node][0],0,MID));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\tif(Q.top().pre_type == MID){\n\t\t\t\t\t\tif(dp[room_info[next_node]][next_node][X] > Q.top().sum_time+V[Q.top().node_id][i].cost){\n\t\t\t\t\t\t\tdp[room_info[next_node]][next_node][X] = Q.top().sum_time+V[Q.top().node_id][i].cost;\n\t\t\t\t\t\t\tQ.push(Info(next_node,dp[room_info[next_node]][next_node][X],X,room_info[next_node]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(Q.top().pre_type == room_info[next_node]){\n\t\t\t\t\t\t\tif(dp[room_info[next_node]][next_node][X] > Q.top().sum_time+V[Q.top().node_id][i].cost){\n\t\t\t\t\t\t\t\tdp[room_info[next_node]][next_node][X] = Q.top().sum_time+V[Q.top().node_id][i].cost;\n\t\t\t\t\t\t\t\tQ.push(Info(next_node,dp[room_info[next_node]][next_node][X],X,room_info[next_node]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{ //Q.top().pre_type != room_info[next_node]\n\t\t\t\t\t\t\tif(V[Q.top().node_id][i].cost < Q.top().rest)continue;\n\n\t\t\t\t\t\t\tif(dp[room_info[next_node]][next_node][X] > Q.top().sum_time+V[Q.top().node_id][i].cost){\n\t\t\t\t\t\t\t\tdp[room_info[next_node]][next_node][X] = Q.top().sum_time+V[Q.top().node_id][i].cost;\n\t\t\t\t\t\t\t\tQ.push(Info(next_node,dp[room_info[next_node]][next_node][X],X,room_info[next_node]));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nstruct state {\n  int v, cost, rt, te;\n  state(){}\n  state(int v, int cost, int rt, int te):v(v), cost(cost), rt(rt), te(te){}\n  bool operator < (const state& r) const {\n    return cost > r.cost;\n  }\n};\n\nint N, M, X;\nint T[10010];\n\nvector<edge> G[10010];\nint mincost[2][202][10010];\n\nint dijkstra()\n{\n  rep(i, 2) rep(j, 202) rep(k, 10010) mincost[i][j][k] = inf;\n  priority_queue<state> que;\n  que.emplace(0, 0, 0, 0);\n  mincost[0][0][0] = 0;\n  while(!que.empty()) {\n    state s = que.top(); que.pop();\n    if(s.v == N-1) return s.cost;\n    if(s.cost > mincost[s.rt/2][s.te][s.v]) continue;\n    for(edge& e : G[s.v]) {\n      if(abs(s.rt - T[e.to]) == 2 && s.te + e.cost < X) continue;\n      int nrt = s.rt, nte = s.te + e.cost;\n      if(T[e.to] != 1) nrt = T[e.to], nte = 0;\n      if(s.cost + e.cost < mincost[nrt/2][nte][e.to]) {\n\tmincost[nrt/2][nte][e.to] = s.cost + e.cost;\n\tque.emplace(e.to, s.cost + e.cost, nrt, nte);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> X;\n  rep(i, N) cin >> T[i];\n  rep(i, M) {\n    int A, B, D;\n    cin >> A >> B >> D; A--, B--;\n    G[A].emplace_back(B, D);\n    G[B].emplace_back(A, D);\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <cstdlib>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <math.h>\n#include <random>\n#include <time.h>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    int N, M, X;\n    cin >> N >> M >> X;\n    int T[10000];\n    for(int i=0; i<N; i++) cin >> T[i];\n    vector<pair<int, int>> root[10000];\n    for(int i=0; i<M; i++){\n        int A, B, D;\n        cin >> A >> B >> D;\n        A--; B--;\n        root[A].push_back(make_pair(B, D));\n        root[B].push_back(make_pair(A, D));\n    }\n\n    int cost[10000][2][201];//その部屋から出るときにどのような状態か\n    for(int i=0; i<N; i++){\n        for(int j=0; j<=X; j++){\n            cost[i][0][j] = INT_MAX;\n            cost[i][1][j] = INT_MAX;\n        }\n    }\n    cost[0][0][X] = 0;\n    bool already[10000][2][201] = {};\n\n    priority_queue<pair<int, pair<int, int>>> que; //cost, place, time(-のときは寒い部屋を出てから、+のときは暑い部屋を出てから)\n    que.push(make_pair(INT_MAX-0, make_pair(0, -X)));\n    int ans = INT_MAX;\n    while(!que.empty()){\n        int now = que.top().second.first;\n        int c = INT_MAX - que.top().first;\n        int t = que.top().second.second;\n        int state2 = 0;\n        if(t > 0) state2 = 1;\n        if(already[now][state2][abs(t)]){\n            que.pop();\n            continue;\n        }\n        if(c >= ans) break;\n        for(int i=0; i<root[now].size(); i++){\n            int next = root[now][i].first;\n            if(t > 0 && T[next] == 0 && root[now][i].second < t) continue;\n            if(t < 0 && T[next] == 2 && root[now][i].second < -t) continue;\n\n            int t2 = 0;\n            if(t > 0) t2 = max(0, t-root[now][i].second);\n            if(t < 0) t2 = min(0, t+root[now][i].second);\n            if(T[next] == 0) t2 = -X;\n            if(T[next] == 2) t2 = X;\n            int state = 0;\n            if(t2 > 0) state = 1;\n            if(cost[next][state][abs(t2)] < c + root[now][i].second) continue;\n\n            cost[next][state][abs(t2)] = c + root[now][i].second;\n            que.push(make_pair(INT_MAX-c-root[now][i].second, make_pair(next, t2)));\n\n            if(next == N-1) ans = min(ans, cost[next][state][abs(t2)]);\n        }\n        already[now][state2][abs(t)] = true;\n        que.pop();\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n/*\n#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n\nint main(){\n    \n    \n    \n    return 0;\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\ntypedef long long int ll;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\ntemplate<typename T>\nbool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false;}\ntemplate<typename T>\nbool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false;}\n// clang-format on\n\n#include <tuple>\n#include <queue>\n// cost, x, to, type\nusing Edge = tuple<ll, int, int, int>;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m, x;\n    cin >> n >> m >> x;\n    vector<int> room(n);\n    REP(i, 0, n) {\n        cin >> room[i];\n    }\n    vector<vector<Edge>> G(n);\n    REP(i, 0, m) {\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--;\n        b--;\n        G[a].emplace_back(d, -1, b, -1);\n        G[b].emplace_back(d, -1, a, -1);\n    }\n    priority_queue<Edge, vector<Edge>, greater<Edge>> pq;\n    pq.emplace(0, 0, 0, room[0]);\n    const ll inf = 1LL << 60;\n    auto Cost = make_v(n, x + 1, inf);\n    while (pq.size()) {\n        ll cost;\n        int rem, to, type;\n        tie(cost, rem, to, type) = pq.top();\n        pq.pop();\n        if (Cost[to][rem] < cost) continue;\n        Cost[to][rem] = cost;\n        REP(i, 0, G[to].size()) {\n            int ncost, nto;\n            tie(ncost, ignore, nto, ignore) = G[to][i];\n            int nrem = min(rem + ncost, x);\n            if ((type ^ room[nto]) == 2 && nrem < x) continue;\n            if (type == room[nto]) {\n                nrem = 0;\n            }\n            int ntype = type;\n            if ((type ^ room[nto]) == 2) {\n                ntype = room[nto];\n                nrem = 0;\n            }\n            if (chmin(Cost[nto][nrem], cost + ncost)) {\n                pq.emplace(Cost[nto][nrem], nrem, nto, ntype);\n            }\n        }\n    }\n    cout << *min_element(Cost[n - 1].begin(), Cost[n - 1].end()) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst ll INF = 1e9;\n\nstruct edge {\n\tint to;\n\tint cost;\n\tedge(int t, int c) : to(t), cost(c) {}\n};\n\nstruct dijk {\n\tint v, t;\n\tll dist;\n\tdijk(int v, int t, ll d) : v(v), t(t), dist(d) {}\n\tbool operator>(const dijk& that) const {\n\t\treturn dist > that.dist;\n\t}\n};\n\nint main()\n{\n\tint N, M, X;\n\tcin >> N >> M >> X;\n\tvector<int> T(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> T[i];\n\t}\n\tvector<vector<edge>> G(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, d;\n\t\tcin >> a >> b >> d; a--, b--;\n\t\tG[a].emplace_back(b, d);\n\t\tG[b].emplace_back(a, d);\n\t}\n\tvector<vector<ll>> d(N, vector<ll>(X * 2 + 1, INF));\n\tpriority_queue<dijk, vector<dijk>, greater<>> pq;\n\tpq.emplace(0, 0, 0);\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tif (d[p.v][p.t] != INF) continue;\n\t\td[p.v][p.t] = p.dist;\n\t\tfor (auto e : G[p.v]) {\n\t\t\tint tt = p.t < X ? min(X, p.t + e.cost) : p.t > X ? max(X, p.t - e.cost) : X;\n\t\t\tif (T[e.to] == 0) {\n\t\t\t\tif (tt > X) continue;\n\t\t\t\ttt = 0;\n\t\t\t}\n\t\t\telse if (T[e.to] == 2) {\n\t\t\t\tif(tt < X) continue;\n\t\t\t\ttt = X * 2;\n\t\t\t}\n\t\t\tif (d[e.to][tt] == INF) {\n\t\t\t\tpq.emplace(e.to, tt, p.dist + e.cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << *min_element(d[N - 1].begin(), d[N - 1].end()) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 112000000012345678LL\n\nusing P = pair<long,int>;\n// cost, idx\n\nint t[10005];\n\nlong d[200*2*10005];\nvector<P> vec[200*2*10005];\n\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  rep(i,n) cin>>t[i];\n\n  rep(_,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    rep(__,2){\n      int ai = a*2*x, bi = b*2*x;\n      if(t[b]==1){\n        if(t[a]!=1){\n          // [0,2] -> 1\n          if(t[a]==2) bi += x;\n          vec[ai].pb(mp(c, bi + max(0, x-c)));\n        }\n        else {\n          // 1 -> 1\n          vec[ai].pb(mp(c, bi));\n          repl(i,1,x){\n            vec[ai+i].pb(mp(c, bi + max(0, i-c)));\n            vec[ai+x+i].pb(mp(c, bi + x + max(0, i-c) ));\n          }\n        }\n      }\n      else if(t[a] == t[b]){\n        // 0 -> 0, 2 -> 2\n        vec[ai].pb(mp(c, bi));\n      }\n      else if(t[a]==1){\n        // 1 -> 2, 1 -> 0\n        if(t[b]==2) ai += x;\n        rep(i,x) vec[ai + i].pb(mp(c, bi));\n\n        ai = a*2*x;\n        if(t[b]==0) ai += x;\n        rep(i,min(c+1,x)) vec[ai + i].pb(mp(c, bi));\n      }\n      else {\n        // 0->2, 2->0\n        if(x <= c) vec[ai].pb(mp(c, bi));\n      }\n\n      swap(a,b);\n    } // make edges\n  }\n\n  rep(i,n) if(t[i]==1){\n    int ai = 2*i*x;\n    vec[ai].pb(mp(0,ai+x));\n    vec[ai+x].pb(mp(0,ai));\n  }\n\n  priority_queue<P, vector<P>, greater<P>> pq;\n  fill(d, d + 2*x*n, INF);\n  d[0] = 0;\n  pq.push(mp(0,0));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    if(d[p.se] < p.fi) continue;\n    for(auto to : vec[p.se]){\n      long nd = p.fi + to.fi;\n      int ni = to.se;\n      if(d[ni] > nd){\n        pq.push(mp(nd,ni));\n        d[ni] = nd;\n      }\n    }\n  }\n\n  long ans = INF;\n  rep(i,2*x) ans = min(ans, d[(n-1)*2*x + i]);\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n// WA?¨????\n// mp(cost, idx)?????????????????´?????§???????????????fi??¨se???????????£???\n// t[i]==1 ????????????x????????????????????£???"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = 10000000;\n\nint n,m,x;\nint room[10000];\nvector<PII> pass[10000]; // [from] = (cost, to)\n\nstruct state{\n\tint d, p, d2;\n\tbool cold;\n\tbool operator<(const state& a) const {\n\t\treturn d == a.d ? d2 < a.d2 : d < a.d;\n\t}\n};\n\n// [??´???, ?????????????????¨?±??????¶???,??????]?????????????????¢\nint dist[10000][2][200+1];\n\nint main() {\n\tcin>>n>>m>>x;\n\tREP(i,n)cin >> room[i];\n\tREP(i,m){\n\t\tint a,b,d;\n\t\tcin >> a >> b >> d;\n\t\ta--;b--;\n\t\tpass[a].push_back(MP(d,b));\n\t\tpass[b].push_back(MP(d,a));\n\t}\n\tREP(i,n){\n\t\tSORT(pass[i]);\n\t\tUNIQUE(pass[i]);\n\t}\n\n\tpriority_queue<state> q;\n\tq.push((state){0,0,0,true});\n\n\tREP(i,n)REP(j,2)REP(k,x+1)dist[i][j][k]=INF;\n\n\twhile(!q.empty()){\n\t\tstate s = q.top();q.pop();\n\t\tEACH(i,pass[s.p]){\n\t\t\tint d = (*i).first,p = (*i).second;\n\t\t\tint nd = s.d + d;\n\t\t\tint nd2 = s.d2 + d;\n\t\t\tif(room[p]==1){\n\t\t\t\t// ?????¢???????????????????????????\n\t\t\t\tif(nd < dist[p][s.cold][min(nd2, x)]){\n\t\t\t\t\tdist[p][s.cold][min(nd2, x)] = nd;\n\t\t\t\t\tq.push((state){nd, p, min(nd2, x), s.cold});\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// cold????????¢????????????d2???????????????d???????????????d2=0???????????´??°\n\t\t\t\t// cold????????¢??????????????????d????????????d2=0\n\t\t\t\tif(s.cold == !!room[p])// ?????¢\n\t\t\t\t\tif(nd2 < x)continue; // ??\\???????????????\n\t\t\t\t// ??\\???????????§?????????????????´??????????????¨\n\t\t\t\tif(nd < dist[p][!room[p]][0]){\n\t\t\t\t\tdist[p][!room[p]][0] = nd;\n\t\t\t\t\tq.push((state){nd, p, 0, !room[p]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\tREP(j,2)REP(k,x)ans=min(ans,dist[n-1][j][k]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\ntypedef pair< int,int > PII;\ntypedef pair< int,pair<int,int> > PPII;\ntypedef pair< int,pair<int,pair<int, int> > > PPPII;\n\nstruct edge{\n    int to,cost;\n    edge(){}\n    edge(int p1,int p2){\n        to=p1;\n        cost=p2;\n    }\n};\n\ntypedef pair<int,int> PII;\nvector<edge> G[10005];\nint dist[10005][205][5];\nint A[20005];\nint N,M,X;\n\n\nvoid dijkstra(int s){\n    priority_queue<PPPII,vector<PPPII>,greater<PPPII> > que;\n    for(int i=0;i<10005;++i)for(int j=0;j<=200;++j)for(int k=0;k<3;++k)dist[i][j][k]=INF;\n    dist[s][0][A[s]]=0;\n    que.push(PPPII(0,PPII(s,PII(0,A[s]))));\n    while(!que.empty()){\n        PPPII p = que.top();\n        que.pop();\n        int v=p.second.first;\n        int time=p.second.second.first;\n        int hot=p.second.second.second;\n        if(dist[v][time][hot]<p.first)continue;\n        for(int i=0;i<G[v].size();i++){\n            edge e = G[v][i];\n            int ntime,nhot;\n            if(A[e.to]==0){\n                if(hot==2){\n                    if(time+e.cost<X)continue;\n                    else {\n                        ntime=0;\n                        nhot=A[e.to];\n                        if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                            dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                            que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                        }\n                    }\n                }\n                if(hot==0){\n                    ntime=0;\n                    nhot=A[e.to];\n                    if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                        dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                        que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                    }\n                }\n            }\n            else if(A[e.to]==2){\n                if(hot==0){\n                    if(time+e.cost<X)continue;\n                    else {\n                        ntime=0;\n                        nhot=A[e.to];\n                        if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                            dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                            que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                        }\n                    }\n                }\n                if(hot==2){\n                    ntime=0;\n                    nhot=A[e.to];\n                    if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                        dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                        que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                    }\n                }\n            }\n\n            else if(A[e.to]==1){\n                ntime=time+e.cost;\n                nhot=hot;\n                if(ntime>=X)ntime=200;\n                if(dist[e.to][ntime][nhot]>dist[v][time][hot]+e.cost){\n                    dist[e.to][ntime][nhot] = dist[v][time][hot]+e.cost;\n                    que.push(PPPII(dist[e.to][ntime][nhot],PPII(e.to,PII(ntime,nhot))));\n                }\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin>>N>>M>>X;\n    for(int i=0;i<N;++i)cin>>A[i];\n    for(int i=0;i<M;++i){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;\n        b--;\n        G[a].PB(edge(b,c));\n        G[b].PB(edge(a,c));\n    }\n    dijkstra(0);\n    int ans=INF;\n    for(int i=0;i<=200;++i){\n        for(int j=0;j<3;++j){\n            ans=min(ans,dist[N-1][i][j]);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint v[11000][2][210];\nint ijk[11000][2][210];\nvector<pair<int,int> > g[11000];\nint t[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",t+i);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);p--;q--;g[p].push_back(make_pair(q,r));\n\t\tg[q].push_back(make_pair(p,r));\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<=c;j++)for(int k=0;k<2;k++)ijk[i][k][j]=mod;\n\tpriority_queue<pair<pair<int,int>,pair<int,int> > >Q;\n\tQ.push(make_pair(make_pair(0,0),make_pair(0,c)));\n\tijk[0][0][c]=0;\n\twhile(Q.size()){\n\t\tint cost=-Q.top().first.first;\n\t\tint at=Q.top().second.first;\n\t\tint tp=Q.top().first.second;\n\t\tint T=Q.top().second.second;Q.pop();\n\t\tif(v[at][tp][T])continue;\n\t\t// printf(\"%d %d: %d\\n\",at,T,cost);\n\t\tv[at][tp][T]=1;\n\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\tint to=g[at][i].first;\n\t\t\tint toc=cost+g[at][i].second;\n\t\t\tint tt=max(T-g[at][i].second,0);\n\t\t\t// if(tt&&ABS(t[at]-t[to])==2)continue;\n\t\t\tif(tt){\n\t\t\t\tif(tp==0&&t[to]==2)continue;\n\t\t\t\tif(tp==1&&t[to]==0)continue;\n\t\t\t}\n\t\t\tif(t[to]!=1)tt=c;\n\t\t\t\n\t\t\tint ttp=tp;\n\t\t\tif(t[to]==0)ttp=0;\n\t\t\tif(t[to]==2)ttp=1;\n\t\t\tif(v[to][ttp][tt])continue;\n\t\t\tif(ijk[to][tp][tt]>toc){\n\t\t\t\tijk[to][tp][tt]=toc;\n\t\t\t\tQ.push(make_pair(make_pair(-toc,ttp),make_pair(to,tt)));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=mod;\n\tfor(int i=0;i<=c;i++)ret=min(ret,min(ijk[a-1][0][i],ijk[a-1][1][i]));\n\tprintf(\"%d\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = 10000000;\n\nint n,m,x;\nint room[10000];\nvector<PII> pass[10000]; // [from] = (cost, to)\n\nstruct state{\n\tint d, p, d2;\n\tbool cold;\n\tbool operator<(const state& a) const {\n\t\treturn d == a.d ? d2 > a.d2 : d < a.d;\n\t}\n};\n\n// ????????????????????¨?±?i????????£??¨????????????????????§??\\?????????????????????????????¨?±??????????h?????¨?±???????\n//?????????????????¢????????????distc[h][i]\nint distc[2][10000];\n\nint main() {\n\tcin>>n>>m>>x;\n\tREP(i,n)cin >> room[i];\n\tREP(i,m){\n\t\tint a,b,d;\n\t\tcin >> a >> b >> d;\n\t\ta--;b--;\n\t\tpass[a].push_back(MP(d,b));\n\t\tpass[b].push_back(MP(d,a));\n\t}\n\tREP(i,n){\n\t\tauto& v = pass[i];\n\t\tSORT(v);\n\t\tUNIQUE(v);\n\t}\n\n\tpriority_queue<state> q;\n\tq.push((state){0,0,0,true});\n\n\tint dist[n];\n\tREP(i,n)dist[i]=INF;\n\tdist[0]=0;\n\n\twhile(!q.empty()){\n\t\tstate s = q.top();q.pop();\n\t\tEACH(i,pass[s.p]){\n\t\t\tint d = (*i).first,p = (*i).second;\n\t\t\tint nd = s.d + d;\n\t\t\tint nd2 = s.d2 + d;\n\t\t\tif(room[p]==1){\n\t\t\t\t// ?????¢???????????????????????????\n\t\t\t\t// ????????????d2?????´??°??§??????????????????\n\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\tdistc[s.cold][p] = nd2;\n\t\t\t\t\tq.push((state){nd, p, nd2, s.cold});\n\t\t\t\t}else if(distc[s.cold][p] < x){\n\t\t\t\t\tdistc[s.cold][p] = nd2;\n\t\t\t\t\tq.push((state){nd, p, nd2, s.cold});\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// cold????????¢????????????d2???????????????d???????????????d2=0???????????´??°\n\t\t\t\t// cold????????¢??????????????????d????????????d2=0\n\t\t\t\tif(s.cold == !!room[p]){ // ?????¢\n\t\t\t\t\tif(nd2 < x)continue; // ??\\???????????????\n\t\t\t\t\t// ??\\???????????????d2=0????????§??????????????´??????????????¨\n\t\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\t\tq.push((state){nd, p, 0, !room[p]});\n\t\t\t\t\t}\n\t\t\t\t}else{ // ?????¢?????????\n\t\t\t\t\t// ??\\???????????§?????????????????´??????????????¨\n\t\t\t\t\tif(nd < dist[p]){\n\t\t\t\t\t\tdist[p] = nd;\n\t\t\t\t\t\tq.push((state){nd, p, 0, !room[p]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[n-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define INF (1000000000000000000LL)\n\ntypedef pair<long long, int> P;\n\nstruct Q {\n    long long time;\n    long long togo;\n    int status;\n    int room;\n    Q() {}\n    Q(long long a,long long b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    long long X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n        --T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        to[a-1].push_back(P((long long)d,b-1));\n        to[b-1].push_back(P((long long)d,a-1));\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    vector<long long> time(N,INF);\n//    unordered_map<int,long long> um;\n\n    q.push(Q(0LL,X,-1,0));\n\n    while(true) {\n        Q now=q.top(); q.pop();\n        if(T[now.room]!=0 && time[now.room]<now.time) continue;\n        time[now.room]=now.time;\n        if(now.room==N-1) break;\n        for(auto nxt : to[now.room]) {\n            if(T[nxt.second]!=0 && time[nxt.second]<now.time+nxt.first) continue;\n\n            if(T[nxt.second]==0 && (T[now.room]==0 || time[nxt.second]>now.time+nxt.first)) {\n                time[nxt.second]=now.time+nxt.first;\n                q.push(Q(now.time+nxt.first,max(0LL,now.togo-nxt.first),now.status,nxt.second));\n            } else if(T[nxt.second]==now.status || nxt.first>=now.togo) {\n                time[nxt.second]=now.time+nxt.first;\n                q.push(Q(time[nxt.second],X,T[nxt.second],nxt.second));\n            }\n        }\n    }\n\n    cout << time[N-1] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma warning(disable:4996)\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10010];\nvector<P>rinsetu[10010];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10010][4][301];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost,0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < c; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define INF (1000000000000000000LL)\n\ntypedef pair<long long, int> P;\n\nstruct Q {\n    long long time;\n    long long togo;\n    int status;\n    int room;\n    Q() {}\n    Q(long long a,long long b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    long long X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n        --T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        if(T[a-1]*T[b-1]>=0 || d>=X) {\n            to[a-1].push_back(P((long long)d,b-1));\n            to[b-1].push_back(P((long long)d,a-1));\n        }\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    vector<long long> time(N,INF);\n//    unordered_map<int,long long> um;\n\n    q.push(Q(0LL,X,-1,0));\n\n    while(true) {\n        Q now=q.top(); q.pop();\n        if(T[now.room]!=0 && time[now.room]<now.time) continue;\n        time[now.room]=now.time;\n        if(now.room==N-1) break;\n        for(auto nxt : to[now.room]) {\n            if(T[nxt.second]!=0 && time[nxt.second]<now.time+nxt.first) continue;\n\n            if(T[nxt.second]==0) {\n//                um[nxt.second]=min(um[nxt.second],now.time+nxt.first);\n                q.push(Q(now.time+nxt.first,max(0LL,now.togo-nxt.first),now.status,nxt.second));\n            } else if(T[nxt.second]==now.status || nxt.first>=now.togo) {\n                time[nxt.second]=now.time+nxt.first;\n                q.push(Q(time[nxt.second],X,T[nxt.second],nxt.second));\n            }\n        }\n    }\n\n    cout << time[N-1] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e15;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(LL t, LL c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\n\nvoid add_edge(Graph& graph, int u, int v, LL cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nint N, M, X;\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> M >> X;\n  VI ty(N);\n  REP(i,N) cin >> ty[i];\n  Graph G(N);\n  REP(i,M){\n\tint u, v, d;\n\tcin >> u >> v >> d;\n\tif(!(d > X && ((ty[u] == 0 && ty[v] == 2) || (ty[u] == 2 && ty[v] == 0))))\n\t  add_edge(G, u-1, v-1, d);\n  }\n\n  // 0 - X : cold, X - 2X: hot\n  VVL dp(N, VL(2*X+1, INF));\n  using Type = pair<LL,PII>;\n  priority_queue<Type, vector<Type>, greater<Type> > pq;\n  dp[0][0] = 0;\n  pq.push(MP(0,MP(0,0)));\n\n  while(!pq.empty()){\n\tType pii = pq.top(); pq.pop();\n\tLL d = pii.FF;\n\tPII s = pii.second;\n\tif(dp[s.FF][s.SS] < d) continue;\n\tfor(auto&& e: G[s.FF]){\n\t  int nxt_tmp = (s.SS <= X? min(X, s.SS+e.cost): max(X, s.SS-e.cost));\n\t  LL nxt_d = dp[s.FF][s.SS] + e.cost;\n\t  if(ty[e.to] == 0){\n\t\tif(nxt_tmp <= X){\n\t\t  if(dp[e.to][0] > nxt_d){\n\t\t\tdp[e.to][0] = nxt_d;\n\t\t\tpq.push(MP(nxt_d, MP(e.to, 0)));\n\t\t  }\n\t\t}\n\t  }\n\t  else if(ty[e.to] == 1){\n\t\tif(dp[e.to][nxt_tmp] > nxt_d){\n\t\t  dp[e.to][nxt_tmp] = nxt_d;\n\t\t  pq.push(MP(nxt_d, MP(e.to, nxt_tmp)));\n\t\t}\n\t  }\n\t  else{\n\t\tif(nxt_tmp >= X){\n\t\t  if(dp[e.to][2*X] > nxt_d){\n\t\t\tdp[e.to][2*X] = nxt_d;\n\t\t\tpq.push(MP(nxt_d, MP(e.to, 2*X)));\n\t\t  }\n\t\t}\n\t  }\n\t}\n  }\n\n  LL ans = INF;\n  REP(i,2*X+1) mini(ans, dp[N-1][i]);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct edge {\n    ll u,v,c;\n    edge(ll u = 0, ll v = 0, ll c = 0) :u(u), v(v), c(c) {}\n};\nll solve(){\n    ll res = 0;\n    ll N,M,X; cin >> N >> M >> X;\n    vector<ll> T(N); for(auto& in:T) cin >> in;\n    vector<vector<edge>> G(N);\n    for(int i = 0; i < M;i++){\n        ll A,B,D; cin >> A >> B >> D;\n        A--; B--;\n        G[A].push_back(edge(A,B,D));\n        G[B].push_back(edge(B,A,D));\n    }\n    vector<vector<vector<ll>>> dist(N,vector<vector<ll>>(3,vector<ll>(X+1,LINF)));\n    dist[0][0][0] = 0;\n    using Items = tuple<ll,ll,ll>;\n    queue<Items> q;\n    q.push(Items(0,0,0));\n    while(q.size()){\n        ll n, f, x; tie(n, f, x) = q.front(); q.pop();\n        for (auto e : G[n]) {\n            if (x + e.c < X) {\n                if (f == 0 && T[e.v] == 2) continue;\n                if (f == 2 && T[e.v] == 0) continue;\n                \n                if (T[e.v] == 1) {\n                    if (dist[e.v][f][x + e.c] > dist[e.u][f][x] + e.c) {\n                        dist[e.v][f][x + e.c] = dist[e.u][f][x] + e.c;\n                        q.push(Items(e.v, f, x + e.c));\n                    }\n                }\n                if (T[e.v] == f) {\n                    if (dist[e.v][f][0] > dist[e.u][f][x] + e.c) {\n                        dist[e.v][f][0] = dist[e.u][f][x] + e.c;\n                        q.push(Items(e.v, f, 0));\n                    }\n                }\n                \n            }\n            else {\n                if (T[e.v] == 1) {\n                    if (dist[e.v][T[e.v]][X] > dist[e.u][f][x] + e.c) {\n                        dist[e.v][T[e.v]][X] = dist[e.u][f][x] + e.c;\n                        q.push(Items(e.v, T[e.v], X));\n                    }\n                }\n                else {\n                    if (dist[e.v][T[e.v]][0] > dist[e.u][f][x] + e.c) {\n                        dist[e.v][T[e.v]][0] = dist[e.u][f][x] + e.c;\n                        q.push(Items(e.v, T[e.v], 0));\n                    }\n                }\n            }\n        }\n   }\n    \n    res = LINF;\n    for(int i = 0; i <= X;i++){\n        res = min({res,dist[N-1][0][i],dist[N-1][1][i],dist[N-1][2][i]});\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<list>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<functional>\n#include<queue>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10000][3][201];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost, 0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<int ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint n, m, x, t[10005], dmin[10005][405];\nvector<vector<P> > g;\n\nvoid dijkstra(){\n    REP(i,n) fill(dmin[i], dmin[i]+(x+1)*2, IINF);\n    dmin[0][0] = 0;\n    priority_queue<P3, vector<P3>, greater<P3> > que;\n    que.push({0,{0,0}});\n    while(!que.empty()){\n        P3 p = que.top();\n        que.pop();\n        int v = p.second.first, tv = p.second.second;\n        if(p.first > dmin[v][tv])continue;\n        for(auto &e : g[v]){\n            int u = e.first, d = e.second, tu;\n            if(tv<x && t[u]==2 && abs(x-tv)>d)continue;\n            if(tv>x && t[u]==0 && abs(x-tv)>d)continue;\n            if(t[u]==2) tu = x*2;\n            else if(t[u]==0) tu = 0;\n            else {\n                if(tv<x) tu = min(x, tv+d);\n                else tu = max(x,tv-d);\n            }\n            if(dmin[u][tu] > dmin[v][tv] + d){\n                dmin[u][tu] = dmin[v][tv] + d;\n                que.push({dmin[u][tu],{u,tu}});\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m >> x;\n    g.resize(n);\n    REP(i,n) cin >> t[i];\n    REP(i,m){\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--; b--;\n        g[a].push_back({b,d});\n        g[b].push_back({a,d});\n    }\n    dijkstra();\n    int ans = IINF;\n    REP(i,x*2+1) ans = min(ans, dmin[n-1][i]);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconstexpr long double EPS = 1e-15;\nconst long double PI = acos(-1);\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n//#define all(v) (v).begin(), (v).end()\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nint n,m;\nll x;\nvector<pair<int,ll>> G[10010];\nint t[10010];\nll d[10010][610];\n\nint f(int tem) {\n    if (tem < 0) return -tem;\n    if (tem == 0) return 300;\n    return tem + 300;\n}\n\nint go(int tem, ll cost) {\n    if (abs(tem) <= cost) return 0;\n    if (tem < 0) return tem + cost;\n    return tem - cost;\n}\n\nbool ok(int tem, int type) {\n    if (type == 1) return 1;\n    if (type == 0) return tem <= 0;\n    return tem >= 0;\n}\n\nvoid solve() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> m >> x;\n    REP(i,n) {\n        cin >> t[i];\n    }\n    REP(i,m) {\n        int from, to;\n        ll cost;\n        cin >> from >> to >> cost;\n        from--;\n        to--;\n        G[from].pb({to,cost});\n        G[to].pb({from,cost});\n    }\n\n    REP(i,10010) {\n        REP(j,610) {\n            d[i][j] = INF;\n        }\n    }\n\n    // コスト，温度，ノード\n    priority_queue<pair<pair<ll,int>,int>,\n                    vector<pair<pair<ll,int>,int>>,\n                    greater<pair<pair<ll,int>,int>>> pq;\n    pq.push({{0,-x},0});\n    d[0][f(-x)] = 0;\n    while (!pq.empty()) {\n        pair<pair<ll,int>,int> tp = pq.top();\n        pq.pop();\n        ll c = tp.fi.fi;\n        int tem = tp.fi.se;\n        int v = tp.se;\n        if (d[v][f(tem)] < c) continue;\n        for  (int i = 0; i < G[v].size(); i++) {\n            int to = G[v][i].fi;\n            ll cost = G[v][i].se;\n            int type = t[to];\n            int tt = go(tem, cost);\n            if (!ok(tt, type)) continue;\n            if (type == 0) tt = -x;\n            else if (type == 2) tt = x;\n            if (d[to][f(tt)] > c + cost) {\n                d[to][f(tt)] = c + cost;\n                pq.push({{d[to][f(tt)], tt}, to});\n            }\n        }\n    }\n    ll ans = INF;\n    for (int i = 0; i <= x; i++) {\n        ans = min(ans, d[n-1][f(i)]);\n        ans = min(ans, d[n-1][f(-i)]);\n    }\n    cout << ans << endl;\n}\n\n\nint main(int argc, char *argv[]){\n\n    // /* Regular */\n    // int case_num = 1;\n    // if (argc > 1 && stoi(argv[1])) cin >> case_num;\n    // REP(case_no, case_num) {\n    //   cerr << endl << \"case \" << case_no + 1 << endl;\n    //   solve();\n    // }\n\n    /* AOJ */\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define pb push_back\ntypedef pair<int, int> Pi;\ntypedef pair<int, Pi > Ti;\n#define fi first\n#define se second\nconst int LLINF = 1LL << 60;\n\nstruct Edge {\n  int to, cost;\n};\n\nint N, M, X;\nint V[10005], mc[10005][2][205];\nvector < Edge > G[10005];\n\nint Dijkstra()\n{\n  priority_queue< Ti , vector < Ti >, greater < Ti > > pq;\n  fill_n(**mc, 10005 * 2 * 205, LLINF); mc[0][0][X] = 0;\n  pq.push(Ti(0, Pi(0, X)));\n\n  while(!pq.empty()) {\n    int v = pq.top().se.fi, w = pq.top().fi, p = pq.top().se.se; pq.pop();\n    int h = p / 1000, x = p % 1000;\n    if(w > mc[v][h][x]) continue;\n    Rep(i, G[v].size()) {\n      int u = G[v][i].to, nw = w + G[v][i].cost, nx = max(0LL, x - G[v][i].cost), nh;\n      if(h && !V[u] && nx > 0 || !h && V[u] == 2 && nx > 0) continue;\n      if(!V[u]) nx = X, nh = 0;\n      else if(V[u] == 2) nx = X, nh = 1;\n      else nh = h;\n      if(nw < mc[u][nh][nx]) {\n\tmc[u][nh][nx] = nw; pq.push(Ti(nw, Pi(u, nh * 1000 + nx)));\n      }\n    }\n  }\n  int ret = LLINF;\n  Rep(i, 2) Rep(j, 205) {\n    ret = min(ret, mc[N - 1][i][j]);\n  }\n  return ret;\n}\n  \nsigned main()\n{\n  int A, B, C;\n  cin >> N >> M >> X;\n  \n  Rep(i, N) cin >> V[i];\n\n  while(M--) {\n    cin >> A >> B >> C; --A, --B;\n    G[A].pb((Edge) { B, C });\n    G[B].pb((Edge) { A, C });\n  }\n\n  cout << Dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{\n  int p,d,c,h;\n  st(){}\n  st(int p,int d,int c,int h):p(p),d(d),c(c),h(h){}\n  bool operator<(const st& a) const{\n    return d>a.d;\n  }\n};\nstruct edge{\n  int to,cost;\n  edge(){}\n  edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> G[11111];\nint dp[10001][201][201];\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  int s[n];\n  for(int i=0;i<n;i++) cin>>s[i];\n  for(int i=0;i<m;i++){\n    int a,b,d;\n    cin>>a>>b>>d;\n    a--;b--;\n    G[a].push_back(edge(b,d));\n    G[b].push_back(edge(a,d));\n  }\n  memset(dp,-1,sizeof(dp));\n  priority_queue<st> q;\n  q.push(st(0,0,x,0));\n  int ans=0;\n  while(!q.empty()){\n    st t=q.top();q.pop();\n    if(~dp[t.p][t.c][t.h]&&dp[t.p][t.c][t.h]<t.d) continue;\n    dp[t.p][t.c][t.h]=t.d;\n    if(t.p==n-1){\n      ans=t.d;\n      break;\n    }\n    for(int i=0;i<(int)G[t.p].size();i++){\n      int v=G[t.p][i].to,u=G[t.p][i].cost;\n      int c=max(0,t.c-u),h=max(0,t.h-u);\n      if(~dp[v][c][h]&&dp[v][c][h]<=t.d+u) continue;\n      if(s[v]==0){\n\tif(h>0) continue;\n\tq.push(st(v,t.d+u,x,h));\n      }\n      if(s[v]==1){\n\tq.push(st(v,t.d+u,c,h));\n      }\n      if(s[v]==2){\n      \tif(c>0) continue;\n\tq.push(st(v,t.d+u,c,x));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{\n  int p,d,c,h;\n  st(){}\n  st(int p,int d,int c,int h):p(p),d(d),c(c),h(h){}\n  bool operator<(const st& a) const{\n    return d>a.d;\n  }\n};\nstruct edge{\n  int to,cost;\n  edge(){}\n  edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> G[10001];\nshort dp[10001][201][201];\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  int s[n];\n  for(int i=0;i<n;i++) cin>>s[i];\n  for(int i=0;i<m;i++){\n    int a,b,d;\n    cin>>a>>b>>d;\n    a--;b--;\n    G[a].push_back(edge(b,d));\n    G[b].push_back(edge(a,d));\n  }\n  memset(dp,-1,sizeof(dp));\n  priority_queue<st> q;\n  q.push(st(0,0,x,0));\n  int ans=0;\n  while(!q.empty()){\n    st t=q.top();q.pop();\n    if(~dp[t.p][t.c][t.h]&&dp[t.p][t.c][t.h]<=t.d) continue;\n    dp[t.p][t.c][t.h]=t.d;\n    if(t.p==n-1){\n      ans=t.d;\n      break;\n    }\n    for(int i=0;i<(int)G[t.p].size();i++){\n      int v=G[t.p][i].to,u=G[t.p][i].cost;\n      int c=max(0,t.c-u),h=max(0,t.h-u);\n      if(~dp[v][c][h]&&dp[v][c][h]<=t.d+u) continue;\n      if(s[v]==0){\n\tif(h>0) continue;\n\tq.push(st(v,t.d+u,x,h));\n      }\n      if(s[v]==1){\n\tq.push(st(v,t.d+u,c,h));\n      }\n      if(s[v]==2){\n      \tif(c>0) continue;\n\tq.push(st(v,t.d+u,c,x));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 59;\n \nstruct edge\n{\n  int to, cost;\n};\nstruct node\n{\n  int now, time, type;\n};\n \nint N, M, X, T[10000];\nvector< edge > g[10000];\nint64 min_cost[10000][202][3];\n \nint bfs()\n{\n  queue< node > qs[202];\n  fill_n(**min_cost, 10000 * 202 * 3, INF);\n  qs[0].emplace((node){0, 0, 1});\n  min_cost[0][0][1] = 0;\n   \n  for(int t = 0; true; t++) {\n    auto& que = qs[t % 202];\n    while(!que.empty()) {\n      const node p = que.front();\n      que.pop();\n      if(t != min_cost[p.now][p.time][p.type]) continue;\n      if(p.now == N - 1) return(t);\n      for(auto e : g[p.now]) {\n        node q = (node){e.to, p.time, p.type};\n        if(q.type + T[e.to] == 3) {\n          if(q.time + e.cost < X) continue;\n          q.time = 0;\n          q.type = T[e.to];\n        } else if(q.type == T[e.to]) {\n          q.time = 0;\n        } else {\n          q.time = min(X, q.time + e.cost);\n        }\n        if(t + e.cost >= min_cost[q.now][q.time][q.type]) continue;\n        min_cost[q.now][q.time][q.type] = t + e.cost;\n        qs[(t + e.cost) % 202].push(q);\n      }\n    }\n  }\n}\n \nint main()\n{   \n  cin >> N >> M >> X;\n  for(int i = 0; i < N; i++) {\n    cin >> T[i];\n    if(T[i] == 0) T[i] = 1;\n    else if(T[i] == 1) T[i] = 0;\n  }\n  for(int i = 0; i < M; i++) {\n    int A, B, D;\n    cin >> A >> B >> D;\n    --A, --B;\n    g[A].emplace_back((edge){B, D});\n    g[B].emplace_back((edge){A, D});\n  }\n  cout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#include <utility>\n#include <tuple>\nusing namespace std;\nusing CostTp = long long int;\n\nconst CostTp INF = 1LL << 60;\nCostTp rec[10010][210][3];\nstruct Elem {\n  CostTp pos, x, mode, cost;\n  Elem() {}\n  Elem(CostTp a, CostTp b, CostTp c, CostTp d) : pos(a), x(b), mode(c), cost(d) {}\n  bool operator<(const Elem &e) const {\n    return cost > e.cost;\n  }\n};\n\nint p[10010];\nvector< pair<int, int> > G[10010];\n\nbool is_danger(int ma, int mb) {\n  if(ma == 0 and mb == 2) return true;\n  if(ma == 2 and mb == 0) return true;\n  return false;\n}\n\nint main() {\n  int N, M, X; cin >> N >> M >> X;\n  for(int i=0; i<N; i++) cin >> p[i];\n  for(int i=0; i<M; i++) {\n    int u, v, cost; cin >> u >> v >> cost;\n    u--; v--;\n    G[u].emplace_back(v, cost);\n    G[v].emplace_back(u, cost);\n  }\n\n  priority_queue<Elem> que;\n  fill(rec[0][0], rec[N+1][0], INF);\n  rec[0][0][ p[0] ] = 0;\n  que.emplace(0, 0, p[0], 0);\n\n  while(que.size()) {\n    Elem cur = que.top(); que.pop();\n    if(rec[cur.pos][cur.x][cur.mode] < cur.cost) continue;\n    // fprintf(stderr, \"cur: %lld, %lld, %lld, %lld\\n\", cur.pos, cur.x, cur.mode, cur.cost);\n    for(auto e : G[cur.pos]) {\n      int to, cost; tie(to, cost) = e;\n      if(is_danger(cur.mode, p[to])) {\n        // danger\n        if(cur.x + cost >= X and rec[to][0][ p[to] ] > cur.cost + cost) {\n          rec[to][0][ p[to] ] = cur.cost + cost;\n          que.emplace(to, 0, p[to], cur.cost + cost);\n        }\n      }\n      else {\n        // refresh\n        {\n          int nx = (p[to] != 1 ? 0 : cur.x + cost);\n          int np = (p[to] != 1 ? p[to] : cur.mode);\n\n          if(p[to] == 1 and nx >= X) {\n            nx = 0;\n            np = 1;\n          }\n          {\n            if(rec[to][ nx ][ np ] > cur.cost + cost) {\n              rec[to][ nx ][ np ] = cur.cost + cost;\n              que.emplace(to, nx, np, cur.cost + cost);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  CostTp ans = INF;\n  for(int i=0; i<=X; i++) {\n    for(int k=0; k<3; k++) {\n      ans = min(ans, rec[N-1][i][k]);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e15;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(LL t, LL c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\n\nvoid add_edge(Graph& graph, int u, int v, LL cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nint N, M, X;\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> M >> X;\n  VI ty(N);\n  REP(i,N) cin >> ty[i];\n  Graph G(N);\n  REP(i,M){\n\tint u, v, d;\n\tcin >> u >> v >> d;\n\tadd_edge(G, u-1, v-1, d);\n  }\n\n  // 0 - X : cold, X - 2X: hot\n  VVL dp(N, VL(2*X+1, INF));\n  using Type = pair<LL,PII>;\n  priority_queue<Type, vector<Type>, greater<Type> > pq;\n  dp[0][0] = 0;\n  pq.push(MP(0,MP(0,0)));\n\n  while(!pq.empty()){\n\tType pii = pq.top(); pq.pop();\n\tLL d = pii.FF;\n\tPII s = pii.second;\n\tif(dp[s.FF][s.SS] < d) continue;\n\tfor(auto&& e: G[s.FF]){\n\t  int nxt_tmp = (s.SS <= X? min(X, s.SS+e.cost): max(X, s.SS-e.cost));\n\t  LL nxt_d = dp[s.FF][s.SS] + e.cost;\n\t  if(ty[e.to] == 0){\n\t\tif(nxt_tmp <= X){\n\t\t  if(dp[e.to][0] > nxt_d){\n\t\t\tdp[e.to][0] = nxt_d;\n\t\t\tpq.push(MP(nxt_d, MP(e.to, 0)));\n\t\t  }\n\t\t}\n\t  }\n\t  else if(ty[e.to] == 1){\n\t\tif(dp[e.to][nxt_tmp] > nxt_d){\n\t\t  dp[e.to][nxt_tmp] = nxt_d;\n\t\t  pq.push(MP(nxt_d, MP(e.to, nxt_tmp)));\n\t\t}\n\t  }\n\t  else{\n\t\tif(nxt_tmp >= X){\n\t\t  if(dp[e.to][2*X] > nxt_d){\n\t\t\tdp[e.to][2*X] = nxt_d;\n\t\t\tpq.push(MP(nxt_d, MP(e.to, 2*X)));\n\t\t  }\n\t\t}\n\t  }\n\t}\n  }\n\n  LL ans = INF;\n  REP(i,2*X+1) mini(ans, dp[N-1][i]);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n)cin>>t[i];\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        if (d[v][type][tim] < dist) continue;\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 1) {\n                u = e.to, ntype = type, ntim = min(x, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = type, ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <cstdint>\n\n#define in std::cin\n#define out std::cout\n\n#include <queue>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <iterator>\n\nusing COST_T = int32_t;\nconstexpr uint32_t N_MAX = 10000;\nconstexpr COST_T INF = 10000 * 400 + 1000;//std::numeric_limits<double>::infinity()\n\n#if defined(_MSC_VER) && defined(_DEBUG)\n\t\t\t\t\t\t\t\t\t\t  //static_assert(false, \"??????????????§??????????????????????????¨???????????????\");\n#endif\n\nstruct edge {\n\tuint32_t to;\n\tCOST_T cost;\n\tedge() {}\n\tedge(uint32_t to_, COST_T cost_)\n\t\t:to(to_), cost(cost_) {}\n};\nstd::vector<edge> graph[N_MAX];\n\nint32_t N, M, X;\nint32_t T[N_MAX];\n\n//??????????????????\nCOST_T D[N_MAX][201][2];\nvoid Dijkstra(uint32_t s)\n{\n\tusing P = std::pair<COST_T, uint64_t>;//cost pos\n\tstd::priority_queue<P, std::vector<P>, std::greater<>> que;\n\tfor(auto&arr2:D)for (auto&arr1 : arr2)for (auto&i : arr1)i=INF;\n\n\tD[s][X][0] = 0;\n\tque.emplace(0, ((uint64_t)(s)<<16)|(X<<8));\n\twhile (!que.empty())\n\t{\n\t\tauto p = que.top(); que.pop();\n\t\tconst auto nowpos = p.second >> 16;\n\t\tint32_t ntime = (p.second >> 8) & 0b1111'1111;\n\t\tint32_t ishot = p.second & 0b1111'1111;\n\t\tconst auto& nowcost = p.first;\n\n\t\tif (D[nowpos][ntime][ishot] < nowcost) { continue; }\n\t\t//printf(\"%d,%d,%d,%d\\n\", nowpos, ntime, ishot, D[nowpos][ntime][ishot]);\n\t\t//for (int32_t to = 0; to < N; ++to)\n\t\t//{\n\t\t//\tauto cost = nowcost + graph[nowpos][to];\n\t\t//\tif (cost < D[to]) {\n\t\t//\t\tD[to] = cost;\n\t\t//\t\tque.emplace(D[to], to);\n\t\t//\t}\n\t\t//}\n\n\t\tfor (const auto& e : graph[nowpos])\n\t\t{\n\t\t\tauto cost = nowcost + e.cost;\n\t\t\tauto time = std::max<int32_t>(0, ntime - e.cost);\n\t\t\tif (time <= 0 || !((T[e.to] == 2 && !ishot) || (T[e.to] == 0 && ishot))) {\n\t\t\t\tauto nextishot = ishot;\n\t\t\t\tif (T[e.to] == 2) {\n\t\t\t\t\ttime = X;\n\t\t\t\t\tnextishot = 1;\n\t\t\t\t}\n\t\t\t\telse if (T[e.to] == 0) {\n\t\t\t\t\ttime = X;\n\t\t\t\t\tnextishot = 0;\n\t\t\t\t}\n\t\t\t\telse if (ntime <= 0) {\n\t\t\t\t\tnextishot = 0;\n\t\t\t\t}\n\t\t\t\tif (cost < D[e.to][time][nextishot]) {\n\t\t\t\t\tD[e.to][time][nextishot] = cost;\n\t\t\t\t\tque.emplace(cost, ((int64_t)(e.to) << 16) | (time << 8) | nextishot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n#if 0\nuint32_t DP[10000][201][2];\n//??´???????????§?????¨??????????????????\nuint32_t func(int pos, int wait, int type/*0??????,1??±???*/)\n{\n\tif (pos == N - 1) { return 0; }\n\tif (T[pos] != 1) {\n\t\t//?\\?????????¨?±?\n\t\twait = X;\n\t\tif (T[pos] == 0) {\n\t\t\ttype = 0;\n\t\t}\n\t\telse {\n\t\t\ttype = 1;\n\t\t}\n\t}\n\telse if (wait == 0) {\n\t\ttype = 0;\n\t}\n\n\tif (DP[pos][wait][type] != 0) { return DP[pos][wait][type]; }\n\tDP[pos][wait][type] = INF;\n\tuint32_t mincost = INF;\n\tfor (const auto& e : graph[pos])\n\t{\n\t\tif (e.cost < wait) {\n\t\t\t//??°?¢????????????§??????\n\t\t\tif (T[e.to] == 0 && type == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (T[e.to] == 2 && type == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tmincost = std::min(mincost, func(e.to, std::max(0, wait - e.cost), type) + e.cost);\n\t}\n\treturn DP[pos][wait][type] = mincost;\n}\n#endif\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N >> M >> X;\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tin >> T[i];\n\t}\n\tfor (size_t i = 0; i < M; ++i) {\n\t\tint a, b, j;\n\t\tin >> a >> b >> j; --a; --b;\n\t\tgraph[a].emplace_back(b, j);\n\t\tgraph[b].emplace_back(a, j);\n\t}\n\tDijkstra(0);\n\tint32_t res = INF;\n\tfor (size_t i = 0; i <= X; ++i)\n\t{\n\t\tres = std::min(res, D[N - 1][i][0]);\n\t\tres = std::min(res, D[N - 1][i][1]);\n\t}\n\tout << res << endl;\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 112000000012345678LL\n\nusing P = pair<long,int>;\n// cost, idx\n\nint t[10005];\n\nlong d[200*2*10005];\nvector<P> vec[200*2*10005];\n\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  rep(i,n) cin>>t[i];\n\n  rep(_,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    rep(__,2){\n      int ai = a*2*x, bi = b*2*x;\n      if(t[b]==1){\n        if(t[a]!=1){\n          // [0,2] -> 1\n          if(t[a]==2) bi += x;\n          vec[ai].pb(mp(c, bi + max(0, x-c)));\n        }\n        else {\n          // 1 -> 1\n          vec[ai].pb(mp(bi, c));\n          repl(i,1,x){\n            vec[ai+i].pb(mp(c, bi + max(0, i-c)));\n            vec[ai+x+i].pb(mp(c, bi + ((i-c>0)?(x+i-c):0) ));\n          }\n        }\n      }\n      else if(t[a] == t[b]){\n        // 0 -> 0, 2 -> 2\n        vec[ai].pb(mp(c, bi));\n      }\n      else if(t[a]==1){\n        // 1 -> 2, 1 -> 0\n        vec[ai].pb(mp(c, bi));\n\n        if(t[b]==2) ai += x;\n        repl(i,1,x) vec[ai + i].pb(mp(c, bi));\n\n        ai = a*2*x;\n        if(t[b]==0) ai += x;\n        repl(i,1,min(c+1,x)) vec[ai + i].pb(mp(c, bi));\n      }\n      else {\n        // 0->2, 2->0\n        if(t[a]==2) ai += x;\n        else bi += x;\n        if(x <= c) vec[ai].pb(mp(c, bi));\n      }\n\n      swap(a,b);\n    } // make edges\n  }\n\n  priority_queue<P, vector<P>, greater<P>> pq;\n  fill(d, d + 2*x*n, INF);\n  d[0] = 0;\n  pq.push(mp(0,0));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    if(d[p.se] < p.fi) continue;\n    for(auto to : vec[p.se]){\n      long nd = p.fi + to.fi;\n      int ni = to.se;\n      if(d[ni] > nd){\n        pq.push(mp(nd,ni));\n        d[ni] = nd;\n      }\n    }\n  }\n\n  long ans = INF;\n  rep(i,2*x) ans = min(ans, d[(n-1)*2*x + i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1e9)\n\ntypedef pair<int, int> P;\n\nstruct Q {\n    int time;\n    int togo;\n    int status;\n    int room;\n    Q() {}\n    Q(int a,int b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    int X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        to[a-1].push_back(P(d,b-1));\n        to[b-1].push_back(P(d,a-1));\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    int time[N][2][X+1];\n\n    for(int i=0; i<N; ++i) {\n        for(int j=0; j<2; ++j) {\n            for(int k=0; k<X+1; ++k) {\n                time[i][j][k]=INF;\n            }\n        }\n    }\n\n    q.push(Q(0,X,0,0)); // time, togo, status(0=cold,1=normal,2=hot), room\n    time[0][0][X]=0;\n    // int cnt=0; // for debug\n    while(!q.empty()) {\n        Q now=q.top(); q.pop();\n        if(time[now.room][now.status/2][now.togo]<now.time) continue;\n        for(auto nxt : to[now.room]) {\n            int nxt_togo=max(0,now.togo-nxt.first);\n            if(T[nxt.second]==1) {\n                if(time[nxt.second][now.status/2][nxt_togo]<=now.time+nxt.first) continue;\n                time[nxt.second][now.status/2][nxt_togo]=now.time+nxt.first;\n                q.push(Q(now.time+nxt.first,nxt_togo,now.status,nxt.second));\n            } else if(T[nxt.second]==now.status || nxt_togo==0) {\n                if(time[nxt.second][T[nxt.second]/2][X]<=now.time+nxt.first) continue;\n                time[nxt.second][T[nxt.second]/2][X]=now.time+nxt.first;\n                q.push(Q(now.time+nxt.first,X,T[nxt.second],nxt.second));\n            }\n        }\n    }\n\n    int ans=INF;\n\n    for(int i=0; i<2; ++i) {\n        for(int j=0; j<X+1; ++j) {\n            ans=min(ans,time[N-1][i][j]);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<functional>\n#include<queue>\nusing namespace std;\nclass road{\npublic:\n    int to,distance;\n    road(int a,int b):to(a),distance(b){\n        \n    }\n};\nclass player{\npublic:\n    int time;\n    int k;\n    int place;\n    player(int a,int b,int c):time(a),k(b),place(c){\n        \n    }\n};\nclass room{\npublic:\n    bool used;\n    int k;\n    vector<road> rouka;\n    room():used(false){\n        \n    }\n};\nbool operator<(const player &a,const player &b){\n    return a.time<b.time;\n}\nbool operator>(const player &a,const player &b){\n    return a.time>b.time;\n}\nint main(){\n    int N,M,X;\n    cin>>N>>M>>X;\n    room *map;\n    map= new room[N+1];\n    for(int i=1;i<N+1;++i) {\n        cin>>map[i].k;\n        --map[i].k;\n    }\n    int a,b,c;\n    for(int i=0;i<M;++i){\n        cin>>a>>b>>c;\n        map[a].rouka.push_back(road(b,c));\n        map[b].rouka.push_back(road(a,c));\n    }\n    priority_queue<player,vector<player>,greater<player> >que;\n    que.push(player(0,0,1));\n    while(true){\n        if(que.empty()){\n            cout<<0<<endl;\n        }\n        player dummy=que.top();que.pop();\n        if(dummy.place==N){\n            cout<<dummy.time<<endl;\n            break;\n        }\n        if(map[dummy.place].used){\n            continue;\n        }\n        if(dummy.k==0){\n            map[dummy.place].used=true;\n        }\n        if(map[dummy.place].k!=0){\n            map[dummy.place].used=true;\n            dummy.k=map[dummy.place].k*X;\n        }\n        for(vector<road>::iterator p=map[dummy.place].rouka.begin(),fi=map[dummy.place].rouka.end();p!=fi;++p){\n            if(map[p->to].used)continue;\n            int nk=(dummy.k>0)?max(dummy.k-p->distance,0):min(dummy.k+p->distance,0);\n            if(map[p->to].k*nk>=0){\n                que.push(player(dummy.time+p->distance,nk,p->to));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{\n  int p,d,c,h;\n  st(){}\n  st(int p,int d,int c,int h):p(p),d(d),c(c),h(h){}\n  bool operator<(const st& a) const{\n    return d>a.d;\n  }\n};\nstruct edge{\n  int to,cost;\n  edge(){}\n  edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> G[10001];\nint dp[10001][201][201];\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  int s[n];\n  for(int i=0;i<n;i++) cin>>s[i];\n  for(int i=0;i<m;i++){\n    int a,b,d;\n    cin>>a>>b>>d;\n    a--;b--;\n    G[a].push_back(edge(b,d));\n    G[b].push_back(edge(a,d));\n  }\n  memset(dp,-1,sizeof(dp));\n  priority_queue<st> q;\n  q.push(st(0,0,x,0));\n  int ans=0;\n  while(!q.empty()){\n    st t=q.top();q.pop();\n    if(~dp[t.p][t.c][t.h]&&dp[t.p][t.c][t.h]<=t.d) continue;\n    dp[t.p][t.c][t.h]=t.d;\n    if(t.p==n-1){\n      ans=t.d;\n      break;\n    }\n    for(int i=0;i<(int)G[t.p].size();i++){\n      int v=G[t.p][i].to,u=G[t.p][i].cost;\n      int c=max(0,t.c-u),h=max(0,t.h-u);\n      if(~dp[v][c][h]&&dp[v][c][h]<=t.d+u) continue;\n      if(s[v]==0){\n\tif(h>0) continue;\n\tq.push(st(v,t.d+u,x,h));\n      }\n      if(s[v]==1){\n\tq.push(st(v,t.d+u,c,h));\n      }\n      if(s[v]==2){\n      \tif(c>0) continue;\n\tq.push(st(v,t.d+u,c,x));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int INF = 1e9;\n\nstruct State\n{\n\tint d, v, t, n;\n\tState(int d, int v, int t, int n) :d(d), v(v), t(t), n(n) {}\n\tbool operator < (const State& s) const {\n\t\treturn d > s.d;\n\t}\n};\n\n\nstruct edge\n{\n\tint to, co;\n\tedge(int to, int co) :to(to), co(co) {}\n};\n\nint N, M, X;\nint T[10000];\nvector<edge> g[10000];\nint dist[10000][205][3];\nint main() {\n\tcin >> N >> M >> X;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> T[i];\n\t}\n\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, d;\n\t\tcin >> a >> b >> d; a--; b--;\n\t\tg[a].emplace_back(b, d);\n\t\tg[b].emplace_back(a, d);\n\t}\n\n\t\n\tpriority_queue<State> pq;\n\tpq.emplace(0, 0, 0, 0);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= X; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tdist[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tdist[0][0][0] = 0;\n\tint ans;\n\twhile (!pq.empty())\n\t{\n\t\tState st = pq.top(); pq.pop();\n\t\tint v = st.v, t = st.t, n = st.n;\n\n\t\tif (st.d > dist[v][t][n]) continue;\n\n\t\tif (v == N - 1) {\n\t\t\tans = dist[v][t][n]; \n\t\t\tbreak;\n\t\t}\n\n\t\tfor (auto e : g[v]) {\n\t\t\tint nt = min(t + e.co, X);\n\t\t\tint nco = dist[v][t][n] + e.co;\n\t\t\tif (T[e.to] == n) {\n\t\t\t\tif (dist[e.to][0][n] > nco) {\n\t\t\t\t\tdist[e.to][0][n] = nco;\n\t\t\t\t\tpq.emplace(dist[e.to][0][n], e.to, 0, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(T[e.to] == 1){\n\t\t\t\tif (dist[e.to][nt][n] > nco) {\n\t\t\t\t\tdist[e.to][nt][n] = nco;\n\t\t\t\t\tpq.emplace(dist[e.to][nt][n], e.to, nt, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (nt != X) continue;\n\t\t\t\tif (dist[e.to][0][T[e.to]] > nco) {\n\t\t\t\t\tdist[e.to][0][T[e.to]] = nco;\n\t\t\t\t\tpq.emplace(dist[e.to][0][T[e.to]], e.to, 0, T[e.to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\t\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef pair<LL, LL> P;\ntypedef pair<P, P> PP;\nconst int MAX_V = 20010;\nstruct edge { LL to, cost; };\nvector<edge> G[MAX_V];\nLL d[MAX_V][5][210];//time place t remain\nint n, m, x;\nint room[MAX_V];\nbool visited[MAX_V][5][210];\nvoid dijkstra() {\n\tpriority_queue<PP, vector<PP>, greater<PP>> pq;\n\tfor (int i = 0; i < MAX_V; i++) {\n\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\tfor (int k = 0; k < 210; k++) {\n\t\t\t\td[i][j][k] = LINF;\n\t\t\t\tvisited[i][j][k] = false;\n\t\t\t}\n\t\t}\n\t}\n\td[0][0][x] = 0;\n\tpq.push(mp(mp(d[0][0][x], 0), mp(0, x)));\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tint time = p.first.first;\n\t\tint place = p.first.second;\n\t\tint t = p.second.first;\n\t\tint remain = p.second.second;\n\t\tif (!visited[place][t][remain]) {\n\t\t\tvisited[place][t][remain] = true;\n\t\t\td[place][t][remain] = time;\n\n\t\t\tfor (int i = 0; i < G[place].size(); i++) {\n\t\t\t\tif (remain - G[place][i].cost <= 0) {\n\t\t\t\t\tpq.push(mp(mp(time + G[place][i].cost, G[place][i].to), mp(room[G[place][i].to], room[G[place][i].to] == 1 ? 0 : x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (room[G[place][i].to] == 1 || room[G[place][i].to] == t) {\n\t\t\t\t\t\tpq.push(mp(mp(time + G[place][i].cost, G[place][i].to), mp(t, room[G[place][i].to] == 1 ? remain - G[place][i].cost : x)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> n >> m >> x;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> room[i];\n\t}\n\tint a, b;\n\tLL c;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tG[a].emplace_back(edge{ b,c });\n\t\tG[b].emplace_back(edge{ a,c });\n\t}\n\tdijkstra();\n\n\tLL ans = LINF;\n\tfor (int j = 0; j <= 2; j++) {\n\t\tfor (int k = 0; k <= x; k++) {\n\t\t\tans = min(ans, d[n - 1][j][k]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld=long double;\nld eps=1e-9;\n\nstruct Edge {\n\tint from;\n\tint to;\n\tlong long int val;\n};\n\nstruct Status {\n\tint now;\n\tint hot;\n\tint rest;\n\tlong long int cost;\n};\nbool operator<(const Status&l, const Status&r) {\n\treturn l.cost>r.cost;\n}\n\nvoid add_edge(vector<vector<Edge>>&graph,int a, int b, int c) {\n\tgraph[a].push_back(Edge{ a,b,c });\n\tgraph[b].push_back(Edge{ b,a,c });\n}\n\nint main() {\n\tint X;\n\tint N,M;cin>>N>>M>>X;\n\tvector<int>hots(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin>>hots[i];\n\t}\n\tvector<vector<Edge>>graph(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b,c;cin>>a>>b>>c;a--;b--;\n\t\tadd_edge(graph,a,b,c);\n\t}\n\tvector<vector<vector<long long int>>>memo(N,\n\t\tvector<vector<long long int>>(2,vector<long long int>(X+1,1e18)));\n\n\tmemo[0][0][X]=0;\n\tpriority_queue<Status>que; \n\tque.push(Status{ 0,0,X,0 });\n\twhile (!que.empty()) {\n\t\tauto atop(que.top());\n\t\tque.pop();\n\t\tconst int now(atop.now);\n\t\tint now_hot=atop.hot;\n\t\tconst int now_rest=atop.rest;\n\t\tconst long long int now_cost=atop.cost;\n\n\t\tfor (auto e : graph[now]) {\n\t\t\tconst int next(e.to);\n\t\t\tint next_hot=hots[next];\n\t\t\tconst long long int next_cost = now_cost + e.val;\n\t\t\tif (next_hot==1) {\n\t\t\t\tconst int next_rest=max(0ll,now_rest-e.val);\n\n\t\t\t\tif (memo[next][now_hot][next_rest] > next_cost) {\n\t\t\t\t\tmemo[next][now_hot][next_rest]=next_cost;\n\t\t\t\t\tque.push(Status{ next,now_hot,next_rest,next_cost });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (next_hot == 0) {\n\t\t\t\tif (now_hot == 1&&(now_rest-e.val>0)) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (memo[next][0][X] > next_cost) {\n\t\t\t\t\t\tmemo[next][0][X]=next_cost;\n\t\t\t\t\t\tque.push(Status{ next,0,X,next_cost });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (now_hot == 0 && (now_rest - e.val > 0)) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (memo[next][1][X] > next_cost) {\n\t\t\t\t\t\tmemo[next][1][X]=next_cost;\n\t\t\t\t\t\tque.push(Status{ next,1,X,next_cost });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans=1e18;\n\tfor (int i = 0; i < 2; ++i) {\n\t\tfor (int j = 0; j <= X; ++j) {\n\t\t\tans=min(ans,memo[N-1][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n    Edge() {}\n    Edge(int to, int cost) : to{to}, cost{cost} {}\n};\n\nconstexpr int MAX = 10000;\nconstexpr int MAX_T = 200;\nconstexpr int INF = (1 << 29);\n\nvector<Edge> G[MAX];\n\nstruct State {\n    int w, v, t, n;\n    State() {}\n    State(int w, int v, int t, int n) : w{w}, v{v}, t{t}, n{n} {}\n\n    bool operator < (const State& s) const {\n        return w > s.w;\n    }\n};\n\nint d[MAX][MAX_T + 1][2];\n\nint solve(int N, int X, const vector<int>& T)\n{\n    priority_queue<State> pq;\n    pq.push(State(0, 0, 0, 0));\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= X; j++) {\n            for (int k = 0; k < 2; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n\n    d[0][0][0] = 0;\n\n    while (!pq.empty()) {\n        State st = pq.top(); pq.pop();\n        int v = st.v, t = st.t, n = st.n;\n\n        if (d[v][t][n] < st.w) continue;\n        \n        if (v == N - 1) {\n            return d[v][t][n];\n        }\n        \n        for (const auto& e : G[v]) {\n            int nt = min(X, t + e.cost);\n            int ncost = d[v][t][n] + e.cost;\n            if (T[e.to] == n) {\n                if (ncost < d[e.to][0][n]) {\n                    d[e.to][0][n] = ncost;\n                    pq.push(State(d[e.to][0][n], e.to, 0, n));\n                }\n            } else {\n                if (T[e.to] == 1) {\n                    if (ncost < d[e.to][nt][n]) {\n                        d[e.to][nt][n] = ncost;\n                        pq.push(State(d[e.to][nt][n], e.to, nt, n));\n                    }\n                } else {\n                    if (nt != X) continue;\n                    if (ncost < d[e.to][0][T[e.to]]) {\n                        d[e.to][0][T[e.to]] = ncost;\n                        pq.push(State(d[e.to][0][T[e.to]], e.to, 0, T[e.to]));\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N, M, X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for (int i = 0; i < N; i++) {\n        cin >> T[i];\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int A, B, D;\n        cin >> A >> B >> D;\n        A--; B--;\n        G[A].emplace_back(B, D);\n        G[B].emplace_back(A, D);\n    }\n    cout << solve(N, X, T) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{\n  int p,d,f,b;\n  st(){}\n  st(int p,int d,int f,int b):p(p),d(d),f(f),b(b){}\n  bool operator<(const st& a) const{\n    return d>a.d;\n  }\n};\nstruct edge{\n  int to,cost;\n  edge(){}\n  edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> G[10001];\nint dp[10001][2][201];\nint main(){\n  int n,m,x;\n  cin>>n>>m>>x;\n  int s[n];\n  for(int i=0;i<n;i++) cin>>s[i];\n  for(int i=0;i<m;i++){\n    int a,b,d;\n    cin>>a>>b>>d;\n    a--;b--;\n    G[a].push_back(edge(b,d));\n    G[b].push_back(edge(a,d));\n  }\n  memset(dp,-1,sizeof(dp));\n  priority_queue<st> q;\n  q.push(st(0,0,0,x));\n  dp[0][0][x]=0;\n  int ans=-1;\n  while(!q.empty()){\n    st p=q.top();q.pop();\n    if(dp[p.p][p.f][p.b]>0&&dp[p.p][p.f][p.b]<p.d) continue;\n    //cout<<p.p<<\" \"<<p.f<<\" \"<<p.b<<\" \"<<p.d<<endl;\n    if(p.p==n-1){\n      ans=p.d;\n      break;\n    }\n    for(int i=0;i<(int)G[p.p].size();i++){\n      int np=G[p.p][i].to,nc=G[p.p][i].cost;\n      int nb=max(0,p.b-nc),nf=p.f;\n      if(s[np]==0){\n\tif(nf==1&&nb) continue;\n\tnf=0;\n\tnb=x;\n      }\n      if(s[np]==2){\n\tif(nf==0&&nb) continue;\n\tnf=1;\n\tnb=x;\n      }\n      if(dp[np][nf][nb]<0||dp[np][nf][nb]>p.d+nc){\n\tdp[np][nf][nb]=p.d+nc;\n\tq.push(st(np,p.d+nc,nf,nb));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Snake JOI\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nenum TYPE {\n    COLD = 0,\n    CONFORTABLE = 1,\n    HOT = 2\n};\n\nstruct Corridor {\n    int target, cost;\n    Corridor(int target, int cost): target(target), cost(cost) {}\n};\n\nstruct Room {\npublic:\n    int id, type;\n    vector<Corridor> edge;\n    Room() {}\n    Room(int id, int type): id(id), type(type) {}\n};\n\nstruct State {\n    int id, time, prev_type, d;\n    State(int id, int time, int prev_type, int d): id(id), time(time), prev_type(prev_type), d(d) {}\n    bool operator < (const State &s) const {\n        return time > s.time;\n    };\n};\n\nint N, M, X;\nRoom rooms[MAX];\nint min_time[MAX][2][201];\n\nint dijkstra() {\n    priority_queue<State> PQ;\n    for(int i = 0; i < MAX; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 201; k++) min_time[i][j][k] = INT_MAX;\n        }\n    }\n    min_time[0][0][0] = 0;\n    PQ.push(State(0, 0, COLD, 0));\n    int ans = INT_MAX, next_time, next_d;\n    while(!PQ.empty()) {\n        if(PQ.top().id == N - 1) {\n            ans = min(ans, PQ.top().time);\n            PQ.pop();\n            continue;\n        }\n        if(PQ.top().time > ans) break;\n        for(auto c: rooms[PQ.top().id].edge) {\n            next_d = min(X, PQ.top().d + c.cost);\n            next_time = PQ.top().time + c.cost;\n            if(abs(PQ.top().prev_type - rooms[c.target].type) > 1 && next_d < X) continue;\n            if(rooms[c.target].type == CONFORTABLE) {\n                if(min_time[c.target][PQ.top().prev_type / 2][next_d] < next_time) continue;\n                min_time[c.target][PQ.top().prev_type / 2][next_d] = next_time;\n                PQ.push(State(c.target, next_time, PQ.top().prev_type, next_d));\n            } else {\n                if(min_time[c.target][rooms[c.target].type / 2][0] < next_time) continue;\n                min_time[c.target][rooms[c.target].type / 2][0] = next_time;\n                PQ.push(State(c.target, next_time, rooms[c.target].type, 0));\n            }\n        }\n        PQ.pop();\n    }\n    return ans;\n}\n\nint main() {\n    int t, a, b, d;\n    scanf(\"%d %d %d\", &N, &M, &X);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &t);\n        rooms[i] = Room(i, t);\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &a, &b, &d);\n        a--;\n        b--;\n        rooms[a].edge.emplace_back(Corridor(b, d));\n        rooms[b].edge.emplace_back(Corridor(a, d));\n    }\n\n    cout << dijkstra() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cassert>\n#include<cstring>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge { int dst,w; };\nstruct Data {\n  int cur, w, type, x;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w > data.w;\n    if( x != data.x ) return x > data.x;\n    if( type != data.type ) return type > data.type;\n    return cur > data.cur;\n  }\n};\nint V,E,X;\n\n#define MAX_V 10010\nvector<Edge> G[MAX_V];\nvector<int> state;\nint mini[MAX_V][3][210];\n\nvoid compute() {\n  rep(i,V) rep(j,3) rep(k,210) mini[i][j][k] = INT_MAX;\n  mini[0][0][X] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0,0,X});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      int dst = e.dst;\n      int nx  = max(data.x - e.w,0);\n      if( nx && state[dst] != 1 && state[dst] != data.type ) continue;\n      if( nx && state[dst] == data.type ) {\n\tnx = X;\n\tif( mini[dst][data.type][nx] > data.w + e.w ) {\n\t  mini[dst][data.type][nx] = data.w + e.w;\n\t  Q.push((Data){dst,data.w+e.w,data.type,nx});\n\t}\n      } else if( nx && state[dst] == 1 ) {\n\tif( mini[dst][data.type][nx] > data.w + e.w ) {\n\t  mini[dst][data.type][nx] = data.w + e.w;\n\t  Q.push((Data){dst,data.w+e.w,data.type,nx});\n\t}\n      } else if( state[dst] == 1 ) {\n\tassert( nx == 0 );\n\tif( mini[dst][1][nx] > data.w + e.w ) {\n\t  mini[dst][1][nx] = data.w + e.w;\n\t  Q.push((Data){dst,data.w+e.w,1,nx});\n\t}\n      } else {\n\tint type = state[dst];\n\tnx = X;\n\tif( mini[dst][type][nx] > data.w + e.w ) {\n\t  mini[dst][type][nx] = data.w + e.w;\n\t  Q.push((Data){dst,data.w+e.w,type,nx});\n\t}\n      }\n    }\n  }\n  int ans = INT_MAX;\n  rep(j,3) rep(k,210) ans = min(ans,mini[V-1][j][k]);\n  cout << ans << endl;\n}\n\nint main() {\n  cin >> V >> E >> X;\n  state.resize(V);\n  rep(i,V) cin >> state[i];\n  rep(i,E) {\n    int s,t,c;\n    cin >> s >> t >> c;\n    --s, --t;\n    G[s].push_back((Edge){t,c});\n    G[t].push_back((Edge){s,c});\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,x;\ninline int getid(int vert,int temp)\n{\n\treturn vert * 401 + temp;\n}\nstruct edge\n{\n\tint to,cost;\n\tedge(int t_,int c_):to(t_),cost(c_){}\n};\n//N CCC...CCC HHH...HHH\nvector<edge>graph[10000 * 401];\nint dist[10000 * 401];\nconst int INF = 1004567890;\nusing P = pair<int,int>;\nvoid dijkstra()\n{\n\tfill(dist,dist + n * 401,INF);\n\tdist[0] = 0;\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push({0,0});\n\twhile(!que.empty())\n\t{\n\t\tauto q = que.top();que.pop();\n\t\tint dis = q.first;\n\t\tint vid = q.second;\n\t\tif(dist[vid] < dis)continue;\n\t\tfor(auto ed : graph[vid])\n\t\t{\n\t\t\tif(dist[ed.to] > dist[vid] + ed.cost)\n\t\t\t{\n\t\t\t\tdist[ed.to] = dist[vid] + ed.cost;\n\t\t\t\tque.push(P(dist[ed.to],ed.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint t[10000];\nvoid putline(int fr,int to,int cs)\n{\n\tif(t[to] == 0 || t[to] == 2)\n\t{\n\t\tif(t[fr] == 1)\n\t\t{\n\t\t\t//1->0 or 1->2\n\t\t\tgraph[getid(fr,0)].push_back(edge(getid(to,0),cs));\n\t\t\tfor(int i = 1;i <= x;++i)\n\t\t\t{\n\t\t\t\tgraph[getid(fr,i + t[to] * 100)].push_back(edge(getid(to,0),cs));\n\t\t\t\tif(i - 1 + cs >= x)\n\t\t\t\t\tgraph[getid(fr,i + 200 - t[to] * 100)].push_back(edge(getid(to,0),cs));\n\t\t\t}\n\t\t}\n\t\telse if(t[fr] == t[to])\n\t\t{\n\t\t\t//0->0 or 2->2\n\t\t\tgraph[getid(fr,0)].push_back(edge(getid(to,0),cs));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//0->2 or 2->0\n\t\t\tif(cs >= x)\n\t\t\t\tgraph[getid(fr,0)].push_back(edge(getid(to,0),cs));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(t[fr] == 1)\n\t\t{\n\t\t\t//1->1\n\t\t\tgraph[getid(fr,0)].push_back(edge(getid(to,0),cs));\n\t\t\tfor(int i = 1;i <= x;++i)\n\t\t\t{\n\t\t\t\tif(i - 1 + cs >= x)\n\t\t\t\t{\n\t\t\t\t\tgraph[getid(fr,i)].push_back(edge(getid(to,0),cs));\n\t\t\t\t\tgraph[getid(fr,i + 200)].push_back(edge(getid(to,0),cs));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tgraph[getid(fr,i)].push_back(edge(getid(to,i + cs),cs));\n\t\t\t\t\tgraph[getid(fr,i + 200)].push_back(edge(getid(to,i + cs + 200),cs));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//0->1 or 2->1\n\t\t\tif(cs >= x)\n\t\t\t\tgraph[getid(fr,0)].push_back(edge(getid(to,0),cs));\n\t\t\telse\n\t\t\t\tgraph[getid(fr,0)].push_back(edge(getid(to,cs + t[fr] * 100 + 1),cs));\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&m,&x);\n\tfor(int i = 0;i < n;++i)\n\t{\n\t\tscanf(\"%d\",t + i);\n\t}\n\tfor(int j = 0;j < m;++j)\n\t{\n\t\tint a,b,d;\n\t\tscanf(\"%d %d %d\",&a,&b,&d);\n\t\t--a;--b;\n\t\tputline(a,b,d);\n\t\tputline(b,a,d);\n\t}\n\tdijkstra();\n\tint ans = INF;\n\tfor(int i = 0;i <= 400;++i)\n\t{\n\t\tans = min(ans,dist[getid(n-1,i)]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<list>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<functional>\n#include<queue>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10000][3][201];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost, 0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint t[10000];\nvector<P>E[10000];\nint d[10000][3][201];\n\nstruct st {\n\tint u, c, i, a;\n};\nbool operator<(const st&a, const st&b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint n, m, x; scanf(\"%d%d%d\", &n, &m, &x);\n\trep(i, n)scanf(\"%d\", &t[i]);\n\trep(i, m) {\n\t\tint a, b, d; scanf(\"%d%d%d\", &a, &b, &d); a--; b--;\n\t\tE[a].push_back(P(d, b)); E[b].push_back(P(d, a));\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\td[0][0][0] = 0; que.push({ 0,0,0,0 });\n\twhile (!que.empty()) {\n\t\tst s = que.top(); que.pop();\n\t\tif (d[s.u][s.i][s.a] != s.c)continue;\n\t\tfor (P&v : E[s.u]) {\n\t\t\tint a = min(x, s.a + v.first), k = t[v.second];\n\t\t\tif (abs(s.i - t[v.second]) == 2) {\n\t\t\t\tif (a < x)continue;\n\t\t\t}\n\t\t\tif (k == 1)k = s.i;\n\t\t\telse a = 0;\n\t\t\tif (d[v.second][k][a] > s.c + v.first) {\n\t\t\t\td[v.second][k][a] = s.c + v.first;\n\t\t\t\tque.push({ v.second, d[v.second][k][a],k,a });\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, x + 1) {\n\t\tMin = min(Min, d[n - 1][0][i]);\n\t\tMin = min(Min, d[n - 1][2][i]);\n\t}\n\tprintf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing data=tuple<int,int,int>;\nusing P=pair<int,data>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[10010];\n\nint d[10010][2][205];\n\nint n,m,x;\nint t[10010];\n\nsigned main()\n{\n    cin>>n>>m>>x;\n\n    rep(i,n)cin>>t[i];\n\n    rep(i,m) {\n        int a,b,d;cin>>a>>b>>d;\n        --a,--b;\n        G[a].PB(edge{b,d});\n        G[b].PB(edge{a,d});\n    }\n\n    priority_queue<P,vector<P>,greater<P>> q;\n\n    rep(i, n) rep(j, 2) rep(k, 205) d[i][j][k] = inf;\n    d[0][0][0] = 0;\n\n    q.push(P(0, data(0, 0, 0)));\n\n    while (q.size()) {\n        P p = q.top(); q.pop();\n\n        int dist = p.fst;\n        int v, type, tim;\n        tie(v,type,tim) = p.scd;\n\n        if (v == n-1) {\n            cout << dist << endl;\n            return 0;\n        }\n\n        if (d[v][type][tim] < dist) continue;\n\n        for (edge &e : G[v]) {\n            int u, ntype, ntim;\n            if (t[e.to] == 1) {\n                u = e.to, ntype = type, ntim = min(200, tim+e.cost);\n            } else if (t[v] == t[e.to]) {\n                u = e.to, ntype = type, ntim = 0;\n            } else if (t[v] != t[e.to]) {\n                if (tim + e.cost < x) continue;\n                u = e.to, ntype = t[e.to], ntim = 0;\n            }\n\n            if (d[u][ntype][ntim] > d[v][type][tim] + e.cost) {\n                d[u][ntype][ntim] = d[v][type][tim] + e.cost;\n                q.push(P(d[u][ntype][ntim], data(u, ntype, ntim)));\n            }\n        }\n    }\n\n    int ans = inf;\n\n    rep(i, 2) rep(j, 205) ans = min(ans, d[n-1][i][j]);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 10010\n#define X 210\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P>PP;\nll d[N][X*2],n,m,x;\nll t[N];\nvector<P> v[N];\npriority_queue<PP,vector<PP>,greater<PP> > Q;\nvoid Qpush(ll cost,ll a,ll b){\n\tQ.push(make_pair(cost,make_pair(a,b)));\n}\nint main(){\n\tcin>>n>>m>>x;\n\tlol(i,n){\n\t\tcin>>t[i+1];\n\t}\n\tlol(i,n+1)lol(j,2*X)d[i][j]=-1;\n\tlol(i,m){\n\t\tll a,b,c;cin>>a>>b>>c;\n\t\tv[a].push_back(make_pair(b,c));\n\t\tv[b].push_back(make_pair(a,c));\n\t}\n\tv[0].push_back(make_pair(1,0));\n\tQpush(0,0,X);\n\twhile(!Q.empty()){\n\t\tll cost=Q.top().first;\n\t\tll a=Q.top().second.first;\n\t\tll b=Q.top().second.second;\n\t\tQ.pop();\n\t\tif(d[a][b]!=-1)continue;\n\t\td[a][b]=cost;\n\t\tfor(auto to:v[a]){\n\t\t\tll ver=to.first,len=to.second;\n\t\t\tll ind=b;\n\t\t\tif(b>=X)ind=max((ll)X,b-len);\n\t\t\tif(b<=X)ind=min((ll)X,b+len);\n\t\t\tif(t[ver]==0&&ind>=X){\n\t\t\t\tQpush(cost+len,ver,X+x);\n\t\t\t}\n\t\t\tif(t[ver]==2&&ind<=X){\n\t\t\t\tQpush(cost+len,ver,X-x);\n\t\t\t}\n\t\t\tif(t[ver]==1){\n\t\t\t\tQpush(cost+len,ver,ind);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=(ll)mod*(ll)mod;\n\tlol(i,2*X){\n\t\tif(d[n][i]!=-1)ans=min(ans,d[n][i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1e9)\n\ntypedef pair<int, int> P;\n\nstruct Q {\n    int time;\n    int togo;\n    int status;\n    int room;\n    Q() {}\n    Q(int a,int b,int c,int d) {\n        this->time=a; this->togo=b; this->status=c; this->room=d;\n    }\n    bool operator<(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo<rhs.togo):(this->time<rhs.time);\n    }\n    bool operator>(const Q& rhs) const {\n        return (this->time==rhs.time)?(this->togo>rhs.togo):(this->time>rhs.time);\n    }\n};\n\nint main() {\n    int N,M;\n    int X;\n    cin >> N >> M >> X;\n\n    vector<int> T(N);\n    for(int i=0; i<N; ++i) {\n        cin >> T[i];\n    }\n\n    vector<P> to[N];\n    for(int i=0; i<M; ++i) {\n        int a,b,d;\n        cin >> a >> b >> d;\n        to[a-1].push_back(P(d,b-1));\n        to[b-1].push_back(P(d,a-1));\n    }\n\n    priority_queue<Q,vector<Q>,greater<Q> > q;\n    int time[N][2][X+1];\n\n    for(int i=0; i<N; ++i) {\n        for(int j=0; j<2; ++j) {\n            for(int k=0; k<X+1; ++k) {\n                time[i][j][k]=INF;\n            }\n        }\n    }\n\n    q.push(Q(0,X,0,0)); // time, togo, status(0=cold,1=normal,2=hot), room\n    time[0][0][X]=0;\n    // int cnt=0; // for debug\n    while(!q.empty()) {\n        Q now=q.top(); q.pop();\n        if(time[now.room][now.status/2][now.togo]<now.time) continue;\n        for(auto nxt : to[now.room]) {\n            int nxt_togo=max(0,now.togo-nxt.first);\n            if(T[nxt.second]==1) {\n                if(time[nxt.second][now.status/2][nxt_togo]<now.time+nxt.first) continue;\n                time[nxt.second][now.status/2][nxt_togo]=now.time+nxt.first;\n                q.push(Q(now.time+nxt.first,nxt_togo,now.status,nxt.second));\n            } else if(T[nxt.second]==now.status || nxt_togo==0) {\n                if(time[nxt.second][T[nxt.second]/2][X]<now.time+nxt.first) continue;\n                time[nxt.second][T[nxt.second]/2][X]=now.time+nxt.first;\n                q.push(Q(now.time+nxt.first,X,T[nxt.second],nxt.second));\n            }\n        }\n    }\n\n    int ans=INF;\n\n    for(int i=0; i<2; ++i) {\n        for(int j=0; j<X+1; ++j) {\n            ans=min(ans,time[N-1][i][j]);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint d[10000];\nvector<P>rinsetu[10000];\nstruct room {\n\tint now, cost, state, keika;\n};\nbool operator <(room a, room b) {\n\treturn a.cost > b.cost;\n}\nint mincost[10000][3][201];//??¨?±?????????????????????????\nint main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfor (int e = 0; e < a; e++) {\n\t\tscanf(\"%d\", &d[e]);\n\t}\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g, h; scanf(\"%d%d%d\", &f, &g, &h);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(P(h, g));\n\t\trinsetu[g].push_back(P(h, f));\n\t}\n\tmemset(mincost, 0x3f, sizeof(mincost));\n\tmincost[0][0][0] = 0;\n\tpriority_queue<room>Q;\n\tQ.push({0,0,0,0});\n\twhile (Q.size()) {\n\t\troom e = Q.top(); Q.pop();\n\t\tif (mincost[e.now][e.state][e.keika] < e.cost)continue;\n\t\tfor (P f : rinsetu[e.now]) {\n\t\t\tint x = min(c, f.first + e.keika), y = d[f.second];\n\t\t\tif (abs(e.state - y) == 2 && x < c)continue;\n\t\t\tif (y == 1) {\n\t\t\t\ty = e.state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (mincost[f.second][y][x] > e.cost + f.first) {\n\t\t\t\tmincost[f.second][y][x] = e.cost + f.first;\n\t\t\t\tQ.push({f.second,mincost[f.second][y][x],y,x});\n\t\t\t}\n\t\t}\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tMIN = min({MIN,mincost[a-1][0][i],mincost[a-1][1][i],mincost[a-1][2][i]});\n\t}\n\tcout << MIN << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvector<vector<P>> G(10010);\nvector<int> t(10010);\n\nint n, m, x;\n\nint dijkstra(int s){\n    int dist[n][x+1][3];\n    for(int i=0; i<n; i++){\n        for(int j=0; j<=x; j++){\n            for(int k=0; k<3; k++){\n                dist[i][j][k] = 1e9;\n            }\n        }\n    }\n\n    priority_queue<T, vector<T>, greater<T>> que;\n    dist[s][x][0] = 0;\n    que.emplace(0, s, x, 0);\n\n    while(!que.empty()){\n        int ccost, cv, cx, ct;\n        tie(ccost, cv, cx, ct) = que.top();\n        que.pop();\n\n        if(dist[cv][cx][ct] < ccost) continue;\n\n        for(auto X : G[cv]){\n            int nv, ncost;\n            tie(nv, ncost) = X;\n\n            int restx = max(0, cx - ncost);\n\n            if(restx == 0){\n                if(t[nv] == 0){\n                    if(dist[cv][cx][ct] + ncost < dist[nv][x][0]){\n                        dist[nv][x][0] = dist[cv][cx][ct] + ncost;\n                        que.emplace(dist[nv][x][0], nv, x, 0);\n                    }\n                }\n                else if(t[nv] == 1){\n                    if(dist[cv][cx][ct] + ncost < dist[nv][0][1]){\n                        dist[nv][0][1] = dist[cv][cx][ct] + ncost;\n                        que.emplace(dist[nv][0][1], nv, 0, 1);\n                    }\n                }\n                else{\n                    if(dist[cv][cx][ct] + ncost < dist[nv][x][2]){\n                        dist[nv][x][2] = dist[cv][cx][ct] + ncost;\n                        que.emplace(dist[nv][x][2], nv, x, 2);\n                    }\n                }\n            }\n            else{\n                if(t[nv] == 0){\n                    if(ct == 2) continue;\n\n                    if(dist[cv][cx][ct] + ncost < dist[nv][x][0]){\n                        dist[nv][x][0] = dist[cv][cx][ct] + ncost;\n                        que.emplace(dist[nv][x][0], nv, x, 0);\n                    }\n                }\n                else if(t[nv] == 1){\n                    if(dist[cv][cx][ct] + ncost < dist[nv][restx][ct]){\n                        dist[nv][restx][ct] = dist[cv][cx][ct] + ncost;\n                        que.emplace(dist[nv][restx][ct], nv, restx, ct);\n                    }\n                }\n                else{\n                    if(ct == 0) continue;\n\n                    if(dist[cv][cx][ct] + ncost < dist[nv][x][2]){\n                        dist[nv][x][2] = dist[cv][cx][ct] + ncost;\n                        que.emplace(dist[nv][x][2], nv, x, 2);\n                    }\n                }\n            }   \n        }\n    }\n\n    int ans = 1e9;\n    for(int i=0; i<=x; i++){\n        for(int j=0; j<3; j++){\n            ans = min(ans, dist[n-1][i][j]);\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cin>>n>>m>>x;\n    for(int i=0; i<n; i++) cin>>t[i];\n\n    for(int i=0; i<m; i++){\n        int a, b, d; cin>>a>>b>>d;\n        a--, b--;\n        G[a].emplace_back(b, d);\n        G[b].emplace_back(a, d);\n    }\n\n    cout << dijkstra(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct edge {\n    int vertex;\n    int len;\n};\n\nstruct status {\n    int vertex;\n    int dis;\n    bool is_last_cold;\n    int ban_time;\n\n    bool operator>(const status &rhs) const {\n        if (dis != rhs.dis) return dis > rhs.dis;\n        return vertex > rhs.vertex;\n    }\n};\n\nint n, x;\nvector<int> temperature;\nvector<vector<edge>> graph;\nvector<vector<vector<int>>> dis;\n\nvoid dijkstra(int s) {\n    priority_queue<status, vector<status>, greater<>> que;\n    dis = vector<vector<vector<int>>>(n, vector<vector<int>>(2, vector<int>(x + 1, 1145141919)));\n    dis[s][true][x] = 0;\n    que.push(status{s, 0, true, x});\n\n    while (!que.empty()) {\n        status now = que.top();\n        que.pop();\n\n        int scored_dis = dis[now.vertex][now.is_last_cold][now.ban_time];\n        if (scored_dis < now.dis)continue;\n\n        for (auto next:graph[now.vertex]) {\n            if (temperature[next.vertex] == 0 && !now.is_last_cold && now.ban_time > next.len)continue;\n            if (temperature[next.vertex] == 2 && now.is_last_cold && now.ban_time > next.len)continue;\n\n            bool next_is_cold;\n            int next_ban_time;\n            if (temperature[next.vertex] == 1) {\n                next_is_cold = now.is_last_cold;\n                next_ban_time = max(0, now.ban_time - next.len);\n            } else {\n                next_is_cold = temperature[next.vertex] == 0;\n                next_ban_time = x;\n            }\n\n            if (dis[next.vertex][next_is_cold][next_ban_time] > now.dis + next.len) {\n                for (int i = next_ban_time; i <= x; i++) {\n                    if (dis[next.vertex][next_is_cold][i] <= now.dis + next.len)break;\n                    dis[next.vertex][next_is_cold][i] = now.dis + next.len;\n                }\n                que.push({next.vertex, now.dis + next.len, next_is_cold, next_ban_time});\n            }\n        }\n    }\n}\n\nint main() {\n    int m;\n    cin >> n >> m >> x;\n    temperature = vector<int>(n);\n    for (int i = 0; i < n; i++)cin >> temperature[i];\n    graph = vector<vector<edge>>(n);\n    for (int i = 0; i < m; i++) {\n        int from, to, cost;\n        cin >> from >> to >> cost;\n        from--;\n        to--;\n        graph[from].push_back({to, cost});\n        graph[to].push_back({from, cost});\n    }\n\n    dijkstra(0);\n\n    cout << min(dis[n - 1][0][x], dis[n - 1][1][x]) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0635 Snake JOI\n// 2018.2.15 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef unsigned char uchar;\n#define QMAX 10000\ntypedef struct { int t, s; uchar b, x; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t, uchar b, uchar x)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].b = b, que[i].x = x;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define MAX 20\n#define MIN(a,b)  ((a)<=(b)?(a):(b))\n\nuchar t[10002];\nint to[10002][MAX]; uchar d[10002][MAX]; short hi[10002];\nchar mk[10002][3][201];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int start, int goal, int X)\n{\n\tint i, u, v, c, k;\n\tunsigned char b, x, b2, x2;\n\n\tqsize = 0;\n\tenq(start, 0, 1, X);\t\t// t[0] = 1\n\twhile (qsize) {\n\t\tu = que[0].s, c = que[0].t, b = que[0].b, x = que[0].x, deq();\n\t\tif (u == goal) break;\n\n\t\tif (mk[u][b][x]) continue;\n\t\tmk[u][b][x] = 1;\n\n\t\tfor (i = 0; i < hi[u]; i++) {\n\t\t\tv = to[u][i];\n\t\t\tif ((b | t[v]) == 3 && d[u][i] < x) continue;\n\t\t\tk = MIN(d[u][i], x);\n\t\t\tif (mk[v][b][k]) continue;\n\t\t\tif (t[v] > 0) b2 = t[v], x2 = X;\n\t\t\telse b2 = b, x2 = (x < d[u][i])? 0: x-d[u][i];\n\t\t\tenq(v, c+d[u][i], b2, x2);\n\t\t}\n\t}\n\treturn c;\n}\n\nint main()\n{\n\tint N, M, X, i, a, b, c;\n\n\tN = in(), M = in(), X = in();\n\n\tfor (i = 0; i < N; i++) {\n\t\ta = getchar_unlocked() & 3; if (a < 2) a = !a;\n\t\tt[i] = a;\t\t\t// 0:快適, 1:寒, 2:暑. \n\t\tgetchar_unlocked();\n\t}\n\n\twhile (M--) {\n\t\ta = in()-1, b = in()-1, c = in();\n\t\ti = hi[a]++, to[a][i] = b, d[a][i] = c;\n\t\ti = hi[b]++, to[b][i] = a, d[b][i] = c;\n\t}\n\n\tprintf(\"%d\\n\", dijkstra(0, N-1, X));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0635 Snake JOI\n// 2018.2.15 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define QMAX 3000\ntypedef struct { int t, s; uchar b, x; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t, uchar b, uchar x)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].b = b, que[i].x = x;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nuchar t[10002];\nint to[10002][20]; uchar d[10002][20]; short hi[10002];\nchar mk[10002][3][201];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int start, int goal, int X)\n{\n\tint i, u, v, c, e;\n\tunsigned char b, x;\n\n\tqsize = 0;\n\tenq(start, 0, 1, X);\t\t// t[0] = 1\n\twhile (qsize) {\n\t\tu = que[0].s, c = que[0].t, b = que[0].b, x = que[0].x, deq();\n\t\tif (u == goal) break;\n\n\t\tif (mk[u][b][x]) continue;\n\t\tmk[u][b][x] = 1;\n\n\t\tfor (i = 0; i < hi[u]; i++) {\n\t\t\tv = to[u][i], e = d[u][i];\n\t\t\tif ((b | t[v]) == 3 && e < x) continue;\n\n\t\t\tif (t[v] > 0) {\n\t\t\t\tif (!mk[v][t[v]][X]) enq(v, c+d[u][i], t[v], X);\n\t\t\t} else {\n\t\t\t\tint k = (int)x- e; if (k < 0) k = 0;\n\t\t\t\tif (!mk[v][b][k]) enq(v, c+d[u][i], b, k);\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nint main()\n{\n\tint N, M, X, i, a, b, c;\n\n\tN = in(), M = in(), X = in();\n\n\tfor (i = 0; i < N; i++) {\n\t\ta = getchar_unlocked() & 3; if (a < 2) a = !a;\n\t\tt[i] = a;\t\t\t// 0:快適, 1:寒, 2:暑. \n\t\tgetchar_unlocked();\n\t}\n\n\twhile (M--) {\n\t\ta = in()-1, b = in()-1, c = in();\n\t\ti = hi[a]++, to[a][i] = b, d[a][i] = c;\n\t\ti = hi[b]++, to[b][i] = a, d[b][i] = c;\n\t}\n\n\tprintf(\"%d\\n\", dijkstra(0, N-1, X));\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic static HashMap<String,String> map = new HashMap<>();\n\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint X = sc.nextInt();\n\t\tint[] T = new int[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tT[i] = sc.nextInt();\n\t\t}\n\t\tint[] A = new int[M];\n\t\tint[] B = new int[M];\n\t\tint[] D = new int[M];\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tA[i] = sc.nextInt()-1;\n\t\t\tB[i] = sc.nextInt()-1;\n\t\t\tD[i] = sc.nextInt();\n\t\t}\n\t\tV[] v = new V[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tv[i] = new V();\n\t\t}\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tv[A[i]].n_V.add(B[i]);\n\t\t\t\tv[A[i]].n_T.add(D[i]);\n\t\t\t\tv[B[i]].n_V.add(A[i]);\n\t\t\t\tv[B[i]].n_T.add(D[i]);\n\t\t}\n\t\tint INF = 2 << 29;\n\t\t\n\t\t\n\t\tint[][][] memo = new int[3][201][N];\n\t\tfor(int i = 0; i < memo.length; i++) {\n\t\t\tfor(int j = 0; j < 201; j++) {\n\t\t\t\tArrays.fill(memo[i][j], INF);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(0,0,0,X,-10000));\n\t\tint ans = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData d = q.poll();\n\t\t\tif(d.now == N-1) {\n\t\t\t\tans = Math.min(ans, d.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tV vv = v[d.now];\n\t\t\tArrayList<Integer> vn = vv.n_V;\n\t\t\tArrayList<Integer> vt = vv.n_T;\n\t\t\t\n\t\t\tif(d.state == 0) {\n\t\t\t\tif(memo[0][d.c_t][d.now] <= d.time) continue;\n\t\t\t\tmemo[0][d.c_t][d.now] = d.time;\n\t\t\t\tfor(int i = 0; i < vn.size(); i++) {\n\t\t\t\t\tint next_v = vn.get(i);\n\t\t\t\t\tint next_t = vt.get(i);\n\t\t\t\t\tint cend = d.c_t;\n\t\t\t\t\tif(next_t >= cend) {\n\t\t\t\t\t\tif(T[next_v] == 0) {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,0,X,0));\n\t\t\t\t\t\t} else if(T[next_v] == 1) {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,1,0,0));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,2,0,X));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(T[next_v] == 0) {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,0,X,0));\n\t\t\t\t\t\t} else if(T[next_v] == 1) {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,0,cend - next_t,0));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d.state == 1) {\n\t\t\t\tif(memo[1][0][d.now] <= d.time) continue;\n\t\t\t\tmemo[1][0][d.now] = d.time;\n\t\t\t\tfor(int i = 0; i < vn.size(); i++) {\n\t\t\t\t\tint next_v = vn.get(i);\n\t\t\t\t\tint next_t = vt.get(i);\n\t\t\t\t\tif(T[next_v] == 0) {\n\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,0,X,0));\n\t\t\t\t\t} else if(T[next_v] == 1) {\n\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,1,0,0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,2,0,X));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif(memo[2][d.h_t][d.now] <= d.time) continue;\n\t\t\t\tmemo[2][d.h_t][d.now] = d.time;\n\t\t\t\tfor(int i = 0; i < vn.size(); i++) {\n\t\t\t\t\tint next_v = vn.get(i);\n\t\t\t\t\tint next_t = vt.get(i);\n\t\t\t\t\tint cend = d.h_t;\n\t\t\t\t\tif(next_t >= cend) {\n\t\t\t\t\t\tif(T[next_v] == 0) {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,0,X,0));\n\t\t\t\t\t\t} else if(T[next_v] == 1) {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,1,0,0));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,2,0,X));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(T[next_v] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if(T[next_v] == 1) {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,2,0,cend - next_t));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tq.add(new Data(d.time + next_t,next_v,2,0,X));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\tstatic class V {\n\t\tArrayList<Integer> n_V = new ArrayList<Integer>();\n\t\tArrayList<Integer> n_T = new ArrayList<Integer>();\n\t}\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\t\n\t\tint time;\n\t\tint now;\n\t\tint state;\n\t\tint c_t;\n\t\tint h_t;\n\t\t\n\t\tData(int a, int b, int c, int d, int e) {\n\t\t\ttime = a;\n\t\t\tnow = b;\n\t\t\tstate = c;\n\t\t\tc_t = d;\n\t\t\th_t = e;\n\t\t}\n\t\t\n\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\nimport std.container;\nimport std.typecons;\nimport std.math;\n\nvoid main(){\n    alias Tuple!(int, int) edge;\n    alias Tuple!(int, int, int, int) state; // dist, node, last temp, x\n\n    int n, m, x;\n    scanf(\"%d%d%d\", &n, &m, &x);\n    auto temp = new int[n];\n    foreach(i; 0..n) scanf(\"%d\", &temp[i]);\n    auto graph = new edge[][](n);\n    foreach(i; 0..m){\n        int a, b, d;\n        scanf(\"%d%d%d\", &a, &b, &d);\n        --a; --b;\n        graph[a] ~= edge(b, d);\n        graph[b] ~= edge(a, d);\n    }\n\n    auto dist = new int[][][](n, 3, 210); // node, last temp, x\n    foreach(a; dist) foreach(b; a) b[] = int.max / 2;\n    state[] a = [state(0,0,0,x)];\n    auto q = new BinaryHeap!(Array!state, \"a > b\")();\n    q.insert(state(0, 0, 0, x));\n    int ans = -1;\n    while(q.length != 0){\n        int cd = q.front[0];\n        int cn = q.front[1];\n        int ct = q.front[2];\n        int cx = q.front[3];\n        q.removeFront;\n        // writeln([cd, cn, ct, cx]);\n        if(cn == n-1){\n            ans = cd;\n            break;\n        }\n        if(dist[cn][ct][cx] < cd) continue;\n\n        foreach(const ref e; graph[cn]){\n            int nd = cd + e[1];\n            int nn = e[0];\n            int nt = temp[nn] != 1 ? temp[nn] : ct;\n            int nx = temp[nn] != 1 ? x : max(0, cx - e[1]);\n            if(abs(nt - ct) == 2 && cx > e[1]) continue;\n            if(dist[nn][nt][nx] > nd){\n                dist[nn][nt][nx] = nd;\n                q.insert(state(nd, nn, nt, nx));\n            }\n        }\n    }\n    writeln(ans);\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nN, M, X = map(int, input().split())\nT = [int(input()) for i in range(N)]\nG = [[] for i in range(N)]\nfor i in range(M):\n    A, B, D = map(int, input().split())\n    G[A-1].append((B-1, D))\n    G[B-1].append((A-1, D))\nINF = 10**9\ndist = [[INF]*(2*X+1) for i in range(N)]\ndist[0][-X] = 0\n\nque = [(0, 0, -X)]\nwhile que:\n    cost, u, t = heappop(que)\n    if dist[u][t] < cost:\n        continue\n    for v, d in G[u]:\n        t1 = max(0, t - d) if t > 0 else min(0, t + d)\n        if (t1 < 0 and T[v] == 2) or (t1 > 0 and T[v] == 0):\n            continue\n        t1 = [-X, t1, X][T[v]]\n        if cost + d < dist[v][t1]:\n            dist[v][t1] = cost + d\n            heappush(que, (cost + d, v, t1))\nprint(min(dist[N-1]))"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 20\n\ndef main():\n  n, m, x = map(int, input().split())\n  tlst = [int(input()) for _ in range(n)]\n  edges = [[] for _ in range(n)]\n  for _ in range(m):\n    a, b, d = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append((b, d))\n    edges[b].append((a, d))\n  \n  que = []\n  heappush(que, (0, x, 0, 0)) #道のり、寒さ、暑さ、部屋番号\n  dic = {}\n  dic[(x, 0, 0)] = 0\n  while que:\n    total, ct, ht, node = heappop(que)\n    for to, dist in edges[node]:\n      new_ct = max(0, ct - dist)\n      new_ht = max(0, ht - dist)\n      t = tlst[to]\n      if t == 1 or (t == 0 and new_ht == 0) or (t == 2 and new_ct == 0):\n        new_total = total + dist\n        if t == 0: new_ct = x\n        if t == 2: new_ht = x\n        if (new_ct, new_ht, to) not in dic or dic[(new_ct, new_ht, to)] > new_total:\n          dic[(new_ct, new_ht, to)] = new_total\n          heappush(que, (new_total, new_ct, new_ht, to))\n  \n  print(min([dic[(ct, ht, n - 1)] if (ct, ht, n - 1) in dic else INF for ct in range(x + 1) for ht in range(x + 1)]))\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter};\nuse std::collections::{VecDeque, BinaryHeap, BTreeMap};\nuse std::f32::MAX;\nuse ::Temperature::{Comfort, Cold, Hot};\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone)]\nenum Temperature {\n    Comfort, Hot, Cold\n}\n#[derive(Copy, Clone)]\nstruct Corridor {\n    to: usize, time: usize,\n}\nstruct KeyWithValue<K, V> {\n    key: K, value: V\n}\nimpl <K, V> KeyWithValue<K, V> {\n    fn new(key: K, value: V) -> KeyWithValue<K, V> {\n        KeyWithValue{key: key, value: value}\n    }\n}\nimpl <K: Ord, V> Ord for KeyWithValue<K, V> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.key.cmp(&self.key)\n    }\n}\nimpl <K: PartialOrd, V> PartialOrd for KeyWithValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        other.key.partial_cmp(&self.key)\n    }\n}\nimpl <K: PartialEq, V> PartialEq for KeyWithValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialEq, V> Eq for KeyWithValue<K, V>{}\nfn main() {\n    let_all!(n: usize, m: usize, x: usize);\n    let mut rooms = Vec::with_capacity(n);\n    for _ in 0 .. n {\n        let_all!(t: usize);\n        match t {\n            0 => rooms.push(Cold),\n            1 => rooms.push(Comfort),\n            2 => rooms.push(Hot),\n            _ => unreachable!(),\n        }\n    }\n    let rooms = rooms;\n    let mut corridors: Vec<Vec<Corridor>> = vec![Vec::new(); n];\n    for _ in 0 .. m {\n        let_all!(a: usize, b: usize, d: usize);\n        corridors[a - 1].push(Corridor{to: b - 1, time: d});\n        corridors[b - 1].push(Corridor{to: a - 1, time: d});\n    }\n    let corridors = corridors;\n    let mut min_time: Vec<Vec<i64>> = vec![vec![std::i64::MAX; 2 * x + 1]; n];\n    let mut heap: BinaryHeap<KeyWithValue<i64, (usize, usize)>> = BinaryHeap::new();\n    min_time[0][0] = 0_i64;\n    heap.push(KeyWithValue::new(0_i64, (0 as usize, 0 as usize)));\n    while let Some(KeyWithValue{key: time, value: (room, x_time)}) = heap.pop() {\n        if room == n - 1 {\n            println!(\"{}\", time);\n            break\n        }\n        if min_time[room][x_time] == time {\n            for &Corridor{to: next, time: distance} in &corridors[room] {\n                match rooms[next] {\n                    Hot if x_time + distance >= x => {\n                        if min_time[next][x * 2] > time + distance as i64 {\n                            min_time[next][x * 2] = time + distance as i64;\n                            heap.push(KeyWithValue::new(min_time[next][x * 2], (next, x * 2)));\n                        }\n                    }\n                    Cold if x_time <= distance + x => {\n                        if min_time[next][0] > time + distance as i64 {\n                            min_time[next][0] = time + distance as i64;\n                            heap.push(KeyWithValue::new(min_time[next][0], (next, 0)));\n                        }\n                    }\n                    Comfort => {\n                        if x_time <= x {\n                            let next_x = min(x_time + distance, x);\n                            if min_time[next][next_x] > time + distance as i64 {\n                                min_time[next][next_x] = time + distance as i64;\n                                heap.push(KeyWithValue::new(min_time[next][next_x], (next, next_x)));\n                            }\n                        }else {\n                            let next_x = if x_time <= distance + x {x} else {x_time - distance};\n                            if min_time[next][next_x] > time + distance as i64 {\n                                min_time[next][next_x] = time + distance as i64;\n                                heap.push(KeyWithValue::new(min_time[next][next_x], (next, next_x)));\n                            }\n                        }\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n}\n"
  }
]