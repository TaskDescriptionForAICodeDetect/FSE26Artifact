[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point vertices[5];\n} Pentagon;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble min_distance_pentagon_to_point(Pentagon p, Point pt) {\n    double min_dist = DBL_MAX;\n    for (int i = 0; i < 5; i++) {\n        double dist = distance(p.vertices[i], pt);\n        if (dist < min_dist) {\n            min_dist = dist;\n        }\n    }\n    return min_dist;\n}\n\ndouble min_distance_pentagon_to_pentagon(Pentagon a, Pentagon b) {\n    double min_dist = DBL_MAX;\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            double dist = distance(a.vertices[i], b.vertices[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n\ndouble dijkstra(double graph[100][100], int n, int start, int end) {\n    double dist[100];\n    bool visited[100] = {false};\n\n    for (int i = 0; i < n; i++) {\n        dist[i] = DBL_MAX;\n    }\n    dist[start] = 0;\n\n    for (int count = 0; count < n - 1; count++) {\n        int u = -1;\n        double min = DBL_MAX;\n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && dist[v] < min) {\n                min = dist[v];\n                u = v;\n            }\n        }\n\n        if (u == -1) break;\n        visited[u] = true;\n\n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && graph[u][v] != DBL_MAX && dist[u] + graph[u][v] < dist[v]) {\n                dist[v] = dist[u] + graph[u][v];\n            }\n        }\n    }\n\n    return dist[end];\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Pentagon pentagons[100];\n    Point vega, altair;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < 5; j++) {\n            scanf(\"%lf %lf\", &pentagons[i].vertices[j].x, &pentagons[i].vertices[j].y);\n        }\n    }\n    scanf(\"%lf %lf\", &vega.x, &vega.y);\n    scanf(\"%lf %lf\", &altair.x, &altair.y);\n\n    double graph[100][100];\n    for (int i = 0; i < N + 2; i++) {\n        for (int j = 0; j < N + 2; j++) {\n            graph[i][j] = DBL_MAX;\n        }\n    }\n\n    // Vega to pentagons and pentagons to Altair\n    for (int i = 0; i < N; i++) {\n        double dist = min_distance_pentagon_to_point(pentagons[i], vega);\n        graph[0][i + 1] = dist;\n        graph[i + 1][0] = dist;\n    }\n\n    for (int i = 0; i < N; i++) {\n        double dist = min_distance_pentagon_to_point(pentagons[i], altair);\n        graph[i + 1][N + 1] = dist;\n        graph[N + 1][i + 1] = dist;\n    }\n\n    // Pentagons to pentagons\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            double dist = min_distance_pentagon_to_pentagon(pentagons[i], pentagons[j]);\n            graph[i + 1][j + 1] = dist;\n            graph[j + 1][i + 1] = dist;\n        }\n    }\n\n    // Vega to Altair directly\n    double direct_dist = distance(vega, altair);\n    graph[0][N + 1] = direct_dist;\n    graph[N + 1][0] = direct_dist;\n\n    double min_dist = dijkstra(graph, N + 2, 0, N + 1);\n    printf(\"%.9f\\n\", min_dist);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nvector<Point> getPentaclePoints(const Point& center, double size) {\n    vector<Point> points(5);\n    for (int i = 0; i < 5; ++i) {\n        double angle = 2 * M_PI * i / 5;\n        points[i].x = center.x + size * cos(angle);\n        points[i].y = center.y + size * sin(angle);\n    }\n    return points;\n}\n\ndouble dijkstra(const vector<vector<pair<int, double>>>& graph, int start, int end) {\n    vector<double> dist(graph.size(), numeric_limits<double>::max());\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n    dist[start] = 0.0;\n    pq.push({0.0, start});\n\n    while (!pq.empty()) {\n        double current_dist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (u == end) {\n            return current_dist;\n        }\n\n        if (current_dist > dist[u]) {\n            continue;\n        }\n\n        for (const auto& edge : graph[u]) {\n            int v = edge.first;\n            double weight = edge.second;\n            if (dist[v] > dist[u] + weight) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return -1.0;\n}\n\nint main() {\n    Point vega, altair;\n    double vega_size, altair_size;\n    cin >> vega.x >> vega.y >> vega_size;\n    cin >> altair.x >> altair.y >> altair_size;\n\n    auto vega_points = getPentaclePoints(vega, vega_size);\n    auto altair_points = getPentaclePoints(altair, altair_size);\n\n    vector<Point> all_points;\n    all_points.insert(all_points.end(), vega_points.begin(), vega_points.end());\n    all_points.insert(all_points.end(), altair_points.begin(), altair_points.end());\n\n    int n = all_points.size();\n    vector<vector<pair<int, double>>> graph(n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dist = distance(all_points[i], all_points[j]);\n            graph[i].push_back({j, dist});\n            graph[j].push_back({i, dist});\n        }\n    }\n\n    double min_dist = numeric_limits<double>::max();\n    for (int i = 0; i < 5; ++i) {\n        for (int j = 5; j < 10; ++j) {\n            double dist = dijkstra(graph, i, j);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    cout.precision(10);\n    cout << fixed << min_dist << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Star {\n    int id;\n    double x, y;\n\n    Star(int id, double x, double y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Edge {\n    int to;\n    double cost;\n\n    Edge(int to, double cost) {\n        this.to = to;\n        this.cost = cost;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int vegaId = 0;\n        int altairId = 1;\n        List<Star> stars = new ArrayList<>();\n        stars.add(new Star(vegaId, sc.nextDouble(), sc.nextDouble())); // Vega\n        stars.add(new Star(altairId, sc.nextDouble(), sc.nextDouble())); // Altair\n        int n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            stars.add(new Star(stars.size(), x, y));\n        }\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < stars.size(); i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < stars.size(); i++) {\n            for (int j = i + 1; j < stars.size(); j++) {\n                double dx = stars.get(i).x - stars.get(j).x;\n                double dy = stars.get(i).y - stars.get(j).y;\n                double dist = Math.sqrt(dx * dx + dy * dy);\n                graph.get(i).add(new Edge(j, dist));\n                graph.get(j).add(new Edge(i, dist));\n            }\n        }\n\n        double[] dist = new double[stars.size()];\n        Arrays.fill(dist, Double.POSITIVE_INFINITY);\n        dist[vegaId] = 0;\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingDouble(e -> e.cost));\n        pq.add(new Edge(vegaId, 0));\n\n        while (!pq.isEmpty()) {\n            Edge current = pq.poll();\n            int u = current.to;\n            if (u == altairId) break;\n            if (current.cost > dist[u]) continue;\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                double newDist = dist[u] + edge.cost;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.add(new Edge(v, newDist));\n                }\n            }\n        }\n\n        System.out.printf(\"%.6f\\n\", dist[altairId]);\n    }\n}",
    "timestamp": "2025-08-05 21:31:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MilkyWayTour {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static double calculateDistance(Point p1, Point p2) {\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n    }\n\n    public static double shortestPath(Point start, Point end, List<Point> pentacles) {\n        pentacles.add(start);\n        pentacles.add(end);\n        int n = pentacles.size();\n        double[][] distances = new double[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                distances[i][j] = distances[j][i] = calculateDistance(pentacles.get(i), pentacles.get(j));\n            }\n        }\n\n        double[][] dp = new double[1 << n][n];\n        for (double[] row : dp) {\n            Arrays.fill(row, Double.MAX_VALUE);\n        }\n\n        dp[1 << (n - 2)][n - 2] = 0;\n\n        for (int mask = 1 << (n - 2); mask < (1 << n); mask++) {\n            for (int end = 0; end < n - 1; end++) {\n                if ((mask & (1 << end)) == 0) continue;\n                for (int curr = 0; curr < n - 1; curr++) {\n                    if (curr == end || (mask & (1 << curr)) == 0) continue;\n                    int prevMask = mask ^ (1 << end);\n                    dp[mask][end] = Math.min(dp[mask][end], dp[prevMask][curr] + distances[curr][end]);\n                }\n            }\n        }\n\n        double minDistance = Double.MAX_VALUE;\n        for (int i = 0; i < n - 1; i++) {\n            minDistance = Math.min(minDistance, dp[(1 << n) - 1][i] + distances[i][n - 1]);\n        }\n\n        return minDistance;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        Point vega = new Point(scanner.nextInt(), scanner.nextInt());\n        Point altair = new Point(scanner.nextInt(), scanner.nextInt());\n\n        int m = scanner.nextInt();\n        List<Point> pentacles = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            pentacles.add(new Point(scanner.nextInt(), scanner.nextInt()));\n        }\n\n        double result = shortestPath(vega, altair, pentacles);\n        System.out.printf(\"%.2f\\n\", result);\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:31:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n\n#define MAX_STARS 100\n\ntypedef struct {\n    int x, y;\n} Star;\n\nint dijkstra(Star stars[], int n, int start, int end) {\n    int dist[MAX_STARS];\n    int visited[MAX_STARS];\n    \n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    for (int count = 0; count < n - 1; count++) {\n        int min_dist = INT_MAX, min_index;\n        \n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && dist[v] < min_dist) {\n                min_dist = dist[v];\n                min_index = v;\n            }\n        }\n        \n        visited[min_index] = 1;\n        \n        for (int v = 0; v < n; v++) {\n            if (!visited[v]) {\n                double distance = sqrt(pow(stars[min_index].x - stars[v].x, 2) + \n                                       pow(stars[min_index].y - stars[v].y, 2));\n                \n                if (dist[min_index] != INT_MAX && \n                    dist[min_index] + distance < dist[v]) {\n                    dist[v] = dist[min_index] + distance;\n                }\n            }\n        }\n    }\n    \n    return dist[end];\n}\n\nint main() {\n    int n, start, end;\n    Star stars[MAX_STARS];\n    \n    scanf(\"%d %d %d\", &n, &start, &end);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &stars[i].x, &stars[i].y);\n    }\n    \n    int total_distance = dijkstra(stars, n, start, end);\n    \n    printf(\"%d\\n\", total_distance);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:31:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n\ndouble dist(const Point& p1, const Point& p2) {\n    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> stars(n);\n    for (int i = 0; i < n; i++) {\n        cin >> stars[i].x >> stars[i].y;\n    }\n\n    Point start, end;\n    cin >> start.x >> start.y >> end.x >> end.y;\n\n    vector<vector<double>> graph(n + 2, vector<double>(n + 2, INT_MAX));\n    \n    for (int i = 0; i < n; i++) {\n        graph[n][i] = dist(start, stars[i]);\n        graph[i][n+1] = dist(stars[i], end);\n    }\n    \n    graph[n][n+1] = dist(start, end);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            graph[i][j] = graph[j][i] = dist(stars[i], stars[j]);\n        }\n    }\n\n    vector<double> distances(n + 2, INT_MAX);\n    vector<bool> visited(n + 2, false);\n    distances[n] = 0;\n\n    for (int count = 0; count < n + 2; count++) {\n        int u = -1;\n        double minDist = INT_MAX;\n        \n        for (int v = 0; v < n + 2; v++) {\n            if (!visited[v] && distances[v] < minDist) {\n                minDist = distances[v];\n                u = v;\n            }\n        }\n\n        if (u == -1) break;\n        visited[u] = true;\n\n        for (int v = 0; v < n + 2; v++) {\n            if (!visited[v] && graph[u][v] != INT_MAX && \n                distances[u] + graph[u][v] < distances[v]) {\n                distances[v] = distances[u] + graph[u][v];\n            }\n        }\n    }\n\n    printf(\"%.2f\\n\", distances[n+1]);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:31:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef dijkstra(graph, start, end):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        if current_node in visited:\n            continue\n        \n        visited.add(current_node)\n        \n        if current_node == end:\n            return current_distance\n        \n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    \n    return float('inf')\n\ndef min_route(stars, pentacle_lines):\n    graph = {star: {} for star in stars}\n    \n    for (star1, star2) in pentacle_lines:\n        distance = ((stars[star1][0] - stars[star2][0]) ** 2 + (stars[star1][1] - stars[star2][1]) ** 2) ** 0.5\n        graph[star1][star2] = distance\n        graph[star2][star1] = distance\n    \n    return dijkstra(graph, \"Vega\", \"Altair\")\n\n# Example usage\nstars = {\n    \"Vega\": (0, 0),\n    \"Altair\": (4, 3),\n    \"StarA\": (1, 1),\n    \"StarB\": (2, 2),\n    \"StarC\": (3, 3)\n}\n\npentacle_lines = [\n    (\"Vega\", \"StarA\"),\n    (\"StarA\", \"StarB\"),\n    (\"StarB\", \"StarC\"),\n    (\"StarC\", \"Altair\")\n]\n\nprint(min_route(stars, pentacle_lines))",
    "timestamp": "2025-08-13 06:42:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MilkyWayTransportation {\n    static class Star {\n        int x, y;\n        Star(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Edge {\n        int from, to;\n        double weight;\n        Edge(int from, int to, double weight) {\n            this.from = from;\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Sample input: stars and their positions\n        List<Star> stars = Arrays.asList(\n            new Star(0, 0),  // Vega\n            new Star(3, 4), \n            new Star(4, 3), \n            new Star(7, 8),  // Altair\n            new Star(6, 5)\n        );\n        \n        // Construct edges between stars (pentacles) with distance as weight\n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < stars.size(); i++) {\n            for (int j = i + 1; j < stars.size(); j++) {\n                double distance = Math.sqrt(Math.pow(stars.get(i).x - stars.get(j).x, 2)\n                                          + Math.pow(stars.get(i).y - stars.get(j).y, 2));\n                edges.add(new Edge(i, j, distance));\n            }\n        }\n\n        int n = stars.size();\n        double[] minDist = new double[n];\n        Arrays.fill(minDist, Double.MAX_VALUE);\n        minDist[0] = 0; // Start at Vega\n        \n        // Calculate minimal travel distance using Dijkstra's algorithm\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingDouble(a -> a.weight));\n        pq.add(new Edge(-1, 0, 0));\n        \n        boolean[] visited = new boolean[n];\n        while (!pq.isEmpty()) {\n            Edge e = pq.poll();\n            if (visited[e.to]) continue;\n            visited[e.to] = true;\n            for (Edge ne : edges) {\n                if (ne.from == e.to) {\n                    if (!visited[ne.to] && minDist[ne.to] > minDist[e.to] + ne.weight) {\n                        minDist[ne.to] = minDist[e.to] + ne.weight;\n                        pq.add(new Edge(ne.from, ne.to, minDist[ne.to]));\n                    }\n                }\n            }\n        }\n\n        // Output the minimal distance to Altair\n        System.out.println(minDist[3]);\n    }\n}",
    "timestamp": "2025-08-13 06:42:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define MAX_STARS 100\n\ntypedef struct {\n    int x, y;\n} Star;\n\nint n; // number of stars\nStar stars[MAX_STARS];\nint vega_index, altair_index;\n\n// Function to compute the squared Euclidean distance between two stars\ndouble distance(Star a, Star b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\ndouble minDistance(double dist[], bool visited[]) {\n    double min = INT_MAX;\n    int min_index;\n\n    for (int v = 0; v < n; v++) {\n        if (!visited[v] && dist[v] <= min) {\n            min = dist[v];\n            min_index = v;\n        }\n    }\n\n    return min_index;\n}\n\ndouble dijkstra() {\n    double dist[MAX_STARS];\n    bool visited[MAX_STARS] = {false};\n\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n    }\n\n    dist[vega_index] = 0;\n\n    for (int count = 0; count < n - 1; count++) {\n        int u = minDistance(dist, visited);\n        visited[u] = true;\n        \n        for (int v = 0; v < n; v++) {\n            double weight = distance(stars[u], stars[v]);\n            if (!visited[v] && dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n            }\n        }\n    }\n\n    return dist[altair_index];\n}\n\nint main() {\n    // Input number of stars\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &stars[i].x, &stars[i].y);\n    }\n    // Input indices for Vega and Altair\n    scanf(\"%d %d\", &vega_index, &altair_index);\n\n    double result = dijkstra();\n    printf(\"%.2f\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:42:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef find_shortest_path(stars, start, end):\n    n = len(stars)\n    graph = [[float('inf')] * n for _ in range(n)]\n    \n    # Build graph of star connections\n    for i in range(n):\n        for j in range(i+1, n):\n            graph[i][j] = graph[j][i] = distance(stars[i], stars[j])\n    \n    # Dijkstra's algorithm\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[start] = 0\n    \n    for _ in range(n):\n        min_dist = float('inf')\n        u = -1\n        \n        for i in range(n):\n            if not visited[i] and dist[i] < min_dist:\n                min_dist = dist[i]\n                u = i\n        \n        if u == -1:\n            break\n        \n        visited[u] = True\n        \n        for v in range(n):\n            if not visited[v] and graph[u][v] != float('inf'):\n                dist[v] = min(dist[v], dist[u] + graph[u][v])\n    \n    return dist[end]\n\ndef main():\n    # Input number of stars\n    n = int(input())\n    \n    # Input star coordinates\n    stars = []\n    for _ in range(n):\n        x, y = map(float, input().split())\n        stars.append((x, y))\n    \n    # Input start and end star indices\n    start, end = map(int, input().split())\n    \n    # Find and print shortest path\n    print(f\"{find_shortest_path(stars, start, end):.3f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:42:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nimport heapq\n\ndef distance(p1, p2):\n    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)\n\ndef get_pentacle_points(center, size):\n    points = []\n    for i in range(5):\n        angle = 2 * math.pi * i / 5 - math.pi / 2\n        x = center[0] + size * math.cos(angle)\n        y = center[1] + size * math.sin(angle)\n        points.append((x, y))\n    return points\n\ndef dijkstra(graph, start, end):\n    heap = [(0, start)]\n    visited = set()\n    dist = {point: float('inf') for point in graph}\n    dist[start] = 0\n    \n    while heap:\n        current_dist, current_point = heapq.heappop(heap)\n        if current_point in visited:\n            continue\n        if current_point == end:\n            return current_dist\n        visited.add(current_point)\n        for neighbor, weight in graph[current_point]:\n            if neighbor not in visited:\n                new_dist = current_dist + weight\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(heap, (new_dist, neighbor))\n    return float('inf')\n\ndef main():\n    vega = tuple(map(float, input().split()))\n    altair = tuple(map(float, input().split()))\n    n = int(input())\n    pentacles = []\n    for _ in range(n):\n        x, y, size = map(float, input().split())\n        pentacles.append((x, y, size))\n    \n    all_points = [vega, altair]\n    for center_x, center_y, size in pentacles:\n        pentacle_points = get_pentacle_points((center_x, center_y), size)\n        all_points.extend(pentacle_points)\n    \n    graph = {point: [] for point in all_points}\n    for i in range(len(all_points)):\n        for j in range(i + 1, len(all_points)):\n            p1 = all_points[i]\n            p2 = all_points[j]\n            d = distance(p1, p2)\n            graph[p1].append((p2, d))\n            graph[p2].append((p1, d))\n    \n    for center_x, center_y, size in pentacles:\n        pentacle_points = get_pentacle_points((center_x, center_y), size)\n        for i in range(5):\n            p1 = pentacle_points[i]\n            p2 = pentacle_points[(i + 2) % 5]\n            d = distance(p1, p2)\n            graph[p1].append((p2, 0))\n            graph[p2].append((p1, 0))\n    \n    min_distance = dijkstra(graph, vega, altair)\n    print(\"{0:.10f}\".format(min_distance))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:43:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble findShortestPath(vector<Point>& stars, int start, int destination) {\n    int n = stars.size();\n    vector<double> minDist(n, numeric_limits<double>::infinity());\n    vector<bool> visited(n, false);\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n\n    // Start from the Vega star\n    minDist[start] = 0.0;\n    pq.push({0.0, start});\n\n    while (!pq.empty()) {\n        double currentDist = pq.top().first;\n        int currentNode = pq.top().second;\n        pq.pop();\n\n        if (visited[currentNode]) continue;\n        visited[currentNode] = true;\n\n        if (currentNode == destination) break;\n\n        for (int i = 0; i < n; ++i) {\n            if (i != currentNode && !visited[i]) {\n                double edgeWeight = distance(stars[currentNode], stars[i]);\n                if (currentDist + edgeWeight < minDist[i]) {\n                    minDist[i] = currentDist + edgeWeight;\n                    pq.push({minDist[i], i});\n                }\n            }\n        }\n    }\n\n    return minDist[destination];\n}\n\nint main() {\n    vector<Point> stars = {\n        {0, 0},  // Vega\n        {1, 2},\n        {3, 4},\n        {5, 6},\n        {7, 8},  // Altair\n    };\n\n    int start = 0;  // Index of Vega\n    int destination = 4;  // Index of Altair\n\n    double shortestPath = findShortestPath(stars, start, destination);\n    cout << \"The minimal travel distance is: \" << shortestPath << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:33:44"
  }
]