[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nobject Main extends App {\n  import scala.io.StdIn._\n  loop()\n  @tailrec def loop(): Unit = {\n    readLine.trim.split(' ').map(_.toInt) match {\n      case Array(0, 0, 0) ⇒ return\n      case Array(n, m, l) ⇒\n        val stars = Array.fill(n){\n          readLine.trim.split(' ').map(_.toInt) match {\n            case Array(x, y, a, r) ⇒ Star(x, y, a, r)\n            case _ ⇒ ???\n          }\n        }\n        val minDistance = Array.fill(n){Double.MaxValue}\n        minDistance(m - 1) = 0\n        val queue = mutable.PriorityQueue[(Int, Double)]((m - 1, 0.0))(Ordering.by[(Int, Double), Double](_._2).reverse)\n        while (queue.nonEmpty && queue.head._1 != l - 1) {\n          val (current, distance) = queue.dequeue()\n          if (minDistance(current) == distance) {\n            for (i ← stars.indices if current != i) {\n              val d = stars(current).minDistance(stars(i))\n              if (minDistance(i) > d + distance) {\n                minDistance(i) = d + distance\n                queue.enqueue((i, d + distance))\n              }\n            }\n          }\n        }\n        println(f\"${minDistance(l - 1)}%.15f\")\n        loop()\n      case _ ⇒ ???\n    }\n  }\n}\ncase class Coordinate(x: Double, y: Double) {\n  def -(that: Coordinate): Vector = Vector(x - that.x, y - that.y)\n  def :+(that: Vector): Coordinate = Coordinate(x + that.x, y + that.y)\n  def +:(that: Vector): Coordinate = this :+ that\n  def distance(that: Coordinate): Double = (this - that).length\n}\ncase class Vector(x: Double, y: Double) {\n  def length: Double = math.sqrt(x * x + y * y)\n  def dot(that: Vector): Double = x * that.x + y * that.y\n  def cross(that: Vector): Double = x * that.y - y * that.x\n}\ncase class Angle(sin: Double, cos: Double) {\n  def +(that: Angle): Angle = Angle(sin * that.cos + cos * that.sin, cos * that.cos - sin * that.sin)\n  def -(that: Angle): Angle = Angle(sin * that.cos - cos * that.sin, cos * that.cos + sin * that.sin)\n}\nobject Angle {\n  val angle72: Angle = Angle(math.sqrt(10 + 2 * math.sqrt(5)) / 4, (math.sqrt(5) - 1) / 4)\n  def fromDegree(degree: Int): Angle = {\n    val rad = degree * math.Pi / 180\n    Angle(math.sin(rad), math.cos(rad))\n  }\n}\ncase class Segment(a: Coordinate, b: Coordinate) {\n  def isCross(that: Segment): Boolean = {\n    val vec = a - b\n    val vec2 = that.a - that.b\n    math.signum(vec.cross(that.a - b)) * math.signum(vec.cross(that.b - b)) <= 0 && math.signum(vec2.cross(a - that.b)) * math.signum(vec2.cross(b - that.b)) <= 0\n  }\n  def distance(that: Coordinate): Double = {\n    val vec = a - b\n    if (vec.dot(that - b) >= 0 && vec.dot(a - that) >= 0) math.abs(vec.y * that.x - vec.x * that.y + a.x * b.y - a.y * b.x) / vec.length\n    else math.min(a.distance(that), b.distance(that))\n  }\n  def distance(that: Segment): Double = {\n    if (isCross(that)) 0\n    else math.min(math.min(distance(that.a), distance(that.b)), math.min(that.distance(a), that.distance(b)))\n  }\n}\n\nclass Star(private val segments: List[Segment]) {\n  def minDistance(that: Star): Double = segments.flatMap(s ⇒ that.segments.map(_.distance(s))).min\n}\nobject Star {\n  def apply(x: Int, y: Int, a: Int, r: Int): Star = {\n    val angle = Angle.fromDegree(a) + Angle(1, 0)\n    val vertex = (0 until 5).scanLeft(angle){case (a, _) ⇒ a + Angle.angle72}.map{angle ⇒ Coordinate(x + r * angle.cos, y + r * angle.sin)}\n    new Star((0 until 5).map(i ⇒ Segment(vertex(i), vertex((i + 2) % 5))).toList)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\n \nconst double INF=1e77;\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n \ntemplate<class T>\nstruct point{\n    T x,y;\n    point operator+(const point &a)const{ point t = {x+a.x,y+a.y}; return t; }\n    point operator-(const point &a)const{ point t = {x-a.x,y-a.y}; return t; }\n};\n \ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){\n    return (point<T> p = {c*a.x,c*a.y});\n}\n \npoint<double> rot(const point<double> &a,double theta){\n\tpoint<double> p = {a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)};\n\treturn p;\n}\n \ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n};\n \nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n \ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n \ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n \nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW;\n    if(rdir<-EPS) return CW;\n    return ON;\n}\n \nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n \ntemplate<class T>\nT dist2(const point<T> &a,const point<T> &b){\n    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n \ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n \ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n \nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        m--;\n        l--;\n \n        star S[100];\n        rep(i,n){\n            scanf(\"%lf%lf%lf%lf\",&S[i].c.x,&S[i].c.y,&S[i].a,&S[i].r);\n        }\n \n        rep(i,n){\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            rep(j,5) S[i].p[j]=S[i].p[j]+S[i].c;\n        }\n \n        int f1[5]={0,2,4,1,3};\n        int f2[5]={2,4,1,3,0};\n \n        double d[100][100];\n        rep(i,n){\n\t\t\trep(j,n) {\n            d[i][j]=INF;\n            rep(a,5) rep(b,5){\n\t\t\t\tsegment<double> s = {S[i].p[f1[a]],S[i].p[f2[a]]};\n\t\t\t\tsegment<double> t = {S[j].p[f1[b]],S[j].p[f2[b]]};\n\t\t\t\td[i][j]=min(d[i][j],dist(s,t));\n\t\t\t}\n\t\t\t}\n        }\n \n        rep(k,n) rep(i,n) rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n \n        printf(\"%.15f\\n\",d[m][l]);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        star S[100];\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf%lf%lf%lf\",&S[i].c.x,&S[i].c.y,&S[i].a,&S[i].r);\n        }\n   \n        for(int i = 0; i < n; i++){\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            for(int j = 0; j < 5; j++) S[i].p[j]=S[i].p[j]+S[i].c;\n        }\n\n\t\tP pt[100][5];\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < 5; j++){\n\t\t\t\tpt[i][j] = S[i].p[j];\n            }\n        }\n\n   \n        int f1[]={0,2,4,1,3,0};\n   \n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    segment<double> s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    segment<double> t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// *template\n\n#include <algorithm>\n#include <array>\n#include <climits>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\n// *define class\n\ntypedef double Real;\nconstexpr Real EPS = 1e-8;\nconst Real PI = acos((Real)-1.0);\nint sign(Real d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\nstruct Point {\n\tReal x, y;\n\tPoint(Real x_ = 0, Real y_ = 0):x(x_), y(y_) {}\n\tinline Point operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tinline Point operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tinline Point operator*(Real s) const { return Point(x * s, y * s); }\n\tinline Point operator/(Real s) const { return Point(x / s, y / s); }\n\tinline bool operator<(const Point &p) const { return sign(x - p.x) == -1 || (sign(x - p.x) == 0 && sign(y - p.y) == -1); }\n\tinline bool operator==(const Point &p) const { return sign(x - p.x) == 0 && sign(y - p.y) == 0; }\n};\n\ninline istream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\ninline ostream &operator<<(ostream &os, const Point &p) {\n\treturn os << '(' << p.x << \", \" << p.y << ')';\n}\n\nstruct Line : public array<Point, 2> {\n\tLine(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Segment : public array<Point, 2> {\n\tSegment() {}\n\tSegment(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Circle {\n\tPoint c;\n\tReal r;\n\tCircle(const Point &c_, Real r_):c(c_), r(r_) {}\n};\n\ntypedef vector<Point> Polygon;\n\n// *define base function\n\ninline Point rotate90(const Point &p) {\n\treturn Point(-p.y, p.x);\n}\n\ninline Point rotate(const Point &p, Real theta) {\n\tconst Real s = sin(theta), c = cos(theta);\n\treturn Point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline Real angle(const Point &p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline Real norm(const Point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline Real abs(const Point &p) {\n\treturn sqrt(norm(p));\n}\n\ninline Real dot(const Point &a, const Point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ninline Real cross(const Point &a, const Point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// *define app function\n\nenum { CCW = 1, CW = -1, BACK = 2, FRONT = -2, ON = 0};\ninline int ccw(const Point &a, const Point &b, const Point &c) { // a:p0, b:p1, c:p2\n\tconst Point p = b - a;\n\tconst Point q = c - a;\n\tconst int sign_cross = sign(cross(p, q));\n\n\tif(sign_cross == 1) return CCW;\n\tif(sign_cross == -1) return CW;\n\tif(sign(dot(p, q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\ninline Point project(const Line &l, const Point &p) {\n\tconst Point a = p - l[0];\n\tconst Point b = l[1] - l[0];\n\treturn l[0] + b * (dot(a, b) / norm(b));\n}\n\ninline Point reflect(const Line &l, const Point &p) {\n\tconst Point t = project(l, p);\n\treturn t + (t - p);\n}\n\ninline bool intersect(const Segment &s, const Point &p) {\n\treturn ccw(s[0], s[1], p) == ON;\n}\n\ninline bool intersect(const Segment &a, const Segment &b) {\n\treturn ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0\n\t\t&& ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\n\ninline bool intersect(const Line &l, const Point &p) {\n\treturn abs(ccw(l[0], l[1], p)) != 1;\n}\n\ninline bool intersect(const Line &l, const Segment &s) {\n\treturn sign(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0])) <= 0;\n}\n\ninline bool intersect(const Line &a, const Line &b) {\n\treturn sign(cross(a[1] - a[0], b[1] - b[0])) != 0\n\t\t|| sign(cross(a[1] - a[0], b[1] - a[0])) == 0;\n}\n\ninline Real dist(const Point &a, const Point &b) {\n\treturn abs(a - b);\n}\n\ninline Real dist(const Line &l, const Point &p) {\n\tconst Point a = l[1] - l[0];\n\tconst Point b = p - l[0];\n\treturn abs(cross(a, b)) / abs(a);\n}\n\ninline Real dist(const Line &l, const Segment &s) {\n\tif(intersect(l, s)) return 0;\n\treturn min(dist(l, s[0]), dist(l, s[1]));\n}\n\ninline Real dist(const Line &a, const Line &b) {\n\tif(intersect(a, b)) return 0;\n\treturn dist(a, b[0]);\n}\n\ninline Real dist(const Segment &s, const Point &p) {\n\tif(sign(dot(s[1] - s[0], p - s[0])) == -1) return dist(s[0], p);\n\tif(sign(dot(s[0] - s[1], p - s[1])) == -1) return dist(s[1], p);\n\treturn dist(Line(s[0], s[1]), p);\n}\n\ninline Real dist(const Segment &a, const Segment &b) {\n\tif(intersect(a, b)) return 0;\n\treturn min({dist(a, b[0]), dist(a, b[1]), dist(b, a[0]), dist(b, a[1])});\n}\n\n// *solve\n\ntypedef array<Segment, 5> Star;\n\nReal dist(const Star &a, const Star &b) {\n\tReal res = INT_MAX;\n\tfor(const auto &s1 : a) {\n\t\tfor(const auto &s2 : b) {\n\t\t\tchmin(res, dist(s1, s2));\n\t\t}\n\t}\n\treturn res;\n}\n\nReal dijkstra(int s, int g, const vector<vector<Real>> &mat) {\n\tconst int n = mat.size();\n\tvector<Real> dist(n, INT_MAX);\n\tvector<bool> used(n, false);\n\tdist[s] = 0;\n\n\twhile(true) {\n\t\tint v = -1;\n\t\tfor(int u = 0; u < n; ++u) {\n\t\t\tif(!used[u] && (v == -1 || dist[v] > dist[u])) v = u;\n\t\t}\n\n\t\tif(v == g) return dist[v];\n\t\tused[v] = true;\n\n\t\tfor(int u = 0; u < n; ++u) {\n\t\t\tchmin(dist[u], dist[v] + mat[v][u]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\n\tconstexpr int N = 5;\n\tarray<Point, N> points;\n\tStar buf;\n\n\tfor(int n, m, l; cin >> n >> m >> l && n;) {\n\t\tvector<Star> stars;\n\t\tstars.reserve(n);\n\n\t\tfor(int _ = 0; _ < n; ++_) {\n\t\t\tPoint c;\n\t\t\tint a, r;\n\t\t\tcin >> c >> a >> r;\n\n\t\t\tconst Point p(0, r);\n\t\t\tfor(int i = 0; i < N; ++i) {\n\t\t\t\tconst Real theta = (a + 72 * i) * (PI / 180.0);\n\t\t\t\tpoints[i] = rotate(p, theta) + c;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < N; ++i) {\n\t\t\t\tbuf[i] = Segment(points[i], points[(i + 2) % N]);\n\t\t\t}\n\n\t\t\tstars.emplace_back(buf);\n\t\t}\n\n\t\tvector<vector<Real>> mat(n, vector<Real>(n));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tmat[i][j] = mat[j][i] = dist(stars[i], stars[j]);\n\t\t\t}\n\t\t}\n\t\tcout << dijkstra(m - 1, l - 1, mat) << '\\n';\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\nconst int INF = 1001001001;\ntypedef complex<double> P;\n\ndouble cross(const P &a, const P &b)\n{\n    return imag(conj(a) * b);\n}\ndouble dot(const P &a, const P &b)\n{\n    return real(conj(a) * b);\n}\n\nstruct L : public vector<P>\n{\n    L(){}\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\nint ccw(P a, P b, P c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)     return 1;   // counter clockwise\n    if(cross(b, c) < 0)     return -1;  // clockwise\n    if(dot(b,c) < 0)        return 2;   // c-a-b on line\n    if(norm(b) < norm(c))   return -2;  // a-b-c on line\n    return 0;                           // a-c-b on line\n}\n\nbool intersectSP(const L &l, const P &p)\n{\n    return abs(l[0]-p) + abs(l[1]-p) - abs(l[1]-l[0]) < EPS;\n}\n\nbool intersect(const L& s, const L& t)\n{\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n                                \ndouble dstcSP(const L& l, const P& p)\n{\n    const P r = projection(l, p);\n    if(intersectSP(l, r)) return abs(r - p);\n    return min(abs(l[0] - p), abs(l[1] - p));\n}\n\ndouble dstc(const L &s, const L &t)\n{\n    if(intersect(s, t)) return 0;\n    return min(min(dstcSP(s, t[0]), dstcSP(s, t[1])),\n               min(dstcSP(t, s[0]), dstcSP(t, s[1])));\n}\n\nconst int con[][2] = { {0,2}, {0,3}, {1,3}, {1,4}, {2,4} };\ntypedef pair<double, int> DI;\n\nint main()\n{\n    int N, M, LL;\n    double x, y, a, r;\n    double d[550];\n    P point[550];\n    L line[550];\n    \n    while(cin >> N >> M >> LL && N)\n    {\n        rep(i, N)\n        {\n            cin >> x >> y >> a >> r;\n            rep(j, 5) {\n                point[i*5+j]\n                = P(x + r * cos(a*PI/180 + j*PI*2/5 + PI/2),\n                    y + r * sin(a*PI/180 + j*PI*2/5 + PI/2));\n            }\n            rep(j, 5) {\n                line[i*5+j] = L(point[i*5+con[j][0]], point[i*5+con[j][1]]);\n            }\n        }\n        --M; --LL;\n        \n        priority_queue<DI, vector<DI>, greater<DI> > que;\n        fill_n(d, 550, INF);\n        d[M*5] = 0;\n        que.push(DI(0, M*5));\n        \n        while(true)\n        {\n            DI p = que.top(); que.pop();\n            int cur = p.second;\n            if(cur/5 == LL) {\n                cout << setprecision(15) << p.first << endl;\n                break;\n            }\n            if(d[cur] < p.first) continue;\n            rep(i, 5*N) if(i != cur) {\n                if(d[i] > d[cur] + dstc(line[cur], line[i])) {\n                    d[i] = d[cur] + dstc(line[cur], line[i]);\n                    que.push(DI(d[i], i));\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-8\n#define equal(a,b) (fabs(a-b) < EPS)\n#define PI M_PI\n#define MAX_N 100\n#define INF 1e9\n \nclass Point{\npublic:\n    double x,y;\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n \nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n \nclass Segment{\npublic:\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n \nclass Star : public Point{\npublic:\n    double a,r;\n    vector<Segment> segs;\n    Star(){}\n    Star(Point p,double a,double r) : Point(p),a(a),r(r) {}\n};\n \nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n \nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n \nbool isIntersectSP(const Segment &s,const Point &p){\n    return equal(ccw(s.s,s.t,p),0);\n}\n \ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)){ return abs(r-p); }\n    return min(abs(s.s-p),abs(s.t-p));\n}\n \ndouble distanceSS(const Segment a,const Segment b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n\t       min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n \nistream &operator >> (istream &is,Star &s){\n    return is >> s.x >> s.y >> s.a >> s.r;\n}\n \ndouble toRad(double ang){ return ang*PI/180.0; }\n \nPoint rotate(const Point &bp,const Point &p,double th){\n    double x = p.x, y = p.y;\n    return Point(cos(th)*x-sin(th)*y+bp.x,sin(th)*x+cos(th)*y+bp.y);\n}\n \nvoid makeStar(vector<Star> &stars){\n    int N = stars.size();\n    for(int i = 0 ; i < N ; i++){\n\tdouble x = stars[i].x, y = stars[i].y;\n\tdouble r = stars[i].r, a = stars[i].a;\n\tPoint bp(x,y), p(x,y+r);\n\tp = p - bp;\n\tp = rotate(bp,p,toRad(a));\n\tvector<Point> ps(5);\n\tfor(int j = 0 ; j < 5 ; j++){\n\t    ps[j] = p;\n\t    p = p - bp;\n\t    p = rotate(bp,p,toRad(72));\n\t}\n\tstars[i].segs.resize(5);\n\tfor(int j = 0 ; j < 5 ; j++){\n\t    stars[i].segs[j] = Segment(ps[j],ps[(j+2)%5]);\n\t}\n    }\n}\n \nint main(){\n    int N,M,L;\n    while(cin >> N >> M >> L, N){\n\tvector<Star> stars(N);\n\tM--; L--;\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> stars[i];\n\t}\n\tmakeStar(stars);\n\tdouble d[MAX_N][MAX_N];\n\tfill(d[0],d[0]+N*N,INF);\n\tfor(int i = 0 ; i < N ; i++){\n\t    d[i][i] = 0;\n\t    for(int j = i+1 ; j < N ; j++){\n\t\tdouble dist = INF;\n\t\tfor(int k = 0 ; k < 5 ; k++){\n\t\t    for(int l = 0 ; l < 5 ; l++){\n\t\t\tSegment s1 = stars[i].segs[k];\n\t\t\tSegment s2 = stars[j].segs[l];\n\t\t\tdist = min(dist,distanceSS(s1,s2));\n\t\t    }\n\t\t}\n\t\td[i][j] = d[j][i] = dist;\n\t    }\n\t}\n\tfor(int k = 0 ; k < N ; k++){\n\t    for(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t}\n\t    }\n\t}\n\tprintf(\"%.10f\\n\",d[M][L]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing  ld = long double;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(15);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_ss(Line(seg[i][ii], seg[i][(ii + 1) % 10]), Line(seg[j][jj], seg[j][(jj + 1) % 10])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return norm(outp(dir(), p - at(0))) / norm(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return norm(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return norm(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t//\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<cmath>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define pb(a) push_back(a)\nconst double EPS = 1e-8;\nusing namespace std;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a,const P& b){\n\t\treturn real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n\t}\n}\ndouble cr(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\t\ndouble dt(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\nstruct L : public vector<P>{\n\tL(const P &a,const P& b){\n\t\tpb(a);pb(b);\n\t}\n};\ntypedef vector<P> G;\n\nstruct C{\n\tP p;double r;\n\tC(const P &p,double r) : p(p),r(r){}\n};\n\nint ccw(P a,P b,P c){\n\tb -= a;\n\tc -= a;\n\tif(cr(b,c) > EPS)return 1;\n\tif(cr(b,c)<-EPS)return -1;\n\tif(dt(b,c)<-EPS)return 2;\n\tif(norm(b)<norm(c) -EPS)return -2;\n\treturn 0;\n}\nP pro(const L &l,const P &p){\n\tdouble t=dt(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\n\nbool itSP(const L &s, const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[0]-s[1]) < EPS;\n}\n\nbool itSS(const L &s, const L &t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ndouble dstSP(const L &s,const P &p){\n\tconst P r = pro(s,p);\n\tif(itSP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble dstSS(const L &s,const L &t){\n\tif(itSS(s,t))return 0;\n\treturn min(min(dstSP(s,t[0]),dstSP(s,t[1])),min(dstSP(t,s[0]),dstSP(t,s[1])));\n}\n#define rep(i,j) for(int i=0;i<j;i++)\nvector<L> hoge(int x,int y,int r,int th_){\n\tdouble th=th_*1.*2*M_PI/360+M_PI/2;\n\tvector<P> ps(5);\n\trep(i,5){\n\t\tdouble a=th+i*2*M_PI/5;\n\t\tps[i].real()=x+r*cos(a);\n\t\tps[i].imag()=y+r*sin(a);\n\t}\n\tvector<L> re;\n\trep(i,5){\n\t\tre.pb(L(ps[i],ps[(i+2)%5]));\n\t}\n\treturn re;\n}\nint main(){\n\tint n,m,l;\n\twhile(cin >> n >> m >> l&&n){\n\tvector<vector<L> > st;\n\trep(i,n){\n\t\tint x,y,a,r;\n\t\tcin >> x >> y >> a >> r;\n\t\tst.pb(hoge(x,y,r,a));\n\t}\n\tdouble dst[100][100];\n\tfill_n(dst[0],sizeof(dst)/sizeof(double),INF);\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tdouble d = INF;\n\t\t\tvector<L> t = st[i];\n\t\t\tvector<L> u = st[j];\n\t\t\trep(k,5){\n\t\t\t\trep(kk,5){\n\t\t\t\t\t//cout <<\"dst \"<< dstSS(t[k],u[kk]) << endl;\n\t\t\t\t\td = min(dstSS(t[k],u[kk]),d);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\tdst[i][j]=d;\n\t\t}\n\t}\n\trep(k,n)rep(i,n)rep(j,n){\n\t\tdst[i][j] = min(dst[i][j],dst[i][k]+dst[k][j]);\n\t}\n\tcout <<fixed << setprecision(10)<< dst[m-1][l-1] << endl;\n\t}\n\t//vector<L> tt = hoge(5,5,5,0);\n\t\t\n\t//rep(i,5) cout << tt[i][0].real() << \",\" <<tt[i][0].imag() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nstruct star {\n\tdouble x;\n\tdouble y;\n\tdouble a;\n\tdouble r;\n};\n\n\nint main() {\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tm--;\n\t\tl--;\n\t\tvector<vector<pair<double, double>>> point(n, vector<pair<double, double>>(5));\n\t\tREP(i, n) {\n\t\t\tdouble x;\n\t\t\tdouble y;\n\t\t\tdouble a;\n\t\t\tdouble r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tREP(j, 5) {\n\t\t\t\tpoint[i][j].first = x + cos((a + (double)j*72.0 + 90.0) / 360.0*M_PI*2.0)*r;\n\t\t\t\tpoint[i][j].second = y + sin((a + (double)j*72.0 + 90.0) / 360.0*M_PI*2.0)*r;\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> vvd(n, vector<double>(n, 1e9));\n\t\tREP(i, n - 1)\n\t\t\tFOR(j, i + 1, n)\n\t\t\t\tREP(k, 5)\n\t\t\tREP(o, 5) {\n\t\t\tvvd[i][j] = min(vvd[i][j], hypot(point[i][k].first - point[j][o].first, point[i][k].second - point[j][o].second));\n\t\t\tvvd[j][i] = vvd[i][j];\n\t\t}\n\t\tpriority_queue<pair<double,int>> Q;\n\t\tvector<double> dpmin(n);\n\t\tREP(i, n)\n\t\t\tdpmin[i] = -1e9;\n\t\tdpmin[m] = 0.0;\n\t\tQ.push({0.0,m});\n\t\tdouble ans;\n\t\twhile (!Q.empty()) {\n\t\t\tpair<double, int> q = Q.top();\n\t\t\tQ.pop();\n\t\t\tif (q.second == l) {\n\t\t\t\tans = -q.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, n) {\n\t\t\t\tint now = q.second;\n\t\t\t\tif (now == i)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dpmin[i]<q.first-vvd[now][i]) {\n\t\t\t\t\tdpmin[i] = q.first - vvd[now][i];\n\t\t\t\t\tQ.push({ q.first - vvd[now][i],i});\n\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%0.7lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\n#include <complex>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n\n#define INF (1<<29)\n\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\ntypedef complex<double> Point;\n\nstruct Line {\n  Point pos,dir; // position, direction\n  Line(){}\n  Line(const Point& pos, const Point& dir){\n    this->pos = pos; this->dir = dir;\n  }\n};\n\ndouble convertD2R(double deg){\n  return (deg * PI) / 180.0;\n}\n\ndouble dot(const Point& a, const Point& b){\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(const Point& a, const Point& b){\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint ccw(Point a, Point b, Point c){\n  b -= a; c -= a;\n  if(cross(b,c) > 0) return +1;    // counter clock wise\n  if(cross(b,c) < 0) return -1;    // clock wise\n  if(dot(b,c) < 0) return +2;      // c--a--b\n  if(norm(b) < norm(c)) return -2; // a--b--c\n  return 0;                        // a--c--b || b == c\n}\n\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l.pos, l.pos - l.dir) / norm(l.pos - l.dir);\n  return l.pos + t * (l.pos - l.dir);\n}\n\nbool intersectSP(const Line& s, const Point& p){\n  return (abs(s.pos - p) + abs(s.dir - p) - abs(s.dir - s.pos) < EPS);\n}\n\nbool intersectSS(const Line& a, const Line& b){\n  return (ccw(a.pos,a.dir,b.pos) * ccw(a.pos,a.dir,b.dir) <= 0 && ccw(b.pos,b.dir,a.pos) * ccw(b.pos,b.dir,a.dir) <= 0);\n}\n\ndouble distanceSP(const Line& s, const Point& p){\n  Point r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r - p);\n  return min(abs(s.pos - p), abs(s.dir - p));\n}\n\ndouble distanceSS(const Line& a, const Line& b){\n  if(intersectSS(a,b)) return 0;\n  return min(min(distanceSP(a,b.pos), distanceSP(a,b.dir)), min(distanceSP(b,a.pos), distanceSP(b,a.dir)));\n}\n\nstruct Star {\n  Line s[5]; // segment\n\n  Star(){}\n  Star(double x, double y, double a, double r){\n    int i;\n    REP(i,5){\n      double theta1 = convertD2R(a) + i * 2*PI/5.0 + PI/2.0; // a + 72 + 90\n      double theta2 = convertD2R(a) + (i+2) * 2*PI/5.0 + PI/2.0; // a + 72 + 90\n      s[i] = (Line){ polar(r,theta1) + Point(x,y), polar(r,theta2) + Point(x,y) };\n    }\n  }\n};\n\nint V; // vertex\nStar star[110]; // x,y,a,r\n\npriority_queue< pair<double,int> > q;\nbool used[110];\ndouble dist[110];\n\nvoid add(int x, double d){\n  if(d < dist[x]){\n    dist[x] = d;\n    q.push(make_pair(-d,x));\n  }\n}\n\nvoid dijkstra(int start){\n  int next,i,j;\n\n  REP(i,V) used[i] = false;\n  REP(i,V) dist[i] = INF;\n  add(start,0.0);\n\n  while(!q.empty()){\n    double d = -q.top().first; int now = q.top().second; q.pop();\n    if(used[now]) continue;\n    used[now] = true;\n    REP(next,V) if(now != next){\n      double d2 = INF;\n      REP(i,5) REP(j,5) d2 = min(d2, distanceSS(star[now].s[i],star[next].s[j]));\n      add(next, d+d2);\n    }\n  }\n}\n\nint main(){\n  int start,goal,i;\n\n  while(1){\n    cin >> V >> start >> goal;\n    if(V == 0 && start == 0 && goal == 0) break;\n    start--; goal--;\n\n    REP(i,V){\n      double x,y,a,r;\n      cin >> x >> y >> a >> r;\n      star[i] = Star(x,y,a,r);\n    }\n\n    dijkstra(start);\n    printf(\"%.17lf\\n\",dist[goal]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-11;\n\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n           (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n    if(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n    return dist_line_and_point(a1,a2,b);\n}\n\nostream& operator<<(ostream& os,point a){\n    os << \"(\" << a.real() << \",\" << a.imag() << \")\";\n    return os;\n}\n\ndouble dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){\n    if(is_intersected_linesegment(a1,a2,b1,b2)){\n        return 0;\n    }\n    return min(min(dist_linesegment_and_point(a1,a2,b1),\n                   dist_linesegment_and_point(a1,a2,b2)),\n               min(dist_linesegment_and_point(b1,b2,a1),\n                   dist_linesegment_and_point(b1,b2,a2)));\n}\n\nstruct Star{\n    point p;\n    double a;\n    double r;\n    vector<point> ps;\n    Star(double x,double y,double a,double r) : p(x,y),a(a),r(r) {\n        for(int i=0;i<5;i++){\n            ps.push_back(p+polar(r,M_PI * (0.4*i + 0.1 + (a / 180))));\n        }\n    }\n};\n\nconst double INF = 1e14;\ndouble dist_stars(Star a,Star b){\n    double ret = INF;\n    for(int i=0;i<5;i++){\n        for(int j=2;j<=3;j++){\n            for(int k=0;k<5;k++){\n                for(int l=2;l<=3;l++){\n                    ret = min(ret,dist_linesegment_and_linesegment(a.ps[i],a.ps[(i+j)%5],\n                                                                   b.ps[k],b.ps[(k+l)%5]));\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cout << fixed << setprecision(8);\n    while(true){\n        int N,M,L;\n        cin >> N >> M >> L;\n        if(N == 0 and M == 0 and L == 0) break;\n        M--;L--;\n        vector<Star> stars;\n        vector<vector<double> > dist(N,vector<double>(N,INF));\n\n        for(int i=0;i<N;i++){\n            double x,y,a,r;\n            cin >> x >> y >> a >> r;\n            stars.push_back(Star(x,y,a,r));\n        }\n\n        for(int i=0;i<N;i++){\n            for(int j=i;j<N;j++){\n                dist[i][j] = dist[j][i] = dist_stars(stars[i],stars[j]);\n            }\n        }\n        for(int i=0;i<N;i++){\n            dist[i][i] = 0;\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        cout << dist[M][L] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-8;\nconst double inf=1e12;\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nP reflection(const L& l,const P& p){\n  return p+2.0*(projection(l,p)-p);\n}\nP rotation(const P& a,double r){\n  return P(x(a)*cos(r)-y(a)*sin(r),x(a)*sin(r)+y(a)*cos(r));\n}\n\n//// counter-clockwise\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L& l,const L& m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps;\n}\nbool intersectSS(const L& s,const L& t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\ndouble distanceSP(const L& s,const P& p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L& s,const L& t) {\n  return intersectSS(s,t)?0:min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n                                min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\n\nP ps[111][5];\ndouble dist[111][111];\nconst double PI=acos(-1);\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int n,m,l;\n    cin>>n>>m>>l;\n    l--;m--;\n    if(n==0)break;\n    rep(i,n){\n      double x,y,a,r;\n      cin>>x>>y>>a>>r;\n      P cent(x,y),p0(0,r);\n      rep(j,5){\n        ps[i][j]=rotation(p0,(((a+(double)j*72.0)/180.0)*PI))+cent;\n      }\n    }\n    rep(i,n)rep(j,n)dist[i][j]=i==j?0:inf;\n    rep(i,n)rep(j,n)rep(id,5)rep(jd,5){\n      if(i==j)continue;\n      minch(dist[i][j],distanceSS(L(ps[i][id],ps[i][(id+2)%5]),L(ps[j][jd],ps[j][(jd+2)%5])));\n    }\n    rep(k,n)rep(i,n)rep(j,n)minch(dist[i][j],dist[i][k]+dist[k][j]);\n    printf(\"%.20f\\n\", dist[l][m]);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tP pt[100][5];\n        for(int i = 0; i < n; i++){\n\t\t\tdouble x,y,a,r;\n            cin>>x>>y>>a>>r;\n            pt[i][0].x = 0, pt[i][0].y = r;\n            pt[i][0]=rot(pt[i][0],a/180*PI);\n            for(int j=1;j<5;j++){\n                pt[i][j]=rot(pt[i][j-1],2*PI/5);\n            }\n            for(int j = 0; j < 5; j++) pt[i][j] += P(x,y);\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    S s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    S t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <complex>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef complex<double> P;\n#define INF (1e100)\n#define EPS (1e-10)\nconst double pi = atan2(0.0, -1.0);\n\nP unit(double t) { return P(cos(t), sin(t)); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if (cross(b, c) > 0) return 1;\n    if (cross(b, c) < 0) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersectSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    return ccw(s0, s1, t0) * ccw(s0, s1, t1) <= 0\n        && ccw(t0, t1, s0) * ccw(t0, t1, s1) <= 0;\n}\nbool intersectSP(const P& s0, const P& s1, const P& p) {\n    return abs(s0-p) + abs(s1-p) - abs(s1-s0) < EPS;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    const double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r = projection(s0, s1, p);\n    if (intersectSP(s0, s1, r)) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if (intersectSS(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint N, M, L;\nP ps[128][8];\ndouble xs[128], ys[128], as[128], rs[128];\ndouble g[128][128], dp[128];\nint vis[128];\n\ndouble solve() {\n    rep (i, N) dp[i] = INF;\n    rep (i, N) vis[i] = 0;\n    dp[M] = 0;\n    rep (i, N) {\n        int at = 0;\n        rep (i, N) if (vis[i] == 0 && dp[i] < dp[at]) at = i;\n        vis[at] = 1;\n        rep (i, N) if (vis[i] == 0) dp[i] = min(dp[i], dp[at] + g[at][i]);\n    }\n    return dp[L];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &N, &M, &L);\n        if (N == 0) return 0;\n        M--, L--;\n        rep (i, N) scanf(\"%lf%lf%lf%lf\", xs+i, ys+i, as+i, rs+i);\n        rep (i, N) rep (k, 5) {\n            const double t = (as[i]+90+k*144) * pi / 180.0;\n            ps[i][k] = P(xs[i], ys[i]) + rs[i] * unit(t);\n        }\n        rep (i, N) rep (j, N) {\n            g[i][j] = INF;\n            rep (a, 5) rep (b, 5) {\n                const double d = distanceSS(ps[i][a], ps[i][(a+1)%5],\n                                            ps[j][b], ps[j][(b+1)%5]);\n                g[i][j] = min(g[i][j], d);\n            }\n        }\n        printf(\"%.9f\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <numeric>\n#include <string>\n#include <iterator>\n#include <sstream>\n#include <map>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\n\nint N,M,L;\n\ntypedef complex<double> P;\n\nP pt[101][5];\ndouble dp[101][101];\n\nconst double pi = 3.1415926535897932384626;\n\ndouble cross(P x, P y){\n\treturn x.real() * y.imag() - x.imag() * y.real();\n}\n\ndouble dot(P x, P y){\n\treturn x.real() * y.real() + x.imag() * y.imag();\n}\n\nbool intersep(P l1,P l2,P r1, P r2){\n\tif(cross(l2 - l1,r1 - l1) * cross(l2 - l1,r2 - l1) < 0){\n\t\tif(cross(r2 - r1,l1 - r1) * cross(r2 - r1, l2 - r1) < 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\ndouble get_len(P p, P l1, P l2){\n\tif(dot(p-l1,l2-l1) <= 0) return abs(p - l1);\n\tif(dot(p-l2,l1-l2) <= 0) return abs(p - l2);\n\tdouble cr = cross(p-l1,l2-l1);\n\treturn (abs(cr) / abs(l2-l1));\n}\n\ndouble get_min(int m,int n){\n\tif(m==n) return 0;\n\tdouble mn = INT_MAX;\n\tfor (int i = 0; i < 5; i++){\n\t\tfor (int j = 0; j < 5; j++){\n\t\t\tif(intersep(pt[m][i],pt[m][(i + 2)% 5], pt[n][j], pt[n][(j + 2) % 5])){\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\tmn = min(mn,get_len(pt[n][j],pt[m][i],pt[m][(i + 2)% 5]));\n\t\t\tmn = min(mn,get_len(pt[m][i],pt[n][j], pt[n][(j + 2) % 5]));\n\t\t}\n\t}\n\treturn mn;\n}\n\nint main()\n{\n\twhile(cin>>N>>M>>L,(N||M||L)){\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tdouble x,y,a,r;cin>>x>>y>>a>>r;\n\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\tdouble alpha = (18 + a + 72 * j)/ 180.0 * pi;\n\t\t\t\tdouble s = sin(alpha);\n\t\t\t\tdouble c = cos(alpha);\n\t\t\t\tP add = P(r,0.0) * P(c,s);\n\t\t\t\tpt[i][j] = P(x,y) + add;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tdp[i][j] = get_min(i,j);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tfor (int k = 0; k < N; k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.20lf\\n\",dp[M - 1][L - 1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( complex<double> a, complex<double> b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(complex<double> p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distancion(L,L); //線分:線分の距離(iteratorのdistanceと被るから留意)\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\n\nstruct edge{\n  int to;\n  double cost;\n  edge( int to, double cost):to(to),cost(cost){};\n};\nvector< vector< edge > > info;\n\nLLL comb( int x, int y, int a, int r){\n  G hosi(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  LLL ls(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    ls[i] = L( hosi[i * 2 % 5], hosi[(i + 1) * 2 % 5]);\n  }\n  return ls;\n}\ndouble dist( LLL a, LLL b){\n  double ret = INF;\n  for(int i = 0 ; i < a.size() ; i++ ){\n    for(int j = 0 ; j < b.size() ; j++ ){\n      ret = min( ret, distancion( a[i], b[i]));\n    }\n  }\n  return ret;\n}\ntypedef pair< double , int > Pi;\nbool used[101];\ndouble Dijkstra( int st, int gl){\n  priority_queue< Pi , vector< Pi > , greater< Pi > > que;\n  fill_n( used, 101, false);\n  que.push( Pi( 0.0, st));\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.sc == gl) return p.fr;\n    if(used[p.sc]++) continue;\n    for(int i = 0 ; i < info[p.sc].size() ; i++ )\n      que.push( Pi( info[p.sc][i].cost + p.fr, info[p.sc][i].to));\n  }\n}\n\nint main(){\n  int n, m, l;\n  vector< LLL  > stars( 101, LLL( 5));\n\n  while(cin >> n >> m >> l, l){\n    info.resize(n + 1);\n    for(int i = 1 ; i <= n ; i++ ){\n      int x, y, a, r;\n      cin >> x >> y >> a >> r;\n      LLL ret = comb( x, y, a, r);\n      copy( ret.begin(), ret.end(), stars[i].begin());\n    }\n\n    for(int i = 1 ; i <= n ; i++ ){\n      for(int j = n ; j > i ; j-- ){\n        double mindistance = dist( stars[i], stars[j]);\n        info[i].push_back( edge( j, mindistance));\n        info[j].push_back( edge( i, mindistance));\n      }\n    }\n    cout << fixed << setprecision(10) << Dijkstra( m, l) << endl;\n    info.resize(0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equlas(a, b) (fabs((a) - (b)) < EPS)\n#define INF (1e9+7)\n#define PI acos(-1)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point (double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator - (Point p) {\n        return Point(x - p.x, y - p.y);\n    }\n\n    Point operator * (double c) {\n        return Point(c * x, c * y);\n    }\n\n    Point operator / (double c) {\n        return Point(x / c, y / c);\n    }\n\n    bool operator < (const Point &p) {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n\n    bool operator == (const Point &p) {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n\n    bool operator != (const Point &p) {\n        return (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n    }\n\n    double norm() {\n        return (x * x + y * y);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n\n    Point rotatePoint(Point s, int angle) {\n        Point tmp(x - s.x, y - s.y);\n        double a = angle * PI / 180.0;\n\n        return Point(\n                    tmp.x * cos(a) - tmp.y * sin(a) + s.x, \n                    tmp.x * sin(a) + tmp.y * cos(a) + s.y);\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot (Vector a, Vector b) {\n    return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross (Vector a, Vector b) {\n    return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(Vector a) {\n    return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\ndouble distL(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distS (Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distL(s, p);\n}\n\nconst int CCW = 1;\nconst int CW = -1;\nconst int ONBACK = 2;\nconst int ONFRONT = -2;\nconst int ONSEG = 0;\n\nint ccw (Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if (cross(a, b) > EPS) return CCW;\n    if (cross(a, b) < -EPS) return CW;\n    if (dot(a, b) < -EPS) return ONBACK;\n    if (a.norm() < b.norm()) return ONFRONT;\n    return ONSEG;\n}\n\nbool intersect (Point a, Point b, Point c, Point d) {\n    return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distSS (Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distS(s1, s2.p1), distS(s1, s2.p2)), min(distS(s2, s1.p1), distS(s2, s1.p2)));\n}\n\nclass Star {\npublic:\n    Point p;\n    vector<Point> v;\n    vector<Segment> sg;\n    int r, a;\n\n    Star (Point p = Point(), int a = 0, int r = 0) : p(p), a(a), r(r) {}\n\n    void setVandSG () {\n        v.resize(5);\n        sg.resize(5);\n        Point topp(p.x, p.y + r);\n        int cnt = 0;\n\n        for (int i = 0; i < 5; ++i) {\n            v[i] = topp.rotatePoint(p, a + 72 * i);\n        }\n\n        for (int i = 0; i < 3; ++i) {\n            sg[cnt] = Segment(v[i], v[i + 2]);\n            cnt++;\n            if (i + 3 <= 4) sg[cnt] = Segment(v[i], v[i + 3]);\n            cnt++;\n        }\n    }\n\n};\n\nint n, m, l, x, y, a, r;\ndouble d[110][110];\nvector<Star> star;\n\nint main() {\n\n    while (scanf(\"%d%d%d\", &n, &m, &l), n | m | l) {\n        // initialize\n        star.resize(n);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == j) d[i][j] = 0.0;\n                else d[i][j] = INF;\n            }\n        }\n\n        //input\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> a >> r;\n            star[i] = Star(Point(double(x), double(y)), a, r);\n            star[i].setVandSG();\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < 5; ++k) {\n                    for (int o = 0; o < 5; ++o) {\n                        if (i != j) d[i][j] = min(d[i][j], distSS(star[i].sg[k], star[j].sg[o]));\n                    }\n                }\n            }\n        }\n\n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        printf(\"%.20f\\n\", d[m-1][l-1]);\n\n        star.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), l = sc.nextInt();\n\t\t\tif ((n|m|l) == 0) break;\n\t\t\tm--; l--;\n\n\t\t\tStar[] stars = new Star[n];\n\t\t\tfor (int i=0;i<n;i++) stars[i] = new Star(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\n\t\t\tdouble[][] d = new double[n][n];\n\t\t\tfor (int i=0;i<n;i++) for (int j=i+1;j<n;j++) {\n//\t\t\t\tdebug(\"star\", i, j);\n\t\t\t\td[i][j] = d[j][i] = stars[i].dist(stars[j]);\n\t\t\t}\n\n\t\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\t\tSystem.out.println(d[m][l]);\n\t\t}\n\t}\n\n\n\tdouble distSS (P p1, P p2, P q1, P q2) {\n\t\tif (cross(p1, p2, q1, q2)) return 0.0;\n\t\tdouble min = INF;\n\t\tmin = min(min, disSP(p1, p2, q1));\n\t\tmin = min(min, disSP(p1, p2, q2));\n\t\tmin = min(min, disSP(q1, q2, p1));\n\t\tmin = min(min, disSP(q1, q2, p2));\n\t\treturn min;\n\t}\n\n\t//テァツつケテ」ツ?ィテァツキツ堙・ツ按?」ツ?ョティツキツ敕ゥツ崢「\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).abs();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).abs();\n\t\treturn disLP(p1, p2, q);\n\t}\n\n\t//テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ョティツキツ敕ゥツ崢「\n\tdouble disLP(P p1, P p2, P q) {\n\t\treturn Math.abs(p2.sub(p1).det(q.sub(p1))) / p2.sub(p1).abs();\n\t}\n\n\t//テァツキツ堙・ツ按?、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t}\n\n\t//テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ偲・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ古ァツ崢エテァツキツ堙ァツ環カテ」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ古」ツ?ィテ」ツ?ォテ」ツ?凝」ツ?湘、ツスツ催ァツスツョテゥツ鳴「テ、ツソツづ」ツつ津」ツ?ソテ」ツつ?\n\tint ccw (P a, P b, P c) {\n\t\tP s = b.sub(a);\n\t\tP t = c.sub(a);\n\t\tif( s.det(t) > EPS ) return 1;\n\t\tif( s.det(t) < -EPS ) return -1;\n\t\tif( s.dot(t) < -EPS ) return 2;\n\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\treturn 0;\n\t}\n\n\tclass Star {\n\t\tP[] p;\n\t\tStar(int px, int py, int sh, int r) {\n\t\t\tp = new P[5];\n\t\t\tfor (int i=0;i<5;i++) {\n\t\t\t\tp[i] = new P(1.0 * px - sin(1.0 * (i * 72 + sh) / 180.0 * PI) * r,\n\t\t\t\t\t\t\t 1.0 * py + cos(1.0 * (i * 72 + sh) / 180.0 * PI) * r);\n\t\t\t}\n\t\t}\n\n\t\tdouble dist(Star s) {\n\t\t\tdouble min = INF;\n\t\t\tfor (int i=0;i<5;i++) for (int j=0;j<5;j++ ) {\n\t\t\t\tmin = min(min, distSS(p[i], p[(i+2)%5], s.p[j], s.p[(j+2)%5]));\n//\t\t\t\tdebug(i, j, min);\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t}\n\n\tpublic class P {\n\t\tdouble EPS = 1e-10;\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble add(double a, double b) {\t//ティツェツ、テ・ツキツョテ」ツつ津ィツ?εヲツ?ョ\n\t\t\tif( Math.abs(a+b) < EPS * ( Math.abs(a) + Math.abs(b) ) ) return 0;\n\t\t\treturn a + b;\n\t\t}\n\n\t\tP add(P p) {\t//テ・ツ陳?\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p) {\t//テ・ツキツョ\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\n\t\tP mlt(double k) {\n\t\t\treturn new P(x*k, y*k);\n\t\t}\n\n\t\tdouble dot(P p) {\t//テ・ツ??ァツゥツ?\n\t\t\t\treturn add(x*p.x, y*p.y);\n\t\t}\n\n\t\tdouble det(P p) {\t//テ・ツ、ツ姪ァツゥツ?\n\t\t\treturn add(x*p.y, -y*p.x);\n\t\t}\n\n\t\t//ティツキツ敕ゥツ崢「テァツウツサ\n\t\tdouble abs() {\n\t\t\tdouble ret = sqrt( add(x*x, y*y) );\n\t\t\tif ( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble abs(P p) {\n\t\t\tdouble dx = add( x, -p.x );\n\t\t\tdouble dy = add( y, -p.y );\n\t\t\tdouble ret = sqrt( add(dx*dx, dy*dy) );\n\t\t\tif( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n           (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n    if(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n    return dist_line_and_point(a1,a2,b);\n}\n\nostream& operator<<(ostream& os,point a){\n    os << \"(\" << a.real() << \",\" << a.imag() << \")\";\n    return os;\n}\ndouble dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){\n    if(is_intersected_linesegment(a1,a2,b1,b2)){\n        return 0;\n    }\n    return min(min(dist_linesegment_and_point(a1,a2,b1),\n                   dist_linesegment_and_point(a1,a2,b2)),\n               min(dist_linesegment_and_point(b1,b2,a1),\n                   dist_linesegment_and_point(b1,b2,a2)));\n}\n\nstruct Star{\n    point p;\n    double a;\n    double r;\n    vector<point> ps;\n    Star(double x,double y,double a,double r) : p(x,y),a(a),r(r) {\n        for(int i=0;i<5;i++){\n            ps.push_back(p+polar(r,M_PI * (0.4*i + 0.1 + (a / 180))));\n        }\n    }\n};\n\nconst double INF = 1e10;\ndouble dist_stars(Star a,Star b){\n    double ret = INF;\n    for(int i=0;i<5;i++){\n        for(int j=i+1;j<5;j++){\n            for(int k=0;k<5;k++){\n                for(int l=k+1;l<5;l++){\n                    ret = min(ret,dist_linesegment_and_linesegment(a.ps[i],a.ps[j],b.ps[k],b.ps[l]));\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    while(true){\n        int N,M,L;\n        cin >> N >> M >> L;\n        if(N == 0 and M == 0 and L == 0) break;\n        vector<Star> stars;\n        vector<vector<double> > dist(N,vector<double>(N,INF));\n\n        for(int i=0;i<N;i++){\n            double x,y,a,r;\n            cin >> x >> y >> a >> r;\n            stars.push_back(Star(x,y,a,r));\n        }\n        for(int i=0;i<N;i++){\n            for(int j=i;j<N;j++){\n                dist[i][j] = dist[j][i] = dist_stars(stars[i],stars[j]);\n            }\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        cout << dist[M-1][L-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\ntypedef vector<Line> star;\nconst ld rot = 144.0 / 180.0 * PI;\n\nvector<Point> make_star(ld x, ld y, ld a, ld r)\n{\n\tvector<Point> res(5);\n\tPoint p(0, r);\n\tp = p * (Point(cos(a / 180.0 * PI), sin(a / 180.0 * PI)));\n\tres[0] = p;\n\tREP(i, 4) res[i + 1] = res[i] * (Point(cos(rot), sin(rot)));\n\tREP(i, 5) res[i] += Point(x, y);\n\treturn res;\n}\n\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvoid dijkstra(Graph &g, int s, Array &d)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nld dist_star(star a, star b)\n{\n\tld res = INF;\n\tREP(i, 5)REP(j, 5)\n\t{\n\t\tchmin(res, dist_ss(a[i], b[j]));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, src, dst;\n\twhile (cin >> n >> src >> dst, n)\n\t{\n\t\tsrc--, dst--;\n\t\tvector<star> stars(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y, a, r; cin >> x >> y >> a >> r;\n\t\t\tvector<Point> ps = make_star(x, y, a, r);\n\t\t\tREP(j, 5)\n\t\t\t{\n\t\t\t\tstars[i].push_back(Line((ps[j % 5]), ps[(j + 1) % 5]));\n\t\t\t}\n\t\t}\n\t\tGraph g(n);\n\t\tREP(i, n)REP(j, n)\n\t\t{\n\t\t\tadd_edge(g, i, j, dist_star(stars[i], stars[j]));\n\t\t}\n\t\tArray dist;\n\t\tdijkstra(g, src, dist);\n\t\tcout << D10 << dist[dst] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#include <complex>\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転（角度）\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\n\nint main(void) {\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        m--,l--;\n        vector<vector<P> > v(n);\n        rep(i,n){ //それぞれの星の頂点をvにpushする\n            P p = inP();\n            double a,r;\n            cin >> a >> r;\n            P t(0,r);\n            rep(j,5){//a+j*72度回転\n                v[i].push_back(turn(t, a+j*72)+p);\n            }\n            rep(j,5){\n                cout << i << \" \" << j << \" \";\n                printP(v[i][j]);\n            }\n        }\n\n        double dp[100][100];\n        rep(i,100)rep(j,100) dp[i][j] = INF;\n        rep(i,100) dp[i][i] = 0;\n\n        rep(i,n)rep(a,5)rep(j,n)rep(b,5)if(i<j){\n            dp[i][j] = dp[j][i] = min(dp[i][j], distancePP(v[i][a],v[j][b]));\n        }\n        rep(i,n)rep(j,n)if(i<j)cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        rep(k,n)rep(i,n)rep(j,n){\n            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n        }\n        cout << shosu(10) << dp[m][l] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  int n,m,l;cin >> n>>m>>l;\n  if(n==0) break;\n  Polygon stars[n];\n  //int r[n];\n  for(int i=0;i<n;i++){\n    int x,y,a,r;cin>>x>>y>>a>>r;\n    for(int j=0;j<5;j++){\n      Point v=Point(x,y)+Point(r*cos((18+a+72*j)*(2*PI)/360),r*sin((18+a+72*j)*(2*PI)/360));\n      stars[i].push_back(v);\n    }\n  }\n  ld dis[n][n];\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n    if(i==j) dis[i][j]=0.0;\n    else dis[i][j]=INF;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ld tmp=INF;\n      for(int k=0;k<5;k++){\n        for(int l=0;l<5;l++){\n          tmp=min(tmp,sqrt(norm(stars[i][k]-stars[j][l])));\n        }\n      }\n      dis[i][j]=tmp;dis[j][i]=tmp;\n    }\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);\n      }\n    }\n  }\n  cout << setprecision(10)<<dis[m-1][l-1] << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nusing namespace std;\n\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]),amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main() {\n\twhile (1) {\n\n\n\tint N, M, L; cin >> N >> M >> L;\n\tif (!N)break;\n\tvector<vector<Line>>stars(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong double x, y, a, r;\n\t\tcin >> x >> y >> a >> r;\n\t\tPoint center(x, y);\n\t\tvector<Point>pos;\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tPoint np = center + r*Point(cos((90+a+ 72.0*j)/180*acos(-1.0)), sin((90 + a + 72.0*j) / 180 * acos(-1.0)));\n\t\t\tpos.push_back(np);\n\t\t}\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tLine nl(pos[(j * 2) % 5], pos[(j * 2 + 2) % 5] );\n\t\t\tstars[i].push_back(nl);\n\t\t}\n\t}\n\tvector<vector<long double>>dists(N, vector<long double>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tdists[i][j] = getdis(stars[i], stars[j]);\n\t\t}\n\t}\n\tfor (int k = 0; k < N; ++k) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tdists[i][j] = min(dists[i][j],dists[i][k] + dists[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout <<fixed<<setprecision(22)<< dists[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tP pt[100][5];\n        for(int i = 0; i < n; i++){\n\t\t\tdouble x,y,a,r;\n            cin>>x>>y>>a>>r;\n            for(int j=0;j<5;j++)\n\t\t\t\tpt[i][j]=rot(P(0.0,r),(a + 72 * j)/180*PI) + P(x,y);\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    S s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    S t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn .0;\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nPoly rotate_poly(Poly po,Point c,R a){//???????¨???????\n    REP(i,po.size()){\n        po[i] = Point(po[i].real() - c.real(),po[i].imag() - c.imag());\n        po[i] = po[i] * Point(cos(a),sin(a));\n        po[i] = Point(po[i].real() + c.real(),po[i].imag() + c.imag());\n    }\n    return po;\n}\n\nR convert_deg_to_rad(R deg){\n    return deg / 180.0 * M_PI;\n}\n\nint N, M, L;\nPoly star[100];\n\nbool input() {\n  cin>>N>>M>>L;\n  R x, y, a, r;\n  REP(i, N) {\n    star[i].clear();\n    cin>>x>>y>>a>>r;\n    R ar = convert_deg_to_rad(a+90.0);\n    REP(j,5) {\n      star[i].pb(Point(x, y)+r*Point(cos(ar), sin(ar)));\n      ar += convert_deg_to_rad(72.0);\n    }\n  }\n  return N!=0;\n}\n\n#define INF 1000000000.0\nR G[100][100];\n\nvoid solve() {\n  fill((R *)G, (R *)G+10000, INF);\n  REP(i,N) {\n    G[i][i] = 0.0;\n  }\n\n  R dis;\n  REP(i, N) {\n    FOR(j, i+1, N) {\n      dis = INF;\n      REP(k, 5) {\n        REP(l, 5) {\n          dis = min(dis,dis_ss(Line(star[i][k],star[i][(k + 2) % 5]), Line(star[j][l], star[j][(l+2)%5])) );\n        }\n      }\n      G[i][j] = dis;\n      G[j][i] = dis;\n      //cout<<i<<','<<j<<':'<<dis<<endl;\n    }\n  }\n  REP(k,N){\n    REP(i,N){\n      REP(j,N){\n        G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n      }\n    }\n  }\n  printf(\"%0.10lf\\n\",G[M-1][L-1]);\n  //cout<<showpoint<<G[M-1][L-1]<<endl;\n}\n\nint main() {\n  while(input()) {\n    /*REP(i, N) {\n      REP(j, 5) {\n        cout<<star[i][j]<<' ';\n      }\n      cout<<endl;\n    }*/\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\n#include <complex>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n\n#define INF (1<<29)\n\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\ntypedef complex<double> Point;\n\nstruct Line {\n  Point pos,dir; // position, direction\n  Line(){}\n  Line(const Point& pos, const Point& dir){\n    this->pos = pos; this->dir = dir;\n  }\n};\n\ndouble convertD2R(double deg){\n  return (deg * PI) / 180.0;\n}\n\ndouble dot(const Point& a, const Point& b){\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(const Point& a, const Point& b){\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint ccw(Point a, Point b, Point c){\n  b -= a; c -= a;\n  if(cross(b,c) > 0) return +1;    // counter clock wise\n  if(cross(b,c) < 0) return -1;    // clock wise\n  if(dot(b,c) < 0) return +2;      // c--a--b\n  if(norm(b) < norm(c)) return -2; // a--b--c\n  return 0;                        // a--c--b || b == c\n}\n\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l.pos, l.pos - l.dir) / norm(l.pos - l.dir);\n  return l.pos + t * (l.pos - l.dir);\n}\n\nbool intersectSP(const Line& s, const Point& p){\n  return (abs(s.pos - p) + abs(s.dir - p) - abs(s.dir - s.pos) < EPS);\n}\n\nbool intersectSS(const Line& a, const Line& b){\n  return (ccw(a.pos,a.dir,b.pos) * ccw(a.pos,a.dir,b.dir) <= 0 && ccw(b.pos,b.dir,a.pos) * ccw(b.pos,b.dir,a.dir) <= 0);\n}\n\ndouble distanceSP(const Line& s, const Point& p){\n  Point r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r - p);\n  return min(abs(s.pos - p), abs(s.dir - p));\n}\n\ndouble distanceSS(const Line& a, const Line& b){\n  if(intersectSS(a,b)) return 0;\n  return min(min(distanceSP(a,b.pos), distanceSP(a,b.dir)), min(distanceSP(b,a.pos), distanceSP(b,a.dir)));\n}\n\nstruct Star {\n  Line s[5]; // segment\n\n  Star(){}\n  Star(double x, double y, double a, double r){\n    int i;\n    REP(i,5){\n      double theta1 = convertD2R(a) + i * 2*PI/5.0 + PI/2.0; // a + 72 + 90\n      double theta2 = convertD2R(a) + (i+2) * 2*PI/5.0 + PI/2.0; // a + 72 + 90\n      s[i] = Line(polar(r,theta1) + Point(x,y), polar(r,theta2) + Point(x,y));\n    }\n  }\n};\n\nint V; // vertex\nStar star[110]; // x,y,a,r\n\npriority_queue< pair<double,int> > q;\nbool used[110];\ndouble dist[110];\n\nvoid add(int x, double d){\n  if(d < dist[x]){\n    dist[x] = d;\n    q.push(make_pair(-d,x));\n  }\n}\n\nvoid dijkstra(int start){\n  int next,i,j;\n\n  REP(i,V) used[i] = false;\n  REP(i,V) dist[i] = INF;\n  add(start,0.0);\n\n  while(!q.empty()){\n    double d = -q.top().first; int now = q.top().second; q.pop();\n    if(used[now]) continue;\n    used[now] = true;\n    REP(next,V) if(now != next){\n      double d2 = INF;\n      REP(i,5) REP(j,5) d2 = min(d2, distanceSS(star[now].s[i],star[next].s[j]));\n      add(next, d+d2);\n    }\n  }\n}\n\nint main(){\n  int start,goal,i;\n\n  while(1){\n    cin >> V >> start >> goal;\n    if(V == 0 && start == 0 && goal == 0) break;\n    start--; goal--;\n\n    REP(i,V){\n      double x,y,a,r;\n      cin >> x >> y >> a >> r;\n      star[i] = Star(x,y,a,r);\n    }\n\n    dijkstra(start);\n    printf(\"%.17lf\\n\",dist[goal]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// geometry ////\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return a * (a.dot(b) / a.length()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn contains(a, b.p) || contains(a, b.p + b.d)\n\t\t|| contains(b, a.p) || contains(b, a.p + a.d);\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return b.d.cross(a - b.p) / b.d.length(); }\ninline double getDistance(P2 a, LineSeg b) { return min(getDistance(perpendicular_foot(a, (Line)b), a), min(getDistance(b.p, a), getDistance(b.p + b.d, a))); }\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b) { return isCross(a, b) ? 0 : min(min(getDistance(a.p, b.p), getDistance(a.p, b.p + b.d)), min(getDistance(a.p + a.d, b.p), getDistance(a.p + a.d, b.p + b.d))); }\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n#define M_PI       3.14159265358979323846\n// Milky Way\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tif (!N) { break; }\n\n\t\tvevector<LineSeg> segs(N);\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(int, x, y, a, r);\n\t\t\tREP(i, 5)\n\t\t\t{\n\t\t\t\tint j = i + 1;\n\t\t\t\tdouble ai = (i * 144 + 90 + a) % 360 * M_PI / 180.0;\n\t\t\t\tdouble aj = (j * 144 + 90 + a) % 360 * M_PI / 180.0;\n\t\t\t\tP2 center(x, y);\n\t\t\t\tP2 pi = center + P2(cos(ai), sin(ai)).direction() * r;\n\t\t\t\tP2 pj = center + P2(cos(aj), sin(aj)).direction() * r;\n\t\t\t\tsegs[_].push_back(LineSeg::From2Point(pi, pj));\n\t\t\t}\n\t\t}\n\n\t\tvevector<Path<double>> graph(N);\n\t\tREP(i, N) REP(j, N)\n\t\t{\n\t\t\tdouble d = INF;\n\t\t\tREP(k, 5) REP(l, 5) d = min(d, getDistance(segs[i][k], segs[j][l]));\n\t\t\tgraph[i].push_back({ i, j, d });\n\t\t}\n\n\t\tprintf(\"%.16f\\n\", dijkstra(graph, M - 1, L - 1).first[L - 1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n  \n  \n  \n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#endif\n  \n#define rep (i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define MEMCPY(dest, src) memcpy(dest, src, sizeof(src))\n  \n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n  \ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n  \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\ntemplate <class T> vector<T> input(int n) { vector<T> res(n); for (int i = 0; i < n; ++i) cin >> res[i]; return res; }\n \n \n \n \n \nconst double EPS_FOR_LIB = 1e-8;\ntypedef double geo_type;\ntypedef complex<geo_type> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n};\nstruct Line\n{\n\tPoint from, to;\n\tLine(Point from, Point to) : from(from), to(to) { }\n\tLine() { }\n};\ntypedef vector<Point> Poly;\n \ngeo_type dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngeo_type cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n \nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > EPS_FOR_LIB) return counter_clockwise;\n\telse if (cross(p, q) < -EPS_FOR_LIB) return clockwise;\n\telse return on;\n}\n\n// 交差判定\nbool intersectLL(const Line& line1, const Line& line2)\n{\n\t// non-parallel\n\tif (abs(cross(line1.to - line1.from, line2.to - line2.from) > EPS_FOR_LIB))\n\t\treturn true;\n\t// same line\n\tif (abs(cross(line1.to - line1.from, line2.from - line1.from) < EPS_FOR_LIB))\n\t\treturn true;\n\treturn false;\n}\nbool intersectLS(const Line& line, const Line& seg)\n{\n\treturn cross(line.to - line.from, seg.from - line.from)\n\t\t* cross(line.to - line.from, seg.to - line.from) < EPS_FOR_LIB;\n}\nbool intersectLP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.to - p, line.from - p)) < EPS_FOR_LIB;\n}\nbool intersectSS(const Line& seg1, const Line& seg2)\n{\n\treturn ccw(seg1.from, seg1.to, seg2.from) * ccw(seg1.from, seg1.to, seg2.to) <= 0\n\t\t&& ccw(seg2.from, seg2.to, seg1.from) * ccw(seg2.from, seg2.to, seg1.to) <= 0;\n}\nbool intersectSP(const Line& seg, const Point& p)\n{\n\treturn norm(seg.from - p) + norm(seg.to - p) - norm(seg.from - seg.to) < EPS_FOR_LIB;\n}\n\n// 距離\n// complex<double>で使わないとNG\n// 点から直線に垂線を下ろした点\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.from - line.to;\n\tgeo_type t = dot(p - line.from, a) / norm(a);\n\treturn line.from + t * a;\n}\n// 線対称な点\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((geo_type)2) * (projection(line, p) - p);\n}\ndouble distanceLP(const Line& line, const Point& p)\n{\n\treturn abs(p - projection(line, p));\n}\ndouble distanceLL(const Line& line1, const Line& line2)\n{\n\treturn intersectLL(line1, line2) ? 0 : distanceLP(line1, line2.from);\n}\ndouble distanceLS(const Line& line, const Line& seg)\n{\n\tif (intersectLS(line, seg))\n\t\treturn 0;\n\treturn min(distanceLP(line, seg.from), distanceLP(line, seg.to));\n}\ndouble distanceSP(const Line& seg, const Point& p)\n{\n\tconst Point r = projection(seg, p);\n\tif (intersectSP(seg, r))\n\t\treturn abs(r - p);\n\treturn min(abs(seg.from - p), abs(seg.to - p));\n}\ndouble distanceSS(const Line& seg1, const Line& seg2)\n{\n\t//if (intersectSS(seg1, seg2))\n\t//\treturn 0;\n\treturn min(min(distanceSP(seg1, seg2.from), distanceSP(seg1, seg2.to)),\n\t\tmin(distanceSP(seg2, seg1.from), distanceSP(seg2, seg1.to)));\n}\n\n\nPoint rotate(const Point& p, double angle, const Point& base = Point(0, 0))\n{\n\tdouble c = cos(angle), s = sin(angle);\n\tPoint t = p - base;\n\treturn Point(t.real() * c - t.imag() * s + base.real(), t.real() * s + t.imag() * c + base.imag());\n}\n\nvector<Line> lines(int x, int y, int a, int r)\n{\n    double w = PI * 2 / 5;\n    double a1 = PI / 2 - w;\n    double a2 = w - a1;\n \n    double c1 = cos(a1), s1 = sin(a1);\n    double c2 = cos(a2), s2 = sin(a2);\n \n    double px[] = { 0, -c2, c1, -c1, c2, 0 };\n    double py[] = { 1, -s2, s1, s1, -s2, 1 };\n \n\tPoint p[6];\n    double ang = PI * a / 180;\n    for (int i = 0; i < 6; ++i)\n\t\tp[i] = (double)r * rotate(Point(px[i], py[i]), ang) + Point(x, y);\n\n    vector<Line> res;\n    for (int i = 0; i < 5; ++i)\n        res.push_back(Line(p[i], p[i + 1]));\n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    const double INF = 1e20;\n \n    int n, s, g;\n    while (cin >> n >> s >> g, n)\n    {\n        --s, --g;\n \n        vector<Line> star[128];\n        for (int i = 0; i < n; ++i)\n        {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            star[i] = lines(x, y, a, r);\n        }\n \n \n        double e[128][128];\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = 0; j < n; ++j)\n            {\n\t\t\t\tif (i == j)\n\t\t\t\t{\n\t\t\t\t\te[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                e[i][j] = INF;\n                for (int k = 0; k < 5; ++k)\n                    for (int l = 0; l < 5; ++l)\n                        min_swap(e[i][j], distanceSS(star[i][k], star[j][l]));\n\t\t\t\t//cout << e[i][j] << endl;\n            }\n        }\n \n \n        double dis[128];\n        fill(dis, dis + n, INF);\n \n        typedef pair<double, int> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        dis[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty())\n        {\n            P tt = q.top(); q.pop();\n            int p = tt.second;\n            double c = tt.first;\n \n            if (p == g)\n                break;\n            else if (c > dis[p])\n                continue;\n \n            for (int i = 0; i < n; ++i)\n            {\n                double nc = c + e[p][i];\n                if (nc < dis[i])\n                {\n                    dis[i] = nc;\n                    q.push(P(nc, i));\n                }\n            }\n        }\n \n        cout.setf(ios::fixed);\n        cout.precision(15);\n        cout << dis[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\nconstexpr long double eps = 1e-10;\nconstexpr long double PI = acos(-1);\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line(point a_, point b_)\n    : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\n\nclass star {\npublic:\n    star(double x, double y, double a, double r) {\n        vector<point> points;\n        for(int i=0; i<5; ++i) {\n            double ar = (a + 72 * i) / 180.0 * PI;\n            double dx = -r*sin(ar), dy = r*cos(ar);\n            points.emplace_back(x+dx, y+dy);\n        }\n        for(int i=0; i<5; ++i) {\n            lines.emplace_back(points[i], points[(i+2)%5]);\n        }\n    }\n\n    vector<segment> lines;\n};\n\nlong double dist(star const& s1, star const& s2) {\n    long double res = 1e9;\n    for(int i=0; i<s1.lines.size(); ++i) {\n        for(int j=0; j<s2.lines.size(); ++j) {\n            res = min(res, dist_ss(s1.lines[i], s2.lines[j]));\n        }\n    }\n    return res;\n}\n\n\nint main() {\n    int n, m, l;\n    while(cin >> n >> m >> l, n) {\n        m--; l--;\n        vector<star> stars;\n        for(int i=0; i<n; ++i) {\n            double x, y, a, r;\n            cin >> x >> y >> a >> r;\n            stars.emplace_back(x, y, a, r);\n        }\n        vector<vector<long double>> d(n, vector<long double>(n, 1e9));\n        for(int i=0; i<n; ++i) {\n            for(int j=0; j<n; ++j) {\n                d[i][j] = dist(stars[i], stars[j]);\n            }\n        }\n        for(int k=0; k<n; ++k) {\n            for(int i=0; i<n; ++i) {\n                for(int j=0; j<n; ++j) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(10) << d[m][l] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define USE_MATH_DEFINES\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n  return d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n  Real x,y;\n\n  Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\n  Point operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n  Point operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n  Point operator*(Real s) const {return Point(x*s,y*s);}\n  Point operator/(Real s) const {return Point(x/s,y/s);}\n  bool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n  bool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n  Segment(const Point &a,const Point &b){ at(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n  Line(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n  Point c;\n  Real r;\n\n  Circle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n  return Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n  const Real s = sin(theta),c = cos(theta);\n  return Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n  return atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n  return a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n  return a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n  return p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n  return sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n  const Point p = b-a;\n  const Point q = c-a;\n  const int sgn = sign(cross(p,q));\n\n  if(sgn == 1) return CCW;\n  if(sgn == -1) return CW;\n  if(sign(dot(p,q)) == -1) return BACK;\n  if(sign(norm(p) - norm(q)) == -1) return FRONT;\n  return ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n  Real t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n  return l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n  const Point c = project(l,p);\n  return c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n  return ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n    && ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n  return ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n  return sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n  return abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n  return sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n    ||  sign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n  return abs(a-b);    \n}\n\nReal dist(const Line &l,const Point &p){\n  const Point a = l[1]-l[0];\n  const Point b = p-l[0];\n  return abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n  if(intersect(l,s)) return 0;\n  return min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n  if(intersect(a,b)) return 0;\n  return dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n  if(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n  if(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n  return dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n  if(intersect(a,b)) return 0;\n  return min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nconst int MAX_V = 101;\nconst Real INF = 1e12;\n\nstruct edge{\n  int to;\n  Real dist;\n  edge(int t_to,Real t_dist){\n    to=t_to;dist=t_dist;\n  }\n};\n\ntypedef pair<Real,int> P;//cost??¨v\n\nvector< vector<edge> > G(MAX_V);\nReal d[MAX_V];\n\nvoid dijkstra(int s){\n  priority_queue<P,vector<P>,greater<P> > que;\n  fill_n((Real *)d, sizeof(d)/sizeof(Real),INF);\n  d[s] = 0;\n  que.push(P(0,s));\n\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v]<p.first) continue;\n    rep(i,G[v].size()){\n      edge e = G[v][i];\n      if(d[e.to] > d[v] + e.dist){//??????????????´???\n        d[e.to] = d[v] + e.dist;\n        que.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(){\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\twhile(1){\n\tint N,M,L;\n\tcin >> N >> M >> L;\n\n\tif(N==0&&M==0&&L==0) break;\n\tM--;L--;\t\n\tG.clear();\n\tG.resize(N);\n\n\n\tvector<vector<Point>> stars(N);\n\n\trep(i,N){\n\t\tPoint s;\n\t\tint a,r;\n\t\tcin >> s >> a >> r;\n\t\tPoint p(0,r);\n\t\trep(j,5){\n\t\t\tReal theta = (a+72*j)*(M_PI/180);\n\t\t\tPoint s1 = rotate(p,theta)+s;\n\t\t\tstars[i].push_back(s1); \n\t\t}\n\t}\n\n\t\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tif(i==j) continue;\t\n\t\t\tReal td=INF;\n\t\t\trep(k,5) rep(l,5){\n\t\t\t\ttd=min(dist(Segment(stars[i][k],stars[i][(k+2)%5]),Segment(stars[j][l],stars[j][(l+2)%5])),td);\t\n\t\t\t}\n\t\t\tG[i].push_back(edge(j,td));\n\t\t}\n\t}\n\n\n\tdijkstra(M);\n\tcout << d[L] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define FOR(i,a,n) for(int i = (a);i < (n);i++)\ndouble M_PI = acos(-1);\nconst double EPS = 1e-10;\nconst double INF = 1e9;\nusing namespace std;\n\nint N,M,L;\n\nstruct Point{\n    double x,y;\n    Point operator - (const Point& p){ return Point{x-p.x,y-p.y};}\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\ndouble norm(Point a){return a.x*a.x+a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a,Point b){return a.x*b.y - a.y*b.x;}\n\nint ccw(Point p1,Point p2,Point p3){\n    Point a = {p2.x-p1.x, p2.y - p1.y};\n    Point b = {p3.x-p1.x, p3.y - p1.y};\n    if(cross(a,b) > EPS) return 1;\n    if(cross(a,b) < -EPS) return -1;\n    if(dot(a,b) < -EPS) return 2;\n    if(norm(a) < norm(b)) return -2;\n    return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1,s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < -EPS) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < -EPS) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n    \n\nSegment star[102][5];\ndouble mindist[102][102];\n\n\n\ndouble getdist(int u, int v){\n    REP(i,5){\n        REP(j,5){\n            if(intersect(star[u][i],star[v][j])){\n                    return 0;\n            }\n        }\n    }\n    double ans = INF;\n    REP(k,2){\n        if(k) swap(u,v);\n        REP(i,5){\n            REP(j,5){\n                ans = min(getDistSP(star[u][i],star[v][j].p1),ans);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>N>>M>>L,N){\n        REP(i,N){\n            int x,y,a,r;\n            cin>>x>>y>>a>>r;\n            Point p[5];\n            REP(j,5) p[j] = Point{x + r*sin((double)(72*j - a)/180*M_PI), y + r*cos((double)(72*j - a)/180*M_PI)};//star's vertex\n            REP(j,5){\n                star[i][j] = Segment{p[j], p[(j+2)%5]};\n            }\n        }\n\n        //caluculate min distance\n        REP(i,N){\n            FOR(j,i,N){\n                mindist[i][j] = mindist[j][i] = getdist(i,j);\n            }\n        }\n\n        //WF        \n        REP(k,N){\n            REP(i,N){\n                REP(j,N){\n                    mindist[i][j] = min(mindist[i][j], mindist[i][k] + mindist[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(8) << mindist[M-1][L-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-10;\ndouble add(double a,double b){\n    if(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\n\nconst double pi=acos(-1);\nint main(){\n    int n,m,l;\n    while(cin>>n>>m>>l){\n        if(n==0)break;\n        P x[n][5];\n        rep(i,n){\n            P c;\n            cin>>c.first>>c.second;\n            double a,b;\n            cin>>a>>b;\n            a*=pi/180;\n            rep(j,5){\n                P y;\n                y={-sin(a+2.0/5.0*j*pi),cos(a+2.0/5.0*j*pi)};\n                x[i][j]=c+y*b;\n            }\n        }\n        double d[n][n];\n        rep(i,n)rep(j,n)d[i][j]=inf;\n        rep(i,n)d[i][i]=0;\n        rep(i,n)rep(j,n){\n            if(i==j)continue;\n            rep(k,5)rep(l,5){\n                d[i][j]=min(d[i][j],dist(x[i][k],x[i][(k+2)%5],x[j][l]));\n            }\n        }\n        rep(i,n)rep(j,n)rep(k,n)d[j][k]=min(d[j][k],d[i][j]+d[i][k]);\n        cout<<fixed<<setprecision(12)<<d[m-1][l-1]<<endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\treturn .0;\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\n//for vector\n\ninline D dot(P x, P y){return real(conj(x)*y);}\n\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline D seg_seg_dis(L a,L b){\n  D res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nint main(){\n  int n,m,l;\n  while(scanf(\"%d%d%d\",&n,&m,&l), n){\n    vector< vector<L> > stars(n);\n    for(int i=0;i<n;i++){\n      int x,y,a,r;\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      P c = P(x,y);\n\n      vector<P> v;\n      P p = P(0,r);\n      for(int j=0;j<5;j++){\n\tv.push_back(c+rotate(p,PI*(a+j*72)/180));\n      }\n      \n      vector<L> l;\n      for(int j=0;j<5;j++){\n\tl.push_back(L(v[j],v[(j+2)%5]));\n      }\n      stars[i] = l;\n    }\n\n    vector< vector<D> > g(n, vector<D>(n,0));\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : stars[i]){\n\t  for(L b : stars[j]){\n\t    if(is_cp(a,b))dis = 0;\n\t    else dis = min(dis, seg_seg_dis(a,b));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    printf(\"%.9lf\\n\",g[m-1][l-1]);\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\ntypedef complex<double> P;\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\ndouble ex(P a,P b,P c){\n\treturn cross(b-a,c-a);\n}\n\nint ccw(P a, P b, P c) {\n b -= a; c -= a;\n if (cross(b, c) > DBL_EPSILON) return +1; // counter clockwise\n if (cross(b, c) < -DBL_EPSILON) return -1; // clockwise\n if (dot(b, c) < -DBL_EPSILON) return +2; // c--a--b on line\n if (norm(b) < norm(c) - DBL_EPSILON) return -2; // a--b--c on line\n return 0; // a--c--b on line (or b == c)\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\t return ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n\t ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\ndouble DistanceSP(P a, P b, P c) {\n\tif (dot(b - a, c - a) < DBL_EPSILON)\n\t\treturn abs(c - a);\n\tif (dot(a - b, c - b) < DBL_EPSILON)\n\t\treturn abs(c - b);\n\treturn abs(cross(b - a, c - a))/abs(a-b);\n}\ndouble DistaiceSS(P a, P b, P c, P d) {\n\tif (isIntersectSS(a, b, c, d)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a, b, c), DistanceSP(a, b, d)),\n\t\t\tmin(DistanceSP(c, d, a), DistanceSP(c, d, b)));\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta = M_PI / 2 + 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta), p.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\nvector<pair<int,int> > edges;\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(ea,edges){\n\t\tP a1=p1.vertex[(*ea).first];\n\t\tP a2=p1.vertex[(*ea).second];\n\t\tforeach(eb,edges){\n\t\t\tP b1=p2.vertex[(*eb).first];\n\t\t\tP b2=p2.vertex[(*eb).second];\n//\t\t\tcout<< a1<<a2<< b1<< b2 <<endl;\n//\t\t\tcout<< DistaiceSS(a1, a2, b1, b2) <<endl;\n\t\t\tm = min(m, DistaiceSS(a1, a2, b1, b2));\n\t\t}\n\n\t}\n\treturn m;\n}\nint x, y, a, r;\n\ndouble dijk(int start, int goal) {\n\tvector<double> memo(N, DBL_MAX);\n\tpriority_queue<pair<double,int> > up;\n\tup.push(make_pair(0, start));\n\tmemo[start] = 0;\n\twhile (!up.empty()) {\n\t\tdouble cost = -up.top().first;\n\t\tint pos = up.top().second;\n\n\t\tup.pop();\n\t\tif (memo[pos] < cost)\n\t\t\tcontinue;\n\t\tif (pos == goal)\n\t\t\treturn cost;\n\t\tREP0(next,N) {\n\t\t\tif (links[pos][next] >= 0) {\n\t\t\t\tdouble ncost = cost + links[pos][next];\n\t\t\t\tif (memo[next] > ncost) {\n\t\t\t\t\tmemo[next] = ncost;\n\t\t\t\t\tup.push(make_pair(-ncost, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tedges.push_back(make_pair(0,2));\n\tedges.push_back(make_pair(0,3));\n\tedges.push_back(make_pair(1,4));\n\tedges.push_back(make_pair(1,3));\n\tedges.push_back(make_pair(2,4));\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(i==j?0:getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tcout.width(10);\n\t\t//cout << dijk(M - 1, L - 1) << endl;\n\t\tprintf(\"%.8lf\\n\", dijk( M-1 , L - 1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n#include <complex>\n\ntypedef complex<double> P;\n\ndouble x[100],y[100],a[100],r[100];\n\ndouble toRad(int deg){\n\treturn (double)deg*2*PI/360;\n}\n\nP getCoord(int i,int j){\n\tdouble xx=x[i]+r[i]*cos(toRad(90+a[i]+72*j));\n\tdouble yy=y[i]+r[i]*sin(toRad(90+a[i]+72*j));\n\treturn P(xx,yy);\n}\n\ndouble getDist(const P &left, const P &right){\n\treturn sqrt(pow(left.real()-right.real(),2)+pow(left.imag()-right.imag(),2));\n}\n\nstruct node{\n\tint n;\n\tdouble cost;\n\tnode(int n,double cost):n(n),cost(cost){}\n\tbool operator<(const node &other)const{\n\t\treturn cost>other.cost;\n\t}\n};\nconst int MAX=INT_MAX/10;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\ndouble cross(P a,P b){\n\treturn (a.real()*b.imag()-a.imag()*b.real());\n}\n#define EQ(a,b) (abs((a)-(b))<EPS)\nbool crossing(P a1,P a2,P b1,P b2){\n\tif(EQ(cross(a1-a2,b1-b2),0.0))return false;\n\treturn ( cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS)&&\n\t\t(cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS);\n\t//return (getDist(a,c)+getDist(c,b)<getDist(a,b)+EPS);\n}\n\nint main(){\n\tint N,M,L;\n\twhile(cin>>N>>M>>L,N){\n\t\tREP(i,N){\n\t\t\tcin>>x[i]>>y[i]>>a[i]>>r[i];\n\t\t}\n\t\t/*\n\t\tREP(i,N)REP(j,5){\n\t\t\tcout<<getCoord(i,j).x<<\",\"<<getCoord(i,j).y<<endl;\n\t\t}\n\t\t*/\n\t\tvvd dist(N,vd(N,MAX));\n\t\tREP(i,N){\n\t\t\tREP(j,5){\n\t\t\t\tREP(k,N){\n\t\t\t\t\tbool flag=false;\n\t\t\t\t\tREP(l,5){\n\t\t\t\t\t\tP left=getCoord(i,j);\n\t\t\t\t\t\tP left2=getCoord(i,(j+2)%5);\n\t\t\t\t\t\tP right=getCoord(k,l);\n\t\t\t\t\t\tP right2=getCoord(k,(l+2)%5);\n\t\t\t\t\t\tif(crossing(left,left2,right,right2)){\n\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\tdist[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!flag){\n\t\t\t\t\t\t\tdist[i][k]=min(dist[i][k],getDist(left,right));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvd cost(N,MAX);\n\n\t\tpriority_queue<node> q;\n\t\tREP(i,5){\n\t\t\tq.push(node(M-1,0));\n\t\t\tcost[M-1]=0;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tnode n=q.top();\n\t\t\tq.pop();\n\t\t\tif(n.cost>cost[n.n])continue;\n\n\t\t\tREP(i,N){\n\t\t\t\tif(dist[n.n][i]<MAX){\n\t\t\t\t\tdouble dd=cost[n.n]+dist[n.n][i];\n\t\t\t\t\tif(cost[i]>dd){\n\t\t\t\t\t\tcost[i]=dd;\n\t\t\t\t\t\tq.push(node(i,dd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", cost[L-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define PI M_PI\n#define MAX_N 100\n#define INF 1e9\n\nclass Point{\npublic:\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nclass Segment{\npublic:\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nclass Star : public Point{\npublic:\n  double a,r;\n  vector<Segment> segs;\n  Star(){}\n  Star(Point p,double a,double r) : Point(p),a(a),r(r) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nPoint projection(const Segment &s,const Point &p){\n  Vector b = s.t-s.s;\n  double t = dot(p-s.s,b)/norm(b);\n  return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n  Point r = projection(s,p);\n  if(isIntersectSP(s,r)){ return abs(r-p); }\n  return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment a,const Segment b){\n  if(isIntersectSS(a,b)){ return 0; }\n  return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n             min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nistream &operator >> (istream &is,Star &s){\n  return is >> s.x >> s.y >> s.a >> s.r;\n}\n\ndouble toRad(double ang){ return ang*PI/180.0; }\n\nPoint rotate(const Point &bp,const Point &p,double th){\n  double x = p.x, y = p.y;\n  return Point(cos(th)*x-sin(th)*y+bp.x,sin(th)*x+cos(th)*y+bp.y);\n}\n\nvoid makeStar(vector<Star> &stars){\n  int N = stars.size();\n  for(int i = 0 ; i < N ; i++){\n    double x = stars[i].x, y = stars[i].y;\n    double r = stars[i].r, a = stars[i].a;\n    Point bp(x,y), p(x,y+r); p = p - bp;\n    p = rotate(bp,p,toRad(a));\n    vector<Point> ps(5);\n    for(int j = 0 ; j < 5 ; j++){\n      ps[j] = p;\n      p = p - bp;\n      p = rotate(bp,p,toRad(72));\n    }\n    stars[i].segs.resize(5);\n    stars[i].segs[0] = Segment(ps[0],ps[2]);\n    stars[i].segs[1] = Segment(ps[0],ps[3]);\n    stars[i].segs[2] = Segment(ps[1],ps[3]);\n    stars[i].segs[3] = Segment(ps[1],ps[4]);\n    stars[i].segs[4] = Segment(ps[2],ps[4]);\n  }\n}\n\nint main(){\n  int N,M,L;\n  while(cin >> N >> M >> L, N){\n    vector<Star> stars(N);\n    M--; L--;\n    for(int i = 0 ; i < N ; i++){\n      cin >> stars[i];\n    }\n    makeStar(stars);\n    double d[MAX_N][MAX_N];\n    fill(d[0],d[0]+N*N,INF);\n    for(int i = 0 ; i < N ; i++){\n      d[i][i] = 0;\n      for(int j = i+1 ; j < N ; j++){\n        double dist = INF;\n        for(int k = 0 ; k < 5 ; k++){\n          for(int l = 0 ; l < 5 ; l++){\n            Segment s1 = stars[i].segs[k];\n            Segment s2 = stars[j].segs[l];\n            dist = min(dist,distanceSS(s1,s2));\n          }\n        }\n        d[i][j] = d[j][i] = dist;\n      }\n    }\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\",d[M][L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS 1e-10\n#define INF 1e8\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Poly;\nstatic const double pi = acos(-1.0);\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < -EPS) return 2;\n  if(norm(b-a)+EPS < norm(c-a))return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble p_to_s_dist(P p, L s){\n  if(dot(p-s.first,s.second-s.first) >= 0 &&\n     dot(p-s.second,s.first-s.second) >= 0) return abs(cross(p-s.first,s.second-s.first))/abs(s.second-s.first);\n  return min(abs(p-s.first),abs(p-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\ndouble Poly_to_Poly_dist(Poly a, Poly b){\n  double dist = INF;\n  int na = a.size(), nb = b.size();\n  a.push_back(a[0]);\n  b.push_back(b[0]);\n  for(int i = 0; i < na; ++i){\n    for(int j = 0; j < na; ++j){\n      dist = min(dist,s_to_s_dist(L(a[i],a[i+1]),L(b[j],b[j+1])));\n    }\n  }\n  return dist;\n}\n\nPoly star(P p, double r, double a){\n  Poly ret;\n  for(int i = 0; i < 5; ++i){\n    ret.push_back(P(polar(r,(a+90+144*i)/360*2*pi)+p));\n  }\n  return ret;\n}\n\nint main(){\n  int N, M, L;\n  double x, y, a, r;\n  while(cin >> N >> M >> L, N){\n    vector<Poly> stars(N);\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y >> a >> r;\n      stars[i] = star(P(x,y),r,a);\n    }\n    vector< vector<double> > WF(N, vector<double>(N, INF));\n    for(int i = 0; i < N; ++i){\n      for(int j = i; j < N; ++j){\n\tif(i == j) WF[i][j] = 0;\n\telse{\n\t  WF[i][j] = Poly_to_Poly_dist(stars[i],stars[j]);\n\t  WF[j][i] = WF[i][j];\n\t}\n      }\n    }\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n\tfor(int j = 0; j < N; ++j){\n\t  WF[i][j] = min(WF[i][j], WF[i][k] + WF[k][j]);\n\t}\n      }\n    }\n    printf(\"%.10lf\\n\", WF[M-1][L-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, int> PD;\ntypedef pair<double, double> PDD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define pi acos(-1)\n\nP vv[] = {P(0, 2), P(2, 4), P(4, 1), P(1, 3), P(3, 0)};\n\nstruct Star {\n  PDD v[5];\n};\n\nPDD operator-(const PDD &a, const PDD &b) {\n  return PDD(a.fi - b.fi, a.se - b.se);\n}\n\ndouble len(PDD p) {\n  return sqrt(p.fi * p.fi + p.se * p.se);\n}\n\ndouble dot(PDD a, PDD b) {\n  return a.fi * b.fi + a.se * b.se;\n}\n\ndouble cross(PDD a, PDD b) {\n  return a.fi * b.se - a.se * b.fi;\n}\n\ndouble distance(PDD p1, PDD p2, PDD q1, PDD q2) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    return 0;\n  } else {\n    double mini = INF;\n    if (dot(p2 - p1, q1 - p1) < 1e-7) minch(mini, len(q1 - p1));\n    else if (dot(p1 - p2, q1 - p2) < 1e-7) minch(mini, len(q1 - p2));\n    else minch(mini, abs(cross(p2 - p1, q1 - p1)) / len(p2 - p1));\n\n    if (dot(p2 - p1, q2 - p1) < 1e-7) minch(mini, len(q2 - p1));\n    else if (dot(p1 - p2, q2 - p2) < 1e-7) minch(mini, len(q2 - p2));\n    else minch(mini, abs(cross(p2 - p1, q2 - p1)) / len(p2 - p1));\n\n    if (dot(q2 - q1, p1 - q1) < 1e-7) minch(mini, len(p1 - q1));\n    else if (dot(q1 - q2, p1 - q2) < 1e-7) minch(mini, len(p1 - q2));\n    else minch(mini, abs(cross(q2 - q1, p1 - q1)) / len(q2 - q1));\n\n    if (dot(q2 - q1, p2 - q1) < 1e-7) minch(mini, len(p2 - q1));\n    else if (dot(q1 - q2, p2 - q2) < 1e-7) minch(mini, len(p2 - q2));\n    else minch(mini, abs(cross(q2 - q1, p2 - q1)) / len(q2 - q1));\n\n    return mini;\n  }\n}\n\nint main(){\n  // cin.sync_with_stdio(false);\n  int n, m, l;\n  while(cin >> n >> m >> l, n) {\n    m--, l--;\n    Star s[n];\n    rep(i, n) {\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      a = a / 180.0 * pi;\n      rep(j, 5) s[i].v[j] = PDD(x + (-1) * r * sin(a + 2 * j * pi / 5.0), y + r * cos(a + 2 * j * pi / 5.0));\n    }\n\n    priority_queue<PD, vector<PD>, greater<PD>> q;\n    q.push(PD(0, m));\n    bool visited[n] = {};\n    double ans = -1;\n    while(!q.empty()) {\n      PD p = q.top(); q.pop();\n\n      if (p.se == l) {\n        ans = p.fi;\n        break;\n      }\n\n      if (visited[p.se]) continue;\n      else visited[p.se] = true;\n\n      rep(i, n) {\n        if (i == p.se) continue;\n        if (!visited[i]) {\n          double mini = INF;\n          rep(j, 5)rep(k, 5) {\n            minch(mini, distance(s[p.se].v[vv[j].fi], s[p.se].v[vv[j].se], s[i].v[vv[k].fi], s[i].v[vv[k].se]));\n          }\n          q.push(PD(p.fi + mini, i));\n        }\n      }\n    }\n\n    printf(\"%.10f\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\n\n\nusing namespace std;\n\nconst long double EPS = 1e-8;\nconst long double INF = 1e12;\ntypedef complex<long double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nlong double cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\nlong double dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  long double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nlong double distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\nlong double distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nclass Star{\npublic:\n\tvector<L> star;\n\tvoid add(P p1,P p2){\n\t\tstar.push_back(L(p1,p2));\n\t}\n\t\n\tlong double dist(const Star &s){\n\t\tlong double res=INF;\n\t\tfor(int i=0;i<star.size();i++){\n\t\t\tfor(int j=0;j<s.star.size();j++){\n\t\t\t\tres=min(res,distanceSS(star[i],s.star[j]));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n};\n\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tvector<Star> stars(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,a,r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\t\n\t\t\tlong double theta=M_PI/180.0*a;\n\t\t\tlong double theta2=M_PI/180.0*72.0;\n\t\t\t\n\t\t\tvector<P> p(5);\n\t\t\t\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tp[j]=P(0,r)*polar((long double)1.0,theta+j*theta2)+P(x,y);\n\t\t\t\t//cout<<p[j]<<endl;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tstars[i].add(p[(2*j)%5],p[(2+2*j)%5]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<long double> > dist(n,vector<long double>(n));\n\t\tfor(int i=0;i<n;i++) dist[i][i]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) dist[i][j]=dist[j][i]=stars[i].dist(stars[j]);\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<setprecision(10)<<dist[m-1][l-1]<<endl;;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define pb push_back\n\n\n\nint N,M,LL;\ndouble d[128][128];\n\ntypedef complex<double> P;\nbool operator < (const P& a, const P& b){\n\treturn  real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n\tL(){}\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\ntypedef vector<P> G;\nstruct C {\n\tP p;double r;\n\tC(const P &p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c){\n\tb -= a;c -=a;\n\tif( cross(b,c)>0)return +1;\n\tif(cross(b,c) < 0) return -1;\n\tif(dot(b,c) < 0) return +2;\n\tif(norm(b) < norm(c)) return -2;\n}\n\nbool intersectLL(const L& l, const L& m){\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nbool intersectSS(const L&s, const L &t){\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nbool intersectSP(const L &s, const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\nP projection(const L &l, const P &p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P& p){\n\treturn abs(p - projection(l,p));\n}\n\ndouble distanceLL(const L &l, const L &m){\n\treturn intersectLL(l,m) ? 0 : distanceLP(l, m[0]);\n}\n\ndouble distanceSP(const L&s, const P &p){\n\tconst P r = projection(s,p);\n\tif(intersectSP(s,r)) return abs(r-p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble distanceSS(const L &s, const L &t){\n\tif(intersectSS(s,t)) return 0;\n\treturn min(min(distanceSP(s,t[0]), distanceSP(s,t[1])),min(distanceSP(t,s[0]), distanceSP(t,s[1])));\n}\n\ndouble tod(double r){\n\treturn M_PI * r / 180;\n}\n\nstruct star{\n\tP p[5];\n\tL l[5];\n\tstar(double x, double y, double a, double r){\n\t\tdouble n = 72;\n\t\ta+=90;\n\t\trep(i,5){\n\t\t\tp[i] = P(x+r*cos(tod(a+n*i)), y+r*sin(tod(a+n*i)));\n\t\t}\n\t\tl[0] = L(p[0],p[2]);\n\t\tl[1] = L(p[0],p[3]);\n\t\tl[2] = L(p[1],p[3]);\n\t\tl[3] = L(p[1],p[4]);\n\t\tl[4] = L(p[2],p[4]);\n\t}\n};\n\n\nvoid init(){\n\trep(i, 128)rep(j,128)d[i][j] = INF;\n\trep(i,128)d[i][i]=0;\n}\n\t\n\n\nint main() {\n\t// your code goes here\n\twhile(1){\n\t\tcin >> N >> M >> LL;\n\t\tif( N == 0) break;\n\t\tint x,y,a,r;\n\t\tM--;\n\t\tLL--;\n\t\tinit();\n\t\tvector<star> stars;\n\n\t\trep(i,N){\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.pb(star(x,y,a,r));\n\t\t}\n\n\t\t\n\t\trep(i,N)rep(j,N){\n\t\t\trep(k,5)rep(kk,5){\n\t\t\t\td[i][j] = min(d[i][j], distanceSS(stars[i].l[k], stars[j].l[kk]));\n\t\t\t\td[j][i] = d[i][j];\n\t\t\t}\n\t\t}\n\n\n\t\trep(k,N)rep(i,N)rep(j,N){\n\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\n\t//\trep(i,5)rep(j,5)cout << i << \"-\" << j << \"->\" << d[i][j] << endl;\n\n\t\tcout << d[M][LL] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n\n#define ARG5(a, b, c, d, NAME, ...) NAME\n#define REP(...) ARG5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define REP1(a) REP2(i, a)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) ARG5(__VA_ARGS__, REPR4, REPR3, REPR2, REPR1)(__VA_ARGS__)\n#define REPR1(a) REPR2(i, a)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')\n#define TMPL_T template <typename T>\n#define TMPL_TU template <typename T, typename U>\n#define mut auto\n#define let const auto\n\nusing Int = long long;\n// clang-format off\nnamespace extio {\nstd::string delimiter=\" \",pdelimiter=\" \";\nstd::string bracket_b=\"\",bracket_e=\"\";\nvoid chdelim(const std::string&s){delimiter=s;}\nvoid chpdelim(const std::string&s){pdelimiter=s;}\nvoid chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}\nTMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}\nTMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}\n}\nnamespace std {\nTMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}\nTMPL_T istream& operator>>(istream&is,tuple<int&,vector<T>&>x)\n{int N=get<0>(x);vector<T>&v=get<1>(x);v.clear();v.reserve(N);REP(i,N){T a;is>>a;v.emplace_back(a);}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<vector<T>&,int&>x){return is>>tie(get<1>(x),get<0>(x));}\nTMPL_T istream& operator>>(istream&is,tuple<int&,T*>x){int N=get<0>(x);T*v=get<1>(x);REP(i,N){is>>v[i];}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<T*,int&>x){return is>>tie(get<1>(x),get<0>(x));}\n}\nTMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\nTMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\n\ninline int in(){int x;std::cin>>x;return x;}\n\n// clang-format on\n// }}}\n//{{{ orliv::graph::Graph\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <limits>\n#include <vector>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  using weight_type = long double;\n  static constexpr weight_type INF = std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\nusing Weight = Edge::weight_type;\nusing Edges = std::vector<Edge>;\nusing Weights = std::vector<Weight>;\nusing Path = std::vector<int>;\nusing Nodes = std::vector<int>;\n}\nusing Graph = std::vector<graph::Edges>;\n}\n#endif\n//}}}\n//{{{ dijkstra.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n#include <algorithm>\n#include <limits>\n#include <queue>\nnamespace orliv {\nnamespace graph {\nnamespace shortest_path {\nnamespace util {\nPath buildPath(int t, std::vector<int>& prev) {\n  Path path;\n  for (int u = t; u >= 0; u = prev[u]) {\n    path.emplace_back(u);\n  }\n  std::reverse(path.begin(), path.end());\n  return std::move(path);\n}\n}\nWeights dijkstra(const Graph& g, int s, std::vector<int>& prev) {\n  const int V = g.size();\n  auto inf = Edge::INF;\n  Weights dist(V, inf);\n  prev.assign(V, -1);\n\n  dist[s] = 0;\n  std::priority_queue<Edge> pq;\n  for (pq.emplace(-2, s, 0); !pq.empty();) {\n    auto e = pq.top();\n    pq.pop();\n    if (prev[e.to] != -1) continue;\n    prev[e.to] = e.from;\n    for (const auto& f : g[e.to]) {\n      if (dist[f.to] <= e.w + f.w) continue;\n      pq.emplace(f.from, f.to, dist[f.to] = e.w + f.w);\n    }\n  }\n  return std::move(dist);\n}\nWeights dijkstra(const Graph& g, int s) {\n  std::vector<int> prev;\n  return std::move(dijkstra(g, s, prev));\n}\nstd::pair<Weight, Path> dijkstra(const Graph& g, int s, int t) {\n  std::vector<int> prev;\n  auto ws = dijkstra(g, s, prev);\n  auto path = util::buildPath(t, prev);\n  return std::move(std::make_pair(ws[t], std::move(path)));\n}\n}\n}\n}\n//}}}\n\nusing namespace std;\n\nusing Real = double;\nusing P = std::complex<Real>;\nstruct L : vector<P> {\n  L(const P& a, const P& b) { push_back(a), push_back(b); }\n};\n\nconst Real EPS = 1e-8;\nReal cross(const P& a, const P& b) {\n  return imag(conj(a) * b);\n}\nReal dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return +1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c) < 0) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool intersect(const L& a, const L& b) {\n  return ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0 &&\n         ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\nbool intersectP(const L& s, const P& p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\nP projection(const L& l, const P& p) {\n  Real t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\nReal distanceP(const L& s, const P& p) {\n  const P r = projection(s, p);\n  if (intersectP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\nReal distance(const L& s, const L& t) {\n  if (intersect(s, t)) return 0;\n  return min({distanceP(s, t[0]), distanceP(s, t[1]), distanceP(t, s[0]), distanceP(t, s[1])});\n}\n\nstruct Star {\n  std::vector<P> ps;\n  Star(Real x, Real y, Real a, Real r) {\n    P base(x, y);\n    P p = std::polar(r, (a + 90) / 180.0 * M_PI);\n    P rot = std::polar(1.0, 0.4 * M_PI);\n    REP(5) {\n      ps.emplace_back(p + base);\n      p *= rot;\n    }\n  }\n  Real dist(const Star& other) const {\n    Real d = 1e9;\n    REP(i, 5) REP(j, 5) {\n      int ni = (i + 2) % 5;\n      int nj = (j + 2) % 5;\n      chmin(d, ::distance(L(ps[i], ps[ni]), L(other.ps[j], other.ps[nj])));\n    }\n    return d;\n  }\n};\n\nsigned main() {\n  int N, M, L;\n  while (N = in(), M = in(), L = in(), N || M || L) {\n    orliv::Graph g(N);\n    vector<Star> stars;\n    REP(i, N) {\n      Real x = in(), y = in(), a = in(), r = in();\n      stars.emplace_back(x, y, a, r);\n    }\n    REP(i, N) REP(j, N) {\n      if (i == j) continue;\n      auto d = stars[i].dist(stars[j]);\n      g[i].emplace_back(i, j, d);\n    }\n    printf(\"%.20Lf\\n\", orliv::graph::shortest_path::dijkstra(g, M - 1, L - 1).first);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\ntypedef complex<double> PT;\ntypedef PT VC;\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b) / abs(l.fi-l.se));\n}\n\nvector<PT> intersec_line_line(LN a, LN b) {\n\tvector<PT> res;\n\tif(abs(cross_prod(a.fi-a.se, b.fi-b.se)) < EPS)\n\t\treturn res;\n\tif(abs(cross_prod(b.fi-a.fi, b.se-a.fi)) < EPS)\n\t\tswap(a.fi, a.se);\n\t\n\tVC va, vb, vc;\n\tdouble s, t;\n\tva = b.fi - a.fi;\n\tvb = b.se - a.fi;\n\tvc = a.se - a.fi;\n\ts = cross_prod(va, vc) / cross_prod(va, vb);\n\tt = cross_prod(vc, vb) / cross_prod(va, vb);\n\tres.push_back(a.fi + (t * va + s * vb) / (s+t));\n\treturn res;\n}\n\nbool on_seg(PT p, SG a) {\n\tVC b, c;\n\tb = a.fi - p;\n\tc = a.se - p;\n\treturn dot_prod(b,c) < EPS && abs(cross_prod(b,c)) < EPS;\n}\n\nvector<PT> intersec_seg_seg(SG a, SG b) {\n\tvector<PT> tmp, res;\n\ttmp = intersec_line_line(a,b);\n\tfor(int i = 0; i < tmp.size(); i++) {\n\t\tif(on_seg(tmp[i], a) && on_seg(tmp[i],b))\n\t\t\tres.push_back(tmp[i]);\n\t}\n\treturn res;\n}\n\n\n// テ、ツサツ・テ、ツクツ甘・ツケツセテ、ツスツ陛」ツδゥテ」ツつ、テ」ツδ姪」ツδゥテ」ツδェテ・ツ?凖ァツオツ?\n\ndouble dist_pts_seg(PT p, SG a) {\n\tdouble res;\n\tres = min(abs(a.fi-p), abs(a.se-p));\n\tif(dot_prod(a.se - a.fi, p - a.fi) > -EPS\n\t\t\t&& dot_prod(a.fi - a.se, p - a.se) > -EPS)\n\t\tres = min(res, dist_pts_line(p, a));\n\treturn res;\n}\n\ndouble dist_seg_seg(SG a, SG b) {\n\tdouble res;\n\tres = min(\n\t\t\tmin(dist_pts_seg(a.fi,b), dist_pts_seg(a.se,b)),\n\t\t\tmin(dist_pts_seg(b.fi,a), dist_pts_seg(b.se,a)) );\n\tif(intersec_seg_seg(a,b).size())\n\t\tres = 0;\n\treturn res;\n}\n\n/* //テ・ツケツセテ、ツスツ陛」ツδ?」ツつケテ」ツδ?\nint main() {\n\tSG a(PT(0,0),PT(0,2));\n\tSG b(PT(-1,1),PT(2,1));\n\tcout << dist_seg_seg(a,b) << endl;\n} // */\n\n//*\nint N, M, L;\nvector<vector<SG> > star;\ndouble edge[120][120];\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nvoid init() {\n\tstar.clear();\n\trep(i,120) {\n\t\trep(j,120)\n\t\t\tedge[i][j] = 1e9;\n\t\tedge[i][i] = 0;\n\t}\n}\n\nint main() {\n\twhile(cin >> N >> M >> L, N || M || L) {\n\t\tinit();\n\t\tM--; L--;\n\t\trep(i,N) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<PT> tmp;\n\t\t\tdouble theta = (a+90) / 180.0 * M_PI;\n\t\t\tdouble phi = 360.0 / 5.0 / 180.0 * M_PI;\n\t\t\trep(i,5) {\n\t\t\t\ttmp.push_back(polar((double)r, theta + phi * i) + PT(x,y));\n\t\t\t//\tcout << tmp[i] << endl;\n\t\t\t}\n\t\t\tvector<SG> push;\n\t\t\trep(i,5) {\n\t\t\t\tpush.push_back(SG(tmp[i],tmp[(i+2)%5]));\n\t\t\t}\n\t\t\tstar.push_back(push);\n\t\t}\n\n\t\trep(i,N) {\n\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\tdouble tmp = 1e9;\n\t\t\t\trep(k,5) {\n\t\t\t\t\trep(l, 5) {\n\t\t\t\t\t\ttmp = min(tmp, dist_seg_seg(star[i][k], star[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\trep(i,N) {\n\t\t\trep(j,N) {\n\t\t\t\trep(k,N) {\n\t\t\t\t\tedge[j][k] = min(edge[j][k], edge[j][i] + edge[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", edge[L][M]);\n\t}\n}\n// */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = complex<double>;\n\nconst double eps = 1e-7;\n\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\ndouble cross(P a, P b) {\n  return (conj(a) * b).imag();\n}\n\nint ccw(P a, P b, P c) {\n  if(cross(b-a, c-a) > eps) return 1;\n  if(cross(b-a, c-a) < -eps) return -1;\n  if(dot(b-a, c-a) < -eps) return -2;\n  if(dot(a-b, c-b) < -eps) return 2;\n  return 0;\n}\n\nbool isIntersectedSS(P a1, P a2, P b1, P b2) {\n  int a = ccw(b1, b2, a1);\n  int b = ccw(b1, b2, a2);\n  int c = ccw(a1, a2, b1);\n  int d = ccw(a1, a2, b2);\n\n  return a * b <= 0 && c * d <= 0;\n}\n\ndouble distanceSP(P a, P b, P c) {\n  if(dot(b-a, c-a) < eps) return abs(c-a);\n  if(dot(a-b, c-b) < eps) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersectedSS(a1, a2, b1, b2)) return 0;\n\n  return min({\n              distanceSP(a1, a2, b1),\n              distanceSP(a1, a2, b2),\n              distanceSP(b1, b2, a1),\n              distanceSP(b1, b2, a2),\n    });\n}\n\nbool solve() {\n  int N, M, L;\n  int x[101], y[101], a[101], r[101];\n  P points[101][5];\n\n  cin >> N >> M >> L;\n\n  if (N == 0) return false;\n\n  for(int i=0; i<N; i++) {\n    cin >> x[i] >> y[i] >> a[i] >> r[i];\n    a[i] += 90;\n\n    for(int j=0; j<5; j++) {\n      double sx = cos((j * 72 + a[i]) / 180.0 * M_PI) * r[i] + x[i];\n      double sy = sin((j * 72 + a[i]) / 180.0 * M_PI) * r[i] + y[i];\n      points[i][j] = P(sx, sy);\n    }\n  }\n\n  double dist[101][101];\n\n  for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n      dist[i][j] = (i != j) * 1e17;\n\n  for(int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n\n      for(int i2=0; i2<5; i2++) {\n        for(int j2=0; j2<5; j2++) {\n          dist[i][j] = dist[j][i] =\n            min(dist[i][j], getDistance(points[i][i2], points[i][(i2+2)%5],\n                                        points[j][j2], points[j][(j2+2)%5])\n                );\n        }\n      }\n    }\n  }\n\n  for(int k=0; k<N; k++)\n    for(int i=0; i<N; i++)\n      for(int j=0; j<N; j++)\n        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\n  printf(\"%.10lf\\n\", dist[M-1][L-1]);\n\n\n  return true;\n}\n\nint main(){\n  while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-11;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 2. * PI / 5.));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e9;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m, l;\n\nvector<Point> p[110];\n\nnamespace std {\n\tbool operator < (const Point& a, const Point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const Point& a, const Point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<Point> {\n\tL(const Point &a, const Point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<Point> G;\n\nstruct C {\n\tPoint p; double r;\n\tC(const Point &p, double r) : p(p), r(r) { }\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // a → b で半時計方向に折れて b → c\n\tif (cross(b, c) < 0)   return -1;       // a → b で時計方向に折れて b → c\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\t\t\t\t\t\t\t\t// a → b で逆を向いて b → c ( または b == c )\n}\n\ndouble dist(Point p) { return abs(p); }//ベクトルpの絶対値\ndouble dist(Point a, Point b) {//2点間の距離\n\treturn abs(a - b);\n}\n\nPoint rot(Point p, double a) {//aはrad\n\tdouble x1 = p.real(), y1 = p.imag();\n\treturn Point(x1*cos(a) - y1*sin(a), x1*sin(a) + y1*cos(a));\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//交差判定\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || \n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   \n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*    \n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; \n}\nbool intersectLP(const L &l, const Point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const Point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\n// 点a,bを通る直線と点cとの距離(cross(x,y)=|x||y|sinθ)\ndouble distanceLP(Point a, Point b, Point c) {\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceSP(Point a, Point b, Point c) {\n\tif (dot(b - a, c - a) < EPS) return abs(c - a);\n\tif (dot(a - b, c - b) < EPS) return abs(c - b);\n\treturn distanceLP(a, b, c);\n}\n\n// 点a1,a2を端点とする線分と点b1,b2を端点とする線分との距離\ndouble distanceSS(Point a1, Point a2, Point b1, Point b2) {\n\tL a = L(a1, a2);\n\tL b = L(b1, b2);\n\tif (intersectSS(a, b))return 0.0;\n\treturn min(min(distanceSP(a1, a2, b1), distanceSP(a1, a2, b2)),\n\t\tmin(distanceSP(b1, b2, a1), distanceSP(b1, b2, a2)));\n}\n\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t};\n\n\tdouble d[100010];\n\tvector<edge> G[100010];//各頂点からの辺\n\n\tvoid clear() {\n\t\trep(i, 100010)G[i].clear();\n\t}\n\n\tvoid dijkstra(int start) {\n\t\tfill(d, d + 100010, INF);\n\t\td[start] = 0;\n\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, start));\n\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second;\n\t\t\tif (d[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m >> l&&n + m + l) {\n\t\tm--; l--;\n\t\trep(i, 110)p[i].clear();\n\t\tdk.clear();\n\t\trep(i, n) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tPoint po = Point(0, r);\n\t\t\tpo = rot(po, 2 * PI *a / 360);\n\t\t\trep(j, 5) {\n\t\t\t\tp[i].push_back(po + Point(x, y));\n\t\t\t\tpo = rot(po, 2 * PI / 5);\n\t\t\t}\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\trep(j, 5) {\n\t\t//\t\tcout << p[i][j].real() << \" \" << p[i][j].imag() << endl;\n\t\t//\t}\n\t\t//}\n\t\trep(i, n) {\n\t\t\tFOR(j, i + 1, n) {\n\t\t\t\tdouble mind = INF;\n\t\t\t\trep(k, p[i].size()) {\n\t\t\t\t\trep(l, p[j].size()) {\n\t\t\t\t\t\tmind = min(distanceSS(p[i][k], p[i][(k + 2) % 5],\n\t\t\t\t\t\t\tp[j][l], p[j][(l + 2) % 5]), mind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << mind << endl;\n\t\t\t\tdk.G[i].push_back({ j,mind });\n\t\t\t\tdk.G[j].push_back({ i,mind });\n\t\t\t}\n\t\t}\n\t\tdk.dijkstra(m);\n\t\tprintf(\"%.20lf\\n\", dk.d[l]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n#include <complex>\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\ninline double cross(const Point& a, const Point& b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n  return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n  b -= a; c -= a;\n  double len = abs(b) * abs(c);\n  if(cross(b, c) > +EPS * len) return +1; // counter-clockwise\n  if(cross(b, c) < -EPS * len) return -1; // clockwise\n  if(dot(b, c) < 0) return +2; // c--a--b\n  if(norm(b) < norm(c)) return -2; // a--b--c\n  return 0; // a--c--b \n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ntypedef pair<double, int> P;\nint main(){\n  int N, M, L;\n  while(cin>>N>>M>>L && N){\n    M--; L--;\n    double x[100], y[100], a[100], r[100];\n    REP(i, N){\n      cin>>x[i]>>y[i]>>a[i]>>r[i];\n    }\n    vector<Line> lines(N * 5);\n    REP(i, N){\n      Point ps[5];\n      REP(j, 5) ps[j] = Point(x[i] + r[i] * cos(M_PI*(90.0 + a[i] + 72 * j)/180.0), y[i] + r[i] * sin(M_PI*(90.0 + a[i] + 72 * j)/180));\n      REP(j, 5) lines[5 * i + j] = Line(ps[j], ps[(j + 2) % 5]);\n    }\n    vector<double> dist(N * 5, INF);\n    priority_queue<P, vector<P>, greater<P> > que;\n    REP(i, 5){\n      dist[5 * M + i] = 0;\n      que.push(P(0, 5 * M + i));\n    }\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int u = p.second;\n      if(dist[u] != p.first) continue;\n      REP(i, N * 5){\n        double next = dist[u] + distanceSS(lines[u], lines[i]);\n        if(next < dist[i]){\n          dist[i] = next;\n          que.push(P(next, i));\n        }\n      }\n    }\n    printf(\"%.10f\\n\", dist[5*L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<iomanip>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define EPS 1e-7\n#define S second\n#define pb push_back\n#define PI 3.14159265358979\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,P> PP;\nint N,M,L;\nclass Point{\npublic:\n  double x,y;\n \n  Point (double x=0,double y=0):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (Point p){return Point(x*p.x,y*p.y);}\n  Point operator / (Point p){return Point(x/p.x,y/p.y);}\n \n  bool operator < (const Point &p)const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n \n  bool operator == (const Point &p)const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n \n};\n \nvector<Point> Set[110];\n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble getDistance(Point a,Point b){\n  return abs(a-b);\n}\n \n \nvoid make_coordinates(double x,double y,double a,double r,int ind){\n  Point s1,s2;\n  //cout <<\"i = \" << ind << endl;\n  s1.x = 0; s1.y = 0; s2.x = x; s2.y = y;\n \n  Point s;\n  double dir = M_PI*a/180.0,pre = M_PI*72.0/180.0;\n  s.x = 0; s.y = r;\n   \n  //cout << endl << \"x = \" << x << \",y = \" << y << \", a = \" << a <<\",r = \" << r<< \"-----------\" << endl;\n  for(int i=0;i<5;i++){\n    Point p; \n    p.x = s.x*cos(dir+pre*i) - s.y*sin(dir+pre*i) + x;\n    p.y = s.x*sin(dir+pre*i) + s.y*cos(dir+pre*i) + y;\n    Set[ind].pb(p);\n    //cout << \"p.x = \" << p.x << \",p.y = \" << p.y  << \",cost = \" << cos(dir+pre*i) << \",sin = \" << sin(dir+pre*i) << endl;\n  }\n \n \n}\nint main(){\n  while(true){\n    cin >> N >> M >> L;\n    if(N+M+L == 0)break;\n    rep(i,110)Set[i].clear();\n    rep(i,N){\n      double x,y,a,r;\n      cin >> x >> y >> a >> r;\n      make_coordinates(x,y,a,r,i);\n    }\n    double d[N*5+6][N*5+6];\n    rep(i,N*5)rep(j,N*5)d[i][j] = INF;\n    /*\n    rep(i,N){\n      rep(k,5){\n    rep(j,N){\n      //if(i == j)continue;\n      rep(l,5){\n        d[i*5+k][j*5+l] = d[j*5+l][i*5+k] = getDistance(Set[i][k],Set[j][l]);\n        if(i == j)d[i*5+k][j*5+l] = d[j*5+l][i*5+k] = 0;\n      }\n    }\n      }\n    }\n    */\n\n    rep(i,N){\n      REP(j,i,N){\n\trep(k,5){\n\t  rep(l,5){\n\t    d[i][j] = min(d[i][j],getDistance(Set[i][k],Set[j][l]));\n\t    d[j][i] = min(d[i][j],d[j][i]);\n\t  }\n\t}\n      }\n    }\n\n\n \n    rep(k,N)rep(i,N)rep(j,N)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n    double ans = INF;\n    /*\n    rep(i,5){\n      rep(j,5){\n\tans = min(d[(M-1)*5+i][(L-1)*5+j],ans);\n    //ans = min(d[(L-1)*5+i][(M-1)*5+j],ans);\n      }\n    }\n    */\n    cout << setiosflags(ios::fixed) << setprecision(20) << d[(M-1)][(L-1)] << endl;\n \n \n \n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, PI/2 + a/180.*PI + j*2*PI/5), p + polar(r, PI/2 + a/180.*PI + (j+1)*2*PI/5));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n//#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nusing T = tuple<int64, int64, int64>;\n\nclass UnionFind{\nprivate:\n  ::std::vector<int_fast32_t> par;\n  size_t n;\n\npublic:\n  UnionFind(){}\n  UnionFind(size_t n):n(n){\n    par.resize(n, -1);\n  }\n\n  uint_fast32_t find(uint_fast32_t x){\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  size_t size(uint_fast32_t x){\n    return -par[find(x)];\n  }\n\n  bool unite(uint_fast32_t x, uint_fast32_t y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return false;\n    if(size(x) < size(y)) std::swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool same(uint_fast32_t x, uint_fast32_t y){\n    return find(x) == find(y);\n  }\n};\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return res;\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n\n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<int> > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n\n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b);\n      G[b].emplace_back(a);\n    }\n  }\n  for(auto &v:G){\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\nconst int BTM = 0;\nconst int LFT = 1;\nconst int RGH = 2;\nconst int TOP = 3;\n\nint n=ss.size();\nvector<EndPoint> ep;\nfor(int i=0;i<n;i++){\nif(ss[i].p1.y==ss[i].p2.y){\nif(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\nep.emplace_back(ss[i].p1,i,LFT);\nep.emplace_back(ss[i].p2,i,RGH);\n}else{\nif(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);\nep.emplace_back(ss[i].p1,i,BTM);\nep.emplace_back(ss[i].p2,i,TOP);\n}\n}\nsort(ep.begin(),ep.end());\n\nset<int> bt;\nbt.insert(INF);\n\nint cnt=0;\nfor(int i=0;i<n*2;i++){\nif(ep[i].st==TOP){\nbt.erase(ep[i].p.x);\n}else if(ep[i].st==BTM){\nbt.emplace(ep[i].p.x);\n}else if(ep[i].st==LFT){\nauto b=bt.lower_bound(ss[ep[i].seg].p1.x);\nauto e=bt.upper_bound(ss[ep[i].seg].p2.x);\ncnt+=distance(b,e);\n}\n}\n\nreturn cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n      [&](Circle c,Point a,Point b){\n        Vector va=c.c-a,vb=c.c-b;\n        double f=cross(va,vb),res=0;\n        if(equals(f,0.0)) return res;\n        if(max(abs(va),abs(vb))<c.r+EPS) return f;\n        Vector d(dot(va,vb),cross(va,vb));\n        if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n          return c.r*c.r*atan2(d.y,d.x);\n        auto u=getCrossPointCS(c,Segment(a,b));\n        if(u.empty()) return res;\n        if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n        u.emplace(u.begin(),a);\n        u.emplace_back(b);\n        for(int i=1;i<(int)u.size();i++)\n          res+=dfs(c,u[i-1],u[i]);\n        return res;\n      };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int64 N, M, L;\n  while (cin >> N >> M >> L && N + M + L) {\n    M--; L--;\n    vector<Segment> vs(N*5);\n    REP(i, N) {\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      vector<Point> ps;\n      REP(j, 5) {\n        double theta = a/180*M_PI + j * 2*M_PI / 5;\n        double dx = -r*sin(theta), dy = r*cos(theta);\n        ps.emplace_back(x+dx, y+dy);\n      }\n      REP(j, 5) {\n        vs[i*5+j] = Segment(ps[j], ps[(j+2)%5]);\n      }\n    }\n    using PDL = pair<double, int64>;\n    vector<vector<PDL>> G(N*5);\n    REP(i, 5*N) {\n      REP(j, 5*N) {\n        if (i == j) continue;\n        G[i].emplace_back(getDistanceSS(vs[i], vs[j]), j);\n      }\n    }\n    vector<double> d(N*5, INF_LL);\n    using PDD = pair<double, double>;\n    d[5*M] = 0;\n    priority_queue<PDL, vector<PDL>, greater<PDL>> pq;\n    pq.emplace(d[5*M], 5*M);\n    while (pq.size()) {\n      int64 vv;\n      double dd;\n      tie(dd, vv) = pq.top(); pq.pop();\n      if (d[vv] < dd) continue;\n      REP(i, G[vv].size()) {\n        if (d[G[vv][i].sc] > dd + G[vv][i].fs) {\n          d[G[vv][i].sc] = dd + G[vv][i].fs;\n          pq.emplace(d[G[vv][i].sc], G[vv][i].sc);\n        }\n      }\n    }\n    cout << fixed << setprecision(10) << d[5*L] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n\n\nusing namespace std;\n\n#define rep(i,n) for(i=0;i<n;i++)\n#define pow2(n) ((n)*(n))\n\n\nconst double pi=3.141592653589793;\n\ntypedef pair <double,int> P;\npriority_queue<P,vector<P>,greater<P> > Q;\n\ndouble star[500][2];\ndouble S[500][500];\n\ndouble R[500];\n\nconst double DINF = 1.0e+21;\n\n\nint main(void)\n{\n\twhile(1){\n\t\tint N,M,L;\n\t\tint x,y,a,r;\n\t\tint i,j;\n\t\tdouble l,sita,cost;\n\t\tP p;\n\t\t\n\t\tdouble x1,x2,x3,x4,y1,y2,y3,y4,ta,tb,tc,td;\n\t\t\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\t\n\t\trep(i,5*N)R[i]=DINF;\n\t\t\n\t\tif(N==0 && M==0 && L==0)return 0;\n\t\t\n\t\trep(i,N){\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&a,&r);\n\t\t\trep(j,5){\n\t\t\t\tsita=((90+a+72*j)%360)*pi/180;\n\t\t\t\t\n\t\t\t\tstar[i*5+j][0]=x+r*cos(sita);\n\t\t\t\tstar[i*5+j][1]=y+r*sin(sita);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t//rep(i,N)rep(j,5)printf(\"$  %d,%d :%lf,%lf  [%lf]\\n\",i,j,star[i*5+j][0],star[i*5+j][1],star[i*5+j][0]*star[i*5+j][0]+star[i*5+j][1]*star[i*5+j][1]);\n\t\t\n\t\t\n\t\t\n\t\trep(i,5*N){\n\t\t\trep(j,5*N){\n\t\t\t\tif(i/5 == j/5){\n\t\t\t\t\tS[i][j]=S[j][i] = 0.0;continue;\n\t\t\t\t}\n\t\t\t\tl=sqrt(pow2(star[i][0]-star[j][0])+pow2(star[i][1]-star[j][1]));\n\t\t\t\tS[i][j]=S[j][i] = l;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t//rep(i,N*5)rep(j,N*5)printf(\"#  %d~%d :%lf\\n\",i,j,S[i][j]);\n\t\t\n\t\trep(i,5*N){\n\t\t\trep(j,5*N){\n\t\t\t\tif(i/5 == j/5)continue;\n\t\t\t\t\n\t\t\t\tbool intersectionEX=true;\n\t\t\t\t\n\t\t\t\tif(x1 >= x2){\n\t\t     \t\t\tif(((x1 < x3 && x1 < x4) || (x2 > x3 && x2 > x4))){\n\t\t\t    \t\t\tintersectionEX = false;\n\t\t\t\t\t}\n\t\t    \t\t}else{\n\t\t\t\t\tif((x2 < x3 && x2 < x4) || (x1 > x3 && x1 > x4)){\n\t\t\t    \t\t\tintersectionEX = false;\n\t\t\t\t\t}\n\t\t   \t\t}\n\t\t\t   \tif(intersectionEX){\n\t\t\t    \t\tif(y1 >= y2){\n\t\t\t\t\t\tif((y1 < y3 && y1 < y4) || (y2 > y3 && y2 > y4)){\n\t\t\t\t    \t\t\tintersectionEX = false;\n\t\t\t\t\t\t}\n\t\t\t    \t\t}else{\n\t\t\t\t\t\tif ((y2 < y3 && y2 < y4) || (y1 > y3 && y1 > y4)){\n\t\t\t\t    \t\t\tintersectionEX = false;\n\t\t\t\t\t\t}\n\t\t\t    \t\t}\n\t\t    \t\t}\n\t\t    \t\tif(intersectionEX){\n\t\t    \t\t\tif (((x1 - x2) * (y3 - y1) + (y1 - y2) * (x1 - x3)) * ((x1 - x2) * (y4 - y1) + (y1 - y2) * (x1 - x4)) >= 0.0){\n\t\t\t\t\t\tintersectionEX = false;\n\t\t    \t\t\t}\n\t\t    \t\t\tif (((x3 - x4) * (y1 - y3) + (y3 - y4) * (x3 - x1)) * ((x3 - x4) * (y2 - y3) + (y3 - y4) * (x3 - x2)) >= 0.0){\n\t\t\t\t\t\tintersectionEX = false;\n\t\t    \t\t\t}\n\t\t    \t\t}\n\t\t    \t\t//intersectionEX = True\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tx1 = star[i][0];\n\t\t\t\ty1 = star[i][1];\n\t\t\t\t\n\t\t\t\tx2 = star[i/5+ (i+2)%5][0];\n\t\t\t\ty2 = star[i/5+ (i+2)%5][1];\n\t\t\t\t\n\t\t\t\tx3 = star[j][0];\n\t\t\t\ty3 = star[j][1];\n\t\t\t\t\n\t\t\t\tx4 = star[j/5+ (j+2)%5][0];\n\t\t\t\ty4 = star[j/5+ (j+2)%5][1];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tta=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\t\t\ttb=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\t\t\ttc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\t\t\ttd=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\t\t\n\t\t\t\t*/\n\t\t\t\tif(intersectionEX== false){\n\t\t\t\t\t//printf(\" cross(%d,%d)(%lf,%lf,%lf,%lf) %lf\\n\",i,j,ta,tb ,tc,td,S[i][j]);\n\t\t\t\t\tS[i][j]=S[j][i] = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t//rep(i,N*5)rep(j,N*5)printf(\"#  %d~%d :%lf\\n\",i,j,S[i][j]);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\trep(i,5){\n\t\t\tQ.push(P(0.0,(M-1)*5+i));\n\t\t}\n\t\t\n\t\t\n\t\twhile(!Q.empty()){\n\t\t\tp = Q.top();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\t//printf(\"#\");\n\t\t\tif(R[p.second]<=p.first)continue;\n\t\t\t//printf(\"%lf %d\\n\",p.first,p.second);\n\t\t\t\n\t\t\tR[p.second]=p.first;\n\t\t\t\n\t\t\trep(i,5*N){\n\t\t\t\tcost=p.first + S[p.second][i];\n\t\t\t\tif(R[i]<=cost)continue;\n\t\t\t\t//printf(\"push %lf %d\\n\",cost,i);\n\t\t\t\tQ.push(P(cost,i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lf\\n\",R[(L-1)*5]);\n\t\t\n\n\t}\n\treturn 0;\n}\n\n\n\n\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = x + ope.x;\n\t\ttmp.y = y + ope.y;\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = x - ope.x;\n\t\ttmp.y = y - ope.y;\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn x*ope.x + y*ope.y;\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn x*ope.y - y*ope.x;\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= 0;\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) < 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) < 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (s-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = d[min_i] + dist[min_i][i];\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+2)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tdouble d;\n\t\tdouble ang_k1, ang_k2, ang_l1, ang_l2;\n\t\tvec2d v_k1, v_k2, v_l1, v_l2;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.8f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;\t//counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;\t\t//c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;\t\t\t\t\t\t\t//a--c--b on line\n}\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv*cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n)\n\t{\n\t\tm--; l--;\n\t\tvector<Line> ls;\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<Point> p(5);\n\t\t\tREP(i, 5) p[i] = (Point(x, y) + Point(0, r) * Point(cos((a + i * 72) / 180 * PI), sin((a + i * 72) / 180 * PI)));\n\t\t\tREP(i, 5)\n\t\t\t{\n\t\t\t\tls.push_back(Line(p[i], p[(i + 1) % 5]));\n\t\t\t}\n\t\t}\n\t\tvector<weight> d(ls.size());\n\t\tGraph g(ls.size());\n\t\tREP(i, ls.size())REP(j, ls.size())\n\t\t{\n\t\t\tg[i].push_back(edge{ j, dist_ss(ls[i], ls[j]) });\n\t\t}\n\t\tdijkstra(g, d, m * 5);\n\t\tcout << D10 << d[l * 5] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\n// ?????????????????´???\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(0, 0), b(0, 0) {}\n\tLine(Point _a, Point _b) : a(_a), b(_b) {}\n};\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c??????????¨???¨???\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b????????§??´???\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c???????????´???\n\treturn 0;\t\t\t\t\t\t\t// a,c,b???????????´???\n}\n\n// ?????´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ??´????????????????????¨??????????????????\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\n// ???????????????????????¨??????????????????\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\n// ???????????´????????????????????????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(15);\n\tcin.sync_with_stdio(false);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<vector<Line>> segd(N, vector<Line>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tsegd[i][j] = Line(seg[i][j], seg[i][(j + 1) % 10]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_ss(segd[i][ii], segd[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nconst double PI = 3.14159265358979323846264;\n\ndouble deg2rad(double deg) {\n  return deg*PI/180;\n}\n\nP rotate(P p, P c, double d) {\n  return c+(p-c)*P(cos(d),sin(d));\n}\n\n\n#include <cstdio>\n\nconst int INF = 100000000;\nL star[200][5];\ndouble d[200][200];\n\ndouble diststar(int i,int j){\n  double ans = 1000000;\n  for (int ii=0; ii<5; ii++)\n    for (int ji=0; ji<5; ji++)\n      ans = min(ans,distanceSS(star[i][ii],star[j][ji]));\n  return ans;\n}\n\nint main() {\n  int n,m,l;\n  while(scanf(\"%d %d %d\",&n,&m,&l),n) {\n    for(int i=0; i<n; i++) {\n      double x,y,a,r;\n      scanf(\"%lf %lf %lf %lf\",&x,&y,&a,&r);\n      P c(x,y),up(x,y+r);\n      for (int j=0; j<5; j++) {\n\tP f = rotate(up,c,deg2rad(j*72+a));\n\tP t = rotate(up,c,deg2rad((j+1)*72+a));\n\tstar[i][j] = L(f,t);\n      }\n    }\n\n    for (int i=0; i<n; i++)\n      for (int j=0; j<n; j++)\n\td[i][j] = (i==j?0:diststar(i,j));\n\n    for (int k=0; k<n; k++)\n      for (int i=0; i<n; i++)\n\tfor (int j=0; j<n; j++)\n\t  d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n    printf(\"%.15f\\n\",d[m-1][l-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nconst double PI = 3.141592653589;\n\ndouble deg2rad(double deg) {\n  return deg*PI/180;\n}\n\nP rotate(P p, P c, double d) {\n  return c+(p-c)*P(cos(d),sin(d));\n}\n\n\n#include <cstdio>\n\nconst int INF = 100000000;\nL star[100][5];\ndouble d[100][100];\n\ndouble diststar(int i,int j){\n  double ans = 1000000;\n  for (int ii=0; ii<5; ii++)\n    for (int ji=0; ji<5; ji++) {\n      ans = min(ans,distanceSS(star[i][ii],star[j][ji]));\n    }\n  return ans;\n}\n\nint main() {\n  int n,m,l;\n  while(scanf(\"%d %d %d\",&n,&m,&l),n) {\n    for(int i=0; i<n; i++) {\n      double x,y,a,r;\n      scanf(\"%lf %lf %lf %lf\",&x,&y,&a,&r);\n      P c(x,y),up(x,y+r);\n      for (int j=0; j<5; j++) {\n\tP f = rotate(up,c,deg2rad(j*72+a));\n\tP t = rotate(up,c,deg2rad((j+1)*72+a));\n\tstar[i][j] = L(f,t);\n      }\n    }\n\n    for (int i=0; i<n; i++)\n      for (int j=0; j<n; j++) \n\td[i][j] = (i==j?0:diststar(i,j));\n\n    for (int k=0; k<n; k++)\n      for (int i=0; i<n; i++)\n\tfor (int j=0; j<n; j++)\n\t  d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n    printf(\"%.8f\\n\",d[m-1][l-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e8, pi = acos(-1.);\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\ndouble cross(const Point& a, const Point& b){\n    return imag(conj(a) * b);\n}\n\ndouble dot(const Point& a, const Point& b){\n    return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(const Point& a, const Point& b){\n        push_back(a); push_back(b);\n    }\n};\n\nPoint proj(const Line& l, const Point& p){\n    double t = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);\n    return l[0] + (l[1] - l[0]) * t;\n}\n\nbool interSP(const Line& s, const Point& p){\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps;\n}\n\nbool interSS(const Line& s, const Line& t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\ndouble distSP(const Line& s, const Point& p){\n    const Point r = proj(s, p);\n    return interSP(s, r)? abs(r - p): min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distSS(const Line& s, const Line& t){\n    return interSS(s, t)? 0: min({distSP(s, t[0]), distSP(s, t[1]), distSP(t, s[0]), distSP(t, s[1])});\n}\n\nint N, M, L;\n\ndouble solve(vector<vector<Line> >& pent){\n    vector<vector<double> > dist(N, vector<double>(N));\n    rep(i, N)rep(j, i){\n        dist[i][j] = inf;\n        for(auto s: pent[i])for(auto t: pent[j])chmin(dist[i][j], distSS(s, t));\n        dist[j][i] = dist[i][j];\n    }\n    rep(k, N)rep(i, N)rep(j, N)chmin(dist[i][j], dist[i][k] + dist[k][j]);\n    return dist[M][L];\n}\n\nint main(){\n    while(cin >> N >> M >> L, N|M|L){\n        M--; L--;\n        vector<vector<Line> > pent(N);\n        rep(i, N){\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            vector<Point> v;\n            rep(j, 5)v.push_back(Point(x, y) + polar(1. * r, (a + 72 * j) * pi / 180 + pi / 2));\n            rep(j, 5)pent[i].emplace_back(v[j], v[(j + 2) % 5]);\n        }\n        cout << fixed << setprecision(20) << solve(pent) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps&&cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p-r) : min(abs(p-s.a),abs(p-s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nPoint turn(Point x, ld r) {\n\tPoint res;\n\tld nx = real(x)*cos(r) - imag(x)*sin(r);\n\tld ny = real(x)*sin(r) + imag(x)*cos(r);\n\tres = { nx,ny };\n\treturn res;\n}\nstruct edge { int to; ld cost; };\ntypedef pair<ld, int> speP;\nint main(){\n\tcout << fixed << setprecision(10) << endl;\n\tint n, s, g;\n\twhile (cin >> n >> s >> g, n) {\n\t\ts--; g--;\n\t\tLine l[100][5];\n\t\trep(i, n) {\n\t\t\tld x, y, a, r; cin >> x >> y >> a >> r;\n\t\t\ta = a * pi / 180.0;\n\t\t\tPoint now = { 0,r };\n\t\t\tnow = turn(now, a);\n\t\t\tPoint c[5];\n\t\t\trep(j, 5) {\n\t\t\t\tc[j] = { real(now) + x,imag(now) + y };\n\t\t\t\tnow = turn(now, 2.0 * pi / 5.0);\n\t\t\t}\n\t\t\tl[i][0] = { c[0],c[2] };\n\t\t\tl[i][1] = { c[0],c[3] };\n\t\t\tl[i][2] = { c[1],c[3] };\n\t\t\tl[i][3] = { c[1],c[4] };\n\t\t\tl[i][4] = { c[2],c[4] };\n\t\t}\n\t\tvector<edge> G[100];\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tld cost = 100000;\n\t\t\t\trep(k1, 5) {\n\t\t\t\t\trep(k2, 5) {\n\t\t\t\t\t\tcost = min(cost, dist_ss(l[i][k1], l[j][k2]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i].push_back({ j,cost });\n\t\t\t\tG[j].push_back({ i,cost });\n\t\t\t}\n\t\t}\n\t\tld d[100];\n\t\trep(i, n) {\n\t\t\td[i] = 1000000;\n\t\t}\n\t\tpriority_queue<speP> q;\n\t\tq.push({ 0,s }); d[s] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tspeP x = q.top(); q.pop();\n\t\t\tint v = x.second;\n\t\t\tif (x.first > d[v])continue;\n\t\t\tint len = G[v].size();\n\t\t\trep(j, len) {\n\t\t\t\tint nex = G[v][j].to;\n\t\t\t\tld c = G[v][j].cost;\n\t\t\t\tif (d[nex] > d[v] + c) {\n\t\t\t\t\td[nex] = d[v] + c;\n\t\t\t\t\tq.push({ d[nex],nex });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << d[g] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-11;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 2. * PI / 5.));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e7;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdlib.h>\n#include <map>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <queue>\n#include <utility>\n#define llint long long\n#define inf 1e9\n#define eps 1e-8\n\nusing namespace std;\ntypedef pair<double, int> P;\n\nstruct vec2d{\n  double x, y;\n  vec2d(){}\n  vec2d(double x, double y){\n    this->x = x, this->y = y;\n  }\n  double add(double a, double b){\n    if(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n    return a+b;\n  }\n  vec2d operator+(vec2d ope){\n    return vec2d(add(x, ope.x), add(y, ope.y));\n  }\n  vec2d operator-(vec2d ope){\n    return vec2d(add(x, -ope.x), add(y, -ope.y));\n  }\n  vec2d operator*(double t){\n    return vec2d(x*t, y*t);\n  }\n  vec2d operator/(double t){\n    return vec2d(x/t, y/t);\n  }\n  double dot(vec2d ope){\n    return add(x*ope.x, y*ope.y);\n  }\n  double cross(vec2d ope){\n    return add(x*ope.y, -y*ope.x);\n  }\n  double norm(){\n    double d2 = dot(*this);\n    if(d2 > 0) return sqrt(d2);\n    return 0.0;\n  }\n};\n\ndouble distPP(vec2d p, vec2d q){\n  return (p-q).norm();\n}\ndouble distSP(vec2d p, vec2d q, vec2d x)\n{\n  if((x-p).dot(q-p)<=0) return distPP(p, x);\n  if((x-q).dot(p-q)<=0) return distPP(q, x);\n  return fabs((x-p).cross(q-p) / distPP(p,q));\n}\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n  return (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n  if((q-p).cross(s-r) == 0){\n    return isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\n  }\n  double t = (r-p).cross(s-r) / (q-p).cross(s-r);\n  vec2d x = p + (q-p)*t;\n  return isOnS(p, q, x) && isOnS(r, s, x);\n}\ndouble distSS(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n  if(isCross(p, q, r, s)) return 0;\n  double ret = distSP(p, q, r);\n  ret = min(ret, distSP(p, q, s));\n  ret = min(ret, distSP(r, s, p));\n  ret = min(ret, distSP(r, s, q));\n  return ret;\n}\n\nstruct edge{\n  int to;\n  double cost;\n  edge(){}\n  edge(int a, double b){\n    to = a, cost = b;\n  }\n};\n\nint n, s, t;\nvec2d l[505], r[505];\nvector<edge> G[505];\nint V;\ndouble dist[505];\n\nvoid dijkstra()\n{\n  for(int i = 0; i < V; i++) dist[i] = inf;\n  dist[s*5] = 0;\n\n  priority_queue<P, vector<P>, greater<P> > Q;\n  Q.push(make_pair(0.0, s*5));\n\n  int v; double d;\n  while(Q.size()){\n    d = Q.top().first;\n    v = Q.top().second;\n    Q.pop();\n    if(dist[v] < d) continue;\n    for(int i = 0; i < G[v].size(); i++){\n      if(dist[G[v][i].to] > d + G[v][i].cost){\n        dist[G[v][i].to] = d + G[v][i].cost;\n        Q.push(make_pair(dist[G[v][i].to], G[v][i].to));\n      }\n    }\n  }\n}\n\nint main(void)\n{\n  while(1)\n  {\n    cin >> n >> s >> t;\n    if(n == 0 && s == 0 && t == 0) break;\n    s--, t--;\n\n    int x, y, a, R;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y >> a >> R;\n      a += 90;\n      double ang = a * M_PI / 180.0, th = 72 * M_PI / 180.0;\n      for(int j = 0; j < 5; j++){\n        l[i*5+j] = vec2d(R * cos(ang+j*th), R * sin(ang+j*th)) + vec2d(x, y);\n        r[i*5+j] = vec2d(R * cos(ang+(j+2)*th), R * sin(ang+(j+2)*th)) + vec2d(x, y);\n      }\n    }\n    V = 5*n;\n    for(int i = 0; i < V; i++){\n      G[i].clear();\n      for(int j = 0; j < V; j++){\n        double dist = distSS(l[i], r[i], l[j], r[j]);\n        //cout << dist << \" \";\n        G[i].push_back(edge(j, dist));\n      }\n      //cout << endl;\n    }\n\n    dijkstra();\n\n    //for(int i = 0; i < 5*n; i++) cout << dist[i] << \" \"; cout << endl;\n\n    double ans = dist[t*5];\n    printf(\"%.11f\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nconstexpr double INF = numeric_limits<double>::max();\n\nconstexpr double EPS = 1e-8;\n\ndouble sq (const double v) { return v * v; }\n\nstruct Vec {\n    double x, y;\n    Vec () {}\n    ~Vec (){ }\n\n    Vec (double x_, double y_): x(x_), y(y_) {}\n\n    Vec operator + (const Vec& o) const { return Vec(x + o.x, y + o.y); }\n    Vec operator - (const Vec& o) const { return Vec(x - o.x, y - o.y); }\n};\n\ndouble inner_prod(const Vec p1, const Vec p2) { return p1.x * p2.x + p1.y * p2.y; }\n\nstruct line {\n    Vec p1, p2;\n\n    line (Vec p1_, Vec p2_): p1(p1_), p2(p2_) {}\n};\n\nstruct star {\n    double x, y, a, r;\n    star () {}\n    ~star () {}\n\n    star (double x_, double y_, double a_, double r_): x(x_), y(y_), a(a_), r(r_) {}\n\n    vector<Vec> get_vertices () {\n        vector<Vec> ret;\n\n        for (int j = 0; j < 5; ++j) {\n            const double rad = a + 72*j;\n\n            const double ret_x = x - r * sin(M_PI * rad / 180);\n            const double ret_y = y + r * cos(M_PI * rad / 180);\n\n            ret.emplace_back(ret_x, ret_y);\n        }\n\n        return ret;\n    }\n\n    vector<line> get_lines () {\n        vector<line> ret;\n\n        auto vs = get_vertices();\n        assert(vs.size() == 5);\n        for (int j = 0; j < 5; ++j) ret.emplace_back(vs[j], vs[(j+2)%5]);\n\n        return ret;\n    }\n};\n\ndouble dist_ps (const Vec p, const line l) {\n\n    if (inner_prod(p - l.p1, l.p2 - l.p1) <= 0 || inner_prod(p - l.p2, l.p1 - l.p2) <= 0) {\n        double d1 = sq(p.x - l.p1.x) + sq(p.y - l.p1.y);\n        double d2 = sq(p.x - l.p2.x) + sq(p.y - l.p2.y);\n\n        return min(d1, d2);\n    }\n\n    if (abs(l.p1.x * l.p2.y - l.p2.x * l.p1.y) < EPS) {\n        const double a = l.p1.x, b = l.p1.y;\n        return sq(a * p.x + b * p.y) / (a * a + b * b);\n    }\n\n    const double a = (l.p1.y - l.p2.y) / (l.p1.x * l.p2.y - l.p2.x * l.p1.y);\n    const double b = (l.p1.x - l.p2.x) / (l.p1.y * l.p2.x - l.p2.y * l.p1.x);\n    return sq(a * p.x + b * p.y + 1) / (a * a + b * b);\n}\n\ndouble put(const Vec p, const line l) {\n    double a, b, c;\n    if (abs(l.p1.x * l.p2.y - l.p2.x * l.p1.y) < EPS) {\n        a = l.p1.x; b = l.p1.y; c = 0;\n    } else {\n        a = (l.p1.y - l.p2.y) / (l.p1.x * l.p2.y - l.p2.x * l.p1.y);\n        b = (l.p1.x - l.p2.x) / (l.p1.y * l.p2.x - l.p2.y * l.p1.x);\n        c = 1;\n    }\n\n    return a * p.x + b * p.y + c;\n}\n\ndouble dist2lines(const line l1, const line l2) {\n    double ans = numeric_limits<double>::max();\n    if (put(l1.p1, l2) * put(l1.p2, l2) < 0 && put(l2.p1, l1) * put(l2.p2, l1) < 0) {\n        return 0;\n    }\n    ans = min(ans, dist_ps(l1.p1, l2));\n    ans = min(ans, dist_ps(l1.p2, l2));\n    ans = min(ans, dist_ps(l2.p1, l1));\n    ans = min(ans, dist_ps(l2.p2, l1));\n    return ans;\n}\n\n// --------------------------------------------------\n\nstruct state {\n    int pos; double dist;\n    state (int pos_, double dist_): pos(pos_), dist(dist_) {}\n\n    bool operator < (const state& o) const {\n        return dist > o.dist;\n    }\n};\n\n// --------------------------------------------------\n\nint N, M, L;\ndouble x[100], y[100], a[100], r[100];\n\ndouble graph[100][100];\n\ndouble solve() {\n    for (int j = 0; j < N; ++j) fill(graph[j], graph[j]+N, INF);\n    for (int j = 0; j < N; ++j) graph[j][j] = 0;\n\n    vector<star> stars;\n    for (int j = 0; j < N; ++j) stars.emplace_back(x[j], y[j], a[j], r[j]);\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            const vector<line> ls1 = stars[j].get_lines();\n            const vector<line> ls2 = stars[k].get_lines();\n\n            for (auto& e: ls1) {\n                for (auto& f: ls2) {\n                    graph[j][k] = graph[k][j] = min(graph[j][k], sqrt(dist2lines(e, f)));\n                }\n            }\n        }\n    }\n\n    double min_dist[100];\n    fill(min_dist, min_dist+N, INF);\n    min_dist[M] = 0;\n\n    priority_queue<state> pq;\n    pq.emplace(M, 0);\n\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n\n        if (st.dist > min_dist[st.pos]) { continue; }\n\n        for (int j = 0; j < N; ++j) {\n            if (j == st.pos) continue;\n\n            if (min_dist[j] > st.dist + graph[st.pos][j]) {\n                min_dist[j] = st.dist + graph[st.pos][j];\n\n                pq.emplace(j, min_dist[j]);\n            }\n        }\n    }\n\n    return min_dist[L];\n}\n\nint main() {\n    while (true) {\n        cin >> N >> M >> L;\n        if (N == 0 && M == 0 && L == 0) return 0;\n\n        --M; --L;\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j] >> a[j] >> r[j];\n        }\n\n        printf(\"%.12f\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//???????????????http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2402\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\n// ????????\\???\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n  return real(conj(a) * b);//conj::??±???????´???°\n}\n\n// ??????\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\n// ????????????\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW::counter clockwise\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n  if (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n  if (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n  if (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n  return 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\n//l::??´??????s::??????\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  //norm::??¶?????????2???\n  return l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint main(){\n\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n      int n,m,l;\n      cin >> n>>m>>l;\n\n      if(n==0) break;\n\n      Polygon stars[n];\n      ld dis[n][n];\n\n      for(int i=0;i<n;i++){\n          int x,y,a,r;cin>>x>>y>>a>>r;\n          for(int j=0;j<5;j++){\n              Point v=Point(x,y)+Point(r*cos((18+a+72*j)*(2*PI)/360),r*sin((18+a+72*j)*(2*PI)/360));\n              stars[i].push_back(v);\n          }\n      }\n\n      for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n          if(i==j) dis[i][j]=0.0;\n          else dis[i][j]=INF;\n      }\n\n      for(int i=0;i<n;i++){\n          for(int j=i+1;j<n;j++){\n              ld tmp=INF;\n              for(int k=0;k<5;k++){\n                  for(int l=0;l<5;l++){\n                      Line x=Line(stars[i][k],stars[i][(k+2)%5]);\n                      Line y=Line(stars[j][l],stars[j][(l+2)%5]);\n                      tmp=min(tmp,dist_ss(x,y));\n                  }\n              }\n              dis[i][j]=tmp;dis[j][i]=tmp;\n          }\n      }\n\n      for(int j=0;j<n;j++){\n          for(int i=0;i<n;i++){\n              for(int k=0;k<n;k++){\n                  dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);\n              }\n          }\n      }\n\n      cout << setprecision(10)<<dis[m-1][l-1] << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing  ld = long double;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main()\n{\n\tint N, M, L;\n\tcout << fixed << setprecision(8);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / (1 + sqrtl(5)) * 2 : r[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_sp(Line(seg[i][ii], seg[i][(ii + 1) % 10]), seg[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2402.cc: Milky Way\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int PN = 5;\nconst double PI = acos(-1.0);\nconst double DINF = 1.0e10;\n  \n/* typedef */\n\ntypedef pair<double,int> pdi;\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  bool operator==(const Pt pt) const { return x == pt.x && y == pt.y; }\n  Pt<T> operator+(const Pt pt) const { return Pt<T>(x + pt.x, y + pt.y); }\n  Pt<T> operator-() const { return Pt<T>(-x, -y); }\n  Pt<T> operator-(const Pt pt) const { return Pt<T>(x - pt.x, y - pt.y); }\n  Pt<T> operator*(T t) const { return Pt<T>(x * t, y * t); }\n  Pt<T> operator/(T t) const { return Pt<T>(x / t, y / t); }\n  T dot(Pt v) const { return x * v.x + y * v.y; }\n  T cross(Pt v) const { return x * v.y - y * v.x; }\n  Pt<T> mid(const Pt pt) { return Pt<T>((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt<T> rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt<T>(c * x - s * y, s * x + c * y);\n  }\n\n  Pt<T> rot90() { return Pt<T>(-y, x); }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n\n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n  void print() { print(\"%.6lf\"); }\n};\n\ntypedef Pt<double> pt;\ntypedef vector<pt> vpt;\n\nstruct CL {\n  pt p;\n  double t0, t1;\n  CL() {}\n  CL(const pt& _p, double _t0, double _t1) : p(_p), t0(_t0), t1(_t1) {}\n};\n\n/* global variables */\n\npt pts[MAX_N][PN];\ndouble ds[MAX_N][MAX_N], dists[MAX_N];\n\n/* subroutines */\n\nbool cross_lines(const pt& ap, const pt av, const pt& bp, const pt bv, CL& cl) {\n  double op01 = av.cross(bv);\n  //if (op01 == 0.0) return false; /* need to handle parallel?? */\n\n  if (op01 == 0.0) {\n    pt v = bp - ap;\n    if (v.cross(av) != 0.0) return false;\n\n    pt a1 = ap + av;\n    pt b1 = bp + bv;\n\n    return\n      ((bp - ap).dot(b1 - ap) <= 0.0 ||\n       (bp - a1).dot(b1 - a1) <= 0.0 ||\n       (ap - bp).dot(a1 - bp) <= 0.0 ||\n       (ap - b1).dot(a1 - b1) <= 0.0);\n  }\n\n  pt v = bp - ap;\n  double op0 = v.cross(av);\n  double op1 = v.cross(bv);\n\n  double t0 = op1 / op01;\n  double t1 = op0 / op01;\n\n  cl.p = bv * t1 + bp;\n  cl.t0 = t0;\n  cl.t1 = t1;\n\n  return true;\n  //return (0.0 <= cl.t0 && cl.t0 <= 1.0 && 0.0 <= cl.t1 && cl.t1 <= 1.0);\n}\n\nbool cross_segs(const pt& ap, const pt av, const pt& bp, const pt bv, CL& cl) {\n  if (! cross_lines(ap, av, bp, bv, cl)) return false;\n  return (0.0 <= cl.t0 && cl.t0 <= 1.0 && 0.0 <= cl.t1 && cl.t1 <= 1.0);\n}\n\ndouble dist_pt_seg(pt &p, pt &bp, pt &bv) {\n  pt v0 = p - bp;\n  if (v0.dot(bv) < 0.0) return v0.d();\n  pt v1 = p - (bp + bv);\n  if (v1.dot(-bv) < 0.0) return v1.d();\n\n  CL cl;\n  pt pv = bv.rot90();\n  cross_lines(p, pv, bp, bv, cl);\n  return (cl.p - p).d();\n}\n\ndouble dist_segs(pt &ap, pt &av, pt &bp, pt &bv) {\n  CL cl;\n  if (cross_segs(ap, av, bp, bv, cl)) return 0.0;\n\n  double mind = dist_pt_seg(ap, bp, bv);\n  pt ap0 = ap + av;\n  double d = dist_pt_seg(ap0, bp, bv);\n  if (mind > d) mind = d;\n  d = dist_pt_seg(bp, ap, av);\n  if (mind > d) mind = d;\n  pt bp0 = bp + bv;\n  d = dist_pt_seg(bp0, ap, av);\n  if (mind > d) mind = d;\n  return mind;\n}\n\ndouble dist_stars(int s0, int s1) {\n  double mind = DINF;\n  for (int i = 0; i < PN; i++) {\n    pt &ap = pts[s0][i];\n    pt av = pts[s0][(i + 2) % PN] - ap;\n    for (int j = 0; j < PN; j++) {\n      pt &bp = pts[s1][j];\n      pt bv = pts[s1][(j + 2) % PN] - bp;\n      double d = dist_segs(ap, av, bp, bv);\n      if (mind > d) mind = d;\n    }\n  }\n  return mind;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (n == 0) break;\n    m--, l--;\n    \n    double dth = PI * 2 / PN;\n    \n    for (int i = 0; i < n; i++) {\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      double th0 = PI * (90 + a) / 180;\n\n      for (int j = 0; j < PN; j++) {\n\tdouble th = th0 + dth * j;\n\tpts[i][j].x = x + r * cos(th);\n\tpts[i][j].y = y + r * sin(th);\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      ds[i][i] = 0.0;\n      for (int j = i + 1; j < n; j++)\n\tds[i][j] = ds[j][i] = dist_stars(i, j);\n      dists[i] = DINF;\n    }\n\n    dists[m] = 0.0;\n    priority_queue<pdi> q;\n    q.push(pdi(0.0, m));\n\n    while (! q.empty()) {\n      pdi u = q.top(); q.pop();\n      double ud = -u.first;\n      int &ui = u.second;\n      if (dists[ui] != ud) continue;\n      if (ui == l) break;\n\n      for (int vi = 0; vi < n; vi++) {\n\tif (vi == ui) continue;\n\tdouble vd = ud + ds[ui][vi];\n\tif (dists[vi] > vd) {\n\t  dists[vi] = vd;\n\t  q.push(pdi(-vd, vi));\n\t}\n      }\n    }\n\n    printf(\"%.10lf\\n\", dists[l]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\ntypedef complex<double> PT;\ntypedef PT VC;\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b) / abs(l.fi-l.se));\n}\n\n// ??\\??????????????????????????????\n\n// ???????????´??????????????£???????????????false??????????????§??¨???\nbool has_intersec_seg_seg(SG a, SG b) {\n\tVC va, vb, vc;\n\tbool res = true;\n\tfor(int i = 0; i < 2; i++) {\n\t\tva = b.fi-a.fi; vb = b.se-a.fi; vc = a.se-a.fi;\n\t\tres = res && cross_prod(va, vc) * cross_prod(vb, vc) < EPS;\n\t\tswap(a,b);\n\t}\n\tres = res && abs(cross_prod(a.fi-a.se, b.fi-b.se)) > EPS;\n\treturn res;\n}\n\ndouble dist_pts_seg(PT p, SG a) {\n\tdouble res;\n\tres = min(abs(a.fi-p), abs(a.se-p));\n\tif(dot_prod(a.se - a.fi, p - a.fi) > -EPS\n\t\t\t&& dot_prod(a.fi - a.se, p - a.se) > -EPS)\n\t\tres = min(res, dist_pts_line(p, a));\n\treturn res;\n}\n\ndouble dist_seg_seg(SG a, SG b) {\n\tdouble res;\n\tfor(int i = 0; i < 2; i++) {\n\t\tres = min(dist_pts_seg(a.fi,b), dist_pts_seg(a.se,b));\n\t\tswap(a,b);\n\t}\n\tif(has_intersec_seg_seg(a,b))\n\t\tres = 0;\n\treturn res;\n}\n\n/* //???????????????\nint main() {\n\tSG a(PT(0,0),PT(0,2));\n\tSG b(PT(-1,1),PT(2,1));\n\tcout << dist_seg_seg(a,b) << endl;\n} // */\n\n//*\nint N, M, L;\nvector<vector<SG> > star;\ndouble edge[120][120];\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nvoid init() {\n\tstar.clear();\n\trep(i,120) {\n\t\trep(j,120)\n\t\t\tedge[i][j] = 1e9;\n\t\tedge[i][i] = 0;\n\t}\n}\n\nint main() {\n\twhile(cin >> N >> M >> L, N || M || L) {\n\t\tinit();\n\t\tM--; L--;\n\t\trep(i,N) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<PT> tmp;\n\t\t\tdouble theta = (a+90) / 180.0 * M_PI;\n\t\t\tdouble phi = 360.0 / 5.0 / 180.0 * M_PI;\n\t\t\trep(i,5) {\n\t\t\t\ttmp.push_back(polar((double)r, theta + phi * i) + PT(x,y));\n\t\t\t//\tcout << tmp[i] << endl;\n\t\t\t}\n\t\t\tvector<SG> push;\n\t\t\trep(i,5) {\n\t\t\t\tpush.push_back(SG(tmp[i],tmp[(i+2)%5]));\n\t\t\t}\n\t\t\tstar.push_back(push);\n\t\t}\n\n\t\trep(i,N) {\n\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\tdouble tmp = 1e9;\n\t\t\t\trep(k,5) {\n\t\t\t\t\trep(l, 5) {\n\t\t\t\t\t\ttmp = min(tmp, dist_seg_seg(star[i][k], star[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\trep(i,N) {\n\t\t\trep(j,N) {\n\t\t\t\trep(k,N) {\n\t\t\t\t\tedge[j][k] = min(edge[j][k], edge[j][i] + edge[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", edge[L][M]);\n\t}\n}\n// */"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return b * (a.dot(b) / b.sqlength()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn 0 + contains(a, b.p) + contains(a, b.p + b.d)\n\t\t+ contains(b, a.p) + contains(b, a.p + a.d) >= 2;\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) {\n\tP2 h = perpendicular_foot(a, (Line)b);\n\treturn contains(b, h) ? getDistance(h, a)\n\t\t: min(getDistance(b.p, a), getDistance(b.p + b.d, a));\n}\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b)\n{\n\treturn isCross(a, b) ? 0 : \n\tmin(min(getDistance(a, b.p), getDistance(a, b.p + b.d)), \n\tmin(getDistance(a.p, b), getDistance(a.p + a.d, b))); }\n\n// a から ta, bから tb だけ離れた点。ta=tb=r なら aとbに内接する円\ninline pair<pair<P2, P2>, pair<P2, P2>> get_distance_points(Line a, double ta, Line b, double tb)\n{\n\tassert(isCross(a, b));\n\n\tP2 va = a.d.orthogonal().direction() * ta;\n\tP2 vb = b.d.orthogonal().direction() * tb;\n\treturn make_pair(\n\t\tmake_pair(\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p - vb, b.d))\n\t\t), make_pair(\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p - vb, b.d))\n\t\t));\n}\n\n/// 円\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\n/// 長方形\nstruct Rect\n{\n\tP2 l, s;\n\tRect() : l(), s() { }\n\tRect(double x, double y, double w, double h) : l(x, y), s(w, h) { }\n\tRect(P2 location, P2 size) : l(location), s(size) { }\n\tbool Contains(const P2 &p) const { return p.x - l.x > -EPS && p.y - l.y > -EPS && p.x - (l.x + s.x) < EPS && p.y - (l.y + s.y) < EPS; } // 接してても真。\n};\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n#define M_PI       3.14159265358979323846\n// Milky Way\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tif (!N) { break; }\n\n\t\tvevector<LineSeg> segs(N);\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(int, x, y, a, r);\n\t\t\tREP(i, 5)\n\t\t\t{\n\t\t\t\tint j = i + 1;\n\t\t\t\tdouble ai = (i * 144 + 90 + a) % 360 * M_PI / 180.0;\n\t\t\t\tdouble aj = (j * 144 + 90 + a) % 360 * M_PI / 180.0;\n\t\t\t\tP2 center(x, y);\n\t\t\t\tP2 pi = center + P2(cos(ai), sin(ai)).direction() * r;\n\t\t\t\tP2 pj = center + P2(cos(aj), sin(aj)).direction() * r;\n\t\t\t\tLineSeg s = LineSeg::From2Point(pi, pj);\n\t\t\t\tsegs[_].push_back(s);\n\n\t\t\t\t//WRITE(s.p, s.d);\n\t\t\t}\n\t\t}\n\n\t\tvevector<Path<double>> graph(N);\n\t\tREP(i, N) REP(j, N)\n\t\t{\n\t\t\tdouble d = INF;\n\t\t\tREP(k, 5) REP(l, 5) d = min(d, getDistance(segs[i][k], segs[j][l]));\n\t\t\tgraph[i].push_back({ i, j, d });\n\t\t}\n\n\t\tprintf(\"%.16f\\n\", dijkstra(graph, L - 1, -1).first[M - 1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\nstruct star{\n    double a,r;\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        star S[100];\n        for(int i = 0; i < n; i++){\n\t\t\tpoint<double> c;\n           cin>>c.x>>c.y>>S[i].a>>S[i].r;\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            for(int j = 0; j < 5; j++) S[i].p[j] += c;\n        }\n\n\t\tP pt[100][5];\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < 5; j++){\n\t\t\t\tpt[i][j] = S[i].p[j];\n            }\n        }\n\n   \n        int f1[]={0,2,4,1,3,0};\n   \n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    segment<double> s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    segment<double> t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n//#define double long double\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\nstruct Point {\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint &operator+=(const Point &p) { x += p.x; y += p.y; return *this; }\n\tPoint &operator-=(const Point &p) { x -= p.x; y -= p.y; return *this; }\n\tPoint &operator*=(double a) { x *= a; y *= a; return *this; }\n\tPoint &operator/=(double a) { x /= a; y /= a; return *this; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\nPoint operator+(const Point &p1, const Point &p2) { return Point(p1) += p2; }\nPoint operator-(const Point &p1, const Point &p2) { return Point(p1) -= p2; }\nPoint operator*(const Point &p, double a) { return Point(p) *= a; }\nPoint operator/(const Point &p, double a) { return Point(p) /= a; }\nbool operator==(const Point &p1, const Point &p2) { return equals(p1.x, p2.x) && equals(p1.y, p2.y); }\nbool operator<(const Point &p1, const Point &p2) {\n\t//return p1.y != p2.y ? p1.y < p2.y : p1.x < p2.x; //y?????? -> x??????\n\treturn p1.x != p2.x ? p1.x < p2.x : p1.y < p2.y; //x?????? -> y??????\n}\nbool operator>(const Point &p1, const Point &p2) { return p2 < p1; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << ' ' << p.y; return os; }\n\nstruct Vector :public Point {\n\tusing Point::Point;\n\tVector() {}\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n\tVector unit() { return *this / abs(); }\n};\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nstruct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\n\nstruct Segment :public Line {\n\tusing Line::Line;\n\tSegment() {}\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\nstruct Circle {\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//degree to radian\ndouble rad(double deg) { return PI*deg / 180; }\n//radian to degree\ndouble deg(double rad) { return rad / PI * 180; }\n\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\n//2??????????????????????§????\ndouble angle(Vector a, Vector b) {\n\tdouble lena = a.abs(), lenb = b.abs();\n\tif (lena == 0 || lenb == 0)return 0; //?§£??????\n\tdouble costheta = dot(a, b) / (lena*lenb);\n\tif (equals(costheta, 1))costheta = 1; //????????????\n\treturn acos(costheta);\n}\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Segment a, Segment b) {\n\tPoint p1 = a.p1, p2 = a.p2, p3 = b.p1, p4 = b.p2;\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment a, Segment b) {\n\tassert(intersect(a, b));\n\tVector base = b.p2 - b.p1;\n\tdouble area1 = abs(cross(base, a.p1 - b.p1));\n\tdouble area2 = abs(cross(base, a.p2 - b.p1));\n\tdouble t = area1 / (area1 + area2);\n\treturn a.p1 + (a.p2 - a.p1)*t;\n}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r - c2.r*c2.r + d*d) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(const Polygon &pl, Point p) {\n\tint n = pl.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = pl[i] - p, b = pl[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(const Polygon &p) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < p.size(); i++)\n\t\ta += cross(p[i], p[(i + 1) % p.size()]);\n\treturn fabs(a / 2.0);\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); //???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); //???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\n//????§???¢???(0,0)???????????¨???????????¢\nPolygon rotate(const Polygon &P, double rad) {\n\tPolygon ret;\n\tfor (auto &p : P)\n\t\tret.emplace_back(p.x*cos(rad) - p.y*sin(rad), p.x*sin(rad) + p.y*cos(rad));\n\treturn ret;\n}\n\n//Heron's formula\ndouble area(double a, double b, double c) {\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\n//????§???¢?????????\nPoint center(const Polygon &P) {\n\tPoint ret(0, 0);\n\tfor (auto &p : P)ret = ret + p;\n\tret = ret / P.size();\n\treturn ret;\n}\n\n//?????´????????????\nLine get_bisection(const Point &p1, const Point &p2) {\n\tCircle c1(p1, INF), c2(p2, INF); //INF ?????¨???????????????\n\tauto ps = get_cross_points(c1, c2);\n\treturn Line(ps.first, ps.second);\n}\n\n//3??????????????¢??????????????? (3???????????¨????????????????????????)\nPoint get_center(const Point &p1, const Point &p2, const Point &p3) {\n\tLine l1 = get_bisection(p1, p2), l2 = get_bisection(p2, p3);\n\treturn get_cross_point(l1, l2);\n}\n\n//???p????????????c?????\\?????????????????\\???\npair<Point, Point> get_tangent(const Circle &c, const Point &p) {\n\tdouble d = get_distance(c.c, p);\n\tCircle c2((c.c + p) / 2, d / 2);\n\treturn get_cross_points(c, c2);\n}\n\nusing Weight = double;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nvector<int> dijkstra(const Graph &g, int s, Array &dist) {\n\tint n = g.size();\n\tassert(s < n);\n\tenum { WHITE, GRAY, BLACK };\n\tvector<int> color(n, WHITE); color[s] = GRAY;\n\tvector<int> ret(n, -1);\n\tdist.assign(n, INF); dist[s] = 0;\n\tusing State = tuple<Weight, int, int>;\n\tpriority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);\n\twhile (pq.size()) {\n\t\tWeight d; int v, u; tie(d, v, u) = pq.top(); pq.pop();\n\t\tif (dist[v] < d)continue;\n\t\tcolor[v] = BLACK; ret[v] = u;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (color[e.d] == BLACK)continue;\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tpq.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tM--, L--;\n\t\tvector<Polygon> v(N);\n\t\trep(i, 0, N) {\n\t\t\tint x, y, a, r; cin >> x >> y >> a >> r;\n\t\t\tVector vec(0, r);\n\t\t\tvec = vec.rotate(rad(a));\n\t\t\trep(j, 0, 5) {\n\t\t\t\tv[i].emplace_back(vec + Point(x, y));\n\t\t\t\tvec = vec.rotate(rad(72));\n\t\t\t}\n\t\t}\n\t\tGraph g(N);\n\t\trep(i, 0, N) {\n\t\t\trep(j, i + 1, N) {\n\t\t\t\trep(k, 0, 5) {\n\t\t\t\t\tSegment a(v[i][k], v[i][(k + 2) % 5]);\n\t\t\t\t\trep(l, 0, 5) {\n\t\t\t\t\t\tSegment b(v[j][l], v[j][(l + 2) % 5]);\n\t\t\t\t\t\taddEdge(g, i, j, get_distance(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArray dist;\n\t\tdijkstra(g, M, dist);\n\t\tcout << dist[L] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nreal pi = acos(-1);\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nstatic constexpr int CONTAIN = 0;\nstatic constexpr int INSCRIBE = 1;\nstatic constexpr int INTERSECT = 2;\nstatic constexpr int CIRCUMSCRIBED = 3;\nstatic constexpr int SEPARATE = 4;\n\nint intersect(Circle c1, Circle c2){\n    if(c1.r < c2.r) swap(c1, c2);\n    real d = abs(c1.c-c2.c);\n    real r = c1.r + c2.r;\n    if(fabs(d-r) < EPS) return CIRCUMSCRIBED;\n    if(d > r) return SEPARATE;\n    if(fabs(d+c2.r-c1.r) < EPS) return INSCRIBE;\n    if(d+c2.r < c1.r) return CONTAIN;\n    return INTERSECT;\n}\n\nreal distance(Line l, Point c){\n    return abs(cross(l.b-l.a, c-l.a)/abs(l.b-l.a));\n}\n\n\nreal distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\nreal distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\nPoint project(Line l, Point p){\n    Point Q = l.b-l.a;\n    return l.a + Q*(dot(p-l.a, Q) / dot(Q, Q));\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPolygon crossPoint(Circle c, Line l){\n    Point p = project(l, c.c), q = (l.b-l.a)/abs(l.b-l.a);\n    if(abs(distance(l, c.c)-c.r) < EPS){\n        return {p};\n    }\n    double k = sqrt(c.r*c.r-dot(p-c.c, p-c.c));\n    return {p-q*k, p+q*k};\n}\n\nPolygon crossPoint(Circle c, Segment s){\n    auto tmp = crossPoint(c, Line(s.a, s.b));\n    Polygon ret;\n    for (auto &&i : tmp) {\n        if(distance(s, i) < EPS) ret.emplace_back(i);\n    }\n    return ret;\n}\n\n\nPolygon crossPoint(Circle c1, Circle c2){\n    double d = abs(c1.c-c2.c);\n    double a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t = arg(c2.c-c1.c);\n    return {c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a)};\n}\n\nPolygon tangent(Circle c1, Point p){\n    Circle c2 = Circle(p, sqrt(dot(c1.c-p, c1.c-p)-c1.r*c1.r));\n    return crossPoint(c1, c2);\n}\nvector<Line> tangent(Circle c1, Circle c2){\n    vector<Line> ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    double k = dot(c1.c-c2.c, c1.c-c2.c);\n    if(abs(k) < EPS) return {};\n    Point u = (c2.c-c1.c)/sqrt(k);\n    Point v(-u.y, u.x);\n    for (auto &&i : {-1, 1}) {\n        double h = (c1.r+i*c2.r)/sqrt(k);\n        if(abs(h*h-1) < EPS){\n            ret.emplace_back(c1.c+u*c1.r, c1.c+(u+v)*c1.r);\n        }else if(h*h < 1){\n            Point u2 = u*h, v2 = v*sqrt(1-h*h);\n            ret.emplace_back(c1.c+(u2+v2)*c1.r, c2.c-(u2+v2)*c2.r*i);\n            ret.emplace_back(c1.c+(u2-v2)*c1.r, c2.c-(u2-v2)*c2.r*i);\n        }\n    }\n    return ret;\n}\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nreal area(Circle c, Polygon &v){\n    int n = v.size();\n    real ans = 0.0;\n    Polygon u;\n    for (int i = 0; i < n; ++i) {\n        u.emplace_back(v[i]);\n        auto q = crossPoint(c, Segment(v[i], v[(i+1)%n]));\n        for (auto &&j : q) {\n            u.emplace_back(j);\n        }\n    }\n    for (int i = 0; i < u.size(); ++i) {\n        Point A = u[i], B = u[(i+1)%u.size()];\n        if(abs(A) >= c.r+EPS || abs(B) >= c.r+EPS){\n            Point C = polar(1, arg(B)-arg(A));\n            ans += c.r*c.r*arg(C)/2;\n        }else {\n            ans += cross(A, B)/2;\n        }\n    }\n    return ans;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nbool isconvex(Polygon v){\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        if(ccw(v[(i+n-1)%n], v[i], v[(i+1)%n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint contains(Polygon v, Point p){\n    int n = v.size();\n    bool x = false;\n    static constexpr int IN = 2;\n    static constexpr int ON = 1;\n    static constexpr int OUT = 0;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?IN:OUT);\n}\n\nreal diameter(Polygon v){\n    int n = v.size();\n    if(n == 2) return abs(v[0]-v[1]);\n    int i = 0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if(v[i] < v[k]) i = k;\n        if(!(v[j] < v[k])) j = k;\n    }\n    real ret = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        ret = max(ret, abs(v[i]-v[j]));\n        if(cross(v[(i+1)%n]-v[i], v[(j+1)%n]-v[j]) < 0.0) i = (i+1)%n;\n        else j = (j+1)%n;\n    }\n    return ret;\n}\n\nPolygon convexCut(Polygon v, Line l){\n    Polygon q;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i], b = v[(i+1)%n];\n        if(ccw(l.a, l.b, a) != -1) q.push_back(a);\n        if(ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0){\n            q.push_back(crossPoint(Line(a, b), l));\n        }\n    }\n    return q;\n}\n\nreal closest_pair(Polygon &v, int l = 0, int r = -1){\n    if(!(~r)){\n        r = v.size();\n        sort(v.begin(),v.end());\n    }\n    if(r - l < 2) {\n        return abs(v.front()-v.back());\n    }\n    int mid = (l+r)/2;\n    real p = v[mid].x;\n    real d = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, sorty);\n    Polygon u;\n    for (int i = l; i < r; ++i) {\n        if(fabs(v[i].x-p) >= d) continue;\n        for (int j = 0; j < u.size(); ++j) {\n            real dy = v[i].y-next(u.rbegin(), j)->y;\n            if(dy >= d) break;\n            d = min(d, abs(v[i]-*next(u.rbegin(), j)));\n        }\n        u.emplace_back(v[i]);\n    }\n    return d;\n}\n\nint main() {\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        vector<Polygon> v(n);\n        for (int i = 0; i < n; ++i) {\n            real x, y, a, r;\n            cin >> x >> y >> a >> r;\n            Point p(x, y);\n            for (int j = 0; j < 5; ++j) {\n                v[i].emplace_back(p+polar(r, (a+18+144*j)/180*pi));\n            }\n        }\n        vector<vector<real>> dp(n, vector<real>(n, MOD));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if(i == j){\n                    dp[i][j] = 0;\n                    continue;\n                }\n                for (int s = 0; s < 5; ++s) {\n                    for (int t = 0; t < 5; ++t) {\n                        dp[i][j] = min(dp[i][j],\n                                distance(Segment(v[i][s], v[i][(s+1)%5]),\n                                         Segment(v[j][t], v[j][(t+1)%5])));\n                    }\n                }\n            }\n        }\n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        printf(\"%.10lf\\n\", dp[m-1][l-1]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\ndouble deg2rad(double deg) {\n    return deg * 2. * PI / 360;\n}\n\n// q????????????p???theta?????¢(???????¨????????????£)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\ndouble distanceLP(L l, P p) {\n    return abs(cross(l.v, p - l.a)) / abs(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.v, p - l.a) < 0) return abs(p - l.a);\n    if (dot(-l.v, p - l.b) < 0) return abs(p - l.b);\n    return distanceLP(l, p);\n}\n\ndouble distanceSS(L l1, L l2) {\n    if (intersectSS(l1, l2)) return 0;\n    double d = INF;\n    d = min(d, distanceSP(l1, l2.a));\n    d = min(d, distanceSP(l1, l2.b));\n    d = min(d, distanceSP(l2, l1.a));\n    d = min(d, distanceSP(l2, l1.b));\n    return d;\n}\n\nstruct Star {\n    P c;\n    double r;\n    vector<P> p;\n    vector<L> l;\n    Star(){}\n    Star(double x, double y, double deg, double _r) : c(x, y), r(_r) {\n        rep(i, 5) {\n            p.emplace_back(rotP(P(x, y + r), c, deg2rad(deg + 72 * i)));\n        }\n        rep(i, 5) {\n            l.emplace_back(L(p[i], p[(i + 2) % 5]));\n        }\n    }\n    double dist(const Star& o) {\n        double ret = INF;\n        rep(i, 5) {\n            rep(j, 5) {\n                ret = min(ret, distanceSS(l[i], o.l[j]));\n            }\n        }\n        return ret;\n    }\n};\n\nstruct edge {\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to, double _cost) : to(_to), cost(_cost) {}\n};\ntypedef vector<vector<edge>> Graph;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, double c) {\n    G[x].emplace_back(y, c);\n    G[y].emplace_back(x, c);\n}\n\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    using Pdi = pair<double, int>;\n    priority_queue<Pdi, vector<Pdi>, greater<Pdi>> pq;   // cost, vertex\n    vector<double> d(n, INF);\n    d[s] = 0.;\n    pq.push(make_pair(0., s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, s, g;\n    while (cin >> n >> s >> g, n) {\n        s--; g--;\n\n        vector<Star> stars;\n        rep(i, n) {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            stars.emplace_back(x, y, a, r);\n        }\n\n        Graph G(n);\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                addEdge(G, i, j, stars[i].dist(stars[j]));\n            }\n        }\n\n        cout << fixed << setprecision(20) << dijkstra(G, s, g) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n  \n  \n  \n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#endif\n  \n#define rep (i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define MEMCPY(dest, src) memcpy(dest, src, sizeof(src))\n  \n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n  \ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n  \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\ntemplate <class T> vector<T> input(int n) { vector<T> res(n); for (int i = 0; i < n; ++i) cin >> res[i]; return res; }\n \n \n \n \n \nconst double EPS_FOR_LIB = 1e-8;\ntypedef double geo_type;\ntypedef complex<geo_type> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n};\nstruct Line\n{\n\tPoint from, to;\n\tLine(Point from, Point to) : from(from), to(to) { }\n\tLine() { }\n};\ntypedef vector<Point> Poly;\n \ngeo_type dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngeo_type cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n \nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > EPS_FOR_LIB) return counter_clockwise;\n\telse if (cross(p, q) < -EPS_FOR_LIB) return clockwise;\n\telse return on;\n}\n\n// 交差判定\nbool intersectLL(const Line& line1, const Line& line2)\n{\n\t// non-parallel\n\tif (abs(cross(line1.to - line1.from, line2.to - line2.from) > EPS_FOR_LIB))\n\t\treturn true;\n\t// same line\n\tif (abs(cross(line1.to - line1.from, line2.from - line1.from) < EPS_FOR_LIB))\n\t\treturn true;\n\treturn false;\n}\nbool intersectLS(const Line& line, const Line& seg)\n{\n\treturn cross(line.to - line.from, seg.from - line.from)\n\t\t* cross(line.to - line.from, seg.to - line.from) < EPS_FOR_LIB;\n}\nbool intersectLP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.to - p, line.from - p)) < EPS_FOR_LIB;\n}\nbool intersectSS(const Line& seg1, const Line& seg2)\n{\n\treturn ccw(seg1.from, seg1.to, seg2.from) * ccw(seg1.from, seg1.to, seg2.to) <= 0\n\t\t&& ccw(seg2.from, seg2.to, seg1.from) * ccw(seg2.from, seg2.to, seg1.to) <= 0;\n}\nbool intersectSP(const Line& seg, const Point& p)\n{\n\treturn norm(seg.from - p) + norm(seg.to - p) - norm(seg.from - seg.to) < EPS_FOR_LIB;\n}\n\n// 距離\n// complex<double>で使わないとNG\n// 点から直線に垂線を下ろした点\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.from - line.to;\n\tdouble t = dot(p - line.from, a) / norm(a);\n\treturn line.from + t * a;\n}\n// 線対称な点\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((geo_type)2) * (projection(line, p) - p);\n}\ndouble distanceLP(const Line& line, const Point& p)\n{\n\treturn abs(p - projection(line, p));\n}\ndouble distanceLL(const Line& line1, const Line& line2)\n{\n\treturn intersectLL(line1, line2) ? 0 : distanceLP(line1, line2.from);\n}\ndouble distanceLS(const Line& line, const Line& seg)\n{\n\tif (intersectLS(line, seg))\n\t\treturn 0;\n\treturn min(distanceLP(line, seg.from), distanceLP(line, seg.to));\n}\ndouble distanceSP(const Line& seg, const Point& p)\n{\n\tconst Point r = projection(seg, p);\n\tif (intersectSP(seg, r))\n\t\treturn abs(r - p);\n\treturn min(abs(seg.from - p), abs(seg.to - p));\n}\ndouble distanceSS(const Line& seg1, const Line& seg2)\n{\n\t//if (intersectSS(seg1, seg2))\n\t//\treturn 0;\n\treturn min(min(distanceSP(seg1, seg2.from), distanceSP(seg1, seg2.to)),\n\t\tmin(distanceSP(seg2, seg1.from), distanceSP(seg2, seg1.to)));\n}\n\n\nPoint rotate(const Point& p, double angle, const Point& base = Point(0, 0))\n{\n\tdouble c = cos(angle), s = sin(angle);\n\tPoint t = p - base;\n\treturn Point(t.real() * c - t.imag() * s + base.real(), t.real() * s + t.imag() * c + base.imag());\n}\n\n\nint sign(double n)\n{\n    if (abs(n) < EPS)\n        return 0;\n    else if (n > 0)\n        return 1;\n    else\n        return -1;\n}\n//double dot(const Point& a, const Point& b)\n//{\n//    return a.real()*b.real() + a.imag()*b.imag();\n//}\n//double cross(const Point& a, const Point& b)\n//{\n//    return a.real()*b.imag() - a.imag()*b.real();\n//}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n    return abs(cross(a-b, point-b) / (a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n    if (dot(b-a, point-a) < 0)\n        return abs(a-point);\n    else if (dot(a-b, point-b) < 0)\n        return abs(b-point);\n    else\n        return distance_line_point(point, a, b);\n}\nbool is_point_on_line(const Point& point, const Point& a, const Point& b)\n{\n    return abs(cross(b-a, point-a)) < EPS;\n}\nbool is_point_on_linesegment(const Point& point, const Point& a, const Point& b)\n{\n    return distance_linesegment_point(point, a, b) < EPS;\n}\nbool intersect_linesegments(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    return cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < -EPS\n        && cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < -EPS\n        || is_point_on_linesegment(b1, a1, a2)\n        || is_point_on_linesegment(b2, a1, a2)\n        || is_point_on_linesegment(a1, b1, b2)\n        || is_point_on_linesegment(a2, b1, b2);\n}\ndouble distance_seg_seg(const Point& a, const Point& b, const Point& c, const Point& d)\n{\n    if (intersect_linesegments(a, b, c, d))\n        return 0;\n    return min(min(distance_linesegment_point(c, a, b), distance_linesegment_point(d, a, b))\n        , min(distance_linesegment_point(a, c, d), distance_linesegment_point(b, c, d)));\n}\ndouble distance_seg_seg(const Line& a, const Line& b)\n{\n\treturn distance_seg_seg(a.from, a.to, b.from, b.to);\n}\n\nvector<Line> lines(int x, int y, int a, int r)\n{\n    double w = PI * 2 / 5;\n    double a1 = PI / 2 - w;\n    double a2 = w - a1;\n \n    double c1 = cos(a1), s1 = sin(a1);\n    double c2 = cos(a2), s2 = sin(a2);\n \n    double px[] = { 0, -c2, c1, -c1, c2, 0 };\n    double py[] = { 1, -s2, s1, s1, -s2, 1 };\n \n\tPoint p[6];\n    double ang = PI * a / 180;\n    for (int i = 0; i < 6; ++i)\n\t\tp[i] = (double)r * rotate(Point(px[i], py[i]), ang) + Point(x, y);\n\n    vector<Line> res;\n    for (int i = 0; i < 5; ++i)\n        res.push_back(Line(p[i], p[i + 1]));\n    return res;\n}\nvoid pri(const Point& p)\n{\n\tprintf(\"(%f, %f)\\n\", p.real(), p.imag());\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    const double INF = 1e20;\n \n    int n, s, g;\n    while (cin >> n >> s >> g, n)\n    {\n        --s, --g;\n \n        vector<Line> star[128];\n        for (int i = 0; i < n; ++i)\n        {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            star[i] = lines(x, y, a, r);\n        }\n \n \n        double e[128][128];\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = 0; j < n; ++j)\n            {\n\t\t\t\tif (i == j)\n\t\t\t\t{\n\t\t\t\t\te[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                e[i][j] = INF;\n                for (int k = 0; k < 5; ++k)\n                    for (int l = 0; l < 5; ++l)\n                        min_swap(e[i][j], distance_seg_seg(star[i][k], star[j][l]));\n            }\n        }\n \n \n        double dis[128];\n        fill(dis, dis + n, INF);\n \n        typedef pair<double, int> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        dis[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty())\n        {\n            P tt = q.top(); q.pop();\n            int p = tt.second;\n            double c = tt.first;\n \n            if (p == g)\n                break;\n            else if (c > dis[p])\n                continue;\n \n            for (int i = 0; i < n; ++i)\n            {\n                double nc = c + e[p][i];\n                if (nc < dis[i])\n                {\n                    dis[i] = nc;\n                    q.push(P(nc, i));\n                }\n            }\n        }\n \n        cout.setf(ios::fixed);\n        cout.precision(15);\n        cout << dis[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n//#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n//#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n//#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n)                                            \\\n  do                                                           \\\n  {                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)            \\\n      cerr << \"(\" << _i_t_e_ << \" = \" << (a)[_i_t_e_] << \") \"; \\\n    cerr << endl;                                              \\\n  } while (0)\n#define showA2(a, n, m)                                                                        \\\n  do                                                                                           \\\n  {                                                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)                                            \\\n    {                                                                                          \\\n      for (int _i_t_e_2 = 0; _i_t_e_2 < (m); _i_t_e_2++)                                       \\\n      {                                                                                        \\\n        cerr << \"(\" << _i_t_e_ << \", \" << _i_t_e_2 << \" = \" << (a)[_i_t_e_][_i_t_e_2] << \") \"; \\\n      }                                                                                        \\\n      cerr << endl;                                                                            \\\n    }                                                                                          \\\n    cerr << endl;                                                                              \\\n  } while (0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\n#include<complex>\n#include<algorithm>\n#include<tuple>\n#include<iomanip>\n#include<vector>\n#include<utility>\n#include<functional>\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n        \n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        t=convex_hull(t);\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=min(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>EPS)return 1;//intersect\n            if(in_triangle(p,t))return 2;//c in t\n            else if(r-d<-EPS)return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n\n\n    //p must be convex and ccw\n    LS diameter(Poly &p){\n        int n=p.size();\n        int is=0,js=0;\n        REP(i,n)if(p[i].Y>p[is].Y)is=i;\n        REP(i,n)if(p[i].Y<p[js].Y)js=i;\n        LS res={p[is],p[js]};\n        {\n            int i=is;\n            int j=js;\n            do{\n                int ni=(i+1)%n;\n                int nj=(j+1)%n;\n                if(cross(p[ni]-p[i],p[nj]-p[j])<EPS)i=ni;\n                else j=nj;\n                if(abs(res.fi-res.se)<abs(p[i]-p[j]))\n                    res=LS(p[i],p[j]);\n            }while(i!=is||j!=js);\n        }\n        return res;\n    }\n    \n    Poly cross_C_L(C c,L v){\n        DCc(p,r,c);\n        DCl(a,b,v);\n        a-=p;\n        b-=p;\n        P u=a-b;\n        u=P(-u.Y,u.X);\n        P x=cross_L_L({a,b},{P(0,0),u});\n        D d=abs(x);\n        Poly res;\n        if(d-r>EPS)return res;\n        D y=sqrt(r*r-d*d);\n        res.pb(p+x+(b-a)*y/abs(b-a));\n        //if(d-r>-EPS)return res;\n        res.pb(p+x+(a-b)*y/abs(b-a));\n        return res;\n    }\n\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nint n, m, l;\n\n\nint main()\n{\n  while (cin >> n >> m >> l, n) {\n    double x[101], y[101], a[101], r[101];\n    geo::P btk[101][5];\n    geo::LS seg[101][5];\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> a[i] >> r[i];\n      for (int j = 0; j < 5; j++) {\n        btk[i][j] = geo::P(x[i] - r[i] * sin(M_PI / 180 * (72 * j + a[i])), y[i] + r[i] * cos(M_PI / 180 * (72 * j + a[i])));\n        //show(btk[i][j]);\n      }\n      for (int j = 0; j < 5; j++) {\n        seg[i][j].fi = btk[i][j % 5];\n        seg[i][j].se = btk[i][(j + 2) % 5];\n      }\n    }\n    double cost[101][101];\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) cost[i][j] = 114514114514.;\n    for (int i = 0; i < n; i++) cost[i][i] = 0.;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        double _min = 114514114514.;\n        for (int k = 0; k < 5; k++) {\n          for (int l1 = 0; l1 < 5; l1++) {\n            chmin(_min, geo::distance_LS_LS(seg[i][k], seg[j][l1]));\n          }\n        }\n        cost[i][j] = _min;\n        cost[j][i] = _min;\n      }\n    }\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        }\n      }\n    }\n    cout << cost[m - 1][l - 1] << endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-7)\n#define INF (1e9)\n#define N 105\nusing namespace std;\ntypedef pair<double,int> P1;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nvector<vector<P> > Stars;\nint n,m,l,x,y,a,r;\ndouble d[N];\n\nP Rot_P(P p,int sita){\n  return P(p.real()*cos(sita*M_PI/180.0)-p.imag()*sin(sita*M_PI/180.0),\n\t   p.real()*sin(sita*M_PI/180.0)+p.imag()*cos(sita*M_PI/180.0));\n}\n\nvoid Make_Star(){\n  P p=P(0,r);\n  p=Rot_P(p,a);\n  vector<P> Star;\n  for(int i=0;i<5;i++){\n    Star.push_back(P(p.real()+x,p.imag()+y));\n    p=Rot_P(p,216);\n  }\n  Stars.push_back(Star);\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));\n}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\ndouble get_d(int A,int B){\n  double res=INF;\n  for(int i=0;i<5;i++){\n    L l1=L(Stars[A][i],Stars[A][(i+1)%5]);\n    for(int j=0;j<5;j++){\n      L l2=L(Stars[B][j],Stars[B][(j+1)%5]);\n      res=min(res,getDistanceSS(l1,l2));\n    }\n  }\n  return res;\n}\n\ndouble dijkstra(){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<n;i++)d[i]=INF;\n  q.push(P1(0,m));\n  d[m]=0;\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    double cost=t.first;\n    int node=t.second;\n    if(d[node]+EPS<cost)continue;\n    if(node==l)return cost;\n    for(int i=0;i<n;i++){\n      if(node==i)continue;\n      double ncost=cost+get_d(node,i);\n      if(d[i]>ncost+EPS){\n\td[i]=ncost;\n\tq.push(P1(ncost,i));\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l;\n    if(!n&&!m&&!l)break;\n    m--; l--;\n    for(int i=0;i<n;i++){\n      cin>>x>>y>>a>>r;\n      Make_Star();\n    }\n    printf(\"%.20f\\n\",dijkstra());\n    for(int i=0;i<n;i++)Stars.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define PI M_PI\n#define MAX_N 100\n#define INF 1e9\n\nclass Point{\npublic:\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nclass Segment{\npublic:\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nclass Star : public Point{\npublic:\n  double a,r;\n  vector<Segment> segs;\n  Star(){}\n  Star(Point p,double a,double r) : Point(p),a(a),r(r) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nPoint projection(const Segment &s,const Point &p){\n  Vector b = s.t-s.s;\n  double t = dot(p-s.s,b)/norm(b);\n  return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n  Point r = projection(s,p);\n  if(isIntersectSP(s,r)){ return abs(r-p); }\n  return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment a,const Segment b){\n  if(isIntersectSS(a,b)){ return 0; }\n  return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n             min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nistream &operator >> (istream &is,Star &s){\n  return is >> s.x >> s.y >> s.a >> s.r;\n}\n\ndouble toRad(double ang){ return ang*PI/180.0; }\n\nPoint rotate(const Point &bp,const Point &p,double th){\n  double x = p.x, y = p.y;\n  return Point(cos(th)*x-sin(th)*y+bp.x,sin(th)*x+cos(th)*y+bp.y);\n}\n\nvoid makeStar(vector<Star> &stars){\n  int N = stars.size();\n  for(int i = 0 ; i < N ; i++){\n    double x = stars[i].x, y = stars[i].y;\n    double r = stars[i].r, a = stars[i].a;\n    Point bp(x,y), p(x,y+r); p = p - bp;\n    p = rotate(bp,p,toRad(a));\n    vector<Point> ps(5);\n    for(int j = 0 ; j < 5 ; j++){\n      ps[j] = p;\n      p = p - bp;\n      p = rotate(bp,p,toRad(144));\n    }\n    stars[i].segs.resize(5);\n    for(int j = 0 ; j < 5 ; j++){\n      stars[i].segs[j] = Segment(ps[j],ps[(j+2)%5]);\n    }\n  }\n}\n\nint main(){\n  int N,M,L;\n  while(cin >> N >> M >> L, N){\n    vector<Star> stars(N);\n    M--; L--;\n    for(int i = 0 ; i < N ; i++){\n      cin >> stars[i];\n    }\n    makeStar(stars);\n    double d[MAX_N][MAX_N];\n    fill(d[0],d[0]+N*N,INF);\n    for(int i = 0 ; i < N ; i++){\n      d[i][i] = 0;\n      for(int j = i+1 ; j < N ; j++){\n        double dist = INF;\n        for(int k = 0 ; k < 5 ; k++){\n          for(int l = 0 ; l < 5 ; l++){\n            Segment s1 = stars[i].segs[k];\n            Segment s2 = stars[j].segs[l];\n            dist = min(dist,distanceSS(s1,s2));\n          }\n        }\n        d[i][j] = d[j][i] = dist;\n      }\n    }\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\",d[M][L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct point { double x, y; };\nstruct line { point p, q; };\n\nint N, M, L, X[100], Y[100], A[100], R[100];\ndouble d[100][100];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td < 0 && ta * tb < 0;\n}\n\ndouble distance(line l, point p) {\n  double x0 = p.x, y0 = p.y;\n  double x1 = l.p.x, y1 = l.p.y;\n  double x2 = l.q.x, y2 = l.q.y;\n  double a = x2 - x1;\n  double b = y2 - y1;\n  double a2 = a * a;\n  double b2 = b * b;\n  double r2 = a2 + b2;\n  double tt = -(a*(x1 - x0) + b*(y1 - y0));\n  if(tt < 0) return sqrt((x1 - x0)*(x1-x0) + (y1 - y0)*(y1-y0));\n  if(tt > r2) return sqrt((x2 - x0)*(x2 - x0) + (y2 - y0)*(y2 - y0));\n  double f1 = a*(y1 - y0) - b*(x1 - x0);\n  return sqrt((f1*f1)/r2);\n}\n\ndouble distance_star(int a, int b) {\n  point pa[5], pb[5];\n  REP(i, 0, 5) {\n    double xa = X[a] + R[a] * cos((double) (A[a] + 72 * i + 90) / 180 * M_PI);\n    double ya = Y[a] + R[a] * sin((double) (A[a] + 72 * i + 90) / 180 * M_PI);\n    double xb = X[b] + R[b] * cos((double) (A[b] + 72 * i + 90) / 180 * M_PI);\n    double yb = Y[b] + R[b] * sin((double) (A[b] + 72 * i + 90) / 180 * M_PI);\n    pa[i] = (point) { xa, ya };\n    pb[i] = (point) { xb, yb };\n  }\n\n  REP(i, 0, 5) REP(j, 0, 5) {\n    line la = (line) { pa[i], pa[(i + 2) % 5] };\n    line lb = (line) { pb[j], pb[(j + 2) % 5] };\n    if(intersect(la, lb)) return 0;\n  }\n\n  double dist = 1e10;\n  REP(i, 0, 5) REP(j, 0, 5) {\n    line la = (line) { pa[i], pa[(i + 2) % 5] };\n    line lb = (line) { pb[i], pb[(i + 2) % 5] };\n    dist = min(dist, distance(la, pb[i]));\n    dist = min(dist, distance(lb, pa[i]));\n  }\n\n  return dist;\n}\n\nint main(void) {\n  while(cin >> N >> M >> L, N || M || L) {\n    M--;\n    L--;\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> A[i] >> R[i];\n\n    REP(i, 0, N) REP(j, 0, N) d[i][j] = distance_star(i, j);\n    REP(k, 0, N) REP(i, 0, N) REP(j, 0, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    printf(\"%.8lf\\n\", d[M][L]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-7; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(Point a1, Point a2, Point b) {\n  return !ccw(a1, a2, b);\n}\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p) {\n  Point r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  //= !ccw(a1, a2, r)\n  return min(abs(a1-p), abs(a2-p));\n}\n\ndouble distSS(Point a1, Point a2, Point b1, Point b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n   min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nconst double pi = acos(-1);\n\nint main(){\n    int n,s,t;\n    while(cin >>n >>s >>t,n){\n\n        vector<VP> star(n);\n        rep(i,n){\n            double x,y,a,r;\n            cin >>x >>y >>a >>r;\n\n            Point c(x,y);\n\n            star[i] = VP(5);\n            rep(j,5){\n                star[i][j] = c + polar(r,pi/2 + (a+72*2*j)*2*pi/360);\n            }\n        }\n\n        auto dist_star = [&](VP a, VP b){\n            double ret = INF;\n            rep(i,5)rep(j,5){\n                ret = min(ret, distSS(a[i],a[(i+1)%5],b[j],b[(j+1)%5]));\n            }\n            return ret;\n        };\n\n        vector<vector<double>> d(n,vector<double>(n,INF));\n        rep(i,n) d[i][i] = 0;\n        rep(i,n)rep(j,i){\n            d[i][j] = d[j][i]= dist_star(star[i],star[j]);\n        }\n\n        rep(k,n)rep(i,n)rep(j,n) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n        printf(\"%.10f\\n\", d[s-1][t-1]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\nint ccw(const Point& _a, const Point& _b, const Point&  _c) {\n\tVector ba = _b - _a, ca = _c - _a;\n\tif (cross(ba, ca) > EPS) return +1; // ccw\n\tif (cross(ba, ca) < -EPS) return -1; // cw\n\tif (dot(ba, ca) < -EPS) return +2; // c-a-b\n\tif (abs(ba) + EPS < abs(ca)) return -2; // a-b-c\n\treturn 0; // a-c-b\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nbool is_cross(const Segment& _a, const Segment& _b) {\n\treturn (ccw(_a.s, _a.e, _b.s) * ccw(_a.s, _a.e, _b.e) <= 0\n\t\t\t&& ccw(_b.s, _b.e, _a.s) * ccw(_b.s, _b.e, _a.e) <= 0);\n}\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tif (is_cross(a, b)) return 0.0;\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 0.4 * PI));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e5;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tcout << setprecision(20) << setiosflags(ios::fixed) << dst[M-1][L-1] << endl;\n\t//printf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<complex>\n#define INF 10000000.0\n#define pb push_back\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> Point;\ntypedef pair<double ,int > P;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real( conj(a) * b );\n}\ndouble cross(Point a, Point b){\n    return imag( conj(a) * b );\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a)<=0 ) return abs(c-a);\n  if ( dot(a-b, c-b)<=0 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\nint is_intersected_ls(Point a1, Point a2, Point b1, Point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) <=0 ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) <=0 );\n}\ndouble distance_ls_ls(Point a1,Point a2,Point a3,Point a4){\n    if(is_intersected_ls(a1,a2,a3,a4))\n        return 0.0;\n    double r1=distance_ls_p(a1,a2,a3),r2=distance_ls_p(a1,a2,a4),r3=distance_ls_p(a3,a4,a1),r4=distance_ls_p(a3,a4,a2);\n    if(r1>r2)\n    r1=r2;\n    if(r3>r4)\n    r3=r4;\n    if(r1>r3)\n    return r3;\n    return r1;\n     \n}\ndouble cal(int a,int b){\n    double ret=INF;\n    for(int i=0;i<5;i++){\n        for(int j=2;j<4&&i+j<5;j++){\n            for(int k=0;k<5;k++){\n                for(int l=2;l<4&&k+l<5;l++){\n                    double u=distance_ls_ls(p[a][i],p[a][i+j],p[b][k],p[b][k+l]);\n                    if(ret>u)\n                        ret=u;\n                }\n            }\n        }\n    }\n    //cout<<ret<<endl;\n    return ret;\n}\n \n \n \nint main(){\n    while(cin>>n>>s>>g,n||s||g){\n        p.clear();\n        p.resize(n);\n        for(int i=0;i<n;i++){\n            double x,y,a,r;\n            Point pot;\n            cin>>x>>y>>a>>r;\n            Point c=Point(x,y);\n            for(int j=0;j<5;j++){\n                //p[i].pb(c+polar(r,PI*(a+(double)j*72.0+90.0)/180.0));\n            \tp[i].pb(Point(x-sin((a+72*j)*PI/180)*r,y+cos((a+72*j)*PI/180)*r));\n            }\n        }\n        //cout<<\"      \"<<distance_ls_p(p[0][4],p[0][1],p[2][2])<<endl;\n \n         \n        vector<vector<double> > cost(n,vector<double>(n,INF));\n         \n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n            \tif(i==j){\n            \t\tcost[i][j]=0;\n            \t\tcontinue;\n            \t}\n                double a=cal(i,j);\n                cost[i][j]=a;\n                cost[j][i]=a;\n            }\n        }\n    \tfor(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tcost[i][j]=min(cost[i][k]+cost[k][j],cost[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t//cout<<cost[s-1][g-1]<<endl;\n    \tprintf(\"%.8lf\\n\",cost[s-1][g-1]);\n        /*\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cout<<cost[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n         \n        /*priority_queue<P,vector<P>,greater<P> > que;\n        que.push(P(0,s-1));\n        vector<double> d(n,INF);\n        d[s-1]=0;\n        while(!que.empty()){\n            P q=que.top();\n            int pos=q.second;\n            double dist=q.first;\n            que.pop();\n            if(pos==g-1){\n                printf(\"%.8lf\\n\",dist);\n                break;\n            }\n            if(dist>d[pos]){\n                continue;\n            }\n            for(int i=0;i<n;i++){\n                 \n                if(cost[pos][i]==INF){\n                    continue;\n                }\n                if(cost[pos][i]+dist<d[i]){\n                    que.push(P(cost[pos][i]+dist,i));\n                    d[i]=cost[pos][i]+dist;\n                }\n                 \n                 \n            }\n        }*/\n         \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ???\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\n// ????§???¢\ntypedef vector<Point> Polygon;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\ndouble getDist(Polygon a, Polygon b)\n{\n  double ret = inf;\n  for(int i = 0; i < 5; i++) {\n    for(int j = 0; j < 5; j++) {\n      Segment s1 = Segment(a[i], a[(i+2)%5]), s2 = Segment(b[j], b[(j+2)%5]);\n      ret = min(ret, getDistance(s1, s2));\n    }\n  }\n  return ret;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, L;\n  while(cin >> N >> M >> L, N) {\n    M--, L--;\n    vector<Polygon> star;\n    for(int i = 0; i < N; i++) {\n      Point p, q, base; int a, r;\n      cin >> p.x >> p.y >> a >> r;\n      q = Point(p.x, p.y + r);\n      base = q - p;\n      Polygon u;\n      for(int i = 0; i < 5; i++) {\n\tPoint r;\n\tdouble theta = (a+72*i)*M_PI/180;\n\tr.x = base.x*cos(theta) - base.y*sin(theta);\n\tr.y = base.x*sin(theta) + base.y*cos(theta);\n\tr = r + p;\n\tu.push_back(r);\n      }\n      star.push_back(u);\n    }\n    cout << star.size() << endl;\n    double G[101][101];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tG[i][j] = (i == j ? 0 : getDist(star[i], star[j]));\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tfor(int k = 0; k < N; k++) G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n      }\n    }\n\n    cout << G[M][L] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\n#define EPS 1e-07\n#define INF 1e8\n\ntemplate<class T>\nstruct point{\n  T x,y;\n  \n  point (){}\n  point (T _x, T _y) : x(_x), y(_y){}\n\n  point &operator+=(const point &a){ x+=a.x; y+=a.y; }\n  point &operator-=(const point &a){ x-=a.x; y-=a.y; }\n  point operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n  point operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n  operator point<double>()const{ return (point<double>){x,y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\nstruct line{\n  point<T> a,b;\n  operator line<double>()const{ return (line<double>){a,b}; }\n};\n\ntemplate<class T>\nstruct segment{\n  point<T> a,b;\n \n  segment(){}\n  segment(point<T> _a, point<T> _b) : a(_a), b(_b) {}\n\n  operator line<T>()const{ return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b){\n  return a.x * b.x + a.y * b.y;\n}\n\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b){\n  return a.x * b.y - b.x * a.y;\n}\n\nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n  double rdir=cross(b-a,c-a);\n  if(rdir >  EPS) return CCW;\n  if(rdir < -EPS) return CW;\n  return ON;\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b){\n  return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n  if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n  if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n  return (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p){\n  if(dot(S.b-S.a,p-S.a)<=0) return dist(p,S.a);\n  if(dot(S.a-S.b,p-S.b)<=0) return dist(p,S.b);\n  return abs(cross(S.b-S.a,p-S.a))/dist(S.a,S.b);\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n  if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n     || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n     || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n     || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n  return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b) <=0 \n    && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b) <= 0;\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1, const segment<T> &S2){\n  if(intersect(S1,S2)) return 0;\n  return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n\t\t  min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\npoint<double> get_point(double x, double y, double a, double r, long long int tt){\n  const double cnt_ang  = M_PI * ( a + tt * 144 + 90 ) / 180;\n  const double cnt_x    = 1.00 * r * cos( cnt_ang ) + x;\n  const double cnt_y    = 1.00 * r * sin( cnt_ang ) + y;\n  \n  return point<double>(cnt_x, cnt_y);\n}\n\nint main() {\n\n  while( true ) {\n\n    long long int n, m, l;\n    cin >> n >> m >> l;\n    if ( n == 0 ) break;\n\n    vector< vector< segment<double> > > stars;\n\n    for ( long long int i = 0; i < n; i++ ) {\n      double in_x, in_y, in_a, in_r;\n      \n      cin >> in_x >> in_y >> in_a >> in_r;\n      \n      vector<segment<double> > segments;\n      \n      for(long long int tt = 0; tt < 5; tt++){\n\tsegments.push_back(segment<double>(get_point(in_x, in_y, in_a, in_r, tt), \n\t\t\t\t\t   get_point(in_x, in_y, in_a, in_r, (tt + 1) % 5)));\n      }\n\n      stars.push_back(segments);\n    }\n\n    \n\n    double len[101][101];\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tlen[i][j] = i == j ? 0 : INF;\n      }\n    }  \n    \n    for( long long int from_star = 0; from_star < n; from_star++){\n      vector<segment<double> > from_segs = stars[from_star];\n      \n      for(long long to_star = from_star + 1; to_star < n; to_star++){\n\tvector<segment<double> > to_segs = stars[to_star];\n\t\n\tfor(long long from_seg_no = 0; from_seg_no < 5; from_seg_no++){\n\t  for(long long to_seg_no = 0; to_seg_no < 5; to_seg_no++){\n\t    const double dist_ss = dist(from_segs[from_seg_no], to_segs[to_seg_no]);\n\t    \n\t    len[from_star][to_star] = min(len[from_star][to_star], dist_ss);\n\t    len[to_star][from_star] = min(len[to_star][from_star], dist_ss);\n\t    //cout << from_star << \"(\" << from_seg_no << \")\"  << \" \" << to_star << \"(\" << to_seg_no << \")\" << \" \" << dist_ss << endl;\n\t  }\n\t}\n      }  \n    }\n\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\t//cout << i << \" to \" << j << \" => \" << len[i][j] << endl;\n\n\tfor ( long long int k = 0; k < n; k++ ) {    \n\t  len[i][j] = min( len[i][j], len[i][k] + len[k][j] );\n\t}\n      }\n    }\n\n    cout << fixed << setprecision(10) << len[m-1][l-1] << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > DBL_EPSILON)\n\t\treturn 1;\n\tif (cross(b, c) < -DBL_EPSILON)\n\t\treturn -1;\n\tif (dot(b, c) < -DBL_EPSILON)\n\t\treturn 2;\n\tif (norm(b) < norm(c) - DBL_EPSILON)\n\t\treturn 2;\n\treturn 0;\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\ndouble DistanceSP(P a, P b, P c) {\n\tif (dot(b - a, c - a) < DBL_EPSILON)\n\t\treturn abs(c - a);\n\tif (dot(a - b, c - b) < DBL_EPSILON)\n\t\treturn abs(c - b);\n\treturn abs(cross(b - a, c - a));\n}\ndouble DistaiceSS(P a, P b, P c, P d) {\n\tif (isIntersectSS(a, b, c, d)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a, b, c), DistanceSP(a, b, d)),\n\t\t\tmin(DistanceSP(c, d, a), DistanceSP(c, d, b)));\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta = M_PI / 2 + 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta), p.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(a1,p1.vertex)\n\t\tforeach(a2,p1.vertex){\n\t\tif(isIntersectSS(p1.p,p2.p,*a1,*a2)){\n\t\t\tforeach(b1,p2.vertex)\n\t\t\t\tforeach(b2,p2.vertex) {\n\t\t\t\t\tm = min(m, DistaiceSS(*a1, *a2, *b1, *b2));\n\t\t\t}\n\t\t}\n\n\t}\n\treturn m;\n}\nint x, y, a, r;\n\ndouble dijk(int start, int goal) {\n\tvector<double> memo(N, DBL_MAX);\n\tpriority_queue<pair<double,int> > up;\n\tup.push(make_pair(0, start));\n\tmemo[start] = 0;\n\twhile (!up.empty()) {\n\t\tdouble cost = -up.top().first;\n\t\tint pos = up.top().second;\n\n\t\tup.pop();\n\t\tif (memo[pos] < cost)\n\t\t\tcontinue;\n\t\tif (pos == goal)\n\t\t\treturn cost;\n\t\tREP0(next,N) {\n\t\t\tif (links[pos][next] >= 0) {\n\t\t\t\tdouble ncost = cost + links[pos][next];\n\t\t\t\tif (memo[next] > ncost) {\n\t\t\t\t\tmemo[next] = ncost;\n\t\t\t\t\tup.push(make_pair(-ncost, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tcout << dijk(M - 1, L - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tP pt[100][5];\n\t\tfor (int i = 0; i <n; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    S s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    S t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tfor (int k = 0; k < n; k++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#include <complex>\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転（角度）\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\n\nint main(void) {\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        m--,l--;\n        vector<vector<P> > v(n);\n        rep(i,n){ //それぞれの星の頂点をvにpushする\n            P p = inP();\n            double a,r;\n            cin >> a >> r;\n            P t(0,r);\n            rep(j,5){//a+j*72度回転\n                v[i].push_back(turn(t, a+j*72)+p);\n            }\n        }\n\n        double dp[100][100];\n        rep(i,100)rep(j,100) dp[i][j] = INF;\n        rep(i,100) dp[i][i] = 0;\n\n        rep(i,n)rep(a,5)rep(j,n)rep(b,5)if(i<j){\n            L l1(v[i][a],v[i][(a+2)%5]);\n            L l2(v[j][b],v[j][(b+2)%5]);\n            dp[i][j] = dp[j][i] = min(dp[i][j], distanceSS(l1,l2));\n            L l3(v[i][a],v[i][(a+3)%5]);\n            L l4(v[j][b],v[j][(b+3)%5]);\n            dp[i][j] = dp[j][i] = min(dp[i][j], distanceSS(l3,l4));\n        }\n        //rep(i,n)rep(j,n)if(i<j)cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        rep(k,n)rep(i,n)rep(j,n){\n            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n        }\n        cout << shosu(10) << dp[m][l] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\ntypedef complex<ld> Point;\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine () : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle () : p(Point(0, 0)), r(0) {}\n\tCircle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll (Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps){\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d,\tc.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0,\t1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j,n) res += cross(p[j], p[(j+1)%n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i,n) {\n\t\tPoint a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i,n) {\n\t\tPoint a = poly[i], b = poly[(i+1)%n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i,n) {\n\t\tPoint A = ps[i], B = ps[(i+1)%n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i,m) {\n\t\tvector<pair<ld,int>> vec;\n\t\tREP(j,n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j,vec.size()-1) {\n\t\t\tint from = vec[j].second, to = vec[j+1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i,m) {\n\t\tvector<pair<ld,int>> vec;\n\t\tREP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j,vec.size()-1) {\n\t\t\tint from = vec[j].second, to = vec[j+1].second;\n\t\t\tld angle = vec[j+1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i,1024) REP(j,1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld,int,bool>>> tup(N);\n\tREP(i,s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i,N) sort(ALL(tup[i]));\n\tREP(i,N) {\n\t\tREP(j,tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i,N) REP(j,i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back((Edge){from, to});\n\t\t\tg[to].push_back((Edge){to, from});\n\t\t}\n\t}\n\treturn g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nstruct Star {\n    Point p;\n    double angle, r;\n};\n\nvector< vector<double> > G;\n\nvector<Point> V(const Star& s) {\n    vector<Point> res;\n    Point p = polar(s.r, pi/2+pi*s.angle/180);\n    REP(i, 5) {\n        res.pb(s.p + p);\n        p *= polar(1.0, 2*pi/5);\n    }\n    return res;\n}\nvector<Line> L(const Star& s) {\n    vector<Point> p = V(s);\n    vector<Line> res;\n    assert(p.size() == 5);\n    REP(i, p.size()) {\n        res.pb({p[i], p[(i+2)%5]});\n    }\n    return res;\n}\ndouble D(const Star& s1, const Star& s2) {\n    vector<Line> v1 = L(s1), v2 = L(s2);\n    double ans = linf;\n    REP(i, v1.size()) REP(j, v2.size()) {\n        ans = min<double>(ans, dist_ss(v1[i], v2[j]));\n    }\n    return ans;\n}\nvector<double> dijkstra(int s) {\n    vector<double> res(G.size(), linf);\n    using Pair = pair<double, int>;\n    priority_queue<Pair, vector<Pair>, greater<Pair>> Q;\n    res[s] = 0;\n    Q.push({0, s});\n    while ( !Q.empty() ) {\n        Pair p = Q.top(); Q.pop();\n        double c; int v; tie(c, v) = p;\n        if (c > res[v]+eps) continue;\n        REP(to, G.size()) {\n            if ( res[v] + G[v][to] < res[to]-eps ) {\n                res[to] = res[v] + G[v][to];\n                Q.push({res[to], to});\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n, s, t;\n    while (cin >> n >> s >> t, n || s || t) {\n        --s, --t;\n        vector<Star> v;\n        REP(i, n) {\n            int x, y, a, r; cin >> x >> y >> a >> r;\n            v.pb({{(double)x, (double)y}, (double)a, (double)r});\n        }\n        G.assign(n, vector<double>(n, linf));\n        REP(i, n) REP(j, n) {\n            G[i][j] = D(v[i], v[j]);\n        }\n        cout << fixed << setprecision(10) << dijkstra(s)[t] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\ndouble eps = 0.0000001;\n// asin(1.) * 2\ndouble pi = 3.14159265358979323846264338327950288;\nusing p2 = complex<double>;\n// x: real\n// y: imag\n\ndouble det(p2 v1, p2 v2) {\n  return v1.real() * v2.imag() - v1.imag() * v2.real();\n}\n\ndouble dot(p2 v1, p2 v2) {\n  return v1.real() * v2.real() + v1.imag() * v2.imag();\n}\n\ndouble dist2(p2 v) { return dot(v, v); }\n\ndouble dist(p2 v) { return sqrt(dist2(v)); }\n\nbool same(double x, double y) { return fabs(x - y) < eps; }\n\ndouble dist2(p2 l1, p2 l2) { return dot(l1 - l2, l1 - l2); }\n\ndouble dist(p2 l1, p2 l2) { return sqrt(dist2(l1, l2)); }\n\nint ccw(p2 a, p2 b, p2 c) {\n  b -= a;\n  c -= a;\n  if (det(b, c) > eps)\n    return 1;\n  if (det(b, c) < -eps)\n    return -1;\n  if (dot(b, c) < -eps)\n    return 2;\n  if (dist2(b) < dist2(c))\n    return -2;\n  return 0;\n}\n\nauto p2comp = [](const p2 &l, const p2 &r) {\n  if (fabs(l.real() - r.real()) > eps)\n    return l.real() < r.real();\n  return l.imag() < r.imag();\n};\n\nstruct Line {\n  p2 st, ed;\n\n  Line(p2 st, p2 ed) : st(st), ed(ed) {}\n\n  Line(double x1, double y1, double x2, double y2)\n      : st(p2(x1, y1)), ed(p2(x2, y2)) {}\n\n  Line(p2 st, double x, double y) : st(st), ed(p2(x, y)) {}\n\n  Line(double x, double y, p2 ed) : st(p2(x, y)), ed(ed) {}\n\n  double dist() { return sqrt(dist2(st, ed)); }\n\n  bool isPalla(Line l) { return fabs(det(ed - st, l.ed - l.st)) < eps; }\n\n  double x() { return ed.real() - st.real(); }\n\n  double y() { return ed.imag() - st.imag(); }\n\n  p2 v() { return ed - st; }\n};\n\n// l1.st + (l1.st - l1.ed) * r.first = l2.st + (l2.st - l2.ed) * r.second\n// 方程式を満たす(r.first, r.second)を返す\n// l1.isPalla(l2) => (nan, nan)\npair<double, double> interP(Line l1, Line l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.st.real() + l2.st.real();\n  double e2 = -l1.st.imag() + l2.st.imag();\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\n\nbool intersec(Line l1, Line l2) {\n  if (l1.isPalla(l2))\n    return false;\n  auto r = interP(l1, l2);\n  return eps < r.first && r.first < 1. - eps && eps < r.second &&\n         r.second < 1. - eps;\n}\n\ndouble inter_r(Line l, p2 c) { return dot(c - l.st, l.v()) / dist2(l.v()); }\n\ndouble dist(Line l, p2 c) {\n  double r = inter_r(l, c);\n  if (r < -eps)\n    return dist(l.st, c);\n  if (r > 1. + eps)\n    return dist(l.ed, c);\n  return dist(l.st + l.v() * r, c);\n}\n\np2 nearest(Line l, p2 c) {\n  double r = inter_r(l, c);\n  if (r < -eps)\n    return l.st;\n  if (1. + eps < r)\n    return l.ed;\n  return l.st + l.v() * r;\n}\n\ndouble dist(Line l1, Line l2) {\n  if (intersec(l1, l2))\n    return 0.;\n  return min(min(dist(l1, l2.st), dist(l1, l2.ed)),\n             min(dist(l2, l1.st), dist(l2, l1.ed)));\n}\n\nstruct Poly {\n  vector<p2> ps;\n  double d;\n\n  Poly(vector<p2> ps) : ps(ps) {\n    d = 0;\n    for (int i = 0; i < ps.size(); i++)\n      d += dist(ps[i], ps[(i + 1) % ps.size()]);\n  }\n\n  // 頂点上/辺上は微妙\n  bool include(p2 p) {\n    // 半直線\n    Line l(p, p2(-10000, -1));\n    int c = 0;\n    for (int i = 0; i < ps.size(); i++) {\n      if (intersec(l, Line(ps[i], ps[(i + 1) % ps.size()])))\n        c++;\n    }\n    return c % 2 == 1;\n  }\n\n  bool include(p2 p, bool on_vert, bool on_edge) {\n    for (auto &q : ps)\n      if (dist(p, q) < eps)\n        return on_vert;\n    for (int i = 0; i < ps.size(); i++) {\n      if (ccw(ps[i], ps[(i + 1) % ps.size()], p) == 0)\n        return on_edge;\n    }\n    return include(p);\n  }\n\n  bool intersecl(Line l) {\n    for (int i = 0; i < ps.size(); i++) {\n      if (intersec(l, Line(ps[i], ps[(i + 1) % ps.size()])))\n        return true;\n    }\n    return false;\n  }\n};\n\nvector<Line> star(p2 p, double deg, double r) {\n  vector<p2> ps;\n  double d = 2. / 5. * pi;\n  for (int i = 0; i < 5; i++) {\n    double theta = d * ((i * 3) % 5) + deg;\n    ps.push_back(p2(-sin(theta) * r, cos(theta) * r) + p);\n  }\n  vector<Line> ls;\n  for (int j = 0; j < 5; j++) {\n    ls.push_back(Line(ps[j], ps[(j + 1) % 5]));\n  }\n  return ls;\n}\n\nstruct N {\n  int i;\n  double d;\n};\n\nbool operator<(const N &l, const N &r) { return l.d < r.d; }\n\ndouble dist(vector<Line> l1, vector<Line> l2) {\n  double ret = numeric_limits<double>::infinity();\n  for (auto &l : l1)\n    for (auto &r : l2)\n      ret = min(ret, dist(l, r));\n  return ret;\n}\n\nint main() {\n  while (true) {\n    int n, s, t;\n    cin >> n >> s >> t;\n    if (n == 0)\n      break;\n    s--;\n    t--;\n    vector<vector<Line>> ls;\n    for (int i = 0; i < n; i++) {\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      ls.push_back(star(p2(x, y), a / 180. * pi, r));\n    }\n    multiset<N> q;\n    q.insert(N{s, 0});\n    vector<vector<double>> cost(n, vector<double>(n));\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        cost[j][i] = cost[i][j] = dist(ls[i], ls[j]);\n      }\n    }\n\n    vector<bool> used(n);\n    while (q.size()) {\n      N now = *q.begin();\n      q.erase(q.begin());\n      if (used[now.i])\n        continue;\n      used[now.i] = true;\n      if (now.i == t) {\n        printf(\"%.20lf\\n\", now.d);\n        break;\n      }\n      for (int i = 0; i < n; i++) {\n        if (used[i])\n          continue;\n        q.insert(N{i, now.d + cost[now.i][i]});\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<utility>\n#include<queue>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\nconst ld eps = 1e-8, pi = acos(-1.0);\nstruct L { P a, b; };\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nld dist_pp(P p, P q) {\n  return abs(p - q);\n}\n\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  ld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n  ld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n  return min(a, b);\n}\n\nP rotate(ld deg, P p) {\n  ld rad = deg * pi / 180.0;\n  return polar(1.0l, rad) * p;\n}\n\nstruct Star { L e[5]; };\n\nld dist_stst(Star s, Star t) {\n  ld val = dist_ss(s.e[0], t.e[0]);\n  for (L ss : s.e) for (L ts : t.e) {\n    val = min(val, dist_ss(ss, ts));\n    val = min(val, \n          min(dist_pp(ss.a,ts.a),\n          min(dist_pp(ss.a,ts.b),\n          min(dist_pp(ss.b,ts.a), dist_pp(ss.b,ts.b)))));\n  }\n  return val;\n}\n\nint main() {\n  int n, m, l;\n  while (cin >> n >> m >> l and n) {\n    m--; l--;\n    vector<Star> stars(n);\n    for (Star &s : stars) {\n      ld x, y, a, r;\n      cin >> x >> y >> a >> r;\n      P center(x, y), d(0,r);\n      for (int i = 0; i < 5; i++) {\n        s.e[i].a = s.e[(i+4)%5].b = center + rotate(a + 72 * i, d);\n      }\n    }\n\n    vector<vector<ld>> dist(n);\n    for (vector<ld> &v : dist) {\n      v.reserve(n);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        dist[i][j] = dist_stst(stars[i], stars[j]);\n      }\n    }\n\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    cout << fixed << setprecision(30)<< dist[m][l] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n#define eps 1.0e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tdouble add(double a, double b){\n\t\tif(abs(a+b) < eps * (abs(a) + abs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, ope.x);\n\t\ttmp.y = add(y, ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, -ope.x);\n\t\ttmp.y = add(y, -ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn add(x*ope.y,  -y*ope.x);\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= 0;\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) <= 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) <= 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+1)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.12f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS 1e-10\n#define INF 1e8\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Poly;\nstatic const double pi = acos(-1.0);\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < -EPS) return 2;\n  if(norm(b-a)+EPS < norm(c-a))return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble p_to_s_dist(P p, L s){\n  if(dot(p-s.first,s.second-s.first) >= 0 &&\n     dot(p-s.second,s.first-s.second) >= 0) return abs(cross(p-s.first,s.second-s.first))/abs(s.second-s.first);\n  return min(abs(p-s.first),abs(p-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\ndouble Poly_to_Poly_dist(Poly a, Poly b){\n  double dist = INF;\n  int na = a.size(), nb = b.size();\n  a.push_back(a[0]);\n  b.push_back(b[0]);\n  for(int i = 0; i < na; ++i){\n    for(int j = 0; j < na; ++j){\n      dist = min(dist,s_to_s_dist(L(a[i],a[i+1]),L(b[j],b[j+1])));\n    }\n  }\n  return dist;\n}\n\nPoly star(P p, double r, double a){\n  Poly ret;\n  for(int i = 0; i < 5; ++i){\n    ret.push_back(P(polar(r,(a+90+144*i)/360*2*pi)+p));\n  }\n  return ret;\n}\n\nint main(){\n  int N, M, L;\n  double x, y, a, r;\n  while(cin >> N >> M >> L, N){\n    vector<Poly> stars(N);\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y >> a >> r;\n      stars[i] = star(P(x,y),r,a);\n    }\n    vector< vector<double> > WF(N, vector<double>(N, INF));\n    for(int i = 0; i < N; ++i){\n      for(int j = i; j < N; ++j){\n\tif(i == j) WF[i][j] = 0;\n\telse{\n\t  WF[i][j] = Poly_to_Poly_dist(stars[i],stars[j]);\n\t  WF[j][i] = WF[i][j];\n\t}\n      }\n    }\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n\tfor(int j = 0; j < N; ++j){\n\t  WF[i][j] = min(WF[i][j], WF[i][k] + WF[k][j]);\n\t}\n      }\n    }\n    printf(\"%.10lf\\n\", WF[M-1][L-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, m, n) for (int i = m; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(v) v.begin(), v.end()\n#define MP make_pair\nusing ld = long double;\nconstexpr ld DINF = 1e18;\nconstexpr ld PI = acos(-1.0);\nconstexpr ld EPS = 1e-13;\n\nstruct dijkstra\n{\n    int V;\n    struct edge\n    {\n        int to;\n        ld cost;\n    };\n    vector<vector<edge>> E;\n    vector<ld> d;\n    using pt = pair<ld, int>;\n    dijkstra(int V_) : V(V_)\n    {\n        E.resize(V);\n        d.resize(V);\n    }\n\n    void add_E(int a, int b, ld c)\n    {\n        E[a].emplace_back(edge{b, c});\n        E[b].emplace_back(edge{a, c});\n    }\n\n    void calc(int s)\n    {\n        priority_queue<pt, vector<pt>, greater<pt>> que;\n        d.assign(V, DINF);\n        que.emplace(0.0, s);\n        d[s] = 0.0;\n        while (!que.empty())\n        {\n            pt p = que.top();\n            que.pop();\n            int v = p.second;\n            if (d[v] < p.first)\n                continue;\n            for (auto &&e : E[v])\n            {\n                if (d[e.to] > d[v] + e.cost)\n                {\n                    d[e.to] = d[v] + e.cost;\n                    que.emplace(d[e.to], e.to);\n                }\n            }\n        }\n    }\n};\n\nstruct point_t\n{\n    ld x, y;\n    int exception = 0;\n    constexpr point_t operator+(const point_t &p) const noexcept\n    {\n        return point_t{this->x + p.x, this->y + p.y};\n    }\n    constexpr point_t operator-(const point_t &p) const noexcept\n    {\n        return point_t{this->x - p.x, this->y - p.y};\n    }\n};\n\nstruct line_t\n{\n    ld a, b, c;\n    int exception = 0;\n};\n\ninline bool Same(point_t &p1, point_t &p2)\n{\n    return (abs(p1.x - p2.x) < EPS && abs(p1.y - p2.y) < EPS);\n}\n\ninline ld Dist(point_t &p1, point_t &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\ninline point_t Rotate(point_t &p, ld theta)\n{\n    return point_t{p.x * cos(theta) - p.y * sin(theta), p.x * sin(theta) + p.y * cos(theta)};\n}\n\nline_t Line2p(point_t &p1, point_t &p2)\n{\n    if (Same(p1, p2))\n        return line_t{0, 0, 0, 1};\n    line_t res;\n    res.a = p2.y - p1.y;\n    res.b = p1.x - p2.x;\n    res.c = (p2.x - p1.x) * p1.y - (p2.y - p1.y) * p1.x;\n    return res;\n}\n\nline_t VerticalLine(point_t &p, line_t &l)\n{\n    line_t res;\n    res.a = l.b;\n    res.b = -l.a;\n    res.c = l.a * p.y - l.b * p.x;\n    return res;\n}\n\npoint_t Intersection(line_t &l1, line_t &l2)\n{\n    point_t res;\n    if (abs(l1.a * l2.b - l1.b * l2.a) < EPS || abs(l1.b * l2.a - l1.a * l2.b) < EPS)\n        return point_t{0, 0, 1};\n    res.x = (l1.b * l2.c - l1.c * l2.b) / (l1.a * l2.b - l1.b * l2.a);\n    res.y = (l1.a * l2.c - l1.c * l2.a) / (l1.b * l2.a - l1.a * l2.b);\n    return res;\n}\n\ninline bool OnLineseg(point_t &p, point_t &L, point_t &R)\n{\n    if (abs(L.x - R.x) < EPS && abs(L.y - R.y) < EPS)\n        return abs(L.x - p.x) < EPS;\n    if (abs(L.x - R.x) < EPS)\n    {\n        ld k = (p.y - L.y) / (R.y - L.y);\n        return (0.0 <= k && k <= 1.0);\n    }\n    else\n    {\n        ld k = (p.x - L.x) / (R.x - L.x);\n        return (0.0 <= k && k <= 1.0);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(50) << setiosflags(ios::fixed);\n\n    while (1)\n    {\n        int n, start, goal;\n        cin >> n >> start >> goal;\n        if (n == 0)\n            return 0;\n        start--, goal--;\n        vector<ld> x(n), y(n), a(n), r(n);\n        rep(i, n)\n        {\n            cin >> x[i] >> y[i] >> a[i] >> r[i];\n            a[i] = a[i] * PI / 180.0;\n        }\n        vector<vector<point_t>> vp;\n        vp.resize(n);\n        rep(i, n)\n        {\n            point_t center = {x[i], y[i]};\n            rep(ri, 5)\n            {\n                point_t p = {x[i], y[i] + r[i]};\n                ld theta = 4.0 / 5.0 * PI * ld(ri) + a[i];\n                p = p - center;\n                p = Rotate(p, theta);\n                p = p + center;\n                vp[i].push_back(p);\n            }\n            vp[i].push_back(vp[i][0]);\n        }\n\n        dijkstra ds(n);\n        rep(i, n) REP(j, i + 1, n)\n        {\n            ld Min = DINF;\n            // 点と点\n            rep(ii, 5) rep(jj, 5)\n            {\n                Min = min(Min, Dist(vp[i][ii], vp[j][jj]));\n            }\n\n            //点と線分\n            rep(ii, 5) rep(jj, 5)\n            {\n                point_t p = vp[i][ii], L = vp[j][jj], R = vp[j][jj + 1];\n                line_t l = Line2p(L, R);\n                if (l.exception != 0)\n                    continue;\n                line_t m = VerticalLine(p, l);\n                if (m.exception != 0)\n                    continue;\n                point_t q = Intersection(l, m);\n                if (q.exception != 0)\n                    continue;\n                if (OnLineseg(q, L, R))\n                    Min = min(Min, Dist(p, q));\n            }\n\n            //線分と点\n            rep(ii, 5) rep(jj, 5)\n            {\n                point_t p = vp[j][ii], L = vp[i][jj], R = vp[i][jj + 1];\n                line_t l = Line2p(L, R);\n                if (l.exception != 0)\n                    continue;\n                line_t m = VerticalLine(p, l);\n                if (m.exception != 0)\n                    continue;\n                point_t q = Intersection(l, m);\n                if (q.exception != 0)\n                    continue;\n                if (OnLineseg(q, L, R))\n                    Min = min(Min, Dist(p, q));\n            }\n\n            //線分と線分（交点があるかだけ調べる）\n            rep(ii, 5) rep(jj, 5)\n            {\n                point_t L1 = vp[i][ii], R1 = vp[i][ii + 1];\n                point_t L2 = vp[j][jj], R2 = vp[j][jj + 1];\n                line_t l = Line2p(L1, R1);\n                line_t m = Line2p(L2, R2);\n                if (l.exception != 0)\n                    continue;\n                if (m.exception != 0)\n                    continue;\n                point_t p = Intersection(l, m);\n                if (p.exception != 0)\n                    continue;\n                if (OnLineseg(p, L1, R1) && OnLineseg(p, L2, R2))\n                    Min = 0.0;\n            }\n\n            ds.add_E(i, j, Min);\n        }\n        ds.calc(start);\n        cout << ds.d[goal] << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdio>\n#include<iomanip>\n#define EPS 1.0e-12\n#define INF 1.0e+12\n#define INFI 1000000\nusing namespace std;\n//2次元座標\nclass point{\npublic:\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y){\n\t\tthis->x=x;\n\t\tthis->y=y;\n\t}\n\tdouble len(point &p){\n\t\treturn sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));\n\t}\n\tpoint operator*(double d){\n\t\tpoint p(x*d,y*d);\n\t\treturn p;\n\t}\n\tpoint operator+(point &o){\n\t\tpoint p(x+o.x,y+o.y);\n\t\treturn p;\n\t}\n\tpoint operator-(point &o){\n\t\tpoint p(x-o.x,y-o.y);\n\t\treturn p;\n\t}\n\tbool operator==(point &o){\n\t\treturn (x==o.x && y==o.y);\n\t}\n\tbool operator!=(point &o){\n\t\treturn !(x==o.x && y==o.y);\n\t}\n};\n//内積\ndouble dot(point p,point q){\n\treturn (p.x*q.x+p.y*q.y);\n}\n//外積\ndouble cross(point p,point q){\n\treturn (p.x*q.y-p.y*q.x);\n}\n//線分と点\ndouble SegmentPoint(point p,point q,point r){\n\tif(dot(q-p,r-p)<EPS) return abs(r.len(p));\n\tif(dot(p-q,r-q)<EPS) return abs(r.len(q));\n\treturn abs(cross(q-p,r-p))/abs(q.len(p));\n}\n//同一直線上じゃないか、重なっている部分が存在する\nbool han(point p0,point p1,point q0,point q1){\n\tif(cross(p0-p1,q0-p0)==0.0 && cross(p0-p1,q1-p0)){//同一直線\n\t\tif(abs(p0.len(q0))+abs(q0.len(p1))<abs(p0.len(p1))+EPS ||\n\t\t\tabs(p0.len(q1))+abs(q1.len(p1))<abs(p0.len(p1))+EPS){\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//線分線分\nbool SegSeg(point p0,point p1,point q0,point q1){\n\tint a=cross(p1-p0,q0-p0);\n\tint b=cross(p1-p0,q1-p0);\n\tint c=cross(q1-q0,p0-q0);\n\tint d=cross(q1-q0,p1-q0);\n\treturn (a*b<EPS)&&(c*d<EPS)&&(han(p0,p1,q0,q1));\n}\n//アウグストゥスみたいななにか\nclass route{\nprivate:\n\tdouble **cost;\n\tdouble *dist;\n\tbool *used;\n\tint v;\npublic:\n\troute(){}\n\troute(int v){\n\t\tthis->v=v;\n\t\tcost=new double*[v];\n\t\tfor(int i=0;i<v;i++) cost[i]=new double[v];\n\t\tdist=new double[v];\n\t\tused=new bool[v];\n\t}\n\tvoid format(double c){\n\t\tfor(int i=0;i<v;i++) for(int j=0;j<v;j++) cost[i][j]=c;\n\t}\n\tvoid set(int n,int m,double c){\n\t\tcost[n][m]=c;\n\t\tcost[m][n]=c;\n\t}\n\tvoid set(int s){\n\t\tfor(int i=0;i<this->v;i++){\n\t\t\tdist[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tdist[s]=0;\n\t\twhile(true){\n\t\t\tint p=-1;\n\t\t\tfor(int i=0;i<this->v;i++){\n\t\t\t\tif(!used[i] && (p==-1 || dist[i]<dist[p])) p=i;\n\t\t\t}\n\t\t\tif(p==-1) break;\n\t\t\tused[p]=true;\n\t\t\tfor(int i=0;i<v;i++){\n\t\t\t\tdist[i]=min(dist[i],dist[p]+cost[p][i]);\n\t\t\t}\n\t\t}\n\t}\n\tdouble RetCost(int e){\n\t\treturn dist[e];\n\t}\n\tdouble ret(int i,int j){\n\t\treturn cost[i][j];\n\t}\n};\n\nstruct st_star{\n\tpoint p[6];\n};\n\nst_star *star;\nroute *r;\n\nint main(){\n\tint i,j,k,l;\n\tint n,m,q;\n\tint x,y,a,t;\n\tcout<<setprecision(20)<<setiosflags(ios::fixed);\n\twhile(cin>>n>>m>>q){\n\t\tif(n==0 && m==0 && q==0) break;\n\t\tr=new route(n);\n\t\tstar=new st_star[n];\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>x>>y>>a>>t;\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tstar[i].p[j].x=x+t*cos(((a+90+216*j)%360)*M_PI/180);\n\t\t\t\tstar[i].p[j].y=y+t*sin(((a+90+216*j)%360)*M_PI/180);\n\t\t\t}\n\t\t\tstar[i].p[5]=star[i].p[0];\n\t\t}\n\t\t//交わりor最短\n\t\tfor(i=0;i<n;i++){\n\t\t\tr->set(i,i,0);\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[0],star[j].p[1])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[1],star[j].p[2])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[2],star[j].p[3])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[3],star[j].p[4])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[4],star[j].p[5])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k==5){\n\t\t\t\t\tdouble p=INF;\n\t\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\t\tfor(l=0;l<5;l++){\n\t\t\t\t\t\t\tp=min(p,SegmentPoint(star[i].p[k],star[i].p[k+1],star[j].p[l]));\n\t\t\t\t\t\t\tp=min(p,SegmentPoint(star[j].p[k],star[j].p[k+1],star[i].p[l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr->set(i,j,p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr->set(m-1);\n\t\tprintf(\"%.25lf\\n\",r->RetCost(q-1));\n\t\tdelete r;\n\t\tdelete []star;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long double)1e18\nusing namespace std;\n\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1);\nconst long double EPS = 1e-10;\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment\nlong double dot(CP a, CP b) { return (a * conj(b)).X; }\nlong double cross(CP a, CP b) { return (a * conj(b)).Y; }\nlong double corner(CP a, CP b) {\n  //[0,pi]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP intersection(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\n// p on (a,b)?\nbool on_seg(CP a, CP b, CP p) {\n  // if not use end point, dot(a - p, b - p) < 0\n  return abs(cross(a - p, b - p)) <= 1e-10 &&\n         dot(a - p, b - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersection(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong double distLP(CP a, CP b, CP p) {\n  return abs(cross(b - a, p - a) / abs(b - a));\n}\n\n// segmentver.\nlong double distSP(CP a, CP b, CP p) {\n  if(dot(b - a, p - a) < 0) return abs(p - a);\n  if(dot(a - b, p - b) < 0) return abs(p - b);\n  return distLP(a, b, p);\n}\n\nstruct line {\n  CP s, t;\n};\n\nstruct data {\n  long double x, y, a, r;\n  line l[5];\n};\n\nstruct dijk {\n  long long p;\n  long double dis;\n};\nbool operator<(const dijk &l, const dijk &r) {\n  return l.dis > r.dis;\n}\n\nCP memo[5];\nlong long n, st, go;\nvector<vector<long double>> dis;\nvector<long double> dp;\nvector<data> v;\npriority_queue<dijk> pq;\n\nlong double solve();\nlong double calc(line &x, line &y);\nlong double linedis(line &now, CP &p);\n\nint main() {\n  cout << fixed << setprecision(10);\n  for(int i = 1; i <= 5; ++i) {\n    long double nowrad = PI / 2 + 2 * i * PI / 5;\n    memo[i - 1] = CP(cos(nowrad), sin(nowrad));\n    memo[i - 1] /= abs(memo[i - 1]);\n  }\n  while(1) {\n    cin >> n >> st >> go;\n    if(n + st + go == 0) break;\n    --st, --go;\n    v.resize(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> v[i].x >> v[i].y >> v[i].a >> v[i].r;\n      v[i].a *= PI / 180;\n      CP rot(cos(v[i].a), sin(v[i].a));\n      rot /= abs(rot);\n      for(int j = 0; j < 5; ++j) {\n        v[i].l[j].s = memo[j] * rot;\n        v[i].l[j].s *= v[i].r;\n        v[i].l[j].s += CP(v[i].x, v[i].y);\n\n        v[i].l[j].t = memo[(j + 2) % 5] * rot;\n        v[i].l[j].t *= v[i].r;\n        v[i].l[j].t += CP(v[i].x, v[i].y);\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong double solve() {\n  dis.assign(n, vector<long double>(n, 0));\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      if(i != j) {\n        dis[i][j] = inf;\n        for(int k = 0; k < 5; ++k)\n          for(int l = 0; l < 5; ++l)\n            dis[i][j] =\n                min(dis[i][j], calc(v[i].l[k], v[j].l[l]));\n      }\n  dp.assign(n, inf);\n  dp[st] = 0;\n  pq.push({st, 0});\n  while(!pq.empty()) {\n    dijk now = pq.top();\n    pq.pop();\n    if(dp[now.p] != now.dis) continue;\n    for(int i = 0; i < n; ++i)\n      if(now.p != i) {\n        dijk nextp = now;\n        nextp.p = i;\n        nextp.dis += dis[now.p][nextp.p];\n        if(dp[nextp.p] > nextp.dis) {\n          dp[nextp.p] = nextp.dis;\n          pq.push(nextp);\n        }\n      }\n  }\n  return dp[go];\n}\n\nlong double calc(line &x, line &y) {\n  if(iscross(x.s, x.t, y.s, y.t)) return 0;\n  long double res = inf;\n  res = min(res, distSP(x.s, x.t, y.s));\n  res = min(res, distSP(x.s, x.t, y.t));\n  res = min(res, distSP(y.s, y.t, x.s));\n  res = min(res, distSP(y.s, y.t, x.t));\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\ntypedef complex<double> P;\nstruct seg{P p1,p2;};\ndouble eps=1e-10;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;\n  if(a.imag()<-eps)return -1;\n  if(a.real()<-eps)return 2;\n  if(abs(b)+eps<abs(c))return -2;\n  return 0;\n}\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\nint main(){\n  double a,b,c,d;\n  int n,ve,al;\n  while(cin>>n>>ve>>al,n){\n    P p[n][5];\n    seg D[n][5];\n    r(i,n){\n      cin>>a>>b>>c>>d;\n      r(j,5)p[i][j]=P(a-d*sin(M_PI/180*(72*j+c)),b+d*cos(M_PI/180*(72*j+c)));\n      r(j,5)D[i][j].p1=p[i][j%5],D[i][j].p2=p[i][(j+2)%5];\n    }\n    double w[n][n];\n    r(i,n)r(j,n)w[i][j]=i==j?0:1000000000;\n    r(i,n)R(j,i+1,n){\n      double t=1000000000;\n      r(k,5)r(l,5)t=min(t,dist(D[i][k].p1,D[i][k].p2,D[j][l].p1,D[j][l].p2));\n      w[i][j]=w[j][i]=t;\n    }\n    r(k,n)r(i,n)r(j,n)w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    printf(\"%.11f\\n\",w[ve-1][al-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n//for vector\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline D seg_seg_dis(L a,L b){\n  D res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nD g[111][111];\nL l[5], stars[111][5];\nP v[5];\n\nint main(){\n  int n,m,l;\n  while(scanf(\"%d%d%d\",&n,&m,&l), n){\n    for(int i=0;i<n;i++){\n      int x,y,a,r;\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      P c = P(x,y);\n\n      P p = P(0,r);\n      for(int j=0;j<5;j++){\n\tv[j] = c+rotate(p,PI*(a+j*72)/180);\n      }\n      \n      for(int j=0;j<5;j++){\n\tstars[i][j] = L(v[j],v[(j+2)%5]);\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : stars[i]){\n\t  for(L b : stars[j]){\n\t    if(is_cp(a,b)){\n\t      dis = 0;\n\t      break;\n\t    }else dis = min(dis, seg_seg_dis(a,b));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n      g[i][i] = 0;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    printf(\"%.9lf\\n\",g[m-1][l-1]);\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\nint ccw(const Point& _a, const Point& _b, const Point&  _c) {\n\tVector ba = _b - _a, ca = _c - _a;\n\tif (cross(ba, ca) > EPS) return +1; // ccw\n\tif (cross(ba, ca) < -EPS) return -1; // cw\n\tif (dot(ba, ca) < -EPS) return +2; // c-a-b\n\tif (abs(ba) + EPS < abs(ca)) return -2; // a-b-c\n\treturn 0; // a-c-b\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nbool is_cross(const Segment& _a, const Segment& _b) {\n\treturn (ccw(_a.s, _a.e, _b.s) * ccw(_a.s, _a.e, _b.e) <= 0\n\t\t\t&& ccw(_b.s, _b.e, _a.s) * ccw(_b.s, _b.e, _a.e) <= 0);\n}\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tif (is_cross(a, b)) return 0.0;\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 0.4 * PI));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e5;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x, &y, &a, &r);\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define rep(i,n) for(int i=0,i##_len=n;i<i##_len;i++)\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Line> make_star(int x, int y, int a, int r){\n  int d = 5;\n  ld rad = 2 * pi / 5;\n  Point p(x, y);\n  Point v(0, r);\n  ld aa = a/180.0 * pi;\n  v *= Point(cos(aa), sin(aa));\n  Point rot(cos(rad), sin(rad));\n  vector<Line> res;\n  rep(i, d){\n    res.emplace_back(v + p,v * rot + p);\n    v *= rot;\n  }\n  return res;\n}\n\ntemplate <typename Cost>\nstruct CEdge {\n  int from, to;\n  Cost cost;\n  CEdge(int s, int t, Cost c) : from(s), to(t), cost(c) {}\n};\n\ntemplate<typename Cost> using CGraph = vector<vector<CEdge<Cost>>>;\n\ntemplate <typename Cost>\nvoid add_edge(CGraph<Cost> &g, int from, int to, Cost cost) {\n  g[from].emplace_back(from, to, cost);\n}\n\nconst int inf = 1e9;\n\ntemplate <typename Cost>\nvector<Cost> dijkstra(const CGraph<Cost> &g, int s, Cost zero = 0) {\n  vector<Cost> d(g.size(), inf);\n  d[s] = zero;\n  using P = pair<Cost,int>;\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(zero, s));\n  while (!que.empty()) {\n    Cost dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    for (const auto &e: g[v]) {\n      if (d[e.to] <= d[v] + e.cost) continue;\n      d[e.to] = d[v] + e.cost;\n      que.push(P(d[e.to], e.to));\n    }\n  }\n  return d;\n}\n\nld dist_stars (vector<Line> s, vector<Line> t){\n  ld res = 1e30l;\n  for(auto&& ss: s){\n    for(auto&& tt: t){\n      res = min(res, dist_ss(ss, tt));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n, m, l;\n  while(cin >> n >> m >> l, n != 0){\n    vector<vector<Line>> stars(n);\n    rep(i, n){\n      int x, y, a, r; cin >> x >> y >> a >> r;\n      stars[i] = make_star(x, y, a, r);\n    }\n    CGraph<ld> g(n);\n    rep(i, n){\n      rep(j, n){\n        add_edge(g, i, j, dist_stars(stars[i], stars[j]));\n      }\n    }\n    vector<ld> route = dijkstra(g, n - 1);\n    cout << std::setprecision(12) << route[m - 1] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m, l;\n\nvector<Point> p[110];\n\ndouble dist(Point p) { return abs(p); }//ベクトルpの絶対値\ndouble dist(Point a, Point b) {//2点間の距離\n\treturn abs(a - b);\n}\n\nPoint rot(Point p, double a) {//aはrad\n\tdouble x1 = p.real(), y1 = p.imag();\n\treturn Point(x1*cos(a) - y1*sin(a), x1*sin(a) + y1*cos(a));\n}\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t};\n\n\tdouble d[100010];\n\tvector<edge> G[100010];//各頂点からの辺\n\n\tvoid clear() {\n\t\trep(i, 100010)G[i].clear();\n\t}\n\n\tvoid dijkstra(int start) {\n\t\tfill(d, d + 100010, INF);\n\t\td[start] = 0;\n\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, start));\n\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second;\n\t\t\tif (d[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m >> l&&n + m + l) {\n\t\tm--; l--;\n\t\trep(i, 110)p[i].clear();\n\t\tdk.clear();\n\t\trep(i, n) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tPoint po = Point(0, r);\n\t\t\tpo = rot(po, 2 * PI *a / 360);\n\t\t\trep(j, 5) {\n\t\t\t\t//cout << po.real() << \" \" << po.imag() << endl;\n\t\t\t\tp[i].push_back(po + Point(x, y));\n\t\t\t\tpo = rot(po, 2 * PI / 5);\n\t\t\t}\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\trep(j, 5) {\n\t\t//\t\tcout << p[i][j].real() << \" \" << p[i][j].imag() << endl;\n\t\t//\t}\n\t\t//}\n\t\trep(i, n) {\n\t\t\tFOR(j, i + 1, n) {\n\t\t\t\tdouble mind = INF;\n\t\t\t\trep(k, p[i].size()) {\n\t\t\t\t\trep(l, p[j].size()) {\n\t\t\t\t\t\tmind = min(dist(p[i][k], p[j][l]), mind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << mind << endl;\n\t\t\t\tdk.G[i].push_back({ j,mind });\n\t\t\t\tdk.G[j].push_back({ i,mind });\n\t\t\t}\n\t\t}\n\t\tdk.dijkstra(m);\n\t\tprintf(\"%.10lf\\n\", dk.d[l]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  int n,m,l;cin >> n>>m>>l;\n  if(n==0) break;\n  Polygon stars[n];\n  //int r[n];\n  for(int i=0;i<n;i++){\n    int x,y,a,r;cin>>x>>y>>a>>r;\n    for(int j=0;j<5;j++){\n      Point v=Point(x,y)+Point(r*cos((18+a+72*j)*(2*PI)/360),r*sin((18+a+72*j)*(2*PI)/360));\n      stars[i].push_back(v);\n    }\n  }\n  ld dis[n][n];\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n    if(i==j) dis[i][j]=0.0;\n    else dis[i][j]=INF;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ld tmp=INF;\n      for(int k=0;k<5;k++){\n        for(int l=0;l<5;l++){\n          tmp=min(tmp,sqrt(norm(stars[i][k]-stars[j][l])));\n        }\n      }\n      dis[i][j]=tmp;dis[j][i]=tmp;\n    }\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);\n      }\n    }\n  }\n  cout << setprecision(10)<<dis[m-1][l-1] << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\ntypedef complex<double> PT;\ntypedef PT VC;\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b) / abs(l.fi-l.se));\n}\n\n// ??\\??????????????????????????????\n\n// ???????????´??????????????£???????????????false??????????????§??¨???\nbool has_intersec_seg_seg(SG a, SG b) {\n\tVC va, vb, vc;\n\tbool res = true;\n\tfor(int i = 0; i < 2; i++) {\n\t\tva = b.fi-a.fi; vb = b.se-a.fi; vc = a.se-a.fi;\n\t\tres = res && cross_prod(va, vc) * cross_prod(vb, vc) < EPS;\n\t\tswap(a,b);\n\t}\n\tres = res && abs(cross_prod(a.fi-a.se, b.fi-b.se)) > EPS;\n\treturn res;\n}\n\ndouble dist_pts_seg(PT p, SG a) {\n\tdouble res;\n\tres = min(abs(a.fi-p), abs(a.se-p));\n\tif(dot_prod(a.se - a.fi, p - a.fi) > -EPS\n\t\t\t&& dot_prod(a.fi - a.se, p - a.se) > -EPS)\n\t\tres = min(res, dist_pts_line(p, a));\n\treturn res;\n}\n\ndouble dist_seg_seg(SG a, SG b) {\n\tdouble res = DBL_MAX;\n\tfor(int i = 0; i < 2; i++) {\n\t\tres = min(res, min(dist_pts_seg(a.fi,b), dist_pts_seg(a.se,b)));\n\t\tswap(a,b);\n\t}\n\tif(has_intersec_seg_seg(a,b))\n\t\tres = 0;\n\treturn res;\n}\n\n/* //???????????????\nint main() {\n\tSG a(PT(0,0),PT(0,2));\n\tSG b(PT(-1,1),PT(2,1));\n\tcout << dist_seg_seg(a,b) << endl;\n} // */\n\n//*\nint N, M, L;\nvector<vector<SG> > star;\ndouble edge[120][120];\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nvoid init() {\n\tstar.clear();\n\trep(i,120) {\n\t\trep(j,120)\n\t\t\tedge[i][j] = 1e9;\n\t\tedge[i][i] = 0;\n\t}\n}\n\nint main() {\n\twhile(cin >> N >> M >> L, N || M || L) {\n\t\tinit();\n\t\tM--; L--;\n\t\trep(i,N) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<PT> tmp;\n\t\t\tdouble theta = (a+90) / 180.0 * M_PI;\n\t\t\tdouble phi = 360.0 / 5.0 / 180.0 * M_PI;\n\t\t\trep(i,5) {\n\t\t\t\ttmp.push_back(polar((double)r, theta + phi * i) + PT(x,y));\n\t\t\t//\tcout << tmp[i] << endl;\n\t\t\t}\n\t\t\tvector<SG> push;\n\t\t\trep(i,5) {\n\t\t\t\tpush.push_back(SG(tmp[i],tmp[(i+2)%5]));\n\t\t\t}\n\t\t\tstar.push_back(push);\n\t\t}\n\n\t\trep(i,N) {\n\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\tdouble tmp = 1e9;\n\t\t\t\trep(k,5) {\n\t\t\t\t\trep(l, 5) {\n\t\t\t\t\t\ttmp = min(tmp, dist_seg_seg(star[i][k], star[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\trep(i,N) {\n\t\t\trep(j,N) {\n\t\t\t\trep(k,N) {\n\t\t\t\t\tedge[j][k] = min(edge[j][k], edge[j][i] + edge[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", edge[L][M]);\n\t}\n}\n// */"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef complex<double> P;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetitionint\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef complex<double> P;\nstruct star{\n\tP p[5];\n};\nstar stars[111];\ndouble dist[111][111];\n\ndouble dot(P p,P q){\n\treturn real(conj(p)*q);\n}\n\ndouble cross(P p,P q){\n\treturn imag(conj(p)*q);\n}\n\n\n\ndouble distPointPoint(P p1, P p2){\n\treturn sqrt(norm(p1-p2));\n}\n\ndouble distPointSeg(P r,P p1, P p2){\n\tdouble t = dot(p2-p1, r-p1)/norm(p2-p1);\n\tif(0.0<=t && t<=1.0)return distPointPoint(r, (1.0-t)*p1+t*p2);\n\telse return min(distPointPoint(r,p1),distPointPoint(r,p2));\n}\n\nbool isIntersect(P p1, P p2, P q1, P q2){\n\treturn (cross(p2-p1, q1-p1)*cross(p2-p1, q2-p1) < 0.0) && (cross(q2-q1, p1-q1)*cross(q2-q1, p2-q1) < 0.0);\n}\n\ndouble distSegSeg(P p1, P p2, P q1, P q2){\n\tif(isIntersect(p1,p2,q1,q2))return 0.0;\n\tdouble ret=distPointSeg(p1, q1, q2);\n\tret = min(ret,distPointSeg(p2, q1, q2));\n\tret = min(ret,distPointSeg(q1, p1, p2));\n\tret = min(ret,distPointSeg(q2, p1, p2));\n\treturn ret;\n}\n\ndouble distStarStar(star s1, star s2){\n\tdouble ret = 1.0e20;\n\tREP(i,5){\n\t\tREP(j,5){\n\t\t\tret = min(ret, distSegSeg(s1.p[i], s1.p[(i+1)%5], s2.p[j], s2.p[(j+1)%5]));\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n,s,e;\n\tdouble pi=acos(-1.0);\n\twhile(cin>>n>>s>>e, n){\n\t\tREP(i,n){\n\t\t\tdouble x,y,a,r;\n\t\t\tcin >> x>>y>>a>>r;\n\t\t\tREP(j,5){\n\t\t\t\tdouble theta = (a+144.0*j)/180.0;\n\t\t\t\tstars[i].p[j] = P(x-r*sin(theta*pi),y+r*cos(theta*pi));\n\t\t\t}\n\t\t}\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tif(i==j)dist[i][j]=0.0;\n\t\t\t\telse dist[i][j] = distStarStar(stars[i], stars[j]);\n\t\t\t}\n\t\t}\n\t\tREP(k,n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,n){\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", dist[s-1][e-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ostream>\n#include<cmath>\n#include<cstdio>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\ndouble x[101],y[101];\nint a[101],r[101];\n#define PI 3.14159265358979324\n\nstruct point{\n\tdouble x,y;\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint operator-(point ano){\n\t\treturn point(x-ano.x,y-ano.y);\n\t}\n\tdouble operator*(point ano){\n\t\treturn x*ano.x+y*ano.y;\n\t}\n\tdouble abs(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tstring to_str(){\n\t\tstringstream s;\n\t\ts<<\"(\"<<x<<\",\"<<y<<\")\";\n\t\treturn s.str();\n\t}\n};\ndouble dist(point a,point b){\n\treturn (a-b).abs();\n}\nstruct line{\n\tpoint a,b;\n\tdouble A,B,C;\n\tline(point a,point b):a(a),b(b){\n\t\tA=(a.y-b.y);B=-(a.x-b.x);C=a.x*b.y-a.y*b.x;\n\t}\n\tpoint diff(){return b-a;}\n\tbool inc(double x,double y){\n\t\treturn (a.x-x)*(b.x-x)<=0 && (a.y-y)*(b.y-y)<=0;\n\t}\n\tstring to_str(){\n\t\tstringstream s;\n\t\ts<<a.to_str()<<\"~\";\n\t\ts<<b.to_str();\n\t\treturn s.str();\n\t}\n};\ndouble dist_point_line(point x,line l){\n\tdouble xl1=(x-l.a)*l.diff();\n\tdouble xl2=(x-l.b)*l.diff();\n\tif(xl1*xl2>0){\n\t\treturn min(dist(l.a,x),dist(l.b,x));\n\t}else{\n\t\treturn abs(l.A*x.x+l.B*x.y+l.C)/sqrt(l.A*l.A+l.B*l.B);\n\t}\n}\nbool cross(line a,line b){\n\tdouble d=a.A*b.B-a.B*b.A;\n\tif(abs(d)<1e-8)return false;\n\tdouble x=-(b.B*a.C-a.B*b.C)/d;\n\tdouble y=-(a.A*b.C-b.A*a.C)/d;\n\treturn a.inc(x,y)&&b.inc(x,y);\n\n}\nbool nonparalell(){return false;}\ndouble dist_lines(line a,line b){\n\t//cross\n\tif(cross(a,b)){\n\t\treturn 0;\n\t}\n\tdouble mind=10000000000;\n\tmind=min(mind,dist_point_line(a.a,b));\n\tmind=min(mind,dist_point_line(a.b,b));\n\tmind=min(mind,dist_point_line(b.a,a));\n\tmind=min(mind,dist_point_line(b.b,a));\n\treturn mind;\n}\nclass star{\npublic:\n\tdouble sx[5],sy[5];\n\tvector<line> l;\n\tint x,y,a,r;\n\tstar(double X,double Y,int A,int R){\n\t\tx=X;y=Y;a=A;r=R;\n\t\tinit();\n\t}\n\tvoid init(){\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tsx[i]=(double)x-(double)r*sin(PI/180*(a+72*i));\n\t\t\t\tsy[i]=y+r*cos(PI/180*(a+72*i));\n\t\t\t}\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tl.push_back(line(point(sx[i],sy[i]),point(sx[(i+2)%5],sy[(i+2)%5])));\n\t\t\t}\n\t}\n\tstring to_str()const{\n\t\tstringstream s;\n\t\ts<<\"[\";\n\t\tfor(int i=0;i<5;i++){\n\t\t\ts<<\"(\";\n\t\t\ts<<sx[i];\n\t\t\ts<<\", \";\n\t\t\ts<<sy[i];\n\t\t\ts<<\")\";\n\t\t}\n\t\ts<<\"]\";\n\t\treturn s.str();\n\t}\n};\ndouble dist(star a,star b){\n\tdouble s=1e+9;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\ts=min(s,dist_lines(a.l[i],b.l[j]));\n\t\t\t}\n\t\t}\n\t\treturn s;\n}\n\ndouble mp[101][101];\nint main(void){\n\tint n,m,l;\n\tvector<star> stars;\n\twhile(cin>>n>>m>>l&&n){\n\t\tstars.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>a[i]>>r[i];\n\t\t\tstar st(x[i],y[i],a[i],r[i]);\n\t\t\tstars.push_back(st);\n\t\t\t//cout<<st.to_str()<<endl;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdouble d=dist(stars[i],stars[j]);\n\t\t\t\tmp[i][j]=d;\n\t\t\t\t//cout<<\"dist[\"<<i<<\",\"<<j<<\"]=\"<<d<<endl;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdouble t=mp[i][k]+mp[k][j];\n\t\t\t\t\tif(t<mp[i][j]){\n\t\t\t\t\t\tmp[i][j]=t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\",mp[m-1][l-1]);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <complex>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double PI  = 2 * acos(0);\nconst double EPS = 1e-8;\n\nstruct S{\n  P p1;\n  P p2;\n  S(P p,P q) : p1(p), p2(q) {}\n  S(){}\n};\n\nint ccw(P p0, P p1, P p2){\n  P d1 = p1-p0;\n  P d2 = p2-p0;\n  double dx1 = d1.real(), dx2 = d2.real();\n  double dy1 = d1.imag(), dy2 = d2.imag();\n\n  if(dx1*dy2 > dy1*dx2) return  1;\n  if(dx1*dy2 < dy1*dx2) return -1;\n  if((dx1*dx2 < 0) || (dy1*dy2 < 0)) return -1;\n  if((dx1*dx1+dy1*dy1) < (dx2*dx2+dy2*dy2)) return 1;\n  return 0;\n}\n\nbool intersect(const S &s1, const S &s2){\n  return ((ccw(s1.p1, s1.p2, s2.p1)\n           *ccw(s1.p1, s1.p2, s2.p2)) <= 0)\n    &&((ccw(s2.p1, s2.p2, s1.p1)\n        *ccw(s2.p1, s2.p2, s1.p2)) <= 0);\n}\n\ninline double inp(const P& a, const P& b) {\n  return (conj(a)*b).real();\n}\n\ninline P proj(const P& p, const P& b) {\n  return b * inp(p, b) / norm(b);\n}\n\ninline P perf(const S& l, const P& p){\n  return l.p1 - proj(l.p1 - p, l.p2 - l.p1);\n}\n\ndouble dist(const S &s, const P &p){\n  const P r = perf(s, p);\n  const double pos = ((r - s.p1) / (s.p2 - s.p1)).real();\n  if( - EPS <= pos && pos <= EPS )\n    return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble dist(const S &s, const S &t){\n  if(intersect(s, t)) return 0.0;\n  return min(dist(s, t.p1), min(dist(s, t.p2), min(dist(t, s.p1), dist(t, s.p2))));\n}\n\nint main(){\n  while(true){\n    const int n = getInt();\n    const int m = getInt();\n    const int l = getInt();\n\n    if(n + m + l == 0) break;\n\n    vector<vector<S> > v(n, vector<S>(5));\n\n    REP(i,n){\n      const int x = getInt();\n      const int y = getInt();\n      const int a = getInt();\n      const int r = getInt();\n\n      P pos = P(x, y) + P(0, r) * P(cos(a / 180.0 * PI), sin(a / 180.0 * PI));\n      P dir = P(cos((270 - 18 + a) / 180.0 * PI), sin((270 - 18 + a) / 180.0 * PI));\n\n      const double rr = r * cos(18 / 180.0 * PI) * 2;\n\n      REP(j,5){\n        v[i][j] = S(pos, pos + dir * rr);\n\n        pos = pos + dir * rr;\n        dir = dir * P(cos((180 - 36) / 180.0 * PI), sin((180 - 36) / 180.0 * PI));\n      }\n    }\n\n    vector<vector<double> > dst(n, vector<double>(n));\n\n    REP(i,n) REP(j,i){\n      double d = 1e10;\n      REP(ii,5) REP(jj,5){\n        d = min(d, dist(v[i][ii], v[j][jj]));\n      }\n      dst[i][j] = dst[j][i] = d;\n    }\n\n    REP(k,n) REP(i,n) REP(j,n)\n      dst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\n    printf(\"%.8f\\n\", dst[m - 1][l - 1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<complex>\n#define INF 10000000\n#define pb push_back\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> Point;\ntypedef pair<double ,int > P;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real( conj(a) * b );\n}\ndouble cross(Point a, Point b){\n    return imag( conj(a) * b );\n}\ndouble dlp(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a)<=0 ) return abs(c-a);\n  if ( dot(a-b, c-b)<=0 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\nint iil(Point a1, Point a2, Point b1, Point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) <=0 ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) <=0 );\n}\ndouble dll(Point a1,Point a2,Point a3,Point a4){\n    if(iil(a1,a2,a3,a4))\n        return 0.0;\n\treturn min(min(dlp(a1,a2,a3),dlp(a1,a2,a4)),min(dlp(a3,a4,a1),dlp(a3,a4,a2)));\n}\ndouble cal(int a,int b){\n    double ret=INF;\n    for(int i=0;i<5;i++){\n        for(int j=2;j<4&&i+j<5;j++){\n            for(int k=0;k<5;k++){\n                for(int l=2;l<4&&k+l<5;l++){\n                    double u=dll(p[a][i],p[a][i+j],p[b][k],p[b][k+l]);\n                    if(ret>u)\n                        ret=u;\n                }\n            }\n        }\n    }\n    return ret;\n}\nint main(){\n    while(cin>>n>>s>>g,n||s||g){\n        p.clear();\n        p.resize(n);\n        for(int i=0;i<n;i++){\n            double x,y,a,r;\n            cin>>x>>y>>a>>r;\n            Point c=Point(x,y);\n            for(int j=0;j<5;j++){\n            \tp[i].pb(c+polar(r,(a+72.0*j+90)*PI/180.0));\n            }\n        }\n        vector<vector<double> > cost(n,vector<double>(n,INF));\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n            \tif(i==j){\n            \t\tcost[i][j]=0;\n            \t\tcontinue;\n            \t}\n                double a=cal(i,j);\n                cost[i][j]=cost[j][i]=a;\n            }\n        }\n    \tfor(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tcost[i][j]=min(cost[i][k]+cost[k][j],cost[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprintf(\"%.8lf\\n\",cost[s-1][g-1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs(d1)<Abs(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\ntypedef Line Segment;\n\nPoint Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\nbool InterLS(Line l,Segment s){\n\tPoint a=l.pos,b=l.pos+l.dir,c=s.pos,d=s.pos+s.dir;\n\treturn CCW(a,b,c)*CCW(a,b,d)<0;\n}\nbool InterSS(Segment a,Segment b){\n\treturn InterLS(a,b) && InterLS(b,a);\n}\ndouble DistLP(Line l,Point p){\n\treturn Abs(Proj(l,p)-p);\n}\ndouble DistSP(Segment s,Point p){\n\tint ccw=CCW(s.pos,s.pos+s.dir,Proj(s,p));\n\tif(ccw==-2)\n\t\treturn Abs(p-s.pos);\n\tif(ccw==2)\n\t\treturn Abs(p-(s.pos+s.dir));\n\treturn DistLP(s,p);\n}\ndouble DistLS(Line l,Segment s){\n\tif(InterLS(l,s)) return 0;\n\treturn min(DistLP(l,s.pos),DistLP(l,s.pos+s.dir));\n}\ndouble DistSS(Segment a,Segment b){\n\tif(InterSS(a,b)) return 0;\n\tdouble d1=min(DistSP(a,b.pos),DistSP(a,b.pos+b.dir));\n\tdouble d2=min(DistSP(b,a.pos),DistSP(b,a.pos+a.dir));\n\treturn min(d1,d2);\n}\n\nint main()\n{\n\tfor(int n,src,dst;scanf(\"%d%d%d\",&n,&src,&dst),n|src|dst;){\n\t\tvi xs(n),ys(n),as(n),rs(n);\n\t\trep(i,n) scanf(\"%d%d%d%d\",&xs[i],&ys[i],&as[i],&rs[i]);\n\t\t\n\t\tvvd dp(n,vd(n,INFTY));\n\t\tint counter=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tPoint p1[6],p2[6];\n\t\t\trep(k,6){\n\t\t\t\tp1[k]=Point(xs[i],ys[i])+Rot(Point(0,rs[i]),(as[i]+k*144)*PI/180);\n\t\t\t\tp2[k]=Point(xs[j],ys[j])+Rot(Point(0,rs[j]),(as[j]+k*144)*PI/180);\n\t\t\t}\n\t\t\trep(k,5) rep(l,5){\n\t\t\t\tcounter++;\n\t\t\t\tSegment s1(p1[k],p1[k+1]-p1[k]);\n\t\t\t\tSegment s2(p2[l],p2[l+1]-p2[l]);\n\t\t\t\tdp[i][j]=min(dp[i][j],DistSS(s1,s2));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tprintf(\"%.10f\\n\",dp[src-1][dst-1]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nclass Star{\npublic:\n\tvector<L> star;\n\tvoid add(P p1,P p2){\n\t\tstar.push_back(L(p1,p2));\n\t}\n\t\n\tdouble dist(const Star &s){\n\t\tdouble res=INF;\n\t\tfor(int i=0;i<star.size();i++){\n\t\t\tfor(int j=0;j<s.star.size();j++){\n\t\t\t\tres=min(res,distanceSS(star[i],s.star[j]));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n};\n\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tvector<Star> stars(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,a,r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\t\n\t\t\tdouble theta=M_PI/180.0*a;\n\t\t\tdouble theta2=M_PI/180.0*72.0;\n\t\t\t\n\t\t\tvector<P> p(5);\n\t\t\t\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tp[j]=P(0,r)*polar(1.0,theta+j*theta2)+P(x,y);\n\t\t\t\t//cout<<p[j]<<endl;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tstars[i].add(p[(2*j)%5],p[(2+2*j)%5]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<double> > dist(n,vector<double>(n,INF));\n\t\tfor(int i=0;i<n;i++) dist[i][i]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++) dist[i][j]=dist[j][i]=stars[i].dist(stars[j]);\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.16f\\n\",dist[m-1][n-1]);\n\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const double PI = acos(-1.0);\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nint ccw(const P& a, P b, P c)\n{\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) {\n    return +1;\n  } else if (cross(b, c) < -EPS) {\n    return -1;\n  } else if (dot(b, c) < -EPS) {\n    return +2;\n  } else if (dot(b, b) + EPS < dot(c, c)) {\n    return -2;\n  } else {\n    return 0;\n  }\n}\n\nstruct segment\n{\n  P a, b;\n  segment() {}\n  segment(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool intersects(const segment& seg) const\n  {\n    return\n      ccw(a, b, seg.a) * ccw(a, b, seg.b) <= 0\n      && ccw(seg.a, seg.b, a) * ccw(seg.a, seg.b, b) <= 0;\n  }\n\n  inline double distance(const P& p) const\n  {\n    if (dot(b-a, p-a) < EPS) {\n      return abs(p-a);\n    } else if (dot(a-b, p-b) < EPS) {\n      return abs(p-b);\n    } else {\n      return abs(cross(b-a, p-a))/abs(b-a);\n    }\n  }\n\n  inline double distance(const segment& seg) const\n  {\n    if (intersects(seg)) {\n      return 0;\n    } else {\n      return\n        min(\n            min(distance(seg.a), distance(seg.b)),\n            min(seg.distance(a), seg.distance(b)));\n    }\n  }\n};\n\nstruct star\n{\n  segment segs[5];\n  star(double x, double y, double a, double r) {\n    const P o(x, y);\n    P p(0, r);\n    p *= polar(1.0, a/180.0*PI);\n    const P m = polar(1.0, 72.0/180.0*PI);\n    P ps[5];\n    for (int i = 0; i < 5; i++) {\n      ps[i] = o + p;\n      p *= m;\n    }\n    for (int i = 0, j = 0; i < 5; i++) {\n      segs[i] = segment(ps[j], ps[(j+2) % 5]);\n      j = (j+2) % 5;\n    }\n  }\n\n  double distance(const star& s) const\n  {\n    double ans = 1e10;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        ans = min(ans, segs[i].distance(s.segs[j]));\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF && N != 0) {\n    --M; --L;\n    vector<star> stars;\n    for (int i = 0; i < N; i++) {\n      int x, y, a, r;\n      scanf(\"%d %d %d %d\", &x, &y, &a, &r);\n      stars.push_back(star(x, y, a, r));\n    }\n\n    vector<vector<double> > g(N, vector<double>(N));\n    for (int i = 0; i < N; i++) {\n      for (int j = i+1; j < N; j++) {\n        double d = stars[i].distance(stars[j]);\n        g[i][j] = g[j][i] = d;\n      }\n    }\n    priority_queue<pair<double,int> > q;\n    vector<double> dist(N, 1e10);\n    dist[M] = 0;\n    q.push(make_pair(0.0, M));\n    while (!q.empty()) {\n      const double d = -q.top().first;\n      const int n = q.top().second;\n      q.pop();\n      if (n == L) {\n        printf(\"%.20f\\n\", fabs(d));\n        break;\n      }\n      for (int i = 0; i < N; i++) {\n        if (n == i) {\n          continue;\n        }\n        const double dd = d + g[n][i];\n        if (dd < dist[i]) {\n          dist[i] = dd;\n          q.push(make_pair(-dd, i));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\nP pt[101][5];\ndouble dp[101][101];\n  \nint N,M,L;\n\ndouble get_min(int m,int n){\n    if(m==n) return 0;\n    double mn = 1e100;\n    static int idx[] = {0,2,4,1,3,0};\n    for (int i = 0; i < 5; i++){\n        S s = S(pt[n][idx[i]],pt[n][idx[i + 1]]);\n        for (int j = 0; j < 5; j++){\n            S t = S(pt[m][idx[j]],pt[m][idx[j + 1]]);\n            mn = min(mn,dist(s,t));\n        }\n    }\n    return mn;\n}\n   \nint main()\n{\n    while(cin>>N>>M>>L,(N||M||L)){\n        for (int i = 0; i < N; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n   \n        for(int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                dp[i][j] = get_min(i,j);\n   \n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++)\n                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n   \n        printf(\"%.20lf\\n\",dp[M - 1][L - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n// ?????\\??????????????´???????????\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // ???????????§?????????????£°?????\\??????\ntypedef vector <P> Pol;\n\n// ??§????????????????????§?????????\ninline B cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\ninline B cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\ninline B cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// ???????????¬?¬??????????\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// ??????\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ????????¢???\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n// verify AOJ 2514\nP proj(P b,P p){ return b*ip(b,p)/norm(b);} \nP proj(L l,P p){ return l.first+proj(vec(l),p-l.first);}\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\ninline int ccw(P base, P a, P b) {              //??????a?????¨??????b???????????±??´??§??¨?????????????????????\n  a -= base; b -= base;\n  if (ep(a, b) > eps)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < -eps)      return RIGHT;   // clockwise\n  if (ip(a, b) < -eps)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  a?????¨b????????±?£??????????????£?????????????\n}\n\n// ??±?£???? ??¶??´??±???\n\t// ???????????¨??¶??´??±?£???????????±¬\n\t// ???????????¨??±?£?????????????????±¬\n\t// ??¶??´??±?£??????¶??´??±?£???????????±¬\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ????????????\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// ???????????¨??¶??´??±?£??????±?£??????¢??¢?¨???£??????????????????????????????\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ???????????¨??¶??´??±?£??????±?£??????¢??¢?¨???£?????????????±¬\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n// ??????\n// Verify AOJ 1183\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n//2?????????????????????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l, c.c);\n\tP e = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(h - c.c));\n\tres.pb(h - e);\n\tres.pb(h + e);\n\treturn res;\n}\n\n\n// ??????????¬???\\??±???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\n\n// ??????????????±?¨??£??£???±???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//?????±?¨??£?????¬???\\??±???\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ?????±?¨??£????????£???±???\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//?¬???\\????????§???????????¨?????§????£???±???\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(i,5)\n\t\t\tres.pb(tanC(a,i));\n\t}\n\treturn res;\n}\n\n\n// ?????????\n\n// ????????§????????¢\n\n// ????????§????????¢?????????????????????????£?????(??????????????§????????¢??§??????)\n//verify AOJ CGL_3-C\nint in_polygon(Pol pol,P p){\n    int n=pol.size();\n    int res=0;\n    rep(i,n){\n        if(ccw(pol[i],pol[(i+1)%n],p)==MID)\n            return 1;\n        if ((pol[i].Y <= p.Y) && (pol[(i+1)%n].Y>p.Y)){\n            D vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X < pol[i].X + vt*dx)\n                    res++;\n        }else if ((pol[i].Y>p.Y)&&(pol[(i+1)%n].Y<=p.Y)){\n            D vt=(p.Y - pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X <pol[i].X+vt*dx)\n                res--;\n        }\n    }\n    return res?2:0;\n}\n\n\n// ????????§????????¢?????????????????????????£?????(??????????????§????????¢??§??????)\n// Verify AOJ 2514\n\nbool in_polygon(Pol pol,L s){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar=L(pol[i],pol[(i+1)%n]);\n\t\tif(iSS(s,tar))\n\t\t\tcheck.pb(pLL(s,tar));\n\t}\n\n\tcheck.pb(s.first);\n\tcheck.pb(s.second);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\tbool res=true;\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m))\n\t\t\tres=false;\n\t}\n\treturn res;\n}\n\n\n// Area\n// Verify AOJ 1100\nD area(Pol pol){\n\tint n=pol.size();\n\tD xx,yy,sum=0.0;\n\trep(i,n){\n\t\txx=pol[i%n].X-pol[(i+1)%n].X;\n\t\tyy=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=xx*yy;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// hough T\n// ??§??¢????????????????????????\n\n\n\n// Convex_hull\n// Verify AOJ 0063\nPol convex_hull(Pol pol){\n\tint n=pol.size();\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tPol res(2*n);\n\tint k=0;\n\t\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n/*\n\n// now developing\nvector<L> merge_L(vector<L>){\n\n}\n\n\n\nPol normalize_polygon(Pol pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+2)%n],pol[(i+1)%n])==MID)\n\t\t\t// remove pol[(i+1)%n]\n\t\t\tn--;\n\t}\n}\n*/\n\ntypedef pair<P, pii> Star;\n#define F first\n#define S second\n\nint main(void){\n    for(int n, s, z; cin >> n >> s >> z, n;){\n        s--, z--;\n\n        vector<Star> stars(n);\n        for(auto && ss : stars){\n            int x, y;\n            cin >> x >> y >> ss.S.F >> ss.S.S;\n            ss.F = P(x, y);\n        }\n\n        vector<VP> p;\n        for(auto && ss : stars){\n            VP cur(5);\n\n            D a = ss.S.F;\n            int r = ss.S.S;\n            P root(0, r);\n\n            rep(i, 5){\n                cur[i] = rot(P(0, 0), root, (a + 72 * i) / 180.0 * pi);\n\n                cur[i] += ss.F;\n            }\n\n            p.pb(cur);\n        }\n\n        vector<vector<D>> minDist(n, vector<D>(n, inf));\n        rep(i, n){\n            rep(j, n){\n                rep(ii, 5){\n                    rep(jj, 5){\n                        minDist[i][j] = min(minDist[i][j], sqrt(sqr(p[i][ii].X - p[j][jj].X) + sqr(p[i][ii].Y - p[j][jj].Y)));\n                    }\n                }\n            }\n        }\n\n        rep(k, n){\n            rep(i, n){\n                rep(j, n){\n                    minDist[i][j] = min(minDist[i][j], minDist[i][k] + minDist[k][j]);\n                }\n            }\n        }\n\n        printf(\"%.15Lf\\n\", minDist[s][z]);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n\ntypedef ld Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nconst Weight INF =1e14;\n\nvoid shortestPath(const Graph &g, int s,\n\t\t  vector<Weight> &dist, vector<int> &prev) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, -1);\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n    for(auto f=g[e.dst].begin(); f!=g[e.dst].end();f++) {\n      if (dist[f->dst] > e.weight+f->weight) {\n\tdist[f->dst] = e.weight+f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n}\n\n\nint main(){\n  int N,M,L;\n  while(cin >> N >> M >> L,N){\n    M--;\n    L--;\n    Graph g(5*N);\n    vector<Line> ls(5*N);\n    for(int i=0;i<N;i++){\n      ld x,y,a,r;\n      cin >> x >> y >> a >> r;\n      vector<Point> ps(5);\n      for(int j=0;j<5;j++){\n\tld b=a+j*72;\n\tb=b*pi/180;\n\tps[j]=Point(x-r*sin(b), y+r*cos(b));\n      }\n      for(int j=0;j<5;j++)\n\tls[i*5+j]=Line(ps[j], ps[(j+1)%5]);\n    }\n    for(int from=0;from<5*N;from++){\n      for(int to=from+1;to<5*N;to++){\n\tg[from].push_back(Edge(from,to,dist_ss(ls[to],ls[from])));\n\tg[to].push_back(Edge(to,from,dist_ss(ls[to],ls[from])));\n      }\n    }\n    vector<Weight> dist;\n    vector<int> prev;\n    shortestPath(g,M*5,dist,prev);\n    printf(\"%.10Lf\\n\",dist[L*5]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\nint ccw(const Point& _a, const Point& _b, const Point&  _c) {\n\tVector ba = _b - _a, ca = _c - _a;\n\tif (cross(ba, ca) > EPS) return +1; // ccw\n\tif (cross(ba, ca) < -EPS) return -1; // cw\n\tif (dot(ba, ca) < -EPS) return +2; // c-a-b\n\tif (abs(ba) + EPS < abs(ca)) return -2; // a-b-c\n\treturn 0; // a-c-b\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nbool is_cross(const Segment& _a, const Segment& _b) {\n\treturn (ccw(_a.s, _a.e, _b.s) * ccw(_a.s, _a.e, _b.e) <= 0\n\t\t\t&& ccw(_b.s, _b.e, _a.s) * ccw(_b.s, _b.e, _a.e) <= 0);\n}\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 0.4 * PI));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[4] + c, vp[1] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[3] + c, vp[0] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e5;\n\tfor_(i,0,5) for_(j,0,5) if (is_cross(a.vs[i], b.vs[j])) return 0.0;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_point_seg(a.vs[i].s, b.vs[j]));\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_point_seg(b.vs[i].s, a.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x, &y, &a, &r);\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#define EPS 1e-9\n#define INF 1e10\n\n\nusing namespace std;\n\nstruct P{\n\tdouble x,y;\n};\nstruct L{\n\tP p1,p2;\n};\nstruct STAR{\n\tP p[5];\n\tL l[5];\n};\n\nSTAR star[102];\ndouble dp[102][102];\n\nvoid setStar(STAR *star, int x, int y, int a, int r){\n\tint i;\n\tfor(i=0;i<5;i++){\n\t\tstar->p[i].x = x+r*cos((double)M_PI*(a+90+i*72)/180);\n\t\tstar->p[i].y = y+r*sin((double)M_PI*(a+90+i*72)/180);\n\t}\n\tstar->l[0].p1 = star->p[0];star->l[0].p2 = star->p[2];\n\tstar->l[1].p1 = star->p[0];star->l[1].p2 = star->p[3];\n\tstar->l[2].p1 = star->p[1];star->l[2].p2 = star->p[3];\n\tstar->l[3].p1 = star->p[1];star->l[3].p2 = star->p[4];\n\tstar->l[4].p1 = star->p[2];star->l[4].p2 = star->p[4];\n}\n\nint isIntersect(L l1, L l2){\nif (((l1.p1.x - l1.p2.x) * (l2.p1.y - l1.p1.y) + (l1.p1.y - l1.p2.y) * (l1.p1.x - l2.p1.x)) * \n        ((l1.p1.x - l1.p2.x) * (l2.p2.y - l1.p1.y) + (l1.p1.y - l1.p2.y) * (l1.p1.x - l2.p2.x)) < 0){\n        if (((l2.p1.x - l2.p2.x) * (l1.p1.y - l2.p1.y) + (l2.p1.y - l2.p2.y) * (l2.p1.x - l1.p1.x)) * \n            ((l2.p1.x - l2.p2.x) * (l1.p2.y - l2.p1.y) + (l2.p1.y - l2.p2.y) * (l2.p1.x - l1.p2.x)) < 0\t){\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\ndouble lpdistance(L l, P p){\n    double dx = (l.p2.x - l.p1.x), dy = (l.p2.y - l.p1.y);\n    double a = dx * dx + dy *dy, b = dx * (l.p1.x - p.x) + dy * (l.p1.y - p.y);\n    double t = -b / a;\n    if(t < 0) t = 0;\n    if(t > 1) t = 1;\n    double tx = l.p1.x + dx * t, ty = l.p1.y + dy * t;\n    return sqrt((p.x - tx) * (p.x - tx) + (p.y - ty) * (p.y - ty));\n}\n\ndouble lldistance(L l1, L l2){\n\tif(isIntersect(l1, l2)) return 0;\n\tdouble     minl= lpdistance(l1, l2.p1);\n\tminl = min(minl, lpdistance(l1, l2.p2));\n\tminl = min(minl, lpdistance(l2, l1.p1));\n\tminl = min(minl, lpdistance(l2, l1.p2));\n\treturn minl;\n}\n\ndouble ssdistance(STAR s1, STAR s2){\n\tdouble minl = INF;\n\tint i,j;\n\tfor(i=0;i<5;i++)\n\tfor(j=0;j<5;j++){\n\t\tminl = min(minl, lldistance(s1.l[i], s2.l[j]));\n\t}\n\treturn minl;\n}\n\nmain(){\n\tint n,m,l,i,j,k,x,y,a,r;\n\twhile(cin>>n>>m>>l,n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tsetStar(star+i,x,y,a,r);\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tdp[i][i]=0;\n\t\t\tfor(j=i+1;j<=n;j++){\n\t\t\t\tdp[i][j]=dp[j][i]=ssdistance(star[i], star[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t}\n\t\tprintf(\"%.20lf\\n\", dp[m][l]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing  ld = long double;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(15);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_ss(Line(seg[i][ii], seg[i][(ii + 1) % 10]), Line(seg[j][jj], seg[j][(jj + 1) % 10])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const double PI = acos(-1.0);\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nstruct segment\n{\n  P a, b;\n  segment() {}\n  segment(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool intersects(const segment& seg) const\n  {\n    return cross(seg.b - seg.a, a - seg.a) * cross(seg.b - seg.a, b - seg.a) <= EPS\n      && cross(b - a, seg.a - a) * cross(b - a, seg.b - a) <= EPS;\n  }\n\n  inline double distance(const P& p) const\n  {\n    if (dot(b-a, p-a) < EPS) {\n      return abs(p-a);\n    } else if (dot(a-b, p-b) < EPS) {\n      return abs(p-b);\n    } else {\n      return abs(cross(b-a, p-a))/abs(b-a);\n    }\n  }\n\n  inline double distance(const segment& seg) const\n  {\n    if (intersects(seg)) {\n      return 0;\n    } else {\n      return\n        min(\n            min(distance(seg.a), distance(seg.b)),\n            min(seg.distance(a), seg.distance(b)));\n    }\n  }\n};\n\nstruct star\n{\n  segment segs[5];\n  star(double x, double y, double a, double r) {\n    const P o(x, y);\n    P p(0, r);\n    p *= polar(1.0, a/180.0*PI);\n    const P m = polar(1.0, 72.0/180.0*PI);\n    P ps[5];\n    for (int i = 0; i < 5; i++) {\n      ps[i] = o + p;\n      p *= m;\n    }\n    for (int i = 0, j = 0; i < 5; i++) {\n      segs[i] = segment(ps[j], ps[(j+2) % 5]);\n      j = (j+2) % 5;\n    }\n  }\n\n  double distance(const star& s) const\n  {\n    double ans = 1e10;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        ans = min(ans, segs[i].distance(s.segs[j]));\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF && N != 0) {\n    --M; --L;\n    vector<star> stars;\n    for (int i = 0; i < N; i++) {\n      int x, y, a, r;\n      scanf(\"%d %d %d %d\", &x, &y, &a, &r);\n      stars.push_back(star(x, y, a, r));\n    }\n\n    vector<vector<double> > g(N, vector<double>(N));\n    for (int i = 0; i < N; i++) {\n      for (int j = i+1; j < N; j++) {\n        double d = stars[i].distance(stars[j]);\n        g[i][j] = g[j][i] = d;\n      }\n    }\n    priority_queue<pair<double,int> > q;\n    vector<double> dist(N, 1e10);\n    dist[M] = 0;\n    q.push(make_pair(0.0, M));\n    while (!q.empty()) {\n      const double d = -q.top().first;\n      const int n = q.top().second;\n      q.pop();\n      if (n == L) {\n        printf(\"%.7f\\n\", fabs(d));\n        break;\n      }\n      for (int i = 0; i < N; i++) {\n        if (n == i) {\n          continue;\n        }\n        const double dd = d + g[n][i];\n        if (dd < dist[i]) {\n          dist[i] = dd;\n          q.push(make_pair(-dd, i));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(const P &a, const P &b) {\n    return !sgn(abs(a-b));\n}\n\n//R cross(P a, P b) { return imag(conj(a)*b); }\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    b -= a; c -= a;\n    int s = sgn(cross(b, c));\n    if (s) return s;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<cmath>\n#define pb(a) push_back(a)\nconst double EPS = 1e-8;\nusing namespace std;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a,const P& b){\n\t\treturn real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n\t}\n}\ndouble cr(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\t\ndouble dt(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\nstruct L : public vector<P>{\n\tL(const P &a,const P& b){\n\t\tpb(a);pb(b);\n\t}\n};\ntypedef vector<P> G;\n\nstruct C{\n\tP p;double r;\n\tC(const P &p,double r) : p(p),r(r){}\n};\n\nint ccw(P a,P b,P c){\n\tb -= a;\n\tc -= a;\n\tif(cr(b,c) > 0)return 1;\n\tif(cr(b,c)< 0)return -1;\n\tif(dt(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\nP pro(const L &l,const P &p){\n\tdouble t=dt(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\n\nbool itSP(const L &s, const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[0]-s[1]) < EPS;\n}\n\nbool itSS(const L &s, const L &t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ndouble dstSP(const L &s,const P &p){\n\tconst P r = pro(s,p);\n\tif(itSP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble dstSS(const L &s,const L &t){\n\tif(itSS(s,t))return 0;\n\treturn min(min(dstSP(s,t[0]),dstSP(s,t[1])),min(dstSP(t,s[0]),dstSP(t,s[1])));\n}\n#define rep(i,j) for(int i=0;i<j;i++)\nvector<L> hoge(int x,int y,int r,int th_){\n\tdouble th=th_*1.*2*M_PI/360+M_PI/2;\n\tvector<P> ps(5);\n\trep(i,5){\n\t\tdouble a=th+i*2*M_PI/5;\n\t\tps[i].real()=x+cos(a);\n\t\tps[i].imag()=y+sin(a);\n\t}\n\tvector<L> re;\n\trep(i,5){\n\t\tre.pb(L(ps[i],ps[(i+1)%5]));\n\t}\n\treturn re;\n}\nint main(){\n\tint n,m,l;\n\twhile(cin >> n >> m >> l&&n){\n\tvector<vector<L> > st;\n\trep(i,n){\n\t\tint x,y,a,r;\n\t\tcin >> x >> y >> a >> r;\n\t\tst.pb(hoge(x,y,r,a));\n\t}\n\tdouble dst[100][100];\n\tfill_n(dst[0],sizeof(dst)/sizeof(double),INF);\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tdouble d = INF;\n\t\t\tvector<L> t = st[i];\n\t\t\tvector<L> u = st[j];\n\t\t\trep(k,5){\n\t\t\t\trep(kk,5){\n\t\t\t\t\td = min(dstSS(t[k],u[kk]),d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst[i][j]=d;\n\t\t}\n\t}\n\trep(k,n)rep(i,n)rep(j,n){\n\t\tdst[i][j] = min(dst[i][j],dst[i][k]+dst[k][j]);\n\t}\n\tcout <<fixed << setprecision(10)<< dst[m-1][l-1] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<complex>\n#define INF 10000000.0\n#define pb push_back\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> Point;\ntypedef pair<double ,int > P;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real( conj(a) * b );\n}\ndouble cross(Point a, Point b){\n    return imag( conj(a) * b );\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a)<=0 ) return abs(c-a);\n  if ( dot(a-b, c-b)<=0 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\nint is_intersected_ls(Point a1, Point a2, Point b1, Point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) <=0 ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) <=0 );\n}\ndouble distance_ls_ls(Point a1,Point a2,Point a3,Point a4){\n    if(is_intersected_ls(a1,a2,a3,a4))\n        return 0.0;\n    double r1=distance_ls_p(a1,a2,a3),r2=distance_ls_p(a1,a2,a4),r3=distance_ls_p(a3,a4,a1),r4=distance_ls_p(a3,a4,a2);\n    if(r1>r2)\n    r1=r2;\n    if(r3>r4)\n    r3=r4;\n    if(r1>r3)\n    return r3;\n    return r1;\n     \n}\ndouble cal(int a,int b){\n    double ret=INF;\n    for(int i=0;i<5;i++){\n        for(int j=i+1;j<5;j++){\n            for(int k=0;k<5;k++){\n                for(int l=k+1;l<5;l++){\n                    double u=distance_ls_ls(p[a][i],p[a][j],p[b][k],p[b][l]);\n                    if(ret>u)\n                        ret=u;\n                }\n            }\n        }\n    }\n    //cout<<ret<<endl;\n    return ret;\n}\n \n \n \nint main(){\n    while(cin>>n>>s>>g,n||s||g){\n        p.clear();\n        p.resize(n);\n        for(int i=0;i<n;i++){\n            double x,y,a,r;\n            Point pot;\n            cin>>x>>y>>a>>r;\n            Point c=Point(x,y);\n            for(int j=0;j<5;j++){\n                //p[i].pb(c+polar(r,PI*(a+(double)j*72.0+90.0)/180.0));\n            \tp[i].pb(Point(x-sin((a+72*j)*PI/180)*r,y+cos((a+72*j)*PI/180)*r));\n            }\n        }\n        //cout<<\"      \"<<distance_ls_p(p[0][4],p[0][1],p[2][2])<<endl;\n \n         \n        vector<vector<double> > cost(n,vector<double>(n,INF));\n         \n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n            \tif(i==j){\n            \t\tcost[i][j]=0;\n            \t\tcontinue;\n            \t}\n                double a=cal(i,j);\n                cost[i][j]=a;\n                cost[j][i]=a;\n            }\n        }\n    \tfor(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tcost[i][j]=min(cost[i][k]+cost[k][j],cost[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t//cout<<cost[s-1][g-1]<<endl;\n    \tprintf(\"%.8lf\\n\",cost[s-1][g-1]);\n        /*\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cout<<cost[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n         \n        /*priority_queue<P,vector<P>,greater<P> > que;\n        que.push(P(0,s-1));\n        vector<double> d(n,INF);\n        d[s-1]=0;\n        while(!que.empty()){\n            P q=que.top();\n            int pos=q.second;\n            double dist=q.first;\n            que.pop();\n            if(pos==g-1){\n                printf(\"%.8lf\\n\",dist);\n                break;\n            }\n            if(dist>d[pos]){\n                continue;\n            }\n            for(int i=0;i<n;i++){\n                 \n                if(cost[pos][i]==INF){\n                    continue;\n                }\n                if(cost[pos][i]+dist<d[i]){\n                    que.push(P(cost[pos][i]+dist,i));\n                    d[i]=cost[pos][i]+dist;\n                }\n                 \n                 \n            }\n        }*/\n         \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<cassert>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main() {\n\tld n, m, l;\n\twhile (scanf(\"%Le %Le %Le\",&n,&m,&l), n) {\n\t\tvector<vector<Line>>star(n, vector<Line>(5));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tld x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<Point>s(5);\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\ts[j] = Point(x + r * sin(-a/180*pi), y + r * cos(a/180*pi));\n\t\t\t\ta += 144;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tstar[i][j] = Line(s[j], s[j + 1]);\n\t\t\t}\n\t\t\tstar[i][4] = Line(s[4], s[0]);\n\t\t}\n\t\tvector<vector<ld>>cost(n, vector<ld>(n,(ld)0));\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tld ma=(ld)99999999.9999;\n\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\tfor (int li = 0; li < 5; li++) {\n\t\t\t\t\t\tma =min(ma, dist_ss(star[i][k], star[j][li]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcost[i][j] = cost[j][i] = ma;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\tif (cost[j][k] > cost[j][i] + cost[k][i])cost[j][k] = cost[j][i] + cost[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%Le\\n\", cost[m - 1][l - 1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,int> D;\n\nP p[100];\ndouble r[100];\nint a[100],n,s,g;\n\ndouble cal(){\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y>>a[i]>>r[i];\n  priority_queue<D,vector<D>,greater<D> > Q;\n  int used[100]={};\n  Q.push(D(0,s-1));\n  while(!Q.empty()){\n    double cs=Q.top().first;\n    int pos=Q.top().second;\n    Q.pop();\n    if(used[pos]++)continue;\n    if(pos==g-1)return cs;\n    for(int i=0;i<n;i++){\n      if(i==pos)continue;\n      for(int j=0;j<5;j++){\n\tdouble na=M_PI*(a[i]+72*j+90)/180;\n\tP S=P(r[i]*cos(na),r[i]*sin(na));\n\tfor(int k=0;k<5;k++){\n\t  double nb=M_PI*(a[pos]+72*k+90)/180;\n\t  P G=P(r[pos]*cos(nb),r[pos]*sin(nb));\n\t  Q.push(D(cs+abs((S+p[i])-(G+p[pos])),i));\n\t  \n\t}\n      }\n    }\n  } \n}\n\nint main(){\n  while(cin>>n>>s>>g,n)printf(\"%.8lf\\n\",cal());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e8, pi = acos(-1.);\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\ninline double cross(const Point& a, const Point& b){\n    return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n    return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(const Point& a, const Point& b){\n        push_back(a); push_back(b);\n    }\n};\n\ninline Point proj(const Line& l, const Point& p){\n    double t = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);\n    return l[0] + (l[1] - l[0]) * t;\n}\n\ninline bool interSP(const Line& s, const Point& p){\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps;\n}\n\ninline bool interSS(const Line& s, const Line& t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\ninline double distSP(const Line& s, const Point& p){\n    const Point r = proj(s, p);\n    return interSP(s, r)? abs(r - p): min(abs(s[0] - p), abs(s[1] - p));\n}\n\ninline double distSS(const Line& s, const Line& t){\n    return interSS(s, t)? 0: min(min(distSP(s, t[0]), distSP(s, t[1])), min(distSP(t, s[0]), distSP(t, s[1])));\n}\n\nint N, M, L;\n\ndouble solve(vector<vector<Line> >& pent){\n    vector<vector<double> > dist(N, vector<double>(N));\n    rep(i, N)rep(j, i){\n        dist[i][j] = inf;\n        for(auto s: pent[i])for(auto t: pent[j])chmin(dist[i][j], distSS(s, t));\n        dist[j][i] = dist[i][j];\n    }\n    rep(k, N)rep(i, N)rep(j, N)chmin(dist[i][j], dist[i][k] + dist[k][j]);\n    return dist[M][L];\n}\n\nint main(){\n    while(cin >> N >> M >> L, N|M|L){\n        M--; L--;\n        vector<vector<Line> > pent(N);\n        rep(i, N){\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            vector<Point> v;\n            rep(j, 5)v.push_back(Point(x, y) + polar(1. * r, (a + 72 * j + 90) * pi / 180));\n            rep(j, 5)pent[i].emplace_back(v[j], v[(j + 2) % 5]);\n        }\n        cout << fixed << setprecision(20) << solve(pent) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T> bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T> bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n// 実数\nusing Real = double;\n// 点\nusing Point = complex<Real>;\nconst Real EPS = 1e-10, PI = acos(-1);\n\n// 実数同士の比較\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point& p, const Real& d) {\n    return Point(real(p) * d, imag(p) * d);\n}\n\n// 点の入力\nistream& operator>>(istream& is, Point& p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\n//// 点の出力\n//ostream &operator<<(ostream &os, Point &p) {\n//  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n//}\n\n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta, const Point& p) {\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\n// ラジアンを度数に変換\nReal radian_to_degree(Real r) {\n    return (r * 180.0 / PI);\n}\n\n// 度数をラジアンに変換\nReal degree_to_radian(Real d) {\n    return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point& a, const Point& b, const Point& c) {\n    const Point v(b - a), w(c - a);\n    Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n    if (alpha > beta) swap(alpha, beta);\n    Real theta = (beta - alpha);\n    return min(theta, 2 * acos(-1) - theta);\n}\n\n// ソート x座標が小さい順に並べる x座標が同じならy座標が小さい順\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\n// 2点を通る直線\nstruct Line {\n    Point a, b;\n\n    Line() = default;\n\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    Line(Real A, Real B, Real C) // Ax + By = C\n    {\n        if (eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n        else a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream& operator<<(ostream& os, Line& p) {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream& operator>>(istream& is, Line& a) {\n        return is >> a.a >> a.b;\n    }\n};\n\n// 2点を結ぶ線分\nstruct Segment : Line {\n    Segment() = default;\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\n\n// 円\nstruct Circle {\n    // 中心\n    Point p;\n    // 半径\n    Real r;\n\n    Circle() = default;\n\n    Circle(Point p, Real r) : p(p), r(r) {}\n};\n\n// 点集合\nusing Points = vector< Point >;\n// ポリゴン 反時計回り\nusing Polygon = vector< Point >;   // 注意!! 凸多角形は反時計回りに与える.(保証されない場合は面積が負なら reverse をかける)\n// 線分集合\nusing Segments = vector< Segment >;\n// 直線集合\nusing Lines = vector< Line >;\n// 円集合\nusing Circles = vector< Circle >;\n\n// 外積\nReal cross(const Point& a, const Point& b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\n\n// 内積\nReal dot(const Point& a, const Point& b) {\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// 点の回転方向\n//          +1\n//          \n//  +2   a   0   b  -2\n//\n//          -1\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n    if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n    return 0;                         // \"ON_SEGMENT\"\n}\n\n// 線分同士の交差判定\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment& s, const Segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nReal CalcDist(const Segment& s, const Point& p) {\n    double t = dot(s.b - s.a, p - s.a) / norm(s.b - s.a);\n    Point c = s.a + (s.b - s.a) * t;\n    Real res = 1000000.0;\n    if (t > -EPS && t < 1.0 + EPS) return sqrt(norm(p - c));\n    chmin(res, sqrt(norm(p - s.b)));\n    chmin(res, sqrt(norm(p - s.a)));\n    return res;\n}\n\nReal CalcDist(const Segment& a, const Segment& b) {\n    return min({CalcDist(a, b.a), CalcDist(a, b.b), CalcDist(b, a.a), CalcDist(b, a.b)});\n}\n\nint InPolygon(Point& p, const Polygon& pol) {\n    int n = pol.size();\n\n    bool is_in = false;\n    for(int i = 0; i < n; ++i) {\n        Point a = pol[i] - p;\n        Point b = pol[(i + 1) % n] - p;\n\n        //　辺上にあるか\n        if (eq(cross(a, b), 0) && dot(a, b) < EPS) return 1;\n        // 交わっているか\n        if (a.imag() < b.imag()) swap(a, b);\n        if (a.imag() > EPS && b.imag() < EPS && cross(a, b) > EPS) is_in = !is_in;\n    }\n\n    return (is_in) ? 2 : 0;\n}\n\nbool CmpX(const Point& lhs, const Point& rhs) {\n    if (lhs.real() != rhs.real()) return lhs.real() < rhs.real();\n    return lhs.imag() < rhs.imag();\n}\n\nPolygon ConvexHull(vector<Point>& points) {\n    int n = points.size();\n    sort(points.begin(), points.end(), CmpX);\n\n    int k = 0;\n    vector<Point> qs(n * 2);\n\n    // 下側凸包を作成\n    for (int i = 0; i < n; ++i) {\n        // 凸じゃなくなった\n        while (k >= 2 && cross(qs[k - 1] - qs[k - 2], points[i] - qs[k - 2]) < -EPS) --k;\n        qs[k++] = points[i];\n    }\n\n    // 上側凸包を作成\n    for (int i = n - 2, tmp = k; i >= 0; --i) {\n        while (k > tmp && cross(qs[k - 1] - qs[k - 2], points[i] - qs[k - 2]) < -EPS) --k;\n        qs[k++] = points[i];\n    }\n\n    // 作った\n    qs.resize(k - 1);\n    return qs;\n}\n\nReal CalcDist(vector<Segment>& a, vector<Segment>& b) {\n\n    Real ret = 1000000.0;\n\n    // 線分同士の距離\n    for (auto& segA : a) {\n        for (auto& segB : b) {\n            if (intersect(segA, segB)) return 0.0;\n            chmin(ret, CalcDist(segA, segB));\n        }\n    }\n\n    return ret;\n}\n\n\nint main() {\n\n    vector<Real> ans;\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l;\n\n        if (n == 0 && m == 0 && l == 0) break;\n\n        vector<vector<Segment>> stars(n, vector<Segment>(5));\n        for (int i = 0; i < n; ++i) {\n            Real x, y, a, r;\n            cin >> x >> y >> a >> r;\n            vector<Point> points(5);\n            for (int j = 0; j < 5; ++j) {\n                Real angle = acos(-1) * (90 + 72 * j + a) / 180.0;\n                Real px = x + r * cos(angle);\n                Real py = y + r * sin(angle);\n                points[j] = Point(px, py);\n            }\n            // ここから線分を求める\n            stars[i][0] = Segment(points[0], points[2]);\n            stars[i][1] = Segment(points[0], points[3]);\n            stars[i][2] = Segment(points[1], points[4]);\n            stars[i][3] = Segment(points[1], points[3]);\n            stars[i][4] = Segment(points[2], points[4]);\n        }\n\n        // 星mから星lに移動するのに必要な距離\n        // n <= 100\n\n        // 各星同士の距離を求めてダイクストラでよさそう\n\n        vector<vector<Real>> dist(n, vector<Real>(n, 0.0));\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                // それぞれの辺からそれぞれの辺への最短距離\n                Real d = CalcDist(stars[i], stars[j]);\n                dist[i][j] = dist[j][i] = d;\n            }\n        }\n\n        // ワーシャルフロイドでいいか\n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        ans.emplace_back(dist[m - 1][l - 1]);\n    }\n\n    for (auto res : ans) cout << fixed << setprecision(8) << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        m--;\n        l--;\n  \n        star S[100];\n        rep(i,n){\n            scanf(\"%lf%lf%lf%lf\",&S[i].c.x,&S[i].c.y,&S[i].a,&S[i].r);\n        }\n  \n        rep(i,n){\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            rep(j,5) S[i].p[j]=S[i].p[j]+S[i].c;\n        }\n  \n        int f1[]={0,2,4,1,3,0};\n  \n        double d[100][100];\n        rep(i,n){\n            rep(j,n) {\n\t\t\t\td[i][j] = 1e100;\n\t\t\t\trep(a,5) rep(b,5){\n\t\t\t\t\tsegment<double> s(S[i].p[f1[a]],S[i].p[f1[a+1]]);\n\t\t\t\t\tsegment<double> t(S[j].p[f1[b]],S[j].p[f1[b+1]]);\n\t\t\t\t\td[i][j]=min(d[i][j],dist(s,t));\n\t\t\t\t}\n            }\n        }\n  \n        rep(k,n) rep(i,n) rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n  \n        printf(\"%.15f\\n\",d[m][l]);\n    }\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst double INF = 100000;\nconst double EPS = 1e-8;\nint sign(double x){\n  if (x > EPS){\n    return 1;\n  } else if (x < - EPS){\n    return -1;\n  } else {\n    return 0;\n  }\n}\nstruct point{\n  double x, y;\n  point(){\n  }\n  point(double x, double y): x(x), y(y){\n  }\n  point operator +(point P){\n    return point(x + P.x, y + P.y);\n  }\n  point operator -(point P){\n    return point(x - P.x, y - P.y);\n  }\n  point operator *(double k){\n    return point(x * k, y * k);\n  }\n  point operator /(double k){\n    return point(x / k, y / k);\n  }\n};\ndouble abs(point P){\n  return sqrt(pow(P.x, 2) + pow(P.y, 2));\n}\ndouble distance(point P, point Q){\n  return abs(Q - P);\n}\ndouble dot(point P, point Q){\n  return P.x * Q.x + P.y * Q.y;\n}\ndouble cross(point P, point Q){\n  return P.x * Q.y - P.y * Q.x;\n}\nstruct line{\n  point A, B;\n  line(){\n  }\n  line(point A, point B): A(A), B(B){\n  }\n};\npoint vec(line L){\n  return L.B - L.A;\n}\nbool is_parallel(line L1, line L2){\n  return sign(cross(vec(L1), vec(L2))) == 0;\n}\nbool on_segment(point P, line L){\n  return sign(dot(P - L.A, vec(L))) == 1 && sign(dot(P - L.B, vec(L))) == -1;\n}\npoint line_intersection(line L1, line L2){\n  return L1.A + vec(L1) * cross(L2.A - L1.A, vec(L2)) / cross(vec(L1), vec(L2));\n}\nbool segment_intersection(line L1, line L2){\n  point P = line_intersection(L1, L2);\n  return on_segment(P, L1) && on_segment(P, L2);\n}\ndouble point_line_distance(point P, line L){\n  return abs(cross(P - L.A, vec(L))) / abs(vec(L));\n}\ndouble point_segment_distance(point P, line L){\n  if (dot(vec(L), P - L.A) < 0){\n    return distance(P, L.A);\n  } else if (dot(vec(L), P - L.B) > 0){\n    return distance(P, L.B);\n  } else {\n    return point_line_distance(P, L);\n  }\n}\nstruct star{\n  array<line, 5> L;\n  star(){\n  }\n  star(double x, double y, double a, double r){\n    array<point, 6> P;\n    for (int i = 0; i < 6; i++){\n      double theta = a + PI * 4 / 5 * i;\n      P[i] = point(x - r * sin(theta), y + r * cos(theta));\n    }\n    for (int i = 0; i < 5; i++){\n      L[i] = line(P[i], P[i + 1]);\n    }\n  }\n  line operator [](int k){\n    return L[k];\n  }\n};\ndouble star_distance(star S1, star S2){\n  for (int i = 0; i < 5; i++){\n    for (int j = 0; j < 5; j++){\n      if (!is_parallel(S1[i], S2[j])){\n        if (segment_intersection(S1[i], S2[j])){\n          return 0;\n        }\n      }\n    }\n  }\n  double ans = INF;\n  for (int i = 0; i < 5; i++){\n    for (int j = 0; j < 5; j++){\n      ans = min(ans, point_segment_distance(S1[i].A, S2[j]));\n    }\n  }\n  for (int i = 0; i < 5; i++){\n    for (int j = 0; j < 5; j++){\n      ans = min(ans, point_segment_distance(S2[i].A, S1[j]));\n    }\n  }\n  return ans;\n}\nint main(){\n  cout << fixed << setprecision(6);\n  while (1){\n    int N, M, L;\n    cin >> N >> M >> L;\n    if (N == 0 && M == 0 && L == 0){\n      break;\n    }\n    M--;\n    L--;\n    vector<star> S(N);\n    for (int i = 0; i < N; i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      a = a / 180 * PI;\n      S[i] = star(x, y, a, r);\n    }\n    vector<double> d(N, INF);\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n    pq.push(make_pair(0, M));\n    while (!pq.empty()){\n      double c = pq.top().first;\n      int v = pq.top().second;\n      pq.pop();\n      if (d[v] == INF){\n        d[v] = c;\n        for (int i = 0; i < N; i++){\n          if (d[i] == INF){\n            pq.push(make_pair(c + star_distance(S[v], S[i]), i));\n          }\n        }\n      }\n    }\n    cout << d[L] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\nusing P = complex<double>;\n\nconst double eps = 1e-7;\n\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\ndouble cross(P a, P b) {\n  return (conj(a) * b).imag();\n}\n\nint ccw(P a, P b, P c) {\n  if(cross(b-a, c-a) > eps) return 1;\n  if(cross(b-a, c-a) < -eps) return -1;\n  if(dot(b-a, c-a) < -eps) return -2;\n  if(dot(a-b, c-b) < -eps) return 2;\n  return 0;\n}\n\nbool isIntersectedSS(P a1, P a2, P b1, P b2) {\n  int a = ccw(b1, b2, a1);\n  int b = ccw(b1, b2, a2);\n  int c = ccw(a1, a2, b1);\n  int d = ccw(a1, a2, b2);\n\n  return a * b <= 0 && c * d <= 0;\n}\n\ndouble distanceSP(P a, P b, P c) {\n  if(dot(b-a, c-a) < eps) return abs(c-a);\n  if(dot(a-b, c-b) < eps) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersectedSS(a1, a2, b1, b2)) return 0;\n\n  return min({\n\t      distanceSP(a1, a2, b1),\n\t      distanceSP(a1, a2, b2),\n\t      distanceSP(b1, b2, a1),\n\t      distanceSP(b1, b2, a2),\n    });\n}\n\nbool solve() {\n  int N, M, L;\n  int x[101], y[101], a[101], r[101];\n  P points[101][5];\n  \n  cin >> N >> M >> L;\n\n  if (N == 0) return false;\n\n  for(int i=0; i<N; i++) {\n    cin >> x[i] >> y[i] >> a[i] >> r[i];\n    a[i] += 90;\n    \n    for(int j=0; j<5; j++) {\n      double sx = cos((j * 72 + a[i]) / 180.0 * M_PI) * r[i] + x[i];\n      double sy = sin((j * 72 + a[i]) / 180.0 * M_PI) * r[i] + y[i];\n      points[i][j] = P(sx, sy);\n    }\n  }\n\n  double dist[101][101];\n\n  for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n      dist[i][j] = (i != j) * 1e17;\n\n  for(int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n\n      for(int i2=0; i2<5; i2++) {\n        for(int j2=0; j2<5; j2++) {\n          dist[i][j] = dist[j][i] =\n            min(dist[i][j], \n              getDistance(points[i][i2], points[i][(i2+2)%5],\n              points[j][j2], points[j][(j2+2)%5])\n            );\n        }\n      }      \n    }\n  }\n\n  REP(k,N)REP(i,N)REP(j,N)dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\n  printf(\"%.10lf\\n\", dist[M-1][L-1]);\n\n\n  return true;\n}\n\nint main(){\n  while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ndouble Signum(double x)\n{\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\ntypedef complex<double> Point;\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\ntypedef Line Segment;\n\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\n\treturn 0;\n}\n\nPoint Proj(Line l,Point p)\n{\n\tPoint a=p-l.pos,b=l.dir;\n\treturn Dot(a,b)/norm(b)*b+l.pos;\n}\n\nbool InterLS(Line l,Segment s)\n{\n\tPoint a=l.pos,b=l.pos+l.dir;\n\tPoint c=s.pos,d=s.pos+s.dir;\n\treturn CCW(a,b,c)*CCW(a,b,d)<0;\n}\nbool InterSS(Segment a,Segment b)\n{\n\treturn InterLS(a,b) && InterLS(b,a);\n}\n\ndouble DistLP(Line l,Point p)\n{\n\treturn abs(Proj(l,p)-p);\n}\ndouble DistSP(Segment s,Point p)\n{\n\tint ccw=CCW(s.pos,s.pos+s.dir,Proj(s,p));\n\tif(ccw==-2)\n\t\treturn abs(p-s.pos);\n\tif(ccw==2)\n\t\treturn abs(p-(s.pos+s.dir));\n\treturn DistLP(s,p);\n}\n\ndouble DistSS(Segment a,Segment b)\n{\n\tif(InterSS(a,b)) return 0;\n\tdouble d1=min(DistSP(a,b.pos),DistSP(a,b.pos+b.dir));\n\tdouble d2=min(DistSP(b,a.pos),DistSP(b,a.pos+a.dir));\n\treturn min(d1,d2);\n}\n\nint main()\n{\n\tfor(int n,src,dst;cin>>n>>src>>dst,n|src|dst;){\n\t\tvi xs(n),ys(n),as(n),rs(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i]>>as[i]>>rs[i];\n\t\t\n\t\tvvd d(n,vd(n,INFTY));\n\t\trep(i,n) rep(j,n){\n\t\t\tdouble x1[6],y1[6],x2[6],y2[6];\n\t\t\trep(k,6){\n\t\t\t\tx1[k]=xs[i]+rs[i]*cos((90+as[i]+k*144)*PI/180);\n\t\t\t\ty1[k]=ys[i]+rs[i]*sin((90+as[i]+k*144)*PI/180);\n\t\t\t\tx2[k]=xs[j]+rs[j]*cos((90+as[j]+k*144)*PI/180);\n\t\t\t\ty2[k]=ys[j]+rs[j]*sin((90+as[j]+k*144)*PI/180);\n\t\t\t}\n\t\t\trep(k,5) rep(l,5){\n\t\t\t\tLine s1(Point(x1[k],y1[k]),Point(x1[k+1]-x1[k],y1[k+1]-y1[k]));\n\t\t\t\tLine s2(Point(x2[l],y2[l]),Point(x2[l+1]-x2[l],y2[l+1]-y2[l]));\n\t\t\t\td[i][j]=min(d[i][j],DistSS(s1,s2));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\n\t\tprintf(\"%.10f\\n\",d[src-1][dst-1]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void readL() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\n\n\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(L &ab,L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL( L &l,  L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS( L &l,  L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP( L &l,  P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS( L &s,  L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L &s,  P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection( L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection( L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP( L &l,  P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL( L &l,  L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS( L &l,  L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP( L &s,  P &p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS( L &s,  L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP( P &p, P &q){\n  return abs(p - q) ;\n}\nP crosspoint(L &l,L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP crosspointSS(L &l1,L &l2) {\n  double d1 = abs(cross(l2.v, l1[0] - l2[0])); // l1.a - l2.b???\n  double d2 = abs(cross(l2.v, l1[1] - l2[0]));\n  double t = d1 / (d1 + d2);\n  return l1[0] + t * l1.v;\n}\nP verticalvector( P &a, P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\nconst double PI = acos(-1);\ndouble d2r(int d){\n  return (1.0 * d/180)*PI;\n}\n\nclass star{\n  public:\n    P p[5],c;\n    L l[5];\n    star(){};\n    star(double x,double y,int a,double r){\n      int d = a + 90;\n      c = P(x,y);\n      rep(i,5){\n        p[i] = c + polar(r,d2r(d));\n        d += 72;\n      }\n      rep(i,5){\n        l[i] = L(p[i],p[(i+2)%5]);\n      }\n    }\n    P& operator[](int i){\n      return p[i];\n    }\n    bool operator<(const star &s) const {\n      return c < s.c;\n    }\n    void show(){\n      rep(i,5){\n        cout << p[i] << endl;\n      }\n    }\n};\ndouble distanceStar(star &s, star &t){\n  double res = INF;\n  rep(i,5){\n    rep(j,5){\n      if(same(s[i],t[j]) || intersectSS(s.l[i],t.l[j])){\n        return 0;\n      }\n      else\n        res = min(res,distancePP(s[i],t[j]));\n    }\n  }\n  return res;\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n,m,l;\n  while(cin >> n >> m >> l,n+m+l){\n    --l,--m;\n    vector<pair<star,int>> vs(n);\n    double x,y,b,r;\n    rep(i,n){\n      cin >> x >> y >> b >> r;\n      vs[i] = mp(star(x,y,b,r),i);\n    }\n    sort(all(vs));\n    int v = 0,a = 0;\n    rep(i,n){\n      /* vs[i].fi.show(); */\n      if(vs[i].se == m){\n        v = i;\n      }\n      if(vs[i].se == l){\n        a = i;\n      }\n    }\n    double ans = 0;\n    if(v > a){\n      swap(v,a);\n    }\n    REP(i,v,a){\n      ans += distanceStar(vs[i].fi,vs[i+1].fi);\n    }\n    fcout(10) << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Based on Spaghetti source (http://www.prefield.com/algorithm/geometry/ccw.html.)\n//Based on the library written by tailed.\n\n#include <complex>\n#include <vector>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 4);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nbool intersectSP(const line_t &s, const xy_t &p) {\n  return abs(s.first - p) + abs(s.second - p) - abs(direction(s)) < EPS;\n}\n\nbool intersectSS(const line_t &s, const line_t &t) {\n  return ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n         ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\nxy_t projection(const line_t &l, const xy_t &p) {\n  double t = dot(p - l.first, direction(l) / norm(direction(l)));\n  return l.first + t*(direction(l));\n}\n\ndouble distanceSP(const line_t &s, const xy_t &p) {\n  const xy_t r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.first - p), abs(s.second - p));\n}\n\ndouble distanceSS(const line_t &s, const line_t &t) {\n  if (intersectSS(s, t)) return 0;\n  \n  return min(min(distanceSP(s, t.second), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first ), distanceSP(t, s.second)));\n}\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n    \n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdio>\n#include<iomanip>\n#define EPS 1.0e-12\n#define INF 1.0e+12\n#define INFI 1000000\nusing namespace std;\n//2次元座標\nclass point{\npublic:\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y){\n\t\tthis->x=x;\n\t\tthis->y=y;\n\t}\n\tdouble len(point &p){\n\t\treturn sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));\n\t}\n\tpoint operator*(double d){\n\t\tpoint p(x*d,y*d);\n\t\treturn p;\n\t}\n\tpoint operator+(point &o){\n\t\tpoint p(x+o.x,y+o.y);\n\t\treturn p;\n\t}\n\tpoint operator-(point &o){\n\t\tpoint p(x-o.x,y-o.y);\n\t\treturn p;\n\t}\n\tbool operator==(point &o){\n\t\treturn (x==o.x && y==o.y);\n\t}\n\tbool operator!=(point &o){\n\t\treturn !(x==o.x && y==o.y);\n\t}\n};\n//内積\ndouble dot(point p,point q){\n\treturn (p.x*q.x+p.y*q.y);\n}\n//外積\ndouble cross(point p,point q){\n\treturn (p.x*q.y-p.y*q.x);\n}\n//線分と点\ndouble SegmentPoint(point p,point q,point r){\n\tif(dot(q-p,r-p)<EPS) return abs(r.len(p));\n\tif(dot(p-q,r-q)<EPS) return abs(r.len(q));\n\treturn abs(cross(q-p,r-p))/abs(q.len(p));\n}\n//同一直線上じゃないか、重なっている部分が存在する\nbool han(point p0,point p1,point q0,point q1){\n\tif(cross(p0-p1,q0-p0)==0.0 && cross(p0-p1,q1-p0)){//同一直線\n\t\tif(abs(p0.len(q0))+abs(q0.len(p1))<abs(p0.len(p1))+EPS ||\n\t\t\tabs(p0.len(q1))+abs(q1.len(p1))<abs(p0.len(p1))+EPS){\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n//線分線分\nbool SegSeg(point p0,point p1,point q0,point q1){\n\tint a=cross(p1-p0,q0-p0);\n\tint b=cross(p1-p0,q1-p0);\n\tint c=cross(q1-q0,p0-q0);\n\tint d=cross(q1-q0,p1-q0);\n\treturn (a*b<EPS)&&(c*d<EPS)&&(han(p0,p1,q0,q1));\n}\n//アウグストゥスみたいななにか\nclass route{\nprivate:\n\tdouble **cost;\n\tdouble *dist;\n\tbool *used;\n\tint v;\npublic:\n\troute(){}\n\troute(int v){\n\t\tthis->v=v;\n\t\tcost=new double*[v];\n\t\tfor(int i=0;i<v;i++) cost[i]=new double[v];\n\t\tdist=new double[v];\n\t\tused=new bool[v];\n\t}\n\tvoid format(double c){\n\t\tfor(int i=0;i<v;i++) for(int j=0;j<v;j++) cost[i][j]=c;\n\t}\n\tvoid set(int n,int m,double c){\n\t\tcost[n][m]=c;\n\t\tcost[m][n]=c;\n\t}\n\tvoid set(int s){\n\t\tfor(int i=0;i<this->v;i++){\n\t\t\tdist[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tdist[s]=0;\n\t\twhile(true){\n\t\t\tint p=-1;\n\t\t\tfor(int i=0;i<this->v;i++){\n\t\t\t\tif(!used[i] && (p==-1 || dist[i]<dist[p])) p=i;\n\t\t\t}\n\t\t\tif(p==-1) break;\n\t\t\tused[p]=true;\n\t\t\tfor(int i=0;i<v;i++){\n\t\t\t\tdist[i]=min(dist[i],dist[p]+cost[p][i]);\n\t\t\t}\n\t\t}\n\t}\n\tdouble RetCost(int e){\n\t\treturn dist[e];\n\t}\n\tdouble ret(int i,int j){\n\t\treturn cost[i][j];\n\t}\n};\n\nstruct st_star{\n\tpoint p[6];\n};\n\nst_star *star;\nroute *r;\n\nint main(){\n\tint i,j,k,l;\n\tint n,m,q;\n\tint x,y,a,t;\n\tcout<<setprecision(20)<<setiosflags(ios::fixed);\n\twhile(cin>>n>>m>>q){\n\t\tif(n==0 && m==0 && q==0) break;\n\t\tr=new route(n);\n\t\tstar=new st_star[n];\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>x>>y>>a>>t;\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tstar[i].p[j].x=x+t*cos(((a+90+216*j)%360)*M_PI/180);\n\t\t\t\tstar[i].p[j].y=y+t*sin(((a+90+216*j)%360)*M_PI/180);\n\t\t\t}\n\t\t\tstar[i].p[5]=star[i].p[0];\n\t\t}\n\t\t//交わりor最短\n\t\tfor(i=0;i<n;i++){\n\t\t\tr->set(i,i,0);\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[0],star[j].p[1])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[1],star[j].p[2])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[2],star[j].p[3])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[3],star[j].p[4])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[4],star[j].p[5])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k==5){\n\t\t\t\t\tdouble p=INF;\n\t\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\t\tfor(l=0;l<5;l++){\n\t\t\t\t\t\t\tp=min(p,SegmentPoint(star[i].p[k],star[i].p[k+1],star[j].p[l]));\n\t\t\t\t\t\t\tp=min(p,SegmentPoint(star[j].p[k],star[j].p[k+1],star[i].p[l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr->set(i,j,p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr->set(m-1);\n\t\tcout<<(double)r->RetCost(q-1)<<endl;\n\t\tdelete r;\n\t\tdelete []star;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define INF 1e8\n#define EPS 1e-10\nusing namespace std;\n\nstruct edge{\n\tdouble cost;\n\tint t;\n\tedge(){}\n\tedge(int tt,double cc){\n\t\tt=tt;\n\t\tcost=cc;\n\t}\n};\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble cross(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).cross(p2-q)==0.0 && (p1-q).dot(p2-q)<=0;\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).cross(q1-p1)/(q2-q1).cross(p2-p1));\n}\n\nint n,S,T;\nint x[101],y[101],a[101],r[101];\nvector<edge> G[101];\n\ndouble dist(P a,P b){\n\treturn sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\ndouble check(P p1,P p2,P q1,P q2){\n\tif((p1-q1).dot(p2-q2)==0.0){\n\t\tif(on_seg(p1,p2,q1) || on_seg(p1,p2,q2) || on_seg(q1,q2,p1) || on_seg(q1,q2,p2))return 0.0;\n\t}else{\n\t\tP r=intersection(p1,p2,q1,q2);\n\t\tif(on_seg(p1,p2,r) && on_seg(q1,q2,r))return 0.0;\n\t}\n\tdouble res=INF;\n\tdouble d=(q1-p1).dot(p2-p1)/dist(p1,p2);\n\tif((q1-p1).dot(p2-p1)<=0.0){\n\t\tres=min(res,dist(p1,q1));\n\t}else if((q1-p1).dot(p2-p1)<(p2-p1).dot(p2-p1)){\n\t\tres=min(res,sqrt(pow(dist(p1,q1),2)-d*d));\n\t}else res=min(res,dist(p2,q1));\n\n\td=(q2-p1).dot(p2-p1)/dist(p1,p2);\n\tif((q2-p1).dot(p2-p1)<=0.0){\n\t\tres=min(res,dist(p1,q2));\n\t}else if((q2-p1).dot(p2-p1)<(p2-p1).dot(p2-p1)){\n\t\tres=min(res,sqrt(pow(dist(p1,q2),2)-d*d));\n\t}else res=min(res,dist(p2,q2));\n\n\tswap(p1,q1);\n\tswap(p2,q2);\n\n\td=(q1-p1).dot(p2-p1)/dist(p1,p2);\n\tif((q1-p1).dot(p2-p1)<=0.0){\n\t\tres=min(res,dist(p1,q1));\n\t}else if((q1-p1).dot(p2-p1)<(p2-p1).dot(p2-p1)){\n\t\tres=min(res,sqrt(pow(dist(p1,q1),2)-d*d));\n\t}else res=min(res,dist(p2,q1));\n\n\td=(q2-p1).dot(p2-p1)/dist(p1,p2);\n\tif((q2-p1).dot(p2-p1)<=0.0){\n\t\tres=min(res,dist(p1,q2));\n\t}else if((q2-p1).dot(p2-p1)<(p2-p1).dot(p2-p1)){\n\t\tres=min(res,sqrt(pow(dist(p1,q2),2)-d*d));\n\t}else res=min(res,dist(p2,q2));\n\treturn res;\n}\n\nstruct data{\n\tint v;\n\tdouble cost;\n\tdata(){}\n\tdata(int vv,double cc){\n\t\tv=vv;\n\t\tcost=cc;\n\t}\n\tbool operator <(const data& d1)const{\n\t\treturn cost>d1.cost;\n\t}\n};\n\ndouble dp[101];\n\ndouble dijk(){\n\tpriority_queue<data> que;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=INF;\n\t}\n\tque.push(data(S,0));\n\tdp[S]=0.0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v]<q.cost)continue;\n\t\tif(q.v==T)return q.cost;\n\t\tfor(int i=0;i<G[q.v].size();i++){\n\t\t\tedge e=G[q.v][i];\n\t\t\tif(e.cost+dp[q.v]<dp[e.t]){\n\t\t\t\tdp[e.t]=dp[q.v]+e.cost;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&S,&T);\n\t\tif(n+S+T==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tS--;\n\t\tT--;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&a[i],&r[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tP p1=P(x[i],y[i])+P((double)r[i]*cos((double)(a[i]+72.0*j+90.0)/180.0*M_PI),(double)r[i]*sin((double)(a[i]+72.0*j+90.0)/180.0*M_PI));\n\t\t\t\tP p2=P(x[i],y[i])+P((double)r[i]*cos((double)(a[i]+72.0*j+234.0)/180.0*M_PI),(double)r[i]*sin((double)(a[i]+72.0*j+234.0)/180.0*M_PI));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble co=INF;\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\t\tP p1=P(x[i],y[i])+P((double)r[i]*cos((double)(a[i]+72.0*k+90.0)/180.0*M_PI),(double)r[i]*sin((double)(a[i]+72.0*k+90.0)/180.0*M_PI));\n\t\t\t\t\t\tP p2=P(x[i],y[i])+P((double)r[i]*cos((double)(a[i]+72.0*k+234.0)/180.0*M_PI),(double)r[i]*sin((double)(a[i]+72.0*k+234.0)/180.0*M_PI));\n\t\t\t\t\t\tP q1=P(x[j],y[j])+P((double)r[j]*cos((double)(a[j]+72.0*l+90.0)/180.0*M_PI),(double)r[j]*sin((double)(a[j]+72.0*l+90.0)/180.0*M_PI));\n\t\t\t\t\t\tP q2=P(x[j],y[j])+P((double)r[j]*cos((double)(a[j]+72.0*l+234.0)/180.0*M_PI),(double)r[j]*sin((double)(a[j]+72.0*l+234.0)/180.0*M_PI));\n\t\t\t\t\t\tco=min(co,check(p1,p2,q1,q2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i].push_back(edge(j,co));\n\t\t\t\tG[j].push_back(edge(i,co));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  int n,m,l;cin >> n>>m>>l;\n  if(n==0) break;\n  Polygon stars[n];\n  //int r[n];\n  for(int i=0;i<n;i++){\n    int x,y,a,r;cin>>x>>y>>a>>r;\n    for(int j=0;j<5;j++){\n      Point v=Point(x,y)+Point(r*cos((18+a+72*j)*(2*PI)/360),r*sin((18+a+72*j)*(2*PI)/360));\n      stars[i].push_back(v);\n    }\n  }\n  ld dis[n][n];\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n    if(i==j) dis[i][j]=0.0;\n    else dis[i][j]=INF;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ld tmp=INF;\n      for(int k=0;k<5;k++){\n        for(int l=0;l<5;l++){\n          Line x=Line(stars[i][k],stars[i][(k+2)%5]);\n          Line y=Line(stars[j][k],stars[j][(l+2)%5]);\n          tmp=min(tmp,dist_ss(x,y));\n        }\n      }\n      dis[i][j]=tmp;dis[j][i]=tmp;\n    }\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);\n      }\n    }\n  }\n  cout << setprecision(10)<<dis[m-1][l-1] << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef pair<double,double> pdd;\n\nconst double pi = atan(1.0) * 4.0;\nconst double EPS = 1e-8;\n\ndouble cross(pdd x, pdd y) {\n\treturn x.first*y.second - x.second*y.first;\n}\n\ndouble dist(pdd x, pdd y) {\n\treturn sqrt((x.first-y.first)*(x.first-y.first) + (x.second-y.second)*(x.second-y.second));\n}\n\nint main() {\n\tint N, M, L;\n\twhile(scanf(\"%d %d %d\", &N, &M, &L), N) {\n\t\tvector< vector<pdd> > star(N);\n\t\trep(i, N) {\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r);\n\t\t\trep(j, 5) {\n\t\t\t\tdouble ang = (72.0 * j + a) * pi / 180.0;\n\t\t\t\tpdd p(x-r*sin(ang), y+r*cos(ang));\n\t\t\t\tstar[i].push_back(p);\n\t\t\t}\n\t\t}\n\t\tdouble cost[100][100];\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = 1e9;\n\t\t\t\tif(i==j) cost[i][j] = 0.0;\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd v1 = pdd(star[i][ii].first - star[i][(ii+1)%5].first, star[i][ii].second - star[i][(ii+1)%5].second);\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tpdd v2 = pdd(star[j][jj].first - star[j][(jj+1)%5].first, star[j][jj].second - star[j][(jj+1)%5].second);\n\t\t\t\t\t\tpdd u1 = pdd(star[i][ii].first - star[j][(jj+1)%5].first, star[i][ii].second - star[j][(jj+1)%5].second);\n\t\t\t\t\t\tpdd u2 = pdd(star[j][jj].first - star[i][(ii+1)%5].first, star[j][jj].second - star[i][(ii+1)%5].second);\n\t\t\t\t\t\tpdd w1 = pdd(star[i][ii].first - star[j][jj].first, star[i][ii].second - star[j][jj].second);\n\t\t\t\t\t\tpdd w2 = pdd(-w1.first, -w1.second);\n\t\t\t\t\t\tif( cross(v1,u1)*cross(v1,w1)<-EPS && cross(v2,u2)*cross(v2,w2)<-EPS ) {\n\t\t\t\t\t\t\tcost[i][j] = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd s = star[i][ii];\n\t\t\t\t\tpdd t = star[i][(ii+1)%5];\n\t\t\t\t\tdouble alp = 0.0f;\n\t\t\t\t\tif( abs(t.first-s.first) < EPS ) {\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], abs(t.first - star[j][jj].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\talp = (t.second-s.second)/(t.first-s.first);\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tpdd p = star[j][jj];\n\t\t\t\t\t\t\tdouble qx = (p.first+alp*p.second-alp*s.second+alp*alp*s.first) / (alp*alp+1.0);\n\t\t\t\t\t\t\tdouble qy = alp*(qx-s.first) + s.second;\n\t\t\t\t\t\t\tpdd q = pdd(qx,qy);\n\t\t\t\t\t\t\tif( dist(q,s)<dist(t,s) && dist(q,t)<dist(t,s) ) {\n\t\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(p,q));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(star[i][ii], star[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = cost[j][i] = min(cost[i][j], cost[j][i]);\n\t\t\t}\n\t\t}\n\t\trep(k, N) {\n\t\t\trep(i, N) {\n\t\t\t\trep(j, N) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", min(cost[M-1][L-1],cost[L-1][M-1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<complex>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nint ccw(const P a, P b, P x) {\n  b -= a;\n  x -= a;\n  double cr = cross(b, x);\n  if (eq(cr, 0)) {\n    if (dot(b, x) < 0) return BACK;\n    if (abs(b) < abs(x)) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\nP vec(L a) {return a.second - a.first;}\nbool iSS(L a, L b) {\n  int cwaf = ccw(a.first, a.second, b.first);\n  int cwbf = ccw(b.first, b.second, a.first);\n  int cwas = ccw(a.first, a.second, b.second);\n  int cwbs = ccw(b.first, b.second, a.second);\n  if (cwaf == ON || cwas == ON || cwbf == ON || cwbs == ON ) return true;\n  return (cwaf | cwas) == (LEFT | RIGHT) && (cwbf | cwbs) == (LEFT | RIGHT);\n}\ndouble dLP(L l, P x) {return abs(cross(vec(l), x - l.first)) / abs(vec(l));}\ndouble dSP(L s, P x) {\n  if (dot(vec(s), x - s.first) <= 0) return abs(x - s.first);\n  if (dot(-vec(s), x - s.second) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\ndouble dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\n\ndouble x[111], y[111], a[111], r[111];\nL star[111][5];\ndouble dis[111][111];\ndouble mem[111];\n\nvoid f(int s, int t) {\n  double res = 1e40;\n  rep (i, 5) rep (j, 5) {\n    res = min(dSS(star[s][i], star[t][j]), res);\n  }\n  dis[s][t] = res;\n}\n\nint main() {\n  int n, m, l;\n  for (;;) {\n    cin >> n >> m >> l;\n    if (n == 0 && m == 0 && l == 0) break;\n    --m; --l;\n    rep (i, n) cin >> x[i] >> y[i] >> a[i] >> r[i];\n    rep (i, n) a[i] = a[i] / 360 * 2 * PI;\n    rep (i, n) rep (j, 5) {\n      double theta = a[i] + j * 2 * PI / 5 + PI / 2;\n      P p1 = P(x[i] + r[i] * cos(theta), y[i] + r[i] * sin(theta));\n      theta = a[i] + (j + 2) * 2 * PI / 5 + PI / 2;\n      P p2 = P(x[i] + r[i] * cos(theta), y[i] + r[i] * sin(theta));\n      star[i][j] = L(p1, p2);\n    }\n    rep (i, n) rep (j, n) if (i < j) f(i, j);\n    rep (i, n) rep (j, n) if (i > j) dis[i][j] = dis[j][i];\n    rep (i, n) mem[i] = INF;\n    priority_queue<pair<double, int> > que;\n    que.push(make_pair(0, m));\n    while (!que.empty()) {\n      pair<double, int> now = que.top();\n      que.pop();\n      if (mem[now.second] <= now.first) continue;\n      mem[now.second] = now.first;\n      rep (i, n) if (i != now.second) {\n\tque.push(make_pair(now.first + dis[now.second][i], i));\n      }\n    }\n    printf(\"%.12lf\\n\", mem[l]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n#define eps 1.0e-10\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tdouble add(double a, double b){\n\t\tif(abs(a+b) < eps * (abs(a) + abs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, ope.x);\n\t\ttmp.y = add(y, ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, -ope.x);\n\t\ttmp.y = add(y, -ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn add(x*ope.y,  -y*ope.x);\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= 0;\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) < 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) < 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+1)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.12f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\ndouble abs(Point p){return sqrt(norm(p));}\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return 1;\n  if(cross(a,b)<-EPS)return -1;\n  if(dot(a,b)<-EPS)return 2;\n  if(norm(a)<norm(b))return -2;\n  return 0;\n}\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\nint main(){\n  double a,b,c,d;\n  int n,ve,al;\n  while(cin>>n>>ve>>al,n){\n    Point p[n][5];\n    seg D[n][5];\n    r(i,n){\n      scanf(\"%lf%lf%lf%lf\",&a,&b,&c,&d);\n      r(j,5){\n        p[i][j].x=a-d*sin(M_PI/180*(72*j+c));\n        p[i][j].y=b+d*cos(M_PI/180*(72*j+c));\n      }\n      D[i][0].p1=p[i][0];D[i][0].p2=p[i][2];\n      D[i][1].p1=p[i][1];D[i][1].p2=p[i][3];\n      D[i][2].p1=p[i][2];D[i][2].p2=p[i][4];\n      D[i][3].p1=p[i][3];D[i][3].p2=p[i][0];\n      D[i][4].p1=p[i][4];D[i][4].p2=p[i][1];\n    }\n    double w[n][n];\n    r(i,n)r(j,n)w[i][j]=i==j?0:1000000000;\n    r(i,n)R(j,i+1,n){\n      double t=1000000000;\n      r(k,5)r(l,5)t=min(t,getDistance(D[i][k],D[j][l]));\n      w[i][j]=w[j][i]=t;\n    }\n    r(k,n)r(i,n)r(j,n)w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    printf(\"%.11f\\n\",w[ve-1][al-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n\n#define X() real()\n#define Y() imag()\n#define x(p) (p).X()\n#define y(p) (p).Y()\n#define SZ(R) (int)(R).size()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%SZ(P)]\n#define prev(P, i) P[(i-1+SZ(P)%SZ(P)]\n\nusing D = double;\nusing P = complex<D>;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return x(a) != x(b) ? x(a) < x(b) : y(a) < y(b);\n  }\n}\nD dot(const P& a, const P& b) {\n  return x(conj(a)*b);\n}\nD cross(const P& a, const P& b) {\n  return y(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nstruct L : public vector<P> {\n  L(){}\n  L(const P& a, const P& b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\nusing G = vector<P>;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nP makeP(D arg, D r = 1.0) {\n  return r * P{cos(arg), sin(arg)};\n}\nP rotP(const P& p, D arg) {\n  return p * makeP(arg);\n}\nD getArgP(const P& p) {\n  return atan2(y(p), x(p));\n}\nD toRad(D deg) {\n  return PI * deg / 180.0;\n}\n\nG makeStar(const P& p, D arg, D r) {\n  G ret;\n  P v{0.0, r};\n  rep(i, 5) {\n    ret.push_back(p + rotP(v, 2*PI/5*i+arg));\n  }\n  return ret;\n}\n\nbool interSP(const L& s, const P& p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[0]-s[1]) < EPS;\n}\nbool interSS(const L& s, const L& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nP proj(const L& l, const P& p) {\n  P v = l[0]-l[1];\n  D t = dot(p - l[0], v) / norm(v);\n  return l[0] + t*(v);\n}\nD distSP(const L& s, const P& p) {\n  P r = proj(s, p);\n  if(interSP(s, r)) return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\nD distSS(const L& s, const L& t) {\n  if(interSS(s, t)) return 0.0;\n  return min({distSP(s, t[0]), distSP(s, t[1]), distSP(t, s[0]), distSP(t, s[1])});\n}\n\nint main() {\n  cout << fixed << setprecision(20);\n  int n, a, b;\n  while(cin >> n >> a >> b) {\n    if(n == 0 && a == 0 && b  == 0) break;\n    a--;\n    b--;\n    vector<G> gs;\n    rep(i, n) {\n      D x, y, a, r;\n      cin >> x >> y >> a >> r;\n      gs.push_back(makeStar(P{x, y}, toRad(a), r));\n    }\n    const D INF = 1e18;\n    vector<vector<D>> d(n, vector<D>(n, INF));\n    rep(i, n) d[i][i] = 0.0;\n    using Ls = vector<L>;\n    vector<Ls> v(n);\n    rep(i, n) {\n      rep(j, 5) {\n\tv[i].push_back(L{curr(gs[i], j), next(gs[i], j+1)});\n      }\n    }\n    rep(i, n) rep(j, i) {\n      double dist = INF;\n      rep(k, 5) rep(l, 5) {\n\tdist = min(dist, distSS(v[i][k], v[j][l]));\n      }\n      d[i][j] = d[j][i] = min(d[i][j], dist);\n    }\n\n    rep(k, n) rep(i, n) rep(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    cout << d[a][b] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> \n#include <bitset> \n#include <cctype> \n#include <complex> \n#include <cmath> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <ctime> \n#include <deque> \n#include <functional> \n#include <iomanip> \n#include <iostream> \n#include <list> \n#include <map> \n#include <numeric> \n#include <queue> \n#include <set> \n#include <sstream> \n#include <stack> \n#include <string> \n#include <utility> \n#include <vector> \n  \nusing namespace std; \n  \ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;} \ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();} \ntemplate<class T> inline T sqr(T x) {return x*x;} \n  \ntypedef vector<int> vi; \ntypedef vector<vi> vvi; \ntypedef vector<string> vs; \ntypedef pair<int, int> pii; \ntypedef long long ll; \n  \n#define all(a)  (a).begin(),(a).end() \n#define rall(a) (a).rbegin(), (a).rend() \n#define pb push_back \n#define mp make_pair \n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i) \n#define exist(s,e) ((s).find(e)!=(s).end()) \n#define range(i,a,b) for(int i=(a);i<(b);++i) \n#define rep(i,n)  range(i,0,n) \n#define clr(a,b) memset((a), (b) ,sizeof(a)) \n#define dump(x)  cerr << #x << \" = \" << (x) << endl; \n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl; \n  \n  \nconst double eps = 1e-10; \nconst double pi  = acos(-1.0); \nconst ll INF =1LL << 62; \nconst int inf =1 << 30; \n  \n  \n// テ、ツサツ・テ、ツクツ?テ・ツケツセテ、ツスツ陛ゥツδィテ・ツ按?\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;} \ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;} \n#define x real() \n#define y imag() \n#define mp make_pair \n  \ntypedef bool B; \ntypedef long double D; \ntypedef complex<D> P; \ntypedef pair <P,P> L; \ntypedef struct {P c;D r;} C; \ntypedef struct {P c;D a,b;} E; // テヲツ・ツ陛・ツ??」ツつづィツソツステ・ツ環?、ツコツ暗・ツョツ?\ntypedef vector <P>Pol; \n  \n// テ」ツつステ」ツδシテ」ツδ暗」ツ?ョテ」ツつュテ」ツδシ \nB cmp_x(const P &a,const P &b){ return (abs(a.x-b.x)<eps ) ?  a.y<b.y : a.x<b.x;}  // base x \nB cmp_y(const P &a,const P &b){ return (abs(a.y-b.y)<eps ) ?  a.x<b.x : a.y<b.y;}  // base y \nB cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg \n  \n  \n// テ・ツ淞コテヲツ慊ャテヲツ督催、ツスツ?\n// verify \nD ip(P a, P b) {return a.x * b.x + a.y * b.y;} \nD ep(P a, P b) {return a.x * b.y - a.y * b.x;} \nD sr(D a) {return sqrt(max(a, (D)0));} \nP vec(L l){return l.second-l.first;} \n  \n  \n// テァツつケ \nD ang (P p){return arg(p);} \nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base テ、ツクツュテ・ツソツ?\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );} \n  \n  \n// ccw  \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID }; \n  \nint ccw(P base, P a, P b) {              //テァツつケaテ」ツ?ィテァツつケbテ」ツ?古、ツクツ偲」ツ?暗」ツつ嘉」ツつ古」ツ?淌・ツ閉湘」ツ??」ツ?ォ \n  a -= base; b -= base; \n  if (ep(a, b) > 0)       return LEFT;    // counter clockwise \n  if (ep(a, b) < 0)      return RIGHT;   // clockwise \n  if (ip(a, b) < 0)      return BACK;    // b--base--a on line \n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line \n                         return MID;      // base--b--a on line  aテ」ツ?ィbテ」ツ?ョテァツキツ堙・ツ按?・ツ按、テ・ツョツ堙」ツ?ッテ」ツ?禿」ツつ?\n} \n  \n  \n  \nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;} \nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;} \n  \n  \n// テ、ツコツ、テァツつケ \nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));} \n  \n  \n// テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ィテァツキツ堙・ツ按?ゥツ鳴「テゥツ?」テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\n  \nB iLL(L l1,L l2){ return !ipar(l1,l2);} \nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;} \nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;} \nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;} \nB iSS(L a, L b) { \n    int cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second); \n    int cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second); \n    return ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT)); \n} \nB iSSs(L a, L b) { \n    int cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second); \n    int cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second); \n    return (cwa & cwb) == (LEFT | RIGHT); \n} \n  \n// テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ィテァツキツ堙・ツ按?ゥツ鳴「テゥツ?」テ」ツ?ョティツキツ敕ゥツ崢「 \n  \nD dLP(L l,P p){ return ep(vec(l),p-l.first)/abs(vec(l));} \nD dSP(L s,P p){ \n    if (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first); \n    if (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second); \n    return dLP(s,p); \n} \nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);} \nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));} \nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));} \n  \n\nstruct star{\n\tL l[5];\n};\n\nint main(void){\n    int n,m,l;\n\twhile(cin >> n,n){\n\t\tD graph[110][110];\n\t\tstar s[110];\n\n\t\tcin >> m >> l;\n\t\tm--;l--;\n\t\trep(i,n){\n\t\t\tP base;\n\t\t\tcin >> base.x >> base.y;\n\t\t\tD angle;\n\t\t\tcin >> angle;\n\t\t\tD r;\n\t\t\tcin >> r;\n\n\t\t\tP points[5];\n\n\t\t\tpoints[0]=base;\n\t\t\tpoints[0].y+=r;\n\n\t\t\tfor(int j=1;j<5;j++){\n\t\t\t\tD theta=1.0*72/180.0*pi;\n\t\t\t\tpoints[j]=rot(base,points[0],theta*j);\n\t\t\t}\n\t\t\trep(j,5){\n\t\t\t\tD theta=angle/180.0*pi;\n\t\t\t\tpoints[j]=rot(base,points[j],theta);\n\t\t\t}\n\t\t\n\t\t\trep(j,5){\n\t\t\t\tint pre=(2*j)%5,post=(2*j+2)%5;\n\t\t\t\ts[i].l[j]=mp(points[pre],points[post]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n)rep(j,n){\n\t\t\tD cmin=INF;\n\t\t\trep(k,5)rep(l,5){\n\t\t\t\tcmin=min(cmin,abs( dSS(s[i].l[k],s[j].l[l] )));\n\t\t\t}\n\t\t\tgraph[i][j]=cmin;\n\t\t}\n\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tgraph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n\t\t}\n\n\t\tcout.precision(9);\n\t\tcout << fixed << graph[m][l] << endl;\n\t}\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int LL;\n/*}}}*/\n\ntypedef complex<double> P;\n\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n\n// 点cが線分a,b上にあるかないか(1)\n//int is_point_on_line(P a, P b, P c) {\n//  return EQ( cross(b-a, c-a), 0.0 ) &&\n//         (dot(b-a, c-a) > -EPS) &&\n//         (dot(a-b, c-b) > -EPS);\n//}\n\n// 点cが線分a,b上にあるかないか(2)\n//int is_point_on_line(P a, P b, P c) {\n//  // |a-c| + |c-b| <= |a-b| なら線分上\n//  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n//}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nstruct line_seg {\n\tP start;\n\tP end;\n};\n\nstruct star {\n\tline_seg lines[5];\n};\nvector<star> stars;\n\n#define INF (INT_MAX - 1)\n#define MAX_N 100\ndouble dist[MAX_N][MAX_N];\n\nint main(int argc, char const* argv[])\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tFOR(i, 0, N) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ta = a * 2 * PI / 360.0;\n\n\t\t\tstar s;\n\t\t\tP vertex;\n\t\t\tvertex.real() = r * cos(PI/2.0 + a);\n\t\t\tvertex.imag() = r * sin(PI/2.0 + a);\n\t\t\tFOR(j, 1, 6) {\n\t\t\t\tline_seg ls;\n\t\t\t\tls.start.real() = vertex.real() + x;\n\t\t\t\tls.start.imag() = vertex.imag() + y;\n\n\t\t\t\tdouble rot = a + j * (72 * 2 * 2 * PI / 360.0);\n\t\t\t\tvertex.real() = r * cos(PI/2.0 + rot);\n\t\t\t\tvertex.imag() = r * sin(PI/2.0 + rot);\n\n\t\t\t\tls.end.real() = vertex.real() + x;\n\t\t\t\tls.end.imag() = vertex.imag() + y;\n\n\t\t\t\ts.lines[j-1] = ls;\n\t\t\t}\n\t\t\tstars.PB(s);\n\t\t}\n\n\t\t// debug\n\t\tFOR(i, 0, SZ(stars)) {\n\t\t\tprintf(\"star %d\\n\", i);\n\t\t\tFOR(j, 0, 5) {\n\t\t\t\tprintf(\"(%lf, %lf)-(%lf, %lf)\\n\", stars[i].lines[j].start.real(), stars[i].lines[j].start.imag(), stars[i].lines[j].end.real(), stars[i].lines[j].end.imag());\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, SZ(stars)) {\n\t\t\tFOR(j, 0, SZ(stars)) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble min_dist = INF;\n\t\t\t\tFOR(k, 0, 5) {\n\t\t\t\t\tFOR(l, 0, 5) {\n\t\t\t\t\t\tdouble tmp = min(\n\t\t\t\t\t\t\t\tmin( distance_ls_p(stars[i].lines[k].start, stars[i].lines[k].end, stars[j].lines[l].start),\n\t\t\t\t\t\t\t\t\t\tdistance_ls_p(stars[i].lines[k].start, stars[i].lines[k].end, stars[j].lines[l].end) ),\n\t\t\t\t\t\t\t\tmin( distance_ls_p(stars[j].lines[l].start, stars[j].lines[l].end, stars[i].lines[k].start),\n\t\t\t\t\t\t\t\t\t\tdistance_ls_p(stars[j].lines[l].start, stars[j].lines[l].end, stars[i].lines[k].end) )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\tmin_dist = min(min_dist, tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[i][j] = dist[j][i] = min_dist;\n\t\t\t\tprintf(\"distance between (%d) and (%d) = %lf\\n\", i, j, min_dist);\n\t\t\t}\n\t\t}\n\n\t\tFOR(k, 0, N) {\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tFOR(j, 0, N) {\n\t\t\t\t\tdist[i][j] = min( dist[i][j], dist[i][k] + dist[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[M-1][L-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\ndouble abs(Point p){return sqrt(norm(p));}\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return 1;\n  if(cross(a,b)<-EPS)return -1;\n  if(dot(a,b)<-EPS)return 2;\n  if(norm(a)<norm(b))return -2;\n  return 0;\n}\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\nint main(){\n  double a,b,c,d;\n  int n,ve,al;\n  while(cin>>n>>ve>>al,n){\n    Point p[n][5];\n    seg D[n][5];\n    r(i,n){\n      cin>>a>>b>>c>>d;\n      r(j,5){\n        p[i][j].x=a-d*sin(M_PI/180*(72*j+c));\n        p[i][j].y=b+d*cos(M_PI/180*(72*j+c));\n      }\n      D[i][0].p1=p[i][0];D[i][0].p2=p[i][2];\n      D[i][1].p1=p[i][1];D[i][1].p2=p[i][3];\n      D[i][2].p1=p[i][2];D[i][2].p2=p[i][4];\n      D[i][3].p1=p[i][3];D[i][3].p2=p[i][0];\n      D[i][4].p1=p[i][4];D[i][4].p2=p[i][1];\n    }\n    double w[n][n];\n    r(i,n)r(j,n)w[i][j]=i==j?0:1000000000;\n    r(i,n)R(j,i+1,n){\n      double t=1000000000;\n      r(k,5)r(l,5)t=min(t,getDistance(D[i][k],D[j][l]));\n      w[i][j]=w[j][i]=t;\n    }\n    r(k,n)r(i,n)r(j,n)w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    printf(\"%.11f\\n\",w[ve-1][al-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef pair<double,double> pdd;\n\nconst double pi = atan(1.0) * 4.0;\nconst double EPS = 1e-8;\n\ndouble cross(pdd x, pdd y) {\n\treturn x.first*y.second - x.second*y.first;\n}\n\ndouble dist(pdd x, pdd y) {\n\treturn sqrt((x.first-y.first)*(x.first-y.first) + (x.second-y.second)*(x.second-y.second));\n}\n\nint main() {\n\tint N, M, L;\n\twhile(scanf(\"%d %d %d\", &N, &M, &L), N) {\n\t\tvector< vector<pdd> > star(N);\n\t\trep(i, N) {\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r);\n\t\t\trep(j, 5) {\n\t\t\t\tdouble ang = (72.0 * j + a) * pi / 180.0;\n\t\t\t\tpdd p(x-r*sin(ang), y+r*cos(ang));\n\t\t\t\tstar[i].push_back(p);\n\t\t\t}\n\t\t}\n\t\tdouble cost[100][100];\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = 1e9;\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd v1 = pdd(star[i][ii].first - star[i][(ii+1)%5].first, star[i][ii].second - star[i][(ii+1)%5].second);\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tpdd v2 = pdd(star[j][jj].first - star[j][(jj+1)%5].first, star[j][jj].second - star[j][(jj+1)%5].second);\n\t\t\t\t\t\tpdd u1 = pdd(star[i][ii].first - star[j][(jj+1)%5].first, star[i][ii].second - star[j][(jj+1)%5].second);\n\t\t\t\t\t\tpdd u2 = pdd(star[j][jj].first - star[i][(ii+1)%5].first, star[j][jj].second - star[i][(ii+1)%5].second);\n\t\t\t\t\t\tpdd w1 = pdd(star[i][ii].first - star[j][jj].first, star[i][ii].second - star[j][jj].second);\n\t\t\t\t\t\tpdd w2 = pdd(-w1.first, -w1.second);\n\t\t\t\t\t\tif( cross(v1,u1)*cross(v1,w1)<0 && cross(v2,u2)*cross(v2,w2)<0 ) {\n\t\t\t\t\t\t\tcost[i][j] = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd s = star[i][ii];\n\t\t\t\t\tpdd t = star[i][(ii+1)%5];\n\t\t\t\t\tdouble alp = 0.0f;\n\t\t\t\t\tif( abs(t.first-s.first) < EPS ) {\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], abs(t.first - star[j][jj].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\talp = (t.second-s.second)/(t.first-s.first);\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tpdd p = star[j][jj];\n\t\t\t\t\t\t\tdouble qx = (p.first+alp*p.second-alp*s.second+alp*alp*s.first) / (alp*alp+1.0);\n\t\t\t\t\t\t\tdouble qy = alp*(qx-s.first) + s.second;\n\t\t\t\t\t\t\tpdd q = pdd(qx,qy);\n\t\t\t\t\t\t\tif( dist(q,s)<dist(t,s) && dist(q,t)<dist(t,s) ) {\n\t\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(p,q));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(star[i][ii], star[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = cost[j][i] = min(cost[i][j], cost[j][i]);\n\t\t\t}\n\t\t}\n\t\trep(k, N) {\n\t\t\trep(i, N) {\n\t\t\t\trep(j, N) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", cost[M-1][L-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  double x, y, a, r;\n  ST(){}\n  ST(double x, double y, double a, double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst double INF = 10000000.0;\nconst double EPS = 1e-8;\n\nint n, s, t;\nvector<ST> input;\ndouble dist[N][N];\n\ndouble dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec){\n  vector<Point> data;\n  Point o = Point(st.x, st.y);\n  Point p = Point(st.x, st.y + st.r);\n  for(int i=0;i<5;i++){\n    data.push_back(rotate(p, o, st.a+72.0*i));\n  }\n  int idx[2][5] = {{0, 0, 1, 1, 2}, {2, 3, 3, 4, 4}};\n  for(int i=0;i<5;i++){\n    vec.push_back((Segment){data[idx[0][i]], data[idx[1][i]]});\n  }\n}\n\ndouble calc_dist(ST pa, ST pb){\n  vector<Segment> a, b;\n  get_seg(pa, a);\n  get_seg(pb, b);\n  double res = INF;\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      res = min(res, getDistance(a[i], b[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\ndouble solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.15f\\n\", (double)solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<tuple>\n#include<complex>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmin(T &l, T r) {\n\tbool res = l > r;\n\tif (res) {\n\t\tl = r;\n\t}\n\treturn res;\n}\n#define IL inline\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\ntypedef double D;\nconst D EPS = 1e-8;\nIL D dot(P a, P b) {\n\treturn a.X*b.X + a.Y*b.Y;\n}\nIL D cross(P a, P b) {\n\treturn a.X*b.Y - a.Y*b.X;\n}\n\n\n\nstruct cww {\n\tcww() {\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t}\n}star;\n\nIL D distance_P_LS(P p, LS ls) {\n\tP a, b, c = p;\n\ttie(a, b) = ls;\n\tif (dot(b - a, c - a) < EPS)return abs(c - a);\n\tif (dot(a - b, c - b) < EPS)return abs(c - b);\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nIL bool isintersected_LS_LS(LS p, LS q) {\n\tP a, b ,c ,d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\tif (abs(cross(b - a, d - c))<EPS) {\n\t\tif (abs(abs(b - c) + abs(a - c) - abs(a - b)) < EPS)return true;\n\t\tif (abs(abs(b - d) + abs(a - d) - abs(a - b)) < EPS)return true;\n\t\tif (abs(abs(a - c) + abs(a - d) - abs(c - d)) < EPS)return true;\n\t\tif (abs(abs(b - c) + abs(b - d) - abs(c - d)) < EPS)return true;\n\n\t\treturn false;\n\t}\n\treturn cross(b - a, c - a)*cross(b - a, d - a) < EPS && cross(d - c, a - c)*cross(d - c, b - c) < EPS;\n}\nIL D distance_LS_LS(LS p, LS q) {\n\tif (isintersected_LS_LS(p, q))return 0;\n\tP a, b, c, d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\tdouble e, f, g, h;\n\te = distance_P_LS(a, q);\n\tf = distance_P_LS(b, q);\n\tg = distance_P_LS(c, p);\n\th = distance_P_LS(d, p);\n\treturn min({ e,f,g,h });\n}\nP rot(P p, double r) {\n\treturn P(p.X*cos(r) - p.Y*sin(r), p.X*sin(r) + p.Y*cos(r));\n}\n\nconst D PI = acos(-1);\nconst D FI = 72.0 / 180.0*PI;\ntypedef pair<double, int> pp;\nconst int ss[][2] = { {0,2},{0,3},{1,3},{1,4},{2,4} };\ntypedef priority_queue<pp, vector<pp>, greater<pp>> QUE;\nint main() {\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tvector<LS> ls(5*N);\n\t\tREP(i, N) {\n\t\t\tdouble x, y,a,r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tP p(x, y);\n\t\t\tvector<P> pt(5);\n\t\t\tpt[0] = rot(P(0, r), a/180.0*PI);\n\t\t\tREP(i, 4)pt[i + 1] = rot(pt[i], FI);\n\t\t\tREP(j, 5) {\n\t\t\t\tls[i * 5 + j] = LS(p+pt[ss[j][0]], p+pt[ss[j][1]]);\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> dist(N * 5, vector<double>(N * 5));\n\t\tREP(i, 5*N)REP(j, 5*N) {\n\t\t\tif (i == j)dist[i][j] = 0;\n\t\t\telse dist[i][j] = distance_LS_LS(ls[i], ls[j]);\n\t\t}\n\t\tint S = 5 * (M - 1);\n\t\tint G = 5 * (L - 1);\n\n\n\n\n\n\t\tvector<double> res(N *5, 1e18);\n\t\tres[S] = 0;\n\t\tQUE que;\n\t\tque.push(pp(0,S));\n\t\twhile (que.size()) {\n\t\t\tint v; double cost;\n\t\t\ttie(cost,v) = que.top();\n\t\t\tque.pop();\n\t\t\tif (cost > res[v])continue;\n\t\t\tREP(u, 5 * N) if(u!=v){\n\t\t\t\tdouble ncost = cost + dist[u][v];\n\t\t\t\tif (chmin(res[u], ncost))que.push(pp(ncost, u));\n\t\t\t}\n\t\t}\n\t\tcout << res[G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class T, class U>\nusing Pair = std::pair<T, U>;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <size_t N>\nusing Bits = std::bitset<N>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\nconstexpr Real INF = std::numeric_limits<Real>::max() / 10;\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\nconst Real PI = std::acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\ntemplate <class T>\nT sq(T x) { return x * x; }\n\nusing Point = std::complex<Real>;\nusing Segment = std::pair<Point, Point>;\nusing Polygon = std::vector<Point>;\n\nBool operator<(const Point& a, const Point& b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n\nstd::istream& operator>>(std::istream& is, Point& p) {\n    Real x, y;\n    is >> x >> y;\n    p = Point(x, y);\n    return is;\n}\n\nconstexpr Real EPS = 1e-10;\n\n// 宇宙船演算子\nInt compare(Real a, Real b) {\n    if (std::abs(a - b) < EPS) return 0;\n    return a - b > 0 ? 1 : -1;\n}\n\nReal dist(Point a, Point b) {\n    return std::abs(a - b);\n}\n\nReal length(Segment s) {\n    return dist(s.first, s.second);\n}\n\n// inner product\nReal dot(Point x, Point y) {\n    return std::real(std::conj(x) * (y));\n}\n\n// outer product\nReal cross(Point x, Point y) {\n    return std::imag(std::conj(x) * (y));\n}\n\n// lに対するxの正射影\nPoint proj(Segment s, Point p) {\n    Real ratio = dot(s.second - s.first, p - s.first) / sq(length(s));\n    return s.first + (s.second - s.first) * ratio;\n}\n\n// lに対するpの位置\n// 0: on segment\n// 1: counter clockwise  -1: clockwise\n// 2: online front       -2: online back\nInt side(Segment s, Point p) {\n    Real c = cross(s.second - s.first, p - s.first);\n    if (compare(c, 0) != 0) return compare(c, 0);\n\n    Real d = dot(s.second - s.first, p - s.first);\n    if (compare(d, 0) < 0) return -2;\n\n    return (compare(length(Segment(s.first, p)), length(s)) > 0 ? 2 : 0);\n}\n\n// bound: 線分の端点を含むか\nBool intersect(Segment s1, Segment s2, Bool bound) {\n    return (side(s1, s2.first) * side(s1, s2.second) < bound) &&\n           (side(s2, s1.first) * side(s2, s1.second) < bound);\n}\n\nReal dist(Segment s, Point p) {\n    Point t = proj(s, p);\n    if (side(s, t) == 0) return dist(p, t);\n    return std::min(dist(p, s.first), dist(p, s.second));\n}\n\nReal dist(Segment s1, Segment s2) {\n    if (intersect(s1, s2, true)) return 0;\n    return std::min({dist(s1, s2.first),\n                     dist(s1, s2.second),\n                     dist(s2, s1.first),\n                     dist(s2, s1.second)});\n}\n\n\nBool solve() {\n    Int n, s, g;\n    std::cin >> n >> s >> g;\n    if (n == 0) return false;\n\n    --s, --g;\n    s *= 5, g *= 5;\n\n    Vector<Segment> segs(n * 5);\n    for (Int i = 0; i < n; ++i) {\n        Real x, y, theta, r;\n        std::cin >> x >> y >> theta >> r;\n\n        for (Int j = 0; j < 5; ++j) {\n            segs[i * 5 + j].first =\n                std::polar(r, (theta + j * 72 + 90) / 180 * PI) + Point(x, y);\n            segs[i * 5 + j].second =\n                std::polar(r, (theta + (j + 2) * 72 + 90) / 180 * PI) + Point(x, y);\n        }\n    }\n\n    Vector<Vector<Real>> d(n * 5, Vector<Real>(n * 5, INF));\n    for (Int u = 0; u < n * 5; ++u) {\n        for (Int v = 0; v < n * 5; ++v) {\n            d[u][v] = dist(segs[u], segs[v]);\n        }\n    }\n\n    Vector<Real> dp(n * 5, INF);\n    dp[s] = 0;\n    MinHeap<Tuple<Real, Int>> heap;\n    heap.emplace(0, s);\n\n    while (!heap.empty()) {\n        Real x;\n        Int v;\n        std::tie(x, v) = heap.top();\n        heap.pop();\n        if (compare(x, dp[v]) > 0) continue;\n\n        for (Int u = 0; u < n * 5; ++u) {\n            if (compare(dp[u], dp[v] + d[v][u]) <= 0) continue;\n            dp[u] = dp[v] + d[v][u];\n            heap.emplace(dp[u], u);\n        }\n    }\n\n    std::cout << Fout(20) << dp[g] << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\nbool operator > (Edge<int> e1, Edge<int> e2) {\n    return e1.cost < e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate <typename T>\nstd::vector<T> dijkstra(const Graph<T> &g, int s) {\n    int sz = (int)(g.size());\n    std::vector<T> dist(sz, std::numeric_limits<T>::max());\n    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n    while(!pq.empty()) {\n        T d = pq.top().first;\n        int now = pq.top().second;\n        pq.pop();\n        if(d > dist[now]) continue;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            T cost = g[now][i].cost;\n            if(dist[next] > dist[now] + cost) {\n                dist[next] = dist[now] + cost;\n                pq.push({cost, next});\n            }\n        }\n    }\n    return dist;\n}\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  return os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\nstruct Line {\n  Point a, b;\n  Line() = default;\n  Line(Point a, Point b) : a(a), b(b) {}\n  Line(Real A, Real B, Real C)\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\nstruct Segment : Line {\n  Segment() = default;\n  Segment(Point a, Point b) : Line(a, b) {}\n};\nstruct Circle {\n  Point p;\n  Real r;\n  Circle() = default;\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\nReal distance(const Line &l, const Point &p);\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nvoid merge_segments(vector< Segment > &segs) {\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\nReal area(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A * 0.5;\n}\nReal area(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m, l; cin >> n >> m >> l;\n    m--; l--;\n    if(n == 0) break;\n    vector<vector<Segment>> v(n);\n    for(int i=0;i<n;++i) {\n      int x, y; cin >> x >> y;\n      double a1; cin >> a1;\n      a1 *= M_PI / 180;\n      int r; cin >> r;\n      Point center(x, y);\n      Point p(x, y + r);\n      Point diff1(cos(a1), sin(a1));\n      double a2 = 72;\n      a2 *= M_PI / 180;\n      Point diff2(cos(a2), sin(a2));\n      p = (p - center) * diff1 + center;\n      vector<Point> tmp;\n      for(int j=0;j<5;++j) {\n        tmp.emplace_back(p);\n        p = (p - center) * diff2 + center;\n      }\n      for(int j=0;j<5;++j) {\n        v[i].emplace_back(Segment(tmp[j], tmp[(j+2)%5]));\n      }\n    }\n    Graph<double> g(n);\n    for(int i=0;i<n;++i) {\n      for(int j=i+1;j<n;++j) {\n        double dist = INF;\n        for(int k=0;k<5;++k) {\n          for(int l=0;l<5;++l) {\n            dist = min(dist, distance(v[i][k], v[j][l]));\n          }\n        }\n        g[i].emplace_back(Edge<double>(i, j, dist));\n        g[j].emplace_back(Edge<double>(j, i, dist));\n      }\n    }\n    vector<double> dist = dijkstra(g, m);\n    cout << dist[l] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tdouble x,y;\n};\n\nstruct Point{\n\tdouble x,y;\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n\tvoid set(double x1,double y1,double x2,double y2){\n\t\tp1.x = x1;\n\t\tp1.y = y1;\n\t\tp2.x = x2;\n\t\tp2.y = y2;\n\t}\n\tPoint p1,p2;\n};\n\ntypedef Segment Line;\n\nint N,start,goal;\ndouble dist[101][101];\n\nInfo info[101][5];\nSegment segment[101][5];\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\nPoint calc_minus(Point a,Point b){\n\tPoint ret;\n\n\tret.x = a.x-b.x;\n\tret.y = a.y-b.y;\n\n\treturn ret;\n}\n\ndouble calc_len(Vector a){\n\treturn sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble getDistanceLP(Line l,Point p){\n\treturn fabs(cross(calc_minus(l.p2,l.p1),calc_minus(p,l.p1))/calc_len(calc_minus(l.p2,l.p1)));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(calc_minus(s.p2,s.p1),calc_minus(p,s.p1)) < 0.0)return calc_len(calc_minus(p,s.p1));\n\tif(dot(calc_minus(s.p1,s.p2),calc_minus(p,s.p2)) < 0.0)return calc_len(calc_minus(p,s.p2));\n\treturn getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\treturn min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t\t\tmin(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nInfo roll(double x, double y, double rad)\n{\n\tInfo ret;\n\n\tret.x = x*cos(rad)-y*sin(rad);\n\tret.y = x*sin(rad)+y*cos(rad);\n\n\treturn ret;\n}\n\nvoid func(){\n\n\tdouble x,y,degree,r;\n\n\tInfo tmp;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lf %lf %lf %lf\",&x,&y,&degree,&r);\n\n\t\ttmp = roll(0.0,r,degree*M_PI/180.0);\n\n\t\tinfo[i][0].x = x+tmp.x;\n\t\tinfo[i][0].y = y+tmp.y;\n\n\t\tfor(int k = 1; k <= 4; k++){\n\t\t\ttmp = roll(info[i][k-1].x-x,info[i][k-1].y-y,(2.0*M_PI/5.0));\n\t\t\tinfo[i][k].x = x+tmp.x;\n\t\t\tinfo[i][k].y = y+tmp.y;\n\t\t}\n\n\t\tfor(int k = 0; k < 5; k++){\n\t\t\tsegment[i][k].set(info[i][k%5].x,info[i][k%5].y,info[i][(k+2)%5].x,info[i][(k+2)%5].y);\n\t\t}\n\t}\n\n\tdouble tmp_min,tmp_dist;\n\n\tbool isCross;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = i; k <= N; k++){\n\t\t\tif(i != k){\n\t\t\t\ttmp_min = DBL_MAX;\n\n\t\t\t\tisCross = false;\n\t\t\t\tfor(int a = 0; a < 5; a++){\n\t\t\t\t\tfor(int b = 0; b < 5; b++){\n\t\t\t\t\t\tif(func(segment[i][a].p1.x,segment[i][a].p1.y,segment[i][a].p2.x,segment[i][a].p2.y,segment[k][b].p1.x,segment[k][b].p1.y)*\n\t\t\t\t\t\t\t\tfunc(segment[i][a].p1.x,segment[i][a].p1.y,segment[i][a].p2.x,segment[i][a].p2.y,segment[k][b].p2.x,segment[k][b].p2.y) <= 0 &&\n\t\t\t\t\t\t\t\t\t\tfunc(segment[k][b].p1.x,segment[k][b].p1.y,segment[k][b].p2.x,segment[k][b].p2.y,segment[i][a].p1.x,segment[i][a].p1.y)*\n\t\t\t\t\t\t\t\t\t\t\tfunc(segment[k][b].p1.x,segment[k][b].p1.y,segment[k][b].p2.x,segment[k][b].p2.y,segment[i][a].p2.x,segment[i][a].p2.y) <= 0){\n\t\t\t\t\t\t\tisCross = true;\n\t\t\t\t\t\t\ttmp_min = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif(isCross)\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif(!isCross){\n\t\t\t\t\tfor(int a = 0; a < 5; a++){\n\t\t\t\t\t\tfor(int b = 0; b < 5; b++){\n\t\t\t\t\t\t\ttmp_dist = getDistance(segment[i][a],segment[k][b]);\n\t\t\t\t\t\t\ttmp_min = min(tmp_min,tmp_dist);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdist[i][k] = tmp_min;\n\t\t\t\tdist[k][i] = tmp_min;\n\n\t\t\t}else{\n\t\t\t\tdist[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int mid = 1; mid <= N; mid++){\n\t\tfor(int st = 1; st <= N; st++){\n\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\tdist[st][gl] = min(dist[st][gl],dist[st][mid]+dist[mid][gl]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.20lf\\n\",dist[start][goal]);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&start,&goal);\n\t\tif(N == 0 && start == 0 && goal == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = x + ope.x;\n\t\ttmp.y = y + ope.y;\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = x - ope.x;\n\t\ttmp.y = y - ope.y;\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn x*ope.x + y*ope.y;\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn x*ope.y - y*ope.x;\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= 0;\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) < 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) < 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (s-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+2)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tdouble d;\n\t\tdouble ang_k1, ang_k2, ang_l1, ang_l2;\n\t\tvec2d v_k1, v_k2, v_l1, v_l2;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.8f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\t//addhtml(\"ctx.fill();\");\n\t}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\n\nint n,st,gl;\nvector<vector<line> > ss;\n\nconst double pi = 3.14159265358979;\n\ndouble ds[105][105];\n\nint main(void){\n\tfor(;;){\n\t\tss.clear();\n\t\tscanf(\"%d%d%d\",&n,&st,&gl); st--; gl--;\n\t\tif(n==0)break;\n\t\t\n\t\t//inithtml();\n\t\trep(k,n){\n\t\t\tdouble x,y,a,r;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&a,&r); a = (a/360.0) * 2 * pi;\n\t\t\tdouble nn = (144.0/360.0) * 2 * pi;\n\t\t\tpos bs(x,y);\n\t\t\tvector<line> ns;\n\t\t\trep(i,5){\n\t\t\t\tpos fr(-r*sin(a+(i*nn)),r*cos(a+(i*nn)));\n\t\t\t\tpos to(-r*sin(a+((i+1)*nn)),r*cos(a+((i+1)*nn)));\n\t\t\t\tline ne(fr+bs,to+bs);\n\t\t\t\tns.push_back(ne);\n\t\t\t\t//ne.outh(30);\n\t\t\t}\n\t\t\tss.push_back(ns);\n\t\t}\n\t\t\n\t\t//outhtml(\"o\",30);\n\t\t\n\t\trep(i,n)ds[i][i]=0;\n\t\trep(i,n)rep(j,i){\n\t\t\tdouble nd = 1e10;\n\t\t\trep(p,5)rep(q,5){\n\t\t\t\tnd = min(nd,ss[i][p].dist(ss[j][q]));\n\t\t\t}\n\t\t\tds[i][j]=ds[j][i]=nd;\n\t\t}\n\t\t\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n\t\t}\n\t\tprintf(\"%.8f\\n\",ds[st][gl]);\n\t}\t\n\t\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<utility>\n#include<queue>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\nconst ld eps = 1e-8, pi = acos(-1.0);\nstruct L { P a, b; };\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nld dist_pp(P p, P q) {\n  return abs(p - q);\n}\n\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  ld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n  ld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n  return min(a, b);\n}\n\nP rotate(ld deg, P p) {\n  ld rad = deg * pi / 180.0;\n  return polar((ld)1.0, rad) * p;\n}\n\nstruct Star { L e[5]; };\n\nld dist_stst(Star s, Star t) {\n  ld val = dist_ss(s.e[0], t.e[0]);\n  for (L ss : s.e) for (L ts : t.e) {\n    val = min(val, dist_ss(ss, ts));\n  }\n  return val;\n}\n\nint main() {\n  int n, m, l;\n  while (cin >> n >> m >> l and n) {\n    m--; l--;\n    vector<Star> stars(n);\n    for (Star &s : stars) {\n      int x, y ,a, r;\n      cin >> x >> y >> a >> r;\n      P center(x, y);\n      cout << center << endl;\n      for (int i = 0; i < 5; i++) {\n        s.e[i].a = s.e[(i+3)%5].b = \n          center + polar((ld)r, (a + 72 * i) * pi / 180.0);\n      }\n    }\n\n    vector<vector<ld>> dist(n);\n    for (vector<ld> &v : dist) {\n      v.reserve(n);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        dist[i][j] = dist_stst(stars[i], stars[j]);\n      }\n    }\n\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    cout << fixed << setprecision(30)<< dist[m][l] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\ntypedef complex<double> P;\nstruct seg{P p1,p2;};\ndouble eps=1e-10;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;\n  if(a.imag()<-eps)return -1;\n  if(a.real()<-eps)return 2;\n  if(abs(b)+eps<abs(c))return -2;\n  return 0;\n}\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\nint main(){\n  double a,b,c,d;\n  int n,ve,al;\n  while(cin>>n>>ve>>al,n){\n    P p[n][5];\n    seg D[n][5];\n    r(i,n){\n      cin>>a>>b>>c>>d;\n      r(j,5)p[i][j]=P(a-d*sin(M_PI/180*(72*j+c)),b+d*cos(M_PI/180*(72*j+c)));\n      r(j,5)D[i][j].p1=p[i][j%5],D[i][j].p2=p[i][(j+2)%5];\n    }\n    double w[n][n];\n    r(i,n)r(j,n)w[i][j]=i==j?0:1000000000;\n    r(i,n)R(j,i+1,n){\n      double t=1000000000;\n      r(k,5)r(l,5)t=min(t,dist(D[i][k].p1,D[i][k].p2,D[j][l].p1,D[j][l].p2));\n      w[i][j]=w[j][i]=t;\n    }\n    r(k,n)r(i,n)r(j,n)w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    printf(\"%.11f\\n\",w[ve-1][al-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return norm(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return norm(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<tuple>\n#include<complex>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmin(T &l, T r) {\n    bool res = l > r;\n    if (res) {\n        l = r;\n    }\n    return res;\n}\n#define IL inline\n#define X real()\n#define Y imag()\n#define fi first\n#define se second\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\ntypedef bool B;\ntypedef double D;\nconst D EPS = 1e-8;\nIL D dot(P a, P b) {\n    return a.X*b.X + a.Y*b.Y;\n}\nIL D cross(P a, P b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n     IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n\n \n \nstruct cww {\n    cww() {\n        cout << fixed;\n        cout << setprecision(10);\n    }\n}star;\n \nIL D distance_P_LS(P p, LS ls) {\n    P a, b, c = p;\n    tie(a, b) = ls;\n    if (dot(b - a, c - a) < EPS)return abs(c - a);\n    if (dot(a - b, c - b) < EPS)return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n    IL B is_LS_LS(LS p, LS q) {\n        P a, b, c, d;\n        tie(a, b) = p;\n        tie(c, d) = q;\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n \n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS)return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\nP rot(P p, double r) {\n    return P(p.X*cos(r) - p.Y*sin(r), p.X*sin(r) + p.Y*cos(r));\n}\n \nconst D PI = acos(-1);\nconst D FI = 72.0 / 180.0*PI;\ntypedef pair<double, int> pp;\nconst int ss[][2] = { {0,2},{0,3},{1,3},{1,4},{2,4} };\ntypedef priority_queue<pp, vector<pp>, greater<pp>> QUE;\nint main() {\n    int N, M, L;\n    while (cin >> N >> M >> L, N) {\n        vector<LS> ls(5*N);\n        REP(i, N) {\n            double x, y,a,r;\n            cin >> x >> y >> a >> r;\n            P p(x, y);\n            vector<P> pt(5);\n            pt[0] = rot(P(0, r), a/180.0*PI);\n            REP(i, 4)pt[i + 1] = rot(pt[i], FI);\n            REP(j, 5) {\n                ls[i * 5 + j] = LS(p+pt[ss[j][0]], p+pt[ss[j][1]]);\n            }\n        }\n        vector<vector<double>> dist(N * 5, vector<double>(N * 5));\n        REP(i, 5*N)REP(j, 5*N) {\n            if (i == j)dist[i][j] = 0;\n            else dist[i][j] = distance_LS_LS(ls[i], ls[j]);\n        }\n        int S = 5 * (M - 1);\n        int G = 5 * (L - 1);\n \n \n \n \n \n        vector<double> res(N *5, 1e18);\n        res[S] = 0;\n        QUE que;\n        que.push(pp(0,S));\n        while (que.size()) {\n            int v; double cost;\n            tie(cost,v) = que.top();\n            que.pop();\n            if (cost > res[v])continue;\n            REP(u, 5 * N) if(u!=v){\n                double ncost = cost + dist[u][v];\n                if (chmin(res[u], ncost))que.push(pp(ncost, u));\n            }\n        }\n        cout << res[G] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing Real = long double;\n\tusing Point = std::complex<Real>;\n\tusing pd5 = std::array<Point, 5>;\n\tusing vd = std::vector<Real>;\n\tusing vvd = std::vector<vd>;\n\n\tint N, M, L;\n\tstd::vector<pd5> stars;\n\tvvd graph;\n\n\tvoid makeStars()\n\t{\n\t\tstars.resize(N);\n\t\tfor (auto& e: stars)\n\t\t{\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &a, &r);\n\t\t\tfor (int i{}; i < 5; i++)\n\t\t\t{\n\t\t\t\tReal angular{(a + 90 + 72 * i) / 180.0 * M_PI};\n\t\t\t\te[i].real(x + r * std::cos(angular));\n\t\t\t\te[i].imag(y + r * std::sin(angular));\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid makeGraph()\n\t{\n\t\tgraph.resize(N, vd(N));\n\t\tfor (int i{}; i < N; i++)\n\t\t\tfor (int j{1}; j < N; j++)\n\t\t\t\tgraph[i][j] = graph[j][i] = calcDistance(i, j);\n\t}\n\n\tReal calcDistance(int a, int b)\n\t{\n\t\tReal min{1e9};\n\t\tfor (int a_i{}; a_i < 5; a_i++)\n\t\t\tfor (int b_i{}; b_i < 5; b_i++)\n\t\t\t{\n\t\t\t\tif (linesCross(a, a_i, b, b_i))\n\t\t\t\t\treturn 0;\n\t\t\t\tPoint &a1{stars[a][a_i]}, &a2{stars[a][(a_i + 2) % 5]}, &b1{stars[b][b_i]}, &b2{stars[b][(b_i + 2) % 5]};\n\t\t\t\tmin = std::min(min, std::abs(a1 - b1));\n\t\t\t\tif (std::real((a1 - b1) / (b2 - b1)) > 0 && std::real((a1 - b2) / (b1 - b2)) > 0)\n\t\t\t\t\tmin = std::min(min, std::abs(a1 - b1) * std::abs(std::sin(std::arg((a1 - b1) / (b2 - b1)))));\n\t\t\t\tif (std::real((b1 - a1) / (a2 - a1)) > 0 && std::real((b1 - a2) / (a1 - a2)) > 0)\n\t\t\t\t\tmin = std::min(min, std::abs(b1 - a1) * std::abs(std::sin(std::arg((b1 - a1) / (a2 - a1)))));\n\t\t\t}\n\t\treturn min;\n\t}\n\n\tbool linesCross(int a, int a_i, int b, int b_i)\n\t{\n\t\tPoint &bbase{stars[b][b_i]};\n\t\tPoint &bfrom{stars[b][(b_i + 2) % 5]};\n\t\tPoint &abase{stars[a][a_i]};\n\t\tPoint &afrom{stars[a][(a_i + 2) % 5]};\n\t\treturn std::imag((abase - bbase) / (bfrom - bbase)) * std::imag((afrom - bbase) / (bfrom - bbase)) < 0\n\t\t\t&& std::imag((bbase - abase) / (afrom - abase)) * std::imag((bfrom - abase) / (afrom - abase)) < 0;\n\t}\n\n\tReal dijkstra()\n\t{\n\t\tusing pri = std::pair<Real, int>;\n\t\tstd::priority_queue<pri, std::vector<pri>, std::greater<pri>> dij;\n\t\tdij.push({0, M});\n\t\tstd::vector<Real> dist(N, 1e9);\n\t\tdist[M] = 0;\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\tauto now{dij.top()};\n\t\t\tdij.pop();\n\t\t\tif (now.first > dist[now.second]) continue;\n\t\t\tfor (int i{}; i < N; i++)\n\t\t\t\tif (now.first + graph[now.second][i] < dist[i])\n\t\t\t\t{\n\t\t\t\t\tdist[i] = now.first + graph[now.second][i];\n\t\t\t\t\tdij.push({dist[i], i});\n\t\t\t\t}\n\t\t}\n\t\treturn dist[L];\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &L);\n\t\tif (N == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tM--; L--;\n\t\tmakeStars();\n\t\tmakeGraph();\n\t\tstd::cout << std::setprecision(10) << std::fixed << dijkstra() << std::endl;\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int LL;\n/*}}}*/\n\ntypedef complex<double> P;\n\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n\n// 点cが線分a,b上にあるかないか(1)\n//int is_point_on_line(P a, P b, P c) {\n//  return EQ( cross(b-a, c-a), 0.0 ) &&\n//         (dot(b-a, c-a) > -EPS) &&\n//         (dot(a-b, c-b) > -EPS);\n//}\n\n// 点cが線分a,b上にあるかないか(2)\n//int is_point_on_line(P a, P b, P c) {\n//  // |a-c| + |c-b| <= |a-b| なら線分上\n//  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n//}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nstruct line_seg {\n\tP start;\n\tP end;\n};\n\nstruct star {\n\tline_seg lines[5];\n};\nvector<star> stars;\n\n#define INF (INT_MAX - 1)\n#define MAX_N 100\ndouble dist[MAX_N][MAX_N];\n\nint main(int argc, char const* argv[])\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tFOR(i, 0, N) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ta = a * 2 * PI / 360.0;\n\n\t\t\tstar s;\n\t\t\tP vertex;\n\t\t\tvertex.real() = r * cos(PI/2.0 + a);\n\t\t\tvertex.imag() = r * sin(PI/2.0 + a);\n\t\t\tFOR(j, 1, 6) {\n\t\t\t\tline_seg ls;\n\t\t\t\tls.start.real() = vertex.real() + x;\n\t\t\t\tls.start.imag() = vertex.imag() + y;\n\n\t\t\t\tdouble rot = a + j * (72 * 2 * 2 * PI / 360.0);\n\t\t\t\tvertex.real() = r * cos(PI/2.0 + rot);\n\t\t\t\tvertex.imag() = r * sin(PI/2.0 + rot);\n\n\t\t\t\tls.end.real() = vertex.real() + x;\n\t\t\t\tls.end.imag() = vertex.imag() + y;\n\n\t\t\t\ts.lines[j-1] = ls;\n\t\t\t}\n\t\t\tstars.PB(s);\n\t\t}\n\n\t\t// debug\n\t\tFOR(i, 0, SZ(stars)) {\n\t\t\t//printf(\"star %d\\n\", i);\n\t\t\tFOR(j, 0, 5) {\n\t\t\t\t//printf(\"(%lf, %lf)-(%lf, %lf)\\n\", stars[i].lines[j].start.real(), stars[i].lines[j].start.imag(), stars[i].lines[j].end.real(), stars[i].lines[j].end.imag());\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, SZ(stars)) {\n\t\t\tFOR(j, 0, SZ(stars)) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble min_dist = INF;\n\t\t\t\tFOR(k, 0, 5) {\n\t\t\t\t\tFOR(l, 0, 5) {\n\t\t\t\t\t\tdouble tmp = min(\n\t\t\t\t\t\t\t\tmin( distance_ls_p(stars[i].lines[k].start, stars[i].lines[k].end, stars[j].lines[l].start),\n\t\t\t\t\t\t\t\t\t\tdistance_ls_p(stars[i].lines[k].start, stars[i].lines[k].end, stars[j].lines[l].end) ),\n\t\t\t\t\t\t\t\tmin( distance_ls_p(stars[j].lines[l].start, stars[j].lines[l].end, stars[i].lines[k].start),\n\t\t\t\t\t\t\t\t\t\tdistance_ls_p(stars[j].lines[l].start, stars[j].lines[l].end, stars[i].lines[k].end) )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\tmin_dist = min(min_dist, tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[i][j] = dist[j][i] = min_dist;\n\t\t\t\t//printf(\"distance between (%d) and (%d) = %lf\\n\", i, j, min_dist);\n\t\t\t}\n\t\t}\n\n\t\tFOR(k, 0, N) {\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tFOR(j, 0, N) {\n\t\t\t\t\tdist[i][j] = min( dist[i][j], dist[i][k] + dist[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[M-1][L-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR dist2(const P &p)const {return norm(outp(dir(), p - at(0))) / norm(dir());}\n\t\tR dist(const P &p)const {return sqrt(dist2(p));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR dist2(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return norm(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return norm(p - at(1));\n\t\t\treturn L::dist2(p);\n\t\t}\n\t\tR dist(const P &p)const {\n\t\t\treturn sqrt(dist(p));\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR dist2(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.dist2(at(0)), l.dist2(at(1)));\n\t\t}\n\t\tR dist2(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.dist2(at(0)), s.dist2(at(1))), \n\t\t\t\t\t   min(dist2(s[0]), dist2(s[1])));\n\t\t}\n\t\ttemplate<class T> R dist(const T& t){return sqrt(dist2(t));}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.dist2(c), c.r*c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.dist2(c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).dist2(c), c.r*c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).dist2(c), c.r*c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R dist2(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).dist2(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate<class T> R dist(const T& t){return sqrt(dist2(t));}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].dist2(star[j][jk]));\n\t\tREP(i, n)REP(j, n) g[i][j] = sqrt(g[i][j]);\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\ndouble to_rad(int degree){\n\treturn degree*PI/180;\n}\n//点pを中心としてr(radian)回転            p(0,0)で原点を中心として回転\nP rotate(P t, P p, double r){\n    //double r=radians(angle);\n    double ta=cos(r)*(t.real()-p.real())-sin(r)*(t.imag()-p.imag())+p.real();\n    double tb=sin(r)*(t.real()-p.real())+cos(r)*(t.imag()-p.imag())+p.imag();\n    return P(ta , tb);\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが線分a,b上にあるかないか(2)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  if (( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n          ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS ))\n        return true;\n  return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2) ||\n             is_point_on_line(b1, b2, a1) || is_point_on_line(b1, b2, a2);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distance_ls(P a1, P a2, P b1, P b2) {\n  if (is_intersected_ls(a1, a2, b1, b2)) { return 0.0; }\n  return min( min(distance_ls_p(a1, a2, b1), distance_ls_p(a1, a2, b2)),\n                  min(distance_ls_p(b1, b2, a1), distance_ls_p(b1, b2, a2)) );\n}\n\nconst double MAX=INT_MAX/10;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\nint main(){\n\tcout.precision(16);\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n|m|l){\n\t\tvvp stars(n,vp());\n\t\tREP(i,n){\n\t\t\tint x,y,a,r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tREP(j,5){\n\t\t\t\tint degree=(((j*2)%5)*72+a)%360;\n\t\t\t\tP p=rotate(P(x,y+r),P(x,y),to_rad(degree));\n\t\t\t\tstars[i].push_back(p);\n\t\t\t}\n\t\t}\n\t\tvvd dist(n,vd(n));\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tif(i==j){\n\t\t\t\t\tdist[i][j]=0;\n\t\t\t\t}else{\n\t\t\t\t\tdouble d=INT_MAX;\n\t\t\t\t\tREP(k,5){\n\t\t\t\t\t\td=min(d,distance_ls(stars[i][k],stars[i][(k+1)%5],stars[j][k],stars[j][(k+1)%5]));\n\t\t\t\t\t}\n\t\t\t\t\tdist[i][j]=d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(k,n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,n){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dist[m-1][l-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\n// XY座標\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-10;\nconst double INF = 1e+12;\nconst double PI = acos(-1.0);\ntypedef complex<double> P;\n\n// 内積(dot product) a・b = |a||b|cosθ \ndouble dot(P a, P b){\n\treturn real( conj(a) * b );\n}\n\n// 外積(cross product) |a×b| = |a||b|sinθ\ndouble cross(P a, P b){\n\treturn imag( conj(a) * b );\n}\n\n// 度からラジアンに変換する.\ndouble to_rad(double deg){\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を a ラジアンだけ回転した点を返す.\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を angle ラジアンだけ回転した点を返す.\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n// 線分クラス\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){\n\t\ta = a_; b = b_;\n\t}\n\t\n\t// 点 p と線分の距離を返す.\n\tdouble distance(P p){\n\t\tif( dot(b-a,p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b,p-b) < EPS ) return abs(p-b);\n\t\treturn abs( cross(b-a,p-a) ) / abs(b-a) ;\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n\tbool is_intersection(const Segment& s){\n\t\treturn ( ccw(a, b, s.a) == ON && ccw(a, b, s.b) == ON && \n\t\t         ccw(s.a, s.b, a) == ON && ccw(s.a, s.b, b) == ON);\n\t}\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\t//if( is_intersection(s) ) return 0.0;\n\t\treturn min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n\t}\n\t// デバッグ出力\n\tvoid print(){\n\t\tprintf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n\t}\n};\n\nint main(){\n\t// n := 星の数, m := スタート, l := ゴール\n\tint n, m, l;\n\twhile( scanf(\"%d %d %d\", &n, &m, &l) , n || m || l ){\n\t\tm--; l--;\n\t\t// v[i] := i 番目の星 (5つの線分)\n\t\tvector< vector<Segment> > v;\n\t\t \n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r );\n\t\t\tdouble angle = to_rad( a + 90 );\n\t\t\tP p1( x + r*cos(angle) , y + r*sin(angle) );\n\t\t\tP p2 = rot2( P(x,y) , p1 , to_rad(72) );\n\t\t\tP p3 = rot2( P(x,y) , p2 , to_rad(72) );\n\t\t\tP p4 = rot2( P(x,y) , p3 , to_rad(72) );\n\t\t\tP p5 = rot2( P(x,y) , p4 , to_rad(72) );\n\t\t\t// vs := 5 つの線分\n\t\t\tvector<Segment> vs;\n\t\t\tvs.push_back( Segment(p1,p3) );\n\t\t\tvs.push_back( Segment(p3,p5) );\n\t\t\tvs.push_back( Segment(p5,p2) );\n\t\t\tvs.push_back( Segment(p2,p4) );\n\t\t\tvs.push_back( Segment(p4,p1) );\n\t\t\tv.push_back( vs );\n\t\t}\n\t\tdouble G[101][101];\n\t\tfor(int i=0 ; i < 101 ; i++ ){\n\t\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tdouble d = INF;\n\t\t\t\tfor(int k1 = 0 ; k1 < v[i].size() ; k1++ ){\n\t\t\t\t\tfor(int k2 = 0 ; k2 < v[j].size() ; k2++ ){\n\t\t\t\t\t\tSegment s1 = v[i][k1];\n\t\t\t\t\t\tSegment s2 = v[j][k2];\n\t\t\t\t\t\td = min( d , s1.distance(s2) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i][j] = G[j][i] = fabs( d );\n\t\t\t} \n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\tG[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8f\\n\", G[m][l] );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\ndouble dot(P a, P b) { return (a.real() * b.real() + a.imag() * b.imag()); }\ndouble det(P a, P b) { return (a.real() * b.imag() - a.imag() * b.real()); }\n\nint n, m, l, x[100], y[100], a[100], r[100];\n\nP p[100][5];\ndouble d[100][100];\n\ndouble distanceLSP(P a, P b, P c) {\n  if (dot(b-a, c-a) < EPS) return abs(c-a);\n  if (dot(a-b, c-b) < EPS) return abs(c-b);\n  return abs(det(b-a, c-a)) / abs(b-a);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d%d\", &n, &m, &l);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &a[i], &r[i]);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 5; j++) {\n        double S = (double)(a[i] + 72 * j) * M_PI / 180;\n        p[i][j] = P(x[i] - r[i] * sin(S), y[i] + r[i] * cos(S));\n      }\n    }\n    for (int i = 0; i < n; i++) d[i][i] = 0.0;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        double temp = distanceLSP(p[i][0], p[i][2], p[j][0]);\n        for (int k = 0; k < 5; k++) {\n          for (int z = 0; z < 5; z++) {\n            temp = min(temp, distanceLSP(p[i][k], p[i][(k + 2) % 5], p[j][z]));\n            temp = min(temp, distanceLSP(p[i][k], p[i][(k + 3) % 5], p[j][z]));\n            temp = min(temp, distanceLSP(p[j][k], p[j][(k + 2) % 5], p[i][z]));\n            temp = min(temp, distanceLSP(p[j][k], p[j][(k + 3) % 5], p[i][z]));\n          }\n        }\n        d[i][j] = d[j][i] = temp;\n      }\n    }\n    for (int k = 0; k < n; k++)\n      for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    printf(\"%.9f\\n\", d[m-1][l-1]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n \n \n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#endif\n \n#define rep (i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define MEMCPY(dest, src) memcpy(dest, src, sizeof(src))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\ntemplate <class T> vector<T> input(int n) { vector<T> res(n); for (int i = 0; i < n; ++i) cin >> res[i]; return res; }\n\n\n\n\n\n//const double EPS = 1e-8;\ntypedef complex<double> Point;\n\nint sign(double n)\n{\n\tif (abs(n) < EPS)\n\t\treturn 0;\n\telse if (n > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / (a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < 0)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) < 0)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(point, a, b);\n}\nbool is_point_on_line(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(b-a, point-a)) < EPS;\n}\nbool is_point_on_linesegment(const Point& point, const Point& a, const Point& b)\n{\n\treturn distance_linesegment_point(point, a, b) < EPS;\n}\nbool intersect_linesegments(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n\treturn cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < -EPS\n\t\t&& cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < -EPS\n\t\t|| is_point_on_linesegment(b1, a1, a2)\n\t\t|| is_point_on_linesegment(b2, a1, a2)\n\t\t|| is_point_on_linesegment(a1, b1, b2)\n\t\t|| is_point_on_linesegment(a2, b1, b2);\n}\ndouble distance_seg_seg(const Point& a, const Point& b, const Point& c, const Point& d)\n{\n\tif (intersect_linesegments(a, b, c, d))\n\t\treturn 0;\n\treturn min(min(distance_linesegment_point(c, a, b), distance_linesegment_point(d, a, b))\n\t\t, min(distance_linesegment_point(a, c, d), distance_linesegment_point(b, c, d)));\n}\n\ndouble yogen(double a, double b, double angle)\n{\n\treturn sqrt(a*a + b*b - 2*a*b*cos(angle));\n}\ndouble len(double r)\n{\n\treturn yogen(r, r, PI * 2 / 3);\n}\n\ntypedef pair<Point, Point> Line;\nvoid rotate(double& x, double& y, double ang, double bx = 0, double by = 0)\n{\n\tdouble tx = x - bx, ty = y - by;\n\tdouble c = cos(ang), s = sin(ang);\n\tx = tx * c - ty * s + bx;\n\ty = tx * s + ty * c + by;\n}\nvector<Line> lines(int x, int y, int a, int r)\n{\n\tdouble l = len(r);\n\tdouble w = PI * 2 / 5;\n\tdouble a1 = PI / 2 - w;\n\tdouble a2 = w - a1;\n\n\tdouble c1 = cos(a1), s1 = sin(a1);\n\tdouble c2 = cos(a2), s2 = sin(a2);\n\n\tdouble px[] = { 0, -c2, c1, -c1, c2, 0 };\n\tdouble py[] = { 1, -s2, s1, s1, -s2, 1 };\n\n\tdouble ang = PI * a / 180;\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\trotate(px[i], py[i], ang);\n\t\tpx[i] *= r, py[i] *= r;\n\t\tpx[i] += x, py[i] += y;\n\t}\n\n\tvector<Line> res;\n\tfor (int i = 0; i < 5; ++i)\n\t\tres.push_back(Line(Point(px[i], py[i]), Point(px[i + 1], py[i + 1])));\n\treturn res;\n}\nint main()\n{\n\tconst double INF = 1e20;\n\n\tint n, s, g;\n\twhile (cin >> n >> s >> g, n)\n\t{\n\t\t--s, --g;\n\n\t\tvector<Line> star[128];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstar[i] = lines(x, y, a, r);\n\t\t}\n\n\n\t\tdouble e[128][128];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\te[i][j] = INF;\n\t\t\t\tfor (int k = 0; k < 5; ++k)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < 5; ++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin_swap(e[i][j], distance_seg_seg(star[i][k].first, star[i][k].second\n\t\t\t\t\t\t\t, star[j][l].first, star[j][l].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tdouble dis[128];\n\t\tfill(dis, dis + n, INF);\n\n\t\ttypedef pair<double, int> P;\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tdis[s] = 0;\n\t\tq.push(P(0, s));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tP tt = q.top(); q.pop();\n\t\t\tint p = tt.second;\n\t\t\tdouble c = tt.first;\n\n\t\t\tif (c > dis[p])\n\t\t\t\tcontinue;\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tdouble nc = c + e[p][i];\n\t\t\t\tif (nc < dis[i])\n\t\t\t\t{\n\t\t\t\t\tdis[i] = nc;\n\t\t\t\t\tq.push(P(nc, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(15);\n\t\tcout << dis[g] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n  \n  \n  \n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#endif\n  \n#define rep (i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define MEMCPY(dest, src) memcpy(dest, src, sizeof(src))\n  \n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n  \ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n  \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\ntemplate <class T> vector<T> input(int n) { vector<T> res(n); for (int i = 0; i < n; ++i) cin >> res[i]; return res; }\n \n \n \n \n \nconst double EPS_FOR_LIB = 1e-8;\ntypedef double geo_type;\ntypedef complex<geo_type> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n};\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point a, Point b) : a(a), b(b) { }\n\tLine() { }\n\tPoint vec() const { return b - a; }\n};\ntypedef vector<Point> Poly;\n \nvoid pri(const Point& p)\n{\n\tprintf(\"(%f, %f)\\n\", p.real(), p.imag());\n}\nvoid pri(const Line& line)\n{\n\tprintf(\"(%f, %f) - (%f, %f)\\n\", line.a.real(), line.a.imag(), line.b.real(), line.b.imag());\n}\n\n\ngeo_type dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngeo_type cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n \nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\tstraight = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > EPS_FOR_LIB) return counter_clockwise;\n\telse if (cross(p, q) < -EPS_FOR_LIB) return clockwise;\n\telse return straight;\n}\n\n// 交差判定\nbool intersectLL(const Line& line1, const Line& line2)\n{\n\t// non-parallel\n\tif (abs(cross(line1.b - line1.a, line2.b - line2.a) > EPS_FOR_LIB))\n\t\treturn true;\n\t// same line\n\tif (abs(cross(line1.b - line1.a, line2.a - line1.a) < EPS_FOR_LIB))\n\t\treturn true;\n\treturn false;\n}\nbool intersectLS(const Line& line, const Line& seg)\n{\n\treturn cross(line.b - line.a, seg.a - line.a)\n\t\t* cross(line.b - line.a, seg.b - line.a) < EPS_FOR_LIB;\n}\nbool intersectLP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.b - p, line.a - p)) < EPS_FOR_LIB;\n}\nbool intersectSS(const Line& seg1, const Line& seg2)\n{\n\treturn ccw(seg1.a, seg1.b, seg2.a) * ccw(seg1.a, seg1.b, seg2.b) <= 0\n\t\t&& ccw(seg2.a, seg2.b, seg1.a) * ccw(seg2.a, seg2.b, seg1.b) <= 0;\n}\nbool intersectSP(const Line& seg, const Point& p)\n{\n\treturn norm(seg.a - p) + norm(seg.b - p) - norm(seg.a - seg.b) < EPS_FOR_LIB;\n}\n\n// 距離\n// complex<double>で使わないとNG\n// 点から直線に垂線を下ろした点\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.a - line.b;\n\tdouble t = dot(p - line.a, a) / norm(a);\n\treturn line.a + t * a;\n}\n// 線対称な点\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((geo_type)2) * (projection(line, p) - p);\n}\n\n// new\ndouble dist(const Point& a, const Point& b)\n{\n\treturn abs(a - b);\n}\n\n// 直交判定\nbool is_orthogonal(const Line& a, const Line& b)\n{\n\treturn dot(a.vec(), b.vec()) < EPS_FOR_LIB;\n}\nbool is_parallel(const Line& a, const Line& b)\n{\n\treturn cross(a.vec(), b.vec()) < EPS_FOR_LIB;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn cross(line.b - line.a, p - line.a) < EPS_FOR_LIB;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn dist(seg.a, p) + dist(p, seg.b) < dist(seg.a, seg.b) + EPS_FOR_LIB;\n}\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.b - line.a, seg.a - line.a)\n\t\t* cross(line.b - line.a, seg.b - line.a) < EPS_FOR_LIB;\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn cross(seg1.b - seg1.a, seg2.a - seg1.a) * cross(seg1.b - seg1.a, seg2.b - seg1.a) < -EPS_FOR_LIB\n\t\t&& cross(seg2.b - seg2.a, seg1.a - seg2.a) * cross(seg2.b - seg2.a, seg1.b - seg2.a) < -EPS_FOR_LIB\n\t\t|| is_on_seg(seg1, seg2.a)\n\t\t|| is_on_seg(seg1, seg2.b)\n\t\t|| is_on_seg(seg2, seg1.a)\n\t\t|| is_on_seg(seg2, seg1.b);\n}\n\ndouble dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.a - line.b, p - line.b) / abs(line.a - line.b));\n}\ndouble dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.a), dist_LP(line, seg.b));\n}\ndouble dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.b - seg.a, p - seg.a) < 0)\n\t\treturn abs(seg.a - p);\n\telse if (dot(seg.a - seg.b, p - seg.b) < 0)\n\t\treturn abs(seg.b - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ndouble dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.a), dist_SP(seg1, seg2.b))\n\t\t\t, min(dist_SP(seg2, seg1.a), dist_SP(seg2, seg1.b)));\n}\n// new\n\n\ndouble distanceLP(const Line& line, const Point& p)\n{\n\treturn abs(p - projection(line, p));\n}\ndouble distanceLL(const Line& line1, const Line& line2)\n{\n\treturn intersectLL(line1, line2) ? 0 : distanceLP(line1, line2.a);\n}\ndouble distanceLS(const Line& line, const Line& seg)\n{\n\tif (intersectLS(line, seg))\n\t\treturn 0;\n\treturn min(distanceLP(line, seg.a), distanceLP(line, seg.b));\n}\ndouble distanceSP(const Line& seg, const Point& p)\n{\n\tconst Point r = projection(seg, p);\n\tif (intersectSP(seg, r))\n\t\treturn abs(r - p);\n\treturn min(abs(seg.a - p), abs(seg.b - p));\n}\n\n\nPoint rotate(const Point& p, double angle, const Point& base = Point(0, 0))\n{\n\tdouble c = cos(angle), s = sin(angle);\n\tPoint t = p - base;\n\treturn Point(t.real() * c - t.imag() * s + base.real(), t.real() * s + t.imag() * c + base.imag());\n}\n\n\nvector<Line> lines(int x, int y, int a, int r)\n{\n    double w = PI * 2 / 5;\n    double a1 = PI / 2 - w;\n    double a2 = w - a1;\n \n    double c1 = cos(a1), s1 = sin(a1);\n    double c2 = cos(a2), s2 = sin(a2);\n \n    double px[] = { 0, -c2, c1, -c1, c2, 0 };\n    double py[] = { 1, -s2, s1, s1, -s2, 1 };\n \n\tPoint p[6];\n    double ang = PI * a / 180;\n    for (int i = 0; i < 6; ++i)\n\t\tp[i] = (double)r * rotate(Point(px[i], py[i]), ang) + Point(x, y);\n\n    vector<Line> res;\n    for (int i = 0; i < 5; ++i)\n        res.push_back(Line(p[i], p[i + 1]));\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    const double INF = 1e20;\n \n    int n, s, g;\n    while (cin >> n >> s >> g, n)\n    {\n        --s, --g;\n \n        vector<Line> star[128];\n        for (int i = 0; i < n; ++i)\n        {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            star[i] = lines(x, y, a, r);\n        }\n \n \n        double e[128][128];\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = 0; j < n; ++j)\n            {\n\t\t\t\tif (i == j)\n\t\t\t\t{\n\t\t\t\t\te[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                e[i][j] = INF;\n                for (int k = 0; k < 5; ++k)\n                    for (int l = 0; l < 5; ++l)\n                        min_swap(e[i][j], dist_SS(star[i][k], star[j][l]));\n            }\n        }\n \n \n        double dis[128];\n        fill(dis, dis + n, INF);\n \n        typedef pair<double, int> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        dis[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty())\n        {\n            P tt = q.top(); q.pop();\n            int p = tt.second;\n            double c = tt.first;\n \n            if (p == g)\n                break;\n            else if (c > dis[p])\n                continue;\n \n            for (int i = 0; i < n; ++i)\n            {\n                double nc = c + e[p][i];\n                if (nc < dis[i])\n                {\n                    dis[i] = nc;\n                    q.push(P(nc, i));\n                }\n            }\n        }\n \n        cout.setf(ios::fixed);\n        cout.precision(15);\n        cout << dis[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef complex < double > P;\ntypedef pair < P, P >      L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l.fr, l.fr - l.sc) / norm( l.fr - l.sc);\n  return l.fr + t * ( l.fr - l.sc);\n}\nbool intersect( L a, P p){ //OK\n   return abs( a.fr - p) + abs( a.sc - p) - abs( a.fr - a.sc) < EPS;\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a.fr, a.sc, b.fr) * ccw( a.fr, a.sc, b.sc) <= 0 &&\n    ccw( b.fr, b.sc, a.fr) * ccw( b.fr, b.sc, a.sc) <= 0;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s.fr - p), abs( s.sc - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b.fr), distance( a, b.sc)),\n              min( distance( b, a.fr), distance( b, a.sc)));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\ndouble info[100][100];\nint n, m, l;\nL stars[100][5];\nint table[][5] = {{0,0,1,1,2},{2,3,3,4,4}};\nvoid add( double x, double y, double a, double r, int z){\n  G hosi(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[z][i] = L( hosi[table[0][i]], hosi[table[1][i]]);\n  }\n}\nint main(){ //vectorが重いかも\n  while(scanf(\"%d%d%d\", &n, &m, &l), n|m|l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      double x, y, a, r;\n      scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &r);\n      add( x, y, a, r, i);\n    }\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    for(int k = 0; k < n; k++ ){\n      for(int i = 0; i < n; i++ ){\n        for(int j = 0; j < n; j++ ){\n          info[i][j] = min( info[i][j], info[i][k] + info[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\", info[m][l]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nstruct Star {\n\tLine l[5];\n};\n\nint main() {\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\t--M, --L;\n\n\t\tvector<Star> v;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, a, r; cin >> x >> y >> a >> r;\n\t\t\tld s = pi/2+pi*a/180.0;\n\t\t\tPoint p[5];\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\tp[j] = Point(x+r*(ld)cos(s+j*2*pi/5), y+r*(ld)sin(s+j*2*pi/5));\n\t\t\t}\n\t\t\tStar star;\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\tstar.l[j] = Line(p[j], p[(j+2)%5]);\n\t\t\t}\n\t\t\tv.push_back(star);\n\t\t}\n\t\tld dist[100][100];\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tfor (int j = 0; j < v.size(); ++j) {\n\t\t\t\tld d = 1e9;\n\t\t\t\tfor (int a = 0; a < 5; ++a) {\n\t\t\t\t\tfor (int b = 0; b < 5; ++b) {\n\t\t\t\t\t\td = min(d, dist_ss(v[i].l[a], v[j].l[b]));\n\t\t\t\t\t\tLine &l1 = v[i].l[a], &l2 = v[i].l[b];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[i][j] = d;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", (double)dist[M][L]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\n#define PI 3.1415926535897932384\n\n\n// 主に以下の資料を参考に作成した。\n// - http://www.prefield.com/algorithm\n// - http://www.deqnotes.net/acmicpc/2d_geometry/\n// - https://github.com/infnty/acm/tree/master/lib/geometry\n// - サークルの先輩が作ったライブラリ\n\n/* 基本要素 */\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n\n\n/* 円 */\n\nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n\nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n\nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n\n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n\nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\n// 2円の交点\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\n// 点pから円aへの接線の接点\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ここでNaNも弾かれる\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n\n// 2円の共通接線。返される各直線に含まれる頂点は円との接点となる\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // 重複する接線を無視（重複していいならこの行不要）\n    }\n  }\n  return ls;\n}\n\n// 三角形の外心。点a,b,cは同一線上にあってはならない\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n\n// 点aと点bを通り、半径がrの円の中心を返す\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // 必要なら !LE(d,r) として円1つになる側へ丸める\n  D dN = sqrt(r*r - d*d);          // 必要なら max(r*r - d*d, 0) とする\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n\n// 点aと点bを通り、直線lに接する円の中心\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n\n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n\n// 点集合を含む最小の円の中心\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n\n\n/* 多角形 */\n\n// 頂点の順序（sortやmax_elementに必要）\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\n// 凸判定。縮退を認めないならccwの判定部分を != 1 とする\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n\n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\n// 凸多角形の内部判定　O(logn)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n\n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n\n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n\n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\n// 凸多角形の直径（最遠点対）\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n\n// 多角形の符号付面積\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\n\n// 多角形の幾何学的重心\nP centroid(const VP& ps) {\n  int n = ps.size();\n  D aSum = 0;\n  P c;\n  rep (i, n) {\n    D a = cross(ps[i], ps[(i+1) % n]);\n    aSum += a;\n    c += (ps[i] + ps[(i+1) % n]) * a;\n  }\n  return 1 / aSum / 3 * c;\n}\n\n// ボロノイ領域\nVP voronoiCell(P p, const VP& ps, const VP& outer) {\n  VP cl = outer;\n  rep (i, ps.size()) {\n    if (EQ(norm(ps[i]-p), 0)) continue;\n    P h = (p+ps[i])*0.5;\n    cl = convexCut(cl, h, h + (ps[i]-h)*P(0,1) );\n  }\n  return cl;\n}\n\n/* 幾何グラフ */\n\nstruct Edge {\n  int from, to;\n  D cost;\n  Edge(int from, int to, D cost) : from(from), to(to), cost(cost) {}\n};\nstruct Graph {\n  int n;\n  vector<vector<Edge> > edges;\n  Graph(int n) : n(n), edges(n) {}\n  void addEdge(Edge e) {\n    edges[e.from].push_back(e);\n    edges[e.to].push_back(Edge(e.to, e.from, e.cost));\n  }\n};\n\n// 線分アレンジメント（線分の位置関係からグラフを作成）\nGraph segmentArrangement(const vector<L>& segs, VP& ps) {\n  int n = segs.size();\n  rep (i, n) {\n    ps.push_back(segs[i].first);\n    ps.push_back(segs[i].second);\n    rep (j, i) {\n      if (isecSS(                 segs[i].first, segs[i].second, segs[j].first, segs[j].second))\n        ps.push_back(crosspointLL(segs[i].first, segs[i].second, segs[j].first, segs[j].second));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n  int m = ps.size();\n  Graph gr(m);\n  vector<pair<D, int> > list;\n  rep (i, n) {\n    list.clear();\n    rep (j, m) {\n      if (isecSP(segs[i].first, segs[i].second, ps[j]))\n        list.push_back(make_pair(norm(segs[i].first-ps[j]), j));\n    }\n    sort(list.begin(), list.end());\n    rep (j, list.size() - 1) {\n      int a = list[j  ].second;\n      int b = list[j+1].second;\n      gr.addEdge(Edge(a, b, abs(ps[a]-ps[b])));\n    }\n  }\n  return gr;\n}\n\n// 可視グラフ（点集合から見える位置へ辺を張ったグラフ）\nGraph visibilityGraph(const VP& ps, const vector<VP>& objs) {\n  int n = ps.size();\n  Graph gr(n);\n  rep (i,n) rep (j,i) {\n    P a = ps[i], b = ps[j];\n    if (!EQ(norm(a-b), 0)) rep (k, objs.size()) {\n      const VP& obj = objs[k];\n      int inStA = inConvex(a, obj);\n      int inStB = inConvex(b, obj);\n      if ((inStA ^ inStB) % 2 || inStA * inStB != 1 && inConvex((a+b)*0.5, obj) == 1) goto skip;\n      rep (l, obj.size()) {\n        P cur = obj[l];\n        P next = obj[(l + 1) % obj.size()];\n        if (isecSS(a, b, cur, next) && !isecSP(cur, next, a) && !isecSP(cur, next, b)) goto skip;\n      }\n    }\n    gr.addEdge( Edge(i, j, abs(a-b)) );\n    skip: {}\n  }\n  return gr;\n}\n\n\n/* その他 */\n\n// 重複する線分を併合する\nvector<L> mergeSegments(vector<L> segs) {\n  int n = segs.size();\n  rep (i,n) if (segs[i].second < segs[i].first) swap(segs[i].second, segs[i].first);\n\n  rep (i,n) rep (j,i) {\n    L &l1 = segs[i], &l2 = segs[j];\n    if (EQ(cross(l1.second-l1.first, l2.second-l2.first), 0)\n        && isecLP(l1.first, l1.second, l2.first)\n        && ccw   (l1.first, l1.second, l2.second) != 2\n        && ccw   (l2.first, l2.second, l1.second) != 2) {\n      segs[j] = L(min(l1.first, l2.first), max(l1.second, l2.second));\n      segs[i--] = segs[--n];\n      break;\n    }\n  }\n  segs.resize(n);\n  return segs;\n}\n\n\n// この辺にコードを載せるほどでもないが重要な定理とか図とか書いておくとよい気がします\n\n// 余弦定理\n// △ABC において、a = BC, b = CA, c = AB としたとき\n// a^2 = b^2 + c^2 ? 2bc cos ∠CAB\n\n// ヘロンの公式\n// 3辺の長さがa,b,cである三角形の面積T\n// T = sqrt{ s(s-a)(s-b)(s-c) }, s = (a+b+c)/2\n\n// ピックの定理\n// 多角形の頂点が全て格子点上にあり、内部に穴がないとき\n// S = i + b/2 - 1 (S:多角形の面積, i: 多角形の内部にある格子点の数, b: 辺上の格子点の数)\n\n\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n,M,L;\n\tdouble x,y,a,r;\n\twhile(cin>>n>>M>>L,n){\n\t    vector<VP> v(n);\n\t    vector<vector<double>> mt(n,vector<double>(n,INF));\n\t\trep(i,n){\n\t\t    cin>>x>>y>>a>>r;\n\t\t    VP p(5);\n\t\t    rep(j,5){\n\t\t        p[j]=P{r*cos((72*j+a+90.0)*PI/180)+x,r*sin((72*j+a+90.0)*PI/180)+y};\n\t\t    }\n\t\t    v[i]=p;\n\t\t    mt[i][i]=0;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t    range(j,i+1,n){\n\t\t        double dis=INF;\n\t\t        rep(k,5){\n\t\t            rep(l,5){\n\t\t                if(isecSS(v[i][k],v[i][(k+2)%5],v[j][l],v[j][(l+2)%5])){\n\t\t                    dis=0;\n\t\t                    l=5;\n\t\t                    k=5;\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        if(dis==INF){\n\t\t            rep(k,5){\n    \t\t            rep(l,5){\n    \t\t                double tmp=distSP(v[i][k],v[i][(k+2)%5],v[j][l]);\n    \t\t                if(dis>tmp){\n    \t\t                    dis=tmp;\n    \t\t                }\n    \t\t                tmp=distSP(v[j][l],v[j][(l+2)%5],v[i][k]);\n    \t\t                if(dis>tmp){\n    \t\t                    dis=tmp;\n    \t\t                }\n    \t\t            }\n    \t\t        }\n\t\t        }\n\t\t        if(abs(dis)<EPS){\n\t\t            dis=0;\n\t\t        }\n\t\t        mt[i][j]=mt[j][i]=dis;\n\t\t    }\n\t\t}\n\t\t\n\t\trep(k,n){\n\t\t    rep(i,n){\n\t\t        rep(j,n){\n\t\t            if(mt[i][j]>mt[i][k]+mt[k][j]){\n\t\t                mt[i][j]=mt[i][k]+mt[k][j];\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n\t\tcout<<setprecision(12)<<mt[M-1][L-1]<<endl;\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\ntypedef complex<double> PT;\ntypedef PT VC;\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b) / abs(l.fi-l.se));\n}\n\nvector<PT> intersec_line_line(LN a, LN b) {\n\tvector<PT> res;\n\tif(abs(cross_prod(a.fi-a.se, b.fi-b.se)) < EPS)\n\t\treturn res;\n\tif(abs(cross_prod(b.fi-a.fi, b.se-a.fi)) < EPS)\n\t\tswap(a.fi, a.se);\n\t\n\tVC va, vb, vc;\n\tdouble s, t;\n\tva = b.fi - a.fi;\n\tvb = b.se - a.fi;\n\tvc = a.se - a.fi;\n\ts = cross_prod(va, vc) / cross_prod(va, vb);\n\tt = cross_prod(vc, vb) / cross_prod(va, vb);\n\tres.push_back(a.fi + (t * va + s * vb) / (s+t));\n\treturn res;\n}\n\nbool on_seg(PT p, SG a) {\n\tVC b, c;\n\tb = a.fi - p;\n\tc = a.se - p;\n\treturn dot_prod(b,c) < EPS && abs(cross_prod(b,c)) < EPS;\n}\n\nvector<PT> intersec_seg_seg(SG a, SG b) {\n\tvector<PT> tmp, res;\n\ttmp = intersec_line_line(a,b);\n\tfor(int i = 0; i < tmp.size(); i++) {\n\t\tif(on_seg(tmp[i], a) && on_seg(tmp[i],b))\n\t\t\tres.push_back(tmp[i]);\n\t}\n\treturn res;\n}\n\n\n// テ、ツサツ・テ、ツクツ甘・ツケツセテ、ツスツ陛」ツδゥテ」ツつ、テ」ツδ姪」ツδゥテ」ツδェテ・ツ?凖ァツオツ?\n\ndouble dist_pts_seg(PT p, SG a) {\n\tdouble res;\n\tres = min(abs(a.fi-p), abs(a.se-p));\n\tif(dot_prod(a.se - a.fi, p - a.fi) > -EPS\n\t\t\t&& dot_prod(a.fi - a.se, p - a.se) > -EPS)\n\t\tres = min(res, dist_pts_line(p, a));\n\treturn res;\n}\n\ndouble dist_seg_seg(SG a, SG b) {\n\tdouble res;\n\tres = min(\n\t\t\tmin(dist_pts_seg(a.fi,b), dist_pts_seg(a.se,b)),\n\t\t\tmin(dist_pts_seg(b.fi,a), dist_pts_seg(b.se,a)) );\n\tif(intersec_seg_seg(a,b).size())\n\t\tres = 0;\n\treturn res;\n}\n\n/* //テ・ツケツセテ、ツスツ陛」ツδ?」ツつケテ」ツδ?\nint main() {\n\tSG a(PT(0,0),PT(0,2));\n\tSG b(PT(-1,1),PT(2,1));\n\tcout << dist_seg_seg(a,b) << endl;\n} // */\n\n//*\nint N, M, L;\nvector<vector<SG> > star;\ndouble edge[120][120];\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nvoid init() {\n\tstar.clear();\n\trep(i,120) {\n\t\trep(j,120)\n\t\t\tedge[i][j] = 1e9;\n\t\tedge[i][i] = 0;\n\t}\n}\n\nint main() {\n\twhile(cin >> N >> M >> L, N || M || L) {\n\t\tinit();\n\t\tM--; L--;\n\t\trep(i,N) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<PT> tmp;\n\t\t\tdouble theta = (a+90) / 180.0 * M_PI;\n\t\t\tdouble phi = 360.0 / 5.0 / 180.0 * M_PI;\n\t\t\trep(i,5) {\n\t\t\t\ttmp.push_back(polar((double)r, theta + phi * i) + PT(x,y));\n\t\t\t//\tcout << tmp[i] << endl;\n\t\t\t}\n\t\t\tvector<SG> push;\n\t\t\trep(i,5) {\n\t\t\t\tpush.push_back(SG(tmp[i],tmp[(i+2)%5]));\n\t\t\t}\n\t\t\tstar.push_back(push);\n\t\t}\n\n\t\trep(i,N) {\n\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\tdouble tmp = 1e9;\n\t\t\t\trep(k,5) {\n\t\t\t\t\trep(l, 5) {\n\t\t\t\t\t\ttmp = min(tmp, dist_seg_seg(star[i][k], star[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\trep(i,N) {\n\t\t\trep(j,N) {\n\t\t\t\trep(k,N) {\n\t\t\t\t\tedge[j][k] = min(edge[j][k], edge[j][i] + edge[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", edge[L][M]);\n\t}\n}\n// */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\tvoid make(){ cin>>x>>y;}\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n\tvoid make(){ s.make(); e.make();}\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> &p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> &s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> &g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nstruct star{\n\tpoint p[5];\n\tline l[5];\n\tvoid make(){\n\t    \tpoint pp;\n\t\tdouble a,r;\n\t\tpp.make();\n\t\tcin>>a>>r;\n\t\tfor(int i=0;i<5;i++){\n\t\t    \tdouble theta =   ( (a+90+72*i) /180.0) *M_PI  ;\n\t\t\tpoint add = point(r*cos(theta),r*sin(theta) );\n\t\t\tp[i] = pp + add;\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tl[i].s = p[i];\n\t\t\tl[i].e = p[(i+2)%5] ;\n\t\t}\n\t}\n\t\n};\ndouble distance(star s1,star s2){\n\tdouble res = 1e9;\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j = 0;j<5;j++){\n\t\t\tres = min(res,distance(s1.l[i],s2.l[j]) );\n\t\t}\n\t}\n\t/*for(int i=0;i<5;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t    \tpoint dis = s1.p[i] - s2.p[j];\n\t\t\tres = min(res,dis.abs() );\n\t\t}\n\t}*/\n\t\n\n\treturn res;\n}\n\ntypedef pair<double,int> mp;\nint main(){\n\twhile(1){\n\t\tint n,m,l;\n\t\tcin>>n>>m>>l;\n\t\tif(n==0)break;\n\t\tm--,l--;\n\t\tvector<star> s(n);\n\t\tvector<vector<double> > g(n,vector<double>  (n,0.0) );\n\t\tvector<bool> used(n,false);\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts[i].make();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t    g[i][j] = distance(s[i],s[j]);\n\t\t\t}\n\t\t}\n\t/*\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcout<<g[i][j]<<' ';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tpriority_queue<mp,vector<mp>,greater<mp> > q;\n\t\tq.push(mp(0.0,m) );\n\n\t\twhile(!q.empty()){\n\t\t\tmp now = q.top();\n\t\t\tq.pop();\n\t\t\tdouble nc = now.first;\n\t\t\tint nn = now.second;\n\t\t\tif(nn == l ) {\n\t\t\t    printf(\"%0.10lf\\n\",nc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(used[nn])continue;\n\t\t\tused[nn] = true;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!used[i]){\n\t\t\t\t\tq.push(mp(nc+g[nn][i],i) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define PI M_PI\n#define MAX_N 110\n#define INF 1e9\n\nclass Point{\npublic:\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nclass Segment{\npublic:\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nclass Star : public Point{\npublic:\n  double a,r;\n  vector<Segment> segs;\n  Star(){}\n  Star(Point p,double a,double r) : Point(p),a(a),r(r) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nPoint projection(const Segment &s,const Point &p){\n  Vector b = s.t-s.s;\n  double t = dot(p-s.s,b)/norm(b);\n  return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n  Point r = projection(s,p);\n  if(isIntersectSP(s,r)){ return abs(r-p); }\n  return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment a,const Segment b){\n  if(isIntersectSS(a,b)){ return 0; }\n  return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n             min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nistream &operator >> (istream &is,Star &s){\n  return is >> s.x >> s.y >> s.a >> s.r;\n}\n\ndouble toRad(double ang){ return ang*PI/180.0; }\n\nPoint rotate(const Point &bp,const Point &p,double th){\n  double x = p.x, y = p.y;\n  return Point(cos(th)*x-sin(th)*y+bp.x,sin(th)*x+cos(th)*y+bp.y);\n}\n\nvoid makeStar(vector<Star> &stars){\n  int N = stars.size();\n  for(int i = 0 ; i < N ; i++){\n    double x = stars[i].x, y = stars[i].y;\n    double r = stars[i].r, a = stars[i].a;\n    Point bp(x,y), p(x,y+r); p = p - bp;\n    p = rotate(bp,p,toRad(a));\n    vector<Point> ps(5);\n    for(int j = 0 ; j < 5 ; j++){\n      ps[j] = p;\n      p = p - bp;\n      p = rotate(bp,p,toRad(144));\n    }\n    stars[i].segs.resize(5);\n    for(int j = 0 ; j < 5 ; j++){\n      stars[i].segs[j] = Segment(ps[j],ps[(j+1)%5]);\n    }\n  }\n}\n\nint main(){\n  int N,M,L;\n  while(cin >> N >> M >> L, N){\n    vector<Star> stars(N);\n    M--; L--;\n    for(int i = 0 ; i < N ; i++){\n      cin >> stars[i];\n    }\n    makeStar(stars);\n    double d[MAX_N][MAX_N];\n    fill(d[0],d[0]+N*N,INF);\n    for(int i = 0 ; i < N ; i++){\n      d[i][i] = 0;\n      for(int j = i+1 ; j < N ; j++){\n        double dist = INF;\n        for(int k = 0 ; k < 5 ; k++){\n          for(int l = 0 ; l < 5 ; l++){\n            Segment s1 = stars[i].segs[k];\n            Segment s2 = stars[j].segs[l];\n            dist = min(dist,distanceSS(s1,s2));\n          }\n        }\n        d[i][j] = d[j][i] = dist;\n      }\n    }\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    printf(\"%.12f\\n\",d[M][L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectLL(const line& l, const line& m){\n    return abs(cross(l.second-l.first, m.second-m.first)) > eps || // non-parallel\n           abs(cross(l.second-l.first, m.first-l.first)) < eps;   // same line\n}\nbool intersectLS(const line& l, const line& s){\n    return cross(l.second-l.first, s.first-l.first)*       // s.first is left of l\n           cross(l.second-l.first, s.second-l.first) < eps; // s.second is right of l\n}\nbool intersectLP(const line& l, const point& p){\n    return abs(cross(l.second-p, l.first-p)) < eps;\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\nbool intersectSP(const line& s, const point& p){\n    return abs(s.first-p)+abs(s.second-p)-abs(s.second-s.first) < eps; // triangle inequality\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\npoint reflection(const line& l, const point& p){\n    return p+point((projection(l, p) - p).real()*2,(projection(l, p) - p).imag()*2);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\nlong double distanceLL(const line &l, const line &m){\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\nlong double distanceLS(const line &l, const line &s){\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\nlong double distanceSP(const line &s, const point& p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s.first - p), abs(s.second - p));\n}\nlong double distanceSS(const line &s, const line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\npoint intersection_l(const point& a1,const point& a2,const point& b1,const point& b2) {\n  const point& a=a2-a1,b=b2-b1;\n  return a1+a*cross(b, b1-a1)/cross(b, a);\n}\npoint intersection_l(const line& l,const line& m){\n    return intersection_l(l.first,l.second,m.first,m.second);\n}\n\nvoid solve(int n,int m,int l){\n    --m;\n    --l;\n\n    const long double pi=acosl(-1);\n    vector<line> ls;\n    rep(i,0,n){\n        long double x,y,a,r;\n        cin >> x >> y >> a >> r;\n        vector<point> ps;\n        a=a*pi/180;\n        rep(j,0,5){\n            ps.push_back(point(x,y)+point(0,r)*point(cosl(a+2*pi/5*j),sinl(a+2*pi/5*j)));\n        }\n        ls.push_back(line(ps[0],ps[2]));\n        ls.push_back(line(ps[0],ps[3]));\n        ls.push_back(line(ps[1],ps[3]));\n        ls.push_back(line(ps[1],ps[4]));\n        ls.push_back(line(ps[2],ps[4]));\n    }\n\n    long double dist[500];\n    fill_n((long double*)dist,500,inf);\n    priority_queue<pair<long double,int>,vector<pair<long double,int>>,greater<pair<long double,int>>> que;\n    rep(i,0,5){\n        dist[m*5+i]=0;\n        que.push(make_pair(0,m*5+i));\n    }\n    while(!que.empty()){\n        auto p=que.top();\n        que.pop();\n        if(p.first>dist[p.second]) continue;\n        rep(i,0,n*5){\n            auto d=distanceSS(ls[p.second],ls[i]);\n            if(p.first+d>=dist[i]) continue;\n            dist[i]=p.first+d;\n            que.push(make_pair(dist[i],i));\n        }\n    }\n\n    long double ans=inf;\n    rep(i,0,5) ans=min(ans,dist[l*5+i]);\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m,l;\n        cin >> n >> m >> l;\n        if(!n and !m and !l) break;\n        solve(n,m,l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\n// XY座標\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-6;\nconst double INF = 1e+12;\nconst double PI = acos(-1.0);\ntypedef complex<double> P;\n\n// 内積(dot product) a・b = |a||b|cosθ \ndouble dot(P a, P b){\n\treturn real( conj(a) * b );\n}\n\n// 外積(cross product) |a×b| = |a||b|sinθ\ndouble cross(P a, P b){\n\treturn imag( conj(a) * b );\n}\n\n// 度からラジアンに変換する.\ndouble to_rad(double deg){\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を a ラジアンだけ回転した点を返す.\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を angle ラジアンだけ回転した点を返す.\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tif( cross(b,c) >  EPS ) return CCW;\n\tif( cross(b,c) < -EPS ) return CW;\n\tif(dot(b, c) < -EPS )   return +2;\n\tif(dot(b, b) + EPS < dot(c, c) ) return -2;\n\treturn ON;\n}\n\n// 線分クラス\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){\n\t\ta = a_; b = b_;\n\t}\n\t\n\t// 点 p と線分の距離を返す.\n\tdouble distance(P p){\n\t\tif( dot(b-a,p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b,p-b) < EPS ) return abs(p-b);\n\t\treturn abs( cross(b-a,p-a) ) / abs(b-a) ;\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n\tbool is_intersection(const Segment& s){\n\t\treturn ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n\t\t         ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n\t}\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( is_intersection(s) ) return 0.0;\n\t\treturn min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n\t}\n\t// デバッグ出力\n\tvoid print(){\n\t\tprintf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n\t}\n};\n\nint main(){\n\t// n := 星の数, m := スタート, l := ゴール\n\tint n, m, l;\n\twhile( scanf(\"%d %d %d\", &n, &m, &l) , n || m || l ){\n\t\tm--; l--;\n\t\t// v[i] := i 番目の星 (5つの線分)\n\t\tvector< vector<Segment> > v;\n\t\t \n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r );\n\t\t\tdouble angle = to_rad( a + 90 );\n\t\t\tP p1( x + r*cos(angle) , y + r*sin(angle) );\n\t\t\tP p2 = rot2( P(x,y) , p1 , to_rad(72) );\n\t\t\tP p3 = rot2( P(x,y) , p2 , to_rad(72) );\n\t\t\tP p4 = rot2( P(x,y) , p3 , to_rad(72) );\n\t\t\tP p5 = rot2( P(x,y) , p4 , to_rad(72) );\n\t\t\t// vs := 5 つの線分\n\t\t\tvector<Segment> vs;\n\t\t\tvs.push_back( Segment(p1,p3) );\n\t\t\tvs.push_back( Segment(p3,p5) );\n\t\t\tvs.push_back( Segment(p5,p2) );\n\t\t\tvs.push_back( Segment(p2,p4) );\n\t\t\tvs.push_back( Segment(p4,p1) );\n\t\t\tv.push_back( vs );\n\t\t}\n\t\tdouble G[101][101];\n\t\tfor(int i=0 ; i < 101 ; i++ ){\n\t\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tdouble d = INF;\n\t\t\t\tfor(int k1 = 0 ; k1 < v[i].size() ; k1++ ){\n\t\t\t\t\tfor(int k2 = 0 ; k2 < v[j].size() ; k2++ ){\n\t\t\t\t\t\tSegment s1 = v[i][k1];\n\t\t\t\t\t\tSegment s2 = v[j][k2];\n\t\t\t\t\t\td = min( d , s1.distance(s2) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i][j] = G[j][i] = d;\n\t\t\t} \n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\tG[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8f\\n\", G[m][l] );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > DBL_EPSILON)\n\t\treturn 1;\n\tif (cross(b, c) < -DBL_EPSILON)\n\t\treturn -1;\n\tif (dot(b, c) < -DBL_EPSILON)\n\t\treturn 2;\n\tif (norm(b) < norm(c) - DBL_EPSILON)\n\t\treturn 2;\n\treturn 0;\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\ndouble DistanceSP(P a,P b,P c){\n\tif(dot(b-a,c-a)<DBL_EPSILON)return abs(c-a);\n\tif(dot(a-b,c-b)<DBL_EPSILON)return abs(c-b);\n\treturn abs(cross(b-a,c-a));\n}\ndouble DistaiceSS(P a,P b,P c,P d){\n\tif(isIntersectSS(a,b,c,d)){\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a,b,c),DistanceSP(a,b,d)),min(DistanceSP(c,d,a),DistanceSP(c,d,b)));\n}\n\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex(){\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta =M_PI/2+ 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta),\n\t\t\t\t\t\t\tp.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(a1,p1.vertex)foreach(a2,p1.vertex)foreach(b1,p2.vertex)foreach(b2,p2.vertex){\n\t\tm = min(m,DistaiceSS(*a1,*a2,*b1,*b2));\n\t}\n\treturn m;\n}\nint x, y, a, r;\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tfor (int k = 0; k < N; k++)\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tlinks[i][j] = min(links[i][j], links[i][k] + links[k][j]);\n\t\tcout << links[M-1][L-1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\nint ccw(const Point& _a, const Point& _b, const Point&  _c) {\n\tVector ba = _b - _a, ca = _c - _a;\n\tif (cross(ba, ca) > EPS) return +1; // ccw\n\tif (cross(ba, ca) < -EPS) return -1; // cw\n\tif (dot(ba, ca) < -EPS) return +2; // c-a-b\n\tif (abs(ba) + EPS < abs(ca)) return -2; // a-b-c\n\treturn 0; // a-c-b\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nbool is_cross(const Segment& _a, const Segment& _b) {\n\treturn (ccw(_a.s, _a.e, _b.s) * ccw(_a.s, _a.e, _b.e) <= 0\n\t\t\t&& ccw(_b.s, _b.e, _a.s) * ccw(_b.s, _b.e, _a.e) <= 0);\n}\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tif (is_cross(a, b)) return 0.0;\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 0.4 * PI));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[4] + c, vp[1] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[3] + c, vp[0] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e5;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_point_seg(a.vs[i].s, b.vs[j]));\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_point_seg(b.vs[i].s, a.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x, &y, &a, &r);\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\n////////////////////////////\n// 基本要素 (点, 線分)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-6;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\nDD dp[110][110] = { 0 };\n\nint main() {\n    int N, s, t;\n    while (cin >> N >> s >> t, N) {\n        --s, --t;\n        vector<vector<Point> > stars(N, vector<Point>(5));\n        for (int i = 0; i < N; ++i) {\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            for (int dir = 0; dir < 5; ++dir) {\n                double ang = torad(a + 90 + dir * 72);\n                stars[i][dir] = Point(x + r * cos(ang), y + r * sin(ang));\n            }\n        }\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                double dist = INF;\n                for (int di = 0; di < 5; ++di) {\n                    for (int dj = 0; dj < 5; ++dj) {\n                        Line si(stars[i][di], stars[i][(di+2)%5]);\n                        Line sj(stars[j][dj], stars[j][(dj+2)%5]);\n                        double tmp = distanceSS(si, sj);\n                        dist = min(dist, tmp);\n                    }\n                }\n                dp[i][j] = dist;\n            }\n        }\n        for (int k = 0; k < N; ++k)\n            for (int i = 0; i < N; ++i)\n                for (int j = 0; j < N; ++j)\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n        cout << fixed << setprecision(10) << dp[s][t] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  double x, y, a, r;\n  ST(){}\n  ST(double x, double y, double a, double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst double INF = 100000000.0;\nconst double EPS = 1e-10;\n\nint n, s, t;\nvector<ST> input;\ndouble dist[N][N];\n\ndouble dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec){\n  vector<Point> data;\n  Point o = Point(st.x, st.y);\n  Point p = rotate(Point(st.x, st.y + st.r), o, st.a);\n  for(int i=0;i<5;i++){\n    data.push_back(p);\n    p = rotate(p, o, 72.0);\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){data[i], data[i+1]});\n  }\n  vec.push_back((Segment){data[4], data[0]});\n}\n\ndouble calc_dist(ST pa, ST pb){\n  vector<Segment> a, b;\n  get_seg(pa, a);\n  get_seg(pb, b);\n  double res = INF;\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      res = min(res, getDistance(a[i], b[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\ndouble solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.20f\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#include <complex>\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転（角度）\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\n\nint main(void) {\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        m--,l--;\n        vector<vector<P> > v(n);\n        rep(i,n){ //それぞれの星の頂点をvにpushする\n            P p = inP();\n            double a,r;\n            cin >> a >> r;\n            P t(0,r);\n            rep(j,5){//a+j*72度回転\n                v[i].push_back(turn(t, a+j*72)+p);\n            }\n        }\n\n        double dp[100][100];\n        rep(i,100)rep(j,100) dp[i][j] = INF;\n        rep(i,100) dp[i][i] = 0;\n\n        rep(i,n)rep(a,5)rep(j,n)rep(b,5)if(i<j){\n            dp[i][j] = dp[j][i] = min(dp[i][j], distancePP(v[i][a],v[j][b]));\n        }\n        //rep(i,n)rep(j,n)if(i<j)cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        rep(k,n)rep(i,n)rep(j,n){\n            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n        }\n        cout << shosu(10) << dp[m][l] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(const P &a, const P &b) {\n    return !sgn(abs(a-b));\n}\n\n//R cross(P a, P b) { return imag(conj(a)*b); }\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    b -= a; c -= a;\n    int s = sgn(cross(b, c));\n    if (s) return s;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    P s2 = vec(s)*P(0, 1);\n     if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  double x, y, a, r;\n  ST(){}\n  ST(double x, double y, double a, double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst double INF = 100000000.0;\nconst double EPS = 1e-10;\n\nint n, s, t;\nvector<ST> input;\ndouble dist[N][N];\n\ndouble dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec){\n  vector<Point> data;\n  Point o = Point(st.x, st.y);\n  Point p = rotate(Point(st.x, st.y + st.r), o, st.a);\n  for(int i=0;i<5;i++){\n    data.push_back(p);\n    p = rotate(p, o, 72.0);\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){data[i], data[i+1]});\n  }\n  vec.push_back((Segment){data[4], data[0]});\n}\n\ndouble calc_dist(ST pa, ST pb){\n  vector<Segment> a, b;\n  get_seg(pa, a);\n  get_seg(pb, b);\n  double res = INF;\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      res = min(res, getDistance(a[i], b[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\ndouble solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.20f\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e8, pi = acos(-1.);\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\ninline double cross(const Point& a, const Point& b){\n    return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n    return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(const Point& a, const Point& b){\n        push_back(a); push_back(b);\n    }\n};\n\nPoint proj(const Line& l, const Point& p){\n    double t = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);\n    return l[0] + (l[1] - l[0]) * t;\n}\n\ninline bool interSP(const Line& s, const Point& p){\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps;\n}\n\ninline bool interSS(const Line& s, const Line& t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\ninline double distSP(const Line& s, const Point& p){\n    const Point r = proj(s, p);\n    return interSP(s, r)? abs(r - p): min(abs(s[0] - p), abs(s[1] - p));\n}\n\ninline double distSS(const Line& s, const Line& t){\n    return interSS(s, t)? 0: min({distSP(s, t[0]), distSP(s, t[1]), distSP(t, s[0]), distSP(t, s[1])});\n}\n\nint N, M, L;\n\ndouble solve(vector<vector<Line> >& pent){\n    vector<vector<double> > dist(N, vector<double>(N));\n    rep(i, N)rep(j, i){\n        dist[i][j] = inf;\n        for(auto s: pent[i])for(auto t: pent[j])chmin(dist[i][j], distSS(s, t));\n        dist[j][i] = dist[i][j];\n    }\n    vector<double> mem(N, inf); mem[M] = 0.;\n    priority_queue<pair<double, int> > q;\n    for(q.emplace(0, M); !q.empty();){\n        double d = -q.top().first; int v = q.top().second; q.pop();\n        if(mem[v] + eps < d)continue;\n        if(v == L)break;\n        rep(i, N)if(i != v && d + dist[v][i] < mem[i] + eps){\n            mem[i] = d + dist[v][i];\n            q.emplace(-mem[i], i);\n        }\n    }\n    return mem[L];\n}\n\nint main(){\n    while(cin >> N >> M >> L, N|M|L){\n        M--; L--;\n        vector<vector<Line> > pent(N);\n        rep(i, N){\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            vector<Point> v;\n            rep(j, 5)v.push_back(Point(x, y) + polar(1. * r, (a + 72 * j + 90) * pi / 180));\n            rep(j, 5)pent[i].emplace_back(v[j], v[(j + 2) % 5]);\n        }\n        cout << fixed << setprecision(20) << solve(pent) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return b * (a.dot(b) / b.sqlength()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn 0 + contains(a, b.p) + contains(a, b.p + b.d)\n\t\t+ contains(b, a.p) + contains(b, a.p + a.d) >= 2;\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) {\n\tP2 h = perpendicular_foot(a, (Line)b);\n\treturn contains(b, h) ? getDistance(h, a)\n\t\t: min(getDistance(b.p, a), getDistance(b.p + b.d, a));\n}\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b)\n{\n\treturn isCross(a, b) ? 0 : \n\tmin(min(getDistance(a, b.p), getDistance(a, b.p + b.d)), \n\tmin(getDistance(a.p, b), getDistance(a.p + a.d, b))); }\n\n// a から ta, bから tb だけ離れた点。ta=tb=r なら aとbに内接する円\ninline pair<pair<P2, P2>, pair<P2, P2>> get_distance_points(Line a, double ta, Line b, double tb)\n{\n\tassert(isCross(a, b));\n\n\tP2 va = a.d.orthogonal().direction() * ta;\n\tP2 vb = b.d.orthogonal().direction() * tb;\n\treturn make_pair(\n\t\tmake_pair(\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p - vb, b.d))\n\t\t), make_pair(\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p - vb, b.d))\n\t\t));\n}\n\n/// 円\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\n/// 長方形\nstruct Rect\n{\n\tP2 l, s;\n\tRect() : l(), s() { }\n\tRect(double x, double y, double w, double h) : l(x, y), s(w, h) { }\n\tRect(P2 location, P2 size) : l(location), s(size) { }\n\tbool Contains(const P2 &p) const { return p.x - l.x > -EPS && p.y - l.y > -EPS && p.x - (l.x + s.x) < EPS && p.y - (l.y + s.y) < EPS; } // 接してても真。\n};\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tfreopen(\"E:/My Documents/Downloads/judge/D/D1\", \"r\", stdin);\n\tfreopen(\"E:/My Documents/Downloads/judge/D/D1.out\", \"w\", stdout);\n\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n#define M_PI       3.14159265358979323846\n// Milky Way\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tif (!N) { break; }\n\n\t\tvevector<LineSeg> segs(N);\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(int, x, y, a, r);\n\t\t\tREP(i, 5)\n\t\t\t{\n\t\t\t\tint j = i + 1;\n\t\t\t\tdouble ai = (i * 144 + 90 + a) % 360 * M_PI / 180.0;\n\t\t\t\tdouble aj = (j * 144 + 90 + a) % 360 * M_PI / 180.0;\n\t\t\t\tP2 center(x, y);\n\t\t\t\tP2 pi = center + P2(cos(ai), sin(ai)).direction() * r;\n\t\t\t\tP2 pj = center + P2(cos(aj), sin(aj)).direction() * r;\n\t\t\t\tLineSeg s = LineSeg::From2Point(pi, pj);\n\t\t\t\tsegs[_].push_back(s);\n\n\t\t\t\t//WRITE(s.p, s.d);\n\t\t\t}\n\t\t}\n\n\t\tvevector<Path<double>> graph(N);\n\t\tREP(i, N) REP(j, N)\n\t\t{\n\t\t\tdouble d = INF;\n\t\t\tREP(k, 5) REP(l, 5) d = min(d, getDistance(segs[i][k], segs[j][l]));\n\t\t\tgraph[i].push_back({ i, j, d });\n\t\t}\n\n\t\tprintf(\"%.16f\\n\", dijkstra(graph, L - 1, -1).first[M - 1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\ndouble to_rad(int degree){\n\treturn degree*PI/180;\n}\n//点pを中心としてr(radian)回転            p(0,0)で原点を中心として回転\nP rotate(P t, P p, double r){\n    //double r=radians(angle);\n    double ta=cos(r)*(t.real()-p.real())-sin(r)*(t.imag()-p.imag())+p.real();\n    double tb=sin(r)*(t.real()-p.real())+cos(r)*(t.imag()-p.imag())+p.imag();\n    return P(ta , tb);\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが線分a,b上にあるかないか(2)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  if (( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n          ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS ))\n        return true;\n  return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2) ||\n             is_point_on_line(b1, b2, a1) || is_point_on_line(b1, b2, a2);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distance_ls(P a1, P a2, P b1, P b2) {\n  if (is_intersected_ls(a1, a2, b1, b2)) { return 0.0; }\n  return min( min(distance_ls_p(a1, a2, b1), distance_ls_p(a1, a2, b2)),\n                  min(distance_ls_p(b1, b2, a1), distance_ls_p(b1, b2, a2)) );\n}\n\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\nint main(){\n\tcout.precision(16);\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n|m|l){\n\t\tvvp stars(n,vp());\n\t\tREP(i,n){\n\t\t\tint x,y,a,r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tREP(j,5){\n\t\t\t\tint degree=(((j*2)%5)*72+a)%360;\n\t\t\t\tP p=rotate(P(x,y+r),P(x,y),to_rad(degree));\n\t\t\t\tstars[i].push_back(p);\n\t\t\t}\n\t\t}\n\t\tvvd dist(n,vd(n));\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tif(i==j){\n\t\t\t\t\tdist[i][j]=0;\n\t\t\t\t}else{\n\t\t\t\t\tdouble d=INT_MAX;\n\t\t\t\t\tREP(k,5){\n\t\t\t\t\t\tREP(l,5){\n\t\t\t\t\t\t\td=min(d,distance_ls(stars[i][k],stars[i][(k+1)%5],stars[j][l],stars[j][(l+1)%5]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdist[i][j]=d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(k,n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,n){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dist[m-1][l-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<algorithm>\n#include<iomanip>\n#define rep(X,Y) for(int X=0;(X)<(Y);++X)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\n\nconst double EPS=1e-8;\ntypedef complex<double> P;\nnamespace std{\n  bool operator< (const P &a, const P &b){\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n  }\n}\n\ndouble cross(const P &a,const P &b){\n  return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n  L(const P &a,const P &b){\n    pb(a); pb(b);\n  }\n};\n\nP proj(const L &l,const P &p){\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nint ccw(P a,P b,P c){\n  b-=a; c-=a;\n  if(cross(b,c)>EPS) return 1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c)<-EPS) return 2;\n  if(norm(b)<norm(c)+EPS) return -2;\n  return 0;\n}\n\ndouble intersectSS(const L &s,const L &t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\ndouble intersectSP(const L &s,const P &p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<EPS;\n}\n\ndouble distSP(const L &s, const P &p){\n  const P r=proj(s,p);\n  if(intersectSP(s,r))return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble distSS(const L &s,const L &t){\n  if(intersectSS(s,t)) return 0;\n  return min({distSP(s,t[0]),distSP(s,t[1]),distSP(t,s[0]),distSP(t,s[1])});\t \n}\n\nconst double M_PI=3.14159265358979;\n\nint main(){\n  int n,m,l;\n  while(cin>>n>>m>>l,n){\n    vector<vector<L>> st(n);\n    cout<<fixed<<setprecision(10);\n    int x,y,a,r;\n    rep(i,n){\n      cin>>x>>y>>a>>r;\n      double th=M_PI/2+1.*a*M_PI/180;\n      vector<P> ps(5);\n      rep(j,5){\n\tps[j]=P(x+r*cos(th),y+r*sin(th));\n\tth+=72.*M_PI/180;\n      }\n      rep(j,5){\n\tst[i].pb(L(ps[j],ps[(j+2)%5]));\n      }\n    }\n    \n    double d[n][n];\n    fill(d[0],d[0]+n*n,1e20);\n    rep(i,n)rep(j,n)rep(a,5)rep(b,5)\n      d[i][j]=min(d[i][j],distSS(st[i][a],st[j][b]));\n    //rep(i,n){rep(j,n)cout<<d[i][j]<<\" \";cout<<endl;}\n    rep(k,n)rep(i,n)rep(j,n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<d[m-1][l-1]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n  \nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( complex<double> a, complex<double> b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(complex<double> p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distancion(L,L); //線分:線分の距離(iteratorのdistanceと被るから留意)\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n  \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\n \ntypedef pair< double , int > Pi;\ndouble info[100][100];\nint n, m, l;\nL stars[100][5];\nint table[][5] = {{0,0,1,1,2},{2,3,3,4,4}};\nvoid add( int x, int y, int a, int r, const int z){\n  G hosi(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[z][i] = L( hosi[table[0][i]], hosi[table[1][i]]);\n  }\n}\ndouble dist( LLL a, LLL b){\n  double ret = INF;\n  for(int i = 0 ; i < a.size() ; i++ ){\n    for(int j = 0 ; j < b.size() ; j++ ){\n      ret = min( ret, distancion( a[i], b[i]));\n    }\n  }\n  return ret;\n}\ndouble WF(){\n  for(int k = 0; k < n; k++ ){\n    for(int i = 0; i < n; i++ ){\n      for(int j = 0; j < n; j++ ){\n        info[i][j] = min( info[i][j], info[i][k] + info[k][j]);\n      }\n    }\n  }\n  return info[m][l];\n}\n  \nint main(){\n  while(cin >> n >> m >> l, l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      int x, y, a, r;\n      cin >> x >> y >> a >> r;\n      add( x, y, a, r, i);\n    }\n  \n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    cout << fixed << setprecision(10) << WF() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n#define eps 1.0e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tdouble add(double a, double b){\n\t\tif(abs(a+b) < eps * (abs(a) + abs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, ope.x);\n\t\ttmp.y = add(y, ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, -ope.x);\n\t\ttmp.y = add(y, -ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn add(x*ope.y,  -y*ope.x);\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= 0;\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) < 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) < 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+1)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.8f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define pb push_back\n\n\n\nint N,M,LL;\ndouble d[128][128];\n\ntypedef complex<double> P;\nbool operator < (const P& a, const P& b){\n\treturn  real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n\tL(){}\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\ntypedef vector<P> G;\nstruct C {\n\tP p;double r;\n\tC(const P &p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c){\n\tb -= a;c -=a;\n\tif( cross(b,c)>0)return +1;\n\tif(cross(b,c) < 0) return -1;\n\tif(dot(b,c) < 0) return +2;\n\tif(norm(b) < norm(c)) return -2;\n}\n\nbool intersectLL(const L& l, const L& m){\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nbool intersectSS(const L&s, const L &t){\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nbool intersectSP(const L &s, const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\nP projection(const L &l, const P &p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P& p){\n\treturn abs(p - projection(l,p));\n}\n\ndouble distanceLL(const L &l, const L &m){\n\treturn intersectLL(l,m) ? 0 : distanceLP(l, m[0]);\n}\n\ndouble distanceSP(const L&s, const P &p){\n\tconst P r = projection(s,p);\n\tif(intersectSP(s,r)) return abs(r-p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble distanceSS(const L &s, const L &t){\n\tif(intersectSS(s,t)) return 0;\n\treturn min(min(distanceSP(s,t[0]), distanceSP(s,t[1])),min(distanceSP(t,s[0]), distanceSP(t,s[1])));\n}\n\ndouble tod(double r){\n\treturn M_PI * r / 180;\n}\n\nstruct star{\n\tP p[5];\n\tL l[5];\n\tstar(double x, double y, double a, double r){\n\t\tdouble n = 72;\n\t\ta+=90;\n\t\trep(i,5){\n\t\t\tp[i] = P(x+r*cos(tod(a+n*i)), y+r*sin(tod(a+n*i)));\n\t\t}\n\t\tl[0] = L(p[0],p[2]);\n\t\tl[1] = L(p[0],p[3]);\n\t\tl[2] = L(p[1],p[3]);\n\t\tl[3] = L(p[1],p[4]);\n\t\tl[4] = L(p[2],p[4]);\n\t}\n};\n\n\nvoid init(){\n\trep(i, 128)rep(j,128)d[i][j] = INF;\n\trep(i,128)d[i][i]=0;\n}\n\t\n\n\nint main() {\n\twhile(1){\n\t\tcin >> N >> M >> LL;\n\t\tif( N == 0) break;\n\t\tint x,y,a,r;\n\t\tM--;\n\t\tLL--;\n\t\tinit();\n\t\tvector<star> stars;\n\n\t\trep(i,N){\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.pb(star(x,y,a,r));\n\t\t}\n\n\t\t\n\t\trep(i,N)rep(j,N){\n\t\t\trep(k,5)rep(kk,5){\n\t\t\t\td[i][j] = min(d[i][j], distanceSS(stars[i].l[k], stars[j].l[kk]));\n\t\t\t\td[j][i] = d[i][j];\n\t\t\t}\n\t\t}\n\n\n\t\trep(k,N)rep(i,N)rep(j,N){\n\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\n\t//\trep(i,5)rep(j,5)cout << i << \"-\" << j << \"->\" << d[i][j] << endl;\n\t\tcout << fixed << setprecision(10);\n\t\tcout << d[M][LL] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nclass Star{\npublic:\n\tvector<L> star;\n\tvoid add(P p1,P p2){\n\t\tstar.push_back(L(p1,p2));\n\t}\n\t\n\tdouble dist(const Star &s){\n\t\tdouble res=INF;\n\t\tfor(int i=0;i<star.size();i++){\n\t\t\tfor(int j=0;j<s.star.size();j++){\n\t\t\t\tres=min(res,distanceSS(star[i],s.star[j]));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n};\n\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tvector<Star> stars(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,a,r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\t\n\t\t\tdouble theta=M_PI/180.0*a;\n\t\t\tdouble theta2=M_PI/180.0*72.0;\n\t\t\t\n\t\t\tvector<P> p(5);\n\t\t\t\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tp[j]=P(0,r)*polar(1.0,theta+j*theta2)+P(x,y);\n\t\t\t\t//cout<<p[j]<<endl;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tstars[i].add(p[(2*j)%5],p[(2+2*j)%5]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<double> > dist(n,vector<double>(n,INF));\n\t\tfor(int i=0;i<n;i++) dist[i][i]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++) dist[i][j]=dist[j][i]=stars[i].dist(stars[j]);\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.10f\\n\",dist[m-1][n-1]);\n\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\n////////////////////////////\n// 基本要素 (点, 線分)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\nDD dp[110][110] = { 0 };\n\nint main() {\n    int N, s, t;\n    while (cin >> N >> s >> t, N) {\n        --s, --t;\n        vector<vector<Point> > stars(N, vector<Point>(5));\n        for (int i = 0; i < N; ++i) {\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            for (int dir = 0; dir < 5; ++dir) {\n                double ang = torad(a + 90 + dir * 72);\n                stars[i][dir] = Point(x + r * cos(ang), y + r * sin(ang));\n            }\n        }\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                double dist = INF;\n                for (int di = 0; di < 5; ++di) {\n                    for (int dj = 0; dj < 5; ++dj) {\n                        Line si(stars[i][di], stars[i][(di+2)%5]);\n                        Line sj(stars[j][dj], stars[j][(dj+2)%5]);\n                        double tmp = distanceSS(si, sj);\n                        dist = min(dist, tmp);\n                    }\n                }\n                dp[i][j] = dist;\n            }\n        }\n        for (int k = 0; k < N; ++k)\n            for (int i = 0; i < N; ++i)\n                for (int j = 0; j < N; ++j)\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n        cout << fixed << setprecision(10) << dp[s][t] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  double x, y, a, r;\n  ST(){}\n  ST(double x, double y, double a, double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst double INF = 100000000.0;\nconst double EPS = 1e-10;\n\nint n, s, t;\nvector<ST> input;\ndouble dist[N][N];\n\ndouble dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec, vector<Point>& vec2){\n  Point o = Point(st.x, st.y);\n  Point p = rotate(Point(st.x, st.y + st.r), o, st.a);\n  for(int i=0;i<5;i++){\n    vec2.push_back(p);\n    p = rotate(p, o, 72.0);\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){vec2[i], vec2[i+1]});\n  }\n  vec.push_back((Segment){vec2[4], vec2[0]});\n}\n\ndouble calc_dist(ST pa, ST pb){\n  vector<Segment> a1, b1;\n  vector<Point> a2, b2;\n  get_seg(pa, a1, a2);\n  get_seg(pb, b1, b2);\n  double res = INF;\n  for(int i=0;i<a1.size();i++){\n    for(int j=0;j<b1.size();j++){\n      res = min(res, getDistance(a1[i], b1[j]));\n    }\n  }\n  for(int i=0;i<a2.size();i++){\n    for(int j=0;j<b2.size();j++){\n      res = min(res, abs(a2[i] - b2[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\ndouble solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.15f\\n\", (double)solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint N,M,l;\n\twhile(cin>>N>>M>>l,N+M+l){\n\t\tvector<G>in(N);\n\t\trep(i,N){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tP p(a,b);\n\t\t\tint r[]={0,144,288,72,216,0};\n\t\t\trep(j,6)in[i].pb(p+turn(P(0,d),r[j]+c));\n\t\t\t//rep(j,6)cout<<in[i][j].real()<<\" \"<<in[i][j].imag()<<endl;\n\t\t}\n\t\tvector<vector<double> >cost(N,vector<double>(N));\n\t\trep(i,N)rep(j,N){\n\t\t\tdouble mi=inf;\n\t\t\trep(q,5)rep(w,5){\n\t\t\t\tL l1(in[i][q],in[i][q+1]);\n\t\t\t\tL l2(in[j][w],in[j][w+1]);\n\t\t\t\tdouble dd=distanceSS(l1,l2);\n\t\t\t\t//if(intersectLL(l1,l2))cout<<\"YES\"<<endl;\n\t\t\t\t//else cout<<\"NO\"<<endl;\n\t\t\t\tmi=min(mi,dd);\n\t\t\t}\n\t\t\tcost[i][j]=mi;\n\t\t}\n\t\trep(k,N)rep(i,N)rep(j,N)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\tprintf(\"%.20f\\n\",cost[--M][--l]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nconstexpr double INF = numeric_limits<double>::max();\n\nconstexpr double EPS = 1e-8;\n\ndouble sq (const double v) { return v * v; }\n\nstruct Vec {\n    double x, y;\n    Vec () {}\n    ~Vec (){ }\n\n    Vec (double x_, double y_): x(x_), y(y_) {}\n\n    Vec operator + (const Vec& o) const { return Vec(x + o.x, y + o.y); }\n    Vec operator - (const Vec& o) const { return Vec(x - o.x, y - o.y); }\n};\n\ndouble inner_prod(const Vec p1, const Vec p2) { return p1.x * p2.x + p1.y * p2.y; }\n\nstruct line {\n    Vec p1, p2;\n\n    line (Vec p1_, Vec p2_): p1(p1_), p2(p2_) {}\n};\n\nstruct star {\n    double x, y, a, r;\n    star () {}\n    ~star () {}\n\n    star (double x_, double y_, double a_, double r_): x(x_), y(y_), a(a_), r(r_) {}\n\n    vector<Vec> get_vertices () {\n        vector<Vec> ret;\n\n        for (int j = 0; j < 5; ++j) {\n            const double rad = a + 72*j;\n\n            const double ret_x = x - r * sin(M_PI * rad / 180);\n            const double ret_y = y + r * cos(M_PI * rad / 180);\n\n            ret.emplace_back(ret_x, ret_y);\n        }\n\n        return ret;\n    }\n\n    vector<line> get_lines () {\n        vector<line> ret;\n\n        auto vs = get_vertices();\n        assert(vs.size() == 5);\n        for (int j = 0; j < 5; ++j) ret.emplace_back(vs[j], vs[(j+2)%5]);\n\n        return ret;\n    }\n};\n\ndouble dist_ps (const Vec p, const line l) {\n\n    if (inner_prod(p - l.p1, l.p2 - l.p1) <= 0 || inner_prod(p - l.p2, l.p1 - l.p2) <= 0) {\n        double d1 = sq(p.x - l.p1.x) + sq(p.y - l.p1.y);\n        double d2 = sq(p.x - l.p2.x) + sq(p.y - l.p2.y);\n\n        return min(d1, d2);\n    }\n\n    if (abs(l.p1.x * l.p2.y - l.p2.x * l.p1.y) < EPS) {\n        const double a = l.p1.x, b = l.p1.y;\n        return sq(a * p.x + b * p.y) / (a * a + b * b);\n    }\n\n    const double a = (l.p1.y - l.p2.y) / (l.p1.x * l.p2.y - l.p2.x * l.p1.y);\n    const double b = (l.p1.x - l.p2.x) / (l.p1.y * l.p2.x - l.p2.y * l.p1.x);\n    return sq(a * p.x + b * p.y + 1) / (a * a + b * b);\n}\n\ndouble dist2lines(const line l1, const line l2) {\n    double ans = numeric_limits<double>::max();\n    ans = min(ans, dist_ps(l1.p1, l2));\n    ans = min(ans, dist_ps(l1.p2, l2));\n    ans = min(ans, dist_ps(l2.p1, l1));\n    ans = min(ans, dist_ps(l2.p2, l1));\n    return ans;\n}\n\n// --------------------------------------------------\n\nstruct state {\n    int pos; double dist;\n    state (int pos_, double dist_): pos(pos_), dist(dist_) {}\n\n    bool operator < (const state& o) const {\n        return dist > o.dist;\n    }\n};\n\n// --------------------------------------------------\n\nint N, M, L;\ndouble x[100], y[100], a[100], r[100];\n\ndouble graph[100][100];\n\ndouble solve() {\n    for (int j = 0; j < N; ++j) fill(graph[j], graph[j]+N, INF);\n    for (int j = 0; j < N; ++j) graph[j][j] = 0;\n\n    vector<star> stars;\n    for (int j = 0; j < N; ++j) stars.emplace_back(x[j], y[j], a[j], r[j]);\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            star s1 = stars[j], s2 = stars[k];\n\n            vector<line> ls1 = s1.get_lines();\n            vector<line> ls2 = s2.get_lines();\n\n            for (auto& e: ls1) {\n                for (auto& f: ls2) {\n                    graph[j][k] = graph[k][j] = min(graph[j][k], sqrt(dist2lines(e, f)));\n                }\n            }\n        }\n    }\n\n    double min_dist[100];\n    fill(min_dist, min_dist+N, INF);\n    min_dist[M] = 0;\n\n    priority_queue<state> pq;\n    pq.emplace(M, 0);\n\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n\n        if (st.dist > min_dist[st.pos]) { continue; }\n\n        for (int j = 0; j < N; ++j) {\n            if (j == st.pos) continue;\n\n            if (min_dist[j] > st.dist + graph[st.pos][j]) {\n                min_dist[j] = st.dist + graph[st.pos][j];\n\n                pq.emplace(j, min_dist[j]);\n            }\n        }\n    }\n\n    return min_dist[L];\n}\n\nint main() {\n    line l1 = {{5, 0}, {15, 0}};\n    Vec p1 = {5, 0};\n\n    while (true) {\n        cin >> N >> M >> L;\n        if (N == 0 && M == 0 && L == 0) break;\n\n        --M; --L;\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j] >> a[j] >> r[j];\n        }\n\n        printf(\"%.12f\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n//for vector\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline D seg_seg_dis(L a,L b){\n  D res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nD g[111][111];\nL stars[111][5];\nP v[5],c,p;\nint n,m,l,x,y,a,r;\n\nint main(){\n  while(scanf(\"%d%d%d\",&n,&m,&l), n){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      c = P(x,y), p = P(0,r);\n      for(int j=0;j<5;j++)v[j] = c+rotate(p,PI*(a+j*72)/180);\n      for(int j=0;j<5;j++)stars[i][j] = L(v[j],v[(j+2)%5]);\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : stars[i]){\n\t  for(L b : stars[j]){\n\t    if(is_cp(a,b)){\n\t      dis = 0;\n\t      break;\n\t    }else dis = min(dis, seg_seg_dis(a,b));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n      g[i][i] = 0;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    printf(\"%.9lf\\n\",g[m-1][l-1]);\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconstexpr double PI = 3.141592653589;\n\ndouble deg2rad(double deg) {\n    return (PI / 180) * deg;\n}\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double a, double b): x(a), y(b) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n};\n\ndouble abs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble fabs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble dot(point a, point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(point a, point b) { return a.x*b.y - a.y*b.x; }\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\nbool has_intersect(line s, line t) {\n    double csa = cross(s.b - s.a, t.a - s.a);\n    double csb = cross(s.b - s.a, t.b - s.a);\n    double cta = cross(t.b - t.a, s.a - t.a);\n    double ctb = cross(t.b - t.a, s.b - t.a);\n\n    return csa * csb < 0 && cta * ctb < 0;\n}\n\npoint intersect(line s, line t) {\n    assert(has_intersect(s, t));\n\n    double c1 = fabs(cross(t.b - t.a, s.a - t.a));\n    double c2 = fabs(cross(t.b - t.a, s.b - t.a));\n\n    return s.a + (s.b - s.a) * (c1 / (c1 + c2));\n}\n\ndouble dist_line_point(line s, point p) {\n    if (dot(s.b - s.a, p - s.a) >= 0 && dot(s.a - s.b, p - s.b) >= 0)\n        return fabs(cross(s.b - s.a, p - s.a)) / abs(s.b - s.a);\n    return min(fabs(p - s.a), fabs(p - s.b));\n}\n\ndouble dist_lines(line s, line t) {\n    if (has_intersect(s, t)) return 0;\n\n    double d1 = dist_line_point(s, t.a);\n    double d2 = dist_line_point(s, t.b);\n    double d3 = dist_line_point(t, s.a);\n    double d4 = dist_line_point(t, s.b);\n\n    return min(min(d1, d2), min(d3, d4));\n}\n\nstruct star {\n    vector<line> ls;\n    star() {}\n};\n\nstar make_star(double cx, double cy, double deg, double r) {\n    point c(cx, cy);\n\n    point a(-sin(deg2rad(deg)) * r,     cos(deg2rad(deg)) * r);\n    point b(-sin(deg2rad(deg+144)) * r, cos(deg2rad(deg+144)) * r);\n\n    star ret;\n\n    for (int i = 0; i < 5; ++i) {\n        ret.ls.emplace_back(c + a, c + b);\n\n        a = point(cos(deg2rad(72)) * a.x - sin(deg2rad(72)) * a.y,\n                  sin(deg2rad(72)) * a.x + cos(deg2rad(72)) * a.y);\n        b = point(cos(deg2rad(72)) * b.x - sin(deg2rad(72)) * b.y,\n                  sin(deg2rad(72)) * b.x + cos(deg2rad(72)) * b.y);\n    }\n\n    return ret;\n}\n\ndouble dist_stars(star s, star t) {\n    double ret = 1e250;\n    for (int i = 0; i < 5; ++i)\n        for (int j = 0; j < 5; ++j)\n            ret = min(ret, dist_lines(s.ls[i], t.ls[j]));\n\n    return ret;\n}\n\nint N, M, L;\nvector<star> S;\n\ndouble solve() {\n    vector<vector<double>> dist(N, vector<double>(N, 1e250));\n    for (int i = 0; i < N; ++i) {\n        dist[i][i] = 0;\n        for (int j = i+1; j < N; ++j) {\n            double d = dist_stars(S[i], S[j]);\n            dist[i][j] = dist[j][i] = d;\n        }\n    }\n\n    for (int k = 0; k < N; ++k)\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < N; ++j)\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    return dist[M][L];\n}\n\nint main() {\n    cout << fixed << setprecision(20);\n    while (true) {\n        cin >> N >> M >> L;\n        if (N == 0 && M == 0 && L == 0) break;\n\n        --M; --L;\n        S.resize(N);\n        for (int i = 0; i < N; ++i) {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            S[i] = make_star(x, y, a, r);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n \nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( complex<double> a, complex<double> b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(complex<double> p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distancion(L,L); //線分:線分の距離(iteratorのdistanceと被るから留意)\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\n\ntypedef pair< double , int > Pi;\nbool used[100];\ndouble info[100][100];\nint n, m, l;\nL stars[100][5];\n\nvoid add( int x, int y, int a, int r, const int z){\n  G hosi(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[z][i] = L( hosi[i * 2 % 5], hosi[(i + 1) * 2 % 5]);\n  }\n}\ndouble dist( LLL a, LLL b){\n  double ret = INF;\n  for(int i = 0 ; i < a.size() ; i++ ){\n    for(int j = 0 ; j < b.size() ; j++ ){\n      ret = min( ret, distancion( a[i], b[i]));\n    }\n  }\n  return ret;\n}\ndouble Dijkstra(){\n  priority_queue< Pi , vector< Pi > , greater< Pi > > que;\n  fill_n( used, 100, false);\n  que.push( Pi( 0.0, m));\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.sc == l) return p.fr;\n    if(used[p.sc]++) continue;\n    for(int i = 0 ; i < n ; i++ )\n      que.push( Pi( info[p.sc][i] + p.fr, i));\n  }\n}\n \nint main(){\n  while(cin >> n >> m >> l, l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      int x, y, a, r;\n      cin >> x >> y >> a >> r;\n      add( x, y, a, r, i);\n    }\n \n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    cout << fixed << setprecision(10) << Dijkstra() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\ntypedef complex<double> Point;\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\ntypedef Line Segment;\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tint sign=Signum(Cross(d1,d2));\n\t\n\tif(sign)\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nPoint Proj(Point a,Point b)\n{\n    return b*Dot(a,b)/norm(b);\n}\n\nPoint Perf(Line l,Point p)\n{\n\tPoint a(p-l.pos);\n    return l.pos+Proj(a,l.dir);\n}\n\nbool IntersectLS(Line l,Segment s)\n{\n\tPoint a=l.pos;\n\tPoint b=l.pos+l.dir;\n\tPoint c=s.pos;\n\tPoint d=s.pos+s.dir;\n\treturn CCW(a,b,c)*CCW(a,b,d)<0;\n}\n\nbool IntersectSS(Segment s1,Segment s2)\n{\n\treturn IntersectLS(s1,s2) && IntersectLS(s2,s1);\n}\n\ndouble DistLP(Line l,Point p)\n{\n\treturn abs(Perf(l,p)-p);\n}\n\ndouble DistSP(Segment s,Point p)\n{\n\tPoint a=s.pos+Proj(p-s.pos,s.dir);\n\tint ccw=CCW(s.pos,s.pos+s.dir,a);\n\tif(ccw==-2)\n\t\treturn abs(p-s.pos);\n\tif(ccw==2)\n\t\treturn abs(p-(s.pos+s.dir));\n\treturn DistLP(s,p);\n}\n\ndouble DistSS(Segment s1,Segment s2)\n{\n\tif(IntersectSS(s1,s2))\n\t\treturn 0;\n\tdouble a=DistSP(s1,s2.pos);\n\tdouble b=DistSP(s1,s2.pos+s2.dir);\n\tdouble c=DistSP(s2,s1.pos);\n\tdouble d=DistSP(s2,s1.pos+s1.dir);\n\treturn min(min(a,b),min(c,d));\n}\n\nint main()\n{\n\tfor(int n,src,dst;cin>>n>>src>>dst,n|src|dst;){\n\t\tvi xs(n),ys(n),as(n),rs(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i]>>as[i]>>rs[i];\n\t\t\n\t\tvector<vector<Point> > ps(n,vector<Point>(5));\n\t\trep(i,n) rep(j,5)\n\t\t\tps[i][j]=Point(xs[i],ys[i])+polar(1.0,(as[i]+72*j)*PI/180)*Point(0,rs[i]);\n\t\t\n\t\tconst double INFTY=1e9;\n\t\tvvd dist(n,vd(n,INFTY));\n\t\trep(i,n) rep(j,n) rep(k,5) rep(l,5){\n\t\t\tint idx[]={0,2,4,1,3,0};\n\t\t\tSegment a(ps[i][idx[k]],ps[i][idx[k+1]]-ps[i][idx[k]]);\n\t\t\tSegment b(ps[j][idx[l]],ps[j][idx[l+1]]-ps[j][idx[l]]);\n\t\t\tdist[i][j]=min(dist[i][j],DistSS(a,b));\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\n\t\tprintf(\"%.20f\\n\",dist[src-1][dst-1]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\nint N,M,L;\n\nint main()\n{\n\tP pt[101][5];\n    while(cin>>N>>M>>L,(N||M||L)){\n        for (int i = 0; i < N; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n   \n\t\tint f1[]={0,2,4,1,3,0};\n\t\tdouble dp[100][100];\n        for(int i = 0; i < N; i++) for (int j = 0; j < N; j++){\n\t\t\tdp[i][j] = 1e100;\n\t\t\tfor (int a = 0; a < 5; a++) for(int b = 0; b < 5; b++){\n\t\t\t\tS s(pt[i][f1[a]], pt[i][f1[a+1]]);\n\t\t\t\tS t(pt[j][f1[a]], pt[j][f1[a+1]]);\n                dp[i][j] = min(dp[i][j],dist(s,t));\n\t\t\t}\n\t\t}\n   \n\t\t for (int k = 0; k < N; k++)\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n   \n        printf(\"%.15lf\\n\",dp[M - 1][L - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// input\ntemplate<typename T>\nvoid input(T& a) { cin >> a; }\ntemplate<typename T,typename... Ts>\nvoid input(T& a,Ts&... ts) {\n    input<T>(a);\n    input<T>(ts...);\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Input parallel\ntemplate<typename T>\nvoid input_at(size_t idx, T& a) {\n    cin >> a[idx];\n}\ntemplate<typename T, typename... Ts>\nvoid input_at(size_t idx, T& a, Ts&... ts) {\n    input_at<T>(idx, a);\n    input_at<T>(idx, ts...);\n}\ntemplate<typename T>\nvoid input_parallel(T& a) {\n    for (size_t idx = 0; idx < (size_t)a.size(); ++idx) {\n        input_at<T>(idx, a);\n    }\n}\ntemplate<typename T, typename...Ts>\nvoid input_parallel(T& a, Ts&... ts) {\n    for (size_t idx = 0; idx < (size_t)a.size(); ++idx) {\n        input_at<Ts...>(idx, a, ts...);\n    }\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\ntemplate<typename T>\nvoid warshall_floyd(MatrixGraph<T> &g) {\n    const auto INF = numeric_limits<T>::max();\n    for(int k = 0; k < g.size(); k++) {\n        for(int i = 0; i < g.size(); i++) {\n            for(int j = 0; j < g.size(); j++) {\n                if(g[i][k] == INF || g[k][j] == INF) continue;\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n            }\n        }\n    }\n}\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> LS;\n\n#define INF 1000000000\n#define EPS 1e-10\n\ndouble cross(const Point &a, const Point &b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nint is_intersected_ls(\n        const Point &a1, const Point &a2,\n        const Point &b1, const Point &b2)\n{\n    return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS &&\n           cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS;\n}\n\nint is_parallel(\n        const Point &a1, const Point &a2,\n        const Point &b1, const Point &b2)\n{\n    return abs(cross(a1-a2, b1-b2)) < EPS;\n}\n\ndouble distance_l_p(const LS &ls, const Point &c) {\n    Point a = ls.fs, b = ls.sc;\n    if (dot(b-a, c-a) < EPS) return abs(c-a);\n    if (dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble ls_distance(const LS &a, const LS &b) {\n    bool parallel = is_parallel(a.fs, a.sc, b.fs, b.sc);\n    bool intersect = is_intersected_ls(a.fs, a.sc, b.fs, b.sc);\n\n    if (!parallel && intersect) return 0;\n\n    return min({distance_l_p(a, b.fs),\n                distance_l_p(a, b.sc),\n                distance_l_p(b, a.fs),\n                distance_l_p(b, a.sc)});\n}\n\nint main()\n{\n    while (true) {\n        int N, M, L;\n        input(N, M, L);\n        if (N == 0) {\n            break;\n        }\n        vector<double> x(N), y(N), a(N), r(N);\n        for (int i = 0; i < N; ++i) {\n            input(x[i], y[i], a[i], r[i]);\n        }\n\n        vector<array<Point,5>> v(N);\n\n        for (int i = 0; i < N; ++i) {\n            for (int k = 0; k < 5; ++k) {\n                double theta = 2*M_PI*(90. + a[i] + 72. * k)/360.;\n                v[i][k] = Point(x[i], y[i]) + std::polar(r[i], theta);\n            }\n        }\n\n\n        auto dist = make_v<double>(N, N);\n        fill_all(dist, numeric_limits<double>::max());\n        for (int i = 0; i < N; ++i) {\n            dist[i][i] = 0;\n        }\n\n        for (int i = 0; i < N; ++i) {\n            for (int k = 0; k < 5; ++k) {\n                LS l1 = {v[i][k], v[i][(k+2)%5]};\n\n                for (int j = i+1; j < N; ++j) {\n                    for (int l = 0; l < 5; ++l) {\n                        LS l2 = {v[j][l], v[j][(l+2)%5]};\n\n                        chmin(dist[i][j], ls_distance(l1, l2));\n                        chmin(dist[j][i], ls_distance(l1, l2));\n\n                    }\n                }\n            }\n        }\n\n        warshall_floyd(dist);\n\n        printf(\"%.8lf\\n\", dist[M-1][L-1]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\n// XY座標\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-6;\nconst double INF = 1e+12;\nconst double PI = acos(-1.0);\ntypedef complex<double> P;\n\n// 内積(dot product) a・b = |a||b|cosθ \ndouble dot(P a, P b){\n\treturn real( conj(a) * b );\n}\n\n// 外積(cross product) |a×b| = |a||b|sinθ\ndouble cross(P a, P b){\n\treturn imag( conj(a) * b );\n}\n\n// 度からラジアンに変換する.\ndouble to_rad(double deg){\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を a ラジアンだけ回転した点を返す.\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を angle ラジアンだけ回転した点を返す.\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tif( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n\tif( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n\tif(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n\tif(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n\treturn ON;\n}\n\n// 線分クラス\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){\n\t\ta = a_; b = b_;\n\t}\n\t\n\t// 点 p と線分の距離を返す.\n\tdouble distance(P p){\n\t\tif( dot(b-a,p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b,p-b) < EPS ) return abs(p-b);\n\t\treturn abs( cross(b-a,p-a) ) / abs(b-a) ;\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n\tbool is_intersection(const Segment& s){\n\t\treturn ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n\t\t         ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n\t}\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( is_intersection(s) ) return 0.0;\n\t\treturn min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n\t}\n\t// デバッグ出力\n\tvoid print(){\n\t\tprintf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n\t}\n};\n\nint main(){\n\t// n := 星の数, m := スタート, l := ゴール\n\tint n, m, l;\n\twhile( scanf(\"%d %d %d\", &n, &m, &l) , n || m || l ){\n\t\tm--; l--;\n\t\t// v[i] := i 番目の星 (5つの線分)\n\t\tvector< vector<Segment> > v;\n\t\t \n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r );\n\t\t\tdouble angle = to_rad( a + 90 );\n\t\t\tP p1( x + r*cos(angle) , y + r*sin(angle) );\n\t\t\tP p2 = rot2( P(x,y) , p1 , to_rad(72) );\n\t\t\tP p3 = rot2( P(x,y) , p2 , to_rad(72) );\n\t\t\tP p4 = rot2( P(x,y) , p3 , to_rad(72) );\n\t\t\tP p5 = rot2( P(x,y) , p4 , to_rad(72) );\n\t\t\t// vs := 5 つの線分\n\t\t\tvector<Segment> vs;\n\t\t\tvs.push_back( Segment(p1,p3) );\n\t\t\tvs.push_back( Segment(p3,p5) );\n\t\t\tvs.push_back( Segment(p5,p2) );\n\t\t\tvs.push_back( Segment(p2,p4) );\n\t\t\tvs.push_back( Segment(p4,p1) );\n\t\t\tv.push_back( vs );\n\t\t}\n\t\tdouble G[101][101];\n\t\tfor(int i=0 ; i < 101 ; i++ ){\n\t\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tdouble d = INF;\n\t\t\t\tfor(int k1 = 0 ; k1 < v[i].size() ; k1++ ){\n\t\t\t\t\tfor(int k2 = 0 ; k2 < v[j].size() ; k2++ ){\n\t\t\t\t\t\tSegment s1 = v[i][k1];\n\t\t\t\t\t\tSegment s2 = v[j][k2];\n\t\t\t\t\t\td = min( d , s1.distance(s2) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i][j] = G[j][i] = d;\n\t\t\t} \n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\tG[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8f\\n\", G[m][l] );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//05\n#include<iostream>\n#include<algorithm>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dt(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\nint main(){\n  for(int n,m,l;cin>>n>>m>>l,n|m|l;){\n    double d[100][100]={{}};\n    int x[100],y[100],a[100],r[100];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>a[i]>>r[i];\n      for(int j=0;j<i;j++){\n\tdouble ml=1<<30;\n\tfor(int k=0;k<5;k++){\n\t  P aa=P(x[i],y[i])+polar(r[i]+.0,(a[i]+72*k+90)/180.*acos(0)*2);\n\t  P bb=P(x[i],y[i])+polar(r[i]+.0,(a[i]+72*k+144+90)/180.*acos(0)*2);\n\t  for(int l=0;l<5;l++){\n\t    P cc=P(x[j],y[j])+polar(r[j]+.0,(a[j]+72*l+90)/180.*acos(0)*2);\n\t    P dd=P(x[j],y[j])+polar(r[j]+.0,(a[j]+72*l+144+90)/180.*acos(0)*2);\n\t    if(cr(aa-bb,cc-bb)*cr(aa-bb,dd-bb)<0&&cr(cc-dd,aa-dd)*cr(cc-dd,bb-dd)<0){\n\t      ml=0;\n\t    }else{\n\t      P ls[2][2]={aa,bb,cc,dd};\n\t      for(int i=0;i<2;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t  P a=ls[i][0];\n\t\t  P b=ls[i][1];\n\t\t  P c=ls[!i][j];\n\t\t  double dp;\n\t\t  if(dt(a-b,c-b)>0&&dt(b-a,c-a)>0){\n\t\t    dp=fabs(cr(a-b,c-b)/abs(a-b));\n\t\t  }else{\n\t\t    dp=min(abs(a-c),abs(b-c));\n\t\t  }\n\t\t  ml=min(ml,dp);\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\td[i][j]=d[j][i]=ml;\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    cout.precision(6);\n    cout<<fixed<<d[m-1][l-1]<<endl;\n  }\n  return 0;\n}\n\t    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<algorithm>\n#include<iomanip>\n#define rep(X,Y) for(int X=0;(X)<(Y);++X)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\n\nconst double EPS=1e-8;\ntypedef complex<double> P;\nnamespace std{\n  bool operator< (const P &a, const P &b){\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n  }\n}\n\ndouble cross(const P &a,const P &b){\n  return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n  L(const P &a,const P &b){\n    pb(a); pb(b);\n  }\n};\n\nP proj(const L &l,const P &p){\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nint ccw(P a,P b,P c){\n  b-=a; c-=a;\n  if(cross(b,c)>EPS) return 1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c)<-EPS) return 2;\n  if(norm(b)<norm(c)+EPS) return -2;\n  return 0;\n}\n\ndouble intersectSS(const L &s,const L &t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\ndouble intersectSP(const L &s,const P &p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<EPS;\n}\n\ndouble distSP(const L &s, const P &p){\n  const P r=proj(s,p);\n  if(intersectSP(s,r))return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble distSS(const L &s,const L &t){\n  if(intersectSS(s,t)) return 0;\n  return min({distSP(s,t[0]),distSP(s,t[1]),distSP(t,s[0]),distSP(t,s[1])});\t \n}\n\n\nint main(){\n  int n,m,l;\n  while(cin>>n>>m>>l,n){\n    vector<vector<L>> st(n);\n    cout<<fixed<<setprecision(10);\n    int x,y,a,r;\n    rep(i,n){\n      cin>>x>>y>>a>>r;\n      double th=M_PI/2+1.*a*M_PI/180;\n      vector<P> ps(5);\n      rep(j,5){\n\tps[j]=P(x+r*cos(th),y+r*sin(th));\n\tth+=72.*M_PI/180;\n      }\n      rep(j,5){\n\tst[i].pb(L(ps[j],ps[(j+2)%5]));\n      }\n    }\n    \n    double d[n][n];\n    fill(d[0],d[0]+n*n,1e20);\n    rep(i,n)rep(j,n)rep(a,5)rep(b,5)\n      d[i][j]=min(d[i][j],distSS(st[i][a],st[j][b]));\n    //rep(i,n){rep(j,n)cout<<d[i][j]<<\" \";cout<<endl;}\n    rep(k,n)rep(i,n)rep(j,n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<d[m-1][l-1]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <complex>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double PI  = 2 * acos(0);\nconst double EPS = 1e-8;\n\nstruct S{\n  P p1;\n  P p2;\n  S(P p,P q) : p1(p), p2(q) {}\n  S(){}\n};\n\nint ccw(P p0, P p1, P p2){\n  P d1 = p1-p0;\n  P d2 = p2-p0;\n  double dx1 = d1.real(), dx2 = d2.real();\n  double dy1 = d1.imag(), dy2 = d2.imag();\n\n  if(dx1*dy2 > dy1*dx2) return  1;\n  if(dx1*dy2 < dy1*dx2) return -1;\n  if((dx1*dx2 < 0) || (dy1*dy2 < 0)) return -1;\n  if((dx1*dx1+dy1*dy1) < (dx2*dx2+dy2*dy2)) return 1;\n  return 0;\n}\n\nbool intersect(const S &s1, const S &s2){\n  return ((ccw(s1.p1, s1.p2, s2.p1)\n           *ccw(s1.p1, s1.p2, s2.p2)) <= 0)\n    &&((ccw(s2.p1, s2.p2, s1.p1)\n        *ccw(s2.p1, s2.p2, s1.p2)) <= 0);\n}\n\ninline double inp(const P& a, const P& b) {\n  return (conj(a)*b).real();\n}\n\ninline P proj(const P& p, const P& b) {\n  return b * inp(p, b) / norm(b);\n}\n\ninline P perf(const S& l, const P& p){\n  return l.p1 - proj(l.p1 - p, l.p2 - l.p1);\n}\n\ndouble dist(const S &s, const P &p){\n  const P r = perf(s, p);\n  const double pos = ((r - s.p1) / (s.p2 - s.p1)).real();\n  if( - EPS <= pos && pos <= EPS )\n    return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble dist(const S &s, const S &t){\n  if(intersect(s, t)) return 0.0;\n  return min(dist(s, t.p1), min(dist(s, t.p2), min(dist(t, s.p1), dist(t, s.p2))));\n}\n\nint main(){\n  while(true){\n    const int n = getInt();\n    const int m = getInt();\n    const int l = getInt();\n\n    if(n + m + l == 0) break;\n\n    vector<vector<S> > v(n, vector<S>(5));\n\n    REP(i,n){\n      const int x = getInt();\n      const int y = getInt();\n      const int a = getInt();\n      const int r = getInt();\n\n      P pos = P(x, y) + P(0, r) * P(cos(a / 180.0 * PI), sin(a / 180.0 * PI));\n      P dir = P(cos((270 - 18 + a) / 180.0 * PI), sin((270 - 18 + a) / 180.0 * PI));\n\n      const double rr = r * cos(18 / 180.0 * PI) * 2;\n\n      REP(j,5){\n        v[i][j] = S(pos, pos + dir * rr);\n\n        pos = pos + dir * rr;\n        dir = dir * P(cos((180 - 36) / 180.0 * PI), sin((180 - 36) / 180.0 * PI));\n      }\n    }\n\n    vector<vector<double> > dst(n, vector<double>(n));\n\n    REP(i,n) REP(j,i){\n      double d = 1e10;\n      REP(ii,5) REP(jj,5){\n        d = min(d, dist(v[i][ii], v[j][jj]));\n      }\n      dst[i][j] = dst[j][i] = d;\n    }\n\n    REP(i,n) REP(j,n){\n      bool inside = false;\n      P pos = (v[i][0].p1 + v[i][1].p1 + v[i][2].p1 + v[i][3].p1 + v[i][4].p1);\n      pos = P(pos.real()/5, pos.imag()/5);\n\n      double sum = 0.0;\n      REP(k,5){\n        if(dist(v[j][k], pos) < EPS) inside = true;\n        sum += arg((v[j][(k + 1) % 5].p1 - pos) / (v[j][k].p1 - pos));\n      }\n      if(sum > 1) inside = true;\n      if(inside) dst[j][i] = dst[i][j] = 0.0;\n    }\n\n    REP(k,n) REP(i,n) REP(j,n)\n      dst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\n    printf(\"%.8f\\n\", dst[m - 1][l - 1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\nconst double EPS = 1e-6;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void readL() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\n\n\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(L &ab,L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL( L &l,  L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS( L &l,  L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP( L &l,  P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS( L &s,  L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L &s,  P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection( L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection( L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP( L &l,  P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL( L &l,  L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS( L &l,  L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP( L &s,  P &p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS( L &s,  L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP( P &p, P &q){\n  return abs(p - q) ;\n}\nP crosspoint(L &l,L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP crosspointSS(L &l1,L &l2) {\n  double d1 = abs(cross(l2.v, l1[0] - l2[0])); // l1.a - l2.b???\n  double d2 = abs(cross(l2.v, l1[1] - l2[0]));\n  double t = d1 / (d1 + d2);\n  return l1[0] + t * l1.v;\n}\nP verticalvector( P &a, P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\nconst double PI = acos(-1);\ndouble d2r(int d){\n  return (1.0 * d/180)*PI;\n}\n\nclass star{\n  public:\n    P p[5],c;\n    L l[5];\n    star(){};\n    star(double x,double y,int a,double r){\n      int d = a + 90;\n      c = P(x,y);\n      rep(i,5){\n        p[i] = c + polar(r,d2r(d));\n        d += 72;\n      }\n      rep(i,5){\n        l[i] = L(p[i],p[(i+2)%5]);\n      }\n    }\n    P& operator[](int i){\n      return p[i];\n    }\n    bool operator<(const star &s) const {\n      return c < s.c;\n    }\n    void show(){\n      rep(i,5){\n        cout << p[i] << endl;\n      }\n      cout << endl;\n    }\n};\ndouble distanceStar(star &s, star &t){\n  double res = INF;\n  rep(i,5){\n    rep(j,5){\n      if(same(s[i],t[j]) || intersectSS(s.l[i],t.l[j]) || intersectSP(s.l[i],t[j]) || intersectSP(t.l[i],s[j])){\n        return 0;\n      }\n      else{\n        res = min(res,distancePP(s[i],t[j]));\n        res = min(res,distanceSP(s.l[i],t[j]));\n        res = min(res,distanceSP(t.l[i],s[j]));\n        res = min(res,distanceSS(s.l[i],t.l[j]));\n      }\n    }\n  }\n  return res;\n}\n\ndouble dis[101][101];\ndouble ans[101][101];\n\nvoid warshall(int n){\n  rep(i,n){\n    rep(j,n){\n      ans[i][j] = INF;\n    }\n  }\n  rep(k,n){\n    rep(i,n){\n      rep(j,n){\n        ans[i][j] = min(ans[i][j],dis[i][k] + dis[k][j]);\n      }\n    }\n  } \n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n,m,l;\n  while(cin >> n >> m >> l,n+m+l){\n    --l,--m;\n    vector<pair<star,int>> vs(n);\n    double x,y,b,r;\n    rep(i,n){\n      cin >> x >> y >> b >> r;\n      vs[i] = mp(star(x,y,b,r),i);\n    }\n    REP(i,0,n){\n      rep(j,n){\n        dis[i][j] = distanceStar(vs[i].fi,vs[j].fi);\n      }\n    }\n    warshall(n);\n    fcout(10) << ans[l][m] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-11;\n\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n           (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n    if(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n    return dist_line_and_point(a1,a2,b);\n}\n\nostream& operator<<(ostream& os,point a){\n    os << \"(\" << a.real() << \",\" << a.imag() << \")\";\n    return os;\n}\n\ndouble dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){\n    if(is_intersected_linesegment(a1,a2,b1,b2)){\n        return 0;\n    }\n    return min(min(dist_linesegment_and_point(a1,a2,b1),\n                   dist_linesegment_and_point(a1,a2,b2)),\n               min(dist_linesegment_and_point(b1,b2,a1),\n                   dist_linesegment_and_point(b1,b2,a2)));\n}\n\nstruct Star{\n    point p;\n    double a;\n    double r;\n    vector<point> ps;\n    Star(double x,double y,double a,double r) : p(x,y),a(a),r(r) {\n        for(int i=0;i<5;i++){\n            ps.push_back(p+polar(r,M_PI * (0.4*i + 0.1 + (a / 180))));\n        }\n    }\n};\n\nconst double INF = 1e14;\ndouble dist_stars(Star a,Star b){\n    double ret = INF;\n    for(int i=0;i<5;i++){\n        for(int j=i+1;j<5;j++){\n            for(int k=0;k<5;k++){\n                for(int l=k+1;l<5;l++){\n                    ret = min(ret,dist_linesegment_and_linesegment(a.ps[i],a.ps[j],b.ps[k],b.ps[l]));\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cout << fixed << setprecision(8);\n    while(true){\n        int N,M,L;\n        cin >> N >> M >> L;\n        if(N == 0 and M == 0 and L == 0) break;\n        M--;L--;\n        vector<Star> stars;\n        vector<vector<double> > dist(N,vector<double>(N,INF));\n\n        for(int i=0;i<N;i++){\n            double x,y,a,r;\n            cin >> x >> y >> a >> r;\n            stars.push_back(Star(x,y,a,r));\n        }\n\n        for(int i=0;i<N;i++){\n            for(int j=i;j<N;j++){\n                dist[i][j] = dist[j][i] = dist_stars(stars[i],stars[j]);\n            }\n        }\n        for(int i=0;i<N;i++){\n            dist[i][i] = 0;\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        cout << dist[M][L] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 2. * PI / 5.));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e7;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.15lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\ndouble dist2(const P& a, const P& b){\n\tP c (b - a);\n\treturn dot(c, c);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\t\t ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nstruct Edge{\n\tint to;\n\tdouble cost;\n};\ndouble d[110];\n\nint main(){\n\tint n, start ,goal;\n\twhile(cin>>n>>start>>goal && n && start && goal){\n\t\tstart--;\n\t\tgoal--;\n\t\trep(i, 110) d[i] = 1e18;\n\t\tvector<vector<P>> p(n);\n\t\trep(i, n){\n\t\t\tdouble x, y, a, r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\ta = PI * a/180.0;\n\t\t\trep(j, 5){\n\t\t\t\tP t(cos(a+2.0*PI * j / 5.0+PI/2)*r+x, sin(a+2.0*PI * j / 5.0+PI/2)*r+y);\n\t\t\t\tp[i].pb(t);\n\t\t\t}\n\t\t}\n\t\tvector<vector<L>> l(n);\n\t\trep(i, n){\n\t\t\trep(j, 5){\n\t\t\t\tint k = (j + 2) % 5;\n\t\t\t\tl[i].pb({p[i][j], p[i][k]});\n\t\t\t}\n\t\t\trep(j, 5){\n\t\t\t\tint k = (j+1)%5;\n\t\t\t\tp[i].pb(crosspoint(l[i][j], l[i][k]));\n\t\t\t}\n\t\t}\n\t\tvector<vector<Edge>> es(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tbool f = false;\n\t\t\trep(a, 5) rep(b, 5) if(intersectSS(l[i][a], l[j][b])) f = true;\n\t\t\tdouble dist = f ? 0.0 : 1e18;\n\t\t\trep(a, 10) rep(b, 10) dist = min(dist, sqrt(dist2(p[i][a], p[j][b])));\n\t\t\trep(a, 5) rep(b, 10) dist = min({dist, distanceSP(l[i][a], p[j][b]), distanceSP(l[j][a], p[i][b])});\n\t\t\tes[i].pb({j, dist});\n\t\t\tes[j].pb({i, dist});\n\t\t}\n\t\td[start] = 0.0;\n\t\ttypedef pair<double, int> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> q;\n\t\tq.push({0.0, start});\n\t\twhile(!q.empty()){\n\t\t\tPP pp = q.top(); q.pop();\n\t\t\tint from = pp.se;\n\t\t\tdouble  c = pp.fi;\n\t\t\tfor(auto& e : es[from]){\n\t\t\t\tint to = e.to;\n\t\t\t\tdouble cost = c + e.cost;\n\t\t\t\tif(d[to]>cost){\n\t\t\t\t\td[to] = cost;\n\t\t\t\t\tq.push({cost, to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15lf\\n\", d[goal]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return norm(outp(dir(), p - at(0))) / norm(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return norm(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return norm(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], sqrt(star[i][ik].distance(star[j][jk])));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint ccw(P a,P b,P c){\n\tP d = b-a;\n\tc-=a;\n\tdouble cr = cross(d,c);\n\tif(cr < -EPS) return 1;\n\tif(cr > EPS) return -1;\n\tif(dot(d,c) < -EPS) return 2;\n\tif(norm(d) < norm(c)-EPS) return -2;\n\treturn 0;\n}\n\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n\t\t   ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n\t// cout << a << \" \" << b << \" \" << c << endl;;\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nint main() {\n\tint n, a, b;\n\tcout << fixed << setprecision(20);\n\tconst double PI = acos(-1);\n\twhile(cin >> n >> a >> b, n) {\n\t\ta--, b--;\n\t\tvector<vector<P>> v(n, vector<P>(5));\n\t\trep(i, n) {\n\t\t\tdouble x, y, k, r;\n\t\t\tcin >> x >> y >> k >> r;\n\t\t\trep(j, 5) {\n\t\t\t\tdouble rad = 360.0 / 5 * j + 90 + k;\n\t\t\t\trad *= PI / 180;\n\t\t\t\tv[i][j] = P(r * cos(rad) + x, r * sin(rad) + y);\n\t\t\t}\n\t\t}\n\t\tvector<vector<double> > dp(n, vector<double>(n, 1e100));\n\t\trep(i, n) dp[i][i] = 0;\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif(i==j) continue;\n\t\t\t\tdouble t = 1e100;\n\t\t\t\trep(k, 5) {\n\t\t\t\t\trep(l, 5) {\n\t\t\t\t\t\tif(is_intersected_ls(v[i][k], v[i][(k + 2) % 5], v[j][l], v[j][(l + 2) % 5])) t = 0;\n\t\t\t\t\t\tif(is_intersected_ls(v[i][k], v[i][(k + 3) % 5], v[j][l], v[j][(l + 2) % 5])) t = 0;\n\t\t\t\t\t\tif(is_intersected_ls(v[i][k], v[i][(k + 2) % 5], v[j][l], v[j][(l + 3) % 5])) t = 0;\n\t\t\t\t\t\tif(is_intersected_ls(v[i][k], v[i][(k + 3) % 5], v[j][l], v[j][(l + 3) % 5])) t = 0;\n\t\t\t\t\t\tt = min(t, distance_ls_p(v[i][k], v[i][(k + 2) % 5], v[j][l]));\n\t\t\t\t\t\tt = min(t, distance_ls_p(v[i][k], v[i][(k + 3) % 5], v[j][l]));\n\t\t\t\t\t\tt = min(t, distance_ls_p(v[j][l], v[j][(l + 2) % 5], v[i][k]));\n\t\t\t\t\t\tt = min(t, distance_ls_p(v[j][l], v[j][(l + 3) % 5], v[i][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j] = t;\n\t\t\t}\n\t\t}\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[a][b] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<complex>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nint ccw(const P a, P b, P x) {\n  b -= a;\n  x -= a;\n  double cr = cross(b, x);\n  if (eq(cr, 0)) {\n    if (dot(b, x) < 0) return BACK;\n    if (abs(b) < abs(x)) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\nP vec(L a) {return a.second - a.first;}\nbool iSS(L a, L b) {\n  int cwaf = ccw(a.first, a.second, b.first);\n  int cwbf = ccw(b.first, b.second, a.first);\n  int cwas = ccw(a.first, a.second, b.second);\n  int cwbs = ccw(b.first, b.second, a.second);\n  if ((cwaf | cwas | cwbf | cwbs) & ON) return true;\n  return (cwaf | cwas) == (LEFT | RIGHT) && (cwbf | cwbs) == (LEFT | RIGHT);\n}\ndouble dLP(L l, P x) {return abs(cross(vec(l), x - l.first)) / abs(vec(l));}\ndouble dSP(L s, P x) {\n  if (dot(vec(s), x - s.first) <= 0) return abs(x - s.first);\n  if (dot(-vec(s), x - s.second) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\ndouble dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\n\ndouble x[111], y[111], a[111], r[111];\nL star[111][5];\ndouble dis[111][111];\ndouble mem[111];\n\nvoid f(int s, int t) {\n  double res = 1e40;\n  rep (i, 5) rep (j, 5) {\n    res = min(dSS(star[s][i], star[t][j]), res);\n    if (eq(res, 0)) break;\n  }\n  dis[s][t] = res;\n}\n\nint main() {\n  int n, m, l;\n  for (;;) {\n    cin >> n >> m >> l;\n    if (n == 0 && m == 0 && l == 0) break;\n    --m; --l;\n    rep (i, n) cin >> x[i] >> y[i] >> a[i] >> r[i];\n    rep (i, n) a[i] = a[i] / 360 * 2 * PI;\n    rep (i, n) rep (j, 5) {\n      double theta = a[i] + j * 2 * PI / 5 + PI / 2;\n      P p1 = P(x[i] + r[i] * cos(theta), y[i] + r[i] * sin(theta));\n      theta = a[i] + (j + 2) * 2 * PI / 5 + PI / 2;\n      P p2 = P(x[i] + r[i] * cos(theta), y[i] + r[i] * sin(theta));\n      star[i][j] = L(p1, p2);\n    }\n    rep (i, n) rep (j, n) if (i < j) f(i, j);\n    rep (i, n) rep (j, n) if (i > j) dis[i][j] = dis[j][i];\n    rep (i, n) mem[i] = INF;\n    priority_queue<pair<double, int> > que;\n    que.push(make_pair(0, m));\n    while (!que.empty()) {\n      pair<double, int> now = que.top();\n      que.pop();\n      if (mem[now.second] <= now.first) continue;\n      mem[now.second] = now.first;\n      rep (i, n) if (i != now.second) {\n\tque.push(make_pair(now.first + dis[now.second][i], i));\n      }\n    }\n    printf(\"%.12lf\\n\", mem[l]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n// ?????\\??????????????´???????????\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // ???????????§?????????????£°?????\\??????\ntypedef vector <P> Pol;\n\n// ??§????????????????????§?????????\ninline B cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\ninline B cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\ninline B cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// ???????????¬?¬??????????\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// ??????\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ????????¢???\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n// verify AOJ 2514\nP proj(P b,P p){ return b*ip(b,p)/norm(b);} \nP proj(L l,P p){ return l.first+proj(vec(l),p-l.first);}\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\ninline int ccw(P base, P a, P b) {              //??????a?????¨??????b???????????±??´??§??¨?????????????????????\n  a -= base; b -= base;\n  if (ep(a, b) > eps)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < -eps)      return RIGHT;   // clockwise\n  if (ip(a, b) < -eps)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  a?????¨b????????±?£??????????????£?????????????\n}\n\n// ??±?£???? ??¶??´??±???\n\t// ???????????¨??¶??´??±?£???????????±¬\n\t// ???????????¨??±?£?????????????????±¬\n\t// ??¶??´??±?£??????¶??´??±?£???????????±¬\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ????????????\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// ???????????¨??¶??´??±?£??????±?£??????¢??¢?¨???£??????????????????????????????\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ???????????¨??¶??´??±?£??????±?£??????¢??¢?¨???£?????????????±¬\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n// ??????\n// Verify AOJ 1183\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n//2?????????????????????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l, c.c);\n\tP e = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(h - c.c));\n\tres.pb(h - e);\n\tres.pb(h + e);\n\treturn res;\n}\n\n\n// ??????????¬???\\??±???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\n\n// ??????????????±?¨??£??£???±???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//?????±?¨??£?????¬???\\??±???\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ?????±?¨??£????????£???±???\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//?¬???\\????????§???????????¨?????§????£???±???\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(i,5)\n\t\t\tres.pb(tanC(a,i));\n\t}\n\treturn res;\n}\n\n\n// ?????????\n\n// ????????§????????¢\n\n// ????????§????????¢?????????????????????????£?????(??????????????§????????¢??§??????)\n//verify AOJ CGL_3-C\nint in_polygon(Pol pol,P p){\n    int n=pol.size();\n    int res=0;\n    rep(i,n){\n        if(ccw(pol[i],pol[(i+1)%n],p)==MID)\n            return 1;\n        if ((pol[i].Y <= p.Y) && (pol[(i+1)%n].Y>p.Y)){\n            D vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X < pol[i].X + vt*dx)\n                    res++;\n        }else if ((pol[i].Y>p.Y)&&(pol[(i+1)%n].Y<=p.Y)){\n            D vt=(p.Y - pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X <pol[i].X+vt*dx)\n                res--;\n        }\n    }\n    return res?2:0;\n}\n\n\n// ????????§????????¢?????????????????????????£?????(??????????????§????????¢??§??????)\n// Verify AOJ 2514\n\nbool in_polygon(Pol pol,L s){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar=L(pol[i],pol[(i+1)%n]);\n\t\tif(iSS(s,tar))\n\t\t\tcheck.pb(pLL(s,tar));\n\t}\n\n\tcheck.pb(s.first);\n\tcheck.pb(s.second);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\tbool res=true;\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m))\n\t\t\tres=false;\n\t}\n\treturn res;\n}\n\n\n// Area\n// Verify AOJ 1100\nD area(Pol pol){\n\tint n=pol.size();\n\tD xx,yy,sum=0.0;\n\trep(i,n){\n\t\txx=pol[i%n].X-pol[(i+1)%n].X;\n\t\tyy=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=xx*yy;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// hough T\n// ??§??¢????????????????????????\n\n\n\n// Convex_hull\n// Verify AOJ 0063\nPol convex_hull(Pol pol){\n\tint n=pol.size();\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tPol res(2*n);\n\tint k=0;\n\t\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n/*\n\n// now developing\nvector<L> merge_L(vector<L>){\n\n}\n\n\n\nPol normalize_polygon(Pol pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+2)%n],pol[(i+1)%n])==MID)\n\t\t\t// remove pol[(i+1)%n]\n\t\t\tn--;\n\t}\n}\n*/\n\ntypedef pair<P, pii> Star;\n#define F first\n#define S second\n\nint main(void){\n    for(int n, s, z; cin >> n >> s >> z, n;){\n        s--, z--;\n\n        vector<Star> stars(n);\n        for(auto && ss : stars){\n            int x, y;\n            cin >> x >> y >> ss.S.F >> ss.S.S;\n            ss.F = P(x, y);\n        }\n\n        vector<VP> p;\n        for(auto && ss : stars){\n            VP cur(5);\n\n            D a = ss.S.F;\n            int r = ss.S.S;\n            P root(0, r);\n\n            rep(i, 5){\n                cur[i] = rot(P(0, 0), root, (a + 72 * i) / 180.0 * pi);\n\n                cur[i] += ss.F;\n            }\n\n            p.pb(cur);\n        }\n\n        vector<vector<D>> minDist(n, vector<D>(n, inf));\n        rep(i, n){\n            rep(j, n){\n                rep(ii, 5){\n                    rep(jj, 5){\n                        L li(p[i][ii], p[i][(ii + 2) % 5]);\n                        L lj(p[j][jj], p[j][(jj + 2) % 5]);\n\n                        minDist[i][j] = min(minDist[i][j], dSS(li, lj));\n                    }\n                }\n            }\n        }\n\n        rep(k, n){\n            rep(i, n){\n                rep(j, n){\n                    minDist[i][j] = min(minDist[i][j], minDist[i][k] + minDist[k][j]);\n                }\n            }\n        }\n\n        printf(\"%.15Lf\\n\", minDist[s][z]);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\n// XY座標\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-10;\nconst double INF = 1e+12;\nconst double PI = acos(-1.0);\ntypedef complex<double> P;\n\n// 内積(dot product) a・b = |a||b|cosθ \ndouble dot(P a, P b){\n\treturn real( conj(a) * b );\n}\n\n// 外積(cross product) |a×b| = |a||b|sinθ\ndouble cross(P a, P b){\n\treturn imag( conj(a) * b );\n}\n\n// 度からラジアンに変換する.\ndouble to_rad(double deg){\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を a ラジアンだけ回転した点を返す.\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を angle ラジアンだけ回転した点を返す.\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 線分クラス\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){\n\t\ta = a_; b = b_;\n\t}\n\t\n\t// 点 p と線分の距離を返す.\n\tdouble distance(P p){\n\t\tif( dot(b-a,p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b,p-b) < EPS ) return abs(p-b);\n\t\treturn abs( cross(b-a,p-a) ) / abs(b-a) ;\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n\tbool is_intersection(const Segment& s){\n\t\treturn ( cross(b-a,s.a-a) * cross(b-a,s.b-a) < EPS && \n\t\t\t\t cross(s.b-s.a,b-s.a) * cross(s.b-s.a,b-s.a) < EPS );\n\t}\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tdouble A = this->distance(s.a);\n\t\tdouble B = this->distance(s.b);\n\t\tdouble C = s.distance( (*this).a );\n\t\tdouble D = s.distance( (*this).b );\n\t\treturn min( min(A,B) , min(C,D) );\n\t}\n\t// デバッグ出力\n\tvoid print(){\n\t\tprintf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n\t}\n};\n\nint main(){\n\t// n := 星の数, m := スタート, l := ゴール\n\tint n, m, l;\n\twhile( scanf(\"%d %d %d\", &n, &m, &l) , n || m || l ){\n\t\tm--; l--;\n\t\t// v[i] := i 番目の星 (5つの線分)\n\t\tvector< vector<Segment> > v;\n\t\t \n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r );\n\t\t\tdouble angle = to_rad( a + 90 );\n\t\t\tP p1( x + r*cos(angle) , y + r*sin(angle) );\n\t\t\tP p2 = rot2( P(x,y) , p1 , to_rad(72) );\n\t\t\tP p3 = rot2( P(x,y) , p2 , to_rad(72) );\n\t\t\tP p4 = rot2( P(x,y) , p3 , to_rad(72) );\n\t\t\tP p5 = rot2( P(x,y) , p4 , to_rad(72) );\n\t\t\t// vs := 5 つの線分\n\t\t\tvector<Segment> vs;\n\t\t\tvs.push_back( Segment(p1,p3) );\n\t\t\tvs.push_back( Segment(p3,p5) );\n\t\t\tvs.push_back( Segment(p5,p2) );\n\t\t\tvs.push_back( Segment(p2,p4) );\n\t\t\tvs.push_back( Segment(p4,p1) );\n\t\t\tv.push_back( vs );\n\t\t}\n\t\tdouble G[101][101];\n\t\tfor(int i=0 ; i < 101 ; i++ ){\n\t\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tdouble d = INF;\n\t\t\t\tfor(int k1 = 0 ; k1 < v[i].size() ; k1++ ){\n\t\t\t\t\tfor(int k2 = 0 ; k2 < v[j].size() ; k2++ ){\n\t\t\t\t\t\tSegment s1 = v[i][k1];\n\t\t\t\t\t\tSegment s2 = v[j][k2];\n\t\t\t\t\t\td = min( d , s1.distance(s2) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i][j] = G[j][i] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\tG[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8f\\n\", G[m][l]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20Lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,int> D;\nconst double EPS = 1e-8;\n\nP p[100];\ndouble r[100],d[100];\nint n,s,g;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first)); }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\ndouble slv(){\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y>>d[i]>>r[i];\n  \n  priority_queue<D,vector<D>,greater<D> > Q;\n  int used[100]={};\n  Q.push(D(0,s-1));\n  while(!Q.empty()){\n    double cs=Q.top().first;\n    int pos=Q.top().second;\n    Q.pop();\n    if(used[pos]++)continue;\n    if(pos==g-1)return cs;\n    \n    for(int i=0;i<n;i++){\n      if(i==pos)continue;\n\n      for(int j=0;j<5;j++){\n\t\n\tdouble na=M_PI*(d[i]+72*j+90)/180;\n\tdouble na1=M_PI*(d[i]+72*(j+2)+90)/180;\n\tL S=L(P(r[i]*cos(na),r[i]*sin(na))+p[i],P(r[i]*cos(na1),r[i]*sin(na1))+p[i]);\n\tfor(int k=0;k<5;k++){\n\t  double nb=M_PI*(d[pos]+72*k+90)/180;\n\t  double nb1=M_PI*(d[pos]+72*(k+2)+90)/180;\n\t  L G=L(P(r[pos]*cos(nb),r[pos]*sin(nb))+p[pos],P(r[pos]*cos(nb1),r[pos]*sin(nb1))+p[pos]);\n\t  Q.push(D(cs+getDistanceSS(S,G),i));\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>s>>g,n)printf(\"%.8lf\\n\",slv());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    double x,y;\n    vec(){}\n    vec(double x, double y){\n        this->x=x; this->y=y;\n    }\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(double d){\n        return (vec){x*d,y*d};\n    }\n    double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\nconst double eps = 0.0000001;\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = ab.cross(ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(ab.dot(ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(ab.dot(ab)<ac.dot(ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nbool isInterSection(vec (&p)[4]){\n    switch(ccw(p[0],p[1],p[2])*ccw(p[0],p[1],p[3])){\n        case -1:\n        case -4:\n        case 0:\n            break;\n        default:\n            return false;\n    }\n    switch(ccw(p[2],p[3],p[0])*ccw(p[2],p[3],p[1])){\n        case -1:\n        case -4:\n        case 0:\n            break;\n        default:\n            return false;\n    }\n   return true;\n}\n\nvec interSection(vec (&p)[4]){\n    vec p23=p[3]-p[2],p02=p[2]-p[0],p01=p[1]-p[0];\n    double k = p23.cross(p02)/p23.cross(p01);\n    return p[0]+p01*k;\n}\n\ndouble dist(vec (&p)[4]){\n    if(isInterSection(p)) return 0;\n    double dist =1e5;\n    vec P;\n    P=p[0]+(p[1]-p[0])*((p[1]-p[0]).dot(p[2]-p[0])/(p[1]-p[0]).dot(p[1]-p[0]));\n    if(!ccw(p[0],p[1],P)){\n        dist = min(dist,(P-p[2]).norm());\n    }\n    P=p[0]+(p[1]-p[0])*((p[1]-p[0]).dot(p[3]-p[0])/(p[1]-p[0]).dot(p[1]-p[0]));\n    if(!ccw(p[0],p[1],P)){\n        dist = min(dist,(P-p[3]).norm());\n    }\n    P=p[2]+(p[3]-p[2])*((p[3]-p[2]).dot(p[0]-p[2])/(p[3]-p[2]).dot(p[3]-p[2]));\n    if(!ccw(p[2],p[3],P)){\n        dist = min(dist,(P-p[0]).norm());\n    }\n    P=p[2]+(p[3]-p[2])*((p[3]-p[2]).dot(p[1]-p[2])/(p[3]-p[2]).dot(p[3]-p[2]));\n    if(!ccw(p[2],p[3],P)){\n        dist = min(dist,(P-p[1]).norm());\n    }\n    dist = min(dist,(p[2]-p[0]).norm());\n    dist = min(dist,(p[2]-p[1]).norm());\n    dist = min(dist,(p[3]-p[0]).norm());\n    dist = min(dist,(p[3]-p[1]).norm());\n    return dist;\n}\n\ntypedef vector<vec> star;\n\ndouble dist(star& a, star& b){\n    vec p[4];\n    double d=1e8;\n    for(int i=0;i<5;i++){\n        p[0]=a[i];\n        p[1]=a[(i+2)%5];\n        for(int j=0;j<5;j++){\n            p[2]=b[j];\n            p[3]=b[(j+2)%5];\n            d=min(d,dist(p));\n        }\n    }\n    return d;\n}\n\nvector<star> S;\ntypedef pair<double,int> P;\ndouble D[100][100];\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L,N){\n        S.clear();\n        M--;L--;\n        for(int i=0;i<N;i++){\n            S.emplace_back();\n            star& s=S.back();\n            int x,y,a,r;\n            cin>>x>>y>>a>>r;\n            for(int i=0;i<5;i++){\n                double Px,Py;\n                Px=x+r*cos((90+a+72*i)/180.0*M_PI);\n                Py=y+r*sin((90+a+72*i)/180.0*M_PI);\n                s.emplace_back(Px,Py);\n            }\n        }\n        fill(D[0],D[100],1e8);\n        for(int i=0;i<N;i++){\n            D[i][i]=0;\n            for(int j=i+1;j<N;j++){\n                D[i][j]=D[j][i]=dist(S[i],S[j]);\n            }\n        }\n        priority_queue<P,vector<P>,greater<P>> que;//cost,to\n        double minimum[100];\n        fill(minimum,minimum+100,1e8);\n        que.emplace(0,M);\n        while(!que.empty()){\n            P p=que.top();que.pop();\n            double cost=p.first;\n            int v=p.second;\n            if(cost>minimum[v])continue;\n            if(v==L){\n                cout.precision(10);\n                cout<<fixed;\n                cout<<cost<<endl;\n                break;\n            }\n            for(int i=0;i<N;i++){\n                if(minimum[i]>cost+D[v][i]){\n                    minimum[i]=cost+D[v][i];\n                    que.emplace(minimum[i],i);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(0, 0), b(0, 0) {}\n\tLine(Point _a, Point _b) : a(_a), b(_b) {}\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\nint main()\n{\n\tint N, M, L;\n\tcout << fixed << setprecision(15);\n\tcin.sync_with_stdio(false);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tvector<vector<Point>> seg(N, vector<Point>(5));\n\t\tvector<vector<Line>> segd(N, vector<Line>(5));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 72 * j) / 180.0 * pi), sinl((90 + a[i] + 72 * j) / 180.0 * pi)) * r[i];\n\t\t\t}\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tsegd[i][j] = Line(seg[i][j], seg[i][(j + 2) % 5]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 5; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 5; jj++) {\n\t\t\t\t\t\tdis[j][i] = dis[i][j] = min(dis[j][i], min(dis[i][j], dist_ss(segd[i][ii], segd[j][jj])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(const P &a, const P &b) {\n    return !sgn(abs(a-b));\n}\n\n//R cross(P a, P b) { return imag(conj(a)*b); }\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nusing ld = double;\nusing P = std::complex<ld>;\nusing G = std::vector<P>;\nconst ld PI = std::acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n\nld cross(const P &a, const P &b) { return a.real() * b.imag() - a.imag() * b.real(); }\nld dot(const P &a, const P &b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\n/*\nCCW\n\n-- BEHIND -- [a -- ON -- b] --- FRONT --\n\nCW\n*/\nenum CCW_RESULT { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > eps) return CCW;    // counter clockwise\n\tif(cross(b, c) < -eps) return CW;    // clockwise\n\tif(dot(b, c) < 0) return BEHIND;     // c--a--b on line\n\tif(norm(b) < norm(c)) return FRONT;  // a--b--c on line\n\treturn ON;\n}\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn std::abs(real(a) - real(b)) > eps ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct L : public std::vector<P> {\n\tL(const P &a = P(), const P &b = P()) : std::vector<P>(2) {\n\t\tbegin()[0] = a;\n\t\tbegin()[1] = b;\n\t}\n\n\t// Ax + By + C = 0\n\tL(ld A, ld B, ld C) {\n\t\tif(std::abs(A) < eps && std::abs(B) < eps) {\n\t\t\tabort();\n\t\t}\n\t\telse if(std::abs(A) < eps) {\n\t\t\t*this = L(P(0, -C / B), P(1, -C / B));\n\t\t}\n\t\telse if(std::abs(B) < eps) {\n\t\t\t*this = L(P(-C / A, 0), P(-C / A, 1));\n\t\t}\n\t\telse {\n\t\t\t*this = L(P(0, -C / B), P(-C / A, 0));\n\t\t}\n\t}\n};\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn std::abs(s[0] - p) + std::abs(s[1] - p) - std::abs(s[1] - s[0]) <\n\t\teps;  // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tld t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t * (l[0] - l[1]);\n}\nld distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return std::abs(r - p);\n\treturn std::min(std::abs(s[0] - p), std::abs(s[1] - p));\n}\nld distanceSS(const L &s, const L &t) {\n\tif(intersectSS(s, t)) return 0;\n\treturn std::min(std::min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\t\t\tstd::min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint N, B, A;\nL S[100][5];\n\ndouble wf[100][100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> N >> A >> B, N) {\n\t\tA--, B--;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ta = a / 180.0 * PI;\n\t\t\tL l = { P(0.0, r), P(0.0, r) * polar(1.0, 144.0 / 180.0 * PI) };\n\t\t\tP ps[5];\n\t\t\tP p = polar(r, PI / 2 + a);\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tps[j] = p + P(x, y);\n\t\t\t\tp *= polar(1.0, 2 * PI / 5);\n\t\t\t}\n\t\t\tS[i][0] = { ps[0], ps[2] };\n\t\t\tS[i][1] = { ps[2], ps[4] };\n\t\t\tS[i][2] = { ps[4], ps[1] };\n\t\t\tS[i][3] = { ps[1], ps[3] };\n\t\t\tS[i][4] = { ps[3], ps[0] };\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : 1e18;\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tdouble d = 1e9;\n\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\tfor(int l = 0; l < 5; l++) {\n\t\t\t\t\t\tint s = 5 * i + k, t = 5 * j + l;\n\t\t\t\t\t\tL l1 = S[i][k], l2 = S[j][l];\n\t\t\t\t\t\td = min(d, distanceSS(l1, l2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twf[i][j] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tcout << fixed << setprecision(15) << wf[A][B] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<long double> Point;\ntypedef pair<long double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  long double x, y, a, r;\n  ST(){}\n  ST(long double x, long double y, long double a, long double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst long double INF = 100000000.0;\nconst long double EPS = 1e-20;\n\nint n, s, t;\nvector<ST> input;\nlong double dist[N][N];\n\nlong double dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\nlong double cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nlong double getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\nlong double getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\nlong double getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, long double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec){\n  vector<Point> data;\n  Point o = Point(st.x, st.y);\n  Point p = rotate(Point(st.x, st.y + st.r), o, st.a);\n  for(int i=0;i<5;i++){\n    data.push_back(p);\n    p = rotate(p, o, 72.0);\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){data[i], data[i+1]});\n  }\n  vec.push_back((Segment){data[4], data[0]});\n}\n\nlong double calc_dist(ST pa, ST pb){\n  vector<Segment> a, b;\n  get_seg(pa, a);\n  get_seg(pb, b);\n  long double res = INF;\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      res = min(res, getDistance(a[i], b[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\nlong double solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      long double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.20f\\n\", (double)solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> point;\n\npoint operator*(const point &p, const double &d) { return point(real(p) * d, imag(p) * d); }\nnamespace std {\nbool operator<(const point &a, const point &b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); }\n}  // namespace std\n\nstruct Line : public vector<point> {\n    Line(const point &a, const point &b) {\n        push_back(a);\n        push_back(b);\n    }\n};\n\ndouble dist(const point &p1, const point &p2) { return abs(p1 - p2); }\n\ndouble cross(const point &a, const point &b) { return real(a) * imag(b) - imag(a) * real(b); }\ndouble dot(const point &a, const point &b) { return real(a) * real(b) + imag(a) * imag(b); }\nint ccw(point a, point b, point c) {\n    b -= a, c -= a;\n    if (cross(b, c) > EPS) return +1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < -EPS) return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersectSS(const Line &s, const Line &t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const Line &s, const point &p) { return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; }\npoint projection(const Line &l, const point &p) {\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + (l[0] - l[1]) * t;\n}\ndouble distanceSP(const Line &s, const point &p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min({distanceSP(s, t[0]), distanceSP(s, t[1]), distanceSP(t, s[0]), distanceSP(t, s[1])});\n}\n\nconst double PI = acos(-1);\nstruct Star {\n    point c;\n    double argu;\n    double r;\n    vector<point> ends;\n    vector<Line> edges;\n    Star(point c_, double argu_, double r_) : c(c_), r(r_), ends(5) {\n        argu = argu_ / 360 * 2 * PI;\n        double theta = PI / 2 + argu;\n        REP(i, 5) {\n            double phi = theta + (double)72 / 180 * PI * i;\n            double x = r * cos(phi), y = r * sin(phi);\n            ends[i] = c + point(x, y);\n        }\n        REP(i, 5) {\n            Line e(ends[i], ends[(i + 2) % 5]);\n            edges.push_back(e);\n            // edges[i] = Line(ends[i], ends[(i + 2) % 5]);\n        }\n    }\n};\n\ndouble d[101][101];\nvoid solve() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    if (N == 0) exit(0);\n    L--, M--;\n    REP(i, N) REP(j, N) {\n        if (i == j)\n            d[i][j] = 0;\n        else\n            d[i][j] = 1e9;\n    }\n    vector<Star> stars;\n    REP(i, N) {\n        double x, y, a, r;\n        cin >> x >> y >> a >> r;\n        point p(x, y);\n        Star s(p, a, r);\n        stars.push_back(s);\n    }\n    REP(i, N - 1) {\n        FOR(j, i + 1, N) {\n            double tmp = 1e9;\n            REP(k, 5) REP(l, 5) { tmp = min(tmp, distanceSS(stars[i].edges[k], stars[j].edges[l])); }\n            REP(k, 5) REP(l, 5) { tmp = min(tmp, dist(stars[i].ends[k], stars[j].ends[l])); }\n            d[i][j] = d[j][i] = tmp;\n        }\n    }\n    REP(k, N) REP(i, N) REP(j, N) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); }\n    REP(k, N) REP(i, N) REP(j, N) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); }\n    REP(k, N) REP(i, N) REP(j, N) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); }\n\n    cout << fixed << setprecision(20) << d[L][M] << endl;\n}\nsigned main() {\n    while (true) {\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vP;\ntypedef vector<double> vd;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n\ndouble rad(double deg) {\n\treturn deg*PI/180.0;\n}\n\ndouble dot(P a, P b) {\n\treturn (a.real()*b.real() + a.imag()*b.imag());\n}\n\ndouble cross(P a, P b) {\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\nint is_point_on_line(P a, P b, P c) {\n\treturn EQ(cross(b-a, c-a), 0.0);\n}\n\nint is_point_on_ls(P a, P b, P c) {\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif((cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < -EPS) &&\n\t   (cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < -EPS))\n\t   return true;\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2) ||\n\t\t   is_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n\tif(dot(b-a, c-a) < -EPS) return abs(c-a);\n\tif(dot(a-b, c-b) < -EPS) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble distance_ls(P a1, P a2, P b1, P b2) {\n\tif(is_intersected_ls(a1, a2, b1, b2)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(distance_ls_p(a1, a2, b1), distance_ls_p(a1, a2, b2)),\n\t\t\t   min(distance_ls_p(b1, b2, a1), distance_ls_p(b1, b2, a2)));\n}\n\nint main() {\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tvector<vP> points(N, vP(5));\n\t\tdouble x, y, a, r;\n\t\tREP(i, N) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tREP(j, 5) {\n\t\t\t\tpoints[i][j] = P(x-r*sin(rad(a+72*j)), y+r*cos(rad(a+72*j)));\n\t\t\t}\n\t\t}\n\n\t\tvector<vd> cost(N, vd(N, INF));\n\t\tREP(i, N) {\n\t\t\tFOR(j, i+1, N-1) {\n\t\t\t\tREP(k, 5) {\n\t\t\t\t\tREP(l, 5) {\n\t\t\t\t\t\tcost[i][j] = cost[j][i] = min(cost[i][j], distance_ls(points[i][k], points[i][(k+2)%5], points[j][l], points[j][(l+2)%5]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(k, N) {\n\t\t\tREP(i, N) {\n\t\t\t\tREP(j, N) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(M == L){\n\t\t\tcost[M-1][L-1] = 0.0;\n\t\t}\n\t\t\n\t\tprintf(\"%.8f\\n\", cost[M-1][L-1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<tuple>\n#include<complex>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmin(T &l, T r) {\n    bool res = l > r;\n    if (res) {\n        l = r;\n    }\n    return res;\n}\n#define IL inline\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\ntypedef double D;\nconst D EPS = 1e-8;\nIL D dot(P a, P b) {\n    return a.X*b.X + a.Y*b.Y;\n}\nIL D cross(P a, P b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n     IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n\n \n \nstruct cww {\n    cww() {\n        cout << fixed;\n        cout << setprecision(10);\n    }\n}star;\n \nIL D distance_P_LS(P p, LS ls) {\n    P a, b, c = p;\n    tie(a, b) = ls;\n    if (dot(b - a, c - a) < EPS)return abs(c - a);\n    if (dot(a - b, c - b) < EPS)return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n    IL B is_LS_LS(LS p, LS q) {\n        P a, b, c, d;\n        tie(a, b) = p;\n        tie(c, d) = q;\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n \n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS)return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\nP rot(P p, double r) {\n    return P(p.X*cos(r) - p.Y*sin(r), p.X*sin(r) + p.Y*cos(r));\n}\n \nconst D PI = acos(-1);\nconst D FI = 72.0 / 180.0*PI;\ntypedef pair<double, int> pp;\nconst int ss[][2] = { {0,2},{0,3},{1,3},{1,4},{2,4} };\ntypedef priority_queue<pp, vector<pp>, greater<pp>> QUE;\nint main() {\n    int N, M, L;\n    while (cin >> N >> M >> L, N) {\n        vector<LS> ls(5*N);\n        REP(i, N) {\n            double x, y,a,r;\n            cin >> x >> y >> a >> r;\n            P p(x, y);\n            vector<P> pt(5);\n            pt[0] = rot(P(0, r), a/180.0*PI);\n            REP(i, 4)pt[i + 1] = rot(pt[i], FI);\n            REP(j, 5) {\n                ls[i * 5 + j] = LS(p+pt[ss[j][0]], p+pt[ss[j][1]]);\n            }\n        }\n        vector<vector<double>> dist(N * 5, vector<double>(N * 5));\n        REP(i, 5*N)REP(j, 5*N) {\n            if (i == j)dist[i][j] = 0;\n            else dist[i][j] = distance_LS_LS(ls[i], ls[j]);\n        }\n        int S = 5 * (M - 1);\n        int G = 5 * (L - 1);\n \n \n \n \n \n        vector<double> res(N *5, 1e18);\n        res[S] = 0;\n        QUE que;\n        que.push(pp(0,S));\n        while (que.size()) {\n            int v; double cost;\n            tie(cost,v) = que.top();\n            que.pop();\n            if (cost > res[v])continue;\n            REP(u, 5 * N) if(u!=v){\n                double ncost = cost + dist[u][v];\n                if (chmin(res[u], ncost))que.push(pp(ncost, u));\n            }\n        }\n        cout << res[G] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<complex>\n#include<iomanip>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\n#define EPS (1e-10)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\ntypedef complex<double> point;\n\nstatic const double pi = acos(-1.0);\n\ndouble dot(point a, point b){\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\n\ndouble cross(point a, point b){\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\nint is_orthogonal(point a1, point a2, point b1, point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n\nint is_parallel(point a1, point a2, point b1, point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// distance between the line ab and the point c\ndouble dis_lp(point a, point b, point c){\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// distance between the line segment ab and the point c\ndouble dis_lsp(point a, point b, point c){\n    if(dot(b-a, c-a)<EPS) return abs(c-a);\n    if(dot(a-b, c-b)<EPS) return abs(c-b);\n    return dis_lp(a, b, c);\n}\n\nint is_intersected(point a1, point a2, point b1, point b2){\n    return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1)<0) && \n           (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1)<0);\n}\n\n// rotation\npoint rotate(point a, double d){\n    point r = polar(1.0, d*2*pi/360);\n    return a*r;\n}\n\nint INF = 10e8;\nint n, m, l;\ndouble dis[100][100];\ndouble x[100];\ndouble y[100];\ndouble a[100];\ndouble r[100];\n\ncomplex<double> star[100][5];\n\nint main(){\n    while(1){\n        cin >> n >> m >> l;\n        if(n==0) break;\n\n        REP(i, n){\n            REP(j, n){\n                dis[i][j] = INF;\n            }\n        }\n\n        REP(i, n){\n            cin >> x[i] >> y[i] >> a[i] >> r[i];\n            point p = point(x[i], y[i]);\n            point t = point(0, r[i]);\n            REP(j, 5){\n                star[i][j] = p + rotate(t, (double)144*j+a[i]);\n            }\n        }\n\n        /*\n        REP(i, n){\n            REP(j, 5){\n                cout << star[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        REP(i, n){\n            REP(j, n){\n                REP(k, 5){\n                    REP(l, 5){\n                        if(is_intersected(star[i][k], star[i][(k+1)%5], star[j][l], star[j][(l+1)%5])){\n                            dis[i][j] = 0;\n                        }\n                    }\n                }\n            }\n        }\n\n        REP(i, n){\n            REP(j, n){\n                REP(k, 5){\n                    REP(l, 5){\n                        dis[i][j] = min(dis[i][j], dis_lsp(star[i][k], star[i][(k+1)%4], star[j][l]));\n                    }\n                }\n            }\n        }\n\n        /*\n        REP(i, n){\n            REP(j, n){\n                cout << dis[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        REP(k, n){\n            REP(i, n){\n                REP(j, n){\n                    dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);\n                }\n            }\n        }\n\n        cout << fixed << setprecision(7) << dis[m-1][l-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <utility>\n\nconst double PI=3.14159265358979323846264;\nconst double EPS=1e-9;\nconst double INF=1e12;\n\nusing Point=std::complex<double>;\nusing LineSeg=std::pair<Point, Point>;\n\ndouble dot(const Point &a, const Point &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const Point &a, const Point &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nenum CCWise {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nCCWise ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool crossed(const LineSeg &s, const LineSeg &t) {\n    const Point &s1=s.first, &s2=s.second, &t1=t.first, &t2=t.second;\n    if (ccw(s1, s2, t1) * ccw(s1, s2, t2) > 0)\n        return false;\n\n    return ccw(t1, t2, s1) * ccw(t1, t2, s2) <= 0;\n}\n\ndouble dist_sp(const LineSeg &s, const Point &p) {\n    const Point &s1=s.first, &s2=s.second;\n    if (dot(s2-s1, p-s1) < EPS) return std::abs(p-s1);\n    if (dot(s1-s2, p-s2) < EPS) return std::abs(p-s2);\n    return std::abs(cross(s2-s1, p-s1)) / std::abs(s2-s1);\n}\n\nstruct Star {\n    Point p;\n    double angle, radius;\n    Point pts[5];\n    Star(double x, double y, double a, double r):\n        p(x, y), angle(a), radius(r)\n    {\n        pts[0] = p + std::polar(r, (90+angle)*PI/180);\n        Point q=std::polar(2*r*std::cos(18*PI/180), (108+angle)*PI/180);\n        for (int i=1; i<5; ++i) {\n            q *= std::polar(1.0, 144*PI/180);\n            pts[i] = pts[i-1] + q;\n        }\n    }\n    double howfar(const Star &other) const {\n        double res=INF;\n\n        for (size_t i=0; i<5; ++i)\n            for (size_t j=0; j<5; ++j) {\n                LineSeg s(pts[i], pts[(i+1)%5]);\n                LineSeg t(other.pts[j], other.pts[(j+1)%5]);\n                if (crossed(s, t))\n                    return 0.0;\n\n                res = std::min(res, dist_sp(s, other.pts[j]));\n                res = std::min(res, dist_sp(t, pts[i]));\n            }\n\n        return res;\n    }\n};\n\nint testcase_ends() {\n    size_t N, M, L;\n    scanf(\"%zu %zu %zu\", &N, &M, &L);\n\n    if (N == 0 && M == 0 && L == 0)\n        return 1;\n\n    std::vector<Star> s;\n    s.reserve(N);\n    for (size_t i=0; i<N; ++i) {\n        int x, y, a, r;\n        scanf(\"%d %d %d %d\", &x, &y, &a, &r);\n        s.emplace_back(x, y, a, r);\n    }\n\n    std::vector<std::vector<double>> dist(N, std::vector<double>(N));\n    for (size_t i=0; i<N; ++i)\n        for (size_t j=i+1; j<N; ++j)\n            dist[i][j] = dist[j][i] = s[i].howfar(s[j]);\n\n    for (size_t k=0; k<N; ++k)\n        for (size_t i=0; i<N; ++i)\n            for (size_t j=0; j<N; ++j)\n                if (dist[i][j] > dist[i][k] + dist[k][j])\n                    dist[i][j] = dist[i][k] + dist[k][j];\n\n    printf(\"%.12f\\n\", dist[--M][--L]);\n    return 0;\n}\n\nint main() {\n    while (true)\n        if (testcase_ends()) break;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return +1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return +2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn s.a + (s.b - s.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\nconst double alpha = 72.0 / 180.0 * M_PI;\nstruct star {\n\tvector<segment> seg;\n\tstar(int x, int y, int a, int r) {\n\t\tconst point s(r, 0);\n\t\tconst point m(x, y);\n\t\tconst double aa = a * M_PI / 180.0;\n\t\tfor(int i = 0; i < 5; ++i) {\n\t\t\tdouble theta = aa + i * 2 * M_PI / 5.0 + M_PI / 2.0;\n\t\t\tconst point p = rotate(s, theta) + m;\n\t\t\ttheta = aa + (i + 2) * 2 * M_PI / 5.0 + M_PI / 2.0;\n\t\t\tconst point q = rotate(s, theta) + m;\n\t\t\tseg.push_back(segment(p, q));\n\t\t}\n\t}\n};\n\nconst double INF = 10000.0;\n\ndouble dist(const star& s, const star& t) {\n\tdouble res = INF;\n\tfor(int i = 0; i < 5; ++i)\n\t\tfor(int j = 0; j < 5; ++j)\n\t\t\tchmin(res, dist(s.seg[i], t.seg[j]));\n\n\treturn res;\n}\n\nint n;\ndouble mat[100][100];\ndouble dijkstra(const int s, const int t) {\n\tvector<double> d(n, INF);\n\tvector<bool> used(n, false);\n\td[s] = 0;\n\n\tfor(;;) {\n\t\tint v = -1;\n\t\tfor(int u = 0; u < n; ++u)\n\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))\n\t\t\t\tv = u;\n\n\t\tif(v == t)\n\t\t\treturn d[t];\n\n\t\tused[v] = true;\n\t\tfor(int u = 0; u < n; ++u)\n\t\t\tchmin(d[u], d[v] + mat[v][u]);\n\t}\n}\n\n\nint main() {\n\tfor(int m, l; scanf(\"%d %d %d\", &n, &m, &l), n;) {\n\t\t--m; --l;\n\t\tvector<star> stars;\n\t\tstars.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r);\n\t\t\tstars.push_back(star(x, y, a, r));\n\t\t}\n\n\t\tfill(mat[0], mat[0] + lengthof(mat), 0.0);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\t\tmat[i][j] = mat[j][i] = dist(stars[i], stars[j]);\n\n\t\tprintf(\"%.20lf\\n\", dijkstra(m, l));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\ndouble dot(P a, P b) { return (a.real() * b.real() + a.imag() * b.imag()); }\ndouble det(P a, P b) { return (a.real() * b.imag() - a.imag() * b.real()); }\n\nint n, m, l, x[100], y[100], a[100], r[100];\n\nP p[100][5];\ndouble d[100][100];\n\ndouble distanceLSP(P a, P b, P c) {\n  if (dot(b-a, c-a) < EPS) return abs(c-a);\n  if (dot(a-b, c-b) < EPS) return abs(c-b);\n  return abs(det(b-a, c-a)) / abs(b-a);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d%d\", &n, &m, &l);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &a[i], &r[i]);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 5; j++) {\n        double S = (double)(a[i] + 72 * j) * M_PI / 180;\n        p[i][j] = P(x[i] - r[i] * sin(S), y[i] + r[i] * cos(S));\n      }\n    }\n    for (int i = 0; i < n; i++) d[i][i] = 0.0;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        double temp = distanceLSP(p[i][0], p[i][2], p[j][0]);\n        for (int k = 0; k < 5; k++) {\n          for (int z = 0; z < 5; z++) {\n            temp = min(temp, distanceLSP(p[i][k], p[i][(k + 2) % 5], p[j][z]));\n            temp = min(temp, distanceLSP(p[i][k], p[i][(k + 3) % 5], p[j][z]));\n            temp = min(temp, distanceLSP(p[j][k], p[j][(k + 2) % 5], p[i][z]));\n            temp = min(temp, distanceLSP(p[j][k], p[j][(k + 3) % 5], p[i][z]));\n          }\n        }\n        d[i][j] = d[j][i] = temp;\n      }\n    }\n    for (int k = 0; k < n; k++)\n      for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    printf(\"%f\\n\", d[m-1][l-1]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nusing ld = double;\nusing P = std::complex<ld>;\nusing G = std::vector<P>;\nconst ld PI = std::acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n\nld cross(const P &a, const P &b) { return a.real() * b.imag() - a.imag() * b.real(); }\nld dot(const P &a, const P &b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\n/*\nCCW\n\n-- BEHIND -- [a -- ON -- b] --- FRONT --\n\nCW\n*/\nenum CCW_RESULT { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > eps) return CCW;    // counter clockwise\n\tif(cross(b, c) < -eps) return CW;    // clockwise\n\tif(dot(b, c) < 0) return BEHIND;     // c--a--b on line\n\tif(norm(b) < norm(c)) return FRONT;  // a--b--c on line\n\treturn ON;\n}\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn std::abs(real(a) - real(b)) > eps ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct L : public std::vector<P> {\n\tL(const P &a = P(), const P &b = P()) : std::vector<P>(2) {\n\t\tbegin()[0] = a;\n\t\tbegin()[1] = b;\n\t}\n\n\t// Ax + By + C = 0\n\tL(ld A, ld B, ld C) {\n\t\tif(std::abs(A) < eps && std::abs(B) < eps) {\n\t\t\tabort();\n\t\t}\n\t\telse if(std::abs(A) < eps) {\n\t\t\t*this = L(P(0, -C / B), P(1, -C / B));\n\t\t}\n\t\telse if(std::abs(B) < eps) {\n\t\t\t*this = L(P(-C / A, 0), P(-C / A, 1));\n\t\t}\n\t\telse {\n\t\t\t*this = L(P(0, -C / B), P(-C / A, 0));\n\t\t}\n\t}\n};\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn std::abs(s[0] - p) + std::abs(s[1] - p) - std::abs(s[1] - s[0]) <\n\t\teps;  // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tld t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t * (l[0] - l[1]);\n}\nld distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return std::abs(r - p);\n\treturn std::min(std::abs(s[0] - p), std::abs(s[1] - p));\n}\nld distanceSS(const L &s, const L &t) {\n\tif(intersectSS(s, t)) return 0;\n\treturn std::min(std::min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\t\t\tstd::min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint N, B, A;\nL S[100][5];\n\nconst double INF = 1e18;\ndouble wf[500][500];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> N >> A >> B, N) {\n\t\tA--, B--;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ta = a / 180.0 * PI;\n\t\t\tL l = { P(0.0, r), P(0.0, r) * polar(1.0, 144.0 / 180.0 * PI) };\n\t\t\tP ps[5];\n\t\t\tP p = polar(r, PI / 2 + a);\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tps[j] = p;\n\t\t\t\tp *= polar(1.0, 2 * PI / 5);\n\t\t\t}\n\t\t\tS[i][0] = { ps[0], ps[2] };\n\t\t\tS[i][1] = { ps[2], ps[4] };\n\t\t\tS[i][2] = { ps[4], ps[1] };\n\t\t\tS[i][3] = { ps[1], ps[3] };\n\t\t\tS[i][4] = { ps[3], ps[0] };\n\t\t\t/*for(int j = 0; j < 5; j++) {\n\t\t\t\tS[i][j] = l;\n\t\t\t\tP v = (l[0] - l[1]) * polar(1.0, -36 / 180.0 * PI);\n\t\t\t\tl[0] = l[1];\n\t\t\t\tl[1] = l[0] + v;\n\t\t\t}*/\n\t\t\t//cout << l[0] << \" \" << l[1] << endl;\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tS[i][j][0] += P(x, y);\n\t\t\t\tS[i][j][1] += P(x, y);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tdouble d = 1e9;\n\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\tfor(int l = 0; l < 5; l++) {\n\t\t\t\t\t\tint s = 5 * i + k, t = 5 * j + l;\n\t\t\t\t\t\tL l1 = S[i][k], l2 = S[j][l];\n\t\t\t\t\t\t/*if(intersectSS(l1, l2)) {\n\t\t\t\t\t\t\twf[s][t] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\td = min(d, abs(l1[0] - l2[0]));\n\t\t\t\t\t\t\td = min(d, abs(l1[1] - l2[0]));\n\t\t\t\t\t\t\td = min(d, abs(l1[0] - l2[1]));\n\t\t\t\t\t\t\td = min(d, abs(l1[1] - l2[1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;*/\n\t\t\t\t\t\td = min(d, distanceSS(l1, l2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twf[i][j] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tcout << fixed << setprecision(15) << wf[A][B] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XYツ催?標\n#define X real()\n#define Y imag()\n\n// * ツ点ツづ個表ツ個サ\ntypedef complex<double> P;\n\n// * ツ仰鳴容ツつキツづゥツ古ォツ債キツε?\nconst double EPS = 1e-6;\n// * Infinity\nconst double INF = 1e12;\n// * ツ円ツ偲シツ猟ヲ\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> ツづ個渉?渉伉づーツ津ィツ義ツつキツづゥ\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2ツ点ツ甘板づ個仰猟猟」\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2ツづつづ個スツカツδ可ーツつェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2ツづつづ個ベツクツトツδ仰つェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * ツ禿?静?(dot product) : aツ・b = |a||b|cosツδヲ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * ツ外ツ静?(cross product) : aツ×b = |a||b|sinツδヲ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : ツ板スツ篠楪計ツ嘉アツづィ (Counter Clock Wise)\n// CW : ツ篠楪計ツ嘉アツづィ (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3ツ点ツつェツづ?つソツづァツ嘉アツづィツづ?つ?づゥツつゥツ陛板つキ, 3ツ点ツつェ1ツ陳シツ静シツづ可湘ヲツづ?づ?つ「ツづゥツづ?つォツづ?ON ツづーツ陛板つキ\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n// ツδ可ジツアツδ督つゥツづァツ度ツ青板づ鳴陛渉環キツつオツづ?陛板つキ\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// ツ度ツ青板つゥツづァツδ可ジツアツδ督づ可陛渉環キツつオツづ?陛板つキ\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// ツ個エツ点ツづーツ篠イツづ可点 p ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// ツ点 a ツづーツ篠イツづ可点 b ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// ツ静シツ閉ェツクツδ可ス\nstruct Segment{\n    P a, b;\n    Segment(P a_, P b_){\n        a = a_; b = b_;\n    }\n    // ツ点 p ツづ?静シツ閉ェツづ個仰猟猟」ツづーツ陛板つキ.\n    double distance(P p){\n        if( dot(b-a,p-a) < EPS ) return abs(p-a);\n        if( dot(a-b,p-b) < EPS ) return abs(p-b);\n        return abs( cross(b-a,p-a) ) / abs(b-a) ;\n    }\n    // ツ静シツ閉ェ s ツづ?古ーツ債キツつオツづ?つ「ツづゥツつゥツづ?つ、ツつゥツづーツ陛板つキ.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n    // ツ点 p ツつェツ静シツ閉ェツ湘」ツづ可つ?づゥツつゥツづ?つ、ツつゥ\n    bool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n    // ツ静シツ閉ェツづ?静シツ閉ェツづ個仰猟猟」\n    double distance(Segment s) {\n        if( is_intersection(s) ) return 0.0;\n        return min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n    }\n    // ツデツバツッツグツ出ツ療?\n    void print(){\n        printf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n    }\n};\n// Segment ツづ個渉?渉伉づーツ津ィツ義 (xツ催?標ツづ個渉ャツつウツつ「ツ端ツ点ツづ?氾、ツ較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\ndouble dist_star(vector<Segment> a, vector<Segment> b){\n\tdouble result = INF;\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tfor(int j=0 ; j < b.size() ; j++ ){\n\t\t\tif( equal(a[i].distance( b[j] ) , 0.0) ) continue;\n\t\t\tresult = min( result , a[i].distance( b[j] ) );\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tint n, m, l;\n\twhile( scanf(\"%d %d %d\", &n, &m, &l ), n || m || l ){\n\t\tm--; l--;\n\t\t\n\t\t// v[i] := i ツ氾板姪堋づ個青ッ (5ツづつづ個静シツ閉ェツづーツ篠敖づ?\n\t\tvector< vector<Segment> > v;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\t// 5 ツづつづ個陳クツ点\n\t\t\tP p1 = P( x + r*cos(to_rad(a+90)) , y+r*sin(to_rad(a+90)) );\n\t\t\tP p2 = rot2( P(x,y) , p1 , to_rad(72) );\n\t\t\tP p3 = rot2( P(x,y) , p2 , to_rad(72) );\n\t\t\tP p4 = rot2( P(x,y) , p3 , to_rad(72) );\n\t\t\tP p5 = rot2( P(x,y) , p4 , to_rad(72) );\n\t\t\t// 5 ツづつづ個静シツ閉ェ\n\t\t\tvector<Segment> vs;\n\t\t\tvs.push_back( Segment(p1,p3) );\n\t\t\tvs.push_back( Segment(p3,p5) );\n\t\t\tvs.push_back( Segment(p5,p2) );\n\t\t\tvs.push_back( Segment(p2,p4) );\n\t\t\tvs.push_back( Segment(p4,p1) );\n\t\t\tv.push_back( vs );\n\t\t}\n\t\t\n\t\t// G[i][j] := ツ青ッ i ツづ?青ッ j ツづ個仰猟猟」 \n\t\tdouble G[101][101];\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tG[i][j] = (i == j)? 0 : INF ;\n \t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=i+1 ; j < n ; j++ ){\n\t\t\t\tdouble d = dist_star( v[i] , v[j] );\n\t\t\t\tG[i][j] = G[j][i] = d;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\tG[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8f\\n\", G[l][m] );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <iomanip>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N,S,G = 0;\n\ndouble l[110][110] = {};\ndouble nowL[110] = {};\nconst double PI = 3.14159265358979;\nstruct Star {\n\tconst int px, py,a;\n\tdouble x[5], y[5];\n\tStar(int _px, int _py, int _a, int _r) :px(_px),py(_py),a(_a) {\n\t\tfor (int i = 0; i < 5;i++) {\n\t\t\tx[i] = px + _r * cos((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t\ty[i] = py + _r * sin((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t}\n\t};\n};\n\nStar *s[105];\n\ndouble MinL(double x0, double y0, double x1, double y1, double x2, double y2) {\n\tdouble dx = x1 - x2, dy = y1 - y2;\n\tdouble x = (dx*dx*x0 - dx*dy*y0 + dy*(dx*y2 - dy*x2)) / (dx*dx - dy*dy);\n\tdouble d;\n\tif (min(x1, x2) <= x && x <= max(x1, x2)) {\n\t\td=abs(dy*x0 - dx*y0 + x1*y2 - x2*y1) / hypot(dx, dy); \n\t}\n\telse {\n\t\td=min(hypot(x1 - x0, y1 - y0), hypot(x2 - x0, y2 - y0));\n\t}\n\treturn d;\n}\nbool Crossing(double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3) {\n\tdouble t1 = (x2 - x3)*(y0 - y2) + (y2 - y3)*(x2 - x0);\n\tdouble t2 = (x2 - x3)*(y1 - y2) + (y2 - y3)*(x2 - x1);\n\tdouble t3 = (x0 - x1)*(y2 - y0) + (y0 - y1)*(x0 - x2);\n\tdouble t4 = (x0 - x1)*(y3 - y0) + (y0 - y1)*(x0 - x3);\n\treturn t3*t4 <= 0 && t1*t2 <= 0;\n}\n\nvoid CalcStar(int a, int b) {\n\tconst unsigned lineGoal[5]={2,3,4,0,1};\n\tdouble temp = 100000;\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0; j < 5;j++) {\n\t\t\tif (Crossing(\n\t\t\t\ts[a]->x[i], s[a]->y[i],\n\t\t\t\ts[a]->x[lineGoal[i]], s[a]->y[lineGoal[i]],\n\t\t\t\ts[b]->x[j], s[b]->y[j],\n\t\t\t\ts[b]->x[lineGoal[j]], s[b]->y[lineGoal[j]]\n\t\t\t)) {\n\t\t\t\tl[b][a] = l[a][b] = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0; j < 5;j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[a]->x[i], s[a]->y[i],\n\t\t\t\ts[b]->x[j], s[b]->y[j],\n\t\t\t\ts[b]->x[lineGoal[j]], s[b]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[b]->x[i], s[b]->y[i],\n\t\t\t\ts[a]->x[j], s[a]->y[j],\n\t\t\t\ts[a]->x[lineGoal[j]], s[a]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tl[b][a] = l[a][b] = temp;\n}\ndouble minCost[110];\nvoid Dijkstra(int _s,int _g) {\n\tfor (int i = 1; i <= N;i++) {\n\t\tminCost[i] = 1000000;\n\t}\n\tminCost[_s] = 0;\n\tstruct Node {\n\t\tint num;\n\t\tdouble cost;\n\t\tbool operator > (const Node& _node)const {\n\t\t\treturn cost > _node.cost;\n\t\t}\n\t};\n\tpriority_queue<Node,vector<Node>,greater<Node>> PQ;\n\tNode node = { _s, 0 };\n\tPQ.push( node );\n\twhile (!PQ.empty()){\n\t\tNode now = PQ.top(); PQ.pop();\n\t\tif (now.cost > minCost[now.num]) {\n\t\t\tcontinue;\n\t\t}\n\t\tminCost[now.num] = now.cost;\n\t\tif (now.num==_g) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= N;i++) {\n\t\t\tif (i!=now.num) {\n\t\t\t\tNode node = { i,now.cost + l[now.num][i] };\n\t\t\t\tPQ.push(node);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (true){\n\t\tcin >> N >> S >> G;\n\t\tif (N==0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ts[i] = new Star(x, y, a, r);\n\t\t\tnowL[i] = 5000;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\t\tCalcStar(i, j);\n\t\t\t}\n\t\t}\n\t\tDijkstra(S, G);\n\t\tcout << fixed << setprecision(7) << minCost[G] << endl;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdelete s[i];\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n\n\nusing namespace std;\n\n#define rep(i,n) for(i=0;i<n;i++)\n#define pow2(n) ((n)*(n))\n\n\nconst double pi=3.141592653589793;\n\ntypedef pair <double,int> P;\npriority_queue<P,vector<P>,greater<P> > Q;\n\ndouble star[500][2];\ndouble S[500][500];\n\ndouble R[500];\n\nconst double DINF = 1.0e+21;\n\n\nint main(void)\n{\n\twhile(1){\n\t\tint N,M,L;\n\t\tint x,y,a,r;\n\t\tint i,j;\n\t\tdouble l,sita,cost;\n\t\tP p;\n\t\t\n\t\t\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\t\n\t\trep(i,5*N)R[i]=DINF;\n\t\t\n\t\tif(N==0 && M==0 && L==0)return 0;\n\t\t\n\t\trep(i,N){\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&a,&r);\n\t\t\trep(j,5){\n\t\t\t\tsita=((90+a+72*j)%360)*pi/180;\n\t\t\t\t\n\t\t\t\tstar[i*5+j][0]=x+r*cos(sita);\n\t\t\t\tstar[i*5+j][1]=y+r*sin(sita);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//rep(i,N)rep(j,5)printf(\"$  %d,%d :%lf,%lf  [%lf]\\n\",i,j,star[i*5+j][0],star[i*5+j][1],star[i*5+j][0]*star[i*5+j][0]+star[i*5+j][1]*star[i*5+j][1]);\n\t\t\n\t\t\n\t\t\n\t\trep(i,5*N){\n\t\t\trep(j,5*N){\n\t\t\t\tif(i/5 == j/5){\n\t\t\t\t\tS[i][j]=S[j][i] = 0.0;continue;\n\t\t\t\t}\n\t\t\t\tl=sqrt(pow2(star[i][0]-star[j][0])+pow2(star[i][1]-star[j][1]));\n\t\t\t\tS[i][j]=S[j][i] = l;\n\t\t\t}\n\t\t}\n\t\t//rep(i,N*5)rep(j,N*5)printf(\"#  %d~%d :%lf\\n\",i,j,S[i][j]);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\trep(i,5){\n\t\t\tQ.push(P(0.0,(M-1)*5+i));\n\t\t}\n\t\t\n\t\t\n\t\twhile(!Q.empty()){\n\t\t\tp = Q.top();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\t//printf(\"#\");\n\t\t\tif(R[p.second]<=p.first)continue;\n\t\t\t//printf(\"%lf %d\\n\",p.first,p.second);\n\t\t\t\n\t\t\tR[p.second]=p.first;\n\t\t\t\n\t\t\trep(i,5*N){\n\t\t\t\tcost=p.first + S[p.second][i];\n\t\t\t\tif(R[i]<=cost)continue;\n\t\t\t\t//printf(\"push %lf %d\\n\",cost,i);\n\t\t\t\tQ.push(P(cost,i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lf\\n\",R[(L-1)*5]);\n\t\t\n\n\t}\n\treturn 0;\n}\n\n\n\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <iomanip>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N,S,G = 0;\n\ndouble l[110][110] = {};\ndouble nowL[110] = {};\nconst double PI = 3.14159265358979;\nstruct Star {\n\tconst int px, py,a;\n\tdouble x[5], y[5];\n\tStar(int _px, int _py, int _a, int _r) :px(_px),py(_py),a(_a) {\n\t\tfor (int i = 0; i < 5;i++) {\n\t\t\tx[i] = px + _r * cos((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t\ty[i] = py + _r * sin((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t}\n\t};\n};\n\nStar *s[105];\n\ndouble MinL(double x0, double y0, double x1, double y1, double x2, double y2) {\n\tdouble dx = x1 - x2, dy = y1 - y2;\n\tdouble x = (dx*dx*x0 + dy*dy*x1 + dx*dy*(y0 - y1)) / (dx*dx + dy*dy);\n\tdouble d;\n\tif (min(x1, x2) <= x && x <= max(x1, x2)) {\n\t\td=abs(dy*x0 - dx*y0 + x1*y2 - x2*y1) / abs(hypot(dx, dy)); \n\t}\n\telse {\n\t\td=min( abs(hypot(x1 - x0, y1 - y0)) , abs(hypot(x2 - x0, y2 - y0)) );\n\t}\n\treturn d;\n}\nbool Crossing(double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3) {\n\tdouble t1 = (x2 - x3)*(y0 - y2) + (y2 - y3)*(x2 - x0);\n\tdouble t2 = (x2 - x3)*(y1 - y2) + (y2 - y3)*(x2 - x1);\n\tdouble t3 = (x0 - x1)*(y2 - y0) + (y0 - y1)*(x0 - x2);\n\tdouble t4 = (x0 - x1)*(y3 - y0) + (y0 - y1)*(x0 - x3);\n\treturn t3*t4 <= 0 && t1*t2 <= 0;\n}\n\nvoid CalcStar(int a, int b) {\n\tconst unsigned lineGoal[5]={2,3,4,0,1};\n\tdouble temp = 100000;\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0; j < 5;j++) {\n\t\t\tif (Crossing(\n\t\t\t\ts[a]->x[i], s[a]->y[i],\n\t\t\t\ts[a]->x[lineGoal[i]], s[a]->y[lineGoal[i]],\n\t\t\t\ts[b]->x[j], s[b]->y[j],\n\t\t\t\ts[b]->x[lineGoal[j]], s[b]->y[lineGoal[j]]\n\t\t\t)) {\n\t\t\t\tl[b][a] = l[a][b] = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0; j < 5;j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[a]->x[i], s[a]->y[i],\n\t\t\t\ts[b]->x[j], s[b]->y[j],\n\t\t\t\ts[b]->x[lineGoal[j]], s[b]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[b]->x[i], s[b]->y[i],\n\t\t\t\ts[a]->x[j], s[a]->y[j],\n\t\t\t\ts[a]->x[lineGoal[j]], s[a]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tl[b][a] = l[a][b] = temp;\n}\ndouble minCost[110];\nvoid Dijkstra(int _s,int _g) {\n\tfor (int i = 1; i <= N;i++) {\n\t\tminCost[i] = 1000000;\n\t}\n\tminCost[_s] = 0;\n\tstruct Node {\n\t\tint num;\n\t\tdouble cost;\n\t\tbool operator > (const Node& _node)const {\n\t\t\treturn cost > _node.cost;\n\t\t}\n\t};\n\tpriority_queue<Node,vector<Node>,greater<Node>> PQ;\n\tNode node = { _s, 0 };\n\tPQ.push( node );\n\twhile (!PQ.empty()){\n\t\tNode now = PQ.top(); PQ.pop();\n\t\tif (now.cost > minCost[now.num]) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 1; i <= N;i++) {\n\t\t\tif (i!=now.num && minCost[now.num] + l[now.num][i] < minCost[i] ) {\n\t\t\t\tminCost[i] = minCost[now.num] + l[now.num][i];\n\t\t\t\tNode node  = { i,minCost[i] };\n\t\t\t\tPQ.push(node);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (true){\n\t\tcin >> N >> S >> G;\n\t\tif (N==0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ts[i] = new Star(x, y, a, r);\n\t\t\tnowL[i] = 5000;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\t\tCalcStar(i, j);\n\t\t\t}\n\t\t}\n\t\tDijkstra(S, G);\n\t\tcout << fixed << setprecision(7) << minCost[G] << endl;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdelete s[i];\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n\ntypedef long double ld;\nconst ld PI = 3.141592653589793238462643383279;\n\nstruct po{\n\tld x;\n\tld y;\n\tpo(ld a){ x = a; y = 0; }\n\tpo(ld a,ld b){ x = a; y = b; }\n\tpo(){}\n\tinline ld operator()(const po& rhs) const {\n\t\treturn x*rhs.x+y*rhs.y;\n\t}\n\tinline ld norm() {\n\t\treturn sqrt((*this)(*this));\n\t}\n\tinline po& operator+=(const po& rhs){\n\t\tx += rhs.x;\n\t\ty += rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator-=(const po& rhs){\n\t\tx -= rhs.x;\n\t\ty -= rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator*=(const po& rhs){\n\t\tld x_ = x*rhs.x-y*rhs.y;\n\t\ty = x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\treturn *this;\n\t}\n\tinline po& operator/=(const po& rhs){\n\t\tld x_ = x*rhs.x+y*rhs.y;\n\t\ty = -x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\tld nor = rhs(rhs);\n\t\tx /= nor;\n\t\ty /= nor;\n\t\treturn *this;\n\t}\n\tinline void in(){\n\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t}\n};\ninline po operator+(const po& a, const po& b){ return po(a) += b; }\ninline po operator-(const po& a, const po& b){ return po(a) -= b; }\ninline po operator*(const po& a, const po& b){ return po(a) *= b; }\ninline po operator/(const po& a, const po& b){ return po(a) /= b; }\n\ninline po similar(const po& a,const po& b,const po& c,const po& p,const po& q){\n\treturn p+(q-p)*(c-a)/(b-a);\n}\n\ntypedef pair<po,po> se;\n#define fr first\n#define sc second\n\nstruct li{\n\tld a;\n\tld b;\n\tld c;\n\tli(po p,po q){\n\t\ta = q.y-p.y;\n\t\tb = p.x-q.x;\n\t\tc = p.y*q.x-p.x*q.y;\n\t}\n\t/*explicit li(se s){\n\t\ta = s.sc.y-s.fr.y;\n\t\tb = s.fr.x-s.sc.x;\n\t\tc = s.fr.y*s.sc.x-s.fr.x*s.sc.y;\n\t\tli(s.fr,s.sc);\n\t}*/\n\tli(){}\n\tinline ld operator()(const po& p) const {\n\t\treturn a*p.x+b*p.y+c;\n\t}\n};\n\nvoid intersect(const li &l,const li &m,po* &ret){\n\tif(abs(l.a*m.b-m.a*l.b) <= 1e-18){\n\t\tret = nullptr;\n\t\treturn;\n\t}\n\tret = new po;\n\tret->x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret->y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n}\n\ninline bool on(const po &p,const se &s){\n\treturn (s.fr-p)(s.sc-p) <= 1e-9;\n}\n\nvoid intersect(const se &s,const se &t,po* &ret){\n\tli l = li(s.fr,s.sc);\n\tli m = li(t.fr,t.sc);\n\tpo *p;\n\tintersect(l,m,p);\n\tif(p == nullptr || (on(*p,s)&&on(*p,t)))ret = p;\n\telse{\n\t\tdelete p;\n\t\tret = nullptr;\n\t}\n}\n\ninline ld dist(const po &p,const po &q){\n\treturn sqrt((p-q)(p-q));\n}\ninline li perpen(const po &p,const li &l){\n\tli ret;\n\tret.a = l.b;\n\tret.b = -l.a;\n\tret.c = l.a*p.y-l.b*p.x;\n\treturn ret;\n}\ninline po perpen_leg(const po &p,const li &l){\n\tpo ret;\n\tli m = perpen(p,l);\n\tret.x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret.y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n\treturn ret;\n}\ninline ld dist(const po &p,const se &s){\n\tpo h = perpen_leg(p,li(s.fr,s.sc));\n\tif(on(h,s))return dist(p,h);\n\telse return min( dist(p,s.fr) , dist(p,s.sc) );\n}\ninline ld dist(const se &s,const se &t){\n\tpo *p;\n\tintersect(s,t,p);\n\tif(p != nullptr){\n\t\tdelete p;\n\t\treturn 0.0;\n\t}\n\tld ret = min( dist(s.fr,t) , dist(s.sc,t) );\n\tret = min( ret , min( dist(t.fr,s) , dist(t.sc,s) ) );\n\treturn ret;\n}\n\nint main(){\n\tint n,m,l;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n == 0)break;\n\t\tstatic ld d[102][102];\n\t\tstatic po p[102];\n\t\tstatic ld a[102],r[102];\n\t\trep1(i,n){\n\t\t\tp[i].in();\n\t\t\tscanf(\"%Lf%Lf\",&a[i],&r[i]);\n\t\t}\n\t\tstatic po ver[102][5];\n\t\trep1(i,n){\n\t\t\trep(j,5){\n\t\t\t\tver[i][j] = p[i]+r[i]*po(cos(2.0*PI*(72.0*2*j+a[i]+90.0)/360.0),sin(2.0*PI*(72.0*2*j+a[i]+90.0)/360.0));\n\t\t\t}\n\t\t}\n\t\trep1(i,n)rep1(j,n){\n\t\t\tif(i == j){\n\t\t\t\td[i][j] = 0.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[i][j] = 10000.0;\n\t\t\trep(k,5)rep(h,5)d[i][j] = min( d[i][j] , dist(se(ver[i][k],ver[i][(k+1)%5]),se(ver[j][h],ver[j][(h+1)%5])) );\n\t\t}\n\t\trep1(k,n)rep1(i,n)rep1(j,n)d[i][j] = min( d[i][j] , d[i][k]+d[k][j] );\n\t\tprintf(\"%.20lf\\n\",(double)d[m][l]);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS and\n            cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n}\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n    if(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n    return dist_line_and_point(a1,a2,b);\n}\n\ndouble dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){\n    if(is_intersected_linesegment(a1,a2,b1,b2)) return 0;\n    return min(min(dist_linesegment_and_point(a1,a2,b1),\n                   dist_linesegment_and_point(a1,a2,b2)),\n               min(dist_linesegment_and_point(b1,b2,a1),\n                   dist_linesegment_and_point(b1,b2,a2)));\n}\n\nstruct Star{\n    point p;\n    double a;\n    double r;\n    vector<point> ps;\n    Star(double x,double y,double a,double r) : p(x,y),a(a),r(r) {\n        for(int i=0;i<5;i++){\n            ps.push_back(p+polar(r,M_PI * (0.4*i + 0.1 + (a / 180))));\n        }\n    }\n};\n\nconst double INF = 1e10;\ndouble dist_stars(Star a,Star b){\n    double ret = INF;\n    for(int i=0;i<5;i++){\n        for(int j=i+1;j<5;j++){\n            for(int k=0;k<5;k++){\n                for(int l=k+1;l<5;l++){\n                    ret = min(ret,dist_linesegment_and_linesegment(a.ps[i],a.ps[j],b.ps[k],b.ps[l]));\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    while(true){\n        int N,M,L;\n        cin >> N >> M >> L;\n        if(N == 0 and M == 0 and L == 0) break;\n        vector<Star> stars;\n        vector<vector<double> > dist(N,vector<double>(N,INF));\n\n        for(int i=0;i<N;i++){\n            double x,y,a,r;\n            cin >> x >> y >> a >> r;\n            stars.push_back(Star(x,y,a,r));\n        }\n        for(int i=0;i<N;i++){\n            for(int j=i;j<N;j++){\n                dist[i][j] = dist[j][i] = dist_stars(stars[i],stars[j]);\n            }\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        cout << dist[M-1][L-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\n  while( true ) {\n\n    long long int n, m, l;\n    cin >> n >> m >> l;\n    if ( n == 0 ) break;\n\n    vector< long long int > x, y, a, r;\n\n    for ( long long int i = 0; i < n; i++ ) {\n\n      long long int in_x, in_y, in_a, in_r;\n      cin >> in_x >> in_y >> in_a >> in_r;\n      x.push_back( in_x );\n      y.push_back( in_y );\n      a.push_back( in_a );\n      r.push_back( in_r );\n\n    }\n\n    double len[101][101];\n\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tlen[i][j] = -1.00;\n      }\n      for ( long long int p = 0; p < 5; p++ ) {\n\tdouble ang = M_PI * ( a[i] + p * 72 + 90 ) / 180;\n\tdouble x0 = 1.00 * r[i] * cos( ang ) + x[i];\n\tdouble y0 = 1.00 * r[i] * sin( ang ) + y[i];\n\tfor ( long long int j = 0; j < n; j++ ) {\n\t  for ( long long int q = 0; q < 5; q++ ) {\n\t    double ang = M_PI * ( a[j] + q * 72 + 90 ) / 180;\n\t    double x1 = 1.00 * r[j] * cos( ang ) + x[j] - x0;\n\t    double y1 = 1.00 * r[j] * sin( ang ) + y[j] - y0;\n\t    double k = sqrt( x1 * x1 + y1 * y1 );\n\t    if ( len[i][j] < 0 ) {\n\t      len[i][j] = k;\n\t    }else {\n\t      len[i][j] = min( len[i][j], k );\n\t    }\n\t  }\n\t}\n      }\n    }\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tfor ( long long int k = 0; k < n; k++ ) {\n\t  len[i][j] = min( len[i][j], len[i][k] + len[k][j] );\n\t}\n      }\n    }\n\n    cout << fixed << setprecision(10) << len[m-1][l-1] << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-10;\ndouble add(double a,double b){\n    if(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\n\nconst double pi=acos(-1);\nint main(){\n    int n,s,t;\n    vector<double> ans;\n    while(cin>>n>>s>>t){\n        if(n==0)break;\n        P x[n][5];\n        rep(i,n){\n            P c;\n            cin>>c.first>>c.second;\n            double a,b;\n            cin>>a>>b;\n            a*=pi/180;\n            rep(j,5){\n                P y;\n                y={-sin(a+2.0/5.0*j*pi),cos(a+2.0/5.0*j*pi)};\n                x[i][j]=c+y*b;\n            }\n        }\n        double d[n][n];\n        rep(i,n)rep(j,n)d[i][j]=inf;\n        rep(i,n)d[i][i]=0;\n        rep(i,n)rep(j,n){\n            if(i==j)continue;\n            rep(k,5)rep(l,5){\n                d[i][j]=min(d[i][j],dist(x[i][k],x[i][(k+2)%5],x[j][l]));\n                if(cross(x[i][k],x[i][(k+2)%5],x[j][l],x[j][(l+2)%5]))d[i][j]=0;\n            }\n        }\n        rep(i,n)rep(j,n)d[i][j]=min(d[i][j],d[j][i]);\n        rep(i,n)rep(j,n)rep(k,n)d[j][k]=min(d[j][k],d[i][j]+d[i][k]);\n        cout<<fixed<<setprecision(12)<<d[m-1][l-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n, si, ti; cin >> n >> si >> ti, --si, --ti;\n    if (!n) break;\n    VV<L> ss(n);\n    for (int i = 0; i < n; ++i) {\n      P o; cin >> o;\n      R th; cin >> th, th = pi / 180 * (th + 90);\n      R r; cin >> r;\n      for (int j = 0; j < 5; ++j) {\n        auto p = o + r * polar<R>(1, th + 0.4 * pi * j);\n        auto q = o + r * polar<R>(1, th + 0.4 * pi * (j + 2));\n        ss[i].emplace_back(L{p, q});\n      }\n    }\n    VV<R> d(n, V<R>(n, 1e10));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n      for (int ki = 0; ki < 5; ++ki) for (int kj = 0; kj < 5; ++kj) {\n        d[i][j] = min(d[i][j], distSS(ss[i][ki], ss[j][kj]));\n      }\n    }\n    for (int k = 0; k < n; ++k) for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n      d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    }\n    cout << fixed << setprecision(15) << d[si][ti] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\nstruct Point{double x,y;};\nint main(){\n  double a,b,c,d;\n  int n,ve,al;\n  while(cin>>n>>ve>>al,n){\n    Point p[n][5];\n    r(i,n){\n      cin>>a>>b>>c>>d;\n      r(j,5){\n        p[i][j].x=a+d*sin(M_PI/180*72*j+c);\n        p[i][j].y=b+d*cos(M_PI/180*72*j+c);\n      }\n    }\n    double w[n][n];\n    r(i,n)r(j,n)w[i][j]=i==j?0:1000000000;\n    r(i,n)R(j,i+1,n){\n      double t=1000000000;\n      r(k,5)r(l,5)t=min(t,sqrt(pow(p[i][k].x-p[j][l].x,2)+pow((p[i][k].y-p[j][l].y),2)));\n      w[i][j]=w[j][i]=t;cout<<t<<endl;\n    }\n    r(k,n)r(i,n)r(j,n)w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    printf(\"%.11f\\n\",w[ve-1][al-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > DBL_EPSILON)\n\t\treturn 1;\n\tif (cross(b, c) < -DBL_EPSILON)\n\t\treturn -1;\n\tif (dot(b, c) < -DBL_EPSILON)\n\t\treturn 2;\n\tif (norm(b) < norm(c) - DBL_EPSILON)\n\t\treturn 2;\n\treturn 0;\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\ndouble DistanceSP(P a, P b, P c) {\n\tif (dot(b - a, c - a) < DBL_EPSILON)\n\t\treturn abs(c - a);\n\tif (dot(a - b, c - b) < DBL_EPSILON)\n\t\treturn abs(c - b);\n\treturn abs(cross(b - a, c - a));\n}\ndouble DistaiceSS(P a, P b, P c, P d) {\n\tif (isIntersectSS(a, b, c, d)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a, b, c), DistanceSP(a, b, d)),\n\t\t\tmin(DistanceSP(c, d, a), DistanceSP(c, d, b)));\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta = M_PI / 2 + 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta), p.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\nvector<pair<int,int> > edges;\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(edge,edges){\n\t\tP a1=p1.vertex[(*edge).first];\n\t\tP a2=p1.vertex[(*edge).second];\n\t\tforeach(edgeb,edges){\n\t\t\tP b1=p2.vertex[(*edgeb).first];\n\t\t\tP b2=p2.vertex[(*edgeb).second];\n\t\t\tm = min(m, DistaiceSS(a1, a2, b1, b2));\n\t\t}\n\n\t}\n\treturn m;\n}\nint x, y, a, r;\n\ndouble dijk(int start, int goal) {\n\tvector<double> memo(N, DBL_MAX);\n\tpriority_queue<pair<double,int> > up;\n\tup.push(make_pair(0, start));\n\tmemo[start] = 0;\n\twhile (!up.empty()) {\n\t\tdouble cost = -up.top().first;\n\t\tint pos = up.top().second;\n\n\t\tup.pop();\n\t\tif (memo[pos] < cost)\n\t\t\tcontinue;\n\t\tif (pos == goal)\n\t\t\treturn cost;\n\t\tREP0(next,N) {\n\t\t\tif (links[pos][next] >= 0) {\n\t\t\t\tdouble ncost = cost + links[pos][next];\n\t\t\t\tif (memo[next] > ncost) {\n\t\t\t\t\tmemo[next] = ncost;\n\t\t\t\t\tup.push(make_pair(-ncost, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tedges.push_back(make_pair(0,2));\n\tedges.push_back(make_pair(0,3));\n\tedges.push_back(make_pair(1,4));\n\tedges.push_back(make_pair(1,3));\n\tedges.push_back(make_pair(2,4));\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tcout << dijk(M - 1, L - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.1415926535897932384626433832795028841971\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvector<P> f(double x, double y, double a, double r){\n    \n    vector<P> ret(5);\n    P vec = P(0.0, r);\n    P add = P(x, y);\n    // a度 左に回転\n    P t = P(cos(a * PI / 180.0), sin(a * PI / 180.0));\n    vec = vec * t;\n    ret[0] = vec + add;\n    t = P(cos(72.0 * PI / 180.0), sin(72.0 * PI / 180.0));\n    for(int i = 1; i < 5; i++){\n        vec = vec * t;\n        ret[i] = vec + add;\n    }\n\n    return ret;\n}\n\ndouble dis(vector<P> a, vector<P> b){\n    double ret = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            ret = min(ret, distance_ls_p(a[i], a[(i + 2) % 5], b[j]));\n            ret = min(ret, distance_ls_p(b[j], b[(j + 2) % 5], a[i]));\n        }\n    }\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<P> > v(n, vector<P> (5));\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            v[i] = f(x, y, a, r);\n        }\n    \n\n        vector<vector<double> > g(n, vector<double> (n, INF));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                g[i][j] = min(g[i][j], dis(v[i], v[j]));\n            }\n        }\n\n       for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n\n        printf(\"%.14f\\n\", g[m - 1][n - 1]);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n\n#define ARG5(a, b, c, d, NAME, ...) NAME\n#define REP(...) ARG5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define REP1(a) REP2(i, a)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) ARG5(__VA_ARGS__, REPR4, REPR3, REPR2, REPR1)(__VA_ARGS__)\n#define REPR1(a) REPR2(i, a)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')\n#define TMPL_T template <typename T>\n#define TMPL_TU template <typename T, typename U>\n#define mut auto\n#define let const auto\n\nusing Int = long long;\n// clang-format off\nnamespace extio {\nstd::string delimiter=\" \",pdelimiter=\" \";\nstd::string bracket_b=\"\",bracket_e=\"\";\nvoid chdelim(const std::string&s){delimiter=s;}\nvoid chpdelim(const std::string&s){pdelimiter=s;}\nvoid chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}\nTMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}\nTMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}\n}\nnamespace std {\nTMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}\nTMPL_T istream& operator>>(istream&is,tuple<int&,vector<T>&>x)\n{int N=get<0>(x);vector<T>&v=get<1>(x);v.clear();v.reserve(N);REP(i,N){T a;is>>a;v.emplace_back(a);}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<vector<T>&,int&>x){return is>>tie(get<1>(x),get<0>(x));}\nTMPL_T istream& operator>>(istream&is,tuple<int&,T*>x){int N=get<0>(x);T*v=get<1>(x);REP(i,N){is>>v[i];}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<T*,int&>x){return is>>tie(get<1>(x),get<0>(x));}\n}\nTMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\nTMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\n\ninline int in(){int x;std::cin>>x;return x;}\n\n// clang-format on\n// }}}\n\n//{{{ orliv::graph::Graph\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <limits>\n#include <vector>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  using weight_type = double;\n  static constexpr weight_type INF = std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\nusing Weight = Edge::weight_type;\nusing Edges = std::vector<Edge>;\nusing Weights = std::vector<Weight>;\nusing Path = std::vector<int>;\nusing Nodes = std::vector<int>;\n}\nusing Graph = std::vector<graph::Edges>;\n}\n#endif\n//}}}\n//{{{ dijkstra.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n#include <algorithm>\n#include <limits>\n#include <queue>\nnamespace orliv {\nnamespace graph {\nnamespace shortest_path {\nnamespace util {\nPath buildPath(int t, std::vector<int>& prev) {\n  Path path;\n  for (int u = t; u >= 0; u = prev[u]) {\n    path.emplace_back(u);\n  }\n  std::reverse(path.begin(), path.end());\n  return std::move(path);\n}\n}\nWeights dijkstra(const Graph& g, int s, std::vector<int>& prev) {\n  const int V = g.size();\n  auto inf = Edge::INF;\n  Weights dist(V, inf);\n  prev.assign(V, -1);\n\n  dist[s] = 0;\n  std::priority_queue<Edge> pq;\n  for (pq.emplace(-2, s, 0); !pq.empty();) {\n    auto e = pq.top();\n    pq.pop();\n    if (prev[e.to] != -1) continue;\n    prev[e.to] = e.from;\n    for (const auto& f : g[e.to]) {\n      if (dist[f.to] <= e.w + f.w) continue;\n      pq.emplace(f.from, f.to, dist[f.to] = e.w + f.w);\n    }\n  }\n  return std::move(dist);\n}\nWeights dijkstra(const Graph& g, int s) {\n  std::vector<int> prev;\n  return std::move(dijkstra(g, s, prev));\n}\nstd::pair<Weight, Path> dijkstra(const Graph& g, int s, int t) {\n  std::vector<int> prev;\n  auto ws = dijkstra(g, s, prev);\n  auto path = util::buildPath(t, prev);\n  return std::move(std::make_pair(ws[t], std::move(path)));\n}\n}\n}\n}\n//}}}\n\nusing namespace std;\n\nusing Real = double;\nusing P = std::complex<Real>;\n\nstruct Star {\n  std::vector<P> ps;\n  Star(Real x, Real y, Real a, Real r) {\n    P base(x, y);\n    P p = std::polar(r, (a + 90) / 180.0 * M_PI);\n    P rot = std::polar(1.0, 0.4 * M_PI);\n    REP(5) {\n      ps.emplace_back(p + base);\n      p *= rot;\n    }\n  }\n  Real dist(const Star& other) const {\n    Real d = 1e9;\n    for (let& p : ps) {\n      for (let& q : other.ps) {\n        chmin(d, abs(p - q));\n      }\n    }\n    return d;\n  }\n};\n\nsigned main() {\n  int N, M, L;\n  while (N = in(), M = in(), L = in(), N || M || L) {\n    orliv::Graph g(N);\n    vector<Star> stars;\n    REP(i, N) {\n      Real x = in(), y = in(), a = in(), r = in();\n      stars.emplace_back(x, y, a, r);\n    }\n    REP(i, N) REP(j, N) {\n      if (i == j) continue;\n      g[i].emplace_back(i, j, stars[i].dist(stars[j]));\n    }\n    printf(\"%.20lf\\n\", orliv::graph::shortest_path::dijkstra(g, M - 1, L - 1).first);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\n// ??????????????¢????????????\n\n// ?????°??? ??? ??§??????\ndouble deg2rad(double x) {return x * M_PI / 180.0;}\n\n// ??? a ???????????¨???????????? b ??? z ????????¢???????????¨????????????\nP rotatePoint(P a, P b, double z) {\n    // ?????°????????´????????????\n    z = deg2rad(z);\n\n    b -= a;\n    double rx = b.X * cos(z) - b.Y * sin(z);\n    double ry = b.X * sin(z) + b.Y * cos(z);\n    P ret(rx, ry); ret += a;\n    return ret;\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// ??? a1, a2 ???????????¨??????????????¨??? b ??¨????????¢\ndouble dist_sp(P a1, P a2, P b) {\n    if( dot(a2-a1, b-a1) < EPS ) return abs(b - a1);\n    if( dot(a1-a2, b-a2) < EPS ) return abs(b - a2);\n    return abs( cross(a2-a1, b-a1) ) / abs(a2 - a1);\n}\n\n// ?????? a1, a2 ??¨ ?????? b1, b2 ??¨????????¢\n// Verified: CGL_2_D: Distance\n// isec_ss?????????????????§??????\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\ndouble dist_ss(P a1, P a2, P b1, P b2) {\n    if(isec_ss(a1, a2, b1, b2)) return 0;\n    return min( min(dist_sp(a1, a2, b1), dist_sp(a1, a2, b2)),\n                min(dist_sp(b1, b2, a1), dist_sp(b1, b2, a2)) );\n}\n\nint N, M, LS;\ndouble dist[110][110];\n\nsigned main() {\n    while(cin >> N >> M >> LS, N || M || LS) {\n        M--; LS--;\n        double x, y, a, r;\n        vector<P> ps[110];\n        vector<L> ls[110];\n        rep(i,0,N) {\n            cin >> x >> y >> a >> r;\n            P po = P(x, y), pt = P(x, y+r);\n            pt = rotatePoint(po, pt, a);\n            rep(j,0,5) {\n                double deg = 72.0 * j;\n                ps[i].push_back( rotatePoint(po, pt, deg) );\n            }\n            ls[i].push_back(L(ps[i][0], ps[i][2]));\n            ls[i].push_back(L(ps[i][0], ps[i][3]));\n            ls[i].push_back(L(ps[i][1], ps[i][3]));\n            ls[i].push_back(L(ps[i][1], ps[i][4]));\n            ls[i].push_back(L(ps[i][2], ps[i][4]));\n        }\n\n        rep(i,0,N) rep(j,0,N) {\n            dist[i][j] = INF;\n            rep(x,0,5) rep(y,0,5) {\n                double temp = dist_ss(ls[i][x].first, ls[i][x].second,\n                                      ls[j][y].first, ls[j][y].second);\n                chmin(dist[i][j], temp);\n            }\n        }\n\n        rep(k,0,N) rep(i,0,N) rep(j,0,N) {\n            chmin(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n        printf(\"%.12f\\n\", dist[M][LS]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\n \nconst double INF=1e77;\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n \ntemplate<class T>\nstruct point{\n    T x,y;\n    point operator+(const point &a)const{ point t = {x+a.x,y+a.y}; return t; }\n    point operator-(const point &a)const{ point t = {x-a.x,y-a.y}; return t; }\n};\n \ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){\n\tpoint<T> p = {c*a.x,c*a.y};\n    return p;\n}\n \npoint<double> rot(const point<double> &a,double theta){\n\tpoint<double> p = {a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)};\n\treturn p;\n}\n \ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n};\n \nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n \ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n \ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n \nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW;\n    if(rdir<-EPS) return CW;\n    return ON;\n}\n \nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n \ntemplate<class T>\nT dist2(const point<T> &a,const point<T> &b){\n    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n \ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n \ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n \nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        m--;\n        l--;\n \n        star S[100];\n        rep(i,n){\n            scanf(\"%lf%lf%lf%lf\",&S[i].c.x,&S[i].c.y,&S[i].a,&S[i].r);\n        }\n \n        rep(i,n){\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            rep(j,5) S[i].p[j]=S[i].p[j]+S[i].c;\n        }\n \n        int f1[5]={0,2,4,1,3};\n        int f2[5]={2,4,1,3,0};\n \n        double d[100][100];\n        rep(i,n){\n\t\t\trep(j,n) {\n            d[i][j]=INF;\n            rep(a,5) rep(b,5){\n\t\t\t\tsegment<double> s = {S[i].p[f1[a]],S[i].p[f2[a]]};\n\t\t\t\tsegment<double> t = {S[j].p[f1[b]],S[j].p[f2[b]]};\n\t\t\t\td[i][j]=min(d[i][j],dist(s,t));\n\t\t\t}\n\t\t\t}\n        }\n \n        rep(k,n) rep(i,n) rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n \n        printf(\"%.15f\\n\",d[m][l]);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define FOR(i,a,n) for(int i = (a);i < (n);i++)\nconst double M_PI = acos(-1);\nconst double EPS = 1e-10;\nconst double INF = 1e9;\nusing namespace std;\n\nint N,M,L;\n\nstruct Point{\n    double x,y;\n    Point operator - (const Point& p){ return Point{x-p.x,y-p.y};}\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\ndouble norm(Point a){return a.x*a.x+a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a,Point b){return a.x*b.y - a.y*b.x;}\n\nint ccw(Point p1,Point p2,Point p3){\n    Point a = {p2.x-p1.x, p2.y - p1.y};\n    Point b = {p3.x-p1.x, p3.y - p1.y};\n    if(cross(a,b) > EPS) return 1;\n    if(cross(a,b) < -EPS) return -1;\n    if(dot(a,b) < -EPS) return 2;\n    if(norm(a) < norm(b)) return -2;\n    return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1,s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < -EPS) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < -EPS) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n    \n\nSegment star[102][5];\ndouble mindist[102][102];\n\n\n\ndouble getdist(int u, int v){\n    REP(i,5){\n        REP(j,5){\n            if(intersect(star[u][i],star[v][j])){\n                    return 0;\n            }\n        }\n    }\n    double ans = INF;\n    REP(k,2){\n        if(k) swap(u,v);\n        REP(i,5){\n            REP(j,5){\n                ans = min(getDistSP(star[u][i],star[v][j].p1),ans);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>N>>M>>L,N){\n        REP(i,N){\n            int x,y,a,r;\n            cin>>x>>y>>a>>r;\n            Point p[5];\n            REP(j,5) p[j] = Point{x + r*sin((double)(72*j - a)/180*M_PI), y + r*cos((double)(72*j - a)/180*M_PI)};//star's vertex\n            REP(j,5){\n                star[i][j] = Segment{p[j], p[(j+2)%5]};\n            }\n        }\n\n        //caluculate min distance\n        REP(i,N){\n            FOR(j,i,N){\n                mindist[i][j] = mindist[j][i] = getdist(i,j);\n            }\n        }\n\n        //WF        \n        REP(k,N){\n            REP(i,N){\n                REP(j,N){\n                    mindist[i][j] = min(mindist[i][j], mindist[i][k] + mindist[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(8) << mindist[M-1][L-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.1415926535897932384626433832795028841971\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvector<P> f(double x, double y, double a, double r){\n    \n    vector<P> ret(5);\n    P vec = P(0.0, r);\n    P add = P(x, y);\n    // a度 左に回転\n    P t = P(cos(a * PI / 180.0), sin(a * PI / 180.0));\n    vec = vec * t;\n    ret[0] = vec + add;\n    t = P(cos(72.0 * PI / 180.0), sin(72.0 * PI / 180.0));\n    for(int i = 1; i < 5; i++){\n        vec = vec * t;\n        ret[i] = vec + add;\n    }\n\n    return ret;\n}\n\ndouble dis(vector<P> a, vector<P> b){\n    double ret = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            ret = min(ret, distance_ls_p(a[i], a[(i + 1) % 5], b[j]));\n            ret = min(ret, distance_ls_p(b[j], b[(j + 1) % 5], a[i]));\n        }\n    }\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<P> > v(n, vector<P> (5));\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            v[i] = f(x, y, a, r);\n        }\n    \n\n        vector<vector<double> > g(n, vector<double> (n, INF));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                g[i][j] = min(g[i][j], dis(v[i], v[j]));\n            }\n        }\n\n       for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n\n        printf(\"%.14f\\n\", g[m - 1][n - 1]);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n#include<iomanip>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\ntypedef double Real;\n\nstruct edge {\n    int v;\n    Real w;\n    edge() {}\n    edge(int v, Real w) : v(v), w(w) {};\n};\n\nvector<Real> dijkstra(int n, vector<vector<edge> >& G, int s) {\n    vector<Real> d(n, LLONG_MAX/10); d[s] = 0;\n    priority_queue<pair<Real, int> > que;\n    que.push(make_pair(0, s));\n    while (!que.empty()) {\n        auto p = que.top(); que.pop();\n        int u = p.second;\n        ll dist = -p.first;\n        if (dist > d[u]) continue;\n        for (edge e : G[u]) {\n            if (d[e.v] > d[u]+e.w) {\n                d[e.v] = d[u] + e.w;\n                que.push(make_pair(-d[e.v], e.v));\n            }\n        }\n    }\n    return d;\n}\n\n\nReal eps = 1e-9;\n\nReal add(Real a, Real b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(Real a, Real b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    Real x, y;\n    P() {}\n    P(Real x, Real y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(Real d) const {return P(x*d, y*d);}\n    Real dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    Real det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    Real dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {Real d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\n\n// ??????p1-p2?????????q???????????????????????????\nbool on_seg(P p1, P p2, P q) {\n    return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2??????????????????????????????\nbool parallel(P p1, P p2, P q1, P q2) {\n    P a = p2-p1;\n    P b = q2-q1;\n    return a.det(b) == 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2?????????\nP intersection(P p1, P p2, P q1, P q2) {\n    return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\ninline Real square(Real x) {return x*x;}\n// ??´???p1-p2??¨???q????????¢\nReal dist(P p1, P p2, P q) {\n    q = q-p1;\n    p2 = p2-p1;\n    return sqrt((q.dot(q)*p2.dot(p2) - square(q.dot(p2))) / p2.dot(p2));\n}\n// ??????p1-p2??¨???q????????¢\nReal distSeg(P p1, P p2, P q) {\n    Real d = (q-p1).dot(p2-p1) / p2.dist(p1);\n    if (d < 0) return q.dist(p1);\n    if (d > p2.dist(p1)) return q.dist(p2);\n    return dist(p1, p2, q);\n}\n\n// ??????p1-p2??¨??????q1-q2????????¢\nReal distSeg(P p1, P p2, P q1, P q2) {\n    if (p1==p2 && q1==q2) return q1.dist(p1);\n    if (p1==p2) return distSeg(q1, q2, p1);\n    if (q1==q2) return distSeg(p1, p2, q1);\n    if (!parallel(p1, p2, q1, q2)) {\n        P r = intersection(p1, p2, q1, q2);\n        if (on_seg(p1, p2, r) && on_seg(q1, q2, r)) return 0;\n    }\n    Real ret = min(distSeg(p1, p2, q1), distSeg(p1, p2, q2));\n    ret = min(ret, min(distSeg(q1, q2, p1), distSeg(q1, q2, p2)));\n    return ret;\n}\n\nconst int MAXN = 111;\nconst Real pi = acos(-1);\nint N, M, L;\nvector<P> stars[MAXN];\n\nReal calc(int a, int b) {\n\tReal ans = 1e9;\n\tfor (int i = 0; i < 5; i++) for (int j = 0; j < 5; j++) {\n\t\tint ni = (i+2)%5, nj = (j+2)%5;\n\t\tans = min(ans, distSeg(stars[a][i], stars[a][ni], stars[b][j], stars[b][nj]));\n\t}\n\treturn ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N >> M >> L) {\n    \tif (N==0) break;\n    \tM--; L--;\n    \tfor (int i = 0; i < N; i++) {\n    \t\tint x, y, a, r;\n    \t\tcin >> x >> y >> a >> r;\n    \t\tstars[i].resize(5);\n    \t\tfor (int j = 0; j < 5; j++) {\n    \t\t\tReal angle = (90 + a + j*72) * pi / 180;\n    \t\t\tstars[i][j] = P(x, y) + P(cos(angle), sin(angle)) * r;\n    \t\t}\n    \t}\n    \tvector<vector<edge> > G(N);\n    \tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n    \t\tReal dist = calc(i, j);\n    \t\tG[i].emplace_back(j, dist);\n    \t\tG[j].emplace_back(i, dist);\n    \t}\n    \tauto d = dijkstra(N, G, M);\n    \tcout << setprecision(12) << d[L] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n#define eps 1.0e-9\n\nusing namespace std;\n\ndouble add(double a, double b){\n\t\tif(abs(a+b) < eps * (abs(a) + abs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, ope.x);\n\t\ttmp.y = add(y, ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, -ope.x);\n\t\ttmp.y = add(y, -ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn add(x*ope.y,  -y*ope.x);\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= 0;\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) < 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) < 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+1)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = add(x[i], r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 ) );\n\t\t\t\tstar[i][j].y = add(y[i], r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.12f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const double PI = acos(-1.0);\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nstruct segment\n{\n  P a, b;\n  segment() {}\n  segment(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool intersects(const segment& seg) const\n  {\n    return\n      max(a.real(), b.real()) >= min(seg.a.real(), seg.b.real())\n      && max(seg.a.real(), seg.b.real()) >= min(a.real(), b.real())\n      && max(a.imag(), b.imag()) >= min(seg.a.imag(), seg.b.imag())\n      && max(seg.a.imag(), seg.b.imag()) >= min(a.imag(), b.imag())\n      && cross(seg.b - seg.a, a - seg.a) * cross(seg.b - seg.b, b - seg.a) <= EPS\n      && cross(b - a, seg.a - a) * cross(b - a, seg.b - a) <= EPS;\n  }\n\n  inline double distance(const P& p) const\n  {\n    if (dot(b-a, p-a) < EPS) {\n      return abs(p-a);\n    } else if (dot(a-b, p-b) < EPS) {\n      return abs(p-b);\n    } else {\n      return abs(cross(b-a, p-a))/abs(b-a);\n    }\n  }\n\n  inline double distance(const segment& seg) const\n  {\n    if (intersects(seg)) {\n      return 0;\n    } else {\n      return\n        min(\n            min(distance(seg.a), distance(seg.b)),\n            min(seg.distance(a), seg.distance(b)));\n    }\n  }\n};\n\nstruct star\n{\n  segment segs[5];\n  star(double x, double y, double a, double r) {\n    const P o(x, y);\n    P p(0, r);\n    p *= polar(1.0, a/180.0*PI);\n    const P m = polar(1.0, 72.0/180.0*PI);\n    P ps[5];\n    for (int i = 0; i < 5; i++) {\n      ps[i] = o + p;\n      p *= m;\n    }\n    for (int i = 0, j = 0; i < 5; i++) {\n      segs[i] = segment(ps[j], ps[(j+2) % 5]);\n      j = (j+2) % 5;\n    }\n  }\n\n  double distance(const star& s) const\n  {\n    double ans = 1e10;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        ans = min(ans, segs[i].distance(s.segs[j]));\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF && N != 0) {\n    --M; --L;\n    vector<star> stars;\n    for (int i = 0; i < N; i++) {\n      int x, y, a, r;\n      scanf(\"%d %d %d %d\", &x, &y, &a, &r);\n      stars.push_back(star(x, y, a, r));\n    }\n\n    vector<vector<double> > g(N, vector<double>(N));\n    for (int i = 0; i < N; i++) {\n      for (int j = i+1; j < N; j++) {\n        double d = stars[i].distance(stars[j]);\n        g[i][j] = g[j][i] = d;\n      }\n    }\n    priority_queue<pair<double,int> > q;\n    vector<double> dist(N, 1e10);\n    dist[M] = 0;\n    q.push(make_pair(0.0, M));\n    while (!q.empty()) {\n      const double d = -q.top().first;\n      const int n = q.top().second;\n      q.pop();\n      if (n == L) {\n        printf(\"%.20f\\n\", fabs(d));\n        break;\n      }\n      for (int i = 0; i < N; i++) {\n        if (n == i) {\n          continue;\n        }\n        const double dd = d + g[n][i];\n        if (dd < dist[i]) {\n          dist[i] = dd;\n          q.push(make_pair(-dd, i));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<utility>\n#include<queue>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n); (i)++)\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\ntypedef pair<ld, int> Data;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std\n{\n\tbool operator<(const P &lhs, const P &rhs)\n\t{\n\t\treturn lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n\t\t\t: lhs.real() < rhs.real();\n\t}\n}\n\nstruct L{ P a, b; };\nstruct C { P p; ld r; };\n\n// counter clockwise\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\n// Intersect\n\nbool isis_ll(L l, L m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s)\n{\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p)\n{\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t)\n{\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n/*bool isis_ss(L s, L t) {\nif (abs(cross(s.b - s.a, t.b - t.a)) < eps) return false;\nP p = is_ll(s, t);\nreturn isis_sp(s, p) && isis_sp(t, p);\n}*/\n\nbool isis_sp(L s, P p)\n{\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p)\n{\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nP mirror(L l, P p)\n{\n\treturn (ld)2 * proj(l, p) - p;\n}\n\nP is_ll(L s, L t)\n{\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(L l, P p)\n{\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p)\n{\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t)\n{\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2)\n{\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc)\n{\n\tVP crs;\n\tint n = vc.size();\n\tREP(i, n)REP(j, i)\n\tfor (P p : is_cc(vc[i], vc[j]))\n\t\tcrs.push_back(p);\n\tREP(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs)\n\t{\n\t\tbool valid = true;\n\t\tREP(i, n)\n\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l)\n{\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps)\n\t{\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l)\n{\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p)\n{\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2)\n{\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps)\n\t{\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps)\n\t{\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse\n\t{\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L { q1, q1 + v });\n\t\tret.push_back(L { q2, q2 + v });\n\t}\n\treturn ret;\n}\n\n\nstruct star\n{\n\tL e[5];\n};\n\nint main()\n{\n\tint n, m, l;\n\twhile (cin >> n >> m >> l && n)\n\t{\n\t\tm--; l--;\n\t\tvector<star> stars(n);\n\t\tfor (int i = 0; i<n; i++)\n\t\t{\n\t\t\tld x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ta = a * pi / 180.0;\n\t\t\tP center(x, y);\n\t\t\tld cos72 = cos(72 * pi / 180.0), sin72 = sin(72 * pi / 180.0);\n\t\t\tld cosa = cos(a), sina = sin(a);\n\t\t\tP d(-r * sina, r * cosa);\n\t\t\tP points[5];\n\t\t\tfor (int j = 0; j<5; j++)\n\t\t\t{\n\t\t\t\tpoints[j] = center + d;\n\t\t\t\td = P(d.real()*cos72 - d.imag()*sin72,\n\t\t\t\t\td.real()*sin72 + d.imag()*cos72);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t{\n\t\t\t\tstars[i].e[j] = L({ points[j % 5], points[(j + 1) % 5] });\n\t\t\t}\n\t\t}\n\t\tld wf[101][101];\n\t\tconst ld INF = 1e20;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\twf[i][j] = (i == j ? 0 : INF);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i<n - 1; i++) for (int j = i + 1; j<n; j++)\n\t\t{\n\t\t\tstar s1 = stars[i], s2 = stars[j];\n\t\t\tld dist = INF;\n\t\t\tfor (int p = 0; p < 5; p++) for (int q = 0; q < 5; q++)\n\t\t\t{\n\t\t\t\tdist = min(dist, dist_ss(s1.e[p], s2.e[q]));\n\t\t\t}\n\t\t\twf[i][j] = wf[j][i] = dist;\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(20) << wf[m][l] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n#define eps 1.0e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tdouble add(double a, double b){\n\t\tif(abs(a+b) < eps * (abs(a) + abs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, ope.x);\n\t\ttmp.y = add(y, ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, -ope.x);\n\t\ttmp.y = add(y, -ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn add(x*ope.y,  -y*ope.x);\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= eps;\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) < 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) < 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+1)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.12f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "1 1 1\n5 5 0 5\n2 1 2\n5 5 0 5\n15 5 0 5\n3 2 3\n15 15 0 5\n5 5 10 5\n25 25 20 5\n0 0 0\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n\n\nusing namespace std;\n\n#define rep(i,n) for(i=0;i<n;i++)\n#define pow2(n) ((n)*(n))\n\n\nconst double pi=3.141592653589793;\n\ntypedef pair <double,int> P;\npriority_queue<P,vector<P>,greater<P> > Q;\n\ndouble star[500][2];\ndouble S[500][500];\n\ndouble R[500];\n\nconst double DINF = 1.0e+21;\n\n\nint main(void)\n{\n\twhile(1){\n\t\tint N,M,L;\n\t\tint x,y,a,r;\n\t\tint i,j;\n\t\tdouble l,sita,cost;\n\t\tP p;\n\t\t\n\t\tdouble x1,x2,x3,x4,y1,y2,y3,y4,ta,tb,tc,td;\n\t\t\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\t\n\t\trep(i,5*N)R[i]=DINF;\n\t\t\n\t\tif(N==0 && M==0 && L==0)return 0;\n\t\t\n\t\trep(i,N){\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&a,&r);\n\t\t\trep(j,5){\n\t\t\t\tsita=((90+a+72*j)%360)*pi/180;\n\t\t\t\t\n\t\t\t\tstar[i*5+j][0]=x+r*cos(sita);\n\t\t\t\tstar[i*5+j][1]=y+r*sin(sita);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t//rep(i,N)rep(j,5)printf(\"$  %d,%d :%lf,%lf  [%lf]\\n\",i,j,star[i*5+j][0],star[i*5+j][1],star[i*5+j][0]*star[i*5+j][0]+star[i*5+j][1]*star[i*5+j][1]);\n\t\t\n\t\t\n\t\t\n\t\trep(i,5*N){\n\t\t\trep(j,5*N){\n\t\t\t\tif(i/5 == j/5){\n\t\t\t\t\tS[i][j]=S[j][i] = 0.0;continue;\n\t\t\t\t}\n\t\t\t\tl=sqrt(pow2(star[i][0]-star[j][0])+pow2(star[i][1]-star[j][1]));\n\t\t\t\tS[i][j]=S[j][i] = l;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t//rep(i,N*5)rep(j,N*5)printf(\"#  %d~%d :%lf\\n\",i,j,S[i][j]);\n\t\t\n\t\trep(i,5*N){\n\t\t\trep(j,5*N){\n\t\t\t\tif(i/5 == j/5)continue;\n\t\t\t\t\n\t\t\t\tbool intersectionEX=true;\n\t\t\t\t\n\t\t\t\tif(x1 >= x2){\n\t\t     \t\t\tif(((x1 < x3 && x1 < x4) || (x2 > x3 && x2 > x4))){\n\t\t\t    \t\t\tintersectionEX = false;\n\t\t\t\t\t}\n\t\t    \t\t}else{\n\t\t\t\t\tif((x2 < x3 && x2 < x4) || (x1 > x3 && x1 > x4)){\n\t\t\t    \t\t\tintersectionEX = false;\n\t\t\t\t\t}\n\t\t   \t\t}\n\t\t\t   \tif(intersectionEX){\n\t\t\t    \t\tif(y1 >= y2){\n\t\t\t\t\t\tif((y1 < y3 && y1 < y4) || (y2 > y3 && y2 > y4)){\n\t\t\t\t    \t\t\tintersectionEX = false;\n\t\t\t\t\t\t}\n\t\t\t    \t\t}else{\n\t\t\t\t\t\tif ((y2 < y3 && y2 < y4) || (y1 > y3 && y1 > y4)){\n\t\t\t\t    \t\t\tintersectionEX = false;\n\t\t\t\t\t\t}\n\t\t\t    \t\t}\n\t\t    \t\t}\n\t\t    \t\tif(intersectionEX){\n\t\t    \t\t\tif (((x1 - x2) * (y3 - y1) + (y1 - y2) * (x1 - x3)) * ((x1 - x2) * (y4 - y1) + (y1 - y2) * (x1 - x4)) > 0.0){\n\t\t\t\t\t\tintersectionEX = false;\n\t\t    \t\t\t}\n\t\t    \t\t\tif (((x3 - x4) * (y1 - y3) + (y3 - y4) * (x3 - x1)) * ((x3 - x4) * (y2 - y3) + (y3 - y4) * (x3 - x2)) > 0.0){\n\t\t\t\t\t\tintersectionEX = false;\n\t\t    \t\t\t}\n\t\t    \t\t}\n\t\t    \t\t//intersectionEX = True\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tx1 = star[i][0];\n\t\t\t\ty1 = star[i][1];\n\t\t\t\t\n\t\t\t\tx2 = star[i/5+ (i+2)%5][0];\n\t\t\t\ty2 = star[i/5+ (i+2)%5][1];\n\t\t\t\t\n\t\t\t\tx3 = star[j][0];\n\t\t\t\ty3 = star[j][1];\n\t\t\t\t\n\t\t\t\tx4 = star[j/5+ (j+2)%5][0];\n\t\t\t\ty4 = star[j/5+ (j+2)%5][1];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tta=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\t\t\ttb=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\t\t\ttc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\t\t\ttd=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\t\t\n\t\t\t\t*/\n\t\t\t\tif(intersectionEX== false){\n\t\t\t\t\t//printf(\" cross(%d,%d)(%lf,%lf,%lf,%lf) %lf\\n\",i,j,ta,tb ,tc,td,S[i][j]);\n\t\t\t\t\tS[i][j]=S[j][i] = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t//rep(i,N*5)rep(j,N*5)printf(\"#  %d~%d :%lf\\n\",i,j,S[i][j]);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\trep(i,5){\n\t\t\tQ.push(P(0.0,(M-1)*5+i));\n\t\t}\n\t\t\n\t\t\n\t\twhile(!Q.empty()){\n\t\t\tp = Q.top();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\t//printf(\"#\");\n\t\t\tif(R[p.second]<=p.first)continue;\n\t\t\t//printf(\"%lf %d\\n\",p.first,p.second);\n\t\t\t\n\t\t\tR[p.second]=p.first;\n\t\t\t\n\t\t\trep(i,5*N){\n\t\t\t\tcost=p.first + S[p.second][i];\n\t\t\t\tif(R[i]<=cost)continue;\n\t\t\t\t//printf(\"push %lf %d\\n\",cost,i);\n\t\t\t\tQ.push(P(cost,i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lf\\n\",R[(L-1)*5]);\n\t\t\n\n\t}\n\treturn 0;\n}\n\n\n\n\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-8f;\nconst double PI = acos(-1.0);\ntypedef complex<double> P;\n\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} };\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\ndouble distLP(L l, P p){\n\tif(dot(l.q-l.p,p-l.p)<-EPS) return abs(p-l.p);\n\tif(dot(l.p-l.q,p-l.q)<-EPS) return abs(p-l.q);\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\nint main(){\n\tint N, s, g;\n\tdouble dist[100][100];\n\twhile(cin >> N >> s >> g && N){\n\t\tvector< vector<P> > vp(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tint x, y, a, r; cin >> x >> y >> a >> r;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tdouble angle = (90+a+72*j)*PI/180;\n\t\t\t\tvp[i].push_back(P(x+r*cos(angle),y+r*sin(angle)));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdist[i][i] = 0;\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tdist[i][j] = 1e12;\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\t\tdist[i][j] = min(dist[i][j], distLP(L(vp[i][k], vp[i][(k+2)%5]), vp[j][l]));\n\t\t\t\t\t\tdist[i][j] = min(dist[i][j], distLP(L(vp[j][k], vp[j][(k+2)%5]), vp[i][l]));\n\t\t\t\t\t\tif(ssIntersect(L(vp[i][k], vp[i][(k+2)%5]), L(vp[j][l], vp[j][(l+2)%5]))){\n\t\t\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++) dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", dist[s-1][g-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn s.a + (s.b - s.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\nconst double alpha = 72.0 / 180.0 * M_PI;\nstruct star {\n\tvector<segment> seg;\n\tstar(int x, int y, int a, int r) {\n\t\tvector<point> points;\n\t\tpoints.push_back(rotate(point(0, r), a / 180.0 * M_PI));\n\t\tfor(int i = 1; i < 5; ++i)\n\t\t\tpoints.push_back(rotate(points[i - 1], alpha));\n\n\t\tconst point margin(x, y);\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tpoints[i] = points[i] + margin;\n\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tseg.push_back(segment(points[i], points[(i + 2) % 5]));\n\t}\n};\n\nconst double INF = 10000.0;\n\ndouble dist(const star& s, const star& t) {\n\tdouble res = INF;\n\tfor(int i = 0; i < 5; ++i)\n\t\tfor(int j = 0; j < 5; ++j)\n\t\t\tchmin(res, dist(s.seg[i], t.seg[i]));\n\n\treturn res;\n}\n\nint n;\ndouble mat[100][100];\ndouble dijkstra(const int s, const int t) {\n\tvector<double> d(n, INF);\n\tvector<bool> used(n, false);\n\td[s] = 0;\n\n\tfor(;;) {\n\t\tint v = -1;\n\t\tfor(int u = 0; u < n; ++u)\n\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))\n\t\t\t\tv = u;\n\n\t\tif(v == t)\n\t\t\treturn d[t];\n\n\t\tused[v] = true;\n\t\tfor(int u = 0; u < n; ++u)\n\t\t\tchmin(d[u], d[v] + mat[v][u]);\n\t}\n}\n\n\nint main() {\n\tfor(int m, l; scanf(\"%d %d %d\", &n, &m, &l), n;) {\n\t\t--m; --l;\n\t\tvector<star> stars;\n\t\tstars.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(star(x, y, a, r));\n\t\t}\n\n\t\tmemset(mat, 0, sizeof(mat));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst double d = dist(stars[i], stars[j]);\n\t\t\t\tmat[i][j] = mat[j][i] = d;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.7lf\\n\", dijkstra(m, l));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<complex>\nusing namespace std;\ndouble x[100][5];\ndouble y[100][5];\ndouble abs(double a){return max(-a,a);}\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nP wolf[100][5];\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble dist[100][100];\ndouble PI=3.14159265359;\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tdouble p,q,r,s;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&p,&q,&s,&r);\n\t\t\tx[i][0]=p-r*sin(s*PI/180);\n\t\t\tx[i][1]=p-r*sin((s+144)*PI/180);\n\t\t\tx[i][2]=p-r*sin((s+288)*PI/180);\n\t\t\tx[i][3]=p-r*sin((s+72)*PI/180);\n\t\t\tx[i][4]=p-r*sin((s+216)*PI/180);\n\t\t\ty[i][0]=q+r*cos(s*PI/180);\n\t\t\ty[i][1]=q+r*cos((s+144)*PI/180);\n\t\t\ty[i][2]=q+r*cos((s+288)*PI/180);\n\t\t\ty[i][3]=q+r*cos((s+72)*PI/180);\n\t\t\ty[i][4]=q+r*cos((s+216)*PI/180);\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tdist[i][j]=INF;\n\t\tfor(int i=0;i<a;i++)dist[i][i]=0;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\twolf[i][j]=P(x[i][j],y[i][j]);\n\t\t\t//\tprintf(\"%d,%d: %f %f\\n\",i,j,x[i][j],y[i][j]);\n\t\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tfor(int k=0;k<5;k++)\n\t\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\t//\tL wolf(P());\n\t\t\t\t\t\tdist[i][j]=min(dist[i][j],distanceSS(L(wolf[i][k],wolf[i][(k+1)%5]),L(wolf[j][l],wolf[j][(l+1)%5])));\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)\n\t\t\tfor(int i=0;i<a;i++)\n\t\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\tprintf(\"%.8f\\n\",dist[b-1][c-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tP pt[100][5];\n        for (int i = 0; i < n; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(0.0,r),alpha);\n            }\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n   \n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    segment<double> s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    segment<double> t(pt[j][f1[a]],pt[j][f1[a+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\n// ?????????????????´???\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(0, 0), b(0, 0) {}\n\tLine(Point _a, Point _b) : a(_a), b(_b) {}\n};\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c??????????¨???¨???\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b????????§??´???\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c???????????´???\n\treturn 0;\t\t\t\t\t\t\t// a,c,b???????????´???\n}\n\n// ?????´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ??´????????????????????¨??????????????????\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\n// ???????????????????????¨??????????????????\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\n// ???????????´????????????????????????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(15);\n\tcin.sync_with_stdio(false);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<vector<Line>> segd(N, vector<Line>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tsegd[i][j] = Line(seg[i][j], seg[i][(j + 1) % 10]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[j][i] = dis[i][j] = min(dis[i][j], dist_ss(segd[i][ii], segd[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n  \nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( complex<double> a, complex<double> b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(complex<double> p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distancion(L,L); //線分:線分の距離(iteratorのdistanceと被るから留意)\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n  \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\n \ntypedef pair< double , int > Pi;\ndouble info[100][100];\nint n, m, l;\nL stars[100][5];\n \nvoid add( int x, int y, int a, int r, const int z){\n  G hosi(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[z][i] = L( hosi[i * 2 % 5], hosi[(i + 1) * 2 % 5]);\n  }\n}\ndouble dist( LLL a, LLL b){\n  double ret = INF;\n  for(int i = 0 ; i < a.size() ; i++ ){\n    for(int j = 0 ; j < b.size() ; j++ ){\n      ret = min( ret, distancion( a[i], b[i]));\n    }\n  }\n  return ret;\n}\ndouble WF(){\n  for(int k = 0; k < n; k++ ){\n    for(int i = 0; i < n; i++ ){\n      for(int j = 0; j < n; j++ ){\n        info[i][j] = min( info[i][j], info[i][k] + info[k][j]);\n      }\n    }\n  }\n  return info[m][l];\n}\n  \nint main(){\n  while(cin >> n >> m >> l, l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      int x, y, a, r;\n      cin >> x >> y >> a >> r;\n      add( x, y, a, r, i);\n    }\n  \n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    cout << fixed << setprecision(10) << WF() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nint N,M,L;\nvector<Segment>A[100];\ndouble d[100][100];\nmain()\n{\n\twhile(cin>>N>>M>>L,N)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tPoint p;double a,r;cin>>p>>a>>r;\n\t\t\tA[i].clear();\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tA[i].push_back(Segment(p+polar(r,(a+90-72*j)*M_PI/180),\n\t\t\t\t\t\t\t\t\t\tp+polar(r,(a+90-72*j+144)*M_PI/180)));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t{\n\t\t\td[i][j]=1e150;\n\t\t\tfor(Segment a:A[i])for(Segment b:A[j])d[i][j]=min(d[i][j],distance(a,b));\n\t\t}\n\t\tfor(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\tcout<<fixed<<setprecision(9)<<d[M-1][L-1]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define PI M_PI\n#define MAX_N 100\n#define INF 1e9\n\nclass Point{\npublic:\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nclass Segment{\npublic:\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nclass Star : public Point{\npublic:\n  double a,r;\n  vector<Segment> segs;\n  Star(){}\n  Star(Point p,double a,double r) : Point(p),a(a),r(r) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nPoint projection(const Segment &s,const Point &p){\n  Vector b = s.t-s.s;\n  double t = dot(p-s.s,b)/norm(b);\n  return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n  Point r = projection(s,p);\n  if(isIntersectSP(s,r)){ return abs(r-p); }\n  return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment a,const Segment b){\n  if(isIntersectSS(a,b)){ return 0; }\n  return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n             min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nistream &operator >> (istream &is,Star &s){\n  return is >> s.x >> s.y >> s.a >> s.r;\n}\n\ndouble toRad(double ang){ return ang*PI/180.0; }\n\nPoint rotate(const Point &bp,const Point &p,double th){\n  double x = p.x, y = p.y;\n  return Point(cos(th)*x-sin(th)*y+bp.x,sin(th)*x+cos(th)*y+bp.y);\n}\n\nvoid makeStar(vector<Star> &stars){\n  int N = stars.size();\n  for(int i = 0 ; i < N ; i++){\n    double x = stars[i].x, y = stars[i].y;\n    double r = stars[i].r, a = stars[i].a;\n    Point bp(x,y), p(x,y+r); p = p - bp;\n    p = rotate(bp,p,toRad(a));\n    vector<Point> ps(5);\n    for(int j = 0 ; j < 5 ; j++){\n      ps[j] = p;\n      p = p - bp;\n      p = rotate(bp,p,toRad(72));\n    }\n    stars[i].segs.resize(5);\n    stars[i].segs[0] = Segment(ps[0],ps[2]);\n    stars[i].segs[1] = Segment(ps[0],ps[3]);\n    stars[i].segs[2] = Segment(ps[1],ps[3]);\n    stars[i].segs[3] = Segment(ps[1],ps[4]);\n    stars[i].segs[4] = Segment(ps[2],ps[4]);\n  }\n}\n\nint main(){\n  int N,M,L;\n  while(cin >> N >> M >> L, N){\n    vector<Star> stars(N);\n    M--; L--;\n    for(int i = 0 ; i < N ; i++){\n      cin >> stars[i];\n    }\n    makeStar(stars);\n    double d[MAX_N][MAX_N];\n    fill(d[0],d[0]+N*N,INF);\n    for(int i = 0 ; i < N ; i++){\n      d[i][i] = 0;\n      for(int j = i+1 ; j < N ; j++){\n        double dist = INF;\n        for(int k = 0 ; k < 5 ; k++){\n          for(int l = 0 ; l < 5 ; l++){\n            Segment s1 = stars[i].segs[k];\n            Segment s2 = stars[j].segs[l];\n            dist = min(dist,distanceSS(s1,s2));\n          }\n        }\n        d[i][j] = d[j][i] = dist;\n      }\n    }\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\",d[M][L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\nint N,M,L;\n\nint main()\n{\n\tP pt[101][5];\n    while(cin>>N>>M>>L,(N||M||L)){\n        for (int i = 0; i < N; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n   \n\t\tint f1[]={0,2,4,1,3,0};\n\t\tdouble dp[100][100];\n        for(int i = 0; i < N; i++) for (int j = 0; j < N; j++){\n\t\t\tdp[i][j] = 1e100;\n\t\t\tfor (int a = 0; a < 5; a++) for(int b = 0; b < 5; b++){\n\t\t\t\tS s(pt[i][f1[a]], pt[i][f1[a+1]]);\n\t\t\t\tS t(pt[j][f1[a]], pt[j][f1[a+1]]);\n                dp[i][j] = min(dp[i][j],dist(s,t));\n\t\t\t}\n\t\t}\n   \n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++)\n                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n   \n        printf(\"%.15lf\\n\",dp[M - 1][L - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = 1e9;\nconst ld EPS = 1e-8;\n\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N) {\n    M--;\n    L--;\n    vector<vector<Point>> star(N, vector<Point> (5));\n    REP(i,N) {\n      ld x, y, a, r;\n      cin >> x >> y >> a >> r;\n      a *= pi / 180;\n      REP(j,5){\n        star[i][j] = Point(x, y) + r * exp(Point(0,1) * (a + pi / 2 + j * 2 * pi / 5));\n      }\n    }\n\n    vector<vector<ld>> d(N, vector<ld> (N, 0));\n    REP(i,N)REP(j,N){\n      ld tmp = INF;\n      REP(k,5)REP(l,5){\n        Line l1(star[i][k], star[i][(k + 2) % 5]);\n        Line l2(star[j][l], star[j][(l + 2) % 5]);\n        tmp = min(tmp, dist_ss(l1, l2));\n      }\n      d[i][j] = tmp;\n    }\n\n    REP(k,N)REP(i,N)REP(j,N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    cout << fixed << setprecision(10) << d[M][L] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n//for vector\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline D seg_seg_dis(L a,L b){\n  D res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nD g[111][111],d[111];\nL stars[111][5];\nP v[5],c,p;\nint n,m,l,x,y,a,r;\nbool use[111];\n\nint main(){\n  while(scanf(\"%d%d%d\",&n,&m,&l), n){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      c = P(x,y), p = P(0,r);\n      for(int j=0;j<5;j++)v[j] = c+rotate(p,PI*(a+j*72)/180);\n      for(int j=0;j<5;j++)stars[i][j] = L(v[j],v[(j+2)%5]);\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : stars[i]){\n\t  for(L b : stars[j]){\n\t    if(is_cp(a,b)){\n\t      dis = 0;\n\t      break;\n\t    }else dis = min(dis, seg_seg_dis(a,b));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n      g[i][i] = 0;\n    }\n\n    for(int i=0;i<n;i++)d[i] = 1e9;\n    d[m-1] = 0;\n    memset(use,0,sizeof(use));\n\n    for(;;){\n      int v = -1;\n      for(int u=0;u<n;u++){\n\tif(!use[u] && (v<0 || d[v] > d[u]))v = u;\n      }\n\n      if(v<0 || v==l-1)break;\n      use[v] = 1;\n\n      for(int u=0;u<n;u++){\n\td[u] = min(d[u],d[v]+g[u][v]);\n      }\n    }\n\n    printf(\"%.9lf\\n\",d[l-1]);\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef double Weight;\n\nconst double EPS = 1e-9;\nconst double INF = 1e10;\nconst double PI = M_PI;\n\n// 平面の点\nstruct Point {\n    Point(double x, double y) : x(x), y(y) {}\n    Point() {}\n    double x, y;\n};\nPoint operator+(const Point &a, const Point &b) {\n    return Point(a.x + b.x, a.y + b.y);\n}\nPoint operator-(const Point &a, const Point &b) {\n    return Point(a.x - b.x, a.y - b.y);\n}\nPoint operator*(const Point &a, const double b) {\n    return Point(a.x * b, a.y * b);\n}\nPoint rotate(const Point &a, double angle) {\n    return Point(cos(angle) * a.x - sin(angle) * a.y,\n                 sin(angle) * a.x + cos(angle) * a.y);\n}\ndouble cross(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble dot(const Point &a, const Point &b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble atan(const Point &a) {\n    return atan2(a.y, a.x);\n}\ndouble norm(const Point &a) {\n    return dot(a, a);\n}\ndouble abs(const Point &a) {\n    return sqrt(norm(a));\n}\nstruct Line:vector<Point> {\n    Line(Point a = Point(0, 0), Point b = Point(0, 0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\nint ccw(Point a, Point b, Point c) {\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\nPoint projection(const Line &l, const Point &p) {\n\n    double t = dot(p - l[0], l[1]- l[0]) / norm(l[0] - l[1]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nbool is_intersect_SS(const Line &s, const Line &t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nbool is_intersect_SP(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p) == 0;\n}\ndouble distance_SP(const Line &s, const Point &p) {\n    const Point r = projection(s, p);\n    if (is_intersect_SP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distance_SS(const Line &s, const Line &t) {\n    if (is_intersect_SS(s, t)) return 0;\n    return min(min(distance_SP(s, t[0]), distance_SP(s, t[1])),\n               min(distance_SP(t, s[0]), distance_SP(t, s[1])));\n}\n\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int f, int t, Weight c) :\n    src(f), dst(t), weight(c) {}\n};\nbool operator<(const Edge &a, const Edge &b) {\n    return a.weight < b.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n    int n = g.size();\n    vector<Weight> dist(n, INF);\n    vector<int> prev(n, -1);\n    dist[s] = 0;\n    priority_queue<Edge> que;\n\n    for (que.push(Edge(-2, s, 0)); !que.empty();) {\n        Edge e = que.top(); que.pop();\n        if (prev[e.dst] != -1)\n            continue;\n        prev[e.dst] = e.src;\n        for (auto f = g[e.dst].begin(); f != g[e.dst].end(); ++f) {\n            if (dist[f->dst] > e.weight + f->weight) {\n                dist[f->dst] = e.weight + f->weight;\n                que.push(Edge(f->src, f->dst, e.weight + f->weight));\n            }\n        }\n    }\n\n    // for (size_t i = 0; i < dist.size(); ++i)\n    //     cout << dist[i] << \"\\n\";\n\n    // Weight res = INF;\n    // for (int i = 0; i < 5; ++i)\n    //     res = min(res, dist[t + i]);\n\n    return dist[t];\n}\n\nint main()\n{\n    int N, M, L;\n\n    while (cin >> N >> M >> L) {\n        if (N == 0 && M == 0 && L == 0)\n            break;\n        --M, --L;\n\n        vector<Line> line(N * 5);\n        vector<Point> point(N * 5);\n        double x, y, a, r;\n\n        // 星の座標を求める\n        for (int i = 0; i < N; ++i) {\n            cin >> x >> y >> a >> r;\n            Point origin(0, r);\n\n            for (int j = 0; j < 5; ++j) {\n                point[i * 5 + j] = rotate(origin, (72 * j + a) * PI / 180.0)\n                    + Point(x, y);\n            }\n        }\n\n        // 星の線分を求める\n        for (int i = 0; i < 5 * N; i += 5) {\n            line[i] = Line(point[i], point[i + 2]);\n            line[i + 1] = Line(point[i], point[i + 3]);\n            line[i + 2] = Line(point[i + 1], point[i + 3]);\n            line[i + 3] = Line(point[i + 1], point[i + 4]);\n            line[i + 4] = Line(point[i + 2], point[i + 4]);\n        }\n\n        Graph g(5 * N);\n        M *= 5; L *= 5;\n\n        for (int i = 0; i < 5 * N; ++i) {\n            for (int j = 0; j < 5 * N; ++j) {\n                if (i == j)\n                    continue;\n                Weight cost = distance_SS(line[i], line[j]);\n                if (abs(cost) < EPS || i / 5 == j / 5)\n                    cost = 0.0;\n                g[i].push_back(Edge(i, j, cost));\n                g[j].push_back(Edge(j, i, cost));\n            }\n        }\n\n        Weight ans = INF;\n        for (int i = 0; i < 5; ++i)\n            ans = min(ans, Dijkstra(g, M + i, L));\n        printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<tuple>\n#include<complex>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmin(T &l, T r) {\n\tbool res = l > r;\n\tif (res) {\n\t\tl = r;\n\t}\n\treturn res;\n}\n#define IL inline\n#define X real()\n#define Y imag()\n#define fi first\n#define se second\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\ntypedef bool B;\ntypedef double D;\nconst D EPS = 1e-8;\nIL D dot(P a, P b) {\n\treturn a.X*b.X + a.Y*b.Y;\n}\nIL D cross(P a, P b) {\n\treturn a.X*b.Y - a.Y*b.X;\n}\nIL int sgn(P a, P b, P c) {\n\tif (cross(b - a, c - a) > EPS)return 1;\n\tif (cross(b - a, c - a) < -EPS)return -1;\n\tif (dot(b - a, c - a) < -EPS)return 2; // b-a-c\n\tif (dot(a - b, c - b) < -EPS)return -2; // a-b-c\n\treturn 0;\n}\n\n\n\nstruct cww {\n\tcww() {\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t}\n}star;\n\nIL D distance_P_LS(P p, LS ls) {\n\tP a, b, c = p;\n\ttie(a, b) = ls;\n\tif (dot(b - a, c - a) < EPS)return abs(c - a);\n\tif (dot(a - b, c - b) < EPS)return abs(c - b);\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\nIL B is_LS_LS(LS p, LS q) {\n\tP a, b, c, d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\treturn sgn(a, b, c)*sgn(a, b, d) <= 0\n\t\t&& sgn(c, d, a)*sgn(c, d, b) <= 0;\n}\n\nIL D distance_LS_LS(LS p, LS q) {\n\tif (is_LS_LS(p,q))return 0;\n\treturn min({\n\t\tdistance_P_LS(p.fi,q),\n\t\tdistance_P_LS(p.se,q),\n\t\tdistance_P_LS(q.fi,p),\n\t\tdistance_P_LS(q.se,p)\n\t});\n}\n\nP rot(P p, double r) {\n\treturn P(p.X*cos(r) - p.Y*sin(r), p.X*sin(r) + p.Y*cos(r));\n}\n\nconst D PI = acos(-1);\nconst D FI = 72.0 / 180.0*PI;\ntypedef pair<double, int> pp;\nconst int ss[][2] = { { 0,2 },{ 0,3 },{ 1,3 },{ 1,4 },{ 2,4 } };\ntypedef priority_queue<pp, vector<pp>, greater<pp>> QUE;\nint main() {\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tvector<LS> ls(5 * N);\n\t\tREP(i, N) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tP p(x, y);\n\t\t\tvector<P> pt(5);\n\t\t\tpt[0] = rot(P(0, r), a / 180.0*PI);\n\t\t\tREP(i, 4)pt[i + 1] = rot(pt[i], FI);\n\t\t\tREP(j, 5) {\n\t\t\t\tls[i * 5 + j] = LS(p + pt[ss[j][0]], p + pt[ss[j][1]]);\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> dist(N * 5, vector<double>(N * 5));\n\t\tREP(i, 5 * N)REP(j, 5 * N) {\n\t\t\tif (i == j)dist[i][j] = 0;\n\t\t\telse dist[i][j] = distance_LS_LS(ls[i], ls[j]);\n\t\t}\n\t\tint S = 5 * (M - 1);\n\t\tint G = 5 * (L - 1);\n\n\n\n\n\n\t\tvector<double> res(N * 5, 1e18);\n\t\tres[S] = 0;\n\t\tQUE que;\n\t\tque.push(pp(0, S));\n\t\twhile (que.size()) {\n\t\t\tint v; double cost;\n\t\t\ttie(cost, v) = que.top();\n\t\t\tque.pop();\n\t\t\tif (cost > res[v])continue;\n\t\t\tREP(u, 5 * N) if (u != v) {\n\t\t\t\tdouble ncost = cost + dist[u][v];\n\t\t\t\tif (chmin(res[u], ncost))que.push(pp(ncost, u));\n\t\t\t}\n\t\t}\n\t\tcout << res[G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n#define eps 1.0e-10\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tdouble add(double a, double b){\n\t\tif(abs(a+b) < eps * (abs(a) + abs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, ope.x);\n\t\ttmp.y = add(y, ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, -ope.x);\n\t\ttmp.y = add(y, -ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn add(x*ope.y,  -y*ope.x);\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c);\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) < 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) < 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+1)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.12f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\nvector<star> ve;\ndouble w[101][101];\n     signed main(){\nint n;\n     \twhile(1){\n     \tcin>>n;\n     \t\tif(n==0) return 0;\n     \t\t\n     \t\tint s,t;\n     \t\tcin>>s>>t;\n     \t\ts--;\n     \t\tt--;\n     \t\tve.clear();\n     \t\tfor(int i=0;i<n;i++){\n     \t\t\t\n     \t\t\tstar st;\n     \t\t\tdouble x,y,r,a;\n     \t\t\tcin>>x>>y>>r>>a;\n     \t\t\tdouble pi=3.1415926535;\n     \t\t\tr=r/180.0*pi;\n     \t\t\t\n     \t\t\tPoint p[5];\n     \t\t\tfor(int j=0;j<5;j++){\n     \t\t\t\tp[j].x=x-a*sin(r+pi*(j+0.0)/5.0*2.0);\n     \t\t\t\tp[j].y=y+a*cos(r+pi*(j+0.0)/5.0*2.0);\n     \t\t\t\t\n     \t\t//\t\tcout<<p[j].x<<\" \"<<p[j].y<<endl;\n     \t\t\t\n     \t\t\t}\n     \t\t\t\n     \t\t\tst.se[0]={p[0],p[2]};\n     \t\t\tst.se[1]={p[1],p[3]};\n     \t\t\tst.se[2]={p[2],p[4]};\n     \t\t\tst.se[3]={p[3],p[0]};\n     \t\t\tst.se[4]={p[4],p[1]};\n     \t\t\t\n     \t\t\tve.pb(st);\n     \t\t\t\n     \t\t}\n     \t\t\n     \t\t\n     \t\tfor(int i=0;i<100;i++)for(int j=0;j<100;j++)w[i][j]=10000000.0;\n     \t\tfor(int i=0;i<100;i++)w[i][i]=0.0;\n     \t\t\n     \t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n     \t\t\tdouble wer=dist(ve[i],ve[j]);\n   //  \t\t\tcout<<i<<\" \"<<j<<\" \"<<wer<<endl;\n     \t\t\tw[i][j]=wer;\n     \t\t\tw[j][i]=wer;\n     \t\t}\n     \t\t\n     \t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n     \t\t\tw[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n     \t\t}\n     \t\tprintf(\"%.10lf\\n\",w[s][t]);\n     \t\n     \t}\n\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n  \nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( complex<double> a, complex<double> b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(complex<double> p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distancion(L,L); //線分:線分の距離(iteratorのdistanceと被るから留意)\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n  \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\n \ntypedef pair< double , int > Pi;\ndouble used[100];\ndouble info[100][100];\nint n, m, l;\nL stars[100][5];\n \nvoid add( int x, int y, int a, int r, const int z){\n  G hosi(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[z][i] = L( hosi[i * 2 % 5], hosi[(i + 1) * 2 % 5]);\n  }\n}\ndouble dist( LLL a, LLL b){\n  double ret = INF;\n  for(int i = 0 ; i < a.size() ; i++ ){\n    for(int j = 0 ; j < b.size() ; j++ ){\n      ret = min( ret, distancion( a[i], b[i]));\n    }\n  }\n  return ret;\n}\ndouble Dijkstra(){\n  priority_queue< Pi , vector< Pi > , greater< Pi > > que;\n  fill_n( used, 100, INF);\n  que.push( Pi( 0.0, m));\n  used[m] = 0.0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.sc == l) return p.fr;\n    if(used[p.sc] < p.fr) continue;\n    for(int i = 0 ; i < n ; i++ ){\n      if(info[p.sc][i] + p.fr < used[i]){\n        que.push( Pi( info[p.sc][i] + p.fr, i));\n        used[i] = info[p.sc][i] + p.fr;\n      }\n    }\n  }\n}\n  \nint main(){\n  while(cin >> n >> m >> l, l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      int x, y, a, r;\n      cin >> x >> y >> a >> r;\n      add( x, y, a, r, i);\n    }\n  \n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    cout << fixed << setprecision(10) << Dijkstra() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XYツ催?標\n#define X real()\n#define Y imag()\n\n// * ツ点ツづ個表ツ個サ\ntypedef complex<double> P;\n\n// * ツ仰鳴容ツつキツづゥツ古ォツ債キツε?\nconst double EPS = 1e-6;\n// * Infinity\nconst double INF = 1e12;\n// * ツ円ツ偲シツ猟ヲ\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> ツづ個渉?渉伉づーツ津ィツ義ツつキツづゥ\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2ツ点ツ甘板づ個仰猟猟」\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2ツづつづ個スツカツδ可ーツつェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2ツづつづ個ベツクツトツδ仰つェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * ツ禿?静?(dot product) : aツ・b = |a||b|cosツδヲ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * ツ外ツ静?(cross product) : aツ×b = |a||b|sinツδヲ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : ツ板スツ篠楪計ツ嘉アツづィ (Counter Clock Wise)\n// CW : ツ篠楪計ツ嘉アツづィ (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3ツ点ツつェツづ?つソツづァツ嘉アツづィツづ?つ?づゥツつゥツ陛板つキ, 3ツ点ツつェ1ツ陳シツ静シツづ可湘ヲツづ?づ?つ「ツづゥツづ?つォツづ?ON ツづーツ陛板つキ\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : ツ板スツ篠楪計ツ嘉アツづィ\n    if( cross(b,c) < -EPS ) return CW;  // CW : ツ篠楪計ツ嘉アツづィ\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n    return ON;\n}\n\n// ツδ可ジツアツδ督つゥツづァツ度ツ青板づ鳴陛渉環キツつオツづ?陛板つキ\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// ツ度ツ青板つゥツづァツδ可ジツアツδ督づ可陛渉環キツつオツづ?陛板つキ\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// ツ個エツ点ツづーツ篠イツづ可点 p ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// ツ点 a ツづーツ篠イツづ可点 b ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// ツ静シツ閉ェツクツδ可ス\nstruct Segment{\n    P a, b;\n    Segment(P a_, P b_){\n        a = a_; b = b_;\n    }\n    // ツ点 p ツづ?静シツ閉ェツづ個仰猟猟」ツづーツ陛板つキ.\n    double distance(P p){\n        if( dot(b-a,p-a) < EPS ) return abs(p-a);\n        if( dot(a-b,p-b) < EPS ) return abs(p-b);\n        return abs( cross(b-a,p-a) ) / abs(b-a) ;\n    }\n    // ツ静シツ閉ェ s ツづ?古ーツ債キツつオツづ?つ「ツづゥツつゥツづ?つ、ツつゥツづーツ陛板つキ.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n    // ツ点 p ツつェツ静シツ閉ェツ湘」ツづ可つ?づゥツつゥツづ?つ、ツつゥ\n    bool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n    // ツ静シツ閉ェツづ?静シツ閉ェツづ個仰猟猟」\n    double distance(Segment s) {\n        if( is_intersection(s) ) return 0.0;\n        return min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n    }\n    // ツデツバツッツグツ出ツ療?\n    void print(){\n        printf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n    }\n};\n\nint main(){\n    // n := ツ青ッツづ個青? m := ツスツタツーツト, l := ツゴツーツδ?\n    int n, m, l;\n    while( scanf(\"%d %d %d\", &n, &m, &l) , n || m || l ){\n        m--; l--;\n        // v[i] := i ツ氾板姪堋づ個青ッ (5ツづつづ個静シツ閉ェ)\n        vector< vector<Segment> > v;\n          \n        for(int i=0 ; i < n ; i++ ){\n            int x, y, a, r;\n            scanf(\"%d %d %d %d\", &x, &y, &a, &r );\n            double angle = to_rad( a + 90 );\n            P p1( x + r*cos(angle) , y + r*sin(angle) );\n            P p2 = rot2( P(x,y) , p1 , to_rad(72) );\n            P p3 = rot2( P(x,y) , p2 , to_rad(72) );\n            P p4 = rot2( P(x,y) , p3 , to_rad(72) );\n            P p5 = rot2( P(x,y) , p4 , to_rad(72) );\n            // vs := 5 ツづつづ個静シツ閉ェ\n            vector<Segment> vs;\n            vs.push_back( Segment(p1,p3) );\n            vs.push_back( Segment(p3,p5) );\n            vs.push_back( Segment(p5,p2) );\n            vs.push_back( Segment(p2,p4) );\n            vs.push_back( Segment(p4,p1) );\n            v.push_back( vs );\n        }\n        double G[101][101];\n        for(int i=0 ; i < 101 ; i++ ){\n            for(int j=0 ; j < 101 ; j++ ){\n                G[i][j] = (i == j)? 0 : INF;\n            }\n        }\n        for(int i=0 ; i < v.size() ; i++ ){\n            for(int j=i+1 ; j < v.size() ; j++ ){\n                double d = INF;\n                for(int k1 = 0 ; k1 < v[i].size() ; k1++ ){\n                    for(int k2 = 0 ; k2 < v[j].size() ; k2++ ){\n                        Segment s1 = v[i][k1];\n                        Segment s2 = v[j][k2];\n                        d = min( d , s1.distance(s2) );\n                    }\n                }\n                G[i][j] = G[j][i] = d;\n            } \n        }\n         \n        for(int k=0 ; k < n ; k++ ){\n            for(int i=0 ; i < n ; i++ ){\n                for(int j=0 ; j < n ; j++ ){\n                    G[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n                }\n            }\n        }\n        printf(\"%.8f\\n\", G[m][l] );\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n\n// ??????????????¢????????????\n\n// ?????°??? ??? ??§??????\ndouble deg2rad(double x) {return x * M_PI / 180.0;}\n\n// ??? a ???????????¨???????????? b ??? z ????????¢???????????¨????????????\nP rotatePoint(P a, P b, double z) {\n    // ?????°????????´????????????\n    z = deg2rad(z);\n\n    b -= a;\n    double rx = b.X * cos(z) - b.Y * sin(z);\n    double ry = b.X * sin(z) + b.Y * cos(z);\n    P ret(rx, ry); ret += a;\n    return ret;\n}\n\nint N, M, L;\ndouble dist[110][110];\n\nsigned main() {\n    while(cin >> N >> M >> L, N || M || L) {\n        M--; L--;\n        double x, y, a, r;\n        vector<P> ps[110];\n        rep(i,0,N) {\n            cin >> x >> y >> a >> r;\n            P po = P(x, y), pt = P(x, y+r);\n            pt = rotatePoint(po, pt, a);\n            rep(j,0,5) {\n                double deg = 72.0 * j;\n                ps[i].push_back( rotatePoint(po, pt, deg) );\n            }\n        }\n\n        rep(i,0,N) rep(j,0,N) {\n            dist[i][j] = INF;\n            rep(x,0,5) rep(y,0,5) {\n                P tx = ps[i][x], ty = ps[j][y];\n                chmin(dist[i][j], abs(tx-ty));\n            }\n        }\n\n        rep(k,0,N) rep(i,0,N) rep(j,0,N) {\n            chmin(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n        printf(\"%.12f\\n\", dist[M][L]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e10\n#define EPS (1e-10)    //誤差\ntypedef complex<double> P;\n\nstruct star{\n    P point[5];    \n};\n\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n\n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n\n\nstar ch(double x, double y, double a, double r){\n    \n    star res;\n    res.point[0] = P(0, r);    \n    \n    //a度左に回転\n    res.point[0] *= exp(P(0.0, a*M_PI/180.0));\n\n    //P(cos(), sin())\n\n    //72度回転　→　回収を五回繰り返す\n    for(int i = 1; i < 5; i++){\n        res.point[i] = res.point[i - 1] * exp(P(0.0, 2.0*M_PI/5.0));        \n    }\n\n    for(int i = 0; i < 5; i++){\n        res.point[i] += P(x, y);        \n    }\n\n    return res;\n}\n\n//星間の距離を返す\ndouble make_dis(star st1, star st2){\n    \n    double res = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            P p11, p12, p21, p22;\n            p11.real() = st1.point[i].real();\n            p11.imag() = st1.point[i].imag();\n            p12.real() = st1.point[(i + 2) % 5].real();\n            p12.imag() = st1.point[(i + 2) % 5].imag();\n\n            p21.real() = st2.point[i].real();\n            p21.imag() = st2.point[i].imag();\n            p22.real() = st2.point[(i + 2) % 5].real();\n            p22.imag() = st2.point[(i + 2) % 5].imag();\n\n\n            double ans = 1e10;\n            ans = min(ans, distance_ls_p(p11, p12, p21));\n            ans = min(ans, distance_ls_p(p11, p12, p22));\n            ans = min(ans, distance_ls_p(p21, p22, p11));\n            ans = min(ans, distance_ls_p(p21, p22, p12));\n            if(is_intersected_ls(p11, p12, p21, p22)) ans = 0.0;\n            res = min(res, ans);\n        }\n    }\n\n    return res;\n}\n\n//幾何入門\nint main(){\n    \n    while(1){\n\n        int n, m, l; cin >> n >> m >> l;\n        if(!n) break;\n        m--;\n        l--;\n\n        //星の構造体\n        vector<star> st(n);\n\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            //入力から星の構造体を返す\n            st[i] = ch(x, y, a, r);\n        }\n\n        vector<vector<double> > dis(n, vector<double> (n, INF));\n\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                if(i == j) dis[i][j] = dis[j][i] = 0.0;\n                else dis[i][j] = dis[j][i] = make_dis(st[i], st[j]);\n            }\n        }\n\n        //ワーシャルフロイド\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n                }\n            }\n        }\n\n        /*for(int i = 0; i < n; i++){\n            cerr << \"star \" << i << endl;\n            for(int j = 0; j < 5; j++){\n                cerr << st[i].point[j].real() << \" \" << st[i].point[j].imag() << endl;\n            }\n        }*/\n\n        printf(\"%.10f\\n\", dis[m][l]);\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int LL;\n/*}}}*/\n\ntypedef complex<double> P;\n\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n\n// 点cが線分a,b上にあるかないか(1)\n//int is_point_on_line(P a, P b, P c) {\n//  return EQ( cross(b-a, c-a), 0.0 ) &&\n//         (dot(b-a, c-a) > -EPS) &&\n//         (dot(a-b, c-b) > -EPS);\n//}\n\n// 点cが線分a,b上にあるかないか(2)\n//int is_point_on_line(P a, P b, P c) {\n//  // |a-c| + |c-b| <= |a-b| なら線分上\n//  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n//}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nstruct line_seg {\n\tP start;\n\tP end;\n};\n\nstruct star {\n\tline_seg lines[5];\n};\nvector<star> stars;\n\n#define INF (INT_MAX - 1)\n#define MAX_N 100\ndouble dist[MAX_N][MAX_N];\n\nint main(int argc, char const* argv[])\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tstars.clear();\n\t\tFOR(i, 0, N) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ta = a * 2 * PI / 360.0;\n\n\t\t\tstar s;\n\t\t\tP vertex;\n\t\t\tvertex.real() = r * cos(PI/2.0 + a);\n\t\t\tvertex.imag() = r * sin(PI/2.0 + a);\n\t\t\tFOR(j, 1, 6) {\n\t\t\t\tline_seg ls;\n\t\t\t\tls.start.real() = vertex.real() + x;\n\t\t\t\tls.start.imag() = vertex.imag() + y;\n\n\t\t\t\tdouble rot = a + j * (72 * 2 * 2 * PI / 360.0);\n\t\t\t\tvertex.real() = r * cos(PI/2.0 + rot);\n\t\t\t\tvertex.imag() = r * sin(PI/2.0 + rot);\n\n\t\t\t\tls.end.real() = vertex.real() + x;\n\t\t\t\tls.end.imag() = vertex.imag() + y;\n\n\t\t\t\ts.lines[j-1] = ls;\n\t\t\t}\n\t\t\tstars.PB(s);\n\t\t}\n\n\t\t// debug\n\t\tFOR(i, 0, SZ(stars)) {\n\t\t\t//printf(\"star %d\\n\", i);\n\t\t\tFOR(j, 0, 5) {\n\t\t\t\t//printf(\"(%lf, %lf)-(%lf, %lf)\\n\", stars[i].lines[j].start.real(), stars[i].lines[j].start.imag(), stars[i].lines[j].end.real(), stars[i].lines[j].end.imag());\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, SZ(stars)) {\n\t\t\tFOR(j, 0, SZ(stars)) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble min_dist = INF;\n\t\t\t\tFOR(k, 0, 5) {\n\t\t\t\t\tFOR(l, 0, 5) {\n\t\t\t\t\t\tdouble tmp = min(\n\t\t\t\t\t\t\t\tmin( distance_ls_p(stars[i].lines[k].start, stars[i].lines[k].end, stars[j].lines[l].start),\n\t\t\t\t\t\t\t\t\t\tdistance_ls_p(stars[i].lines[k].start, stars[i].lines[k].end, stars[j].lines[l].end) ),\n\t\t\t\t\t\t\t\tmin( distance_ls_p(stars[j].lines[l].start, stars[j].lines[l].end, stars[i].lines[k].start),\n\t\t\t\t\t\t\t\t\t\tdistance_ls_p(stars[j].lines[l].start, stars[j].lines[l].end, stars[i].lines[k].end) )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\tmin_dist = min(min_dist, tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[i][j] = dist[j][i] = min_dist;\n\t\t\t\t//printf(\"distance between (%d) and (%d) = %lf\\n\", i, j, min_dist);\n\t\t\t}\n\t\t}\n\n\t\tFOR(k, 0, N) {\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tFOR(j, 0, N) {\n\t\t\t\t\tdist[i][j] = min( dist[i][j], dist[i][k] + dist[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.20lf\\n\", dist[M-1][L-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\n//for vector\n\ninline D dot(P x, P y){return real(conj(x)*y);}\n\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline D seg_seg_dis(L a,L b){\n  D res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nint main(){\n  int n,m,l;\n  while(cin >> n >> m >> l, n){\n    vector< vector<L> > stars(n);\n    for(int i=0;i<n;i++){\n      int x,y,a,r;\n      cin >> x >> y >> a >> r;\n      P c = P(x,y);\n\n      vector<P> v;\n      P p = P(0,r);\n      for(int j=0;j<5;j++){\n\tv.push_back(c+rotate(p,PI*(a+j*72)/180));\n      }\n      \n      vector<L> l;\n      for(int j=0;j<5;j++){\n\tl.push_back(L(v[j],v[(j+2)%5]));\n\tl.push_back(L(v[j],v[(j+3)%5]));\n      }\n      stars[i] = l;\n    }\n\n    vector< vector<D> > g(n, vector<D>(n,0));\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : stars[i]){\n\t  for(L b : stars[j]){\n\t    if(is_cp(a,b))dis = 0;\n\t    else dis = min(dis, seg_seg_dis(a,b));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    cout << fixed << setprecision(9) << g[m-1][l-1] << endl;\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "1 1 1\n5 5 0 5\n2 1 2\n5 5 0 5\n15 5 0 5\n3 2 3\n15 15 0 5\n5 5 10 5\n25 25 20 5\n0 0 0\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const double PI = acos(-1.0);\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nstruct segment\n{\n  P a, b;\n  segment() {}\n  segment(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool intersects(const segment& seg) const\n  {\n    return\n      cross(seg.b - seg.a, a - seg.a) * cross(seg.b - seg.a, b - seg.a) <= EPS\n      && cross(b - a, seg.a - a) * cross(b - a, seg.b - a) <= EPS;\n  }\n\n  inline double distance(const P& p) const\n  {\n    if (dot(b-a, p-a) < EPS) {\n      return abs(p-a);\n    } else if (dot(a-b, p-b) < EPS) {\n      return abs(p-b);\n    } else {\n      return abs(cross(b-a, p-a))/abs(b-a);\n    }\n  }\n\n  inline double distance(const segment& seg) const\n  {\n    if (intersects(seg)) {\n      return 0;\n    } else {\n      return\n        min(\n            min(distance(seg.a), distance(seg.b)),\n            min(seg.distance(a), seg.distance(b)));\n    }\n  }\n};\n\nstruct star\n{\n  segment segs[5];\n  star(double x, double y, double a, double r) {\n    const P o(x, y);\n    P p(0, r);\n    p *= polar(1.0, a/180.0*PI);\n    const P m = polar(1.0, 72.0/180.0*PI);\n    P ps[5];\n    for (int i = 0; i < 5; i++) {\n      ps[i] = o + p;\n      p *= m;\n    }\n    for (int i = 0, j = 0; i < 5; i++) {\n      segs[i] = segment(ps[j], ps[(j+2) % 5]);\n      j = (j+2) % 5;\n    }\n  }\n\n  double distance(const star& s) const\n  {\n    double ans = 1e10;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        ans = min(ans, segs[i].distance(s.segs[j]));\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF && N != 0) {\n    --M; --L;\n    vector<star> stars;\n    for (int i = 0; i < N; i++) {\n      int x, y, a, r;\n      scanf(\"%d %d %d %d\", &x, &y, &a, &r);\n      stars.push_back(star(x, y, a, r));\n    }\n\n    vector<vector<double> > g(N, vector<double>(N));\n    for (int i = 0; i < N; i++) {\n      for (int j = i+1; j < N; j++) {\n        double d = stars[i].distance(stars[j]);\n        g[i][j] = g[j][i] = d;\n      }\n    }\n    priority_queue<pair<double,int> > q;\n    vector<double> dist(N, 1e10);\n    dist[M] = 0;\n    q.push(make_pair(0.0, M));\n    while (!q.empty()) {\n      const double d = -q.top().first;\n      const int n = q.top().second;\n      q.pop();\n      if (n == L) {\n        printf(\"%.20f\\n\", fabs(d));\n        break;\n      }\n      for (int i = 0; i < N; i++) {\n        if (n == i) {\n          continue;\n        }\n        const double dd = d + g[n][i];\n        if (dd < dist[i]) {\n          dist[i] = dd;\n          q.push(make_pair(-dd, i));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double INF = 1e8;\n\nstruct P{\n    double x, y;\n};\n\n//P is structure of coodinate.\nP rotationMatrix(P p, double angle){\n    double x, y;\n    x = p.x * cos(angle) - p.y * sin(angle);\n    y = p.x * sin(angle) + p.y * cos(angle);\n    p.x = x;\n    p.y = y;\n    return p;\n}\n\ndouble dist(P a, P b){\n    return sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));\n}\n\nclass Edge{\n    public:\n        double to, cost;\n        Edge(double to, double cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n    public:\n        double dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\ndouble dijkstra(AdjList g, int start, int goal, int n){\n    vector<Node> node(n);\n    priority_queue<double, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n    q.push(make_pair(0, start * 5));\n    node[start * 5].dis = 0;\n\n    pair<double, int> u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second;\n        node[current].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[next].isUsed == 0){\n                if(node[next].dis > node[current].dis + g[current][i].cost){\n                    node[next].dis = node[current].dis + g[current][i].cost;\n                    q.push(make_pair(node[next].dis, next));\n                }\n            }\n        }\n        //rep(i,node.size()){ show(node[i].dis) } cout << endl;\n    }\n\n    double mini = INF;\n    rep(i,5){\n        mini = min(mini, node[goal * 5 + i].dis);\n    }\n    return mini;\n}\n\nint main(){\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        m--; l--;\n        vector<P> v;\n        rep(i,n){\n            double x, y, a, r;\n            cin >> x >> y >> a >> r;\n\n            P tmp = rotationMatrix(P{0,r}, 2 * M_PI / 360 * a);\n            rep(i,5){\n                v.emplace_back(P{tmp.x + x, tmp.y + y});\n                tmp = rotationMatrix(tmp, 2 * M_PI / 5);\n            }\n        }\n        //rep(i,v.size()){ cout << v[i].x << ' ' << v[i].y << endl; }\n\n        AdjList g(v.size());\n        rep(i,v.size()){\n            rep(j,v.size()){\n                if(i / 5 == j / 5){\n                    g[i].emplace_back(j,0);\n                    //g[j].emplace_back(i,0);\n                }else{\n                   // cout << v[i].x << ' ' << v[i].y << endl;\n                   // cout << v[j].x << ' ' << v[j].y << endl;\n                   // show(dist(v[i],v[j]))\n                    g[i].emplace_back(j,dist(v[i], v[j]));\n                    //g[j].emplace_back(i,dist(v[j], v[i]));\n                }\n            }\n        }\n        cout <<fixed << setprecision(8)<< dijkstra(g,m,l,v.size()) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nconst double PI = 3.14159265358979323846264;\n\ndouble deg2rad(double deg) {\n  return deg*PI/180;\n}\n\nP rotate(P p, P c, double d) {\n  return c+(p-c)*P(cos(d),sin(d));\n}\n\n\n#include <cstdio>\n\nconst int INF = 1000000000;\nL star[200][5];\ndouble d[200][200];\n\ndouble diststar(int i,int j){\n  double ans = 1000000;\n  for (int ii=0; ii<5; ii++)\n    for (int ji=0; ji<5; ji++)\n      ans = min(ans,distanceSS(star[i][ii],star[j][ji]));\n  return ans;\n}\n\nint main() {\n  int n,m,l;\n  while(scanf(\"%d %d %d\",&n,&m,&l),n) {\n    for(int i=0; i<n; i++) {\n      double x,y,a,r;\n      scanf(\"%lf %lf %lf %lf\",&x,&y,&a,&r);\n      P c(x,y),up(x,y+r);\n      for (int j=0; j<5; j++) {\n\tP f = rotate(up,c,deg2rad(j*144+a));\n\tP t = rotate(up,c,deg2rad(((j+1)%5)*144+a));\n\tstar[i][j] = L(f,t);\n      }\n    }\n\n    for (int i=0; i<n; i++)\n      for (int j=0; j<n; j++)\n\td[i][j] = (i==j?0:diststar(i,j));\n\n    for (int k=0; k<n; k++)\n      for (int i=0; i<n; i++)\n\tfor (int j=0; j<n; j++)\n\t  d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n    printf(\"%.15f\\n\",d[m-1][l-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing  ld = long double;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(15);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_ss(Line(seg[i][ii], seg[i][(ii + 1) % 10]), Line(seg[j][jj], seg[j][(jj + 1) % 10])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  int n,m,l;cin >> n>>m>>l;\n  if(n==0) break;\n  Polygon stars[n];\n  //int r[n];\n  for(int i=0;i<n;i++){\n    int x,y,a,r;cin>>x>>y>>a>>r;\n    for(int j=0;j<5;j++){\n      Point v=Point(x,y)+Point(r*cos((18+a+72*j)*(2*PI)/360),r*sin((18+a+72*j)*(2*PI)/360));\n      stars[i].push_back(v);\n    }\n  }\n  ld dis[n][n];\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n    if(i==j) dis[i][j]=0.0;\n    else dis[i][j]=INF;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ld tmp=INF;\n      for(int k=0;k<5;k++){\n        for(int l=0;l<5;l++){\n          Line x=Line(stars[i][k],stars[i][(k+2)%5]);\n          Line y=Line(stars[j][l],stars[j][(l+2)%5]);\n          tmp=min(tmp,dist_ss(x,y));\n        }\n      }\n      dis[i][j]=tmp;dis[j][i]=tmp;\n    }\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);\n      }\n    }\n  }\n  cout << setprecision(10)<<dis[m-1][l-1] << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble dis[101][101];\nvector<Polygon> Stars;\nint N,M,L,x,y,a,r;\n\ndouble getDis(Polygon a,Polygon b){\n  double mind=inf;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      mind=min(abs(a[i]-b[j]),mind);\n    }\n  }\n  return mind;\n}\n\ndouble Dijkstra()\n{\n  priority_queue<pair<double,int> > PQ;\n  int color[101];\n  double d[101];\n  for(int i=0;i<N;i++){\n    d[i]=inf;\n    color[i]=0;\n  }\n  d[M-1]=0;\n  PQ.push(make_pair(0,M-1));\n  color[M-1]=0;\n  while(!PQ.empty()){\n    pair<double,int> p=PQ.top();PQ.pop();\n    int u=p.s;\n    color[u]=2;\n\n    if(d[u]<p.f*(-1))continue;\n\n    for(int i=0;i<N;i++){\n      if(color[i]==2 || dis[u][i]==inf)continue;\n      if(d[i]>dis[u][i]+d[u]){\n\td[i]=dis[u][i]+d[u];\n\tPQ.push(make_pair(d[i]*(-1),i));\n\tcolor[i]=1;\n      }\n    }\n  }\n  return d[L-1];\n}  \n\nint main()\n{\n  while(1){\n    cin>>N>>M>>L;\n    if(N+M+L==0)break;\n    Stars.clear();\n    for(int i=0;i<N;i++){\n      cin>>x>>y>>a>>r;\n      Polygon p;\n      for(int i=0;i<5;i++){\n\tp.push_back(PointRotation(Point(x,y),Point(x,y+r),(a+i*72)));\n      }\n      Stars.push_back(p);\n    }\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif(i==j)continue;\n\tdis[i][j]=getDis(Stars[i],Stars[j]);\n      }\n    }\n    printf(\"%.10f\\n\",Dijkstra());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\n//ccw\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //counter clockwise\n    if(cross(b,c) <-EPS) return -1; //clockwise\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSS(const L& s, const L& t){\n    return ( ccw(s[0],s[1],t[0]) *ccw(s[0],s[1],t[1]) <= 0 ) &&\n        ( ccw(t[0],t[1],s[0]) *ccw(t[0],t[1],s[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P& p){\n    return abs(s[0]-p) +abs(s[1]-p) -abs(s[1]-s[0]) < EPS;\n}\n\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint main(){\n    while(1){\n        int n,m,l;\n        cin >> n >> m >> l;\n        if(n==0) break;\n        \n        vector<vector<L> > star(n, vector<L>(5));\n        for(int i=0; i<n; i++){\n            double x,y,a,r;\n            cin >> x >> y >> a >> r;\n            P top(0, r);\n            double rad = a*M_PI/180.0;\n            top *= P(cos(rad), sin(rad));\n\n            P v[5];\n            v[0]=top;\n            for(int j=1; j<5; j++){\n                v[j] = v[j-1]*P(cos(0.4*M_PI), sin(0.4*M_PI));\n            }\n            for(int j=0; j<5; j++){\n                v[j] += P(x,y);\n            }\n            for(int j=0; j<5; j++){\n                star[i][j] = L(v[j], v[(j+2)%5]);\n            }\n        }\n\n        vector<vector<double> > adj(n, vector<double>(n, INF));\n        for(int i=0; i<n; i++){\n            for(int j=i; j<n; j++){\n                double dist=INF;\n                for(int k=0; k<5; k++){\n                    for(int l=0; l<5; l++){\n                        dist = min(dist, distanceSS(star[i][k], star[j][l]));\n                    }\n                }\n                adj[i][j] = adj[j][i] = dist;\n            }\n        }\n\n        for(int k=0; k<n; k++){\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n                }\n            }\n        }\n\n        cout << fixed;\n        cout << setprecision(10);\n        cout << adj[m-1][l-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD dot(P a, P b) {\n    return (conj(a)*b).X;\n}\nD cross(P a, P b) {\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c) {\n    b -= a;\tc -= a;\n    //3???????????´???????????????\n    if (cross(b,c) > EPS) return +1;\t// counter clockwise\n    if (cross(b,c) < -EPS) return -1;\t// clockwise\n    //3???????????´???????????????\n    if (dot(b,c) < -EPS) return +2;\t\t// c--a--b on line\n    if (norm(b) < norm(c)) return -2;\t// a--b--c on line or a==b\n    return 0;\t\t\t\t\t\t\t// a--c--b on line or a==c or b==c\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n    return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n    ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nD distLP(P a1, P a2, P p) {\n    //?°???±????????¨?????????????£?\n    return abs(cross(a2-a1,p-a1))/abs(a2-a1);\n}\n\nD distSP(P a1, P a2, P p) {\n    //?°???±????????¨?????????????£?\n    if(LE(dot(a2-a1, p-a1), 0))\n        return abs(p-a1);\n    if(LE(dot(a1-a2, p-a2), 0))\n        return abs(p-a2);\n    return distLP(a1, a2, p);\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n    if (isecSS(a1, a2, b1, b2)) return 0;\n    return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n               min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nclass Star{\npublic:\n    vector<P> points;\n    \n    Star(int x, int y, int a, int r){\n        for(int i=0; i<5; i++){\n            points.push_back(P(x, y) + P(0, r)*polar(1.0, 2*M_PI*i/5 + M_PI/180*a));\n        }\n    }\n};\n\nbool intersect(Star& star1, Star& star2){\n    int order[] = {0, 2, 4, 1, 3};\n    \n    for(int i=0; i<5; i++){\n        for(int j=0; j<5; j++){\n            if(isecSS(star1.points[order[i]], star1.points[order[(i+1)%5]], star2.points[order[j]], star2.points[order[(j+1)%5]]))\n                return true;\n        }\n    }\n    return false;\n}\n\ndouble distance(Star& star1, Star& star2){\n    int order[] = {0, 2, 4, 1, 3};\n    \n    double ret = INF;\n    for(int i=0; i<5; i++){\n        for(int j=0; j<5; j++){\n            ret = min(ret, distSS(star1.points[order[i]], star1.points[order[(i+1)%5]], star2.points[order[j]], star2.points[order[(j+1)%5]]));\n        }\n    }\n    return ret;\n}\n\nclass Edge{\npublic:\n    int to;\n    double cost;\n    Edge(int to, double cost): to(to), cost(cost){};\n};\n\ndouble dijkstra(vector<vector<Edge> >& G, int s, int g){\n    int N = G.size();\n    vector<double> d(N, INF);\n    \n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> q;\n    d[s] = 0;\n    q.push(make_pair(d[s], s));\n    \n    while(!q.empty()){\n        pair<double, int> v = q.top(); q.pop();\n        if(v.first != d[v.second])\n            continue;\n        \n        for(Edge &e: G[v.second]){\n            if(e.cost + d[v.second] < d[e.to]){\n                d[e.to] = e.cost + d[v.second];\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\n\nint N, M, L;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(16);\n    \n    while(cin >> N >> M >> L, N|M|L){\n        M--; L--;\n        \n        vector<Star> stars;\n        for(int i=0; i<N; i++){\n            int x, y, a, r; cin >> x >> y >> a >> r;\n            stars.push_back(Star(x, y, a, r));\n        }\n        \n        vector<vector<Edge>> G(N);\n        \n        for(int i=0; i<N; i++){\n            for(int j=i+1; j<N; j++){\n                Star& star1 = stars[i];\n                Star& star2 = stars[j];\n                if(intersect(star1, star2)){\n                    G[i].push_back(Edge(j, 0));\n                    G[j].push_back(Edge(i, 0));\n                }else{\n                    double d = distance(star1, star2);\n                    G[i].push_back(Edge(j, d));\n                    G[j].push_back(Edge(i, d));\n                }\n            }\n        }\n        cout << dijkstra(G, M, L) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#include \"../dump.hpp\"\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n// 点\ntypedef complex<double> P;\n\n// 外積\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n// 内積\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\n// 直線\n// 線分は端点を入れる\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\n// 曲がる方向\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // 反時計周り\n  if (cross(b, c) < 0)   return -1;       // 時計回り\n  if (dot(b, c) < 0)     return +2;       // c--a--b の順に一直線\n  if (norm(b) < norm(c)) return -2;       // a--b--c の順に一直線\n  return 0;\n}\n\n// 点の線への射影\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n// 線分と点の交差判定\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n// 線分同士の交差判定\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n// 線分と点の距離\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// 線分同士の距離\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 点同士の距離\ndouble distancePP(const P &p, const P &q){\n  return abs(p-q);\n}\n\n// fを中心にpをdeg回転\nP rotateP(P p, const P &f, double deg){\n  double dis = distancePP(p,f);\n  deg += arg(p-f);\n  p = f + P(dis*cos(deg),dis*sin(deg));\n  return p;\n}\n\n// fを中心にlをdeg回転\nL rotateL(L l, const P &f, double deg){\n  L res{f,f};\n  rep(i,l.size()) res[i] = rotateP(l[i],f,deg);\n  return res;\n}\n  \nusing Cost = double;\nclass node {\npublic:\n  int v;\n  Cost d;\n  node(int _a, Cost _b):v(_a),d(_b){}\n  bool operator<(const node &n) const { return d > n.d; }\n};\nclass edge {\npublic:\n  int to;\n  Cost d;\n  edge(){}\n  edge(int _to, Cost _d):to(_to),d(_d){}\n};\nclass dijkstra{\npublic:\n  vector<vector<edge>> G;\n  vector<Cost> dist;\n\n  dijkstra(int s,int t,const vector<vector<edge>> &_G):G(_G){ // sからtへの最短経路\n    dist.resize(G.size(),INF);\n  \n    priority_queue<node> que;\n    que.push(node(s, 0));\n    dist[s] = 0;\n    \n    while(!que.empty()){\n      int v = que.top().v;\n      Cost d = que.top().d;\n      que.pop();\n      if(v == t) break;\n      \n      rep(i, G[v].size()){\n\tCost tmp = d + G[v][i].d;\n\tif(dist[G[v][i].to] > tmp){\n\t  dist[G[v][i].to] = tmp;\n\t  que.push(node(G[v][i].to, tmp));\n\t}\n      }\n    }\n  }\n};\n\nint main(){\n  int n, m, l;\n  while(cin >> n >> m >> l, n){\n    m--; l--;\n    \n    // 星の5本線を格納する構造\n    vector<vector<L>> stars(n);\n    rep(i,n){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n\n      // 頂点の5点を作る\n      double d = M_PI * a / 180.0;\n      double diff = M_PI * 72.0 / 180.0;\n      vector<P> tmp;\n      P c(x,y),def1(x,y+r),def2 = rotateP(def1,c,2*diff);\n      L def{def1,def2};\n      rep(j,5){\n\tstars[i].push_back(rotateL(def,c,d));\n\td += diff;\n      }\n      // rep(j,5){\n      // \ttmp.emplace_back(rotateP(def1,c,d));\n      // \td += diff;\n      // }\n      // dump(tmp);\n      // // 5点から5本線を作る\n      // rep(j,5)\n      // \tstars[i].push_back({tmp[j],tmp[(j+2)%5]});\n    }\n\n    // グラフを作る\n    vector<vector<edge>> g(n);\n    rep(i,n) FOR(j,i+1,n){\n      double d = INF;\n      rep(x,5) rep(y,5) chmin(d,distanceSS(stars[i][x],stars[j][y]));\n      g[i].push_back(edge(j,d));\n      g[j].push_back(edge(i,d));\n    }\n    \n    // 最短経路\n    dijkstra dijk(m,l,g);\n    //dump(dijk.dist);\n    printf(\"%.10f\\n\",dijk.dist[l]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \nint N,M,L;\n  \n \nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n \ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n \nP pt[101][5];\ndouble dp[101][101];\n \ndouble get_min(int m,int n){\n    if(m==n) return 0;\n    double mn = INT_MAX;\n    static int idx[] = {0,2,4,1,3,0};\n    for (int i = 0; i < 5; i++){\n        S s = S(pt[n][idx[i]],pt[n][idx[i + 1]]);\n        for (int j = 0; j < 5; j++){\n            S t = S(pt[m][idx[j]],pt[m][idx[j + 1]]);\n            mn = min(mn,dist(s,t));\n        }\n    }\n    return mn;\n}\n  \nint main()\n{\n    while(cin>>N>>M>>L,(N||M||L)){\n        for (int i = 0; i < N; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n  \n        for(int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                dp[i][j] = get_min(i,j);\n  \n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++)\n                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n  \n        printf(\"%.20lf\\n\",dp[M - 1][L - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> PL;\n\n#define INF 1e16\n\n#define MAX_N 1000\n\ndouble EPS=1e-10;\ndouble add(double a,double b){\n  if(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n  return a+b;\n}\nstruct P\n{\n  double x,y;\n  P(){}\n  P(double x, double y):x(x),y(y){}\n  P operator + (P p){\n    return P(add(x,p.x),add(y,p.y));\n  }\n  P operator - (P p){\n    return P(add(x,-p.x),add(y,-p.y));\n  }\n  P operator * (double d){\n    return P(x*d,y*d);\n  }\n  double dot(P p){\n    return add(p.x*x,p.y*y);\n  }\n  double cross(P p){\n    return add(x*p.y,-y*p.x);\n  }\n  double norm(){\n    return x*x+y*y;\n  }\n  double abs(){\n    return sqrt(norm());\n  }\n  P rot(double r){\n    return P(x*cos(r)-y*sin(r),x*sin(r)+y*cos(r));\n  }\n};\n\nP ps[111][5];\ndouble dist[111][111];\nconst double PI=acos(-1);\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int n,m,l;\n    cin>>n>>m>>l;\n    l--;m--;\n    if(n==0)break;\n    rep(i,n){\n      double x,y,a,r;\n      cin>>x>>y>>a>>r;\n      P base,dv;\n      base.x=0; base.y=r;\n      dv.x=x; dv.y=y;\n      rep(j,5){\n        ps[i][j]=base.rot(((a+j*72)/180)*PI)+dv;\n      }\n    }\n    rep(i,n)rep(j,n)dist[i][j]=i==j?0:INF;\n    rep(i,n)rep(id,5)rep(j,n)rep(jd,5){\n      minch(dist[i][j],(ps[i][id]-ps[j][jd]).abs());\n    }\n    rep(k,n)rep(i,n)rep(j,n)minch(dist[i][j],dist[i][k]+dist[k][j]);\n    printf(\"%.10f\\n\", dist[l][m]);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\ndouble dist2(const P& a, const P& b){\n\tP c (b - a);\n\treturn real(c)*real(c)+imag(c)*imag(c);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\t\t ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ndouble d[110][110];\n\nint main(){\n\t\tint n, start ,goal;\n\t\twhile(cin>>n>>start>>goal && n && start && goal){\n\t\t\t\tstart--;\n\t\t\t\tgoal--;\n\t\t\t\trep(i, 110) rep(j, 110) d[i][j] = i == j ? 0.0 : 1e18;\n\t\t\t\tvector<vector<P>> p(n);\n\t\t\t\trep(i, n){\n\t\t\t\t\t\tdouble x, y, a, r;\n\t\t\t\t\t\tcin>>x>>y>>a>>r;\n\t\t\t\t\t\ta = PI * a/180;\n\t\t\t\t\t\trep(j, 5){\n\t\t\t\t\t\t\tP t(cos(a+2.0*PI * j / 5.0+PI/2)*r+x, sin(a+2.0*PI * j / 5.0+PI/2)*r+y);\n\t\t\t\t\t\t\tp[i].pb(t);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<vector<L>> l(n);\n\t\t\t\trep(i, n){\n\t\t\t\t\trep(j, 5){\n\t\t\t\t\t\tint k = (j + 2) % 5;\n\t\t\t\t\t\tl[i].pb({p[i][j], p[i][k]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(i, n) rep(j, n){\n\t\t\t\t\trep(a, 5) rep(b, 5) if(intersectSS(l[i][a], l[j][b])) d[i][j] = 0.0;\n\t\t\t\t\trep(a, 5) rep(b, 5) d[i][j] = min(d[i][j], sqrt(dist2(p[i][a], p[j][b])));\n\t\t\t\t}\n\t\t\t\trep(k, n) rep(i, n) rep(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\tprintf(\"%.15lf\\n\", d[start][goal]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ???\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\n// ????§???¢\ntypedef vector<Point> Polygon;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\ndouble getDist(Polygon a, Polygon b)\n{\n  double ret = inf;\n  for(int i = 0; i < 5; i++) {\n    for(int j = 0; j < 5; j++) {\n      Segment s1 = Segment(a[i], a[(i+2)%5]), s2 = Segment(b[j], b[(j+2)%5]);\n      ret = min(ret, getDistance(s1, s2));\n    }\n  }\n  return ret;\n}\n\nsigned main()\n{\n  int N, M, L;\n  while(cin >> N >> M >> L, N) {\n    M--, L--;\n    vector<Polygon> star;\n    for(int i = 0; i < N; i++) {\n      Point p, q, base; int a, r;\n      cin >> p.x >> p.y >> a >> r;\n      q = Point(p.x, p.y + r);\n      base = q - p;\n      Polygon u;\n      for(int i = 0; i < 5; i++) {\n\tPoint r;\n\tdouble theta = (a+72*i)*M_PI/180;\n\tr.x = base.x*cos(theta) - base.y*sin(theta);\n\tr.y = base.x*sin(theta) + base.y*cos(theta);\n\tr = r + p;\n\tu.push_back(r);\n      }\n      star.push_back(u);\n    }\n    double G[101][101];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tG[i][j] = (i == j ? 0 : getDist(star[i], star[j]));\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tfor(int k = 0; k < N; k++) G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n      }\n    }\n\n    printf(\"%.20f\\n\", G[M][L]);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > DBL_EPSILON)\n\t\treturn 1;\n\tif (cross(b, c) < -DBL_EPSILON)\n\t\treturn -1;\n\tif (dot(b, c) < -DBL_EPSILON)\n\t\treturn 2;\n\tif (norm(b) < norm(c) - DBL_EPSILON)\n\t\treturn 2;\n\treturn 0;\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t}\n};\n\n\nvector<P> getPoint(Star p) {\n\tvector<P> l;\n\tfor (int i = 0; i < 5; i++) {\n\t\tdouble theta =M_PI/2+ 2 * i * M_PI / 5 + p.a * M_PI / 180;\n\t\tl.push_back(\n\t\t\t\tP(p.p.real() + p.r * cos(theta),\n\t\t\t\t\t\tp.p.imag() + p.r * sin(theta)));\n\t}\n\treturn l;\n}\n\ndouble getLength(Star p1, Star p2) {\n\tvector<P> a = getPoint(p1);\n\tvector<P> b = getPoint(p2);\n\n\tdouble m = DBL_MAX;\n\tforeach(a1,a)\n\t\tforeach(b1,b) {\n\t\t\tm = min(m,abs((*a1) - (*b1)));\n\t\t}\n\treturn m;\n}\nint x, y, a, r;\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tfor (int k = 0; k < N; k++)\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tlinks[i][j] = min(links[i][j], links[i][k] + links[k][j]);\n\t\tcout << links[M-1][L-1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdio>\n#define EPS 1.0e-12\n#define INF 1.0e+12\n#define INFI 1000000\nusing namespace std;\n//2次元座標\nclass point{\npublic:\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y){\n\t\tthis->x=x;\n\t\tthis->y=y;\n\t}\n\tdouble len(point &p){\n\t\treturn sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));\n\t}\n\tpoint operator*(double d){\n\t\tpoint p(x*d,y*d);\n\t\treturn p;\n\t}\n\tpoint operator+(point &o){\n\t\tpoint p(x+o.x,y+o.y);\n\t\treturn p;\n\t}\n\tpoint operator-(point &o){\n\t\tpoint p(x-o.x,y-o.y);\n\t\treturn p;\n\t}\n\tbool operator==(point &o){\n\t\treturn (x==o.x && y==o.y);\n\t}\n\tbool operator!=(point &o){\n\t\treturn !(x==o.x && y==o.y);\n\t}\n};\n//内積\ndouble dot(point p,point q){\n\treturn (p.x*q.x+p.y*q.y);\n}\n//外積\ndouble cross(point p,point q){\n\treturn (p.x*q.y-p.y*q.x);\n}\n//線分と点\ndouble SegmentPoint(point p,point q,point r){\n\tif(dot(q-p,r-p)<EPS) return abs(r.len(p));\n\tif(dot(p-q,r-q)<EPS) return abs(r.len(q));\n\treturn abs(cross(q-p,r-p))/abs(q.len(p));\n}\n//同一直線上じゃないか、重なっている部分が存在する\nbool han(point p0,point p1,point q0,point q1){\n\tif(cross(p0-p1,q0-p0)==0.0 && cross(p0-p1,q1-p0)){//同一直線\n\t\tif(abs(p0.len(q0))+abs(q0.len(p1))<abs(p0.len(p1))+EPS ||\n\t\t\tabs(p0.len(q1))+abs(q1.len(p1))<abs(p0.len(p1))+EPS){\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n//線分線分\nbool SegSeg(point p0,point p1,point q0,point q1){\n\tint a=cross(p1-p0,q0-p0);\n\tint b=cross(p1-p0,q1-p0);\n\tint c=cross(q1-q0,p0-q0);\n\tint d=cross(q1-q0,p1-q0);\n\treturn (a*b<EPS)&&(c*d<EPS)&&(han(p0,p1,q0,q1));\n}\n//アウグストゥスみたいななにか\nclass route{\nprivate:\n\tdouble **cost;\n\tdouble *dist;\n\tbool *used;\n\tint v;\npublic:\n\troute(){}\n\troute(int v){\n\t\tthis->v=v;\n\t\tcost=new double*[v];\n\t\tfor(int i=0;i<v;i++) cost[i]=new double[v];\n\t\tdist=new double[v];\n\t\tused=new bool[v];\n\t}\n\tvoid format(double c){\n\t\tfor(int i=0;i<v;i++) for(int j=0;j<v;j++) cost[i][j]=c;\n\t}\n\tvoid set(int n,int m,double c){\n\t\tcost[n][m]=c;\n\t\tcost[m][n]=c;\n\t}\n\tvoid set(int s){\n\t\tfor(int i=0;i<this->v;i++){\n\t\t\tdist[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tdist[s]=0;\n\t\twhile(true){\n\t\t\tint p=-1;\n\t\t\tfor(int i=0;i<this->v;i++){\n\t\t\t\tif(!used[i] && (p==-1 || dist[i]<dist[p])) p=i;\n\t\t\t}\n\t\t\tif(p==-1) break;\n\t\t\tused[p]=true;\n\t\t\tfor(int i=0;i<v;i++){\n\t\t\t\tdist[i]=min(dist[i],dist[p]+cost[p][i]);\n\t\t\t}\n\t\t}\n\t}\n\tdouble RetCost(int e){\n\t\treturn dist[e];\n\t}\n\tdouble ret(int i,int j){\n\t\treturn cost[i][j];\n\t}\n};\n\nstruct st_star{\n\tpoint p[6];\n};\n\nst_star *star;\nroute *r;\n\nint main(){\n\tint i,j,k,l;\n\tint n,m,q;\n\tint x,y,a,t;\n\twhile(cin>>n>>m>>q){\n\t\tif(n==0 && m==0 && q==0) break;\n\t\tr=new route(n);\n\t\tstar=new st_star[n];\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>x>>y>>a>>t;\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tstar[i].p[j].x=x+t*cos(((a+90+216*j)%360)*M_PI/180);\n\t\t\t\tstar[i].p[j].y=y+t*sin(((a+90+216*j)%360)*M_PI/180);\n\t\t\t}\n\t\t\tstar[i].p[5]=star[i].p[0];\n\t\t}\n\t\t//交わりor最短\n\t\tfor(i=0;i<n;i++){\n\t\t\tr->set(i,i,0);\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[0],star[j].p[1])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[1],star[j].p[2])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[2],star[j].p[3])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[3],star[j].p[4])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[4],star[j].p[5])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k==5){\n\t\t\t\t\tdouble p=INF;\n\t\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\t\tfor(l=0;l<5;l++){\n\t\t\t\t\t\t\tp=min(p,SegmentPoint(star[i].p[k],star[i].p[k+1],star[j].p[l]));\n\t\t\t\t\t\t\tp=min(p,SegmentPoint(star[j].p[k],star[j].p[k+1],star[i].p[l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr->set(i,j,p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr->set(m-1);\n\t\tcout<<r->RetCost(q-1)<<endl;\n\t\tdelete r;\n\t\tdelete []star;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nusing D = double;\nusing P = complex<D>;\n\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint sgn(D a, D b) { return sgn(b-a); }\nbool near(P a, P b) { return !sgn(abs(a-b)); }\nD mabs(P p) { return abs(p.real()) + abs(p.imag()); }\n\nbool lessP(P l, P r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nD cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nD dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n  \nD deg2rad(D x) {\n    return x/180*PI;\n}\n  \n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P b, P c) {\n    int s = sgn(cross(b, c) / mabs(b));\n    if (s) return s;\n    if (!sgn(mabs(c)) || !sgn(mabs(c-b))) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\n \nstruct L {\n    P s, t;\n    L() {};\n    L(P s, P t) :s(s), t(t) {};\n};\n \nP vec(const L &l) {\n    return l.t - l.s;\n}\n \nD abs(const L &l) {\n    return abs(vec(l));\n}\n \n \nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.s,s.t,t.s), b = ccw(s.s,s.t,t.t);\n    int c = ccw(t.s,t.t,s.s), d = ccw(t.s,t.t,s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n \nD distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.s)/abs(vec(l)));\n}\n \nD distSP(const L &s, const P &p) {\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.s, s.s+s2, p) == 1) return abs(s.s-p);\n    if (ccw(s.t, s.t+s2, p) == -1) return abs(s.t-p);\n    return min(min(abs(s.s-p), abs(s.t-p)), distLP(s, p));\n}\n \nD distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.s), distSP(s, t.t)),\n               min(distSP(t, s.s), distSP(t, s.t)));\n}\n \nconst int MN = 110;\nL sl[MN][5];\nD g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            D x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                D aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<D>(r, deg2rad(aa));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                D r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20lf\\n\", g[m][l]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > DBL_EPSILON)\n\t\treturn 1;\n\tif (cross(b, c) < -DBL_EPSILON)\n\t\treturn -1;\n\tif (dot(b, c) < -DBL_EPSILON)\n\t\treturn 2;\n\tif (norm(b) < norm(c) - DBL_EPSILON)\n\t\treturn 2;\n\treturn 0;\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\ndouble DistanceSP(P a,P b,P c){\n\tif(dot(b-a,c-a)<DBL_EPSILON)return abs(c-a);\n\tif(dot(a-b,c-b)<DBL_EPSILON)return abs(c-b);\n\treturn abs(cross(b-a,c-a));\n}\ndouble DistaiceSS(P a,P b,P c,P d){\n\tif(isIntersectSS(a,b,c,d)){\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a,b,c),DistanceSP(a,b,d)),min(DistanceSP(c,d,a),DistanceSP(c,d,b)));\n}\n\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t}\n};\n\n\nvector<P> getPoint(Star p) {\n\tvector<P> l;\n\tfor (int i = 0; i < 5; i++) {\n\t\tdouble theta =M_PI/2+ 2 * i * M_PI / 5 + p.a * M_PI / 180;\n\t\tl.push_back(\n\t\t\t\tP(p.p.real() + p.r * cos(theta),\n\t\t\t\t\t\tp.p.imag() + p.r * sin(theta)));\n\t}\n\treturn l;\n}\n\ndouble getLength(Star p1, Star p2) {\n\tvector<P> a = getPoint(p1);\n\tvector<P> b = getPoint(p2);\n\n\tdouble m = DBL_MAX;\n\tforeach(a1,a)foreach(a2,a)foreach(b1,b)foreach(b2,b){\n\t\tm = min(m,DistaiceSS(*a1,*a2,*b1,*b2));\n\t}\n\treturn m;\n}\nint x, y, a, r;\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tfor (int k = 0; k < N; k++)\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tlinks[i][j] = min(links[i][j], links[i][k] + links[k][j]);\n\t\tcout << links[M-1][L-1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\ndouble deg2rad(double deg) {\n    return deg * 2. * PI / 360;\n}\n\n// q????????????p???theta?????¢(???????¨????????????£)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\ndouble distanceLP(L l, P p) {\n    return abs(cross(l.v, p - l.a)) / abs(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.v, p - l.a) < 0) return abs(p - l.a);\n    if (dot(-l.v, p - l.b) < 0) return abs(p - l.b);\n    return distanceLP(l, p);\n}\n\ndouble distanceSS(L l1, L l2) {\n    if (intersectSS(l1, l2)) return 0;\n    double d = INF;\n    d = min(d, distanceSP(l1, l2.a));\n    d = min(d, distanceSP(l1, l2.b));\n    d = min(d, distanceSP(l2, l1.a));\n    d = min(d, distanceSP(l2, l1.b));\n    return d;\n}\n\nstruct Star {\n    P c;\n    double r;\n    vector<P> p;\n    vector<L> l;\n    Star(){}\n    Star(double x, double y, double deg, double _r) : c(x, y), r(_r) {\n        rep(i, 5) {\n            p.emplace_back(rotP(P(x, y + r), c, deg2rad(deg + 72 * i)));\n            // cout << p[i].real() << \" \" << p[i].imag() << endl;\n        }\n        rep(i, 5) {\n            l.emplace_back(L(p[i], p[(i + 2) % 5]));\n        }\n    }\n    double dist(const Star& o) {\n        double ret = INF;\n        rep(i, 5) {\n            rep(j, 5) {\n                ret = min(ret, distanceSS(l[i], o.l[j]));\n            }\n        }\n        return ret;\n    }\n};\n\nstruct edge {\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to, double _cost) : to(_to), cost(_cost) {}\n};\ntypedef vector<vector<edge>> Graph;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, double c) {\n    G[x].emplace_back(y, c);\n    G[y].emplace_back(x, c);\n}\n\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    using Pdi = pair<double, int>;\n    priority_queue<Pdi, vector<Pdi>, greater<Pdi>> pq;   // cost, vertex\n    vector<double> d(n, INF);\n    d[s] = 0.;\n    pq.push(make_pair(0., s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nvoid printGraph(const Graph& G) {\n    rep(i, G.size()) {\n        cout << i << \": \";\n        rep(j, G[i].size()) {\n            cout << \"{\" << G[i][j].to << \", \" << G[i][j].cost << \"}, \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, s, g;\n    while (cin >> n >> s >> g, n) {\n        s--; g--;\n\n        vector<Star> stars;\n        rep(i, n) {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            stars.emplace_back(x, y, a, r);\n        }\n\n        Graph G(n);\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                addEdge(G, i, j, stars[i].dist(stars[j]));\n            }\n        }\n\n        // printGraph(G);\n\n        cout << fixed << setprecision(20) << dijkstra(G, s, g) << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\nx' = xcos - ysin\ny' = xsin + ycos\n*/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> PII;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = atan2(0, -1);\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\n//S?????????????????AL??????????????\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + (double)2 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\t\treturn min({distanceSP(s, t[0]), distanceSP(s, t[1]), distanceSP(t, s[0]), distanceSP(t, s[1])});\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nstruct edge{\n  int to;\n  double cost;\n};\n\nvector<L> l[105];\nvector<edge> G[105];\ndouble d[105];\nint main() {\n  //cout << PI << endl;\n  while(true) {\n  int n, s, g;\n  cin >> n >> s >> g;\n  if(!n && !s && !g) break;\n  for(int i=0; i<n; ++i) {\n    int x, y, a, r;\n    cin >> x >> y >> a >> r;\n    P p[5];\n    for(int j=0; j<5; ++j) {\n      p[j] = {x + r*cos(j*2*PI/5+a*2*PI/360+PI/2), y + r*(sin(j*2*PI/5+a*2*PI/360+PI/2))};\n      //cout << j*2*PI/5+a*2*PI/360+PI/2 << \" \" << p[j].real() << \" \" << p[j].imag() << endl;\n    }\n    l[i].clear();\n    l[i].push_back(L{p[0], p[2]});\n    l[i].push_back(L{p[0], p[3]});\n    l[i].push_back(L{p[1], p[3]});\n    l[i].push_back(L{p[1], p[4]});\n    l[i].push_back(L{p[2], p[4]});\n  }\n\n  //cout << \"in\" << endl;\n  for(int i=0; i<n; ++i) G[i].clear();\n  for(int i=0; i<n; ++i) {\n    for(int j=0; j<n; ++j) {\n      //l[i]??¨l[j]????????¢????±???????????????????\n      if(i == j) continue;\n      double mi = INF;\n      for(int k=0; k<5; ++k) {\n        for(int k2=0; k2<5; ++k2) {\n          mi = min(mi, distanceSS(l[i][k], l[j][k2]));\n        }\n      }\n      G[i].push_back({j, mi});\n      G[j].push_back({i, mi});\n    }\n  }\n  /*for(int i=0; i<n; ++i) {\n    cout << i << \":\";\n    for(edge e: G[i]) {\n      cout << \"(\" << e.to << \" \" << e.cost << \")\";\n    }\n    cout << endl;\n  }\n  cout << \"edge\" << endl;*/\n\n  s--; g--;\n  priority_queue<PII, vector<PII>, greater<PII>> que;\n  fill(d, d+n, INF);\n  d[s] = 0;\n  que.push(PII(0, s));\n\n  while(que.size()) {\n    PII p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(int i=0; i<G[v].size(); ++i) {\n      edge e = G[v][i];\n      if(d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(PII(d[e.to], e.to));\n      }\n    }\n  }\n  cout << fixed << setprecision(15) << d[g] << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > +EPS) return 1;\n  if (cross(b, c) < -EPS) return -1;\n  if (dot(b, c)   < -EPS) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 2);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n    \n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  int N, M;\n  while (cin >> N >> M && N + M){\n    poly_t poly(N);\n    REP(i, N){\n      cin >> poly[i];\n    }\n    \n    vector<xy_t> L(M);\n    REP(i, M){\n      cin >> L[i];\n    }\n    \n\n    REP(i, M){\n      poly_t pi = poly;\n      \n      REP(j, M) if (i != j){\n        pi = convex_cut(pi, bisector(L[i], L[j]));\n      }\n      \n      cout << fixed << setprecision(20) << area(pi) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e8, pi = acos(-1.);\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\ninline double cross(const Point& a, const Point& b){\n    return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n    return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(const Point& a, const Point& b){\n        push_back(a); push_back(b);\n    }\n};\n\ninline Point proj(const Line& l, const Point& p){\n    double t = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);\n    return l[0] + (l[1] - l[0]) * t;\n}\n\ninline bool interSP(const Line& s, const Point& p){\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps;\n}\n\ninline bool interSS(const Line& s, const Line& t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\ninline double distSP(const Line& s, const Point& p){\n    const Point r = proj(s, p);\n    return interSP(s, r)? abs(r - p): min(abs(s[0] - p), abs(s[1] - p));\n}\n\ninline double distSS(const Line& s, const Line& t){\n    return interSS(s, t)? 0: min(min(distSP(s, t[0]), distSP(s, t[1])), min(distSP(t, s[0]), distSP(t, s[1])));\n}\n\nint N, M, L;\n\ndouble solve(vector<vector<Line> >& pent){\n    vector<vector<double> > dist(N, vector<double>(N));\n    rep(i, N)rep(j, i){\n        dist[i][j] = inf;\n        rep(k, 5)rep(l, 5)chmin(dist[i][j], distSS(pent[i][k], pent[j][l]));\n        dist[j][i] = dist[i][j];\n    }\n    rep(k, N)rep(i, N)rep(j, N)chmin(dist[i][j], dist[i][k] + dist[k][j]);\n    return dist[M][L];\n}\n\nint main(){\n    while(cin >> N >> M >> L, N|M|L){\n        M--; L--;\n        vector<vector<Line> > pent(N);\n        rep(i, N){\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            vector<Point> v;\n            rep(j, 5)v.push_back(Point(x, y) + polar(1. * r, (a + 72 * j + 90) * pi / 180));\n            rep(j, 5)pent[i].emplace_back(v[j], v[(j + 2) % 5]);\n        }\n        cout << fixed << setprecision(20) << solve(pent) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n\nvector<P> get_p(P a,double d,double r){\n  vector<P> res(5);\n  d=(d/360)*2*M_PI;\n  P p=P(0,r)*P(cos(d),sin(d));\n  res[0]=p+a;\n  d=2*M_PI/5;\n  for(int i=1;i<=4;i++){\n    p=p*P(cos(d),sin(d));\n    res[i]=p+a;\n  }\n  return res;\n}\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble G[N][N],x[N],y[N],d[N],r[N];\ndouble get_dis(int a,int b){\n  vector<P> A=get_p(P(x[a],y[a]),d[a],r[a]);\n  vector<P> B=get_p(P(x[b],y[b]),d[b],r[b]);\n  double res=1e9;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      res=min(res,getDistanceSS(L(A[i],A[(i+2)%5]),L(B[j],B[(j+2)%5])));\n  return res;\n}\n\nint main(){\n  while(1){\n  int n,s,g;\n  cin>>n>>s>>g;\n  if(!n&&!s&&!g)break;\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++)G[i][j]=1e9*(i!=j);\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>d[i]>>r[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(i!=j) G[i][j]=get_dis(i,j);\n  \n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  printf(\"%.20f\\n\",G[s-1][g-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n#define dINF (1LL<<59)\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //テァツつケ\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //テ・ツ環?ァツョツ?\n    P operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //テヲツクツ崚ァツョツ?\n    P operator * (const double k )const{ return P( x*k   , y*k    ); } //テ、ツケツ療ァツョツ?\n    P operator / (const double k )const{ return P( x/k   , y/k    ); } //テゥツ卍、テァツョツ?\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    bool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //テ」ツδ偲」ツδォテ」ツδ?\n    double abs() { return sqrt(norm()); }   //テ・ツ、ツァテ」ツ?催」ツ??\n    void normalize() {double d = sqrt(x*x+y*y); x /= d; y /= d;}\t//テヲツュツ」ティツヲツ湘・ツ個?\n};\nstruct C{P p;double r;};    //テ・ツ??\nstruct S{P p1,p2;};         //テァツキツ堙・ツ按?\ntypedef vector<P> Polygon;  //テ・ツ、ツ堙ィツァツ津・ツスツ「\ntypedef P Vector;           //テ」ツδ凖」ツつッテ」ツδ暗」ツδォ\ntypedef S L;                //テァツ崢エテァツキツ?\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//テァツキツ堙・ツ按?、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n\nstruct star{\n    vector<P> ep;\n    vector<S> ss;\n};\n\n\ndouble toRad( int a ){\n    return a*3.14159265358/180.0;\n}\n\nvector<P> getEp(int x,int y,int a,int r){\n    vector<P> ret;\n    \n    int theta = a;\n    rep(i,5){\n        double xx = x, yy = y;\n        xx -= r*sin(toRad(a));\n        yy += r*cos(toRad(a));\n        \n        ret.pb({xx,yy});\n        \n        a+=72;\n    }\n    return ret;\n}\n\nbool isCross(star a,star b){\n    rep(i,5){\n        rep(j,5){\n            if( intersect(a.ss[i].p1, a.ss[i].p2, b.ss[j].p1, b.ss[j].p2) ){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「 verified ARC042-B\ndouble dLP(S l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「 verified QUPC-G\ndouble dSP(S s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\ndouble dSS(S s, S t){return  min({dSP(s, t.p1), dSP(s, t.p2), dSP(t, s.p1), dSP(t, s.p2)});}\n\n\ndouble getMinDist(star a,star b){\n    vector<S> c = a.ss, d = b.ss;\n    double ret = dINF;\n    rep(i,c.size()){\n        rep(j,d.size()){\n            double res = dSS(c[i],d[j]);\n            ret = min(ret,res);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int v,s,g;\n    while(cin>>v>>s>>g&&(v||s||g)){\n        s--,g--;\n        vector<star> vs;\n        rep(i,v){\n            int x,y,a,r;\n            cin>>x>>y>>a>>r;\n            vector<P> tp = getEp(x,y,a,r);\n            assert(tp.size()==5);\n            vector<S> ts;\n            rep(i,tp.size()){\n                int d1 = (i+2)%5, d2 = (i+3)%5;\n                if(i<d1)ts.pb(S{tp[i],tp[d1]});\n                if(i<d2)ts.pb(S{tp[i],tp[d2]});\n            }\n            assert(ts.size()==5);\n            vs.pb(star{tp,ts});\n        }\n        \n        double d[101][101];\n        rep(i,101)rep(j,101)d[i][j] = dINF;\n        rep(i,101)d[i][i] = 0.0;\n        \n        \n        rep(i,vs.size()){\n            rep(j,vs.size()){\n                if(i==j)continue;\n                if(isCross(vs[i],vs[j])){\n                    d[i][j]=0.0;\n                    continue;\n                }else{\n                    double res = getMinDist(vs[i],vs[j]);\n                    d[i][j] = res;\n                }\n            }\n        }\n        rep(k,v){\n            rep(i,v){\n                rep(j,v){\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n                }\n            }\n        }\n        \n        printf(\"%.20lf\\n\",d[s][g]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e8, pi = acos(-1.);\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\ninline double cross(const Point& a, const Point& b){\n    return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n    return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(const Point& a, const Point& b){\n        push_back(a); push_back(b);\n    }\n};\n\nPoint proj(const Line& l, const Point& p){\n    double t = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);\n    return l[0] + (l[1] - l[0]) * t;\n}\n\ninline bool interSP(const Line& s, const Point& p){\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps;\n}\n\ninline bool interSS(const Line& s, const Line& t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\ninline double distSP(const Line& s, const Point& p){\n    const Point r = proj(s, p);\n    return interSP(s, r)? abs(r - p): min(abs(s[0] - p), abs(s[1] - p));\n}\n\ninline double distSS(const Line& s, const Line& t){\n    return interSS(s, t)? 0: min({distSP(s, t[0]), distSP(s, t[1]), distSP(t, s[0]), distSP(t, s[1])});\n}\n\nint N, M, L;\n\ndouble solve(vector<vector<Line> >& pent){\n    vector<vector<double> > dist(N, vector<double>(N));\n    rep(i, N)rep(j, i){\n        dist[i][j] = inf;\n        for(auto s: pent[i])for(auto t: pent[j])chmin(dist[i][j], distSS(s, t));\n        dist[j][i] = dist[i][j];\n    }\n    vector<double> mem(N, inf); mem[M] = 0.;\n    priority_queue<pair<double, int> > q;\n    for(q.emplace(0, M); !q.empty();){\n        double d = -q.top().first; int v = q.top().second; q.pop();\n        if(mem[v] + eps < d)continue;\n        if(v == L)break;\n        rep(i, N)if(d + dist[v][i] + eps < mem[i]){\n            mem[i] = d + dist[v][i];\n            q.emplace(-mem[i], i);\n        }\n    }\n    return mem[L];\n}\n\nint main(){\n    while(cin >> N >> M >> L, N|M|L){\n        M--; L--;\n        vector<vector<Line> > pent(N);\n        rep(i, N){\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            vector<Point> v;\n            rep(j, 5)v.push_back(Point(x, y) + polar(1. * r, (a + 72 * j + 90) * pi / 180));\n            rep(j, 5)pent[i].emplace_back(v[j], v[(j + 2) % 5]);\n        }\n        cout << fixed << setprecision(20) << solve(pent) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nbool isIntersect(vector<P> a,vector<P> b){\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      if(isIntersect(L(a[i],a[(i+2)%5]),L(b[j],b[(j+2)%5])))return 1;\n  return 0;\n}\n\nvector<P> get_p(P a,double d,double r){\n  vector<P> res(5);\n  d=(d/360)*2*M_PI;\n  P p=P(0,r)*P(cos(d),sin(d));\n  res[0]=p+a;\n  d=2*M_PI/5;\n  for(int i=1;i<=4;i++){\n    p=p*P(cos(d),sin(d));\n    res[i]=p+a;\n  }\n  return res;\n}\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\ndouble G[N][N],x[N],y[N],d[N],r[N];\n\ndouble get_dis(int a,int b){\n  vector<P> A=get_p(P(x[a],y[a]),d[a],r[a]);\n  vector<P> B=get_p(P(x[b],y[b]),d[b],r[b]);\n  double res=1e9;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      res=min(res,getDistanceSS(L(A[i],A[(i+2)%5]),L(B[j],B[(j+2)%5])));\n  return res;\n}\n\nint main(){\n  while(1){\n  int n,s,g;\n  cin>>n>>s>>g;\n  if(!n&&!s&&!g)break;\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++)G[i][j]=1e9*(i!=j);\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>d[i]>>r[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(i!=j) G[i][j]=get_dis(i,j);\n  \n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  printf(\"%.20f\\n\",G[s-1][g-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef complex<double> P;\ndouble PI;\ntypedef struct{\n\tP c[5];\n}star;\nstar stars[100];\ndouble dist[100][100];\ninline double dot(P p1, P p2){\n\treturn real(p1*conj(p2));\n}\ninline double cross(P p1, P p2){\n\treturn imag(p1*conj(p2));\n}\ninline double getcos(P p1, P p0, P p2){\n\tP v1 = p1-p0;\n\tP v2 = conj(p2-p0);\n\treturn dot(v1,v2)/sqrt(norm(v1)*norm(v2));\n}\n\nint ccw(P a, P b, P c) {  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line  return 0;\n}\n\nbool intersectSS(const P &L1a,const P &L1b,const P &L2a,const P &L2b){\n  return ccw(L1a,L1b,L2a)*ccw(L1a,L1b,L2b) <= 0 &&\n         ccw(L2a,L2b,L1a)*ccw(L2a,L2b,L1b) <= 0;\n}\n\ninline double distPP(P p1, P p2){\n\treturn sqrt(norm(p1-p2));\n}\n\ninline double distPL(P p, P L1, P L2){\n\tdouble a,b,c;\n\ta = L2.imag() - L1.imag();\n\tb = -(L2.real() - L1.real());\n\tc = L2.real()*L1.imag() - L1.real()*L2.imag();\n\treturn abs(a*p.real()+b*p.imag()+c)/sqrt(pow(a, 2.0)+pow(b, 2.0));\n}\n\ninline double distLL(P a1, P a2, P b1, P b2){\n\tdouble ret = 1e15;\n\tdouble cos1, cos2;\n\tif(intersectSS(a1,a2,b1,b2))return 0.0;\n\tcos1 = getcos(b1,b2,a1);\n\tcos2 = getcos(b2,b1,a1);\n\tif(cos1>0 && cos2>0)ret = min(ret, distPL(a1,b1,b2));\n\telse ret = min(ret, min(distPP(a1,b1), distPP(a1, b2)));\n\tcos1 = getcos(b1,b2,a2);\n\tcos2 = getcos(b2,b1,a2);\n\tif(cos1>0 && cos2>0)ret = min(ret, distPL(a2,b1,b2));\n\telse ret = min(ret, min(distPP(a2,b1), distPP(a2, b2)));\n\tcos1 = getcos(a1,a2,b1);\n\tcos2 = getcos(a2,a1,b1);\n\tif(cos1>0 && cos2>0)ret = min(ret, distPL(b1,a1,a2));\n\telse ret = min(ret, min(distPP(b1,a1), distPP(b1, a2)));\n\tcos1 = getcos(a1,a2,b2);\n\tcos2 = getcos(a2,a1,b2);\n\tif(cos1>0 && cos2>0)ret = min(ret, distPL(b2,a1,a2));\n\telse ret = min(ret, min(distPP(b2,a1), distPP(b2, a2)));\n\treturn ret;\n}\n\n\n\ndouble distSS(int p, int q){//星間距離\n\tif(p==q)return 0;\n\tdouble ret = 1e15;\n\tREP(i,5){\n\t\tREP(j,5){\n\t\t\tret = min(ret, distLL(stars[p].c[i], stars[p].c[(i+2)%5], stars[q].c[j], stars[q].c[(j+2)%5]));\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tPI = acos(-1.0);\n\twhile(1){\n\t\tint n,m,l;\n\t\tcin>>n>>m>>l;\n\t\tif(n==0)return 0;\n\t\tm--,l--;\n\t\tREP(i,n){\n\t\t\tdouble x,y,a,r;\n\t\t\tscanf(\"%lf%lf%lf%lf\", &x, &y, &a, &r);\n\t\t\tREP(j,5)stars[i].c[j] = P(x-r*sin((a+72.0*j)/180.0*PI), y+r*cos((a+72.0*j)/180.0*PI));\n\t\t}\n\t\tREP(i,n){\n\t\t\tdist[i][i] = 0.0;\n\t\t\tREP(j,i){\n\t\t\t\tdist[i][j] =dist[j][i] = distSS(i,j);\n\t\t\t}\n\t\t}\n\t\tREP(k,n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,i){\n\t\t\t\t\tdist[j][i] = dist[i][j] = min(dist[i][j], dist[i][k]+ dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15f\\n\", dist[m][l]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<complex>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nint ccw(const P a, P b, P x) {\n  b -= a;\n  x -= a;\n  double cr = cross(b, x);\n  if (eq(cr, 0)) {\n    if (dot(b, x) < 0) return BACK;\n    if (abs(b) < abs(x)) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\nP vec(L a) {return a.second - a.first;}\nbool iSS(L a, L b) {\n  int cwaf = ccw(a.first, a.second, b.first);\n  int cwbf = ccw(b.first, b.second, a.first);\n  int cwas = ccw(a.first, a.second, b.second);\n  int cwbs = ccw(b.first, b.second, a.second);\n  if (cwaf == ON || cwas == ON || cwbf == ON || cwbs == ON ) return true;\n  return (cwaf | cwas) == (LEFT | RIGHT) && (cwbf | cwbs) == (LEFT | RIGHT);\n}\ndouble dLP(L l, P x) {return abs(cross(vec(l), x - l.first)) / abs(vec(l));}\ndouble dSP(L s, P x) {\n  if (dot(vec(s), x - s.first) <= 0) return abs(x - s.first);\n  if (dot(-vec(s), x - s.second) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\ndouble dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\n\ndouble x[111], y[111], a[111], r[111];\nL star[111][5];\ndouble dis[111][111];\ndouble mem[111];\n\nvoid f(int s, int t) {\n  double res = 1e40;\n  rep (i, 5) rep (j, 5) {\n    /*    \n\t  cout << s << \" \" << t << \" \" << i << \" \" << j << endl;\n    cout << star[s][i].first << star[s][i].second << star[t][j].first << star[t][j].second << dSS(star[s][i], star[t][j]) << endl;\n    cout << dSP(star[s][i], star[t][j].first) << endl;\n    cout << dSP(star[s][i], star[t][j].second) << endl;\n    cout << dLP(star[t][j], star[s][i].first) << endl;\n    cout << vec(star[t][j]) << star[s][i].first - star[t][j].first << endl;\n    cout << cross(vec(star[t][j]), star[s][i].first - star[t][j].first) << endl;\n    cout << dSP(star[t][j], star[s][i].second) << endl;\n    */\n    res = min(dSS(star[s][i], star[t][j]), res);\n  }\n  dis[s][t] = res;\n}\n\nint main() {\n  int n, m, l;\n  for (;;) {\n    cin >> n >> m >> l;\n    if (n == 0 && m == 0 && l == 0) break;\n    --m; --l;\n    rep (i, n) cin >> x[i] >> y[i] >> a[i] >> r[i];\n    rep (i, n) a[i] = a[i] / 360 * 2 * PI;\n    rep (i, n) rep (j, 5) {\n      double theta = a[i] + j * 2 * PI / 5 + PI / 2;\n      //cout << theta << endl;\n      P p1 = P(x[i] + r[i] * cos(theta), y[i] + r[i] * sin(theta));\n      theta = a[i] + (j + 2) * 2 * PI / 5 + PI / 2;\n      P p2 = P(x[i] + r[i] * cos(theta), y[i] + r[i] * sin(theta));\n      star[i][j] = L(p1, p2);\n      //cout << i << \" \" << j << \" \" << theta << \" \" << p1 << \" \" << p2 << endl;\n    }\n    rep (i, n) rep (j, n) f(i, j);\n    //rep (i, n) rep (j, n) cout << i << \" \" << j << \" \" << dis[i][j] << endl;\n    rep (i, n) mem[i] = INF;\n    priority_queue<pair<double, int> > que;\n    que.push(make_pair(0, m));\n    while (!que.empty()) {\n      pair<double, int> now = que.top();\n      que.pop();\n      if (mem[now.second] <= now.first) continue;\n      mem[now.second] = now.first;\n      rep (i, n) if (i != now.second) {\n\tque.push(make_pair(now.first + dis[now.second][i], i));\n      }\n    }\n    printf(\"%.12lf\\n\", mem[l]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;   // 許容誤差。問題によって変える\nconst double pi=M_PI;\nconst double INFD=1e+9;\ntypedef complex<double> P; // Point\n#define rep(i,n) for(int i=0;i<n;i++)\n//点の座標は複素数で持つ\n#define X real()\n#define Y imag()\nnamespace std\n{\nbool operator<(const P p1, const P p2)\n{\n    return p1.X != p2.X ? p1.X < p2.X : p1.Y < p2.Y;\n}\nP operator+(const P p1, const P p2) { return P(p1.X + p2.X, p1.Y + p2.Y); }\nP operator-(const P p1, const P p2) { return P(p1.X - p2.X, p1.Y - p2.Y); }\nP operator*(const P p, double k) { return P(p.X * k, p.Y * k); }\nP operator/(const P p, double k) { return P(p.X / k, p.Y / k); }\n} \n//Segment/L\nstruct Segment\n{\n    P p1, p2;\n    Segment() {}\n    Segment(P p1, P p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment L;\n\n\n//ノルム\n//二点a,bを投げるとノルムの2乗(a1-b1)^2+(a2-b2)^2を返す\ndouble norm(P &p1, P &p2)\n{\n    return (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);\n}\n\n//外積cross(a,b) = |a||b|sinθ=a1b2-a2b1\n//二点a,bを投げると外積を返す\ndouble cross(const P &a, const P &b)\n{\n    return (conj(a) * b).Y;\n}\n\n//内積dot(a,b) = |a||b|cosθ=a1b1+a2b2\n//二点a,bを投げると内積を返す\ndouble dot(const P &a, const P &b)\n{\n    return (conj(a) * b).X;\n}\n\n//射影\n//L(又はS)と点Pを投げるとLへPを射影した座標を返す\n//依存:dot,norm\nP Projection(L l, P p)\n{\n    P base = l.p2 - l.p1;                        //始点\n    double r = dot(p - l.p1, base) / norm(base); //線分に対する倍率の計算\n    return l.p1 + base * r;\n}\n\n//鏡映\n//L(又はS)と点Pを投げるとLを軸としたPの鏡像座標を返す\n//依存:Projection,dot,norm\nP Reflection(L l, P p)\n{\n    return p + (Projection(l, p) - p) * 2.0;\n}\n\n//位置関係判定(線分abを軸にcがどちら側にあるか)\n//三点a,b,cを投げることで，a-bを軸として\n//時計回りの場合:1,反時計回りの場合:-1,c-a-bの並び:2,a-b-cの並び:-2\n//その他（重なってる等）:0\n//依存:cross,dot,norm\nint ccw(P a, P b, P c)\n{\n    b -= a;\n    c -= a; //aからの向きを考える\n    if (cross(b, c) > EPS)\n        return +1; //clockwise\n    else if (cross(b, c) < -EPS)\n        return -1; //counter clockwise\n    else if (dot(b, c) < -EPS)\n        return +2; //c-a-b\n    else if (norm(b) < norm(c))\n        return -2; //a-b-c\n    else\n        return 0; //他\n}\n\n//Intersection Determination\n//L,S,Pそれぞれのペアの交差判定，PPは直接比較できるのでないです\n//それぞれのペアを投げる,引数の順番は関数名に記載\n//交差又は含まれている場合true,そうでない場合falseを返す\n\n//依存:cross\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l.p2 - l.p1, m.p2 - m.p1)) > EPS || // non-parallel\n           abs(cross(l.p2 - l.p1, m.p1 - l.p1)) < EPS;   // same L\n}\n//依存:cross\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l.p2 - l.p1, s.p1 - l.p1) * // s.p1 is left of l\n               cross(l.p2 - l.p1, s.p2 - l.p1) <\n           EPS; // s.p2 is right of l\n}\n//依存:cross\nbool intersectLP(const L &l, const P &p)\n{\n    return abs(cross(l.p2 - p, l.p1 - p)) < EPS;\n}\n//依存:ccw,cross,dot,norm\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s.p1, s.p2, t.p1) * ccw(s.p1, s.p2, t.p2) <= 0 &&\n           ccw(t.p1, t.p2, s.p1) * ccw(t.p1, t.p2, s.p2) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p)\n{\n    return abs(s.p1 - p) + abs(s.p2 - p) - abs(s.p2 - s.p1) < EPS; // triangle inequality\n}\n\n//distance\n//L,S,Pについてペアを投げるとその距離を計算\n//引数の順番は関数名参照\n\n//依存:Projection,dot,norm\ndouble distanceLP(const L &l, const P &p)\n{\n    return abs(p - Projection(l, p));\n}\n//依存:intersectLL,cross,distanceLP,Projection,dot,norm\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n//依存:intersectLS,cross,distanceLP,Projection,dot,norm\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s))\n        return 0;\n    return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n//依存:intersectSP,Projection,dot,norm\ndouble distanceSP(const L &s, const P &p)\n{\n    const P r = Projection(s, p);\n    if (intersectSP(s, r))\n        return abs(r - p);\n    return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n//依存:intersectSS,ccw,cross,dot,norm,distanceSP,intersectSP,Projection\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t))\n        return 0;\n    return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n               min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\ndouble distancePP(const P &p1, const P &p2)\n{\n    return abs(p1 - p2);\n}\n//二本のL(又はS)を投げると交点座標を返す\n//一致している場合は一本目のp1を返します\n//交わっていない場合はfalseを返します\n//依存:cross\nP crosspoint(const L &l, const L &m)\n{\n    double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n    double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return l.p1; // same line\n    if (abs(A) < EPS)\n        assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m.p1 + B / A * (m.p2 - m.p1);\n}\n\nP top[103][5]={};\nL star[103][5]={};\ndouble dist[103][103]={};\n\nsigned main(){\n    int n,m,l;\n    while(cin>>n>>m>>l and n){\n        m--;l--;\n        rep(i,n){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            rep(j,5){\n                top[i][j]=P(x-r*sin(a*pi/180),y+r*cos(a*pi/180));\n                a+=72;\n            }\n            star[i][0]=L(top[i][0],top[i][2]);\n            star[i][1]=L(top[i][0],top[i][3]);\n            star[i][2]=L(top[i][1],top[i][3]);\n            star[i][3]=L(top[i][1],top[i][4]);\n            star[i][4]=L(top[i][2],top[i][4]);\n            //rep(s,5){\n            //    cout<<\"startop\"<<top[i][s]<<endl;\n            //}\n        }\n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                double tmp=INFD;\n                rep(k,5)rep(l,5){\n                    tmp=min(tmp,distanceSS(star[i][k],star[j][l]));\n                    //cout<<\"distanceSS\"<<distanceSS(star[i][k],star[j][l])<<endl;\n                }\n                dist[i][j]=tmp;\n                dist[j][i]=tmp;\n            }\n        }\n        rep(k,n){\n            rep(i,n){\n                rep(j,n){\n                    dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n                    dist[j][i]=dist[i][j];\n                }\n            }\n        }\n        printf(\"%.10lf\\n\",dist[m][l]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\ndouble ex(P a,P b,P c){\n\treturn cross(b-a,c-a);\n}\n\nint ccw(P a, P b, P c) {\n b -= a; c -= a;\n if (cross(b, c) > DBL_EPSILON) return +1; // counter clockwise\n if (cross(b, c) < -DBL_EPSILON) return -1; // clockwise\n if (dot(b, c) < -DBL_EPSILON) return +2; // c--a--b on line\n if (norm(b) < norm(c) - DBL_EPSILON) return -2; // a--b--c on line\n return 0; // a--c--b on line (or b == c)\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\t return ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n\t ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\ndouble DistanceSP(P a, P b, P c) {\n\tif (dot(b - a, c - a) < DBL_EPSILON)\n\t\treturn abs(c - a);\n\tif (dot(a - b, c - b) < DBL_EPSILON)\n\t\treturn abs(c - b);\n\treturn abs(cross(b - a, c - a))/abs(a-b);\n}\ndouble DistaiceSS(P a, P b, P c, P d) {\n\tif (isIntersectSS(a, b, c, d)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a, b, c), DistanceSP(a, b, d)),\n\t\t\tmin(DistanceSP(c, d, a), DistanceSP(c, d, b)));\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta = M_PI / 2 + 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta), p.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\nvector<pair<int,int> > edges;\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(ea,edges){\n\t\tP a1=p1.vertex[(*ea).first];\n\t\tP a2=p1.vertex[(*ea).second];\n\t\tforeach(eb,edges){\n\t\t\tP b1=p2.vertex[(*eb).first];\n\t\t\tP b2=p2.vertex[(*eb).second];\n\t\t//\tcout<< a1<<a2<< b1<< b2 <<endl;\n\t\t//\tcout<< DistaiceSS(a1, a2, b1, b2) <<endl;\n\t\t\tm = min(m, DistaiceSS(a1, a2, b1, b2));\n\t\t}\n\n\t}\n\treturn m;\n}\nint x, y, a, r;\n\ndouble dijk(int start, int goal) {\n\tvector<double> memo(N, DBL_MAX);\n\tpriority_queue<pair<double,int> > up;\n\tup.push(make_pair(0, start));\n\tmemo[start] = 0;\n\twhile (!up.empty()) {\n\t\tdouble cost = -up.top().first;\n\t\tint pos = up.top().second;\n\n\t\tup.pop();\n\t\tif (memo[pos] < cost)\n\t\t\tcontinue;\n\t\tif (pos == goal)\n\t\t\treturn cost;\n\t\tREP0(next,N) {\n\t\t\tif (links[pos][next] >= 0) {\n\t\t\t\tdouble ncost = cost + links[pos][next];\n\t\t\t\tif (memo[next] > ncost) {\n\t\t\t\t\tmemo[next] = ncost;\n\t\t\t\t\tup.push(make_pair(-ncost, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tedges.push_back(make_pair(0,2));\n\tedges.push_back(make_pair(0,3));\n\tedges.push_back(make_pair(1,4));\n\tedges.push_back(make_pair(1,3));\n\tedges.push_back(make_pair(2,4));\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tcout << dijk(M - 1, L - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 999999999\n#define edge pair<pair<double,double>,pair<double,double>>\n#define point pair<double,double>\n#define PI 3.1415926535898\nusing namespace std;\nstruct star{\n    double x;\n    double y;\n    double a;\n    double r;\n};\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 0.00000001;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n\ndouble min_star_dist(star a,star b){\n    const complex<double> arg(cos(PI*72.0/180.0),sin(PI*72.0/180.0));\n    vector<L> a_edges;\n    vector<L> b_edges;\n    vector<P> a_points;\n    vector<P> b_points;\n    complex<double> tmp;\n    tmp=complex<double>(0,a.r);\n    tmp*=complex<double>(cos(PI*a.a/180.0),sin(PI*a.a/180.0));\n    rep(i,5){\n        a_points.push_back(tmp+P(a.x,a.y));\n        tmp*=arg;\n    }\n    tmp=complex<double>(0,b.r);\n    tmp*=complex<double>(cos(PI*b.a/180.0),sin(PI*b.a/180.0));\n    rep(i,5){\n        b_points.push_back(tmp+P(b.x,b.y));\n        tmp*=arg;\n    }\n    rep(i,5){\n        a_edges.emplace_back(a_points[i],a_points[(i+2)%5]);\n        b_edges.emplace_back(b_points[i],b_points[(i+2)%5]);\n    }\n    double ret=INF;\n    rep(i,5){\n        rep(j,5){\n            if(isecSS(a_edges[i].first,a_edges[i].second,b_edges[j].first,b_edges[j].second)){\n                return 0;\n            }\n            double t = distSP(a_edges[i].first,a_edges[i].second,b_points[j]);\n            ret=(ret<t)?ret:t;\n            t = distSP(b_edges[j].first,b_edges[j].second,a_points[i]);\n            ret=(ret<t)?ret:t;\n        }\n    }\n    return ret;\n}\n\nint main(void){\n    int n,m,l;\n    while(cin>>n>>m>>l,n){\n        vector<star> stars(n);\n        vector<vector<double>> dist(n,vector<double>(n,INF));\n        rep(i,n){\n            dist[i][i]=0;\n            double a,b,c,d;\n            cin>>a>>b>>c>>d;\n            stars[i]=(star){a,b,c,d};\n        }\n        rep(i,n-1){\n            for(int j=i+1;j<n;j++){\n                dist[i][j]=dist[j][i]=min_star_dist(stars[i],stars[j]);\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n        }\n        printf(\"%.10lf\\n\",dist[m-1][l-1]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <iomanip>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P, P> SIDE;\n\ntypedef struct{\n\tint x, y, a, r;\n\tvector<SIDE> side;\n}STAR;\n\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n/*\n// ベクトルaの絶対値を求める\ndouble length = abs(a);\n\n// 2点a,b間の距離を求める\ndouble distance = abs(a-b);\n\n// ベクトルaの単位ベクトルを求める\nP b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nP n1 = a * P(0, 1);\nP n2 = a * P(0, -1);\n\n// ベクトルaの単位法線ベクトルun1,un2を求める\nP un1 = (a * P(0, +1)) / abs(a);\nP un2 = (a * P(0, -1)) / abs(a);\n*/\n\n// 回転\nP rotate(P p, int a) {\n  double arg = M_PI / 180 * a;\n  return p * P(cos(arg), sin(arg));\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n\n/*\n// 点cが線分a,b上にあるかないか(1)\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 ) &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\n// 点cが線分a,b上にあるかないか(2)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n*/\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n/*\n//円の交点\npair<P> intersection_circle(P p1,P p2,double r1,double r2){\n  double d = abs(p2-p1);\n  double th = acos((d*d+r1*r1-r2*r2)/(2*d*r1));\n  return make_pair(p1 + polar( r1, arg(p2-p1)+th ), polar( r1, arg(p2-p1)-th ) );\n}\n*/\n\ndouble dist(STAR start, STAR end)\n{\n\tdouble dis = 1000000000;\n\tfor(int i = 0; i < 5; i++) {\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tif(is_intersected_ls(start.side[i].first, start.side[i].second, end.side[j].first, end.side[j].second)) dis = 0;\n\t\t\tdis = min(dis, distance_ls_p(start.side[i].first, start.side[i].second, end.side[j].first));\n\t\t\tdis = min(dis, distance_ls_p(start.side[i].first, start.side[i].second, end.side[j].second));\n\t\t}\n\t}\n\treturn dis;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif(N == 0) break;\n\t\tvector<STAR> stars;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<SIDE> tmp;\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tP start = rotate(P(0, r), a + 72 * j) + P(x, y);\n\t\t\t\tP end = rotate(P(0, r), a + 72 * (j + 1)) + P(x, y);\n\t\t\t\ttmp.push_back(SIDE(start, end));\n\t\t\t}\n\t\t\tSTAR star = {x, y, a, r, tmp};\n\t\t\tstars.push_back(star);\n\t\t}\n\t\tdouble distance[100][100];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tdistance[i][j] = dist(stars[i], stars[j]);\n\t\t\t\t//cout << distance[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tdistance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << setprecision(10) << distance[M-1][L-1] << endl;\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef complex < double > P;\ntypedef pair < double, int > Pi;\ntypedef pair < P, P >      L;\ntypedef pair < P, P >      Ls;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l.fr, l.fr - l.sc) / norm( l.fr - l.sc);\n  return l.fr + t * ( l.fr - l.sc);\n}\nbool intersect( L a, P p){ //OK\n   return abs( a.fr - p) + abs( a.sc - p) - abs( a.fr - a.sc) < EPS;\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a.fr, a.sc, b.fr) * ccw( a.fr, a.sc, b.sc) <= 0 &&\n    ccw( b.fr, b.sc, a.fr) * ccw( b.fr, b.sc, a.sc) <= 0;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s.fr - p), abs( s.sc - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b.fr), distance( a, b.sc)),\n              min( distance( b, a.fr), distance( b, a.sc)));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\ndouble info[100][100];\nbool used[100];\nint n, m, l;\nL stars[100][5];\nint table[][5] = {{0,0,1,1,2},{2,3,3,4,4}};\nP hosi[5];\nvoid add( double x, double y, double a, double r, int z){\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[z][i] = L( hosi[table[0][i]], hosi[table[1][i]]);\n  }\n}\ndouble Dijkstra(){\n  priority_queue< Pi , vector< Pi > , greater< Pi > > que;\n  fill_n( used, 100, false);\n  que.push( Pi( 0.0, m));\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.sc == l) return p.fr;\n    if(used[p.sc]++) continue;\n    for(int i = 0 ; i < n ; i++ )\n      que.push( Pi( info[p.sc][i] + p.fr, i));\n  }\n}\nint main(){ //vectorが重いかも\n  while(scanf(\"%d%d%d\", &n, &m, &l), n|m|l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      double x, y, a, r;\n      scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &r);\n      add( x, y, a, r, i);\n    }\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    printf(\"%.10f\\n\", Dijkstra());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n/*\n  ベクトルの内積\n  a.real() * b.real() + a.imag() * b.imag()\n*/\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\n\n/*\n  ベクトルの外積\n  a.real() * b.imag() - a.imag() * b.real()\n*/\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n// 回転行列\nP rotate(P p, double theta,double cx,double cy){\n  theta = theta * M_PI / 180.0;\n  p.real()-=cx; p.imag()-=cy;\n  double x = real(p) * cos(theta) - imag(p) * sin(theta);\n  double y = real(p) * sin(theta) + imag(p) * cos(theta);\n  x+=cx; y+=cy;\n  return P(x,y);\n}\n\n// ベクトル a,b の位置関係\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n\n// 線分と線分の交差判定（交差していたらtrue）\nbool isIntersect(L s1, L s2){\n  \n  //ccw による判定だけだと, 二線分が同一直線上にあるときに間違うため、追加\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n// 線分と点の距離\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //直線と点の距離\n}\n\n// 線分と線分の距離\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\ndouble AngleToRad(double angle){\n  return angle * M_PI / 180.0;\n}\n\nstruct star{\n  L line[5];\n  void set(double x,double y,double a,double r){\n    P p[5];\n    double angle = 90;\n    for(int i=0;i<5;i++){\n      double rad = AngleToRad(angle);\n      p[i] = P(x+r*cos(rad),y+r*sin(rad));\n      p[i] = rotate(p[i],a,x,y);\n      angle -= 72;\n    }\n    for(int i=0;i<5;i++)\n      line[i] = L(p[i],p[(i+2)%5]);\n  }\n\n  double getDis(const star &s){\n    double ret = 1e15;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n\tret = min( ret , getDistanceSS(line[i],s.line[j]) );\n      }\n    }\n    return ret;\n  }\n\n};\n\ntypedef pair<double,int> PA;\n\nint N,B,A;\nstar S[111];\ndouble Dis[111];\n\nint main(){\n  while( (~scanf(\"%d%d%d\",&N,&B,&A)) && (N||B||A) ){\n    for(int i=0;i<N;i++){\n      int x,y,a,r;\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      S[i].set(x,y,a,r);\n    }\n    --B;--A;\n    priority_queue<PA,vector<PA>,greater<PA> > q;\n    fill(Dis,Dis+N,1e15);\n    q.push( PA(0.0,B) );\n    Dis[B] = 0.0;\n    while( !q.empty() ){\n      PA  p = q.top(); q.pop();\n      int now = p.second;\n      double c = p.first;\n      if( Dis[p.second] < p.first ) continue;\n      for(int i=0;i<N;i++){\n\tif( now == i ) continue;\n\tdouble nc = c + S[now].getDis(S[i]);\n\tif( Dis[i] > nc+EPS ) {\n\t  Dis[i] = nc;\n\t  q.push( PA(nc,i) );\n\t}\n      }\n    }\n    printf(\"%.9lf\\n\",Dis[A]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst double EPS = 1e-10;\nconst double PI = 3.141592653589793;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point { // ???\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\t// bool operator < (const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator < (const Point &p) const { // ??????????¨±???????????????\n\t\treturn x + EPS < p.x || (eq<double>(x, p.x) && y + EPS < p.y);\n\t}\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>; // ????§???¢\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\ndouble length(const Point& a) { return a.abs(); } // ???????????????\nPoint rotationalTransfer(const Point& a, const Point& c, double deg) { // a???c???????????¨??????deg????????¢?????????\n\tdouble rad = PI * deg / 180.0;\n\t// return Point(a.x * cos(rad) - a.y * sin(rad) + c.x, a.x * sin(rad) + a.y * cos(rad) + c.y);\n\t// return c + Point()\n}\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment { //??????\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { // ?????????????????????true\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//*** ??????????????? ***\nPoint getCrossPoint(Segment s1, Segment s2) { // ???????????????????????¨??????????????????????????????????????¨\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1)), d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t  = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2) { // ??????s1??¨??????s2?????????\n\tif( intersect(s1, s2) ) return 0.0; //????????£???????????¨???\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\nconst int MAX_N = 210;\nusing TYPE = double; // ?????¢???????????\\??????\nvector<pair<int, TYPE> > G[MAX_N];\nvector<TYPE> dijkstra(int start){\n\tvector<TYPE> dist(MAX_N, INFF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<TYPE, int>, vector<pair<TYPE, int> >, greater<pair<TYPE, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tTYPE cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; TYPE time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\n\nint main(void){\n\t\n\twhile(1) {\n\n\t\tint N, M, L; scanf(\"%d %d %d\", &N, &M, &L);\n\t\tif(N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\tvector<vector<Segment>> star;\n\t\t\n\t\trep(i, N){\n\t\t\tdouble x, y, a, r; scanf(\"%lf %lf %lf %lf\", &x, &y, &a, &r);\n\t\t\tPoint c(x, y);\n\t\t\tPoint s(x, y + r);\n\t\t\tvector<Point> v;\n\t\t\t// rep(j, 5) v.pb(rotationalTransfer(s, c, a + 72.0 * j));\n\t\t\trep(j, 5) {\n\t\t\t\tdouble rad = (90 + a + j * 72) * PI / 180.0;\n\t\t\t\tv.pb(Point(x, y) + Point(cos(rad), sin(rad)) * r);\n\t\t\t}\n\t\t\tvector<Segment> seg;\n\t\t\t// ??????5????????????\n\t\t\trep(j, 5) seg.pb(Segment(v[j % 5], v[(j + 2) % 5]));\n\t\t\tstar.pb(seg);\n\t\t}\n\t\t\n\t\trep(i, MAX_N) G[i].clear();\n\t\t\n\t\trep(i, star.size())rep(j, star.size()){\n\t\t\tif(i == j) continue;\n\t\t\tdouble mi = INF;\n\t\t\tfor(auto u : star[i])for(auto v : star[j]){\n\t\t\t\tchmin(mi, getDistanceSS(u, v));\n\t\t\t}\n\t\t\t// printf(\"mi %f\\n\", mi);\n\t\t\tG[i].pb(mp(j, mi)), G[j].pb(mp(i, mi));\n\t\t}\n\n\t\tauto ret = dijkstra(M);\n\t\tprintf(\"%.9f\\n\", ret[L]);\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <iomanip>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N,S,G = 0;\n\ndouble l[110][110] = {};\ndouble nowL[110] = {};\nconst double PI = 3.14159265358979;\nstruct Star {\n\tconst int px, py,a;\n\tdouble x[5], y[5];\n\tStar(int _px, int _py, int _a, int _r) :px(_px),py(_py),a(_a) {\n\t\tfor (int i = 0; i < 5;i++) {\n\t\t\tx[i] = px + _r * cos((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t\ty[i] = py + _r * sin((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t}\n\t};\n};\n\nStar *s[105];\n\ndouble MinL(double x0, double y0, double x1, double y1, double x2, double y2) {\n\tdouble dx = x1 - x2, dy = y1 - y2;\n\tdouble x = (dx*dx*x0 - dx*dy*y0 + dy*(dx*y2 - dy*x2)) / (dx*dx - dy*dy);\n\tdouble d;\n\tif (min(x1, x2) <= x && x <= max(x1, x2)) {\n\t\td=abs(dy*x0 - dx*y0 + x1*y2 - x2*y1) / hypot(dx, dy); \n\t}\n\telse {\n\t\td=min(hypot(x1 - x0, y1 - y0), hypot(x2 - x0, y2 - y0));\n\t}\n\treturn d;\n}\n\nvoid CalcStar(int a, int b) {\n\tconst unsigned lineGoal[5]={2,3,4,0,1};\n\tdouble temp = 100000;\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0; j < 5;j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[a]->x[i], s[a]->y[i],\n\t\t\t\ts[b]->x[j], s[b]->y[j],\n\t\t\t\ts[b]->x[lineGoal[j]], s[b]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[b]->x[i], s[b]->y[i],\n\t\t\t\ts[a]->x[j], s[a]->y[j],\n\t\t\t\ts[a]->x[lineGoal[j]], s[a]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tl[b][a] = l[a][b] = temp;\n}\n\ndouble minCost[110];\nvoid Dijkstra(int _s,int _g) {\n\tfor (int i = 1; i <= N;i++) {\n\t\tminCost[i] = 1000000;\n\t}\n\tminCost[_s] = 0;\n\tstruct Node {\n\t\tint num;\n\t\tdouble cost;\n\t\tbool operator > (const Node& _node)const {\n\t\t\treturn cost > _node.cost;\n\t\t}\n\t};\n\tpriority_queue<Node,vector<Node>,greater<Node>> PQ;\n\tNode node = { _s, 0 };\n\tPQ.push( node );\n\twhile (!PQ.empty()){\n\t\tNode now = PQ.top(); PQ.pop();\n\t\tif (now.cost > minCost[now.num]) {\n\t\t\tcontinue;\n\t\t}\n\t\tminCost[now.num] = now.cost;\n\t\tif (now.num==_g) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= N;i++) {\n\t\t\tif (i!=now.num) {\n\t\t\t\tNode node = { i,now.cost + l[now.num][i] };\n\t\t\t\tPQ.push(node);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (true){\n\t\tcin >> N >> S >> G;\n\t\tif (N==0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ts[i] = new Star(x, y, a, r);\n\t\t\tnowL[i] = 5000;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\t\tCalcStar(i, j);\n\t\t\t}\n\t\t}\n\t\tDijkstra(S, G);\n\t\tcout << fixed << setprecision(7) << minCost[G] << endl;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdelete s[i];\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\nint N,M,L;\n\nint main()\n{\n\tP pt[101][5];\n    while(cin>>N>>M>>L,(N||M||L)){\n        for (int i = 0; i < N; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n   \n\t\tint f1[]={0,2,4,1,3,0};\n\t\tdouble dp[100][100];\n        for(int i = 0; i < N; i++) for (int j = 0; j < N; j++){\n\t\t\tdp[i][j] = 1e100;\n\t\t\tfor (int a = 0; a < 5; a++) for(int b = 0; b < 5; b++){\n\t\t\t\tS s(pt[i][f1[a]], pt[i][f1[a+1]]);\n\t\t\t\tS t(pt[j][f1[a]], pt[j][f1[a+1]]);\n                dp[i][j] = min(dp[i][j],dist(s,t));\n\t\t\t}\n\t\t}\n   \n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++)\n                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n   \n        printf(\"%.20lf\\n\",dp[M - 1][L - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\ndouble deg2rad(double deg) {\n    return deg * 2. * PI / 360;\n}\n\n// q????????????p???theta?????¢(???????¨????????????£)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\ndouble distanceLP(L l, P p) {\n    return abs(cross(l.v, p - l.a)) / abs(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.v, p - l.a) < 0) return abs(p - l.a);\n    if (dot(-l.v, p - l.b) < 0) return abs(p - l.b);\n    return distanceLP(l, p);\n}\n\ndouble distanceSS(L l1, L l2) {\n    if (intersectSS(l1, l2)) return 0;\n    double d = INF;\n    d = min(d, distanceSP(l1, l2.a));\n    d = min(d, distanceSP(l1, l2.b));\n    d = min(d, distanceSP(l2, l1.a));\n    d = min(d, distanceSP(l2, l1.b));\n    return d;\n}\n\nstruct Star {\n    P c;\n    double r;\n    vector<P> p;\n    vector<L> l;\n    Star(){}\n    Star(double x, double y, double deg, double _r) : c(x, y), r(_r) {\n        rep(i, 5) {\n            p.emplace_back(rotP(P(x, y + r), c, deg2rad(deg + 72 * i)));\n            // cout << p[i].real() << \" \" << p[i].imag() << endl;\n        }\n        rep(i, 5) {\n            l.emplace_back(L(p[i], p[(i + 2) % 5]));\n        }\n    }\n    double dist(const Star& o) {\n        double ret = INF;\n        rep(i, 5) {\n            rep(j, 5) {\n                ret = min(ret, distanceSS(l[i], o.l[j]));\n            }\n        }\n        return ret;\n    }\n};\n\nstruct edge {\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to, double _cost) : to(_to), cost(_cost) {}\n};\ntypedef vector<vector<edge>> Graph;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, double c) {\n    G[x].emplace_back(y, c);\n    G[y].emplace_back(x, c);\n}\n\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    using Pdi = pair<double, int>;\n    priority_queue<Pdi, vector<Pdi>, greater<Pdi>> pq;   // cost, vertex\n    vector<double> d(n, INF);\n    d[s] = 0.;\n    pq.push(make_pair(0., s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nvoid printGraph(const Graph& G) {\n    rep(i, G.size()) {\n        cout << i << \": \";\n        rep(j, G[i].size()) {\n            cout << \"{\" << G[i][j].to << \", \" << G[i][j].cost << \"}, \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, s, g;\n    while (cin >> n >> s >> g, n) {\n        s--; g--;\n\n        vector<Star> stars;\n        rep(i, n) {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            stars.emplace_back(x, y, a, r);\n        }\n\n        Graph G(n);\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                addEdge(G, i, j, stars[i].dist(stars[j]));\n            }\n        }\n\n        // printGraph(G);\n\n        cout << fixed << setprecision(20) << dijkstra(G, s, g) << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define FOR(i,a,n) for(int i = (a);i < (n);i++)\nconst double M_PI = acos(-1);\nconst double EPS = 1e-10;\nconst double INF = 1e9;\nusing namespace std;\n\nint N,M,L;\n\nstruct Point{\n    double x,y;\n    Point operator - (const Point& p){ return Point{x-p.x,y-p.y};}\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\ndouble norm(Point a){return a.x*a.x+a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a,Point b){return a.x*b.y - a.y*b.x;}\n\nint ccw(Point p1,Point p2,Point p3){\n    Point a = {p2.x-p1.x, p2.y - p1.y};\n    Point b = {p3.x-p1.x, p3.y - p1.y};\n    if(cross(a,b) > EPS) return 1;\n    if(cross(a,b) < -EPS) return -1;\n    if(dot(a,b) < -EPS) return 2;\n    if(norm(a) < norm(b)) return -2;\n    return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1,s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < -EPS) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < -EPS) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n    \n\nSegment star[102][5];\ndouble mindist[102][102];\n\n\n\ndouble getdist(int u, int v){\n    REP(i,5){\n        REP(j,5){\n            if(intersect(star[u][i],star[v][j])){\n                    return 0;\n            }\n        }\n    }\n    double ans = INF;\n    REP(k,2){\n        if(k) swap(u,v);\n        REP(i,5){\n            REP(j,5){\n                ans = min(getDistSP(star[u][i],star[v][j].p1),ans);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>N>>M>>L,N){\n        REP(i,N){\n            int x,y,a,r;\n            cin>>x>>y>>a>>r;\n            Point p[5];\n            REP(j,5) p[j] = Point{x + r*sin((double)(72*j - a)/180*M_PI), y + r*cos((double)(72*j - a)/180*M_PI)};//star's vertex\n            REP(j,5){\n                star[i][j] = Segment{p[j], p[(j+2)%5]};\n            }\n        }\n\n        //caluculate min distance\n        REP(i,N){\n            FOR(j,i,N){\n                mindist[i][j] = mindist[j][i] = getdist(i,j);\n            }\n        }\n\n        //WF        \n        REP(k,N){\n            REP(i,N){\n                REP(j,N){\n                    mindist[i][j] = min(mindist[i][j], mindist[i][k] + mindist[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(8) << mindist[M-1][L-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n//for vector\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline D seg_seg_dis(L a,L b){\n  D res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nD g[111][111];\n\nint main(){\n  int n,m,l;\n  while(scanf(\"%d%d%d\",&n,&m,&l), n){\n    vector< vector<L> > stars(n);\n    for(int i=0;i<n;i++){\n      int x,y,a,r;\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      P c = P(x,y);\n\n      vector<P> v(5);\n      P p = P(0,r);\n      for(int j=0;j<5;j++){\n\tv[j] = c+rotate(p,PI*(a+j*72)/180);\n      }\n      \n      vector<L> l(5);\n      for(int j=0;j<5;j++){\n\tl[j] = L(v[j],v[(j+2)%5]);\n      }\n      stars[i] = l;\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : stars[i]){\n\t  for(L b : stars[j]){\n\t    if(is_cp(a,b)){\n\t      dis = 0;\n\t      break;\n\t    }else dis = min(dis, seg_seg_dis(a,b));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n      g[i][i] = 0;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    printf(\"%.9lf\\n\",g[m-1][l-1]);\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nPoly rotate_poly(Poly po,Point c,R a){//???????¨???????\n    REP(i,po.size()){\n        po[i] = Point(po[i].real() - c.real(),po[i].imag() - c.imag());\n        po[i] = po[i] * Point(cos(a),sin(a));\n        po[i] = Point(po[i].real() + c.real(),po[i].imag() + c.imag());\n    }\n    return po;\n}\n\nR convert_deg_to_rad(R deg){\n    return deg / 180.0 * M_PI;\n}\n\nint N, M, L;\nPoly star[100];\n\nbool input() {\n  cin>>N>>M>>L;\n  R x, y, a, r;\n  REP(i, N) {\n    star[i].clear();\n    cin>>x>>y>>a>>r;\n    R ar = convert_deg_to_rad(a+90.0);\n    REP(j,5) {\n      star[i].pb(Point(x, y)+r*Point(cos(ar), sin(ar)));\n      ar += convert_deg_to_rad(72.0);\n    }\n  }\n  return N!=0;\n}\n\n#define INF 1000000000.0\nR G[100][100];\n\nvoid solve() {\n  fill((R *)G, (R *)G+10000, INF);\n  REP(i,N) {\n    G[i][i] = 0.0;\n  }\n\n  R dis;\n  REP(i, N) {\n    FOR(j, i+1, N) {\n      dis = INF;\n      REP(k, 5) {\n        REP(l, 5) {\n          dis = min(dis,dis_ss(Line(star[i][k],star[i][(k + 2) % 5]), Line(star[j][l], star[j][(l+2)%5])) );\n        }\n      }\n      G[i][j] = dis;\n      G[j][i] = dis;\n      //cout<<i<<','<<j<<':'<<dis<<endl;\n    }\n  }\n  REP(k,N){\n    REP(i,N){\n      REP(j,N){\n        G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n      }\n    }\n  }\n  printf(\"%0.10lf\\n\",G[M-1][L-1]);\n  //cout<<showpoint<<G[M-1][L-1]<<endl;\n}\n\nint main() {\n  while(input()) {\n    /*REP(i, N) {\n      REP(j, 5) {\n        cout<<star[i][j]<<' ';\n      }\n      cout<<endl;\n    }*/\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\nconst double INF = 1e9;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n#define X real()\n#define Y imag()\n\n\ndouble dot(Point a, Point b){\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b){\n    return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b,c) > +EPS) return +1;\n    if(cross(b,c) < -EPS) return -1;\n    if(dot(b,c)   < -EPS) return +2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\n\nbool isecSS(Point a1,Point a2,Point b1,Point b2){\n    return ccw(a1,a2,b1)*ccw(a1,a2,b2) <= 0 &&\n           ccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n\nbool isecSP(Point a1,Point a2,Point b){\n    return !ccw(a1,a2,b);\n}\n\nPoint proj(Point a1, Point a2, Point p){\n    return a1 + dot(a2-a1, p-a1)/norm(a2-a1)*(a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p){\n    Point r = proj(a1,a2,p);\n    if(isecSP(a1,a2,r)) return abs(r-p);\n    return min(abs(a1-p),abs(a2-p));\n}\n\n\ndouble distSS(Point a1,Point a2,Point b1,Point b2){\n    if(isecSS(a1,a2,b1,b2)) return 0;\n    return min({\n        distSP(a1,a2,b1),\n        distSP(a1,a2,b2),\n        distSP(b1,b2,a1),\n        distSP(b1,b2,a2)});\n}\n\nVP make_star(double x,double y,double a,double r){\n    VP s(5);\n    rep(i,5){\n        s[i] = Point(x,y) + polar(r, (90+a+144*i)*PI/180.0);\n    }\n    return s;\n}\n\ndouble dist_star(VP s1, VP s2){\n    double res = INF;\n    rep(i,5)rep(j,5){\n        double dist = distSS(s1[i],s1[(i+1)%5], s2[j],s2[(j+1)%5]);\n        res = min(res,dist);\n    }\n    return res;\n}\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L, N|M|L){\n        vector<VP> st(N);\n        rep(i,N){\n            double x,y,a,r;\n            cin>>x>>y>>a>>r;\n            st[i] = make_star(x,y,a,r);\n        }\n        vector<vector<double>> d(N, vector<double>(N, INF));\n        rep(i,N) d[i][i] = 0;\n        rep(i,N)rep(j,i){\n            double dist = dist_star(st[i],st[j]);\n            d[i][j] = dist;\n            d[j][i] = dist;\n        }\n        rep(k,N)rep(i,N)rep(j,N) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n        printf(\"%.20f\\n\",d[M-1][L-1]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <utility>\n\nconst double PI=3.14159265358979323846264;\nconst double EPS=1e-9;\nconst double INF=1e12;\n\nusing Point=std::complex<double>;\nusing LineSeg=std::pair<Point, Point>;\n\ndouble dot(const Point &a, const Point &b) {\n    return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(const Point &a, const Point &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\nenum CCWise {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nCCWise ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool crossed(const LineSeg &s, const LineSeg &t) {\n    const Point &s1=s.first, &s2=s.second, &t1=t.first, &t2=t.second;\n    if (ccw(s1, s2, t1) * ccw(s1, s2, t2) > 0)\n        return false;\n\n    return ccw(t1, t2, s1) * ccw(t1, t2, s2) <= 0;\n}\n\nstruct Star {\n    Point p;\n    double angle, radius;\n    Point pts[5];\n    Star(double x, double y, double a, double r):\n        p(x, y), angle(a), radius(r)\n    {\n        pts[0] = p + std::polar(r, (90+angle)*PI/180);\n        Point q=std::polar(2*r*std::cos(18*PI/180), (108+angle)*PI/180);\n        for (int i=1; i<5; ++i) {\n            q *= std::polar(1.0, 144*PI/180);\n            pts[i] = pts[i-1] + q;\n        }\n    }\n    double howfar(const Star &other) const {\n        double res=INF;\n\n        for (size_t i=0; i<5; ++i)\n            for (size_t j=0; j<5; ++j) {\n                if (crossed({pts[i], pts[(i+1)%5]},\n                            {other.pts[j], other.pts[(j+1)%5]}))\n                    return 0.0;\n\n                res = std::min(res, std::abs(pts[i]-other.pts[j]));\n            }\n\n        return res;\n    }\n};\n\nint testcase_ends() {\n    size_t N, M, L;\n    scanf(\"%zu %zu %zu\", &N, &M, &L);\n\n    if (N == 0 && M == 0 && L == 0)\n        return 1;\n\n    std::vector<Star> s;\n    s.reserve(N);\n    for (size_t i=0; i<N; ++i) {\n        int x, y, a, r;\n        scanf(\"%d %d %d %d\", &x, &y, &a, &r);\n        s.emplace_back(x, y, a, r);\n    }\n\n    std::vector<std::vector<double>> dist(N, std::vector<double>(N));\n    for (size_t i=0; i<N; ++i)\n        for (size_t j=i+1; j<N; ++j)\n            dist[i][j] = dist[j][i] = s[i].howfar(s[j]);\n\n    for (size_t k=0; k<N; ++k)\n        for (size_t i=0; i<N; ++i)\n            for (size_t j=0; j<N; ++j)\n                if (dist[i][j] > dist[i][k] + dist[k][j])\n                    dist[i][j] = dist[i][k] + dist[k][j];\n\n    printf(\"%.12f\\n\", dist[--M][--L]);\n    return 0;\n}\n\nint main() {\n    while (true)\n        if (testcase_ends()) break;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) loop(i,0,b)\ndouble const pi = acos(-1);\ndouble const inf = 1e100;\ndouble const eps = 1e-8;\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\ninline double cross(const point& a, const point& b) {\n    return imag(conj(a)*b);\n}\n\ninline double dot(const point& a, const point& b) {\n    return real(conj(a)*b);\n}\n\nstruct line : public vector<point> {\n    line(const point &a, const point &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ninline int ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\nbool intersectSS(const line &s, const line &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npoint projection(const line &l, const point &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\nbool intersectSP(const line &s, const point &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\ndouble distanceSP(const line &s, const point &p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const line &s, const line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s,t[0]), distanceSP(s,t[1])),\n               min(distanceSP(t,s[0]), distanceSP(t,s[1])));\n}\n\nint N,M,L;\ndouble x[128], y[128], a[128], r[128];\n\ndouble u = 2*pi/5;\ndouble distanceStarStar(int s1, int s2){\n    point p1(x[s1],y[s1]), p2(x[s2],y[s2]);\n    double r1=r[s1], r2=r[s2], t1=a[s1], t2=a[s2];\n    double res = inf;\n    rep(i1,5)rep(i2,5){\n        line l1(p1 + polar(r1,t1+u*i1 + pi/2),\n                p1 + polar(r1,t1+u*(2+i1) + pi/2));\n        line l2(p2 + polar(r2,t2+u*i2 + pi/2),\n                p2 + polar(r2,t2+u*(2+i2) + pi/2));\n        res = min(res, distanceSS(l1,l2));\n        if(abs(res)<eps) return 0;\n    }\n    return res;\n}\n\ndouble solve(){\n    M--; L--;\n    double d[128][128];\n    rep(i,N)loop(j,i,N){\n        d[i][j] = i==j ? 0 : distanceStarStar(i,j);\n        d[j][i] = d[i][j];\n    }\n    rep(k,N)rep(i,N)rep(j,N){\n        d[i][j] = min(d[i][k]+d[k][j], d[i][j]);\n    }\n    return d[M][L];\n}\n\nint main(){\n    while(scanf(\"%d%d%d\",&N,&M,&L), N|M|L){\n        rep(i,N){\n            scanf(\"%lf%lf%lf%lf\",x+i,y+i,a+i,r+i);\n            a[i]=a[i]*pi/180;\n        }\n        printf(\"%.20lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\n#define double long double\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nconstexpr double eps=1e-9;\nconstexpr double PI=3.14159265358979323846264338327950;\n \ninline int sgn(double x){\n    if(x<-eps) return -1;\n    if(x>eps) return 1;\n    return 0;\n}\n \ninline bool EQ(double x, double y){\n    return sgn(x-y)==0;\n}\n \ninline bool GE(double x, double y){\n    return sgn(x-y)==1;\n}\n \ninline bool LE(double x, double y){\n    return sgn(x-y)==-1;\n}\n \ninline bool GEQ(double x, double y){\n    return sgn(x-y)>=0;\n}\n \ninline bool LEQ(double x, double y){\n    return sgn(x-y)<=0;\n}\n \nstruct Point{\n    double x, y;\n    Point(double x=0, double y=0): x(x), y(y){}\n \n    Point operator+(const Point &p){\n        return {x+p.x, y+p.y};\n    }\n \n    Point operator-(const Point &p){\n        return {x-p.x, y-p.y};\n    }\n \n    Point operator*(const double k){\n        return {k*x, k*y};\n    }\n \n    Point operator/(const double k){\n        return {x/k, y/k};\n    }\n \n    double operator*(const Point &p){\n        return x*p.x+y*p.y;\n    }\n \n    double operator^(const Point &p){\n        return x*p.y-y*p.x;\n    }\n \n    bool operator==(const Point &p){\n        return EQ(x, p.x) && EQ(y, p.y);\n    }\n \n    bool operator<(const Point &p) const{\n        if(EQ(x, p.x)) return LE(y, p.y);\n        return LE(x, p.x);\n    }\n};\n\nusing Vec=Point;\nusing Polygon=vector<Point>;\n\ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n    return sqrt(norm(p));\n}\n\nPoint rot(Point p, double t){\n    return {p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)};\n}\n\nconstexpr int CCW_COUNTER_CLOCKWISE=1; //反時計回り\nconstexpr int CCW_CLOCKWISE=-1; //時計回り\nconstexpr int CCW_ONLINE_BACK=-2; //一直線, C->A->B\nconstexpr int CCW_ONLINE_FRONT=2; //一直線, A->B->C\nconstexpr int CCW_ON_SEGMENT=0; //一直線, A->C->B\n \ninline int ccw(Point a, Point b, Point c){\n    Vec v=b-a, w=c-a;\n    if(GE(v^w, 0)) return CCW_COUNTER_CLOCKWISE;\n    if(LE(v^w, 0)) return CCW_CLOCKWISE;\n    if(LE(v*w, 0)) return CCW_ONLINE_BACK;\n    if(LE((a-b)*(c-b), 0)) return CCW_ONLINE_FRONT;\n    return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point a, Point b, Point c, Point d){\n    return ccw(a, b, c)*ccw(a, b, d)<=0 && ccw(c, d, a)*ccw(c, d, b)<=0;\n}\n\ndouble getDistanceLP(Point a, Vec v, Point p){\n    return abs(v^(p-a)/abs(v));\n}\n\ndouble getDistanceSP(Point a, Point b, Point p){\n    if(LE((b-a)*(p-a), 0)) return abs(p-a);\n    if(LE((a-b)*(p-b), 0)) return abs(p-b);\n    return getDistanceLP(a, b-a, p);\n}\n\ndouble getDistanceSS(Point a, Point b, Point c, Point d){\n    if(intersectSS(a, b, c, d)) return 0;\n    return min({getDistanceSP(a, b, c), getDistanceSP(a, b, d), getDistanceSP(c, d, a), getDistanceSP(c, d, b)});\n}\n\nint main(){\n    int n, M, L;\n    while(scanf(\"%d%d%d\", &n, &M, &L) && n){\n        --M; --L;\n        Polygon p[n];\n        rep(i, n){\n            Point c; double a, r;\n            scanf(\"%Lf%Lf%Lf%Lf\", &c.x, &c.y, &a, &r);\n            p[i].push_back({c.x, c.y+r});\n\n            For(k, 1, 5) p[i].push_back(c+rot(p[i][0]-c, PI*72*k/180));\n\n            rep(k, 5) p[i][k] = c+rot(p[i][k]-c, PI*a/180);\n        }\n\n        double d[n][n];\n        rep(i, n){\n            rep(j, n)if(i != j){\n                double tmp = INF;\n                rep(k, 5)rep(l, 5){\n                    chmin(tmp, getDistanceSS(p[i][k], p[i][(k+2)%5], p[j][l], p[j][(l+2)%5]));\n                }\n                d[i][j] = tmp;\n            }\n            d[i][i] = 0;\n        }\n\n        rep(k, n)rep(i, n)rep(j, n){\n            chmin(d[i][j], d[i][k] + d[k][j]);\n        }\n        printf(\"%.20Lf\\n\", d[M][L]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace geo {\n\n// ???????????§??????\n\ntypedef std::complex<double> Point;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef std::vector<Point> Polygon;\n\n\n// ?????°, ??????\n\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\nconst double INF = 1e16;\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE \t\t= -1;\nconst int ONLINE_BACK\t\t= 2;\nconst int ONLINE_FRONT\t\t= -2;\nconst int ON_SEGMENT\t\t= 0;\nconst int OUT\t\t\t\t= 0;\nconst int ON\t\t\t\t= 1;\nconst int IN\t\t\t\t= 2;\n\ninline double square(double a){return a * a;}\ninline bool equal(double a, double b){return abs(a - b) < EPS;}\ninline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\ninline double norm(const Point &a){return square(a.real()) + square(a.imag());}\ninline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\ninline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\ninline double toDeg(double t){return t / PI * 180;}\ninline double toRad(double t){return t / 180 * PI;}\n\n#define curr(v, i) v[i]\n#define next(v, i) v[(i + 1) % v.size()]\n#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\n\n// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n// ????§?????????????????????? Point rp ?????£??\\????????????\n\nbool cmpx(const Point &a, const Point &b){\n\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\treturn b.imag() < b.imag();\n}\n\nbool cmpy(const Point &a, const Point &b){\n\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\treturn a.real() < b.real();\n}\n\nPoint rp;\nbool cmparg(const Point &a, const Point &b){\n\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\tif (!equal(rada, radb)) return rada < radb;\n\treturn norm(a) < norm(b);\n}\n\n\n// ??´???, ??????\n\nbool orthgonal(const Vector &a, const Vector &b){\n\treturn equal(dot(a, b), 0.0);\n}\n\nbool parallel(const Vector &a, const Vector &b){\n\treturn equal(cross(a, b), 0.0);\n}\n\n\n// ????°?, ?°???±\n\nPoint project(const Segment &s, const Point &p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(const Segment &s, const Point &p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n\n// ??????????????????\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n// ?????¢\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1) / std::abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\nbool intersect(const Segment &s1, const Segment &s2);\ndouble distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tstd::min(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n\n// ????????????\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &s){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = distanceSP(s, c.p) - c.r;\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\nint intersect(const Circle &c1, const Circle &c2){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\treturn 0;\n}\n\n\n// ??????\n\nPoint crossPoint(const Segment &s1, const Segment &s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = std::abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = std::abs(cross(base, s1.p2 - s2.p1));\n\t\n\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\tassert(!equal(d1 + d2, 0.0));\n\t\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nstd::vector<Point> crossPoints(const Circle &c, const Line &l){\n\tstd::vector<Point> res;\n\tif (!intersect(c, l)) return res;\n\t\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = std::sqrt(c.r * c.r - norm(pr - c.p));\n\tres.push_back(pr + e * base);\n\tres.push_back(pr - e * base);\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\treturn res;\n}\n\nstd::vector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\tstd::vector<Point> res;\n\tif (!intersect(c1, c2)) return res;\n\t\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tres.push_back(c1.p + std::polar(c1.r, t + a));\n\tres.push_back(c1.p + std::polar(c1.r, t - a));\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\n\treturn res;\n}\n\n\n// ??????\n\nint contains(const Polygon &g, const Point &p){\n\tint n = g.size();\n\tbool res = false;\n\tfor (int i = 0; i < n; i++){\n\t\tPoint a = g[i] - p;\n\t\tPoint b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t}\n\treturn res ? IN : OUT;\n}\n\n\n// ??????\n\nPolygon convexHull(std::vector<Point> s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tstd::sort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\tstd::reverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\t\n\treturn l;\n}\n\t\n\n// ???????§???¢??????\n\nPolygon convexCut(const Polygon &g, const Line &l){\n\tPolygon res;\n\tfor (int i = 0; i < g.size(); i++){\n\t\tconst Point &a = curr(g, i);\n\t\tconst Point &b = next(g, i);\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\tres.push_back(a);\n\t\t}\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n}\n\nnamespace std {\nbool operator < (const geo::Point &a, const geo::Point &b){\n\treturn geo::cmpx(a, b);\n}\n}\n\nint n, m, l;\ndouble x[1000], y[1000], r[1000], a[1000];\nstd::vector<geo::Point> ps[100];\nstd::vector<geo::Segment> star[100];\n\ndouble solve()\n{\n\tstatic double dist[100][100];\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tdouble t = geo::INF;\n\t\t\tfor (auto &S : star[i]){\n\t\t\t\tfor (auto &T : star[j]){\n\t\t\t\t\tt = std::min(t, geo::distance(S, T));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist[i][j] = dist[j][i] = t;\n\t\t}\n\t}\n\t\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tdist[i][j] = std::min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dist[m][l];\n}\n\nint main()\n{\n\twhile (std::scanf(\"%d %d %d\", &n, &m, &l), n){\n\t\tm--; l--;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tstd::scanf(\"%lf %lf %lf %lf\", x + i, y + i, a + i, r + i);\n\t\t\ta[i] = geo::toRad(a[i]);\n\t\t\t\n\t\t\tps[i].clear();\n\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\tdouble A = a[i] + (geo::PI * 2 / 5) * j + (geo::PI / 2);\n\t\t\t\tps[i].push_back(geo::Point(x[i], y[i]) + std::polar(r[i], A));\n\t\t\t\t//std::cout << ps[i].back();\n\t\t\t}\n\t\t\tstar[i].clear();\n\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\tint k = (j + 2) % 5;\n\t\t\t\tstar[i].push_back(geo::Segment(ps[i][j], ps[i][k]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.20f\\n\", solve());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<iomanip>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define EPS 1e-7\n#define S second\n#define pb push_back\n#define PI 3.14159265358979\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,P> PP;\nint N,M,L;\nclass Point{\npublic:\n  double x,y;\n\n  Point (double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (Point p){return Point(x*p.x,y*p.y);} \n  Point operator / (Point p){return Point(x/p.x,y/p.y);}\n\n  bool operator < (const Point &p)const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point &p)const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nvector<Point> Set[110];\n\ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n\ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble getDistance(Point a,Point b){\n  return abs(a-b);\n}\n\n\nvoid make_coordinates(double x,double y,double a,double r,int ind){\n  Point s1,s2;\n  //cout <<\"i = \" << ind << endl;\n  s1.x = 0; s1.y = 0; s2.x = x; s2.y = y;\n\n  Point s;\n  double dir = M_PI*a/180.0,pre = M_PI*72.0/180.0;\n  s.x = 0; s.y = r;\n  \n  //cout << endl << \"x = \" << x << \",y = \" << y << \", a = \" << a <<\",r = \" << r<< \"-----------\" << endl;\n  for(int i=0;i<5;i++){\n    Point p;  \n    p.x = s.x*cos(dir+pre*i) - s.y*sin(dir+pre*i) + x;\n    p.y = s.x*sin(dir+pre*i) + s.y*cos(dir+pre*i) + y;\n    Set[ind].pb(p);\n    //cout << \"p.x = \" << p.x << \",p.y = \" << p.y  << \",cost = \" << cos(dir+pre*i) << \",sin = \" << sin(dir+pre*i) << endl;\n  }\n\n\n}\nint main(){\n  while(true){\n    cin >> N >> M >> L;\n    if(N+M+L == 0)break;\n    rep(i,110)Set[i].clear();\n    rep(i,N){\n      double x,y,a,r;\n      cin >> x >> y >> a >> r;\n      make_coordinates(x,y,a,r,i);\n    }\n    double d[N*5+6][N*5+6];\n    rep(i,N*5)rep(j,N*5)d[i][j] = INF;\n    rep(i,N){\n      rep(k,5){\n\trep(j,N){\n\t  //if(i == j)continue;\n\t  rep(l,5){\n\t    d[i*5+k][j*5+l] = d[j*5+l][i*5+k] = getDistance(Set[i][k],Set[j][l]);\n\t    if(i == j)d[i*5+k][j*5+l] = d[j*5+l][i*5+k] = 0;\n\t  }\n\t}\n      }\n    }\n\n    rep(k,N*5)rep(i,N*5)rep(j,N*5)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n    double ans = INF;\n    rep(i,5){\n      rep(j,5){\n\tans = min(d[(M-1)*5+i][(L-1)*5+j],ans); \n\t//ans = min(d[(L-1)*5+i][(M-1)*5+j],ans);\n      }\n    }\n    cout << setiosflags(ios::fixed) << setprecision(20) << ans << endl;\n\n\n\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-10;\n\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n           (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n    if(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n    return dist_line_and_point(a1,a2,b);\n}\n\nostream& operator<<(ostream& os,point a){\n    os << \"(\" << a.real() << \",\" << a.imag() << \")\";\n    return os;\n}\n\ndouble dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){\n    if(is_intersected_linesegment(a1,a2,b1,b2)){\n        return 0;\n    }\n    return min(min(dist_linesegment_and_point(a1,a2,b1),\n                   dist_linesegment_and_point(a1,a2,b2)),\n               min(dist_linesegment_and_point(b1,b2,a1),\n                   dist_linesegment_and_point(b1,b2,a2)));\n}\n\nstruct Star{\n    point p;\n    double a;\n    double r;\n    vector<point> ps;\n    Star(double x,double y,double a,double r) : p(x,y),a(a),r(r) {\n        for(int i=0;i<5;i++){\n            ps.push_back(p+polar(r,M_PI * (0.4*i + 0.1 + (a / 180))));\n        }\n    }\n};\n\nconst double INF = 1e10;\ndouble dist_stars(Star a,Star b){\n    double ret = INF;\n//     for(int i=0;i<5;i++){\n//         for(int j=i+1;j<5;j++){\n//             for(int k=0;k<5;k++){\n//                 for(int l=k+1;l<5;l++){\n//                     ret = min(ret,dist_linesegment_and_linesegment(a.ps[i],a.ps[j],b.ps[k],b.ps[l]));\n//                 }\n//             }\n//         }\n//     }\n//\n//\n    for(int i=0;i<5;i++){\n        for(int j=0;j<5;j++){\n            for(int k=0;k<5;k++){\n                for(int l=0;l<5;l++){\n                    ret = min(ret,dist_linesegment_and_linesegment(a.ps[i],a.ps[j],b.ps[k],b.ps[l]));\n                }\n            }\n        }\n    }\n\n\n\n\n    return ret;\n}\n\nint main(){\n    cout << fixed << setprecision(8);\n    while(true){\n        int N,M,L;\n        cin >> N >> M >> L;\n        if(N == 0 and M == 0 and L == 0) break;\n        M--;L--;\n        vector<Star> stars;\n        vector<vector<double> > dist(N,vector<double>(N,INF));\n\n        for(int i=0;i<N;i++){\n            double x,y,a,r;\n            cin >> x >> y >> a >> r;\n            stars.push_back(Star(x,y,a,r));\n        }\n        for(int i=0;i<N;i++){\n            for(int j=i;j<N;j++){\n                dist[i][j] = dist[j][i] = dist_stars(stars[i],stars[j]);\n            }\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        cout << dist[M][L] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    b -= a; c -= a;\n    int s = sgn(cross(b, c));\n    if (s) return s;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define FOR(i,a,n) for(int i = (a);i < (n);i++)\nconst double M_PI = acos(-1);\nconst double EPS = 1e-10;\nconst double INF = 1e9;\nusing namespace std;\n\nint N,M,L;\n\nstruct Point{\n    double x,y;\n    Point operator - (const Point& p){ return Point{x-p.x,y-p.y};}\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\ndouble norm(Point a){return a.x*a.x+a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a,Point b){return a.x*b.y - a.y*b.x;}\n\nint ccw(Point p1,Point p2,Point p3){\n    Point a = {p2.x-p1.x, p2.y - p1.y};\n    Point b = {p3.x-p1.x, p3.y - p1.y};\n    if(cross(a,b) > EPS) return 1;\n    if(cross(a,b) < -EPS) return -1;\n    if(dot(a,b) < -EPS) return 2;\n    if(norm(a) < norm(b)) return -2;\n    return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1,s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < -EPS) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < -EPS) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n    \n\nSegment star[102][5];\ndouble mindist[102][102];\n\n\n\ndouble getdist(int u, int v){\n    REP(i,5){\n        REP(j,5){\n            if(intersect(star[u][i],star[v][j])){\n                    return 0;\n            }\n        }\n    }\n    double ans = INF;\n    REP(k,2){\n        if(k) swap(u,v);\n        REP(i,5){\n            REP(j,5){\n                ans = min(getDistSP(star[u][i],star[v][j].p1),ans);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>N>>M>>L,N){\n        REP(i,N){\n            int x,y,a,r;\n            cin>>x>>y>>a>>r;\n            Point p[5];\n            REP(j,5) p[j] = Point{x + r*sin((double)(72*j - a)/180*M_PI), y + r*cos((double)(72*j - a)/180*M_PI)};//star's vertex\n            REP(j,5){\n                star[i][j] = Segment{p[j], p[(j+2)%5]};\n            }\n        }\n\n        //caluculate min distance\n        REP(i,N){\n            FOR(j,i,N){\n                mindist[i][j] = mindist[j][i] = getdist(i,j);\n            }\n        }\n\n        //WF        \n        REP(k,N){\n            REP(i,N){\n                REP(j,N){\n                    mindist[i][j] = min(mindist[i][j], mindist[i][k] + mindist[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(8) << mindist[M-1][L-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double INF=1e77;\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){\n\treturn (point<T>){c*a.x,c*a.y};\n}\n\npoint<double> rot(const point<double> &a,double theta){\n\treturn (point<double>){a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)};\n}\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n};\n\nstruct star{\n\tpoint<double> c;\n\tdouble a,r;\n\tpoint<double> p[5];\n};\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\nT dist2(const point<T> &a,const point<T> &b){\n\treturn (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n\tif(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n\tif(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n\treturn (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n\tif(intersect(S1,S2)) return 0;\n\treturn sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n\t\t\t\t\tmin(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\nint main(){\n\tfor(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tm--;\n\t\tl--;\n\n\t\tstar S[100];\n\t\trep(i,n){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&S[i].c.x,&S[i].c.y,&S[i].a,&S[i].r);\n\t\t}\n\n\t\trep(i,n){\n\t\t\tS[i].p[0]=(point<double>){0,S[i].r};\n\t\t\tS[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n\t\t\tfor(int j=1;j<5;j++){\n\t\t\t\tS[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n\t\t\t}\n\t\t\trep(j,5) S[i].p[j]=S[i].p[j]+S[i].c;\n\t\t}\n\n\t\tint f1[5]={0,2,4,1,3};\n\t\tint f2[5]={2,4,1,3,0};\n\n\t\tdouble d[100][100];\n\t\trep(i,n) rep(j,n) {\n\t\t\td[i][j]=INF;\n\t\t\trep(a,5) rep(b,5) d[i][j]=min(d[i][j],dist((segment<double>){S[i].p[f1[a]],S[i].p[f2[a]]},(segment<double>){S[j].p[f1[b]],S[j].p[f2[b]]}));\n\t\t}\n\n\t\trep(k,n) rep(i,n) rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\n\t\tprintf(\"%.15f\\n\",d[m][l]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nint ccw(const P a, P b, P x) {\n  b -= a;\n  x -= a;\n  double cr = cross(b, x);\n  if (eq(cr, 0)) {\n    if (dot(b, x) < 0) return BACK;\n    if (abs(b) < abs(x)) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\nP vec(L a) {return a.second - a.first;}\nbool iSS(L a, L b) {\n  int cwaf = ccw(a.first, a.second, b.first);\n  int cwbf = ccw(b.first, b.second, a.first);\n  int cwas = ccw(a.first, a.second, b.second);\n  int cwbs = ccw(b.first, b.second, a.second);\n  if ((cwaf | cwas | cwbf | cwbs) & ON) return true;\n  return (cwaf | cwas) == (LEFT | RIGHT) && (cwbf | cwbs) == (LEFT | RIGHT);\n}\ndouble dLP(L l, P x) {return abs(cross(vec(l), x - l.first)) / abs(vec(l));}\ndouble dSP(L s, P x) {\n  if (dot(vec(s), x - s.first) <= 0) return abs(x - s.first);\n  if (dot(-vec(s), x - s.second) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\ndouble dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\n\ndouble x[111], y[111], a[111], r[111];\nL star[111][5];\ndouble dis[111][111];\ndouble mem[111];\n\nvoid f(int s, int t) {\n  double res = 1e40;\n  rep (i, 5) rep (j, 5) {\n    res = min(dSS(star[s][i], star[t][j]), res);\n    if (eq(res, 0)) break;\n  }\n  dis[s][t] = res;\n}\n\nint main() {\n  int n, m, l;\n  for (;;) {\n    cin >> n >> m >> l;\n    if (n == 0 && m == 0 && l == 0) break;\n    --m; --l;\n    rep (i, n) cin >> x[i] >> y[i] >> a[i] >> r[i];\n    rep (i, n) a[i] = a[i] / 360 * 2 * PI;\n    rep (i, n) rep (j, 5) {\n      double theta = a[i] + j * 2 * PI / 5 + PI / 2;\n      P p1 = P(x[i] + r[i] * cos(theta), y[i] + r[i] * sin(theta));\n      theta = a[i] + (j + 2) * 2 * PI / 5 + PI / 2;\n      P p2 = P(x[i] + r[i] * cos(theta), y[i] + r[i] * sin(theta));\n      star[i][j] = L(p1, p2);\n    }\n    rep (i, n) rep (j, n) if (i < j) f(i, j);\n    rep (i, n) rep (j, n) if (i > j) dis[i][j] = dis[j][i];\n    rep (i, n) mem[i] = INF;\n    priority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n    que.push(make_pair(0, m));\n    while (!que.empty()) {\n      pair<double, int> now = que.top();\n      que.pop();\n      if (mem[now.second] <= now.first) continue;\n      mem[now.second] = now.first;\n      rep (i, n) if (i != now.second) {\n\tque.push(make_pair(now.first + dis[now.second][i], i));\n      }\n    }\n    printf(\"%.12lf\\n\", mem[l]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <iomanip>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N,S,G = 0;\n\ndouble l[110][110] = {};\ndouble nowL[110] = {};\nconst double PI = 3.14159265358979;\nstruct Star {\n\tconst int px, py,a;\n\tdouble x[5], y[5];\n\tStar(int _px, int _py, int _a, int _r) :px(_px),py(_py),a(_a) {\n\t\tfor (int i = 0; i < 5;i++) {\n\t\t\tx[i] = px + _r * cos((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t\ty[i] = py + _r * sin((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t}\n\t};\n};\n\nStar *s[105];\n\ndouble MinL(double x0, double y0, double x1, double y1, double x2, double y2) {\n\tdouble dx = x1 - x2, dy = y1 - y2;\n\tdouble x = (dx*dx*x0 - dx*dy*y0 + dy*(dx*y2 - dy*x2)) / (dx*dx - dy*dy);\n\tdouble d;\n\tif (min(x1, x2) <= x && x <= max(x1, x2)) {\n\t\td=abs(dy*x0 - dx*y0 + x1*y2 - x2*y1) / hypot(dx, dy); \n\t}\n\telse {\n\t\td=min(hypot(x1 - x0, y1 - y0), hypot(x2 - x0, y2 - y0));\n\t}\n\treturn d;\n}\nbool Crossing(double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3) {\n\tdouble t1 = (x2 - x3)*(y0 - y2) + (y2 - y3)*(x2 - x0);\n\tdouble t2 = (x2 - x3)*(y1 - y2) + (y2 - y3)*(x2 - x1);\n\tdouble t3 = (x0 - x1)*(y2 - y0) + (y0 - y1)*(x0 - x2);\n\tdouble t4 = (x0 - x1)*(y3 - y0) + (y0 - y1)*(x0 - x3);\n\treturn t3*t4 <= 0 && t1*t2 <= 0;\n}\n\nvoid CalcStar(int a, int b) {\n\tconst unsigned lineGoal[5]={2,3,4,0,1};\n\tdouble temp = 100000;\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0; j < 5;j++) {\n\t\t\tif (Crossing(\n\t\t\t\ts[a]->x[i], s[a]->y[i],\n\t\t\t\ts[a]->x[lineGoal[i]], s[a]->y[lineGoal[i]],\n\t\t\t\ts[b]->x[j], s[b]->y[j],\n\t\t\t\ts[b]->x[lineGoal[j]], s[b]->y[lineGoal[j]]\n\t\t\t)) {\n\t\t\t\tl[b][a] = l[a][b] = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0; j < 5;j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[a]->x[i], s[a]->y[i],\n\t\t\t\ts[b]->x[j], s[b]->y[j],\n\t\t\t\ts[b]->x[lineGoal[j]], s[b]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[b]->x[i], s[b]->y[i],\n\t\t\t\ts[a]->x[j], s[a]->y[j],\n\t\t\t\ts[a]->x[lineGoal[j]], s[a]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tl[b][a] = l[a][b] = temp;\n}\ndouble minCost[110];\nvoid Dijkstra(int _s,int _g) {\n\tfor (int i = 1; i <= N;i++) {\n\t\tminCost[i] = 1000000;\n\t}\n\tminCost[_s] = 0;\n\tstruct Node {\n\t\tint num;\n\t\tdouble cost;\n\t\tbool operator > (const Node& _node)const {\n\t\t\treturn cost > _node.cost;\n\t\t}\n\t};\n\tpriority_queue<Node,vector<Node>,greater<Node>> PQ;\n\tNode node = { _s, 0 };\n\tPQ.push( node );\n\twhile (!PQ.empty()){\n\t\tNode now = PQ.top(); PQ.pop();\n\t\tif (now.cost > minCost[now.num]) {\n\t\t\tcontinue;\n\t\t}\n\t\tminCost[now.num] = now.cost;\n\t\tif (now.num==_g) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= N;i++) {\n\t\t\tif (i!=now.num) {\n\t\t\t\tNode node = { i,now.cost + l[now.num][i] };\n\t\t\t\tPQ.push(node);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (true){\n\t\tcin >> N >> S >> G;\n\t\tif (N==0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ts[i] = new Star(x, y, a, r);\n\t\t\tnowL[i] = 5000;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\t\tCalcStar(i, j);\n\t\t\t}\n\t\t}\n\t\tDijkstra(S, G);\n\t\tcout << fixed << setprecision(7) << minCost[G] << endl;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdelete s[i];\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<utility>\n#include<queue>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\nconst ld eps = 1e-8, pi = acos(-1.0);\nstruct L { P a, b; };\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nld dist_pp(P p, P q) {\n  return abs(p - q);\n}\n\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  ld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n  ld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n  return min(a, b);\n}\n\nP rotate(ld deg, P p) {\n  ld rad = deg * pi / 180.0;\n  return polar(1.0000000000000l, rad) * p;\n}\n\nstruct Star { L e[5]; };\n\nld dist_stst(Star s, Star t) {\n  ld val = dist_ss(s.e[0], t.e[0]);\n  for (L ss : s.e) for (L ts : t.e) {\n    val = min(val, dist_ss(ss, ts));\n    val = min(val, \n          min(dist_pp(ss.a,ts.a),\n          min(dist_pp(ss.a,ts.b),\n          min(dist_pp(ss.b,ts.a), dist_pp(ss.b,ts.b)))));\n  }\n  return val;\n}\n\nint main() {\n  int n, m, l;\n  while (cin >> n >> m >> l and n) {\n    m--; l--;\n    vector<Star> stars(n);\n    for (Star &s : stars) {\n      int x, y ,a, r;\n      cin >> x >> y >> a >> r;\n      P center(x, y), d(0,r);\n      for (int i = 0; i < 5; i++) {\n        s.e[i].a = s.e[(i+4)%5].b = center + rotate(a + 72 * i, d);\n      }\n    }\n\n    vector<vector<ld>> dist(n);\n    for (vector<ld> &v : dist) {\n      v.reserve(n);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        dist[i][j] = dist_stst(stars[i], stars[j]);\n      }\n    }\n\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    cout << fixed << setprecision(30)<< dist[m][l] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<iostream>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef pair<double,int> Pd;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double PI = acos(-1);\n\ndouble dot(P x,P y){return real(conj(x)*y);}\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ndouble seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ndouble seg_seg_dis(L a,L b){\n  double res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nint n,m,l;\ndouble xi[110],yi[110],ai[110],ri[110];\nvector<Pd> g[110];\nL s[110][5];\ndouble d[110];\n\nvoid make_star(int x){\n  P p[5];\n  P tmp = P(0.0,ri[x]);\n  p[0] = rotate(tmp,ai[x]*PI/180);\n  for(int i=1;i<5;i++)p[i] = rotate(p[i-1],72*PI/180);\n  for(int i=0;i<5;i++)p[i] += P(xi[x],yi[x]);\n  for(int i=0;i<5;i++)s[x][i] = L(p[i],p[(i+2)%5]);\n}\n \nvoid make_graph(void){\n  for(int i=0;i<n;i++)make_star(i);\n  \n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      bool f = false;\n      for(int k1=0;k1<5;k1++){\n\tfor(int k2=0;k2<5;k2++){\n\t  f |= is_cp(s[i][k1],s[j][k2]);\n\t  if(f)break;\n\t}\n      }\n      if(f){\n\tg[i].push_back(Pd(0.0,j));\n\tg[j].push_back(Pd(0.0,i));\n      }else{\n\tdouble dis = 1e10;\n\tfor(int k1=0;k1<5;k1++){\n\t  for(int k2=0;k2<5;k2++){\n\t    dis = min(dis,seg_seg_dis(s[i][k1],s[j][k2]));\n\t  }\n\t}\t\n\tg[i].push_back(Pd(dis,j));\n\tg[j].push_back(Pd(dis,i));\n      }\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d%d\",&n,&m,&l), (n||m||l)){\n    for(int i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&xi[i],&yi[i],&ai[i],&ri[i]);\n\n    for(int i=0;i<n;i++)g[i].clear();\n    make_graph();\n\n    for(int i=0;i<n;i++)d[i] = 1e10; d[m-1] = 0.0;\n    priority_queue<Pd,vector<Pd>,greater<Pd> >q;\n    q.push(Pd(0.0,m-1));\n\n    while(q.size()){\n      Pd p = q.top(); q.pop();\n      double cost = p.fs;\n      int pos = p.sc;\n\n      if(pos == l-1)break;\n\n      for(int i=0;i<g[pos].size();i++){\n\tdouble dis = cost + g[pos][i].fs;\n\tint next = g[pos][i].sc;\n\tif(dis+EPS < d[next]){\n\t  d[next] = dis;\n\t  q.push(Pd(dis,next));\n\t}\n      }\n    }\n\n    printf(\"%.10lf\\n\",d[l-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vP;\ntypedef vector<double> vd;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n\ndouble rad(double deg) {\n\treturn deg*PI/180.0;\n}\n\ndouble dot(P a, P b) {\n\treturn (a.real()*b.real() + a.imag()*b.imag());\n}\n\ndouble cross(P a, P b) {\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\nint is_point_on_line(P a, P b, P c) {\n\treturn EQ(cross(b-a, c-a), 0.0);\n}\n\nint is_point_on_ls(P a, P b, P c) {\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif((cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < -EPS) &&\n\t   (cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < -EPS))\n\t   return true;\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2) ||\n\t\t   is_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n\tif(dot(b-a, c-a) < -EPS) return abs(c-a);\n\tif(dot(a-b, c-b) < -EPS) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble distance_ls(P a1, P a2, P b1, P b2) {\n\tif(is_intersected_ls(a1, a2, b1, b2)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(distance_ls_p(a1, a2, b1), distance_ls_p(a1, a2, b2)),\n\t\t\t   min(distance_ls_p(b1, b2, a1), distance_ls_p(b1, b2, a2)));\n}\n\nint main() {\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tvector<vP> points(N, vP(5));\n\t\tdouble x, y, a, r;\n\t\tREP(i, N) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tREP(j, 5) {\n\t\t\t\tpoints[i][j] = P(x-r*sin(rad(a+72*j)), y+r*cos(rad(a+72*j)));\n\t\t\t}\n\t\t}\n\n\t\tvector<vd> cost(N, vd(N, INF));\n\t\tREP(i, N) {\n\t\t\tFOR(j, i+1, N-1) {\n\t\t\t\tREP(k, 5) {\n\t\t\t\t\tREP(l, 5) {\n\t\t\t\t\t\tcost[i][j] = cost[j][i] = min(cost[i][j], distance_ls(points[i][k], points[i][(k+2)%5], points[j][l], points[j][(l+2)%5]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(M == L){\n\t\t\tcost[M-1][L-1] = 0.0;\n\t\t}\n\t\t\n\t\tprintf(\"%.8f\\n\", cost[M-1][L-1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\nint N,M,L;\n\nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        m--;\n        l--;\n   \n        star S[100];\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf%lf%lf%lf\",&S[i].c.x,&S[i].c.y,&S[i].a,&S[i].r);\n        }\n   \n        for(int i = 0; i < n; i++){\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            for(int j = 0; j < 5; j++) S[i].p[j]=S[i].p[j]+S[i].c;\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n   \n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    segment<double> s(S[i].p[f1[a]],S[i].p[f1[a+1]]);\n                    segment<double> t(S[j].p[f1[b]],S[j].p[f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < N; k++)\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m][l]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n#define eps 1.0e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tlong double x, y;\n\tvec2d(){}\n\tlong double add(long double a, long double b){\n\t\tif(abs(a+b) < eps * (abs(a) + abs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d(long double x, long double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, ope.x);\n\t\ttmp.y = add(y, ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, -ope.x);\n\t\ttmp.y = add(y, -ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const long double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tlong double dot(const vec2d& ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tlong double cross(const vec2d& ope){\n\t\treturn add(x*ope.y,  -y*ope.x);\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= 0;\n}\n\nlong double distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\nlong double distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) <= 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) <= 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\nlong double distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tlong double t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tlong double ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\nlong double dist[105][105];\n\nlong double dijkstra()\n{\n\tlong double d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\nlong double distanceStar(int S, int T)\n{\n\tlong double ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+1)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.12f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\nstruct Line :Polygon{\n\tLine(){};\n\tLine(Point p,Point q){push_back(p);push_back(q);}\n};\n\ndouble cross(Point p, Point q){\n\treturn imag(conj(p)*q);\n}\ndouble dot(Point p, Point q){\n\treturn real(conj(p)*q);\n}\n\nint ccw(Point a, Point b, Point c){\n\tb -= a,c -= a;\n\tif(cross(b,c)>9)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\n\nbool intersectSS(Line s,Line t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 1;\n}\n\nPoint projection(Line l, Point p){\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t * (l[0] - l[1]);\n}\n\nbool intersectSP(Line s, Point p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(Line s,Point p){\n\tconst Point r = projection(s,p);\n\tif(intersectSP(s, r))return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(Line s, Line t){\n\tif(intersectSS(s, t))return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint main(){\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n){\n\t\tPolygon stars[102];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tstars[i].resize(0);\n\t\t\tdouble x,y,a,r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\tstars[i].push_back(Point(x,y) + polar(r,(a + 90 + 72 * 2 * j) / 180.0 * PI));\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble dist[102][102];\n\t\tfor(int i = 0;i < 102;i++)\n\t\t\tfor(int j = 0;j < 102;j++)\n\t\t\t\tdist[i][j] = INF*(i!=j);\t\t\t\t\t\t\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tdouble value = INF;\n\t\t\t\tfor(int k = 0;k < 5;k++){\n\t\t\t\t\tLine line = Line(stars[i][k],stars[i][(k+1)%5]);\n\t\t\t\t\tfor(int q = 0;q < 5;q++){\n\t\t\t\t\t\tvalue = min(value,distanceSP(line,stars[j][q]));\n\t\t\t\t\t}\n\t\t\t\t\tline = Line(stars[j][k],stars[j][(k+1)%5]);\n\t\t\t\t\tfor(int q = 0;q < 5;q++){\n\t\t\t\t\t\tvalue = min(value,distanceSP(line,stars[i][q]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[i][j] = dist[j][i] = min(value,dist[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0;k < n;k++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.8lf\\n\",dist[m-1][l-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nusing Point = complex<double>;\nusing Polygon = vector<Point>;\n\ninline int sgn(const double &a) { return (a < -EPS ? -1 : (a > EPS ? 1 : 0)); }\n\ninline bool eq(const Point &a, const Point &b) { return abs(a - b) < EPS; }\n\nnamespace std {\ninline bool operator<(const Point &a, const Point &b) {\n    if (sgn(a.real() - b.real()))\n        return sgn(a.real() - b.real()) < 0;\n    return sgn(a.imag() - b.imag()) < 0;\n}\n} // namespace std;\n\ndouble dot(const Point &a, const Point &b) { return real(conj(a) * b); }\n\ndouble det(const Point &a, const Point &b) { return imag(conj(a) * b); }\n\nstruct Line {\n    Point p1, p2;\n\n    Line(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\n    bool operator<(const Line &rhs) const {\n        if (eq(p2, rhs.p2))\n            return p1 < rhs.p1;\n        return p2 < rhs.p2;\n    }\n    bool operator==(const Line &rhs) const {\n        return (eq(p1, rhs.p1) && eq(p2, rhs.p2)) ||\n               (eq(p1, rhs.p2) && eq(p2, rhs.p1));\n    }\n};\n\ninline Point curr(const Polygon &p, const int &i) { return p[i % p.size()]; }\n\ninline Point next(const Polygon &p, const int &i) {\n    return p[(i + 1) % p.size()];\n}\n\ninline Point prev(const Polygon &p, const int &i) {\n    return p[(i + p.size() - 1) % p.size()];\n}\n\nenum CCW {\n    ONLINE_FRONT = -2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Point a = p1 - p0;\n    Point b = p2 - p0;\n    if (sgn(det(a, b)) == 1)\n        return COUNTER_CLOCKWISE;\n    if (sgn(det(a, b)) == -1)\n        return CLOCKWISE;\n    if (sgn(dot(a, b)) == -1)\n        return ONLINE_BACK;\n    if (sgn(norm(b) - norm(a)) == 1)\n        return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersectLS(Line a, Line b, bool segflag) {\n    if (segflag)\n        return (ccw(a.p1, a.p2, b.p1) * ccw(a.p1, a.p2, b.p2) <= 0) &&\n               (ccw(b.p1, b.p2, a.p1) * ccw(b.p1, b.p2, a.p2) <= 0);\n    else\n        return (sgn(det(a.p2 - a.p1, b.p1 - a.p1) *\n                    det(a.p2 - a.p1, b.p2 - a.p1)) <= 0) &&\n               (sgn(det(b.p2 - b.p1, a.p1 - b.p1) *\n                    det(b.p2 - b.p1, a.p2 - b.p1)) <= 0);\n}\n\ndouble distanceLP(Line line, Point p) {\n    return abs(det(line.p2 - line.p1, p - line.p1)) / abs(line.p2 - line.p1);\n}\n\ndouble distanceSP(Line line, Point p) {\n    if (sgn(dot(line.p2 - line.p1, p - line.p1)) < 0)\n        return abs(p - line.p1);\n    if (sgn(dot(line.p1 - line.p2, p - line.p2)) < 0)\n        return abs(p - line.p2);\n    return distanceLP(line, p);\n}\n\ndouble distanceSS(Line s1, Line s2) {\n    if (intersectLS(s1, s2, true))\n        return 0;\n    double d1 = distanceSP(s1, s2.p1);\n    double d2 = distanceSP(s1, s2.p2);\n    double d3 = distanceSP(s2, s1.p1);\n    double d4 = distanceSP(s2, s1.p2);\n    return min({d1, d2, d3, d4});\n}\n\nvector<Line> make_star(double x, double y, double a, double r) {\n    Point c(0, r);\n    vector<Point> v;\n    for(int i=0;i<5;++i){\n        double theta = (a + 72*i) * PI / 180.0;\n        Point rot(cos(theta), sin(theta));\n        v.push_back(c*rot + Point(x, y));\n    }\n    vector<Line> res;\n    for(int i=0;i<5;++i){\n        res.push_back(Line(v[i], v[(i+2)%5]));\n    }\n    return res;\n}\n\ndouble compute_distance(vector<Line> st1, vector<Line> st2) {\n    double res = INF;\n    for(auto l1: st1){\n        for(auto l2: st2){\n            double d = distanceSS(l1, l2);\n            if(sgn(res - d) > 0)res = d;\n        }\n    }\n    return res;\n}\n\nstruct Edge{\n    int from, to;\n    double cost;\n};\n\nstruct Node{\n    int num;\n    double cost;\n    bool operator<(const Node &obj)const{\n        return sgn(cost - obj.cost) > 0;\n    }\n};\n\ndouble mini[102]={};\n\nvoid init(int n, int m){\n    for(int i=0;i<=n;++i)\n        mini[i] = INF;\n    mini[m] = 0;\n}\n\nint main(){\n    int n, m, l;\n    while(cin >> n >> m >> l, n != 0){\n        init(n, m);\n        vector<vector<Line>> stars;\n        for(int i=0;i<n;++i){\n            double x, y, a, r;\n            cin >> x >> y >> a >> r;\n            auto star = make_star(x, y, a, r);\n            stars.push_back(star);\n        }\n        vector<vector<Edge>> graph(n+1, vector<Edge>());\n        for(int i=0;i<n;++i){\n            for(int j=i+1;j<n;++j){\n                double d = compute_distance(stars[i], stars[j]);\n                graph[i+1].push_back({i+1, j+1, d});\n                graph[j+1].push_back({j+1, i+1, d});\n            }\n        }\n        priority_queue<Node> que;\n        que.push({m, 0});\n        while(!que.empty()){\n            auto cur = que.top(); que.pop();\n            if(cur.num == l){\n                printf(\"%.10f\\n\", cur.cost);\n                break;\n            }\n            for(auto e: graph[cur.num]){\n                double new_cost = cur.cost + e.cost;\n                if(sgn(mini[e.to] - new_cost) > 0){\n                    mini[e.to] = new_cost;\n                    que.push({e.to, new_cost});\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\nint ccw(const Point& _a, const Point& _b, const Point&  _c) {\n\tVector ba = _b - _a, ca = _c - _a;\n\tif (cross(ba, ca) > EPS) return +1; // ccw\n\tif (cross(ba, ca) < -EPS) return -1; // cw\n\tif (dot(ba, ca) < -EPS) return +2; // c-a-b\n\tif (abs(ba) + EPS < abs(ca)) return -2; // a-b-c\n\treturn 0; // a-c-b\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nbool is_cross(const Segment& _a, const Segment& _b) {\n\treturn (ccw(_a.s, _a.e, _b.s) * ccw(_a.s, _a.e, _b.e) <= 0\n\t\t\t&& ccw(_b.s, _b.e, _a.s) * ccw(_b.s, _b.e, _a.e) <= 0);\n}\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tif (is_cross(a, b)) return 0.0;\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 0.4 * PI));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e5;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  int n,m,l;cin >> n>>m>>l;\n  if(n==0) break;\n  Polygon stars[n];\n  for(int i=0;i<n;i++){\n    int x,y,a,r;cin>>x>>y>>a>>r;\n    for(int j=0;j<5;j++){\n      Point v=Point(x,y)+Point(r*cos((18+a+72*j)*(2*PI)/360),r*sin((18+a+72*j)*(2*PI)/360));\n      stars[i].push_back(v);\n    }\n  }\n  ld dis[n][n];\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n    if(i==j) dis[i][j]=0.0;\n    else dis[i][j]=INF;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ld tmp=INF;\n      for(int k=0;k<5;k++){\n        for(int l=0;l<5;l++){\n          Line x=Line(stars[i][k],stars[i][(k+2)%5]);\n          Line y=Line(stars[j][l],stars[j][(l+2)%5]);\n          tmp=min(tmp,dist_ss(x,y));\n        }\n      }\n      dis[i][j]=tmp;dis[j][i]=tmp;\n    }\n  }\n  for(int j=0;j<n;j++){\n    for(int i=0;i<n;i++){\n      for(int k=0;k<n;k++){\n        dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);\n      }\n    }\n  }\n  cout << setprecision(10)<<dis[m-1][l-1] << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\n#define EPS 1e-8\ntypedef complex<double> Point;\nnamespace std {\n    bool operator < (const Point &a, const Point &b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    Point operator / (const Point &p, const double &a) {\n        return Point(real(p)/a, imag(p)/a);\n    }\n    Point operator * (const Point &p, const double &a) {\n        return Point(real(p)*a, imag(p)*a);\n    }\n    bool operator == (const Point &a, const Point &b) {\n        return real(a) == real(b) && imag(a) == imag(b);\n    }\n}\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> { \n    Line () {}\n    Line (const Point &a, const Point &b) {\n        push_back(a); push_back(b);\n    }\n};\nstruct Circle {\n    Point c; double r;\n    Circle () {}\n    Circle (const Point &c, double r) : c(c), r(r) {}\n};\n\n\n\ndouble cross (const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\ndouble dot (const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; //ccw\n    if (cross(b, c) < 0)   return -1; //cw\n    if (dot(b, c) < 0)     return +2; //c--a--b on line\n    if (norm(b) < norm(c)) return -2; //a--b--c on line\n    return 0; //a--c--b or (c=b)\n}\n\nbool parallelLL (const Line &l, const Line &m) {\n    return abs(cross(l[1] - l[0],m[1] - m[0])) > EPS ;\n}\n\nbool intersectLL (const Line &l, const Line &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS (const Line &l, const Line &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP (const Line &l, const Point &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS (const Line &s, const Line &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP (const Line &s, const Point &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\nPoint reflection(const Line &l, const Point &p) {\n    return p + 2.0 * (projection(l, p) - p);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(const Line &l, const Line &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const Line &l, const Line &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const Point &p) {\n    const Point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n            min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nPoint crosspoint(const Line &l, const Line &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble area (const Polygon &g) {\n    double sum = 0;\n    for (int i = 0; i < g.size(); i++) \n        sum += cross(g[i], g[(i+1)%g.size()]);\n    return abs(sum)/2;\n}\n\n// O(N log N)\nPolygon convexHull (Polygon g) {\n    int n = g.size(), k = 0;\n    sort(g.begin(), g.end());\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = g[i++]) //lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], g[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = g[i--]) //upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], g[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n\n//O(N)\n//return left of l in g\nPolygon convexCut (const Polygon &g, const Line &l) {\n    Polygon ret;\n    for (int i = 0; i < g.size(); i++) {\n        Point a = g[i], b = g[(i+1)%g.size()];\n        if (ccw(l[0], l[1], a) != -1) ret.push_back(a);\n        if (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0)\n            ret.push_back(crosspoint(Line(a,b), l));\n    }\n    return ret;\n}\n\n//?????¨????§???¢???????????????\nbool inPolygon (const Polygon &g, const Point &p) {\n    double sum = 0.0;\n    int n = g.size();\n    for (int i = 0; i < g.size(); i++) {\n        int j = (i+1)%n;\n        if (intersectSP(Line(g[i], g[j]), p)) return true;\n        sum += arg((g[j]-p)/(g[i]-p));\n    }\n    return abs(sum) > 1;\n}\n\n//??????????????????????±???????\nvector<Point> normal (const Point &p) {\n    vector<Point> res;\n    res.push_back( Point(-imag(p), real(p)));\n    res.push_back( Point(imag(p), -real(p)));\n    return res;\n}\n\n//2??????????????????????±??????????\nvector<Point> bisector (const Point &a, const Point &b) {\n    vector<Point> res;\n    vector<Point> normals = normal(a-b);\n    Point center = (a+b)/2;\n    res.push_back(normals[0]);\n    res.push_back(normals[1]);\n    return res;\n}\n\n\n// ??????????????????????¬??????????\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\n\n// ?????????????????????????????????\nbool equal(double a, double b){ \n    return abs(b - a) < EPS;\n}\n\n\n// ????????\\??? (????????????????§?th????????§??\\????????\\???)\nLine circleTangent(Circle& C, double th){\n    Point p0 = C.c + polar(C.r, th);\n    Point p1 = p0 + polar(1.0, th + M_PI / 2);\n    return Line(p0, p1);\n}\n\n// ?????????????????±?????\\??? (C?????????????????\\????????????????????????????§??????????)\nvector<double> commonTangents(const Circle &C, const Circle &D){\n    vector<double> res;\n    Point v = D.c - C.c;\n    double l = abs(v); // ??????????????????????????¢\n    double a = arg(v); // ?????????????????????????§?\n    if(sign(l - abs(C.r - D.r)) > 0){\n        // ????????? or ?????\\ or ??¢????????????\n        // ??????????????´??\\???\n        double a1 = acos((C.r - D.r) / l);\n        res.push_back(a + a1);\n        res.push_back(a - a1);\n        if(sign(l - (C.r + D.r)) > 0){\n            // ??¢????????????\n            // ??????????????´??\\???\n            double a2 = acos((C.r + D.r) / l);\n            res.push_back(a + a2);\n            res.push_back(a - a2);\n        }\n    }\n    if((equal(abs(C.r - D.r), l) || equal(C.r + D.r, l)) && sign(l) != 0){\n        // ?????\\ or ?????\\\n        // ???????????\\???\n        res.push_back(a);\n    }\n    return res;\n}\n\n\nvector<Point> crosspointLC(const Line &l, const Circle &c) {\n    vector<Point> ret;\n    Point center = projection(l, c.c);\n    double d = abs(center - c.c);\n    double t = sqrt(c.r * c.r - d * d);\n    if (isnan(t)) { return ret; }\n    Point vect = (l[1] - l[0]);\n    vect /= abs(vect);\n    ret.push_back(center - vect * t);//\n    if (t > EPS) {\n        ret.push_back(center + vect * t);\n    }\n    return ret;\n}\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n    vector<Point> ret;\n    double d = abs(c1.c - c2.c);\n    if (max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) { return ret; }\n    double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    Point start = c1.c + (c2.c - c1.c) / d * x;\n    Point vect = (c1.c - c2.c) * Point(0.0, 1.0);\n    return crosspointLC(Line(start, start + vect), c1);\n}\n\n\nPoint rotate(Point p, double deg){\n    Point res = p;\n    deg = deg * M_PI / 180.0;\n    double x = real(p), y = imag(p);\n    real(res) = x * cos(deg) - y * sin(deg);\n    imag(res) = x * sin(deg) + y * cos(deg);\n    return res;\n}\n\nint main(void){\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        m--; l--;\n        vector<Polygon> star(n);\n        REP(k, n){\n            double x, y, a, r;\n            cin >> x >> y >> a >> r;\n            vector<Point> vp;\n            REP(i, 5){\n                double xx = r, yy = 0.0;\n                double deg = (a + 90 + i * 72);\n                Point p = rotate(Point(xx, yy), deg);\n                p += Point(x, y);\n                vp.push_back(p);\n            }\n            REP(i, 5){\n                star[k].push_back(vp[(i * 2) % 5]);   \n            }\n        }\n        vector<vector<double> > dist(n + 1, vector<double>(n + 1, 1e9));\n        REP(i, n){\n            REP(j, n){\n                if(i == j){\n                    dist[i][j] = 0.0;\n                    continue;\n                }\n                REP(k, 5){\n                    REP(l, 5){\n                        Line l1 = Line(star[i][k], star[i][(k+1)%5]);\n                        Line l2 = Line(star[j][l], star[j][(l+1)%5]);\n                        //cout << i << \":\" << j << \":\" << k << \":\" << l << \":\" << endl;\n                        //cout << distanceSS(l1, l2) << endl;\n                        dist[i][j] = min(dist[i][j], distanceSS(l1, l2));\n                    }\n                }\n            }\n        }\n        REP(i, n) REP(j, n){\n            //cout << dist[i][j] << \":\" << i << \":\" << j << endl;\n        }\n        REP(k, n) REP(i, n) REP(j, n)\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        printf(\"%.12f\\n\", dist[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> \n#include <bitset> \n#include <cctype> \n#include <complex> \n#include <cmath> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <ctime> \n#include <deque> \n#include <functional> \n#include <iomanip> \n#include <iostream> \n#include <list> \n#include <map> \n#include <numeric> \n#include <queue> \n#include <set> \n#include <sstream> \n#include <stack> \n#include <string> \n#include <utility> \n#include <vector> \n  \nusing namespace std; \n  \ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;} \ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();} \ntemplate<class T> inline T sqr(T x) {return x*x;} \n  \ntypedef vector<int> vi; \ntypedef vector<vi> vvi; \ntypedef vector<string> vs; \ntypedef pair<int, int> pii; \ntypedef long long ll; \n  \n#define all(a)  (a).begin(),(a).end() \n#define rall(a) (a).rbegin(), (a).rend() \n#define pb push_back \n#define mp make_pair \n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i) \n#define exist(s,e) ((s).find(e)!=(s).end()) \n#define range(i,a,b) for(int i=(a);i<(b);++i) \n#define rep(i,n)  range(i,0,n) \n#define clr(a,b) memset((a), (b) ,sizeof(a)) \n#define dump(x)  cerr << #x << \" = \" << (x) << endl; \n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl; \n  \n  \nconst double eps = 1e-10; \nconst double pi  = acos(-1.0); \nconst ll INF =1LL << 62; \nconst int inf =1 << 30; \n  \n  \n// テ、ツサツ・テ、ツクツ?テ・ツケツセテ、ツスツ陛ゥツδィテ・ツ按?\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;} \ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;} \n#define x real() \n#define y imag() \n#define mp make_pair \n  \ntypedef bool B; \ntypedef long double D; \ntypedef complex<D> P; \ntypedef pair <P,P> L; \ntypedef struct {P c;D r;} C; \ntypedef struct {P c;D a,b;} E; // テヲツ・ツ陛・ツ??」ツつづィツソツステ・ツ環?、ツコツ暗・ツョツ?\ntypedef vector <P>Pol; \n  \n// テ」ツつステ」ツδシテ」ツδ暗」ツ?ョテ」ツつュテ」ツδシ \nB cmp_x(const P &a,const P &b){ return (abs(a.x-b.x)<eps ) ?  a.y<b.y : a.x<b.x;}  // base x \nB cmp_y(const P &a,const P &b){ return (abs(a.y-b.y)<eps ) ?  a.x<b.x : a.y<b.y;}  // base y \nB cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg \n  \n  \n// テ・ツ淞コテヲツ慊ャテヲツ督催、ツスツ?\n// verify \nD ip(P a, P b) {return a.x * b.x + a.y * b.y;} \nD ep(P a, P b) {return a.x * b.y - a.y * b.x;} \nD sr(D a) {return sqrt(max(a, (D)0));} \nP vec(L l){return l.second-l.first;} \n  \n  \n// テァツつケ \nD ang (P p){return arg(p);} \nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base テ、ツクツュテ・ツソツ?\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );} \n  \n  \n// ccw  \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID }; \n  \nint ccw(P base, P a, P b) {              //テァツつケaテ」ツ?ィテァツつケbテ」ツ?古、ツクツ偲」ツ?暗」ツつ嘉」ツつ古」ツ?淌・ツ閉湘」ツ??」ツ?ォ \n  a -= base; b -= base; \n  if (ep(a, b) > 0)       return LEFT;    // counter clockwise \n  if (ep(a, b) < 0)      return RIGHT;   // clockwise \n  if (ip(a, b) < 0)      return BACK;    // b--base--a on line \n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line \n                         return MID;      // base--b--a on line  aテ」ツ?ィbテ」ツ?ョテァツキツ堙・ツ按?・ツ按、テ・ツョツ堙」ツ?ッテ」ツ?禿」ツつ?\n} \n  \n  \n  \nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;} \nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;} \n  \n  \n// テ、ツコツ、テァツつケ \nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));} \n  \n  \n// テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ィテァツキツ堙・ツ按?ゥツ鳴「テゥツ?」テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\n  \nB iLL(L l1,L l2){ return !ipar(l1,l2);} \nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;} \nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;} \nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;} \nB iSS(L a, L b) { \n    int cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second); \n    int cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second); \n    return ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT)); \n} \nB iSSs(L a, L b) { \n    int cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second); \n    int cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second); \n    return (cwa & cwb) == (LEFT | RIGHT); \n} \n  \n// テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ィテァツキツ堙・ツ按?ゥツ鳴「テゥツ?」テ」ツ?ョティツキツ敕ゥツ崢「 \n  \nD dLP(L l,P p){ return ep(vec(l),p-l.first)/abs(vec(l));} \nD dSP(L s,P p){ \n    if (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first); \n    if (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second); \n    return dLP(s,p); \n} \nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);} \nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));} \nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));} \n  \n\nstruct star{\n\tL l[5];\n};\n\nint main(void){\n    int n,m,l;\n\twhile(cin >> n,n){\n\t\tD graph[110][110];\n\n\t\trep(i,n)rep(j,n) graph[i][j]=INF;\n\n\t\tstar s[110];\n\n\t\tcin >> m >> l;\n\t\tm--;l--;\n\t\trep(i,n){\n\t\t\tP base;\n\t\t\tcin >> base.x >> base.y;\n\t\t\tD angle;\n\t\t\tcin >> angle;\n\t\t\tD r;\n\t\t\tcin >> r;\n\n\t\t\tP points[5];\n\n\t\t\tpoints[0]=base;\n\t\t\tpoints[0].y+=r;\n\n\t\t\tfor(int j=1;j<5;j++){\n\t\t\t\tD theta=1.0*72/180.0*pi;\n\t\t\t\tpoints[j]=rot(base,points[0],theta*j);\n\t\t\t}\n\t\t\trep(j,5){\n\t\t\t\tD theta=angle/180.0*pi;\n\t\t\t\tpoints[j]=rot(base,points[j],theta);\n\t\t\t}\n\t\t\n\t\t\trep(j,5){\n\t\t\t\tint pre=(2*j)%5,post=(2*j+2)%5;\n\t\t\t\ts[i].l[j]=mp(points[pre],points[post]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n)rep(j,n){\n\t\t\tD cmin=INF;\n\t\t\trep(k,5)rep(l,5){\n\t\t\t\tcmin=min(cmin,abs( dSS(s[i].l[k],s[j].l[l] )));\n\t\t\t}\n\t\t\tgraph[i][j]=cmin;\n\t\t}\n\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tgraph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n\t\t}\n\n\t\tcout.precision(9);\n\t\tcout << fixed << graph[m][l] << endl;\n\t}\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n#include <immintrin.h>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//テ・ツ??」ツ?ョテヲツ篠・テァツキツ?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//テゥツ敖「テァツゥツ??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n// Suffix Array\tテ・ツ按敕ヲツ慊淌・ツ個飽(|S|log^2|S|), テヲツ、ツ愿ァツエツ「O(|T|log|S|), テゥツォツ佚」ツ?陛ゥツ?催・ツ按療ヲツァツ凝ァツッツ碓(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble way[100][100];\nint main() {\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tm--, l--;\n\t\tfill(way[0], way[100], 1e9);\n\t\trep(i, n)way[i][i] = 0;\n\t\tva<int, 4> s(n);\n\t\trep(i, n)rep(j, 4)cin >> s[i][j];\n\t\trep(i, n)rep(j, i) {\n\t\t\tvector<P> si(5), sj(5);\n\t\t\tP r(0, s[i][3]);\n\t\t\tr *= P(cos(pi / 180 * s[i][2]), sin(pi / 180 * s[i][2]));\n\t\t\tP ro(cos(2 * pi / 5), sin(2 * pi / 5));\n\t\t\trep(k, 5)si[k] = P(s[i][0], s[i][1]) + r, r *= ro;\n\t\t\tr = P(0, s[j][3]);\n\t\t\tr *= P(cos(pi / 180 * s[j][2]), sin(pi / 180 * s[j][2]));\n\t\t\trep(k, 5)sj[k] = P(s[j][0], s[j][1]) + r, r *= ro;\n\t\t\trep(k, 5)rep(l, 5)cmin(way[i][j], dist_ss(L{ si[k],si[(k + 2 > 4 ? k + 2 - 5 : k + 2)] }, L{ sj[k], sj[(k + 2 > 4 ? k + 2 - 5 : k + 2)] }));\n\t\t\tway[j][i] = way[i][j];\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n)cmin(way[i][j], way[i][k] + way[k][j]);\n\t\tcout << fixed << setprecision(10) << way[m][l] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\n#define EPS 1e-9\n//#define INF 1e9\n#define PI (4.0*atan(1.0))\n//#define rep(i,n) for(int i=0;i<n;i++)\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P,i) - curr(P,i))\nenum { OUT, ON, IN };\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint N,M,LL,connect[][2]={{0,2},{0,3},{1,3},{1,4},{2,4}};\ndouble d[555];\nL line[555];\n\ntypedef pair<double,int> DI;\n\nint main(){\n\twhile(cin>>N>>M>>LL && N){\n\t\tM--;LL--;\n\t\trep(i,N){\n\t\t\tdouble x,y,a,r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tP point[6];\n\t\t\trep(j,5){\n\t\t\t\tpoint[j]=P(x+r*cos(PI/2 + a/180*PI + PI*2/5*j),\n\t\t\t\t\ty+r*sin(PI/2 + a/180*PI + PI*2/5*j));\n\t\t\t}\n\t\t\trep(j,5){\n\t\t\t\tline[i*5+j]=L(point[connect[j][0]],\n\t\t\t\t\tpoint[connect[j][1]]);\n\t\t\t}\n\t\t}\n\t\tfill(d,d+N*5,INF);\n\t\td[M*5]=0;\n\t\tpriority_queue<DI,vector<DI>,greater<DI> > Q;\n\t\tQ.push(mp(0,M*5));\n\t\twhile(1){\n\t\t\tDI p=Q.top();\n\t\t\tQ.pop();\n\t\t\tdouble dist=p.fir;\n\t\t\tint cur=p.sec;\n\t\t\tif(dist > d[cur])continue;\n\t\t\tif(cur/5 == LL){\n\t\t\t\tcout<<setprecision(15)<<dist<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,N*5)if(i!=cur){\n\t\t\t\tdouble nd=dist+distanceSS(line[cur],line[i]);\n\t\t\t\tif(nd<d[i]){\n\t\t\t\t\td[i]=nd;\n\t\t\t\t\tQ.push(mp(nd,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n \n \n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#endif\n \n#define rep (i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define MEMCPY(dest, src) memcpy(dest, src, sizeof(src))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\ntemplate <class T> vector<T> input(int n) { vector<T> res(n); for (int i = 0; i < n; ++i) cin >> res[i]; return res; }\n\n\n\n\n\n//const double EPS = 1e-8;\ntypedef complex<double> Point;\n\nint sign(double n)\n{\n\tif (abs(n) < EPS)\n\t\treturn 0;\n\telse if (n > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / (a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < 0)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) < 0)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(point, a, b);\n}\nbool is_point_on_line(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(b-a, point-a)) < EPS;\n}\nbool is_point_on_linesegment(const Point& point, const Point& a, const Point& b)\n{\n\treturn distance_linesegment_point(point, a, b) < EPS;\n}\nbool intersect_linesegments(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n\treturn cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < -EPS\n\t\t&& cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < -EPS\n\t\t|| is_point_on_linesegment(b1, a1, a2)\n\t\t|| is_point_on_linesegment(b2, a1, a2)\n\t\t|| is_point_on_linesegment(a1, b1, b2)\n\t\t|| is_point_on_linesegment(a2, b1, b2);\n}\ndouble distance_seg_seg(const Point& a, const Point& b, const Point& c, const Point& d)\n{\n\tif (intersect_linesegments(a, b, c, d))\n\t\treturn 0;\n\treturn min(min(distance_linesegment_point(c, a, b), distance_linesegment_point(d, a, b))\n\t\t, min(distance_linesegment_point(a, c, d), distance_linesegment_point(b, c, d)));\n}\n\n\ntypedef pair<Point, Point> Line;\nvoid rotate(double& x, double& y, double ang, double bx = 0, double by = 0)\n{\n\tdouble tx = x - bx, ty = y - by;\n\tdouble c = cos(ang), s = sin(ang);\n\tx = tx * c - ty * s + bx;\n\ty = tx * s + ty * c + by;\n}\nvector<Line> lines(int x, int y, int a, int r)\n{\n\tdouble w = PI * 2 / 5;\n\tdouble a1 = PI / 2 - w;\n\tdouble a2 = w - a1;\n\n\tdouble c1 = cos(a1), s1 = sin(a1);\n\tdouble c2 = cos(a2), s2 = sin(a2);\n\n\tdouble px[] = { 0, -c2, c1, -c1, c2, 0 };\n\tdouble py[] = { 1, -s2, s1, s1, -s2, 1 };\n\n\tdouble ang = PI * a / 180;\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\trotate(px[i], py[i], ang);\n\t\tpx[i] *= r, py[i] *= r;\n\t\tpx[i] += x, py[i] += y;\n\t}\n\n\tvector<Line> res;\n\tfor (int i = 0; i < 5; ++i)\n\t\tres.push_back(Line(Point(px[i], py[i]), Point(px[i + 1], py[i + 1])));\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tconst double INF = 1e20;\n\n\tint n, s, g;\n\twhile (cin >> n >> s >> g, n)\n\t{\n\t\t--s, --g;\n\n\t\tvector<Line> star[128];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstar[i] = lines(x, y, a, r);\n\t\t}\n\n\n\t\tdouble e[128][128];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\te[i][j] = INF;\n\t\t\t\tfor (int k = 0; k < 5; ++k)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < 5; ++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin_swap(e[i][j], distance_seg_seg(star[i][k].first, star[i][k].second\n\t\t\t\t\t\t\t, star[j][l].first, star[j][l].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tdouble dis[128];\n\t\tfill(dis, dis + n, INF);\n\n\t\ttypedef pair<double, int> P;\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tdis[s] = 0;\n\t\tq.push(P(0, s));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tP tt = q.top(); q.pop();\n\t\t\tint p = tt.second;\n\t\t\tdouble c = tt.first;\n\n\t\t\tif (p == g)\n\t\t\t\tbreak;\n\t\t\telse if (c > dis[p])\n\t\t\t\tcontinue;\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tdouble nc = c + e[p][i];\n\t\t\t\tif (nc < dis[i])\n\t\t\t\t{\n\t\t\t\t\tdis[i] = nc;\n\t\t\t\t\tq.push(P(nc, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(15);\n\t\tcout << dis[g] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//???????????????http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2402\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\n// ????????\\???\nPoint input_point()\n{\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b); //conj::??±???????´???°\n}\n\n// ??????\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line\n{\n  public:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\n// ????????????\nclass Circle\n{\n  public:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 1; // a,b,c??????????¨???¨?????????????????¶\n    if (cross(b, c) < -eps)\n        return -1; // a,b,c???????¨???¨?????????????????¶\n    if (dot(b, c) < 0)\n        return 2; // c,a,b???????????´???????????¶\n    if (norm(b) < norm(c))\n        return -2; // a,b,c???????????´???????????¶\n    return 0;      // a,c,b???????????´???????????¶\n}\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\n//l::??´??????s::??????\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p)\n{\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p)\n{\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    //norm::??¶?????????2???\n    return l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t)\n{\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p)\n{\n    return abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m)\n{\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s)\n{\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p)\n{\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t)\n{\n    if (isis_ss(s, t))\n        return 0;\n    return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps)\n        dfr = 0.0;\n    else if (dfr < 0.0)\n        return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0)\n        res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l)\n{\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps)\n    {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l)\n{\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p))\n            res.push_back(p);\n    return res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p)\n{\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l))\n    {\n        return ret;\n    }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps)\n        return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps)\n    {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps)\n    {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), ALL(nret));\n    }\n    else\n    {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p)\n{\n    ld res = 0;\n    int n = p.size();\n    REP(j, n)\n    res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly)\n{\n    ld angle = 0;\n    int n = poly.size();\n    REP(i, n)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\nint main()\n{\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true)\n    {\n        int n, m, l;\n        cin >> n >> m >> l;\n\n        if (n == 0)\n            break;\n\n        Polygon stars[n];\n        ld dis[n][n];\n\n        for (int i = 0; i < n; i++)\n        {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            for (int j = 0; j < 5; j++)\n            {\n                Point v = Point(x, y) + Point(r * cos((18 + a + 72 * j) * (2 * PI) / 360), r * sin((18 + a + 72 * j) * (2 * PI) / 360));\n                stars[i].push_back(v);\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n            {\n                if (i == j)\n                    dis[i][j] = 0.0;\n                else\n                    dis[i][j] = INF;\n            }\n\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                ld tmp = INF;\n                for (int k = 0; k < 5; k++)\n                {\n                    for (int l = 0; l < 5; l++)\n                    {\n                        Line x = Line(stars[i][k], stars[i][(k + 2) % 5]);\n                        Line y = Line(stars[j][l], stars[j][(l + 2) % 5]);\n                        tmp = min(tmp, dist_ss(x, y));\n                    }\n                }\n                dis[i][j] = tmp;\n                dis[j][i] = tmp;\n            }\n        }\n\n        for (int j = 0; j < n; j++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int k = 0; k < n; k++)\n                {\n                    dis[i][k] = min(dis[i][k], dis[i][j] + dis[j][k]);\n                }\n            }\n        }\n\n        cout << setprecision(10) << dis[m - 1][l - 1] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  int n,m,l;cin >> n>>m>>l;\n  if(n==0) break;\n  Polygon stars[n];\n  for(int i=0;i<n;i++){\n    int x,y,a,r;cin>>x>>y>>a>>r;\n    for(int j=0;j<5;j++){\n      Point v=Point(x,y)+Point(r*cos((18+a+72*j)*(2*PI)/360),r*sin((18+a+72*j)*(2*PI)/360));\n      stars[i].push_back(v);\n    }\n  }\n  ld dis[n][n];\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n    if(i==j) dis[i][j]=0.0;\n    else dis[i][j]=INF;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ld tmp=INF;\n      for(int k=0;k<5;k++){\n        for(int l=0;l<5;l++){\n          Line x=Line(stars[i][k],stars[i][(k+2)%5]);\n          Line y=Line(stars[j][l],stars[j][(l+2)%5]);\n          tmp=min(tmp,dist_ss(x,y));\n        }\n      }\n      dis[i][j]=tmp;dis[j][i]=tmp;\n    }\n  }\n  for(int j=0;j<n;j++){\n    for(int i=0;i<n;i++){\n      for(int k=0;k<n;k++){\n        dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);\n      }\n    }\n  }\n  cout << setprecision(10)<<dis[m-1][l-1] << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.1415926535897932384626433832795028841971\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点と点の距離\ndouble dis(P a, P b){\n    return sqrt((a.real() - b.real()) * (a.real() - b.real()) + (a.imag() - b.imag()) * (a.imag() - b.imag()));\n}\n\nvector<P> f(double x, double y, double a, double r){\n    \n    vector<P> ret(5);\n    P vec = P(0.0, r);\n    P add = P(x, y);\n    // a度 左に回転\n    P t = P(cos(a * PI / 180.0), sin(a * PI / 180.0));\n    vec = vec * t;\n    ret[0] = vec + add;\n    t = P(cos(72.0 * PI / 180.0), sin(72.0 * PI / 180.0));\n    for(int i = 1; i < 5; i++){\n        vec = vec * t;\n        ret[i] = vec + add;\n    }\n\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<P> > v(n, vector<P> (5));\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            v[i] = f(x, y, a, r);\n        }\n    \n\n        vector<vector<double> > g(n, vector<double> (n, INF));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < 5; k++) for(int l = 0; l < 5; l++){\n                    g[i][j] = min(g[i][j], abs(v[i][k] - v[j][l]));\n                }\n            }\n        }\n\n       for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n\n        printf(\"%.14f\\n\", g[m - 1][n - 1]);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n#include <queue>\n#include <pair.h>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > DBL_EPSILON)\n\t\treturn 1;\n\tif (cross(b, c) < -DBL_EPSILON)\n\t\treturn -1;\n\tif (dot(b, c) < -DBL_EPSILON)\n\t\treturn 2;\n\tif (norm(b) < norm(c) - DBL_EPSILON)\n\t\treturn 2;\n\treturn 0;\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\ndouble DistanceSP(P a, P b, P c) {\n\tif (dot(b - a, c - a) < DBL_EPSILON)\n\t\treturn abs(c - a);\n\tif (dot(a - b, c - b) < DBL_EPSILON)\n\t\treturn abs(c - b);\n\treturn abs(cross(b - a, c - a));\n}\ndouble DistaiceSS(P a, P b, P c, P d) {\n\tif (isIntersectSS(a, b, c, d)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a, b, c), DistanceSP(a, b, d)),\n\t\t\tmin(DistanceSP(c, d, a), DistanceSP(c, d, b)));\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta = M_PI / 2 + 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta), p.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(a1,p1.vertex)\n\t\tforeach(a2,p1.vertex)\n\t\t\tforeach(b1,p2.vertex)\n\t\t\t\tforeach(b2,p2.vertex) {\n\t\t\t\t\tm = min(m, DistaiceSS(*a1, *a2, *b1, *b2));\n\t\t\t\t}\n\treturn m;\n}\nint x, y, a, r;\n\ndouble dijk(int start, int goal) {\n\tvector<double> memo(N, DBL_MAX);\n\tpriority_queue<pair<double,int> > up;\n\tup.push(make_pair(0, start));\n\tmemo[start] = 0;\n\twhile (!up.empty()) {\n\t\tdouble cost = -up.top().first;\n\t\tint pos = up.top().second;\n\n\t\tup.pop();\n\t\tif (memo[pos] < cost)\n\t\t\tcontinue;\n\t\tif (pos == goal)\n\t\t\treturn cost;\n\t\tREP0(next,N) {\n\t\t\tif (links[pos][next] >= 0) {\n\t\t\t\tdouble ncost = cost + links[pos][next];\n\t\t\t\tif (memo[next] > ncost) {\n\t\t\t\t\tmemo[next] = ncost;\n\t\t\t\t\tup.push(make_pair(-ncost, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tcout << dijk(M - 1, L - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\nstruct star{\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        star S[100];\n        for(int i = 0; i < n; i++){\n\t\t\tdouble x,y,a,r;\n            cin>>x>>y>>a>>r;\n            S[i].p[0].x = 0, S[i].p[0].y = r;\n            S[i].p[0]=rot(S[i].p[0],a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            for(int j = 0; j < 5; j++) S[i].p[j] += P(x,y);\n        }\n\n\t\tP pt[100][5];\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < 5; j++){\n\t\t\t\tpt[i][j] = S[i].p[j];\n            }\n        }\n\n   \n        int f1[]={0,2,4,1,3,0};\n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    segment<double> s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    segment<double> t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define rep(i,n) for(int i=0,i##_len=n;i<i##_len;i++)\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Line> make_star(int x, int y, int a, int r){\n  int d = 5;\n  ld rad = 4 * pi / 5;\n  Point p(x, y);\n  Point v(0, r);\n  ld aa = a/180.0 * pi;\n  v *= Point(cos(aa), sin(aa));\n  Point rot(cos(rad), sin(rad));\n  vector<Line> res;\n  rep(i, d){\n    res.emplace_back(v + p,v * rot + p);\n    v *= rot;\n  }\n  return res;\n}\n\ntemplate <typename Cost>\nstruct CEdge {\n  int from, to;\n  Cost cost;\n  CEdge(int s, int t, Cost c) : from(s), to(t), cost(c) {}\n};\n\ntemplate<typename Cost> using CGraph = vector<vector<CEdge<Cost>>>;\n\ntemplate <typename Cost>\nvoid add_edge(CGraph<Cost> &g, int from, int to, Cost cost) {\n  g[from].emplace_back(from, to, cost);\n}\n\nconst int inf = 1e9;\n\ntemplate <typename Cost>\nvector<Cost> dijkstra(const CGraph<Cost> &g, int s, Cost zero = 0) {\n  vector<Cost> d(g.size(), inf);\n  d[s] = zero;\n  using P = pair<Cost,int>;\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(zero, s));\n  while (!que.empty()) {\n    Cost dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    for (const auto &e: g[v]) {\n      if (d[e.to] <= d[v] + e.cost) continue;\n      d[e.to] = d[v] + e.cost;\n      que.push(P(d[e.to], e.to));\n    }\n  }\n  return d;\n}\n\nld dist_stars (vector<Line> s, vector<Line> t){\n  ld res = 1e30l;\n  for(auto&& ss: s){\n    for(auto&& tt: t){\n      res = min(res, dist_ss(ss, tt));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n, m, l;\n  while(cin >> n >> m >> l, n != 0){\n    vector<vector<Line>> stars(n);\n    rep(i, n){\n      int x, y, a, r; cin >> x >> y >> a >> r;\n      stars[i] = make_star(x, y, a, r);\n    }\n    CGraph<ld> g(n);\n    rep(i, n){\n      rep(j, n){\n        add_edge(g, i, j, dist_stars(stars[i], stars[j]));\n      }\n    }\n    vector<ld> route = dijkstra(g, n - 1);\n    cout << std::setprecision(12) << route[m - 1] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef complex < double > P;\ntypedef pair< P, P> L;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l.fr, l.fr - l.sc) / norm( l.fr - l.sc);\n  return l.fr + t * ( l.fr - l.sc);\n}\nbool intersect( L a, P p){ //OK\n   return abs( a.fr - p) + abs( a.sc - p) - abs( a.fr - a.sc) < EPS;\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a.fr, a.sc, b.fr) * ccw( a.fr, a.sc, b.sc) <= 0 &&\n    ccw( b.fr, b.sc, a.fr) * ccw( b.fr, b.sc, a.sc) <= 0;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s.fr - p), abs( s.sc - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b.fr), distance( a, b.sc)),\n              min( distance( b, a.fr), distance( b, a.sc)));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\n\n  int table[][5] = {{0,0,1,1,2},{2,3,3,4,4}};\n\nvoid add( L* stars,double x, double y, double a, double r){\n  P hosi[5];\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[i] = L( hosi[table[0][i]], hosi[table[1][i]]);\n  }\n}\nint main(){ //vectorが重いかも\n  double info[100][100];\n  int n, m, l;\n  L stars[100][5];\n  while(scanf(\"%d%d%d\", &n, &m, &l), n|m|l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      double x, y, a, r;\n      scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &r);\n      add( stars[i], x, y, a, r);\n    }\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    for(int k = 0; k < n; k++ ){\n      for(int i = 0; i < n; i++ ){\n        for(int j = 0; j < n; j++ ){\n          info[i][j] = min( info[i][j], info[i][k] + info[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\", info[m][l]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<complex>\n#define INF 10000000.0\n#define pb push_back\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> Point;\ntypedef pair<double ,int > P;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real( conj(a) * b );\n}\ndouble cross(Point a, Point b){\n    return imag( conj(a) * b );\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a)<=0 ) return abs(c-a);\n  if ( dot(a-b, c-b)<=0 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\nint is_intersected_ls(Point a1, Point a2, Point b1, Point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) <=0 ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) <=0 );\n}\ndouble distance_ls_ls(Point a1,Point a2,Point a3,Point a4){\n    if(is_intersected_ls(a1,a2,a3,a4))\n        return 0.0;\n    double r1=distance_ls_p(a1,a2,a3),r2=distance_ls_p(a1,a2,a4),r3=distance_ls_p(a3,a4,a1),r4=distance_ls_p(a3,a4,a2);\n    if(r1>r2)\n    r1=r2;\n    if(r3>r4)\n    r3=r4;\n    if(r1>r3)\n    return r3;\n    return r1;\n     \n}\ndouble cal(int a,int b){\n    double ret=INF;\n    for(int i=0;i<5;i++){\n        for(int j=i+1;j<5;j++){\n            for(int k=0;k<5;k++){\n                for(int l=k+1;l<5;l++){\n                    double u=distance_ls_ls(p[a][i],p[a][j],p[b][k],p[b][l]);\n                    if(ret>u)\n                        ret=u;\n                }\n            }\n        }\n    }\n    //cout<<ret<<endl;\n    return ret;\n}\n \n \n \nint main(){\n    while(cin>>n>>s>>g,n||s||g){\n        p.clear();\n        p.resize(n);\n        for(int i=0;i<n;i++){\n            double x,y,a,r;\n            Point pot;\n            cin>>x>>y>>a>>r;\n            Point c=Point(x,y);\n            for(int j=0;j<5;j++){\n                p[i].pb(c+polar(r,PI*(a+(double)j*72.0+90.0)/180.0));\n            }\n        }\n        //cout<<\"      \"<<distance_ls_p(p[0][4],p[0][1],p[2][2])<<endl;\n \n         \n        vector<vector<double> > cost(n,vector<double>(n,INF));\n         \n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n            \tif(i==j){\n            \t\tcost[i][j]=0;\n            \t\tcontinue;\n            \t}\n                double a=cal(i,j);\n                cost[i][j]=a;\n                cost[j][i]=a;\n            }\n        }\n    \tfor(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tcost[i][j]=min(cost[i][k]+cost[k][j],cost[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t//cout<<cost[s-1][g-1]<<endl;\n    \tprintf(\"%.8lf\\n\",cost[s-1][g-1]);\n        /*\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cout<<cost[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n         \n        /*priority_queue<P,vector<P>,greater<P> > que;\n        que.push(P(0,s-1));\n        vector<double> d(n,INF);\n        d[s-1]=0;\n        while(!que.empty()){\n            P q=que.top();\n            int pos=q.second;\n            double dist=q.first;\n            que.pop();\n            if(pos==g-1){\n                printf(\"%.8lf\\n\",dist);\n                break;\n            }\n            if(dist>d[pos]){\n                continue;\n            }\n            for(int i=0;i<n;i++){\n                 \n                if(cost[pos][i]==INF){\n                    continue;\n                }\n                if(cost[pos][i]+dist<d[i]){\n                    que.push(P(cost[pos][i]+dist,i));\n                    d[i]=cost[pos][i]+dist;\n                }\n                 \n                 \n            }\n        }*/\n         \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef pair<double,double> pdd;\n\nconst double pi = atan(1.0) * 4.0;\nconst double EPS = 1e-8;\n\ndouble cross(pdd x, pdd y) {\n\treturn x.first*y.second - x.second*y.first;\n}\n\ndouble dist(pdd x, pdd y) {\n\treturn sqrt((x.first-y.first)*(x.first-y.first) + (x.second-y.second)*(x.second-y.second));\n}\n\nint main() {\n\tint N, M, L;\n\twhile(scanf(\"%d %d %d\", &N, &M, &L), N) {\n\t\tvector< vector<pdd> > star(N);\n\t\trep(i, N) {\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r);\n\t\t\trep(j, 5) {\n\t\t\t\tdouble ang = (72.0 * j + a) * pi / 180.0;\n\t\t\t\tpdd p(x-r*sin(ang), y+r*cos(ang));\n\t\t\t\tstar[i].push_back(p);\n\t\t\t}\n\t\t}\n\t\tdouble cost[100][100];\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = 1e9;\n\t\t\t\tif(i==j) cost[i][j] = 0.0;\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd v1 = pdd(star[i][ii].first - star[i][(ii+1)%5].first, star[i][ii].second - star[i][(ii+1)%5].second);\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tpdd v2 = pdd(star[j][jj].first - star[j][(jj+1)%5].first, star[j][jj].second - star[j][(jj+1)%5].second);\n\t\t\t\t\t\tpdd u1 = pdd(star[i][ii].first - star[j][(jj+1)%5].first, star[i][ii].second - star[j][(jj+1)%5].second);\n\t\t\t\t\t\tpdd u2 = pdd(star[j][jj].first - star[i][(ii+1)%5].first, star[j][jj].second - star[i][(ii+1)%5].second);\n\t\t\t\t\t\tpdd w1 = pdd(star[i][ii].first - star[j][jj].first, star[i][ii].second - star[j][jj].second);\n\t\t\t\t\t\tpdd w2 = pdd(-w1.first, -w1.second);\n\t\t\t\t\t\tif( cross(v1,u1)*cross(v1,w1)<0 && cross(v2,u2)*cross(v2,w2)<0 ) {\n\t\t\t\t\t\t\tcost[i][j] = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd s = star[i][ii];\n\t\t\t\t\tpdd t = star[i][(ii+1)%5];\n\t\t\t\t\tdouble alp = 0.0f;\n\t\t\t\t\tif( abs(t.first-s.first) < EPS ) {\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], abs(t.first - star[j][jj].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\talp = (t.second-s.second)/(t.first-s.first);\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tpdd p = star[j][jj];\n\t\t\t\t\t\t\tdouble qx = (p.first+alp*p.second-alp*s.second+alp*alp*s.first) / (alp*alp+1.0);\n\t\t\t\t\t\t\tdouble qy = alp*(qx-s.first) + s.second;\n\t\t\t\t\t\t\tpdd q = pdd(qx,qy);\n\t\t\t\t\t\t\tif( dist(q,s)<dist(t,s) && dist(q,t)<dist(t,s) ) {\n\t\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(p,q));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(star[i][ii], star[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = cost[j][i] = min(cost[i][j], cost[j][i]);\n\t\t\t}\n\t\t}\n\t\trep(k, N) {\n\t\t\trep(i, N) {\n\t\t\t\trep(j, N) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", min(cost[M-1][L-1],cost[L-1][M-1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cmath>\n#include<complex>\n#define INF 10000000\n#define pb push_back\nusing namespace std;\ntypedef complex<double> Point;\ntypedef pair<double,int> P;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real(conj(a)*b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a)*b);\n}\ndouble dlp(Point a, Point b, Point c) {\n  if(dot(b-a,c-a)<=0 )return abs(c-a);\n  if(dot(a-b,c-b)<=0 )return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\nint iil(Point a1,Point a2,Point b1,Point b2){\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<=0)&&(cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<=0);\n}\ndouble dll(Point a1,Point a2,Point a3,Point a4){\n    if(iil(a1,a2,a3,a4))\n        return 0.0;\n\treturn min(min(dlp(a1,a2,a3),dlp(a1,a2,a4)),min(dlp(a3,a4,a1),dlp(a3,a4,a2)));\n}\ndouble cal(int a,int b){\n    double ret=INF;\n    for(int i=0;i<5;i++)\n        for(int j=2;j<4&&i+j<5;j++)\n            for(int k=0;k<5;k++)\n                for(int l=2;l<4&&k+l<5;l++)\n                \tret=min(dll(p[a][i],p[a][i+j],p[b][k],p[b][k+l]),ret);\n    return ret;\n}\nint main(){\n    while(cin>>n>>s>>g,n||s||g){\n        p.clear();\n        p.resize(n);\n        for(int i=0;i<n;i++){\n            double x,y,a,r;\n            cin>>x>>y>>a>>r;\n            Point c=Point(x,y);\n            for(int j=0;j<5;j++){\n            \tp[i].pb(c+polar(r,(a+72.0*j+90)*PI/180.0));\n            }\n        }\n        vector<vector<double> > cost(n,vector<double>(n,INF));\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n            \tif(i==j){\n            \t\tcost[i][j]=0;\n            \t\tcontinue;\n            \t}\n                cost[i][j]=cost[j][i]=cal(i,j);\n            }\n        }\n    \tfor(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tcost[i][j]=min(cost[i][k]+cost[k][j],cost[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprintf(\"%.8lf\\n\",cost[s-1][g-1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define PI 3.14159265358\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n\nvector<P> getStar(P c,double a,double r){\n\tconst static P rot(cos(72*PI/180),sin(72*PI/180));\n\tvector<P> ret(5);\n\tret[0]=c+P(0,r)*P(cos(a*PI/180),sin(a*PI/180));\n\trange(i,1,5){\n\t\tret[i]=(ret[i-1]-c)*rot+c;\n\t}\n\tswap(ret[1],ret[2]);\n\tswap(ret[1],ret[4]);\n\tswap(ret[1],ret[3]);\n\treturn ret;\n}\n\ndouble getDist(vector<P> &a,vector<P> &b){\n\tdouble r=1e8;\n\trep(i,5)rep(j,5){\n\t\tr=min(r,distSS(a[i],a[(i+1)%5],b[j],b[(j+1)%5]));\n\t}\n\treturn r;\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tvector<vector<P>> star(n);\n\t\trep(i,n){\n\t\t\tdouble x,y,a,r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tstar[i]=getStar(P(x,y),a,r);\n\t\t}\n\t\t\n\t\tvector<vector<double>> dist(n,vector<double>(n));\n\t\trep(i,n)rep(j,n){\n\t\t\tdist[i][j]=getDist(star[i],star[j]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\tcout<<setprecision(14)<<fixed<<dist[m-1][l-1]<<endl;\t\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\ndouble deg2rad(double deg) {\n    return deg * 2. * PI / 360;\n}\n\n// rot p around q by theta (counter-clockwise) \nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\ndouble distanceLP(L l, P p) {\n    return abs(cross(l.v, p - l.a)) / abs(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.v, p - l.a) < 0) return abs(p - l.a);\n    if (dot(-l.v, p - l.b) < 0) return abs(p - l.b);\n    return distanceLP(l, p);\n}\n\ndouble distanceSS(L l1, L l2) {\n    if (intersectSS(l1, l2)) return 0;\n    double d = INF;\n    d = min(d, distanceSP(l1, l2.a));\n    d = min(d, distanceSP(l1, l2.b));\n    d = min(d, distanceSP(l2, l1.a));\n    d = min(d, distanceSP(l2, l1.b));\n    return d;\n}\n\nstruct Star {\n    P c;\n    double r;\n    vector<P> p;\n    vector<L> l;\n    Star(){}\n    Star(double x, double y, double deg, double _r) : c(x, y), r(_r) {\n        rep(i, 5) {\n            p.emplace_back(rotP(P(x, y + r), c, deg2rad(deg + 72 * i)));\n        }\n        rep(i, 5) {\n            l.emplace_back(L(p[i], p[(i + 2) % 5]));\n        }\n    }\n    double dist(const Star& o) {\n        double ret = INF;\n        rep(i, 5) {\n            rep(j, 5) {\n                ret = min(ret, distanceSS(l[i], o.l[j]));\n            }\n        }\n        return ret;\n    }\n};\n\nstruct edge {\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to, double _cost) : to(_to), cost(_cost) {}\n};\ntypedef vector<vector<edge>> Graph;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, double c) {\n    G[x].emplace_back(y, c);\n    G[y].emplace_back(x, c);\n}\n\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    using Pdi = pair<double, int>;\n    priority_queue<Pdi, vector<Pdi>, greater<Pdi>> pq;   // cost, vertex\n    vector<double> d(n, INF);\n    d[s] = 0.;\n    pq.push(make_pair(0., s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, s, g;\n    while (cin >> n >> s >> g, n) {\n        s--; g--;\n\n        vector<Star> stars;\n        rep(i, n) {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            stars.emplace_back(x, y, a, r);\n        }\n\n        Graph G(n);\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                addEdge(G, i, j, stars[i].dist(stars[j]));\n            }\n        }\n\n        cout << fixed << setprecision(20) << dijkstra(G, s, g) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdio>\n#include<iomanip>\n#define EPS 1.0e-12\n#define INF 1.0e+12\n#define INFI 1000000\nusing namespace std;\n//2次元座標\nclass point{\npublic:\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y){\n\t\tthis->x=x;\n\t\tthis->y=y;\n\t}\n\tdouble len(point &p){\n\t\treturn sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));\n\t}\n\tpoint operator*(double d){\n\t\tpoint p(x*d,y*d);\n\t\treturn p;\n\t}\n\tpoint operator+(point &o){\n\t\tpoint p(x+o.x,y+o.y);\n\t\treturn p;\n\t}\n\tpoint operator-(point &o){\n\t\tpoint p(x-o.x,y-o.y);\n\t\treturn p;\n\t}\n\tbool operator==(point &o){\n\t\treturn (x==o.x && y==o.y);\n\t}\n\tbool operator!=(point &o){\n\t\treturn !(x==o.x && y==o.y);\n\t}\n};\n//内積\ndouble dot(point p,point q){\n\treturn (p.x*q.x+p.y*q.y);\n}\n//外積\ndouble cross(point p,point q){\n\treturn (p.x*q.y-p.y*q.x);\n}\n//線分と点\ndouble SegmentPoint(point p,point q,point r){\n\tif(dot(q-p,r-p)<EPS) return abs(r.len(p));\n\tif(dot(p-q,r-q)<EPS) return abs(r.len(q));\n\treturn abs(cross(q-p,r-p))/abs(q.len(p));\n}\n//同一直線上じゃないか、重なっている部分が存在する\nbool han(point p0,point p1,point q0,point q1){\n\tif(cross(p0-p1,q0-p0)==0.0 && cross(p0-p1,q1-p0)){//同一直線\n\t\tif(abs(p0.len(q0))+abs(q0.len(p1))<abs(p0.len(p1))+EPS ||\n\t\t\tabs(p0.len(q1))+abs(q1.len(p1))<abs(p0.len(p1))+EPS){\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n//線分線分\nbool SegSeg(point p0,point p1,point q0,point q1){\n\tint a=cross(p1-p0,q0-p0);\n\tint b=cross(p1-p0,q1-p0);\n\tint c=cross(q1-q0,p0-q0);\n\tint d=cross(q1-q0,p1-q0);\n\treturn (a*b<EPS)&&(c*d<EPS)&&(han(p0,p1,q0,q1));\n}\n//アウグストゥスみたいななにか\nclass route{\nprivate:\n\tdouble **cost;\n\tdouble *dist;\n\tbool *used;\n\tint v;\npublic:\n\troute(){}\n\troute(int v){\n\t\tthis->v=v;\n\t\tcost=new double*[v];\n\t\tfor(int i=0;i<v;i++) cost[i]=new double[v];\n\t\tdist=new double[v];\n\t\tused=new bool[v];\n\t}\n\tvoid format(double c){\n\t\tfor(int i=0;i<v;i++) for(int j=0;j<v;j++) cost[i][j]=c;\n\t}\n\tvoid set(int n,int m,double c){\n\t\tcost[n][m]=c;\n\t\tcost[m][n]=c;\n\t}\n\tvoid set(int s){\n\t\tfor(int i=0;i<this->v;i++){\n\t\t\tdist[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tdist[s]=0;\n\t\twhile(true){\n\t\t\tint p=-1;\n\t\t\tfor(int i=0;i<this->v;i++){\n\t\t\t\tif(!used[i] && (p==-1 || dist[i]<dist[p])) p=i;\n\t\t\t}\n\t\t\tif(p==-1) break;\n\t\t\tused[p]=true;\n\t\t\tfor(int i=0;i<v;i++){\n\t\t\t\tdist[i]=min(dist[i],dist[p]+cost[p][i]);\n\t\t\t}\n\t\t}\n\t}\n\tdouble RetCost(int e){\n\t\treturn dist[e];\n\t}\n\tdouble ret(int i,int j){\n\t\treturn cost[i][j];\n\t}\n};\n\nstruct st_star{\n\tpoint p[6];\n};\n\nst_star *star;\nroute *r;\n\nint main(){\n\tint i,j,k,l;\n\tint n,m,q;\n\tint x,y,a,t;\n\tcout<<setprecision(20);\n\twhile(cin>>n>>m>>q){\n\t\tif(n==0 && m==0 && q==0) break;\n\t\tr=new route(n);\n\t\tstar=new st_star[n];\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>x>>y>>a>>t;\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tstar[i].p[j].x=x+t*cos(((a+90+216*j)%360)*M_PI/180);\n\t\t\t\tstar[i].p[j].y=y+t*sin(((a+90+216*j)%360)*M_PI/180);\n\t\t\t}\n\t\t\tstar[i].p[5]=star[i].p[0];\n\t\t}\n\t\t//交わりor最短\n\t\tfor(i=0;i<n;i++){\n\t\t\tr->set(i,i,0);\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[0],star[j].p[1])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[1],star[j].p[2])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[2],star[j].p[3])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[3],star[j].p[4])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(SegSeg(star[i].p[k],star[i].p[k+1],star[j].p[4],star[j].p[5])){\n\t\t\t\t\t\tr->set(i,j,0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k==5){\n\t\t\t\t\tdouble p=INF;\n\t\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\t\tfor(l=0;l<5;l++){\n\t\t\t\t\t\t\tp=min(p,SegmentPoint(star[i].p[k],star[i].p[k+1],star[j].p[l]));\n\t\t\t\t\t\t\tp=min(p,SegmentPoint(star[j].p[k],star[j].p[k+1],star[i].p[l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr->set(i,j,p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr->set(m-1);\n\t\tcout<<r->RetCost(q-1)<<endl;\n\t\tdelete r;\n\t\tdelete []star;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-8;\nconst double inf=1e12;\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nP reflection(const L& l,const P& p){\n  return p+2.0*(projection(l,p)-p);\n}\nP rotation(const P& a,double r){\n  return P(x(a)*cos(r)-y(a)*sin(r),x(a)*sin(r)+y(a)*cos(r));\n}\n\n//// counter-clockwise\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L& l,const L& m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps;\n}\nbool intersectSS(const L& s,const L& t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\ndouble distanceSP(const L& s,const P& p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L& s,const L& t) {\n  return intersectSS(s,t)?0:min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n                                min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\n\nP ps[111][5];\ndouble dist[111][111];\nconst double PI=acos(-1);\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int n,m,l;\n    cin>>n>>m>>l;\n    l--;m--;\n    if(n==0)break;\n    rep(i,n){\n      double x,y,a,r;\n      cin>>x>>y>>a>>r;\n      P cent(x,y),p0(0,r);\n      rep(j,5){\n        ps[i][j]=rotation(p0,(((a+j*72)/180)*PI))+cent;\n      }\n    }\n    rep(i,n)rep(j,n)dist[i][j]=i==j?0:inf;\n    rep(i,n)rep(j,n)rep(id,5)rep(jd,5){\n      if(i==j)continue;\n      minch(dist[i][j],distanceSS(L(ps[i][id],ps[i][(id+1)%5]),L(ps[j][jd],ps[j][(jd+1)%5])));\n    }\n    rep(k,n)rep(i,n)rep(j,n)minch(dist[i][j],dist[i][k]+dist[k][j]);\n    printf(\"%.15f\\n\", dist[l][m]);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n#define INF 0x3f3f3f3f\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\nstruct Point {\n\tdouble x, y;\n\tPoint() :x(0.0), y(0.0) {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tPoint& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n};\nPoint operator+(const Point& p1, const Point& p2) { return Point(p1) += p2; }\nPoint operator-(const Point& p1, const Point& p2) { return Point(p1) -= p2; }\n\nstruct Vector :public Point {\n\tusing Point::Point;\n\tVector() {}\n\tVector(const Point& P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)); }\n\t//Vector unit() { return *this / abs(); }\n};\n\ndouble dot(Vector a, Vector b) { return a.x* b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x* b.y - a.y * b.x; }\n\nstruct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\n\nstruct Segment :public Line {\n\tusing Line::Line;\n\tSegment() {}\n\tSegment(const Line& L) { p1 = L.p1; p2 = L.p2; }\n\t//Vector vec() { return p2 - p1; }\n};\n\ndouble rad(double deg) { return PI * deg / 180; }\n\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm(), b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Segment a, Segment b) {\n\tPoint p1 = a.p1, p2 = a.p2, p3 = b.p1, p4 = b.p2;\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble get_distance(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\nusing Weight = double;\nstruct Edge {\n\tint s, d; Weight w;\n\tEdge() {};\n\tEdge(int s, int d, Weight w) :s(s), d(d), w(w) {};\n};\nbool operator<(const Edge & e1, const Edge & e2) {\n\treturn e1.w == e2.w ? (e1.s == e2.s ? e1.d < e2.d : e1.s < e2.s) :\n\t\te1.w < e2.w;\n}\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\n\nvoid addArc(Graph & g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph & g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nauto dijkstra = [&](const Graph & g, int s, Array & dist) {\n\tint n = g.size();\n\tvector<bool> vis(n);\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); dist[s] = 0;\n\tusing State = tuple<Weight, int, int>;\n\tpriority_queue<State, vector<State>, greater<State>> pq;\n\tpq.emplace(0, s, -1);\n\twhile (pq.size()) {\n\t\tWeight d; int v, p; tie(d, v, p) = pq.top(); pq.pop();\n\t\tif (dist[v] < d)continue;\n\t\tvis[v] = true;\n\t\tprev[v] = p;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (vis[e.d])continue;\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tpq.emplace(dist[e.d], e.d, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n};\n\nsigned main() {\n\tcout << fixed << setprecision(10);\n\tfor (int N, M, L; cin >> N >> M >> L && N;) {\n\t\tM--, L--;\n\n\t\tvector<double> x(N), y(N), a(N), r(N);\n\t\trep(i, 0, N) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\n\t\tauto id = [&](int i, int j) {return 5 * i + j; };\n\t\tvector<Point> V(5 * N);\n\t\trep(i, 0, N) {\n\t\t\trep(j, 0, 5) {\n\t\t\t\tdouble d = a[i] + j * 360 / 5;\n\t\t\t\tdouble t = rad(d);\n\t\t\t\tV[id(i, j)] = Point(x[i] - r[i] * sin(t), y[i] + r[i] * cos(t));\n\t\t\t}\n\t\t}\n\n\t\tGraph g(5 * N);\n\n\t\trep(i, 0, N)rep(j, 0, 5) {\n\t\t\tint a = id(i, j);\n\t\t\tint b = id(i, (j + 2) % 5);\n\t\t\taddEdge(g, a, b, 0);\n\t\t}\n\n\t\trep(i, 0, N)rep(j, i + 1, N) {\n\t\t\trep(k, 0, 5)rep(l, 0, 5) {\n\t\t\t\tSegment s1(Line(V[id(i, k)], V[id(i, (k + 2) % 5)])),\n\t\t\t\t\ts2(Line(V[id(j, l)], V[id(j, (l + 2) % 5)]));\n\t\t\t\taddEdge(g, id(i, k), id(j, l), get_distance(s1, s2));\n\t\t\t\t//cerr << id(i, k) << \" \" << id(j, l) << \" \" << get_distance(s1, s2) << endl;\n\t\t\t}\n\t\t}\n\n\t\tArray dist;\n\t\tdijkstra(g, id(M, 0), dist);\n\t\tcout << dist[id(L, 0)] << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll read(){ll i;cin>>i;return i;}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-7;\nconst ld PI=acos(ld(-1));\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nauto cmcmp=[](const cm&a,const cm&b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\nld tri2(cm a,cm b,cm c){\n\treturn crs(b-a,c-a);\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n\nusing ln=pair<cm,cm>;\ncm dir(ln a){return a.b-a.a;}\ncm eval(ln a,ld b){return a.a+dir(a)*b;}\ncm proj(ln a,cm b){\n\tcm c=dir(a);\n\treturn a.a+c*dot(c,b-a.a)/norm(c);\n}\ncm refl(ln a,cm b){\n\treturn ld(2)*proj(a,b)-b;\n}\n//AOJ0153\nld dsp(ln a,cm b){\n\tcm c=proj(a,b);\n\tif(abs(bet(a.a,a.b,c))<=1)return abs(b-c);\n\treturn min(abs(b-a.a),abs(b-a.b));\n}\nint ccw(ln a,cm b){return ccw(a.a,a.b,b);}\n//AOJ1157\n//0-no,1-yes(endpoint),2-yes(innner)\nint iss(ln a,ln b){\n\tint c=ccw(a.a,a.b,b.a)*ccw(a.a,a.b,b.b);\n\tint d=ccw(b.a,b.b,a.a)*ccw(b.a,b.b,a.b);\n\tint e=max(c,d);\n\tif(e)return 1-e;\n\tint f=bet(a.a,a.b,b.a),g=bet(a.a,a.b,b.b);\n\tif(max(f,g)==-2||min(f,g)==2)return 0;\n\treturn 1;\n}\n//AOJ1157\nld dss(ln a,ln b){\n\tif(iss(a,b))return 0;\n\treturn min({dsp(a,b.a),dsp(a,b.b),dsp(b,a.a),dsp(b,a.b)});\n}\n\ntemplate<class E,class D=ll>\nvc<D> dijkstra(const vvc<E>& g,int s){\n\tconst int n=g.size();\n\tusing P=pair<D,int>;\n\tpriority_queue<P,vc<P>,greater<P>> pq;\n\tvc<D> dist(n,1e9);\n\tconst auto ar=[&](int v,D d){\n\t\tif(dist[v]>d){\n\t\t\tdist[v]=d;\n\t\t\tpq.push(P(d,v));\n\t\t}\n\t};\n\tar(s,0);\n\twhile(pq.size()){\n\t\tD d;\n\t\tint v;\n\t\ttie(d,v)=pq.top();pq.pop();\n\t\tfor(auto e:g[v])\n\t\t\tar(e.to,d+e.cost);\n\t}\n\treturn dist;\n}\n\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\twhile(1){\n\t\tint n=read(),m=read()-1,l=read()-1;\n\t\tif(n==0)break;\n\t\tvc<ln> w;\n\t\trep(i,n){\n\t\t\tld s,t,a,r;\n\t\t\tcin>>s>>t>>a>>r;\n\t\t\tvc<cm> z;\n\t\t\trep(k,5)\n\t\t\t\tz.pb(cm(s,t)+polar(r,PI/2+a/180*PI+k*PI*0.8));\n\t\t\trep(k,5)\n\t\t\t\tw.eb(z[k],z[(k+1)%5]);\n\t\t}\n\t\t\n\t\tstruct E{int to;ld cost;};\n\t\tvvc<E> g(n*5+2);\n\t\tg[n*5].pb(E{m*5,0});\n\t\tg[l*5].pb(E{n*5+1,0});\n\t\trep(i,n*5)rep(j,n*5)\n\t\t\tg[i].pb(E{j,dss(w[i],w[j])});\n\t\t\n\t\tcout<<dijkstra<E,ld>(g,n*5)[n*5+1]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef double Weight;\n\nconst double EPS = 1e-9;\nconst double INF = 1e10;\nconst double PI = M_PI;\n\n// 平面の点\nstruct Point {\n    Point(double x, double y) : x(x), y(y) {}\n    Point() {}\n    double x, y;\n};\nPoint operator+(const Point &a, const Point &b) {\n    return Point(a.x + b.x, a.y + b.y);\n}\nPoint operator-(const Point &a, const Point &b) {\n    return Point(a.x - b.x, a.y - b.y);\n}\nPoint operator*(const Point &a, const double b) {\n    return Point(a.x * b, a.y * b);\n}\nPoint rotate(const Point &a, double angle) {\n    return Point(cos(angle) * a.x - sin(angle) * a.y,\n                 sin(angle) * a.x + cos(angle) * a.y);\n}\ndouble cross(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble dot(const Point &a, const Point &b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble atan(const Point &a) {\n    return atan2(a.y, a.x);\n}\ndouble norm(const Point &a) {\n    return dot(a, a);\n}\ndouble abs(const Point &a) {\n    return sqrt(norm(a));\n}\nstruct Line:vector<Point> {\n    Line(Point a = Point(0, 0), Point b = Point(0, 0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\nint ccw(Point a, Point b, Point c) {\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\nPoint projection(const Line &l, const Point &p) {\n\n    double t = dot(p - l[0], l[1]- l[0]) / norm(l[0] - l[1]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nbool is_intersect_SS(const Line &s, const Line &t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nbool is_intersect_SP(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p) == 0;\n}\ndouble distance_SP(const Line &s, const Point &p) {\n    const Point r = projection(s, p);\n    if (is_intersect_SP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distance_SS(const Line &s, const Line &t) {\n    if (is_intersect_SS(s, t)) return 0;\n    return min(min(distance_SP(s, t[0]), distance_SP(s, t[1])),\n               min(distance_SP(t, s[0]), distance_SP(t, s[1])));\n}\n\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int f, int t, Weight c) :\n    src(f), dst(t), weight(c) {}\n};\nbool operator<(const Edge &a, const Edge &b) {\n    return a.weight < b.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n    int n = g.size();\n    vector<Weight> dist(n, INF);\n    vector<int> prev(n, -1);\n    dist[s] = 0;\n    priority_queue<Edge> que;\n\n    for (que.push(Edge(-2, s, 0)); !que.empty();) {\n        Edge e = que.top(); que.pop();\n        if (prev[e.dst] != -1)\n            continue;\n        prev[e.dst] = e.src;\n        for (auto f = g[e.dst].begin(); f != g[e.dst].end(); ++f) {\n            if (dist[f->dst] > e.weight + f->weight) {\n                dist[f->dst] = e.weight + f->weight;\n                que.push(Edge(f->src, f->dst, e.weight + f->weight));\n            }\n        }\n    }\n\n    // for (size_t i = 0; i < dist.size(); ++i)\n    //     cout << dist[i] << \"\\n\";\n\n    Weight res = INF;\n    for (int i = 0; i < 5; ++i)\n        res = min(res, dist[t + i]);\n\n    return res;\n}\n\nint main()\n{\n    int N, M, L;\n\n    while (cin >> N >> M >> L) {\n        if (N == 0 && M == 0 && L == 0)\n            break;\n        --M, --L;\n\n        vector<Line> line(N * 5);\n        vector<Point> point(N * 5);\n        double x, y, a, r;\n\n        // 星の座標を求める\n        for (int i = 0; i < N; ++i) {\n            cin >> x >> y >> a >> r;\n            Point origin(0, r);\n\n            for (int j = 0; j < 5; ++j) {\n                point[i * 5 + j] = rotate(origin, (72 * j + a) * PI / 180.0)\n                    + Point(x, y);\n            }\n        }\n\n        // 星の線分を求める\n        for (int i = 0; i < 5 * N; i += 5) {\n            line[i] = Line(point[i], point[i + 2]);\n            line[i + 1] = Line(point[i], point[i + 3]);\n            line[i + 2] = Line(point[i + 1], point[i + 3]);\n            line[i + 3] = Line(point[i + 1], point[i + 4]);\n            line[i + 4] = Line(point[i + 2], point[i + 4]);\n        }\n\n        Graph g(5 * N);\n        M *= 5; L *= 5;\n\n        for (int i = 0; i < 5 * N; ++i) {\n            for (int j = 0; j < 5 * N; ++j) {\n                if (i == j)\n                    continue;\n                Weight cost = distance_SS(line[i], line[j]);\n                if (abs(cost) < EPS)\n                    cost = 0.0;\n                g[i].push_back(Edge(i, j, cost));\n                g[j].push_back(Edge(j, i, cost));\n            }\n        }\n\n        Weight ans = INF;\n        for (int i = 0; i < 5; ++i)\n            ans = min(ans, Dijkstra(g, M + i, L));\n        printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=105,INF=1<<20;\n\n#define double long double\n\nconst double eps=1e-10;\nconst double pi=acos((double)-1.0L);\n#define equals(a,b) (fabs((a)-(b))<eps)\n\ndouble torad(int deg) {return (double)(deg)*pi/180.0;}\ndouble todeg(double ang) {return ang*180.0/pi;}\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point(double x=0,double y=0):x(x),y(y){}\n    \n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n    \n    bool operator < (const Point &p)const{\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    \n    bool operator == (const Point &p)const{\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n    Point p1,p2;\n};\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int counter_clockwise=1;\nstatic const int clockwise=-1;\nstatic const int online_back=2;\nstatic const int online_front=-2;\nstatic const int on_segment=0;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    \n    if(cross(a,b)>eps) return counter_clockwise;\n    if(cross(a,b)<-eps) return clockwise;\n    if(dot(a,b)<-eps) return online_back;\n    if(a.norm()<b.norm()) return online_front;\n    \n    return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ntypedef Segment Line;\n\ndouble getDistance(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min({getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2),getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)});\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\npair<Point,Point> segCrossPpoints(Circle c,Line l){\n    //assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r-c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ntypedef vector<Point> Polygon;\n\n/*\n IN 2\n ON 1\n OUT 0\n */\n\nint contains(Polygon g,Point p){\n    int n=int(g.size());\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<eps&&eps<b.y&&cross(a,b)>eps) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s,bool ok){\n    Polygon u,l;\n    sort(all(s));\n    \n    if(int(s.size())<3) return s;\n    int n=int(s.size());\n    \n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    \n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    \n    if(ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])==counter_clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])==counter_clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    if(!ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])!=clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])!=clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    reverse(all(l));\n    \n    for(int i=int(u.size())-2;i>=1;i--) l.push_back(u[i]);\n    \n    return l;\n}//ok==1なら辺の上も含める\n\ndouble dis[MAX][MAX];\nint N;\n\nvoid floyd(){\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int s,g;cin>>N>>s>>g;\n        if(N==0) break;\n        s--;g--;\n        vector<vector<Point>> A(N,vector<Point>(6));\n        \n        for(int i=0;i<N;i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            \n            for(int j=0;j<6;j++){\n                A[i][j]={x+r*cos(torad(a+90.0+144.0*j)),y+r*sin(torad(a+90.0+144.0*j))};\n            }\n        }\n        \n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                dis[i][j]=INF;\n            }\n            dis[i][i]=0.0;\n        }\n        \n        for(int a=0;a<N;a++){\n            for(int b=0;b<N;b++){\n                if(a==b) continue;\n                \n                for(int i=0;i<5;i++){\n                    for(int j=0;j<5;j++){\n                        Segment s1={A[a][i],A[a][i+1]};\n                        Segment s2={A[b][j],A[b][j+1]};\n                        dis[a][b]=min(dis[a][b],getDistance(s1,s2));\n                    }\n                }\n            }\n        }\n        \n        floyd();\n        \n        cout<<setprecision(25)<<dis[s][g]<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  double x, y, a, r;\n  ST(){}\n  ST(double x, double y, double a, double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst double INF = 1000000000.0;\nconst double EPS = 1e-8;\n\nint n, s, t;\nvector<ST> input;\ndouble dist[N][N];\n\ndouble dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec){\n  vector<Point> data;\n  Point o = Point(st.x, st.y);\n  Point p = Point(st.x, st.y + st.r);\n  for(int i=0;i<5;i++){\n    data.push_back(rotate(p, o, st.a+72.0*i));\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){data[i], data[i+1]});\n  }\n  vec.push_back((Segment){data[4], data[0]});\n}\n\ndouble calc_dist(ST pa, ST pb){\n  vector<Segment> a, b;\n  get_seg(pa, a);\n  get_seg(pb, b);\n  double res = INF;\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      res = min(res, getDistance(a[i], b[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\ndouble solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.15f\\n\", (double)solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// geometry ////\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.x * v.x < -EPS || u.y - v.y < -EPS) { return -1; }\n\tif (u.sqlength() - v.sqlength() < -EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return a * (a.dot(b) / a.length()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn contains(a, b.p) || contains(a, b.p + b.d)\n\t\t|| contains(b, a.p) || contains(b, a.p + a.d);\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return b.d.cross(a - b.p) / b.d.length(); }\ninline double getDistance(P2 a, LineSeg b) { return min(getDistance(perpendicular_foot(a, (Line)b), a), min(getDistance(b.p, a), getDistance(b.p + b.d, a))); }\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b) { return isCross(a, b) ? 0 : min(min(getDistance(a.p, b.p), getDistance(a.p, b.p + b.d)), min(getDistance(a.p + a.d, b.p), getDistance(a.p + a.d, b.p + b.d))); }\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tif (!(N | M | L)) { break; }\n\t\tvector<LineSeg> segs;\n\t\tREP(i, N)\n\t\t{\n\t\t\tREAD(int, x, y, a, r);\n\t\t\tREP(j, 5)\n\t\t\t{\n\t\t\t\tdouble ofst = (a + 90.0) / 180.0 * 3.14159265358979323846;\n\t\t\t\tdouble unit = 2 * (2.0 / 5.0) * 3.14159265358979323846;\n\t\t\t\tdouble s = unit * j + ofst, e = unit * (j + 1) + ofst;\n\t\t\t\t\n\t\t\t\tP2 c = P2(x, y), ps = P2(cos(s), sin(s)), pe = P2(cos(e), sin(e));\n\t\t\t\tsegs.push_back(LineSeg::From2Point(c + ps * r, c + pe * r));\n\t\t\t\t\n\t\t\t\t//WRITE(segs.back().p, segs.back().d);\n\t\t\t}\n\t\t}\n\n\t\tvevector<Path<double>> routes(N);\n\t\tREP(i, N) REP(j, N) if (i != j)\n\t\t{\n\t\t\tdouble minDistance = INF;\n\t\t\tREP(k, 5) REP(l, 5) minDistance = min(minDistance, getDistance(segs[i * 5 + k], segs[j * 5 + l]));\n\t\t\troutes[i].push_back({ i, j, minDistance });\n\t\t}\n\n\t\tdouble ans = dijkstra(routes, M - 1, L - 1).first[L - 1];\n\t\tprintf(\"%.20f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        m--;\n        l--;\n   \n        star S[100];\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf%lf%lf%lf\",&S[i].c.x,&S[i].c.y,&S[i].a,&S[i].r);\n        }\n   \n        for(int i = 0; i < n; i++){\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            for(int j = 0; j < 5; j++) S[i].p[j]=S[i].p[j]+S[i].c;\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n   \n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    segment<double> s(S[i].p[f1[a]],S[i].p[f1[a+1]]);\n                    segment<double> t(S[j].p[f1[b]],S[j].p[f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m][l]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,x,y) i=(x);i<(y);i++\n#define rep(i,n) for(int i=0,i##_len=n;i<i##_len;i++)\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Line> make_star(int x, int y, int a, int r){\n  int d = 5;\n  ld rad = 4 * pi / 5;\n  Point p(x, y);\n  Point v(0, r);\n  ld aa = a / 180.0 * pi;\n  v *= Point(cos(aa), sin(aa));\n  Point rot(cos(rad), sin(rad));\n  vector<Line> res;\n  rep(i, d){\n    res.emplace_back(v + p,v * rot + p);\n    v *= rot;\n  }\n  return res;\n}\n\ntemplate <typename Cost>\nstruct CEdge {\n  int from, to;\n  Cost cost;\n  CEdge(int s, int t, Cost c) : from(s), to(t), cost(c) {}\n};\n\ntemplate<typename Cost> using CGraph = vector<vector<CEdge<Cost>>>;\n\ntemplate <typename Cost>\nvoid add_edge(CGraph<Cost> &g, int from, int to, Cost cost) {\n  g[from].emplace_back(from, to, cost);\n}\n\nconst int inf = 1e9;\n\ntemplate <typename Cost>\nvector<Cost> dijkstra(const CGraph<Cost> &g, int s, Cost zero = 0) {\n  vector<Cost> d(g.size(), inf);\n  d[s] = zero;\n  using P = pair<Cost,int>;\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(zero, s));\n  while (!que.empty()) {\n    Cost dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    for (const auto &e: g[v]) {\n      if (d[e.to] <= d[v] + e.cost) continue;\n      d[e.to] = d[v] + e.cost;\n      que.push(P(d[e.to], e.to));\n    }\n  }\n  return d;\n}\n\nld dist_stars (vector<Line> s, vector<Line> t){\n  ld res = 1e30l;\n  for(auto&& ss: s){\n    for(auto&& tt: t){\n      res = min(res, dist_ss(ss, tt));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n, m, l;\n  while(cin >> n >> m >> l, n != 0){\n    vector<vector<Line>> stars(n);\n    rep(i, n){\n      int x, y, a, r; cin >> x >> y >> a >> r;\n      stars[i] = make_star(x, y, a, r);\n    }\n    CGraph<ld> g(n);\n    rep(i, n){\n      rep(j, n){\n        add_edge(g, i, j, dist_stars(stars[i], stars[j]));\n      }\n    }\n    cout << std::setprecision(24) << dijkstra(g, n - 1)[m - 1] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.14159265359\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点と点の距離\ndouble dis(P a, P b){\n    return sqrt((a.real() - b.real()) * (a.real() - b.real()) + (a.imag() - b.imag()) * (a.imag() - b.imag()));\n}\n\nvector<P> f(double x, double y, double a, double r){\n    \n    vector<P> ret(5);\n    P vec = P(0.0, r);\n    P add = P(x, y);\n    // a度 左に回転\n    P t = P(cos(a * PI / 180.0), sin(a * PI / 180.0));\n    vec = vec * t;\n    ret[0] = vec + add;\n    t = P(cos(72.0 * PI / 180.0), sin(72.0 * PI / 180.0));\n    for(int i = 1; i < 5; i++){\n        vec = vec * t;\n        ret[i] = vec + add;\n    }\n\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<P> > v(n, vector<P> (5));\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            v[i] = f(x, y, a, r);\n        }\n    \n\n        vector<vector<double> > g(n, vector<double> (n, INF));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < 5; k++) for(int l = 0; l < 5; l++){\n                    g[i][j] = min(g[i][j], dis(v[i][k], v[j][l]));\n                }\n            }\n        }\n\n       for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n\n        printf(\"%.10f\\n\", g[m - 1][n - 1]);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\nconst Double PI = 3.14159265358979;\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 2. * PI / 5.));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e7;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.15lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.1415926535897932384626433832795028841971\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvector<P> f(double x, double y, double a, double r){\n    \n    vector<P> ret(5);\n    P vec = P(0.0, r);\n    P add = P(x, y);\n    // a度 左に回転\n    P t = P(cos(a * PI / 180.0), sin(a * PI / 180.0));\n    vec = vec * t;\n    ret[0] = vec + add;\n    t = P(cos(72.0 * PI / 180.0), sin(72.0 * PI / 180.0));\n    for(int i = 1; i < 5; i++){\n        vec = vec * t;\n        ret[i] = vec + add;\n    }\n\n    return ret;\n}\n\ndouble dis(vector<P> a, vector<P> b){\n    double ret = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            if(is_intersected_ls(a[i], a[(i + 2) % 5], b[j], b[(j + 2) % 5])) ret = 0.0;\n            ret = min(ret, distance_ls_p(b[j], b[(j + 2) % 5], a[i]));\n            ret = min(ret, distance_ls_p(b[j], b[(j + 2) % 5], a[(i + 2) % 5]));\n            ret = min(ret, distance_ls_p(a[i], a[(i + 2) % 5], b[j]));\n            ret = min(ret, distance_ls_p(a[i], a[(i + 2) % 5], b[(j + 2) % 5]));\n\n        }\n    }\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<P> > v(n, vector<P> (5));\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            v[i] = f(x, y, a, r);\n        }\n    \n\n        vector<vector<double> > g(n, vector<double> (n, INF));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                g[i][j] = min(g[i][j], dis(v[i], v[j]));\n            }\n        }\n\n       for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n\n        printf(\"%.14f\\n\", g[m - 1][l - 1]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double INF = 1e8;\n\nstruct P{\n    double x, y;\n};\n\n//P is structure of coodinate.\nP rotationMatrix(P p, double angle){\n    double x, y;\n    x = p.x * cos(angle) - p.y * sin(angle);\n    y = p.x * sin(angle) + p.y * cos(angle);\n    p.x = x;\n    p.y = y;\n    return p;\n}\n\ndouble dist(P a, P b){\n    return sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));\n}\n\nclass Edge{\n    public:\n        double to, cost;\n        Edge(double to, double cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n    public:\n        double dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\ndouble dijkstra(AdjList g, int start, int goal, int n){\n    vector<Node> node(n);\n    priority_queue<double, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n    q.push(make_pair(0, start * 5));\n    node[start * 5].dis = 0;\n\n    pair<double, int> u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second;\n        node[current].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[next].isUsed == 0){\n                if(node[next].dis > node[current].dis + g[current][i].cost){\n                    node[next].dis = node[current].dis + g[current][i].cost;\n                    q.push(make_pair(node[next].dis, next));\n                }\n            }\n        }\n        //rep(i,node.size()){ show(node[i].dis) } cout << endl;\n    }\n    return node[goal * 5].dis;\n}\n\nint main(){\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        m--; l--;\n        vector<P> v;\n        rep(i,n){\n            double x, y, a, r;\n            cin >> x >> y >> a >> r;\n\n            P tmp = rotationMatrix(P{0,r}, 2 * M_PI / 360 * a);\n            rep(i,5){\n                v.emplace_back(P{tmp.x + x, tmp.y + y});\n                tmp = rotationMatrix(tmp, 2 * M_PI / 5);\n            }\n        }\n        //rep(i,v.size()){ cout << v[i].x << ' ' << v[i].y << endl; }\n\n        AdjList g(v.size());\n        rep(i,v.size()){\n            rep(j,v.size()){\n                if(i / 5 == j / 5){\n                    g[i].emplace_back(j,0);\n                    //g[j].emplace_back(i,0);\n                }else{\n                   // cout << v[i].x << ' ' << v[i].y << endl;\n                   // cout << v[j].x << ' ' << v[j].y << endl;\n                   // show(dist(v[i],v[j]))\n                    g[i].emplace_back(j,dist(v[i], v[j]));\n                    //g[j].emplace_back(i,dist(v[j], v[i]));\n                }\n            }\n        }\n        cout <<fixed << setprecision(8)<< dijkstra(g,m,l,v.size()) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20Lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n#define INF 10000000\n#define pb push_back\nusing namespace std;\ntypedef complex<double> Point;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real(conj(a)*b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a)*b);\n}\ndouble dlp(Point a, Point b, Point c) {\n  if(dot(b-a,c-a)<=0)return abs(c-a);\n  if(dot(a-b,c-b)<=0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\nint iil(Point a1,Point a2,Point b1,Point b2){\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<=0)&&(cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<=0);\n}\ndouble dll(Point a1,Point a2,Point a3,Point a4){\n    if(iil(a1,a2,a3,a4))\n        return 0.0;\n\treturn min(min(dlp(a1,a2,a3),dlp(a1,a2,a4)),min(dlp(a3,a4,a1),dlp(a3,a4,a2)));\n}\ndouble cal(int a,int b){\n    double ret=INF;\n    for(int i=0;i<5;i++)\n        for(int j=2;j<4&&i+j<5;j++)\n            for(int k=0;k<5;k++)\n                for(int l=2;l<4&&k+l<5;l++)\n                \tret=min(dll(p[a][i],p[a][i+j],p[b][k],p[b][k+l]),ret);\n    return ret;\n}\nint main(){\n    while(cin>>n>>s>>g,n||s||g){\n    \tp=vector<vector<Point> >(n,vector<Point>(5));\n        for(int i=0;i<n;i++){\n            double x,y,a,r;\n            cin>>x>>y>>a>>r;\n            for(int j=0;j<5;j++){\n            \tp[i][j]=Point(x,y)+polar(r,(a+72.0*j+90)*PI/180.0);\n            }\n        }\n        vector<vector<double> > cost(n,vector<double>(n,INF));\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n            \tif(i==j){\n            \t\tcost[i][j]=0;\n            \t\tcontinue;\n            \t}\n                cost[i][j]=cost[j][i]=cal(i,j);\n            }\n        }\n    \tfor(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tcost[i][j]=min(cost[i][k]+cost[k][j],cost[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprintf(\"%.8lf\\n\",cost[s-1][g-1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n//for vector\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline D seg_seg_dis(L a,L b){\n  D res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nD g[111][111],d[111];\nL starl[111][5];\nP starv[111][5],c,p;\nint n,m,l,x,y,a,r;\nbool use[111];\n\nint main(){\n  while(scanf(\"%d%d%d\",&n,&m,&l), n){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      c = P(x,y), p = P(0,r);\n      for(int j=0;j<5;j++)starv[i][j] = c+rotate(p,PI*(a+j*72)/180);\n      for(int j=0;j<5;j++)starl[i][j] = L(starv[i][j],starv[i][(j+2)%5]);\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : starl[i]){\n\t  for(L b : starl[j]){\n\t    if(is_cp(a,b))dis = 0;\n\t  }\n\t}\n\tif(dis>EPS){\n\t  for(P a : starv[i]){\n\t    for(L b : starl[j])dis = min(dis, seg_p_dis(b,a));\n\t  }\n\t  for(P a : starv[j]){\n\t    for(L b : starl[i])dis = min(dis, seg_p_dis(b,a));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n      g[i][i] = 0;\n    }\n\n    for(int i=0;i<n;i++)d[i] = 1e9;\n    d[m-1] = 0;\n    memset(use,0,sizeof(use));\n\n    for(;;){\n      int v = -1;\n      for(int u=0;u<n;u++){\n\tif(!use[u] && (v<0 || d[v] > d[u]))v = u;\n      }\n\n      if(v<0 || v==l-1)break;\n      use[v] = 1;\n\n      for(int u=0;u<n;u++){\n\td[u] = min(d[u],d[v]+g[u][v]);\n      }\n    }\n\n    printf(\"%.9lf\\n\",d[l-1]);\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst double EPS = 1e-10;\nconst double PI = 3.141592653589793;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point { // ???\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\t// bool operator < (const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator < (const Point &p) const { // ??????????¨±???????????????\n\t\treturn x + EPS < p.x || (eq<double>(x, p.x) && y + EPS < p.y);\n\t}\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>; // ????§???¢\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\ndouble length(const Point& a) { return a.abs(); } // ???????????????\nPoint rotationalTransfer(Point c, double r, double deg) { // c???????????¨????????????r????????¨??????deg??????????????§?¨?\n\tdouble rad = PI * deg / 180.0; return c + Point(cos(rad), sin(rad)) * r;\n}\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment { //??????\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { // ?????????????????????true\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//*** ??????????????? ***\nPoint getCrossPoint(Segment s1, Segment s2) { // ???????????????????????¨??????????????????????????????????????¨\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1)), d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t  = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2) { // ??????s1??¨??????s2?????????\n\tif( intersect(s1, s2) ) return 0.0; //????????£???????????¨???\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\nconst int MAX_N = 210;\nusing TYPE = double; // ?????¢???????????\\??????\nvector<pair<int, TYPE> > G[MAX_N];\nvector<TYPE> dijkstra(int start){\n\tvector<TYPE> dist(MAX_N, INFF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<TYPE, int>, vector<pair<TYPE, int> >, greater<pair<TYPE, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tTYPE cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; TYPE time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\n\nint main(void){\n\t\n\twhile(1) {\n\n\t\tint N, M, L; scanf(\"%d %d %d\", &N, &M, &L);\n\t\tif(N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\tvector<vector<Segment>> star;\n\t\t\n\t\trep(i, N){\n\t\t\tdouble x, y, a, r; scanf(\"%lf %lf %lf %lf\", &x, &y, &a, &r);\n\t\t\tPoint c(x, y);\n\t\t\tvector<Point> v;\n\n\t\t\trep(j, 5) {\n\t\t\t\t// double rad = (90 + a + j * 72) * PI / 180.0;\n\t\t\t\t// v.pb(Point(x, y) + Point(cos(rad), sin(rad)) * r);\n\t\t\t\tv.pb(rotationalTransfer(c, r, 90 + a + j * 72.));\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tvector<Segment> seg;\n\t\t\t// ??????5????????????\n\t\t\trep(j, 5) seg.pb(Segment(v[j % 5], v[(j + 2) % 5]));\n\t\t\tstar.pb(seg);\n\t\t}\n\t\t\n\t\trep(i, MAX_N) G[i].clear();\n\n\t\trep(i, star.size())rep(j, star.size()){\n\t\t\tif(i == j) continue;\n\t\t\tdouble mi = INF;\n\t\t\tfor(auto u : star[i])for(auto v : star[j]){\n\t\t\t\tchmin(mi, getDistanceSS(u, v));\n\t\t\t}\n\t\t\t// printf(\"mi %f\\n\", mi);\n\t\t\tG[i].pb(mp(j, mi)), G[j].pb(mp(i, mi));\n\t\t}\n\n\t\tauto ret = dijkstra(M);\n\t\tprintf(\"%.9f\\n\", ret[L]);\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n#include <immintrin.h>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//テ・ツ??」ツ?ョテヲツ篠・テァツキツ?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//テゥツ敖「テァツゥツ??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n// Suffix Array\tテ・ツ按敕ヲツ慊淌・ツ個飽(|S|log^2|S|), テヲツ、ツ愿ァツエツ「O(|T|log|S|), テゥツォツ佚」ツ?陛ゥツ?催・ツ按療ヲツァツ凝ァツッツ碓(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble way[100][100];\nint main() {\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tm--, l--;\n\t\tfill(way[0], way[100], 1e9);\n\t\trep(i, n)way[i][i] = 0;\n\t\tva<int, 4> s(n);\n\t\trep(i, n)rep(j, 4)cin >> s[i][j];\n\t\trep(i, n)rep(j, i) {\n\t\t\tvector<P> si(5), sj(5);\n\t\t\tP r(0, s[i][3]);\n\t\t\tr *= P(cos(pi / 180 * s[i][2]), sin(pi / 180 * s[i][2]));\n\t\t\tP ro(cos(2 * pi / 5), sin(2 * pi / 5));\n\t\t\trep(k, 5)si[k] = P(s[i][0], s[i][1]) + r, r *= ro;\n\t\t\tr = P(0, s[j][3]);\n\t\t\tr *= P(cos(pi / 180 * s[j][2]), sin(pi / 180 * s[j][2]));\n\t\t\trep(k, 5)sj[k] = P(s[j][0], s[j][1]) + r, r *= ro;\n\t\t\trep(k, 5)rep(l, 5)cmin(way[i][j], dist_ss(L{ si[k],si[(k + 2 > 4 ? k + 2 - 5 : k + 2)] }, L{ sj[l], sj[(l + 2 > 4 ? l + 2 - 5 : l + 2)] }));\n\t\t\tway[j][i] = way[i][j];\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n)cmin(way[i][j], way[i][k] + way[k][j]);\n\t\tcout << fixed << setprecision(10) << way[m][l] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double INF = 1e8;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//????§???¢??????????±???¨??????????????§?¨?\nPoint pointSymmetry(Polygon g){\n    int size = g.size() / 2;\n    if(g.size() % 2) return Point{INF,INF};\n\n    set<Point> s;\n    rep(i,size){\n        rep(j,size){\n            if(i == j) continue;\n            s.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n        }\n    }\n    if(s.size() > 1) return Point{INF,INF};\n    return *s.begin();\n}\n\nclass Edge{\n    public:\n        double to, cost;\n        Edge(double to, double cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n    public:\n        double dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\ndouble dijkstra(AdjList g, int start, int goal, int n){\n    vector<Node> node(n);\n    priority_queue<double, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n    q.push(make_pair(0, start));\n    node[start].dis = 0;\n\n    pair<double, int> u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second;\n        node[current].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[next].isUsed == 0){\n                if(node[next].dis > node[current].dis + g[current][i].cost){\n                    node[next].dis = node[current].dis + g[current][i].cost;\n                    q.push(make_pair(node[next].dis, next));\n                }\n            }\n        }\n        //rep(i,node.size()){ show(node[i].dis) } cout << endl;\n    }\n\n    return node[goal].dis;\n}\n\ndouble distance(vector<Segment> a, vector<Segment> b){\n    double mini = INF;\n    rep(i,5){\n        rep(j,5){\n            mini = min(mini,distanceLL(a[i], b[j]));\n        }\n    }\n    return mini;\n}\n\nint main(){\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        m--; l--;\n        vector<Segment> star[105];\n        rep(i,n){\n            vector<Point> v;\n            double x, y, a, r;\n            cin >> x >> y >> a >> r;\n\n            Point tmp = rotation(Point(0,r), 2 * M_PI / 360 * a);\n            rep(j,5){\n                v.emplace_back(Point(tmp.real() + x, tmp.imag() + y));\n                tmp = rotation(tmp, 2 * M_PI / 5);\n            }\n            rep(j,5){\n                star[i].emplace_back(Segment{v[j], v[(j + 2) % 5]});\n            }\n        }\n        //rep(i,v.size()){ cout << v[i].x << ' ' << v[i].y << endl; }\n\n        AdjList g(n);\n        rep(i,n){\n            rep(j,n){\n                if(i == j) continue;\n                double dis = distance(star[i], star[j]);\n                g[i].emplace_back(j,dis);\n            }\n        }\n        cout <<fixed << setprecision(8)<< dijkstra(g,m,l,n) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n\n#define ARG5(a, b, c, d, NAME, ...) NAME\n#define REP(...) ARG5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define REP1(a) REP2(i, a)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) ARG5(__VA_ARGS__, REPR4, REPR3, REPR2, REPR1)(__VA_ARGS__)\n#define REPR1(a) REPR2(i, a)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')\n#define TMPL_T template <typename T>\n#define TMPL_TU template <typename T, typename U>\n#define mut auto\n#define let const auto\n\nusing Int = long long;\n// clang-format off\nnamespace extio {\nstd::string delimiter=\" \",pdelimiter=\" \";\nstd::string bracket_b=\"\",bracket_e=\"\";\nvoid chdelim(const std::string&s){delimiter=s;}\nvoid chpdelim(const std::string&s){pdelimiter=s;}\nvoid chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}\nTMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}\nTMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}\n}\nnamespace std {\nTMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}\nTMPL_T istream& operator>>(istream&is,tuple<int&,vector<T>&>x)\n{int N=get<0>(x);vector<T>&v=get<1>(x);v.clear();v.reserve(N);REP(i,N){T a;is>>a;v.emplace_back(a);}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<vector<T>&,int&>x){return is>>tie(get<1>(x),get<0>(x));}\nTMPL_T istream& operator>>(istream&is,tuple<int&,T*>x){int N=get<0>(x);T*v=get<1>(x);REP(i,N){is>>v[i];}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<T*,int&>x){return is>>tie(get<1>(x),get<0>(x));}\n}\nTMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\nTMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\n\ninline int in(){int x;std::cin>>x;return x;}\n\n// clang-format on\n// }}}\n//{{{ orliv::graph::Graph\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <limits>\n#include <vector>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  using weight_type = long double;\n  static constexpr weight_type INF = std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\nusing Weight = Edge::weight_type;\nusing Edges = std::vector<Edge>;\nusing Weights = std::vector<Weight>;\nusing Path = std::vector<int>;\nusing Nodes = std::vector<int>;\n}\nusing Graph = std::vector<graph::Edges>;\n}\n#endif\n//}}}\n//{{{ dijkstra.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n#include <algorithm>\n#include <limits>\n#include <queue>\nnamespace orliv {\nnamespace graph {\nnamespace shortest_path {\nnamespace util {\nPath buildPath(int t, std::vector<int>& prev) {\n  Path path;\n  for (int u = t; u >= 0; u = prev[u]) {\n    path.emplace_back(u);\n  }\n  std::reverse(path.begin(), path.end());\n  return std::move(path);\n}\n}\nWeights dijkstra(const Graph& g, int s, std::vector<int>& prev) {\n  const int V = g.size();\n  auto inf = Edge::INF;\n  Weights dist(V, inf);\n  prev.assign(V, -1);\n\n  dist[s] = 0;\n  std::priority_queue<Edge> pq;\n  for (pq.emplace(-2, s, 0); !pq.empty();) {\n    auto e = pq.top();\n    pq.pop();\n    if (prev[e.to] != -1) continue;\n    prev[e.to] = e.from;\n    for (const auto& f : g[e.to]) {\n      if (dist[f.to] <= e.w + f.w) continue;\n      pq.emplace(f.from, f.to, dist[f.to] = e.w + f.w);\n    }\n  }\n  return std::move(dist);\n}\nWeights dijkstra(const Graph& g, int s) {\n  std::vector<int> prev;\n  return std::move(dijkstra(g, s, prev));\n}\nstd::pair<Weight, Path> dijkstra(const Graph& g, int s, int t) {\n  std::vector<int> prev;\n  auto ws = dijkstra(g, s, prev);\n  auto path = util::buildPath(t, prev);\n  return std::move(std::make_pair(ws[t], std::move(path)));\n}\n}\n}\n}\n//}}}\n\nusing namespace std;\n\nusing Real = double;\nusing P = std::complex<Real>;\n\nconst Real EPS = 1e-8;\nReal cross(const P& a, const P& b) {\n  return imag(conj(a) * b);\n}\nReal dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return +1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c) < 0) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool intersect(const P& a, const P& b, const P& c, const P& d) {\n  return ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0;\n}\n\nstruct Star {\n  std::vector<P> ps;\n  Star(Real x, Real y, Real a, Real r) {\n    P base(x, y);\n    P p = std::polar(r, (a + 90) / 180.0 * M_PI);\n    P rot = std::polar(1.0, 0.4 * M_PI);\n    REP(5) {\n      ps.emplace_back(p + base);\n      p *= rot;\n    }\n  }\n  Real dist(const Star& other) const {\n    Real d = 1e9;\n    REP(i, 5) REP(j, 5) {\n      int ni = (i + 2) % 5;\n      int nj = (j + 2) % 5;\n      if (intersect(ps[i], ps[ni], other.ps[j], other.ps[nj])) { return 0; }\n      chmin(d, abs(ps[i] - other.ps[j]));\n    }\n    return d;\n  }\n};\n\nsigned main() {\n  int N, M, L;\n  while (N = in(), M = in(), L = in(), N || M || L) {\n    orliv::Graph g(N);\n    vector<Star> stars;\n    REP(i, N) {\n      Real x = in(), y = in(), a = in(), r = in();\n      stars.emplace_back(x, y, a, r);\n    }\n    REP(i, N) REP(j, N) {\n      if (i == j) continue;\n      auto d = stars[i].dist(stars[j]);\n      g[i].emplace_back(i, j, d);\n    }\n    printf(\"%.20Lf\\n\", orliv::graph::shortest_path::dijkstra(g, M - 1, L - 1).first);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include<functional>\n#include<stack>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\n#define ALL(x) (x).begin(),(x).end()\n\n#pragma region Gomi\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back({from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back({ from, to });\n\t\t\tg[to].push_back({ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\n#pragma endregion\n\n#define INF 1000000\nint n=101;\nld dist[101][101];\nld cost[101];\nchar used[101];\n\n\nint main() {\n\twhile (true) {\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0) { break; }\n\t\tREP(i, 101) {\n\t\t\tREP(j, 101) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdist[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<Line>> lines(N,vector<Line>(5,Line(Point(0,0), Point(0, 0))));\n\t\tREP(i, N) {\n\t\t\tld x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<Point> points(5,Point(0,0));\n\t\t\tREP(gomi, 5) {\n\t\t\t\tpoints[gomi]=Point(x + r*cos((a + 18+144*gomi)/180*pi), y + r*sin((a + 18 + 144 * gomi)) / 180 * pi);\n\t\t\t}\n\t\t\tREP(gomi, 5) {\n\t\t\t\tlines[i][gomi] = Line(points[gomi%5], points[(gomi+1) % 5]);\n\t\t\t}\n\t\t}\n\t\tREP(i, N-1) {\n\t\t\tFOR(j,i+1, N) {\n\n\t\t\t\tld min = 1000 * 1000;\n\t\t\t\tREP(k, 5) {\n\t\t\t\t\tREP(l, 5) {\n\t\t\t\t\t\tld hoge=dist_ss(lines[i][k], lines[j][l]);\n\t\t\t\t\t\tif (hoge < min) { min = hoge; }\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[i][j] = min;\n\t\t\t\tdist[j][i] = min;\n\t\t\t\tcout << min << endl;\n\t\t\t}\n\t\t}\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\tif (dist[i][j] > dist[i][k] + dist[k][j]) {\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[M-1][N-1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef pair<double,double> pdd;\n\nconst double pi = atan(1.0) * 4.0;\nconst double EPS = 1e-8;\n\ndouble cross(pdd x, pdd y) {\n\treturn x.first*y.second - x.second*y.first;\n}\n\ndouble dist(pdd x, pdd y) {\n\treturn sqrt((x.first-y.first)*(x.first-y.first) + (x.second-y.second)*(x.second-y.second));\n}\n\nint main() {\n\tint N, M, L;\n\twhile(scanf(\"%d %d %d\", &N, &M, &L), N) {\n\t\tvector< vector<pdd> > star(N);\n\t\trep(i, N) {\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r);\n\t\t\trep(j, 5) {\n\t\t\t\tdouble ang = (72.0 * j + a) * pi / 180.0;\n\t\t\t\tpdd p(x-r*sin(ang), y+r*cos(ang));\n\t\t\t\tstar[i].push_back(p);\n\t\t\t}\n\t\t}\n\t\tdouble cost[100][100];\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = 1e9;\n\t\t\t\tif(i==j) cost[i][j] = 0.0;\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd v1 = pdd(star[i][ii].first - star[i][(ii+2)%5].first, star[i][ii].second - star[i][(ii+2)%5].second);\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tpdd v2 = pdd(star[j][jj].first - star[j][(jj+2)%5].first, star[j][jj].second - star[j][(jj+2)%5].second);\n\t\t\t\t\t\tpdd u1 = pdd(star[i][ii].first - star[j][(jj+2)%5].first, star[i][ii].second - star[j][(jj+2)%5].second);\n\t\t\t\t\t\tpdd u2 = pdd(star[j][jj].first - star[i][(ii+2)%5].first, star[j][jj].second - star[i][(ii+2)%5].second);\n\t\t\t\t\t\tpdd w1 = pdd(star[i][ii].first - star[j][jj].first, star[i][ii].second - star[j][jj].second);\n\t\t\t\t\t\tpdd w2 = pdd(-w1.first, -w1.second);\n\t\t\t\t\t\tif( cross(v1,u1)*cross(v1,w1)<-EPS && cross(v2,u2)*cross(v2,w2)<-EPS ) {\n\t\t\t\t\t\t\tcost[i][j] = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd s = star[i][ii];\n\t\t\t\t\tpdd t = star[i][(ii+2)%5];\n\t\t\t\t\tdouble alp = 0.0f;\n\t\t\t\t\tif( abs(t.first-s.first) < EPS ) {\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], abs(t.first - star[j][jj].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\talp = (t.second-s.second)/(t.first-s.first);\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tpdd p = star[j][jj];\n\t\t\t\t\t\t\tdouble qx = (p.first+alp*p.second-alp*s.second+alp*alp*s.first) / (alp*alp+1.0);\n\t\t\t\t\t\t\tdouble qy = alp*(qx-s.first) + s.second;\n\t\t\t\t\t\t\tpdd q = pdd(qx,qy);\n\t\t\t\t\t\t\tif( dist(q,s)<dist(t,s) && dist(q,t)<dist(t,s) ) {\n\t\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(p,q));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(star[i][ii], star[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = cost[j][i] = min(cost[i][j], cost[j][i]);\n\t\t\t}\n\t\t}\n\t\trep(k, N) {\n\t\t\trep(i, N) {\n\t\t\t\trep(j, N) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", min(cost[M-1][L-1],cost[L-1][M-1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tP pt[100][5];\n        for (int i = 0; i < n; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n   \n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    segment<double> s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    segment<double> t(pt[j][f1[a]],pt[j][f1[a+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define  range(i, l, r) for (int i = (int)(l); i < (int)(r); (i) += 1)\n#define rrange(i, l, r) for (int i = (int)(r) - 1; i >= (int)(l); (i) -= 1)\n\n#define  whole(f, x, ...) ([&](decltype((x)) container) { return (f)(  begin(container),  end(container), ## __VA_ARGS__); })(x)\n#define rwhole(f, x, ...) ([&](decltype((x)) container) { return (f)( rbegin(container), rend(container), ## __VA_ARGS__); })(x)\n\n#define debug(x) cerr << \"(\" << __LINE__ << \")\" << #x << \": \" << (x) << endl\n\nusing i32 = int;\nusing u32 = unsigned int;\nusing i64 = long long;\nusing u64 = unsigned long long;\n\n// constexpr i32 mod   = 998244353;\nconstexpr i32 mod   = 1e9 + 7;\nconstexpr i32 inf   = 1001001001;\nconstexpr i64 infll = 1001001001001001001ll;\n\nconstexpr int dx[] = {0, -1, 1, 0, -1, 1, -1, 1};\nconstexpr int dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\nstruct IoSetup { IoSetup(int x = 15){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(x); cerr << fixed << setprecision(x); } } iosetup;\n\ntemplate <typename T = i64> T input() { T x; cin >> x; return x; }\n\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { range(i, 0, v.size()) { os << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\n\ntemplate <typename T> vector<T> make_vector(size_t a, T b) { return vector<T>(a, b); }\ntemplate <typename... Ts> auto make_vector(size_t a, Ts... ts) { return vector<decltype(make_vector(ts...))>(a, make_vector(ts...)); }\n\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// }}}\n\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  return os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\n\nusing Points = vector< Point >;\nusing Segments = vector< Segment >;\n\nvoid solver(int n, int m, int l) {\n    vector< Points > pts;\n    vector< Segments > segs;\n    range(i, 0, n) {\n        double x, y, a, r;\n        cin >> x >> y >> a >> r;\n\n        Points pt;\n        Point v(0, r);\n        range(j, 0, 5) {\n            pt.push_back(v);\n            v = rotate(2 * PI * (2.0 / 5.0), v);\n        }\n\n        for (auto &p: pt) {\n            p = rotate(degree_to_radian(a), p);\n            p += Point(x, y);\n        }\n        \n        Segments seg;\n        range(j, 0, 5) {\n            int ni = (j + 1) % 5;\n            seg.push_back(Segment(pt[j], pt[ni]));\n        }\n\n        segs.push_back(seg);\n    }\n\n    auto G = make_vector(n, n, double(inf));\n    range(i, 0, n) range(j, 0, n) {\n        for (const auto &s1: segs[i]) {\n            for (const auto &s2 : segs[j]) {\n                chmin(G[i][j], distance(s1, s2));\n            }\n        }\n    }\n\n    range(k, 0, n) range(i, 0, n) range(j, 0, n) {\n        chmin(G[i][j], G[i][k] + G[k][j]);\n    }\n\n    cout << G[m][l] << endl;\n}\n\nsigned main(int argc, char *argv[]) {\n    int n, m, l;\n    while (cin >> n >> m >> l, n) {\n        solver(n, m - 1, l - 1);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nnamespace Geometry{\n#define F first\n#define S second\n  typedef long double D;\n  typedef complex<long double> P;\n  typedef pair<P,D> C;\n    \n  const D EPS=1e-9;\n  const D PI=asin(1)*2;\n  const D INF=1e18;\n    \n  static bool comp(const P &p1,const P &p2){\n    if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n    return p1.real()<p2.real();\n  }\n    \n  static bool comp_y(const P &p1,const P &p2){\n    if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n    return p1.imag()<p2.imag();\n  }\n    \n  static bool eqls(const P &p1,const P &p2){return abs(p1-p2)<EPS;}\n    \n  D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n  D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n  P project(P vec,P x){return vec*(x/vec).real();}\n    \n  P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n  P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n  P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n  bool intersectSL(P p1,P p2,P vec){\n    vec/=abs(vec); p1/=vec; p2/=vec;\n    return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n  }\n    \n  bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n  bool intersectSS(P p1,P p2,P p3,P p4){\n    if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n    if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n    return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n  }\n    \n  D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n  D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n  D distSP(P p1,P p2,P x){\n    if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n    if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n    return distLP(p1,p2,x);\n  }\n    \n  D distSS(P p1,P p2,P p3,P p4){\n    if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n    return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n                distSP(p3,p4,p1),distSP(p3,p4,p2)});\n  }\n    \n  P crosspointLL(P p1,P p2,P vec){\n    if(abs(cross(p2-p1,vec))<EPS){return vec;}\n    return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n  }\n    \n  P crosspointLL(P p1,P p2,P p3,P p4){\n    return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n  }\n    \n  P crosspointSS(P p1,P p2,P p3,P p4){\n    if(distSP(p1,p2,p3)<EPS){return p3;}\n    if(distSP(p1,p2,p4)<EPS){return p4;}\n    return crosspointLL(p1,p2,p3,p4);\n  }\n    \n  bool intersectShL(P p1,P p2,P vec){\n    vec/=abs(vec);\n    return intersectSL(p1,p2,vec) &&\n      crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n  }\n    \n  bool intersectShL(P p1,P p2,P p3,P p4){\n    return intersectShL(p1-p3,p2-p3,p4-p3);\n  }\n    \n  //1::in,0::on edge,-1::out\n  int contain(const vector<P> &poly,const P &p){\n    vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n    int s=A.size();\n    vector<bool> cnt(s,false);\n    for(int i=0;i<(int)poly.size();i++){\n      int k=(i+1)%poly.size();\n      if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n      for(int j=0;j<s;j++){\n        if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n      }\n    }\n    int in=0;\n    for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n    return in>s/2?1:-1;\n  }\n    \n  vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n    vector<P> ret;\n    for(int i=0;i<(int)poly.size();i++){\n      int j=(i+1)%poly.size();\n      if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n      if(intersectSL(poly[i],poly[j],p1,p2) &&\n         distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n        ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly){\n    D ans=0;\n    for(int i=2;i<(int)poly.size();i++){\n      ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n    }\n    return abs(ans)/2;\n  }\n    \n  vector<P> convexhull(vector<P> pts){\n    vector<P> ret;\n    sort(pts.begin(),pts.end(),comp);\n    auto fnc=[&](){\n               for(auto &I:pts){\n                 if(!ret.empty() && abs(I-ret.back())<EPS){continue;}\n                 while(ret.size()>1){\n                   P A=ret.back()-ret[ret.size()-2];\n                   P B=I-ret.back();\n                   if(cross(A,B)<-EPS){ret.pop_back();}\n                   else if(abs(cross(A,B))<EPS && dot(A,B)>EPS){ret.pop_back();}\n                   else{break;}\n                 }\n                 ret.push_back(I);\n               }\n             };\n    fnc();\n    reverse(pts.begin(),pts.end());\n    fnc();\n    if(ret.size()>1 && ret[0]==ret.back()){ret.pop_back();}\n    return ret;\n  }\n    \n  //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n  int intersectCC(C c1,C c2){\n    D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n    if(d<EPS && dif<EPS){return -1;}\n    if(d-r>EPS){return 4;}\n    if(d-r>-EPS){return 3;}\n    if(d-dif>EPS){return 2;}\n    if(d-dif>-EPS){return 1;}\n    return 0;\n  }\n    \n  vector<P> crosspointLC(P p1,P p2,C c){\n    vector<P> ret;\n    P pr=project(p1,p2,c.F);\n    D d=distLP(p1,p2,c.F);\n    if(d-c.S>EPS){return ret;}\n    if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n    P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n    ret.push_back(pr-vec);\n    ret.push_back(pr+vec);\n    return ret;\n  }\n    \n  vector<P> crosspointSC(P p1,P p2,C c){\n    vector<P> ret;\n    for(auto &I:crosspointLC(p1,p2,c)){\n      if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n    }\n    return ret;\n  }\n    \n  vector<P> crosspointCC(C c1,C c2){\n    vector<P> ret;\n    P vec=c2.F-c1.F;\n    D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n    D h=sqrt(c1.S*c1.S-base*base);\n    vec/=abs(vec);\n    ret.push_back(c1.F+vec*P(base,-h));\n    ret.push_back(c1.F+vec*P(base,h));\n    return ret;\n  }\n    \n  vector<P> tangentCP(C c,P p){\n    return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n  }\n    \n  vector<pair<P,P>> tangentCC(C c1,C c2){\n    vector<pair<P,P>> ret;\n    P d=c2.F-c1.F;\n    for(D i:{-1,1}){\n      D r=c1.S+c2.S*i;\n      if(intersectCC(c1,c2)>i+1){\n        for(P s:{-1i,1i}){\n          P p=r+s*sqrt(norm(d)-norm(r));\n          ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n        }\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly,C c){\n    D ret=0;\n    for(int i=0;i<(int)poly.size();i++){\n      P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n      if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n      else{\n        vector<P> A=crosspointSC(a,b,{0,c.S});\n        if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n        else{\n          ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n          ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n          ret+=cross(A[0],A.back());\n        }\n      }\n    }\n    return abs(ret)/2;\n  }\n    \n  //反時計回り\n  D diameter(const vector<P> &poly){\n    D ret=0;\n    ll l=0,r=0,n=poly.size();\n    if(n==2){return abs(poly[0]-poly[1]);}\n    for(int i=0;i<n;i++){\n      if(comp(poly[l],poly[i])){l=i;}\n      if(comp(poly[i],poly[r])){r=i;}\n    }\n    ll sl=r,sr=l;\n    while(sl!=l || sr!=r){\n      ret=max(ret,abs(poly[r]-poly[l]));\n      if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n      else{(++r)%=n;}\n    }\n    return ret;\n  }\n    \n  D closestpair(vector<P> pt){\n    sort(pt.begin(),pt.end(),comp);\n    D ret=INF;\n    int N=pt.size();\n    for(int i=1;i<N;i<<=1){\n      for(int j=0;i+j<N;j+=i*2){\n        int m=i+j;\n        vector<P> R;\n        D l=-INF,r=INF;\n        for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n        for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n        for(int k=0;m+k<N && k<i;k++){\n          if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n        }\n        int idx=0;\n        for(int k=j;k<m;k++){\n          if(r-pt[k].real()>ret){continue;}\n          int M=R.size();\n          while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n          for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n            ret=min(ret,abs(R[s]-pt[k]));\n          }\n        }\n        auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n        inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n      }\n    }\n    return ret;\n  }\n    \n  P centerofgravity(const vector<P> &pt){\n    P ret(0,0);\n    D wt=0;\n    for(int i=2;i<(int)pt.size();i++){\n      D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n      P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n      wt+=w2;\n      ret+=p*w2;\n    }\n    return ret/wt;\n  }\n    \n  void segment_arrangement(const vector<pair<P,P>> &L,vector<pair<int,int>> &seg,vector<P> &pt){\n    int N=L.size();\n    for(int i=0;i<N;i++){\n      pt.push_back(L[i].F);\n      pt.push_back(L[i].S);\n      for(int j=i+1;j<N;j++){\n        if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n          pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n        }\n      }\n    }\n    auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n    sort(pt.begin(),pt.end(),le);\n    pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n    for(auto &I:L){\n      vector<pair<D,int>> on;\n      for(int j=0;j<(int)pt.size();j++){\n        if(distSP(I.F,I.S,pt[j])<EPS){\n          on.emplace_back(abs(pt[j]-I.F),j);\n        }\n      }\n      sort(on.begin(),on.end());\n      for(int j=1;j<(int)on.size();j++){\n        seg.emplace_back(on[j-1].S,on[j].S);\n      }\n    }\n    sort(seg.begin(),seg.end());\n    seg.erase(unique(seg.begin(),seg.end()),seg.end());\n  }\n    \n  vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n    vector<pair<int,int>> seg;\n    vector<P> pt;\n    segment_arrangement(L,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n      edge[I.F].push_back(I.S);\n      edge[I.S].push_back(I.F);\n    }\n    vector<P> ret;\n    function<void(int,int)> dfs=[&](int v,int pre){\n                                  if(pre!=-1 && v==0){return;}\n                                  ret.push_back(pt[v]);\n                                  vector<pair<D,int>> nx;\n                                  for(auto &u:edge[v]){\n                                    D a=arg((pt[u]-pt[v])/(pre==-1 || eqls(pt[v],pt[pre])?P(1):pt[v]-pt[pre]));\n                                    if(abs(a+PI)<EPS){a=PI;}\n                                    nx.emplace_back(a,u);\n                                  }\n                                  sort(nx.begin(),nx.end());\n                                  dfs(nx[0].S,v);\n                                };\n    dfs(0,-1);\n    return ret;\n  }\n    \n  istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n  istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n  void Input(P &p){D x,y;cin>>x>>y;p={x,y};}\n};\n\nusing namespace Geometry;\n\nconst int sz=5;\nvector<P> star(sz+1);\n\nvoid make_star(){\n  P p(0,1);\n  P K(cos(2*PI/5*2),sin(2*PI/5*2));\n  P k(1,0);\n  for(int i=0;i<sz+1;i++){star[i]=k*p; k*=K;}\n}\n\nbool solve(){\n  ll N,M,L;\n  cin>>N>>M>>L;\n  if(N==0){return false;}\n  M--; L--;\n  vector<pair<P,pair<P,D>>> A(N);\n  for(auto &I:A){\n    D a;\n    Input(I.F);\n    cin>>a>>I.S.S;\n    I.S.F=P(cos(a*PI/180),sin(a*PI/180));\n  }\n  vector<vector<D>> dist(N,vector<D>(N,INF));\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      for(int k=0;k<sz;k++){\n        for(int l=0;l<sz;l++){\n          P s1=A[i].F+star[k]*A[i].S.F*A[i].S.S;\n          P t1=A[i].F+star[k+1]*A[i].S.F*A[i].S.S;\n          P s2=A[j].F+star[l]*A[j].S.F*A[j].S.S;\n          P t2=A[j].F+star[l+1]*A[j].S.F*A[j].S.S;\n          if(abs(s1-t1)<EPS){\n            if(abs(s2-t2)<EPS){dist[i][j]=min(dist[i][j],abs(s1-s2));}\n            else{dist[i][j]=min(dist[i][j],distSP(s2,t2,s1));}\n          }\n          else{\n            if(abs(s2-t2)<EPS){dist[i][j]=min(dist[i][j],distSP(s1,t1,s2));}\n            else{dist[i][j]=min(dist[i][j],distSS(s1,t1,s2,t2));}\n          }\n        }\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      for(int k=0;k<N;k++){\n        dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n      }\n    }\n  }\n  cout<<dist[M][L]<<endl;\n  return true;\n}\n\nint main(){\n  cout<<fixed<<setprecision(12);\n  make_star();\n  while(solve());\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\nusing ll = long long;\n\n#define INF 1e9\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n#define X real()\n#define Y imag()\nusing star = vector<Point>;\n\n\ndouble dot(Point a, Point b){\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b){\n    return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return +1;\n    if(cross(b,c) <-EPS) return -1;\n    if(dot(b,c)   <-EPS) return +2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\n\nbool isecSS(Point a1,Point a2,Point b1,Point b2){\n    return ccw(a1,a2,b1)*ccw(a1,a2,b2) <= 0 &&\n           ccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n\nbool isecSP(Point a1,Point a2,Point b){\n    return !ccw(a1,a2,b);\n}\n\nPoint proj(Point a1, Point a2, Point p){\n    return a1 + dot(a2-a1, p-a1)/norm(a2-a1)*(a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p){\n    Point r = proj(a1,a2,p);\n    if(isecSP(a1,a2,r)) return abs(r-p);\n    return min(abs(a1-p),abs(a2-p));\n}\n\n\ndouble distSS(Point a1,Point a2,Point b1,Point b2){\n    if(isecSS(a1,a2,b1,b2)) return 0;\n    return min(\n        min(distSP(a1,a2,b1),distSP(a1,a2,b2)),\n        min(distSP(b1,b2,a1),distSP(b1,b2,a2))\n    );\n}\n\nstar make_star(double x,double y,double a,double r){\n    star s(5);\n    rep(i,5){\n        s[i] = Point(x,y) + polar(r, (90+a+144*i)*PI/180.0);\n    }\n    return s;\n}\n\ndouble dist_star(star s1, star s2){\n    double res = INF;\n    rep(i,5)rep(j,5){\n        double dist = distSS(s1[i],s1[(i+1)%5], s2[j],s2[(j+1)%5]);\n        res = min(res,dist);\n    }\n    return res;\n}\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L, N|M|L){\n        vector<star> st(N);\n        rep(i,N){\n            double x,y,a,r;\n            cin>>x>>y>>a>>r;\n            st[i] = make_star(x,y,a,r);\n        }\n        vector<vector<double>> d(N, vector<double>(N, INF));\n        rep(i,N) d[i][i] = 0;\n        rep(i,N)rep(j,i){\n            double dist = dist_star(st[i],st[j]);\n            d[i][j] = dist;\n            d[j][i] = dist;\n        }\n        rep(k,N)rep(i,N)rep(j,N) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n        printf(\"%.20f\\n\",d[M-1][L-1]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double INF = 1e+12;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));\n}\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\nvector<P> getStar(double x, double y, double a, double r){\n  vector<P> res;\n  P p = P(0,r);\n  a *= M_PI / 180.0;\n  for(int i=0;i<5;i++){\n    res.push_back(p);\n    p = rotate(p, 2.0 / 5.0 * (M_PI * 2.0));    \n  }\n  for(int i=0;i<5;i++){\n    res[i] = rotate(res[i], a);\n    res[i] += P(x,y);\n  }\n  return res;\n}\n\nint n,be,al;\nvector<vector<P> > v;\n\nvoid solve(){\n  double G[100][100];\n\n  fill(G[0],G[n],INF);\n  for(int i=0;i<n;i++) G[i][i] = 0;\n\n  for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++)\n      for(int k=0;k<5;k++)\n        for(int l=0;l<5;l++)\n          G[i][j] = G[j][i] = min(G[i][j], getDistanceSS(L(v[i][k],v[i][(k+1)%5]), L(v[j][l],v[j][(l+1)%5])));\n\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n\n  printf(\"%.10f\\n\",G[be][al]);\n}\n\nint main(){\n  while(cin >> n >> be >> al && (n|be|al)){\n    v.clear();\n    be--;\n    al--;\n    for(int i=0;i<n;i++){\n      double x,y,a,r;\n      cin >> x >> y >> a >> r;\n      v.push_back(getStar(x,y,a,r));\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > DBL_EPSILON)\n\t\treturn 1;\n\tif (cross(b, c) < -DBL_EPSILON)\n\t\treturn -1;\n\tif (dot(b, c) < -DBL_EPSILON)\n\t\treturn 2;\n\tif (norm(b) < norm(c) - DBL_EPSILON)\n\t\treturn 2;\n\treturn 0;\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\ndouble DistanceSP(P a, P b, P c) {\n\tif (dot(b - a, c - a) < DBL_EPSILON)\n\t\treturn abs(c - a);\n\tif (dot(a - b, c - b) < DBL_EPSILON)\n\t\treturn abs(c - b);\n\treturn abs(cross(b - a, c - a));\n}\ndouble DistaiceSS(P a, P b, P c, P d) {\n\tif (isIntersectSS(a, b, c, d)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a, b, c), DistanceSP(a, b, d)),\n\t\t\tmin(DistanceSP(c, d, a), DistanceSP(c, d, b)));\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta = M_PI / 2 + 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta), p.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(a1,p1.vertex)\n\t\tforeach(a2,p1.vertex){\n\t\tif(isIntersectSS(p1.p,p2.p,*a1,*a2)){\n\t\t\tforeach(b1,p2.vertex)\n\t\t\t\tforeach(b2,p2.vertex) {\n\t\t\t\tif(isIntersectSS(p1.p,p2.p,*b1,*b2)){\n\t\t\t\t\tm = min(m, DistaiceSS(*a1, *a2, *b1, *b2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn m;\n}\nint x, y, a, r;\n\ndouble dijk(int start, int goal) {\n\tvector<double> memo(N, DBL_MAX);\n\tpriority_queue<pair<double,int> > up;\n\tup.push(make_pair(0, start));\n\tmemo[start] = 0;\n\twhile (!up.empty()) {\n\t\tdouble cost = -up.top().first;\n\t\tint pos = up.top().second;\n\n\t\tup.pop();\n\t\tif (memo[pos] < cost)\n\t\t\tcontinue;\n\t\tif (pos == goal)\n\t\t\treturn cost;\n\t\tREP0(next,N) {\n\t\t\tif (links[pos][next] >= 0) {\n\t\t\t\tdouble ncost = cost + links[pos][next];\n\t\t\t\tif (memo[next] > ncost) {\n\t\t\t\t\tmemo[next] = ncost;\n\t\t\t\t\tup.push(make_pair(-ncost, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tcout << dijk(M - 1, L - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef complex<double> C;\ntypedef pair<C, C> L;\n \nconst double EPS = 1e-10;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\nL stars[100][5];\ndouble dist[100][100];\nint n, m, l;\n\n\ndouble dot(C a, C b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(C a, C b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint ccw (C a, C b, C c) {\n    b -= a;  c -= a;\n    if (cross(b,c) >  EPS) return +1;  // counter clockwise\n    if (cross(b,c) < -EPS) return -1;  // clockwise\n    if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n    return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSS(C a1, C a2, C b1, C b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nbool is_intersected_ls(C a1, C a2, C b1, C b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble distance_ls_p(C a, C b, C c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble distance_ls_ls (L l1, L l2) {\n    C a1 = l1.first, a2 = l1.second;\n    C b1 = l2.first, b2 = l2.second;\n    if (isecSS(a1, a2, b1, b2)) {\n        return 0.0;\n    }\n    double ret1 =  min(distance_ls_p(a1, a2, b1), distance_ls_p(a1, a2, b2));\n    double ret2 =  min(distance_ls_p(b1, b2, a1), distance_ls_p(b1, b2, a2));\n    return min(ret1, ret2);\n}\n\nvoid solve() {\n    rep(i,n) {\n        double x, y, a, r;\n        cin >> x >> y >> a >> r;\n        C p = C(x,y);\n        a += 90;\n        stars[i][0] = L(r*exp(C(0,a*M_PI/180.0))+p, r*exp(C(0,a*M_PI/180.0+2*2*M_PI/5.0))+p);\n        stars[i][1] = L(r*exp(C(0,a*M_PI/180.0))+p, r*exp(C(0,a*M_PI/180.0+3*2*M_PI/5.0))+p);\n        stars[i][2] = L(r*exp(C(0,a*M_PI/180.0+2*M_PI/5.0))+p, r*exp(C(0,a*M_PI/180.0+3*2*M_PI/5.0))+p);\n        stars[i][3] = L(r*exp(C(0,a*M_PI/180.0+2*M_PI/5.0))+p, r*exp(C(0,a*M_PI/180.0+4*2*M_PI/5.0))+p);\n        stars[i][4] = L(r*exp(C(0,a*M_PI/180.0+2*2*M_PI/5.0))+p, r*exp(C(0,a*M_PI/180.0+4*2*M_PI/5.0))+p);\n        /*\n        rep(j,5) {\n            C c = stars[i][j].first;\n            C d = stars[i][j].second;\n            cerr << c.real() << \" \" << c.imag() << \" \" << d.real() << \" \" << d.imag() << endl;\n        }\n        cerr << endl;\n        */\n    }\n    rep(i,n) rep(j,n) {\n        if (i == j) {\n            dist[i][j] = 0;\n            continue;\n        }\n        double dis = 1000000000.0;\n        rep(k,5) rep(l,5) {\n            dis = min(dis, distance_ls_ls(stars[i][k], stars[j][l]));\n            //cerr << k << \" \" << l << \" \" << distance_ls_ls(stars[i][k], stars[j][l]) << endl;\n        }\n        dist[i][j] = dis;\n    }\n    rep(i,n) rep(j,n) rep(k,n) {\n        dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n    }\n    printf(\"%.9f\\n\", dist[m-1][l-1]);\n}\n\nint main() {\n    while (cin >> n >> m >> l) {\n        if (n == 0 && m == 0 && l == 0) break;\n        solve();\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\ndouble dist2(const P& a, const P& b){\n\tP c (b - a);\n\treturn real(c)*real(c)+imag(c)*imag(c);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\t\t ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ndouble d[110][110];\n\nint main(){\n\t\tint n, start ,goal;\n\t\twhile(cin>>n>>start>>goal && n && start && goal){\n\t\t\t\tstart--;\n\t\t\t\tgoal--;\n\t\t\t\trep(i, 110) rep(j, 110) d[i][j] = i == j ? 0.0 : 1e18;\n\t\t\t\tvector<vector<P>> p(n);\n\t\t\t\trep(i, n){\n\t\t\t\t\t\tdouble x, y, a, r;\n\t\t\t\t\t\tcin>>x>>y>>a>>r;\n\t\t\t\t\t\ta = PI * a/180;\n\t\t\t\t\t\trep(j, 5){\n\t\t\t\t\t\t\tP t(cos(a+2.0*PI * j / 5.0+PI/2)*r+x, sin(a+2.0*PI * j / 5.0+PI/2)*r+y);\n\t\t\t\t\t\t\tp[i].pb(t);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<vector<L>> l(n);\n\t\t\t\trep(i, n){\n\t\t\t\t\trep(j, 5){\n\t\t\t\t\t\tint k = (j + 2) % 5;\n\t\t\t\t\t\tl[i].pb({p[i][j], p[i][k]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(i, n) rep(j, n){\n\t\t\t\t\trep(a, 5) rep(b, 5) if(intersectSS(l[i][a], l[j][b])) d[i][j] = 0.0;\n\t\t\t\t\trep(a, 5) rep(b, 5) d[i][j] = min(d[i][j], sqrt(dist2(p[i][a], p[j][b])));\n\t\t\t\t}\n\t\t\t\trep(k, n) rep(i, n) rep(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\tprintf(\"%.15lf\\n\", d[start][goal]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nbool intersectSP(const line_t &s, const xy_t &p) {\n  return abs(s.first - p) + abs(s.second - p) - abs(direction(s)) < EPS;\n}\n\nbool intersectSS(const line_t &s, const line_t &t) {\n  return ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n         ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\nxy_t projection(const line_t &l, const xy_t &p) {\n  double t = dot(p - l.first, direction(l)) / norm(direction(l));\n  return l.first + t*(direction(l));\n}\n\ndouble distanceSP(const line_t &s, const xy_t &p) {\n  const xy_t r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.first - p), abs(s.second - p));\n}\n\ndouble distanceSS(const line_t &s, const line_t &t) {\n  if (intersectSS(s, t)) return 0;\n  \n  return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nstruct star {\n  int x, y, a, r;\n  \n  vector<xy_t> points() const {\n    vector<xy_t> ps;\n    xy_t   center = xy_t(x, y);\n    double theta  = (double)a / 180 * M_PI + M_PI / 2;\n    REP(i, 5) {\n      ps.push_back(center + polar((double)r, theta + M_PI * i * 2 / 5));\n    }\n    return ps;\n  }\n  \n  vector<line_t> segments() const {\n    vector<xy_t>   ps = this->points();\n    vector<line_t> res;\n\n    res.push_back(line_t(ps[0], ps[2]));\n    res.push_back(line_t(ps[1], ps[3]));\n    res.push_back(line_t(ps[2], ps[4]));\n    res.push_back(line_t(ps[3], ps[0]));\n    res.push_back(line_t(ps[4], ps[1]));\n    return res;\n  }\n};\n\ndouble distance(const star &s, const star &t){\n  vector<line_t> seg_ss = s.segments();\n  vector<line_t> seg_ts = t.segments();\n  double res = 1e9;\n\n  for (line_t seg_s : seg_ss){\n    for (line_t seg_t : seg_ts){\n      res = min(res, distanceSS(seg_s, seg_t));\n    }\n  }\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, L;\n  while (cin >> N >> M >> L && N + M + L){\n    vector<star> stars(N);\n    vector<vector<double> > dist(N, vector<double>(N));\n    REP(i, N){\n      cin >> stars[i].x >> stars[i].y >> stars[i].a >> stars[i].r;\n    }\n\n    REP(i, N) REP(j, N){\n      dist[i][j] = distance(stars[i], stars[j]);\n      // cout << dist[i][j]<< (j == N - 1 ? '\\n' : ' ');\n    }\n    \n    REP(k, N) REP(i, N) REP(j, N){\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n    printf(\"%.20lf\\n\", dist[L - 1][M - 1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\n\n\nP crossP(const L &l, L m) {\n    m.x -= l.x; m.y -= l.x;\n    m.x *= polar<R>(1.0, -arg(vec(l)));\n    m.y *= polar<R>(1.0, -arg(vec(l)));\n    P p = m.x - vec(m) * (m.x.imag() / vec(m).imag());\n    p *= polar<R>(1.0, arg(vec(l)));\n    p += l.x;\n    return p;\n}\n\nconst int MN = 110;\nP p[MN][10];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[i][j] = P(x, y) + polar<R>(r, radNorP(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                p[i][j+5] = crossP(L(p[i][j], p[i][(j+2)%5]), L(p[i][(j+1)%5], p[i][(j+3)%5]));\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    L u = L(p[i][k], p[i][(k+2)%5]);\n                    for (int l = 0; l < 10; l++) {\n                        r = min(r, distSP(u, p[j][l]));\n                    }\n                }\n                for (int k = 0; k < 5; k++) {\n                    L u = L(p[j][k], p[j][(k+2)%5]);\n                    for (int l = 0; l < 10; l++) {\n                        r = min(r, distSP(u, p[i][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20Lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cmath>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<29)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<Point> vp;\ntypedef vector<vp> vvp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\n\n\nint N,M,L;\n\nint main()\n{\n  while(cin >> N >> M >> L,N|M|L)\n    {\n      vvp info(N);\n      vvd G(N,vd(N));\n      rep(i,N)rep(j,N)G[i][j] = (i==j?0:inf);\n\n      rep(i,N)\n\t{\n\t  double x,y,a,r;\n\t  cin >> x >> y >> a >> r;\n\t  rep(j,5)\n\t    {\n\t      Point p = Point(0,r);\n\t      p = rotate(p,toRad(a+72*j));\n\t      info[i].push_back(Point(p.x+x,p.y+y));\n\t    }\n\t}\n\n      rep(i,N)//from\n\t{\n\t  REP(j,i+1,N)//to\n\t    {\n\t      double mincost = inf;\n\n\t      rep(k,5)\n\t\t{\n\t\t  rep(l,5)\n\t\t    {\n\t\t      if(isIntersect(Segment(info[i][k],info[i][(k+2)%5]),Segment(info[j][l],info[j][(l+2)%5])) || isIntersect(Segment(info[i][k],info[i][(k+2)%5]),Segment(info[j][l],info[j][(l+3)%5])))\n\t\t\t{\n\t\t\t  mincost = 0;\n\t\t\t  break;\n\t\t\t}\t\t    \n\t\t      if(isIntersect(Segment(info[i][k],info[i][(k+3)%5]),Segment(info[j][l],info[j][(l+2)%5])) || isIntersect(Segment(info[i][k],info[i][(k+3)%5]),Segment(info[j][l],info[j][(l+3)%5])))\n\t\t\t{\n\t\t\t  mincost = 0;\n\t\t\t  break;\n\t\t\t}\t\t    \n\t\t    }\n\t\t  if(mincost == 0)break;\n\t\t}\n\n\t      if(mincost == 0)goto Next;\n\n\t      rep(k,5)//which node\n\t\t{\n\t\t  rep(l,5)//which segment\n\t\t    {\n\t\t      mincost = min(mincost,min(getDistanceSP(Segment(info[j][l],info[j][(l+2)%5]),info[i][k]),\n\t\t\t\t\t\tgetDistanceSP(Segment(info[j][l],info[j][(l+3)%5]),info[i][k])));\n\t\t    }\n\t\t}\n\n\t    Next:;\n\t      G[i][j] = G[j][i] = mincost;\n\t    }\n\t}\n\n\n      rep(k,N)rep(i,N)rep(j,N)G[i][j] = min(G[i][j],\n\t\t\t\t\t    G[i][k]+G[k][j]);      \n\n      cout << setiosflags(ios::fixed) << setprecision(1000) << G[M-1][L-1] << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n  \nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( complex<double> a, complex<double> b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(complex<double> p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distancion(L,L); //線分:線分の距離(iteratorのdistanceと被るから留意)\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n  \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\n\ndouble info[100][100];\nint n, m, l;\nL stars[100][5];\nint table[][5] = {{0,0,1,1,2},{2,3,3,4,4}};\nvoid add( double x, double y, double a, double r, int z){\n  G hosi(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[z][i] = L( hosi[table[0][i]], hosi[table[1][i]]);\n  }\n}\nint main(){\n  while(scanf(\"%d%d%d\", &n, &m, &l), n|m|l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      double x, y, a, r;\n      scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &r);\n      add( x, y, a, r, i);\n    }\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    for(int k = 0; k < n; k++ ){\n      for(int i = 0; i < n; i++ ){\n        for(int j = 0; j < n; j++ ){\n          info[i][j] = min( info[i][j], info[i][k] + info[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\", info[m][l]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst int INF = numeric_limits<int>::max() / 2;\nconst double PI = 3.14159265358979323846;\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  int n,m,l;cin >> n>>m>>l;\n  if(n==0) break;\n  Polygon stars[n];\n  //int r[n];\n  for(int i=0;i<n;i++){\n    int x,y,a,r;cin>>x>>y>>a>>r;\n    for(int j=0;j<5;j++){\n      Point v=Point(x,y)+Point(r*cos((18+a+72*j)*(2*PI)/360),r*sin((18+a+72*j)*(2*PI)/360));\n      stars[i].push_back(v);\n    }\n  }\n  ld dis[n][n];\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n    if(i==j) dis[i][j]=0.0;\n    else dis[i][j]=INF;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ld tmp=INF;\n      for(int k=0;k<5;k++){\n        for(int l=0;l<5;l++){\n          Line x=Line(stars[i][k],stars[i][(k+2)%5]);\n          Line y=Line(stars[j][k],stars[j][(l+2)%5]);\n          tmp=min(tmp,dist_ss(x,y));\n        }\n      }\n      dis[i][j]=tmp;dis[j][i]=tmp;\n    }\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);\n      }\n    }\n  }\n  cout << setprecision(10)<<dis[m-1][l-1] << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n#include <immintrin.h>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//テ・ツ??」ツ?ョテヲツ篠・テァツキツ?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//テゥツ敖「テァツゥツ??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n// Suffix Array\tテ・ツ按敕ヲツ慊淌・ツ個飽(|S|log^2|S|), テヲツ、ツ愿ァツエツ「O(|T|log|S|), テゥツォツ佚」ツ?陛ゥツ?催・ツ按療ヲツァツ凝ァツッツ碓(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble way[100][100];\nint main() {\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tm--, l--;\n\t\tfill(way[0], way[100], 1e9);\n\t\trep(i, 2 * n)way[i][i] = 0;\n\t\tva<int, 4> s(n);\n\t\trep(i, n)rep(j, 4)cin >> s[i][j];\n\t\trep(i, n)rep(j, i) {\n\t\t\tvector<P> si(5), sj(5);\n\t\t\tP r(0, s[i][3]);\n\t\t\tr *= P(cos(pi / 180 * s[i][2]), sin(pi / 180 * s[i][2]));\n\t\t\tP ro(cos(2 * pi / 5), sin(2 * pi / 5));\n\t\t\trep(k, 5)si[k] = P(s[i][0], s[i][1]) + r, r *= ro;\n\t\t\tr = P(0, s[j][3]);\n\t\t\tr *= P(cos(pi / 180 * s[j][2]), sin(pi / 180 * s[j][2]));\n\t\t\trep(k, 5)sj[k] = P(s[j][0], s[j][1]) + r, r *= ro;\n\t\t\trep(k, 5)rep(l, 5)cmin(way[i][j], dist_ss(L{ si[k],si[(k + 2 > 4 ? k + 2 - 5 : k + 2)] }, L{ sj[k], sj[(k + 2 > 4 ? k + 2 - 5 : k + 2)] }));\n\t\t\tway[j][i] = way[i][j];\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n)cmin(way[i][j], way[i][k] + way[k][j]);\n\t\tcout << fixed << setprecision(10) << way[m][l] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tdouble x,y;\n};\n\nInfo roll(double x, double y, double rad)\n{\n\tInfo ret;\n\n\tret.x = x*cos(rad)-y*sin(rad);\n\tret.y = x*sin(rad)+y*cos(rad);\n\n\treturn ret;\n}\n\ndouble calc(Info left,Info right){\n\treturn sqrt((left.x-right.x)*(left.x-right.x)+(left.y-right.y)*(left.y-right.y));\n}\n\nInfo info[101][5];\n\nint N,start,goal;\ndouble dist[101][101];\n\nvoid func(){\n\n\tdouble x,y,degree,r;\n\n\tInfo tmp;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lf %lf %lf %lf\",&x,&y,&degree,&r);\n\n\t\ttmp = roll(0.0,r,degree*M_PI/180.0);\n\n\t\tinfo[i][0].x = x+tmp.x;\n\t\tinfo[i][0].y = y+tmp.y;\n\n\t\tfor(int k = 1; k <= 4; k++){\n\t\t\ttmp = roll(info[i][k-1].x-x,info[i][k-1].y-y,(2.0*M_PI/5.0));\n\t\t\tinfo[i][k].x = x+tmp.x;\n\t\t\tinfo[i][k].y = y+tmp.y;\n\t\t}\n\t}\n\n\tdouble tmp_min,tmp_dist;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = i; k <= N; k++){\n\t\t\tif(i != k){\n\t\t\t\ttmp_min = DBL_MAX;\n\n\t\t\t\tfor(int a = 0; a < 5; a++){\n\t\t\t\t\tfor(int b = 0; b < 5; b++){\n\t\t\t\t\t\ttmp_dist = calc(info[i][a],info[k][b]);\n\t\t\t\t\t\ttmp_min = min(tmp_min,tmp_dist);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdist[i][k] = tmp_min;\n\t\t\t\tdist[k][i] = tmp_min;\n\t\t\t}else{\n\t\t\t\tdist[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int mid = 1; mid <= N; mid++){\n\t\tfor(int st = 1; st <= N; st++){\n\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\tdist[st][gl] = min(dist[st][gl],dist[st][mid]+dist[mid][gl]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.20lf\\n\",dist[start][goal]);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&start,&goal);\n\t\tif(N == 0 && start == 0 && goal == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nconst double PI=acos(-1);\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\ntypedef Line Segment;\n\nPoint Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\nbool InterLS(Line l,Segment s){\n\tPoint a=l.pos,b=l.pos+l.dir,c=s.pos,d=s.pos+s.dir;\n\treturn CCW(a,b,c)*CCW(a,b,d)<0;\n}\nbool InterSS(Segment a,Segment b){\n\treturn InterLS(a,b) && InterLS(b,a);\n}\ndouble DistLP(Line l,Point p){\n\treturn Abs(Proj(l,p)-p);\n}\ndouble DistSP(Segment s,Point p){\n\tint ccw=CCW(s.pos,s.pos+s.dir,Proj(s,p));\n\tif(ccw==-2)\n\t\treturn Abs(p-s.pos);\n\tif(ccw==2)\n\t\treturn Abs(p-(s.pos+s.dir));\n\treturn DistLP(s,p);\n}\ndouble DistLS(Line l,Segment s){\n\tif(InterLS(l,s)) return 0;\n\treturn min(DistLP(l,s.pos),DistLP(l,s.pos+s.dir));\n}\ndouble DistSS(Segment a,Segment b){\n\tif(InterSS(a,b)) return 0;\n\tdouble d1=min(DistSP(a,b.pos),DistSP(a,b.pos+b.dir));\n\tdouble d2=min(DistSP(b,a.pos),DistSP(b,a.pos+a.dir));\n\treturn min(d1,d2);\n}\n\nint main()\n{\n\tfor(int n,src,dst;cin>>n>>src>>dst,n|src|dst;){\n\t\tvi xs(n),ys(n),as(n),rs(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i]>>as[i]>>rs[i];\n\t\t\n\t\tvvd dp(n,vd(n,INFTY));\n\t\tint counter=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tPoint p1[6],p2[6];\n\t\t\trep(k,6){\n\t\t\t\tp1[k]=Point(xs[i],ys[i])+Rot(Point(0,rs[i]),(as[i]+k*144)*PI/180);\n\t\t\t\tp2[k]=Point(xs[j],ys[j])+Rot(Point(0,rs[j]),(as[j]+k*144)*PI/180);\n\t\t\t}\n\t\t\trep(k,5) rep(l,5){\n\t\t\t\tcounter++;\n\t\t\t\tSegment s1(p1[k],p1[k+1]-p1[k]);\n\t\t\t\tSegment s2(p2[l],p2[l+1]-p2[l]);\n\t\t\t\tdp[i][j]=min(dp[i][j],DistSS(s1,s2));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tprintf(\"%.10f\\n\",dp[src-1][dst-1]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\nconst double PI = acos(-1.0);\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point(double theta){\n        y = sin(theta);\n        x = cos(theta);\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nvoid shortestPath(const vector<vector<double> >& graph, int start, vector<double>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, DBL_MAX);\n    dist[start] = 0.0;\n    priority_queue<pair<double,int> ,vector<pair<double,int> >, greater<pair<double,int> > > q;\n    q.push(make_pair(0.0, start));\n\n    while(!q.empty()){\n        pair<double, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first - EPS)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(dist[v] + graph[v][i] < dist[i] - EPS){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, l;\n        cin >> n >> m >> l;\n        if(n == 0)\n            return 0;\n        -- m;\n        -- l;\n\n        vector<vector<Point> > p(n, vector<Point>(5));\n        for(int i=0; i<n; ++i){\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            for(int j=0; j<5; ++j)\n                p[i][j] = Point(y, x) + Point((90 + a + 72 * j) / 180.0 * PI) * r;\n        }\n\n        vector<vector<double> > graph(n, vector<double>(n, DBL_MAX));\n        for(int a=0; a<n; ++a){\n            for(int b=a; b<n; ++b){\n                for(int i=0; i<5; ++i){\n                    for(int j=0; j<5; ++j){\n                        graph[a][b] = min(graph[a][b], segmentsDist(p[a][i], p[a][(i+2)%5], p[b][j], p[b][(j+2)%5]));\n                        graph[b][a] = min(graph[b][a], graph[a][b]);\n                    }\n                }\n            }\n        }\n\n        vector<double> dist;\n        shortestPath(graph, m, dist);\n        printf(\"%.10f\\n\", dist[l]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\ntypedef complex<double> PT;\ntypedef PT VC;\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b) / abs(l.fi-l.se));\n}\n\nvector<PT> intersec_line_line(LN a, LN b) {\n\tvector<PT> res;\n\tif(abs(cross_prod(a.fi-a.se, b.fi-b.se)) < EPS)\n\t\treturn res;\n\tif(abs(cross_prod(b.fi-a.fi, b.se-a.fi)) < EPS)\n\t\tswap(a.fi, a.se);\n\t\n\tVC va, vb, vc;\n\tdouble s, t;\n\tva = b.fi - a.fi;\n\tvb = b.se - a.fi;\n\tvc = a.se - a.fi;\n\ts = cross_prod(va, vc) / cross_prod(va, vb);\n\tt = cross_prod(vc, vb) / cross_prod(va, vb);\n\tres.push_back(a.fi + (t * va + s * vb) / (s+t));\n\treturn res;\n}\n\nbool on_seg(PT p, SG a) {\n\tVC b, c;\n\tb = a.fi - p;\n\tc = a.se - p;\n\treturn dot_prod(b,c) < EPS && abs(cross_prod(b,c)) < EPS;\n}\n\nvector<PT> intersec_seg_seg(SG a, SG b) {\n\tvector<PT> tmp, res;\n\ttmp = intersec_line_line(a,b);\n\tfor(int i = 0; i < tmp.size(); i++) {\n\t\tif(on_seg(tmp[i], a) && on_seg(tmp[i],b))\n\t\t\tres.push_back(tmp[i]);\n\t}\n\treturn res;\n}\n\n\n// テ、ツサツ・テ、ツクツ甘・ツケツセテ、ツスツ陛」ツδゥテ」ツつ、テ」ツδ姪」ツδゥテ」ツδェテ・ツ?凖ァツオツ?\n\ndouble dist_pts_seg(PT p, SG a) {\n\tdouble res;\n\tres = min(abs(a.fi-p), abs(a.se-p));\n\tif(dot_prod(a.se - a.fi, p - a.fi) > -EPS\n\t\t\t&& dot_prod(a.fi - a.se, p - a.se) > -EPS)\n\t\tres = min(res, dist_pts_line(p, a));\n\treturn res;\n}\n\ndouble dist_seg_seg(SG a, SG b) {\n\tdouble res;\n\tres = min(\n\t\t\tmin(dist_pts_seg(a.fi,b), dist_pts_seg(a.se,b)),\n\t\t\tmin(dist_pts_seg(b.fi,a), dist_pts_seg(b.se,a)) );\n\tif(intersec_seg_seg(a,b).size())\n\t\tres = 0;\n\treturn res;\n}\n\n/* //テ・ツケツセテ、ツスツ陛」ツδ?」ツつケテ」ツδ?\nint main() {\n\tSG a(PT(0,0),PT(0,2));\n\tSG b(PT(-1,1),PT(2,1));\n\tcout << dist_seg_seg(a,b) << endl;\n} // */\n\n//*\nint N, M, L;\nvector<vector<SG> > star;\ndouble edge[120][120];\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nvoid init() {\n\tstar.clear();\n\trep(i,120) {\n\t\trep(j,120)\n\t\t\tedge[i][j] = 1e9;\n\t\tedge[i][i] = 0;\n\t}\n}\n\nint main() {\n\twhile(cin >> N >> M >> L, N || M || L) {\n\t\tinit();\n\t\tM--; L--;\n\t\trep(i,N) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<PT> tmp;\n\t\t\tdouble theta = (a+90) / 180.0 * M_PI;\n\t\t\tdouble phi = 360.0 / 5.0 / 180.0 * M_PI;\n\t\t\trep(i,5) {\n\t\t\t\ttmp.push_back(polar((double)r, theta + phi * i) + PT(x,y));\n\t\t\t//\tcout << tmp[i] << endl;\n\t\t\t}\n\t\t\tvector<SG> push;\n\t\t\trep(i,5) {\n\t\t\t\tpush.push_back(SG(tmp[i],tmp[(i+2)%5]));\n\t\t\t}\n\t\t\tstar.push_back(push);\n\t\t}\n\n\t\trep(i,N) {\n\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\tdouble tmp = 1e9;\n\t\t\t\trep(k,5) {\n\t\t\t\t\trep(l, 5) {\n\t\t\t\t\t\ttmp = min(tmp, dist_seg_seg(star[i][k], star[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\trep(i,N) {\n\t\t\trep(j,N) {\n\t\t\t\trep(k,N) {\n\t\t\t\t\tedge[j][k] = min(edge[j][k], edge[j][i] + edge[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", edge[L][M]);\n\t}\n}\n// */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,int> D;\nconst double EPS = 1e-8;\n\nP p[100];\ndouble r[100],d[100];\nint n,s,g;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first)); }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\ndouble cal(){\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y>>d[i]>>r[i];\n  \n  priority_queue<D,vector<D>,greater<D> > Q;\n  int used[100]={};\n  Q.push(D(0,s-1));\n  while(!Q.empty()){\n    double cs=Q.top().first;\n    int pos=Q.top().second;\n    Q.pop();\n    if(used[pos]++)continue;\n    if(pos==g-1)return cs;\n    \n    for(int i=0;i<n;i++){\n      if(i==pos)continue;\n\n      for(int j=0;j<5;j++){\n\t\n\tdouble na=M_PI*(d[i]+72*j+90)/180;\n\tdouble na1=M_PI*(d[i]+72*(j+2)+90)/180;\n\tL S=L(P(r[i]*cos(na),r[i]*sin(na))+p[i],P(r[i]*cos(na1),r[i]*sin(na1))+p[i]);\n\tfor(int k=0;k<5;k++){\n\t  double nb=M_PI*(d[pos]+72*k+90)/180;\n\t  double nb1=M_PI*(d[pos]+72*(k+2)+90)/180;\n\t  L G=L(P(r[pos]*cos(nb),r[pos]*sin(nb))+p[pos],P(r[pos]*cos(nb1),r[pos]*sin(nb1))+p[pos]);\n\t  Q.push(D(cs+getDistanceSS(S,G),i));\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>s>>g,n)printf(\"%.8lf\\n\",cal());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\nstruct Line :Polygon{\n\tLine(){};\n\tLine(Point p,Point q){push_back(p);push_back(q);}\n};\n\ndouble cross(Point p, Point q){\n\treturn imag(conj(p)*q);\n}\ndouble dot(Point p, Point q){\n\treturn real(conj(p)*q);\n}\n\nint ccw(Point a, Point b, Point c){\n\tb -= a,c -= a;\n\tif(cross(b,c)>9)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\n\nbool intersectSS(Line s,Line t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 1;\n}\n\nPoint projection(Line l, Point p){\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t * (l[0] - l[1]);\n}\n\nbool intersectSP(Line s, Point p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(Line s,Point p){\n\tconst Point r = projection(s,p);\n\tif(intersectSP(s, r))return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(Line s, Line t){\n\tif(intersectSS(s, t))return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint main(){\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n){\n\t\tPolygon stars[102];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tstars[i].resize(0);\n\t\t\tdouble x,y,a,r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\tstars[i].push_back(Point(x,y) + polar(r,(a + 90 + 72 * 2 * j) / 180.0 * PI));\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble dist[102][102];\n\t\tfor(int i = 0;i < 102;i++)\n\t\t\tfor(int j = 0;j < 102;j++)\n\t\t\t\tdist[i][j] = INF*(i!=j);\t\t\t\t\t\t\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tdouble value = INF;\n\t\t\t\tfor(int k = 0;k < 5;k++){\n\t\t\t\t\tLine line = Line(stars[i][k],stars[i][(k+1)%5]);\n\t\t\t\t\tfor(int q = 0;q < 5;q++){\n\t\t\t\t\t\tvalue = min(value,distanceSP(line,stars[j][q]));\n\t\t\t\t\t}\n\t\t\t\t\tline = Line(stars[j][k],stars[j][(k+1)%5]);\n\t\t\t\t\tfor(int q = 0;q < 5;q++){\n\t\t\t\t\t\tvalue = min(value,distanceSP(line,stars[i][q]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdist[i][j] = dist[j][i] = min(value,dist[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0;k < n;k++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.7lf\\n\",dist[m-1][l-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\ninline int Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\ninline Point operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\ninline Point operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\ninline Point operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\ninline double Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ninline double Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ninline Point Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\ninline double Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ninline double Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\ninline int CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\ntypedef Line Segment;\n\ninline Point Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\ninline bool InterLS(Line l,Segment s){\n\tPoint a=l.pos,b=l.pos+l.dir,c=s.pos,d=s.pos+s.dir;\n\treturn CCW(a,b,c)*CCW(a,b,d)<0;\n}\ninline bool InterSS(Segment a,Segment b){\n\treturn InterLS(a,b) && InterLS(b,a);\n}\ninline double DistLP(Line l,Point p){\n\treturn Abs(Proj(l,p)-p);\n}\ninline double DistSP(Segment s,Point p){\n\tint ccw=CCW(s.pos,s.pos+s.dir,Proj(s,p));\n\tif(ccw==-2)\n\t\treturn Abs(p-s.pos);\n\tif(ccw==2)\n\t\treturn Abs(p-(s.pos+s.dir));\n\treturn DistLP(s,p);\n}\ninline double DistLS(Line l,Segment s){\n\tif(InterLS(l,s)) return 0;\n\treturn min(DistLP(l,s.pos),DistLP(l,s.pos+s.dir));\n}\ninline double DistSS(Segment a,Segment b){\n\tif(InterSS(a,b)) return 0;\n\tdouble d1=min(DistSP(a,b.pos),DistSP(a,b.pos+b.dir));\n\tdouble d2=min(DistSP(b,a.pos),DistSP(b,a.pos+a.dir));\n\treturn min(d1,d2);\n}\n\nint main()\n{\n\tfor(int n,src,dst;scanf(\"%d%d%d\",&n,&src,&dst),n|src|dst;){\n\t\tvi xs(n),ys(n),as(n),rs(n);\n\t\trep(i,n) scanf(\"%d%d%d%d\",&xs[i],&ys[i],&as[i],&rs[i]);\n\t\t\n\t\tvvd dp(n,vd(n,INFTY));\n\t\tint counter=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tPoint p1[6],p2[6];\n\t\t\trep(k,6){\n\t\t\t\tp1[k]=Point(xs[i],ys[i])+Rot(Point(0,rs[i]),(as[i]+k*144)*PI/180);\n\t\t\t\tp2[k]=Point(xs[j],ys[j])+Rot(Point(0,rs[j]),(as[j]+k*144)*PI/180);\n\t\t\t}\n\t\t\trep(k,5) rep(l,5){\n\t\t\t\tcounter++;\n\t\t\t\tSegment s1(p1[k],p1[k+1]-p1[k]);\n\t\t\t\tSegment s2(p2[l],p2[l+1]-p2[l]);\n\t\t\t\tdp[i][j]=min(dp[i][j],DistSS(s1,s2));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tprintf(\"%.10f\\n\",dp[src-1][dst-1]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n#include <complex>\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\ninline double cross(const Point& a, const Point& b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n  return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n  b -= a; c -= a;\n  double len = abs(b) * abs(c);\n  if(cross(b, c) > +EPS * len) return +1; // counter-clockwise\n  if(cross(b, c) < -EPS * len) return -1; // clockwise\n  if(dot(b, c) < 0) return +2; // c--a--b\n  if(norm(b) < norm(c)) return -2; // a--b--c\n  return 0; // a--c--b \n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nint main(){\n  int N, M, L;\n  while(cin>>N>>M>>L && N){\n    M--; L--;\n    double x[100], y[100], a[100], r[100];\n    REP(i, N){\n      cin>>x[i]>>y[i]>>a[i]>>r[i];\n    }\n    vector<Line> lines(N * 5);\n    REP(i, N){\n      Point ps[5];\n      REP(j, 5) ps[j] = Point(x[i] + r[i] * cos(M_PI*(90.0 + a[i] + 72 * j)/180.0), y[i] + r[i] * sin(M_PI*(90.0 + a[i] + 72 * j)/180));\n      REP(j, 5) lines[5 * i + j] = Line(ps[j], ps[(j + 2) % 5]);\n    }\n    vector<double> dist(N * 5, INF);\n    queue<int> que;\n    REP(i, 5){\n      dist[5 * M + i] = 0;\n      que.push(5 * M + i);\n    }\n    while(!que.empty()){\n      int u = que.front(); que.pop();\n      REP(i, N * 5){\n        double next = dist[u] + distanceSS(lines[u], lines[i]);\n        if(next < dist[i]){\n          dist[i] = next;\n          que.push(i);\n        }\n      }\n    }\n    printf(\"%.10f\\n\", dist[5*L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\ntypedef complex<double> P;\nstruct seg{P p1,p2;};\ndouble eps=1e-10;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;\n  if(a.imag()<-eps)return -1;\n  if(a.real()<-eps)return 2;\n  if(abs(b)+eps<abs(c))return -2;\n  return 0;\n}\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\nint main(){\n  double a,b,c,d;\n  int n,ve,al;\n  while(cin>>n>>ve>>al,n){\n    P p[n][5];\n    seg D[n][5];\n    r(i,n){\n      scanf(\"%lf%lf%lf%lf\",&a,&b,&c,&d);\n      r(j,5)p[i][j]=P(a-d*sin(M_PI/180*(72*j+c)),b+d*cos(M_PI/180*(72*j+c)));\n      D[i][0].p1=p[i][0];D[i][0].p2=p[i][2];\n      D[i][1].p1=p[i][1];D[i][1].p2=p[i][3];\n      D[i][2].p1=p[i][2];D[i][2].p2=p[i][4];\n      D[i][3].p1=p[i][3];D[i][3].p2=p[i][0];\n      D[i][4].p1=p[i][4];D[i][4].p2=p[i][1];\n    }\n    double w[n][n];\n    r(i,n)r(j,n)w[i][j]=i==j?0:1000000000;\n    r(i,n)R(j,i+1,n){\n      double t=1000000000;\n      r(k,5)r(l,5)t=min(t,dist(D[i][k].p1,D[i][k].p2,D[j][l].p1,D[j][l].p2));\n      w[i][j]=w[j][i]=t;\n    }\n    r(k,n)r(i,n)r(j,n)w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    printf(\"%.11f\\n\",w[ve-1][al-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// geometry library\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\nbool operator<(const P& a, const P& b) {\n  return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n};\ndouble cross(const P& a, const P& b) { return imag(conj(a) * b); }\ndouble dot(const P& a, const P& b) { return real(conj(a) * b); }\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P& a, const P& b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1; // counter clock wise\n  if (cross(b, c) < 0)   return -1; // clock wise\n  if (dot(b, c) < 0)     return +2; // c--a--b \n  if (norm(b) < norm(c)) return -2; // a--b--c\n  return 0;\n}\n\nbool intersectLL(const L& l, const L& m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n      abs(cross(l[1] - l[0], m[0] - l[0])) < EPS;\n}\n\nbool intersectLS(const L& l, const L& s) {\n  return cross(l[1] - l[0], s[0] - l[0]) *\n      cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n\nbool intersectLP(const L& l, const P& p) {\n  return abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n\nbool intersectSS(const L& s, const L& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n      ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const L& s, const P& p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distanceLP(const L& l, const P& p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distanceLL(const L& l, const L& m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\ndouble distanceLS(const L& l, const L& s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\ndouble distanceSP(const L& s, const P& p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L& s, const L& t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nP crosspoint(const L& l, const L& m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(false);\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n// end of library\nconst double kRad = M_PI / 180.0;\nconst int kInf = 1 << 28;\nint N, M, Li;\nL ls[102][7];\ndouble dist[102][102];\n\nvoid make_graph() {\n  rep(i,N) rep(j,N) dist[i][j] = kInf;\n  rep(i,N) rep(j,5) {\n    L me = ls[i][j];\n    rep(k,N) rep(l,5) {\n      if (i == k) continue;\n      L other = ls[k][l];\n      dist[i][k] = min(dist[i][k], distanceSS(me, other));\n    }\n  }\n}\n\ndouble solve(int s, int t) {\n  // vector<double> d(N, kInf);\n  // d[s] = 0;\n  // priority_queue<Pd, vector<Pd>, greater<Pd> > pq;\n  // pq.push(Pd(0, s));\n  // while (!pq.empty()) {\n  //   Pd p = pq.top(); pq.pop();\n  //   int v = p.second;\n  //   if (d[v] < p.first) continue;\n  //   for (int i = 0; i < N; ++i) {\n      \n  //   }\n  // }\n  // return d[t];\n  rep(i,N) dist[i][i] = 0;\n  rep(k,N) rep(i,N) rep(j,N)\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  return dist[s][t];\n}\n\nint main() {\n  while (scanf(\"%d%d%d\", &N, &M, &Li), N) {\n    --M; --Li;\n    int x, y, a, r;\n    rep(i,N) {\n      scanf(\"%d%d%d%d\", &x, &y, &a, &r);\n      a += 18;\n      vector<P> vp;\n      for (int j = 0; j < 5; ++j) {\n        double lx = r * cos(a * kRad) + x, ly = r * sin(a * kRad) + y;\n        vp.push_back(P(lx, ly));\n        a += 72;\n        a %= 360;\n      }\n      ls[i][0] = L(vp[0], vp[2]);\n      ls[i][1] = L(vp[1], vp[4]);\n      ls[i][2] = L(vp[2], vp[4]);\n      ls[i][3] = L(vp[3], vp[0]);\n      ls[i][4] = L(vp[3], vp[1]);\n    }\n    make_graph();\n    printf(\"%f\\n\", solve(M, Li));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tP pt[100][5];\n        for(int i = 0; i < n; i++){\n\t\t\tdouble x,y,a,r;\n            cin>>x>>y>>a>>r;\n            for(int j = 0; j < 5; j++)\n\t\t\t\tpt[i][j]=rot(P(r,0.0),(18 + a + 72 * j)/180.0 * PI) + P(x,y);\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    S s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    S t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n\n// ??????????????¢????????????\n\n// ?????°??? ??? ??§??????\ndouble deg2rad(double x) {return x * M_PI / 180.0;}\n\n// ??? a ???????????¨???????????? b ??? z ????????¢???????????¨????????????\nP rotatePoint(P a, P b, double z) {\n    // ?????°????????´????????????\n    z = deg2rad(z);\n\n    b -= a;\n    double rx = b.X * cos(z) - b.Y * sin(z);\n    double ry = b.X * sin(z) + b.Y * cos(z);\n    P ret(rx, ry); ret += a;\n    return ret;\n}\n\nint N, M, L;\ndouble dist[110][110];\n\nsigned main() {\n    while(cin >> N >> M >> L, N || M || L) {\n        M--; L--;\n        double x, y, a, r;\n        vector<P> ps[110];\n        rep(i,0,N) {\n            cin >> x >> y >> a >> r;\n            P po = P(x, y), pt = P(x, y+r);\n            pt = rotatePoint(po, pt, a);\n            rep(j,0,5) {\n                double deg = 72.0 * j;\n                ps[i].push_back( rotatePoint(po, pt, deg) );\n            }\n        }\n\n        rep(i,0,N) rep(j,0,N) {\n            dist[i][j] = INF;\n            rep(x,0,5) rep(y,0,5) {\n                P tx = ps[i][x], ty = ps[j][y];\n                chmin(dist[i][j], abs(tx-ty));\n            }\n        }\n\n        rep(k,0,N) rep(i,0,N) rep(j,0,N) {\n            chmin(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n        printf(\"%.12f\\n\", dist[M][L]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<vector>\n#include<map>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//線分p1-p2と線分q1-q2が交差するか\nbool intersecting(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//原点中心回転\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originを中心回転\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//二点間の距離\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//単位ベクトルに変換\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//線分と点の距離\ndouble dist_lp(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal= make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//法線ベクトル\n\tif(intersecting(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//線分同士の距離\ndouble dist_ll(P p1,P p2,P q1,P q2){\n\tif(intersecting(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_lp(p1,p2,q1),dist_lp(p1,p2,q2))\n\t\t,min(dist_lp(q1,q2,p1),dist_lp(q1,q2,p2)) );\n}\n//ラジアンに変換\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n\nvector<pair<P,P> > create_star(double x,double y,double a,double r){\n\tvector<pair<P,P> > res;\n\tvector<P> p;\n\tfor(int i=0;i<5;i++){\n\t\tdouble rad = radian(18+i*72);\n\t\tp.push_back( P(x,y) +rotate(P(r*cos(rad),r*sin(rad)) ,a) );\n\t}\n\tfor(int i=0;i<5;i++){\n\t\tres.push_back( make_pair(p[i],p[(i+2)%5]) );\n\t}\n\treturn res;\n}\ndouble dist_star(vector<pair<P,P> > &a,vector<pair<P,P> > &b){\n\tdouble res=INF;\n\tfor(int i=0;i<a.size();i++){\n\t\tfor(int j=0;j<b.size();j++){\n\t\t\tres = min(res, \n\t\t\t\tdist_ll(a[i].first,a[i].second,b[j].first,b[j].second) );\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tdouble d[100][100];\n\tvector<vector<pair<P,P> > > stars;\n\tint N,M,L;\n\tdouble x,y,a,r;\n\twhile(cin>>N>>M>>L, N||M||L){\n\t\tM--;\n\t\tL--;\n\t\tstars.clear();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tstars.push_back(create_star(x,y,radian(a),r));\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i;j<N;j++){\n\t\t\t\td[i][j]=d[j][i] = dist_star(stars[i],stars[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<N;k++)\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\tprintf(\"%.20f\\n\",d[M][L]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<complex>\n#define INF 10000000.0\n#define pb push_back\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> Point;\ntypedef pair<double ,int > P;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real( conj(a) * b );\n}\ndouble cross(Point a, Point b){\n    return imag( conj(a) * b );\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a)<=0 ) return abs(c-a);\n  if ( dot(a-b, c-b)<=0 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\nint is_intersected_ls(Point a1, Point a2, Point b1, Point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) <=0 ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) <=0 );\n}\ndouble distance_ls_ls(Point a1,Point a2,Point a3,Point a4){\n\tif(is_intersected_ls(a1,a2,a3,a4))\n\t\treturn 0.0;\n\tdouble r1=distance_ls_p(a1,a2,a3),r2=distance_ls_p(a1,a2,a4),r3=distance_ls_p(a3,a4,a1),r4=distance_ls_p(a3,a4,a2);\n\tif(r1>r2)\n\tr1=r2;\n\tif(r3>r4)\n\tr3=r4;\n\tif(r1>r3)\n\treturn r3;\n\treturn r1;\n\t\n}\ndouble cal(int a,int b){\n\tdouble ret=INF;\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=i+1;j<5;j++){\n\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\tfor(int l=k+1;l<5;l++){\n\t\t\t\t\tdouble u=distance_ls_ls(p[a][i],p[a][j],p[b][k],p[b][l]);\n\t\t\t\t\tif(ret>u)\n\t\t\t\t\t\tret=u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<ret<<endl;\n\treturn ret;\n}\n\n\n\nint main(){\n\twhile(cin>>n>>s>>g,n||s||g){\n\t\tp.clear();\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,a,r;\n\t\t\tPoint pot;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tPoint c=Point(x,y);\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tp[i].pb(c+polar(r,PI*(a+(double)j*72.0+90.0)/180.0));\n\t\t\t}\n\t\t}\n\t\t//cout<<\"      \"<<distance_ls_p(p[0][4],p[0][1],p[2][2])<<endl;\n\n\t\t\n\t\tvector<vector<double> > cost(n,vector<double>(n,INF));\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble a=cal(i,j);\n\t\t\t\tcost[i][j]=a;\n\t\t\t\tcost[j][i]=a;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcout<<cost[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,s-1));\n\t\tvector<double> d(n,INF);\n\t\td[s-1]=0;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();\n\t\t\tint pos=q.second;\n\t\t\tdouble dist=q.first;\n\t\t\tque.pop();\n\t\t\tif(pos==g-1){\n\t\t\t\tprintf(\"%.8lf\\n\",dist);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dist>d[pos]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\n\t\t\t\tif(cost[pos][i]==INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cost[pos][i]+dist<d[i]){\n\t\t\t\t\tque.push(P(cost[pos][i]+dist,i));\n\t\t\t\t\td[i]=cost[pos][i]+dist;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#ifdef DEBUG\n#define line() cout << \"[\" << __LINE__ << \"] \";\n#define dump(i) cout << #i \": \" << i << \" \";\n#define dumpl(i) cout << #i \": \" << i << endl;\n#else\n#define line(i)\n#define dump(i)\n#define dumpl(i)\n#endif\n#define EPS (1e-10)\nusing namespace std;\n\ndouble add(double a, double b)\n{\n\n    if (abs(a + b) < EPS * (abs(a) + abs(b)))\n        return 0;\n    return a + b;\n}\n\nstruct P\n{\n    double x, y;\n    P(){};\n    P(double x, double y) : x(x), y(y) {}\n    P operator+(P p)\n    {\n        return (P(add(x, p.x), add(y, p.y)));\n    }\n    P operator-(P p)\n    {\n        return (P(add(x, -p.x), add(y, -p.y)));\n    }\n    P operator*(double k)\n    {\n        return (P(k * x, k * y));\n    }\n    double dot(P p)\n    {\n        return add(x * p.x, y * p.y);\n    }\n    double det(P p)\n    {\n        return add(x * p.y, -y * p.x);\n    }\n};\ntypedef P Vector;\nstruct Seg\n{\n    P p1, p2;\n    Seg() {}\n    Seg(P p1, P p2) : p1(p1), p2(p2) {}\n};\n//点qが線分p1-p2上にあるか\nbool on_seg(P p1, P p2, P q)\n{\n    return (p1 - q).det(p2 - q) == 0 && (p1 - q).dot(p2 - q) <= 0;\n}\nP intersection(P p1, P p2, P q1, P q2)\n{\n    return p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\n\n//三辺の長さがそれぞれa,b,cの三角形の面積を求める\ndouble heron(double a, double b, double c)\n{\n    double s = (a + b + c) / 2;\n\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// p1-p2の線分の長さを求める\ndouble distPP(P p1, P p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n// 線分p1-p2と点qの長さを求める\ndouble distLP(P p1, P p2, P q)\n{\n    if ((p2 - p1).dot(q - p1) < 0.0)\n    {\n        return distPP(p1, q);\n    }\n    if ((p1 - p2).dot(q - p2) < 0.0)\n    {\n        return distPP(p2, q);\n    }\n    return abs((p2 - p1).det(q - p1) / distPP(p2, p1));\n}\n\n//線分p1-p2とq1-q2が交差しているならtrue、そうでないならfalse\nbool isCrossed(P p1, P p2, P q1, P q2)\n{\n    P pi = intersection(p1, p2, q1, q2);\n    return (on_seg(p1, p2, pi) && on_seg(q1, q2, pi));\n}\n\n//線分p1-p2とq1-q2の最小距離を求める\ndouble distLL(P p1, P p2, P q1, P q2)\n{\n    if (isCrossed(p1, p2, q1, q2))\n    {\n        return 0.0;\n    }\n    else\n    {\n        return min({distLP(p1, p2, q1), distLP(p1, p2, q2), distLP(q1, q2, p1), distLP(q1, q2, p2)});\n    }\n}\ndouble distLL(Seg s1, Seg s2)\n{\n    return distLL(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble deg2rad(int n)\n{\n    return (double)n * M_PI / 180.0;\n}\n\nstruct Star\n{\n    double x, y, a, r;\n    P p[5];\n    Seg s[5];\n    Star(){};\n\n    Star(double x, double y, double a, double r) : x(x), y(y), a(a), r(r)\n    {\n        rep(i, 5)\n        {\n            p[i] = P(x + r * cos(deg2rad(90 + a + 72 * i)), y + r * sin(deg2rad(90 + a + 72 * i)));\n        }\n        rep(i, 5)\n        {\n            s[i] = Seg(p[i], p[(i + 2) % 5]);\n        }\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    while (true)\n    {\n        int n, m, l;\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        Star star[n];\n        rep(i, n)\n        {\n            double x, y, a, r;\n            cin >> x >> y >> a >> r;\n            star[i] = Star(x, y, a, r);\n        }\n        double dist[n][n];\n\n        rep(i, n) rep(j, n)\n        {\n            dist[i][j] = 101010.0;\n            rep(a, 5) rep(b, 5)\n            {\n                dist[i][j] = min(dist[i][j], distLL(star[i].s[a], star[j].s[b]));\n            }\n        }\n        rep(i, n) rep(j, n) rep(k, n)\n        {\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n        rep(i, n) rep(j, n) rep(k, n)\n        {\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n        rep(i, n) rep(j, n) rep(k, n)\n        {\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n\n        cout << setprecision(16) << dist[l - 1][m - 1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n\ndouble dot(P a, P b) { return (a.real() * b.real() + a.imag() * b.imag()); }\ndouble det(P a, P b) { return (a.real() * b.imag() - a.imag() * b.real()); }\n\nint n, m, l, x[100], y[100], a[100], r[100];\n\nP p[100][5];\ndouble d[100][100];\n\ndouble distanceLSP(P a, P b, P c) {\n  if (dot(b-a, c-a) < EPS) return abs(c-a);\n  if (dot(a-b, c-b) < EPS) return abs(c-b);\n  return abs(det(b-a, c-a)) / abs(b-a);\n}\n\nbool isIntersectedLS(P a1, P a2, P b1, P b2) {\n  if (EQ(det(a1-a2, b1-b2), 0.0)) {\n    if (abs(a1-b1) + abs(a2-b1) < abs(a1-a2) + EPS) return true;\n    if (abs(a1-b2) + abs(a2-b2) < abs(a1-a2) + EPS) return true;\n    return false;\n  }\n  return (det(a2-a1, b1-a1) * det(a2-a1, b2-a1) < EPS) &&\n         (det(b2-b1, a1-b1) * det(b2-b1, a2-b1) < EPS);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d%d\", &n, &m, &l);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &a[i], &r[i]);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 5; j++) {\n        double S = (double)(a[i] + 72 * j) * M_PI / 180;\n        p[i][j] = P(x[i] - r[i] * sin(S), y[i] + r[i] * cos(S));\n      }\n    }\n    for (int i = 0; i < n; i++) d[i][i] = 0.0;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        double temp = distanceLSP(p[i][0], p[i][2], p[j][0]);\n        for (int k = 0; k < 5; k++) {\n          for (int z = 0; z < 5; z++) {\n            temp = min(temp, distanceLSP(p[i][k], p[i][(k + 2) % 5], p[j][z]));\n            temp = min(temp, distanceLSP(p[i][k], p[i][(k + 3) % 5], p[j][z]));\n            temp = min(temp, distanceLSP(p[j][k], p[j][(k + 2) % 5], p[i][z]));\n            temp = min(temp, distanceLSP(p[j][k], p[j][(k + 3) % 5], p[i][z]));\n            if (isIntersectedLS(p[i][k], p[i][(k + 2) % 5], p[j][z], p[j][(z + 2) % 5])) temp = 0.0, k = 5, z = 5;\n            if (isIntersectedLS(p[i][k], p[i][(k + 3) % 5], p[j][z], p[j][(z + 2) % 5])) temp = 0.0, k = 5, z = 5;\n            if (isIntersectedLS(p[i][k], p[i][(k + 2) % 5], p[j][z], p[j][(z + 3) % 5])) temp = 0.0, k = 5, z = 5;\n            if (isIntersectedLS(p[i][k], p[i][(k + 3) % 5], p[j][z], p[j][(z + 3) % 5])) temp = 0.0, k = 5, z = 5;\n          }\n        }\n        d[i][j] = d[j][i] = temp;\n      }\n    }\n    for (int k = 0; k < n; k++)\n      for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    printf(\"%.9f\\n\", d[m-1][l-1]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\nvector<P> get_p(P a,double d,double r){\n  vector<P> res(5);\n  d=(d/360)*2*M_PI;\n  P p=P(0,r)*P(cos(d),sin(d));\n  res[0]=p+a;\n  d=2*M_PI/5;\n  for(int i=1;i<=4;i++){\n    p=p*P(cos(d),sin(d));\n    res[i]=p+a;\n  }\n  return res;\n}\n\n\ndouble G[N][N],x[N],y[N],d[N],r[N];\ndouble get_dis(int a,int b){\n  vector<P> A=get_p(P(x[a],y[a]),d[a],r[a]);\n  vector<P> B=get_p(P(x[b],y[b]),d[b],r[b]);\n  double res=1e9;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      res=min(res,getDistanceSS(L(A[i],A[(i+2)%5]),L(B[j],B[(j+2)%5])));\n  return res;\n}\n\nint main(){\n  while(1){\n  int n,s,g;\n  cin>>n>>s>>g;\n  if(!n&&!s&&!g)break;\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++)G[i][j]=1e9;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>d[i]>>r[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)G[i][j]=get_dis(i,j);\n  \n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  printf(\"%.20f\\n\",G[s-1][g-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nusing P = complex<double>;\nusing L = pair<P,P>;\nusing Poly = vector<P>;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-10, pi = acos(-1), INF = 1e9;\n\ndouble dot(const P a, const P b){ return a.X*b.X+a.Y*b.Y;}\ndouble cross(const P a, const P b){ return a.X*b.Y-a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a, c -= a;\n  if(cross(b,c) > EPS) return +1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < 0) return 2;\n  if(norm(b) + EPS < norm(c)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  P af = a.first, as = a.second, bf = b.first, bs = b.second;\n  return (ccw(af,as,bf)*ccw(af,as,bs) <= 0 and ccw(bf,bs,af)*ccw(bf,bs,as) <= 0);\n}\n\ndouble ps_dist(P a, L s){\n  P sf = s.first, ss = s.second;\n  if(dot(ss-sf,a-sf) >= 0 and dot(sf-ss,a-ss) >= 0)\n    return abs(cross(sf-ss,a-ss))/abs(sf-ss);\n  return min(abs(a-sf),abs(a-ss));\n}\n\ndouble ss_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  P af = a.first, as = a.second, bf = b.first, bs = b.second;\n  return min({ps_dist(af,b),ps_dist(as,b),ps_dist(bf,a),ps_dist(bs,a)});\n}\n\ndouble polpol_dist(Poly a, Poly b){\n  int N = a.size(), M = b.size();\n  double ret = INF;\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j){\n      ret = min(ret,ss_dist(L(a[i],a[(i+1)%N]),L(b[j],b[(j+1)%M])));\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L, N){\n    --M,--L;\n    vector<Poly> S(N);\n    Poly star;\n    P s(0,1);\n    star.push_back(s);\n    for(int i = 0; i < 4; ++i){\n      s *= P(cos(pi*0.8),sin(pi*0.8));\n      star.push_back(s);\n    }\n    //for(auto c : star) cerr << c << endl;\n    //return 0;\n    for(int i = 0; i < N; ++i){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      P t(r*cos(a/180*pi),r*sin(a/180*pi));\n      for(int j = 0; j < 5; ++j){\n        S[i].push_back(t*star[j] + P(x,y));\n      }\n    }\n    vector<vector<double>> D(N,vector<double>(N,INF));\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n        D[i][j] = polpol_dist(S[i],S[j]);\n      }\n    }\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          D[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n        }\n      }\n    }\n    printf(\"%.12f\\n\",D[M][L]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\nstruct star{\n    double a,r;\n    point<double> p[5];\n};\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        star S[100];\n        for(int i = 0; i < n; i++){\n\t\t\tpoint<double> c;\n            scanf(\"%lf%lf%lf%lf\",&c.x,&c.y,&S[i].a,&S[i].r);\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            for(int j = 0; j < 5; j++) S[i].p[j] += c;\n        }\n\n\t\tP pt[100][5];\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < 5; j++){\n\t\t\t\tpt[i][j] = S[i].p[j];\n            }\n        }\n\n   \n        int f1[]={0,2,4,1,3,0};\n   \n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    segment<double> s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    segment<double> t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nusing Point = complex<double>;\n\nstruct DualPoint : public pair<Point, Point> {\n    using pair<Point, Point>::pair;\n\n    Point& operator [](size_t idx) {\n        return idx == 0 ? first : second;\n    }\n    \n    const Point& operator [](size_t idx) const {\n        return idx == 0 ? first : second;\n    }\n};\n\nstruct Line : public DualPoint {\n    using DualPoint::DualPoint;\n};\n\nstruct Seg : public DualPoint {\n    using DualPoint::DualPoint;\n};\n\nconst double eps = 1e-6;\nconst long double pi = 3.14159265358979323846264338327950288419716939937510L;\n\ndouble dot(const Point &a, const Point &b) {\n    return (conj(a) * b).real();\n}\n\ndouble cross(const Point &a, const Point &b) {\n    return (conj(a) * b).imag();\n}\n\nenum ccwd {\n    Clock = -1,\n    CoClock = 1,\n    CAB = 2,\n    ABC = -2,\n    ACB = 0,\n};\n\nccwd ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    double p, q;\n    {\n        auto tmp = conj(b) * c;\n        p = tmp.real();\n        q = tmp.imag();\n    }\n    if (0 < q) return CoClock;\n    if (q < 0) return Clock;\n    if (p < 0) return CAB;\n    if (norm(b) < norm(c)) return ABC;\n    return ACB;\n}\n\nbool is_zero(double a) {\n    return abs(a) <= eps;\n}\n\nbool is_parallel(const Line &l1, const Line &l2) {\n    return is_zero(cross(l1[1] - l1[0], l2[1] - l2[0]));\n}\n\nbool is_same_line(Point o, Point a, Point b) {\n    return is_zero(cross(a - o, b - o));\n}\n\nbool intersect(const Line &p, const Line &q) {\n    if (!is_parallel(p, q)) return true;\n    return is_same_line(p[0], p[1], q[1]);\n}\n\nbool intersect(const Line &l, const Seg &s) {\n    double a = cross(l[1] - l[0], s[0] - l[0]);\n    double b = cross(l[1] - l[0], s[1] - l[0]);\n    return a * b < 0;\n}\n\nbool intersect(const Seg &p, const Seg &q) {\n    bool pf = (ccw(p[0], p[1], q[0]) * ccw(p[0], p[1], q[1])) <= 0;\n    bool qf = (ccw(q[0], q[1], p[0]) * ccw(q[0], q[1], p[1])) <= 0;\n    return pf && qf;\n}\n\nbool intersect(const Line &l, const Point &p) {\n    return is_same_line(p, l[0], l[1]);\n}\n\nbool intersect(const Seg &s, const Point &p) {\n    double l1 = abs(s[0] - s[1]);\n    double l2 = abs(s[0] - p);\n    double l3 = abs(s[1] - p);\n    return is_zero(l2 + l3 - l1);\n}\n\n// projection from p to l\nPoint proj(const Line &l, const Point &p) {\n    double mul = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);  // cos(theta) / (p-l[0]).norm()\n    return l[0] + mul * (l[1] - l[0]);\n}\n\nPoint refl(const Line &l, const Point &p) {\n    Point pr = proj(l, p);\n    return p + (2. * (pr - p));\n}\n\ndouble distance(const Line &l, const Point &p) {\n    return abs(p - proj(l, p));\n}\n\ndouble distance(const Line &p, const Line &q) {\n    if (is_parallel(p, q)) return distance(p, q[0]);\n    return 0;\n}\n\ndouble distance(const Line &l, const Seg &s) {\n    if (intersect(l, s)) return 0;\n    return min(distance(l, s[0]), distance(l, s[1]));\n}\n\ndouble distance(const Seg &s, const Point &p) {\n    Line l(s[0], s[1]);\n    Point pr = proj(l, p);\n    if (intersect(s, pr)) return abs(pr - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distance(const Seg &p, const Seg &q) {\n    if (intersect(p, q)) return 0;\n    return var_min(distance(p, q[0]), distance(p, q[1]),\n                   distance(q, p[0]), distance(q, p[1]));\n}\n\ndouble fix_arg(double arg) {\n    arg += 2 * pi;\n    if (2 * pi <= arg) arg -= 2 * pi;\n    return arg;\n}\n\nbool comp_coclock(const Point &p1, const Point &p2) {\n    return fix_arg(arg(p1)) < fix_arg(arg(p2));\n}\n\nPoint rotate(const Point &p, double arg) {\n    complex<double> r(cos(arg), sin(arg));\n    return p * r;\n}\n\nstruct Star {\n    const static size_t line_sz = 5 * 4 / 2 - 5;\n    array<Point, 5> points;\n    array<Seg, line_sz> lines;\n    double x, y, r;\n\n    Star(double x, double y, double a, double r) : x(x), y(y), r(r) {\n        a = a / 360 * 2 * pi + pi / 2;\n        points[0] = rotate(Point(r, 0), a);\n        for (int i = 1; i < 5; i++) points[i] = rotate(points[i - 1], 2 * pi / 5);\n        sort(ALL(points), comp_coclock);\n        for (auto &&e : points) e += Point(x, y);\n        size_t idx = 0;\n        for (int i = 0; i < 5; i++) for (int j = i + 2; j < (i == 0 ? 4 : 5); j++) lines[idx++] = Seg(points[i], points[j]);\n    }\n};\n\ndouble distance(const Star &p, const Star &q) {\n    double ret = numeric_limits<double>::max();\n    for (auto &&s1 : p.lines) for (auto &&s2 : q.lines) {\n        chmin(ret, distance(s1, s2));\n    }\n    return ret;\n}\n\ndouble mat[100][100];\nusing Dist = pair<double, ll>;\n\nbool solve() {\n    ll N, M, L;\n    cin >> N >> M >> L;\n    if (!(N + M + L)) return false;\n    M--; L--;\n    V<Star> stars;\n    for (ll i = 0; i < N; i++) {\n        double x, y, a, r;\n        cin >> x >> y >> a >> r;\n        stars.emplace_back(x, y, a, r);\n    }\n\n    for (ll i = 0; i < N; i++) for (ll j = i + 1; j < N; j++) {\n        double d = distance(stars[i], stars[j]);\n        mat[i][j] = mat[j][i] = d;\n    }\n\n    V<double> dists(N, numeric_limits<double>::max());\n    priority_queue<Dist, V<Dist>, greater<Dist>> pq;\n    dists[M] = 0;\n    pq.emplace(0, M);\n    while (pq.size()) {\n        double d;\n        ll cur;\n        tie(d, cur) = pq.top();\n        pq.pop();\n        if (eps < d - dists[cur]) continue;\n        for (ll nxt = 0; nxt < N; nxt++) {\n            double c = mat[cur][nxt];\n            double nd = d + c;\n            if (!(eps < dists[nxt] - nd)) continue;\n            dists[nxt] = nd;\n            pq.emplace(nd, nxt);\n        }\n    }\n\n    cout << dists[L] << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<complex>\n#define INF 10000000.0\n#define pb push_back\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> Point;\ntypedef pair<double ,int > P;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real( conj(a) * b );\n}\ndouble cross(Point a, Point b){\n    return imag( conj(a) * b );\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a)<=0 ) return abs(c-a);\n  if ( dot(a-b, c-b)<=0 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble cal(int a,int b){\n\tdouble ret=INF;\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=i+1;j<5;j++){\n\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t//cout<<distance_ls_p(p[a][i],p[a][j],p[b][k])<<endl;\n\t\t\t\t//cout<<distance_ls_p(p[b][i],p[b][j],p[a][k])<<endl;\n\t\t\t\tdouble u=distance_ls_p(p[a][i],p[a][j],p[b][k]),v=distance_ls_p(p[b][i],p[b][j],p[a][k]);\n\t\t\t\tif(ret>u)\n\t\t\t\tret=u;\n\t\t\t\tif(ret>v)\n\t\t\t\tret=v;\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<ret<<endl;\n\treturn ret;\n}\n\n\n\nint main(){\n\twhile(cin>>n>>s>>g,n||s||g){\n\t\tp.clear();\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,a,r;\n\t\t\tPoint pot;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tPoint c=Point(x,y);\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tp[i].pb(c+polar(r,PI*(a+(double)j*72.0+90.0)/180.0));\n\t\t\t}\n\t\t}\n\t\t//cout<<\"      \"<<distance_ls_p(p[0][4],p[0][1],p[2][2])<<endl;\n\n\t\t\n\t\tvector<vector<double> > cost(n,vector<double>(n,INF));\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble a=cal(i,j);\n\t\t\t\tcost[i][j]=a;\n\t\t\t\tcost[j][i]=a;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcout<<cost[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,s-1));\n\t\tvector<double> d(n,INF);\n\t\td[s-1]=0;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();\n\t\t\tint pos=q.second;\n\t\t\tdouble dist=q.first;\n\t\t\tque.pop();\n\t\t\tif(pos==g-1){\n\t\t\t\tprintf(\"%.8lf\\n\",dist);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dist>d[pos]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\n\t\t\t\tif(cost[pos][i]==INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cost[pos][i]+dist<d[i]){\n\t\t\t\t\tque.push(P(cost[pos][i]+dist,i));\n\t\t\t\t\td[i]=cost[pos][i]+dist;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<cassert>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main() {\n\tld n, m, l;\n\twhile (scanf(\"%Le %Le %Le\",&n,&m,&l), n) {\n\t\tvector<vector<Line>>star(n, vector<Line>(5));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tld x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<Point>s(5);\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\ts[j] = Point(x + r * sin(-a/180*pi), y + r * cos(a/180*pi));\n\t\t\t\ta += 144;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tstar[i][j] = Line(s[j], s[j + 1]);\n\t\t\t}\n\t\t\tstar[i][4] = Line(s[4], s[0]);\n\t\t}\n\t\tvector<vector<ld>>cost(n, vector<ld>(n,(ld)0));\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tld ma=(ld)9999.999999999;\n\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\tfor (int li = 0; li < 5; li++) {\n\t\t\t\t\t\tma =min(ma, dist_ss(star[i][k], star[j][li]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcost[i][j] = cost[j][i] = ma;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\tif (cost[j][k] > cost[j][i] + cost[k][i])cost[j][k] = cost[j][i] + cost[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.20Lf\\n\", cost[m - 1][l - 1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\n/* 基本要素 */\n\n#define X real()\n#define Y imag()\n\nusing Double = double;\nusing Point = complex<Double>;\nusing Line = pair<Point, Point>;\nusing Polygon = vector<Point>;\n\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\nconst Double INF = numeric_limits<Double>::max();\n\n// 正，負，ゼロの判定\nint sgn(Double x) {\n  return x < -EPS ? -1 : x > +EPS ? 1 : 0;\n}\n// 内積\nDouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n// 外積\nDouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (sgn(cross(b,c))    > 0) return +1; // counter clockwise\n  if (sgn(cross(b,c))    < 0) return -1; // clockwise\n  if (sgn(dot(b,c))      < 0) return +2; // c--a--b on line\n  if (sgn(abs(b)-abs(c)) < 0) return -2; // a--b--c on line or a==b\n  return 0;                              // a--c--b on line or a==c or b==c\n}\n// ベクトルの回転（xはラジアン）\nPoint rotated(Point a, double x) {\n  return Point(a.X*cos(x)-a.Y*sin(x), a.X*sin(x)+a.Y*cos(x));\n}\n\n/* 交差判定 */\n\n// 直線と点\nbool isecLP(Point a1, Point a2, Point b) {\n  return abs(ccw(a1, a2, b)) != 1;\n}\n// 線分と点\nbool isecSP(Point a1, Point a2, Point b) {\n  return !ccw(a1, a2, b);\n}\n// 直線と直線（交差もしくは重なる）\nbool isecLL(Point a1, Point a2, Point b1, Point b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n// 直線と線分\nbool isecLS(Point a1, Point a2, Point b1, Point b2) {\n  return sgn(cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1)) <= 0;\n}\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n/* 距離 */\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n// 点pの直線aへの反射点を返す\nPoint reflection(Point a1, Point a2, Point p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nDouble distLP(Point a1, Point a2, Point p) {\n  return abs(proj(a1, a2, p) - p);\n}\nDouble distSP(Point a1, Point a2, Point p) {\n  Point r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\nDouble distLL(Point a1, Point a2, Point b1, Point b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\nDouble distLS(Point a1, Point a2, Point b1, Point b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\nDouble distSS(Point a1, Point a2, Point b1, Point b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n// 2直線の交点\nPoint crossPointLL(Point a1, Point a2, Point b1, Point b2) {\n  Double d1 = cross(b2-b1, b1-a1);\n  Double d2 = cross(b2-b1, a2-a1);\n  if (!sgn(d1) && sgn(d2)) return a1;    // same line\n  if (!sgn(d2)) throw \"No cross point\";  // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n\nint N, M, L;\nPoint ps[110][5];\nLine es[110][5];\nDouble dis[110][110];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> N >> M >> L, N) {\n    for (int i = 0; i < N; i++) {\n      int x, y, a, r;\n      cin >> x >> y >> a >> r;\n      Point o(x, y);\n      Point p = rotated(Point(0,r), PI*a/180);\n      for (int j = 0; j < 5; j++) {\n        ps[i][j] = o + p;\n        p = rotated(p, 2*PI/5);\n      }\n      for (int j = 0; j < 5; j++) {\n        es[i][j] = Line(ps[i][j], ps[i][(j+2)%5]);\n      }\n    }\n\n    fill_n((Double*)dis, 110*110, INF);\n    for (int i = 0; i < N; i++) {\n      for (int j = i; j < N; j++) {\n        Double tmp = INF;\n        for (int k = 0; k < 5; k++) {\n          for (int l = 0; l < 5; l++) {\n            tmp = min(tmp, distSS(es[i][k].first, es[i][k].second, es[j][l].first, es[j][l].second));\n          }\n        }\n        dis[i][j] = dis[j][i] = tmp;\n      }\n    }\n\n    for (int k = 0; k < N; k++) {\n      for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n          dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);\n        }\n      }\n    }\n    cout << dis[M-1][L-1] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define PI acos(-1)\n\n\n\n\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL() {}\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\n\nint N, M, LL;\nvector<P> star[100];\ndouble d[100][100];\n\ndouble dist(int a, int b)\n{\n\tvector<L> aa, bb;\n\n\trep(i, 0, 5) aa.push_back(L(star[a][(i * 2) % 5], star[a][((i + 1) * 2) % 5]));\n\trep(i, 0, 5) bb.push_back(L(star[b][(i * 2) % 5], star[b][((i + 1) * 2) % 5]));\n\n\tdouble ret = INF;\n\trep(i, 0, 5) rep(j, 0, 5) ret = min(ret, distanceSS(aa[i], bb[j]));\n\treturn ret;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> M >> LL)\n\t{\n\t\tif (N == 0) return 0;\n\t\tM--; LL--;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstar[i].clear();\n\n\t\t\tdouble x, y, a, r; cin >> x >> y >> a >> r;\n\t\t\trep(j, 0, 5)\n\t\t\t{\n\t\t\t\tdouble thi = j * 72;\n\t\t\t\tdouble xx = -r * sin((a + thi) / 180.0 * PI) + x;\n\t\t\t\tdouble yy = r * cos((a + thi) / 180.0 * PI) + y;\n\t\t\t\tstar[i].push_back(P(xx, yy));\n\t\t\t}\n\t\t}\n\n\t\trep(i, 0, N) rep(j, 0, N) d[i][j] = INF;\n\t\trep(i, 0, N) d[i][i] = 0;\n\t\trep(i, 0, N) rep(j, i + 1, N) d[i][j] = d[j][i] = dist(i, j);\n\n\t\trep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\tprintf(\"%.10f\\n\", d[M][LL]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace Geometry{\n    using namespace std;\n    using ld=long double;\n    using Point=complex<ld>;\n    const ld PI=acos(-1);\n    struct Line{\n        Point a,b;\n    };\n\n    struct Circle{\n        Point p;\n        ld r;\n    };\n    const ld EPS=1e-8;\n    inline bool EQ(Point a,Point b){return abs(a-b)<EPS;}\n    ld dot(Point a,Point b){return real(a)*real(b)+imag(a)*imag(b);}\n    ld cross(Point a,Point b){return real(a)*imag(b)-imag(a)*real(b);}\n\n    const int CCW=1;\n    const int CW=-1;\n    const int BAC=2;\n    const int ACB=-2;\n    const int ABC=0;\n    int ccw(Point a,Point b,Point c){\n        b-=a,c-=a;\n        if(cross(b,c)>EPS) return CCW; // counter clockwise\n        if(cross(b,c)<-EPS) return CW; //clockwise\n        if(dot(b,c)<-EPS) return BAC; //b-a-c\n        if(abs(b)<abs(c)) return ACB; //a-c-b\n        return ABC; //a-b-c (abs(b)>abs(c))\n    }\n    ld dist_lp(Line l,Point p){\n        Point x=l.b-l.a;\n        Point y=p-l.a;\n        return abs(cross(x,y))/abs(x);\n    }\n    ld dist_sp(Line l,Point p){\n        if(dot(p-l.a,l.b-l.a)<EPS) return abs(p-l.a);\n        if(dot(p-l.b,l.a-l.b)<EPS) return abs(p-l.b);\n        return dist_lp(l,p);\n    }\n    bool isis_ss(Line x,Line y){\n        return ccw(x.a,x.b,y.a)*ccw(x.a,x.b,y.b)<=0 && ccw(y.a,y.b,x.a)*ccw(y.a,y.b,x.b)<=0;\n    }\n    ld dist_ss(Line x,Line y){\n        if(isis_ss(x,y)) return 0;\n        ld a=min(dist_sp(x,y.a),dist_sp(x,y.b));\n        ld b=min(dist_sp(y,x.a),dist_sp(y,x.b));\n        return min(a,b);\n    }\n}\n\nusing namespace Geometry;\n\nld solve(int n,int m,int l){\n    vector<array<Line,5>> stars(n);\n    for(int i=0;i<n;i++){\n        ld x,y,a,r;\n        cin>>x>>y>>a>>r;\n        ld theta=(a+90.)/180.*PI;\n        ld delta=ld(72)/180.*PI;\n        for(int j=0;j<5;j++){\n            Point p0={x+r*cos(theta+j*delta),y+r*sin(theta+j*delta)};\n            Point p1={x+r*cos(theta+(j+2)*delta),y+r*sin(theta+(j+2)*delta)};\n            stars[i][j]=Line{p0,p1};\n        }\n    }\n    const ld INF=1e18;\n    vector<vector<ld>> dist(n,vector<ld>(n,INF));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i==j){\n                dist[i][j]=0;\n                continue;\n            }\n            for(int ki=0;ki<5;ki++){\n                for(int kj=0;kj<5;kj++){\n                    dist[i][j]=min(dist[i][j],dist_ss(stars[i][ki],stars[j][kj]));\n                }\n            }\n        }\n    }\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n    return dist[m][l];\n}\nint main(){\n    int n,m,l;\n    cout<<setprecision(10)<<fixed;\n    while(cin>>n>>m>>l,n){\n        m--,l--;\n        cout<<solve(n,m,l)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\n\nvoid solve(){\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l;\n        if (n == 0) return;\n        m--; l--;\n        long double dist[100][100] = {};\n        vector<vector<Point>> inputs;\n        REP(i, n) {\n            long double x, y, a, r;\n            cin >> x >> y >> a >> r;\n            Point base{ x,y };\n            a += 90;\n            Point add{ r * cos(a / 180.0L * M_PI),r * sin(a / 180.0L * M_PI) };\n            inputs.push_back(vector<Point>{});\n            REP(q, 7) {\n                inputs.back().push_back(base + add);\n                add *= Point{ cos(144.0L / 180.0L * M_PI),sin(144.0L / 180.0L * M_PI) };\n            }\n        }\n        REP(i, n) {\n            REP(q, n) {\n                if (i == q) continue;\n                dist[i][q] = 1e9;\n                REP(j, inputs[i].size() - 1) {\n                    REP(t, inputs[q].size() - 1) {\n                        dist[i][q] = min(dist[i][q], Dist_Line_Line(Line{ inputs[i][j],inputs[i][j + 1] }, Line{ inputs[q][t],inputs[q][t + 1] }));\n                    }\n                }\n            }\n        }\n        REP(i, 3) {\n            REP(q, n) {\n                REP(j, n) {\n                    REP(t, n) {\n                        dist[q][j] = min(dist[q][j], dist[q][t] + dist[t][j]);\n                    }\n                }\n            }\n        }\n        cout << dist[m][l] << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\n\nint N,S,T;\nstruct NODE{\n\tint to;\n\tdouble cost;\n\tNODE(int to,double cost) : to(to) , cost(cost) {};\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\ndouble PI = acos(-1);\nP rotate(P a,double t){\n\tdouble x = a.real();\n\tdouble y = a.imag();\n\treturn P( x * cos(t) - y * sin(t) , y * cos(t) + x * sin(t) );\n}\n\nint main(){\n\twhile(cin >> N >> S >> T && N){\n\t\tS--,T--;\n\t\tvector<NODE> g[100];\n\t\tvector<L> se[100];\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tP c;\n\t\t\tdouble a,r;\n\t\t\tcin >> c.real() >> c.imag() >> a >> r;\n\t\t\ta = PI / 180 * a;\n\t\t\tP A = P(0,r);\n\t\t\tP B = rotate(A,2*PI/5);\n\t\t\tP C = rotate(B,2*PI/5);\n\t\t\tP D = rotate(C,2*PI/5);\n\t\t\tP E = rotate(D,2*PI/5);\n\t\t\tP F = rotate(E,2*PI/5);\n\t\t\t//cout << A << \" \" << B << \" \" << C << \" \" << D << \" \" << E << \" \" << F << endl;\n\t\t\tA = c + rotate(A,a);\n\t\t\tB = c + rotate(B,a);\n\t\t\tC = c + rotate(C,a);\n\t\t\tD = c + rotate(D,a);\n\t\t\tE = c + rotate(E,a);\n\t\t\tse[i].push_back(L(A,C));\n\t\t\tse[i].push_back(L(A,D));\n\t\t\tse[i].push_back(L(B,D));\n\t\t\tse[i].push_back(L(B,E));\n\t\t\tse[i].push_back(L(C,E));\n\t\t}\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tdouble ans = INF;\n\t\t\t\tfor(int k = 0 ; k < 5 ; k++){\n\t\t\t\t\tfor(int l = 0 ; l < 5 ; l++){\n\t\t\t\t\t\tans = min(distanceSS(se[i][k],se[j][l]),ans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg[i].push_back(NODE(j,ans));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint done[100]={};\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(S,0));\n\t\twhile(Q.size()){\t\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to]++ ) continue;\n\t\t\tif( q.to == T ){\n\t\t\t\tprintf(\"%.10lf\\n\",q.cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-9, pi = acos(ld(-1.0));\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\n// Line\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\n// counter clockwise\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\n// 点pから直線lに下ろした垂線の足\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\n// 直線lと線分mが交点を持つか\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点pが線分s上に存在するか\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\n// 線分sと点pの距離\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分sと線分tの距離\nld dist_ss(L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  return min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nstruct Star {\n  vector<L> lines;\n};\n\nld d(Star s1, Star s2) {\n  ld mind = 1000000000.0;\n  REP(i,5)REP(j,5){\n    mind = min(mind,dist_ss(s1.lines[i],s2.lines[j]));\n  }\n  return mind;\n}\n\nint main() {\n  while(1){\n    int n,m,l;\n    cin>>n>>m>>l;\n    --m;--l;\n    vector<Star> s;\n    if(!n)break;\n    REP(i,n){\n      ld x,y,a,r;\n      cin>>x>>y>>a>>r;\n      P p = polar<ld>(r, a/180.0*pi+pi/2.0);\n      P c(x,y);\n      Star st;\n      REP(j,5){\n        st.lines.emplace_back(p*polar<ld>(1.0,2.0*j*pi/2.5)+c,p*polar<ld>(1.0,2.0*(j+2)*pi/2.5)+c);\n      }\n      s.push_back(st);\n    }\n    vector<vector<ld>> dist(n,vector<ld>(n));\n    REP(i,n)REP(j,n){\n      if(i==j){\n        dist[i][j]=0.0;\n      }else{\n        dist[i][j] = d(s[i],s[j]);\n      }\n    }\n    REP(k,n)REP(i,n)REP(j,n)\n      dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n    cout << setprecision(15) << fixed << dist[m][l] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <complex>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef complex<double> P;\n#define INF (1e100)\n#define EPS (1e-10)\nconst double pi = atan2(0.0, -1.0);\n\nP unit(double t) { return P(cos(t), sin(t)); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if (cross(b, c) > 0) return 1;\n    if (cross(b, c) < 0) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersectSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    return ccw(s0, s1, t0) * ccw(s0, s1, t1) <= 0\n        && ccw(t0, t1, s0) * ccw(t0, t1, s1) <= 0;\n}\nbool intersectSP(const P& s0, const P& s1, const P& p) {\n    return abs(s0-p) + abs(s1-p) - abs(s1-s0) < EPS;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    const double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r = projection(s0, s1, p);\n    if (intersectSP(s0, s1, r)) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if (intersectSS(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint N, M, L;\nP ps[128][8];\ndouble xs[128], ys[128], as[128], rs[128];\ndouble g[128][128], dp[128];\nint vis[128];\n\ndouble solve() {\n    rep (i, N) dp[i] = INF;\n    rep (i, N) vis[i] = 0;\n    dp[M] = 0;\n    rep (i, N) {\n        int at = -1;\n        rep (i, N) if (vis[i] == 0) at = i;\n        rep (i, N) if (vis[i] == 0 && dp[i] < dp[at]) at = i;\n        vis[at] = 1;\n        rep (i, N) if (vis[i] == 0) dp[i] = min(dp[i], dp[at] + g[at][i]);\n    }\n    return dp[L];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &N, &M, &L);\n        if (N == 0) return 0;\n        M--, L--;\n        rep (i, N) scanf(\"%lf%lf%lf%lf\", xs+i, ys+i, as+i, rs+i);\n        rep (i, N) rep (k, 5) {\n            const double t = (as[i]+90+k*144) * pi / 180.0;\n            ps[i][k] = P(xs[i], ys[i]) + rs[i] * unit(t);\n        }\n        rep (i, N) rep (j, i) {\n            g[i][j] = g[j][i] = INF;\n            rep (a, 5) rep (b, 5) {\n                const double d = distanceSS(ps[i][a], ps[i][(a+1)%5],\n                                            ps[j][b], ps[j][(b+1)%5]);\n                g[i][j] = g[j][i] = min(g[i][j], d);\n            }\n        }\n        printf(\"%.9f\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nbool operator < (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() < r.imag() : l.real() < r.real();\n}\n\nbool operator > (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() > r.imag() : l.real() > r.real();\n}\n\nP rotate(P const& v, Real s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s));\n}\n\nbool equals(Real a, Real b) {\n  return abs(a - b) < EPS;\n}\n\nbool equals (P const& l, P const& r) {\n  return abs(l - r) < EPS;\n}\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle {\n  P p; Real r;\n  Circle(){}\n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nstruct Polygon : public vector<P> {\n  vector<P>& g = *this;\n  Polygon() = default;\n  Polygon(vector<P> const& g) { this->g = g; }\n  P& operator[] (int x) { return vector<P>::operator[]((x + size()) % size()); }\n  Segment side(int x) { return std::move(Segment(this->operator[](x), this->operator[](x+1))); }\n  Segment backside(int x) { return std::move(Segment(this->operator[](x), this->operator[](x-1))); }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersect_ss(Segment const& s, Segment const& t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= EPS &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= EPS;\n}\n\nbool intersect_ll(Line const& l, Line const& m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nbool intersect_ls(Line const& l, Segment const& s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP reflection(Line const& l, P const& p) {\n  return p + (Real)2.0 * (projection(l, p) - p);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_ss(Segment const& s, Segment const& t) {\n  if (intersect_ss(s, t)) return 0;\n  return min(min(distance_sp(s, t[0]), distance_sp(s, t[1])),\n             min(distance_sp(t, s[0]), distance_sp(t, s[1])));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nbool intersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c.p) <= c.r + EPS;\n}\n\nbool intersect_cs(Circle const& c, Line const& l) {\n  if(abs(l[0] - c.p) < c.r - EPS && abs(l[1] - c.p) < c.r - EPS) { return false; }\n  return distance_lp(l, c.p) <= c.r + EPS;\n}\n\nbool intersect_gs(Polygon const& g, Segment const& s) { // not verified\n  auto u = const_cast<Polygon&>(g);\n  rep(i, g.size()) {\n    if(!intersect_sp(s, u[i]) && intersect_ss(s, u.side(i))) { return true; }\n  }\n  return false;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  auto A = cross(l[1] - l[0], m[1] - m[0]);\n  auto B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false && \"PRECONDITION NOT SATISFIED\");\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto h = projection(l, c.p);\n  auto e = (l[1]-l[0]) / abs(l[1]-l[0]);\n  auto base = sqrt(c.r*c.r-abs(h-c.p)*abs(h-c.p));\n  return {h+e*base, h-e*base};\n}\n\npair<P, P> crosspoint(Circle c1, Circle c2) {\n  if(c1.p.real() > c2.p.real()) swap(c1, c2);\n  auto const d = abs(c2.p - c1.p);\n  auto const alpha  = acos((c2.p.real() - c1.p.real()) / d) * ((c1.p.imag() > c2.p.imag()) ? -1.0 : 1.0);\n  auto const beta   = acos((c1.r * c1.r - c2.r * c2.r + d * d) / 2.0 / d / c1.r);\n  return make_pair(c1.p + polar(c1.r, alpha - beta), c1.p + polar(c1.r, alpha + beta));\n}\n \nvector<P> tangent_points(Circle const& c, P const& p) {\n  vector<P> ret;\n  auto const sec2 = norm(p - c.p);\n  auto const tan2 = max(Real(0), sec2 - c.r * c.r);\n  auto const nv = (p - c.p) * c.r * c.r / sec2;\n  auto const pv = (p - c.p) * P(0, -1) * c.r * sqrt(tan2) / sec2;\n  ret.push_back(c.p + nv + pv);\n  ret.push_back(c.p + nv - pv);\n  return ret;\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line const& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint N, M, L;\n\ntypedef vector<Segment> Star;\n\nStar create_star(P const& p, double r, double a) {\n  Star ret;\n  rep(i, 5)\n    ret.emplace_back(\n      p + rotate(P(0, r), (2*M_PI) * (i%5) / 5 + a),\n      p + rotate(P(0, r), (2*M_PI) * ((i+2)%5) / 5 + a)\n    );\n  return ret;\n}\n\ndouble distance_stars(Star const& a, Star const& b) {\n  double min_dist = inf;\n  for(auto const& sa: a) for(auto const& sb: b) {\n    minimize(min_dist, distance_ss(sa, sb));\n  }\n  return min_dist;\n}\n\ntemplate<class T> using PQ_G = priority_queue<T, vector<T>, greater<T>>;\n\nint main() {\n\n  while(cin >> N >> M >> L && N && M && L) {\n    M--, L--;\n\n    vector<Star> stars;\n\n    rep(i, N) {\n      int x, y, a, r; cin >> x >> y >> a >> r;\n      stars.push_back(create_star(P(x, y), r, a / 180. * M_PI));\n    }\n\n    vector<vector<pair<int, double>>> G(N);\n\n    rep(i, N) REP(j, i + 1, N) {\n      double dist = distance_stars(stars[i], stars[j]);\n      G[i].emplace_back(j, dist);\n      G[j].emplace_back(i, dist);\n    }\n\n    vector<double> dist(N, inf);\n\n    PQ_G<pair<double, int>> pq;\n    pq.emplace(0.0, M);\n    dist[M] = 0;\n\n    while(!pq.empty()) {\n      double c; int p; tie(c, p) = pq.top(); pq.pop();\n      if(dist[p] < c - EPS) continue;\n\n      if(p == L) {\n        printf(\"%.20f\\n\", c);\n        break;\n      }\n\n      for(auto e: G[p]) {\n        int to; double w; tie(to, w) = e;\n        if(dist[to] <= c + w) continue;\n        dist[to] = c + w;\n        pq.emplace(dist[to], to);\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\n \nconst double INF=1e77;\nconst double EPS=1e-8;\nconst double PI=acos(-1);\n \ntemplate<class T>\nstruct point{\n    T x,y;\n    point operator+(const point &a)const{ point t = {x+a.x,y+a.y}; return t; }\n    point operator-(const point &a)const{ point t = {x-a.x,y-a.y}; return t; }\n};\n \ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){\n\tpoint<T> p = {c*a.x,c*a.y};\n    return p;\n}\n \npoint<double> rot(const point<double> &a,double theta){\n\tpoint<double> p = {a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)};\n\treturn p;\n}\n \ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n};\n \nstruct star{\n    point<double> c;\n    double a,r;\n    point<double> p[5];\n};\n \ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n \ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n \nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW;\n    if(rdir<-EPS) return CW;\n    return ON;\n}\n \nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n \ntemplate<class T>\nT dist2(const point<T> &a,const point<T> &b){\n    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n \ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n \ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n \nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n        m--;\n        l--;\n \n        star S[100];\n        rep(i,n){\n            scanf(\"%lf%lf%lf%lf\",&S[i].c.x,&S[i].c.y,&S[i].a,&S[i].r);\n        }\n \n        rep(i,n){\n            S[i].p[0].x = 0, S[i].p[0].y = S[i].r;\n            S[i].p[0]=rot(S[i].p[0],S[i].a/180*PI);\n            for(int j=1;j<5;j++){\n                S[i].p[j]=rot(S[i].p[j-1],2*PI/5);\n            }\n            rep(j,5) S[i].p[j]=S[i].p[j]+S[i].c;\n        }\n \n        int f1[]={0,2,4,1,3,0};\n \n        double d[100][100];\n        rep(i,n){\n\t\t\trep(j,n) {\n            d[i][j]=INF;\n            rep(a,5) rep(b,5){\n\t\t\t\tsegment<double> s = {S[i].p[f1[a]],S[i].p[f1[a+1]]};\n\t\t\t\tsegment<double> t = {S[j].p[f1[b]],S[j].p[f1[b+1]]};\n\t\t\t\td[i][j]=min(d[i][j],dist(s,t));\n\t\t\t}\n\t\t\t}\n        }\n \n        rep(k,n) rep(i,n) rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n \n        printf(\"%.15f\\n\",d[m][l]);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<utility>\n#include<queue>\n#include<cmath>\n#include<iomanip>\n\ntypedef long double ld;\ntypedef std::complex<ld> P;\nconst ld eps = 1e-8, pi = acos(-1.0);\nstruct L { P a, b; };\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n      : lhs.real() < rhs.real();\n  }\n}\n\nusing namespace std;\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\n\nP is_ll(L s, L t){\n  P sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nld dist_pp(P p, P q) {\n  return abs(p - q);\n}\n\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  ld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n  ld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n  return min(a, b);\n}\n\nP rotate(ld deg, P p) {\n  ld rad = deg * pi / 180.0;\n  return polar((ld)1.0, rad) * p;\n}\n\nstruct Star { L e[5]; };\n\nld dist_stst(Star s, Star t) {\n  ld val = dist_ss(s.e[0], t.e[0]);\n  for (L ss : s.e) for (L ts : t.e) {\n    val = min(val, dist_ss(ss, ts));\n  }\n  return val;\n}\n\nint main() {\n  int n, m, l;\n  while (cin >> n >> m >> l and n) {\n    m--; l--;\n    vector<Star> stars(n);\n    for (Star &s : stars) {\n      int x, y ,a, r;\n      cin >> x >> y >> a >> r;\n      P center(x, y);\n      for (int i = 0; i < 5; i++) {\n        s.e[i].a = \n          center + polar((ld)r, (90 + a + 72 * i) * pi / 180.0);\n        s.e[i].b = \n          center + polar((ld)r, (90 + a + 72 * (i + 2)) * pi / 180.0);\n      }\n    }\n\n    vector<vector<ld>> dist(n);\n    for (vector<ld> &v : dist) {\n      v.reserve(n);\n    }\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        dist[i][j] = dist_stst(stars[i], stars[j]);\n      }\n    }\n\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    cout << fixed << setprecision(30)<< dist[m][l] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <complex>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef complex<double> P;\n#define INF (1e100)\n#define EPS (1e-10)\nconst double pi = atan2(0.0, -1.0);\n\nP unit(double t) { return P(cos(t), sin(t)); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if (cross(b, c) > 0) return 1;\n    if (cross(b, c) < 0) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersectSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    return ccw(s0, s1, t0) * ccw(s0, s1, t1) <= 0\n        && ccw(t0, t1, s0) * ccw(t0, t1, s1) <= 0;\n}\nbool intersectSP(const P& s0, const P& s1, const P& p) {\n    return abs(s0-p) + abs(s1-p) - abs(s1-s0) < EPS;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    const double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r = projection(s0, s1, p);\n    if (intersectSP(s0, s1, r)) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if (intersectSS(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint N, M, L;\nP ps[128][8];\ndouble xs[128], ys[128], as[128], rs[128];\ndouble g[128][128], dp[128];\nint vis[128];\n\ndouble solve() {\n    rep (i, N) dp[i] = INF;\n    rep (i, N) vis[i] = 0;\n    dp[M] = 0;\n    rep (i, N) {\n        int at = -1;\n        rep (i, N) if (vis[i] == 0) at = i;\n        rep (i, N) if (vis[i] == 0 && dp[i] < dp[at]) at = i;\n        vis[at] = 1;\n        rep (i, N) if (vis[i] == 0) dp[i] = min(dp[i], dp[at] + g[at][i]);\n    }\n    return dp[L];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &N, &M, &L);\n        if (N == 0) return 0;\n        M--, L--;\n        rep (i, N) scanf(\"%lf%lf%lf%lf\", xs+i, ys+i, as+i, rs+i);\n        rep (i, N) rep (k, 5) {\n            const double t = (as[i]+90+k*144) * pi / 180.0;\n            ps[i][k] = P(xs[i], ys[i]) + rs[i] * unit(t);\n        }\n        rep (i, N) rep (j, N) {\n            g[i][j] = INF;\n            rep (a, 5) rep (b, 5) {\n                const double d = distanceSS(ps[i][a], ps[i][(a+1)%5],\n                                            ps[j][b], ps[j][(b+1)%5]);\n                g[i][j] = min(g[i][j], d);\n            }\n        }\n        printf(\"%.9f\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(const P &a, const P &b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNor(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    b -= a; c -= a;\n    int s = sgn(cross(b, c));\n    if (s) return s;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\n//????????¨?????????????°??????¢\nR distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min(min(distSP(s, t.x), distSP(s, t.y)),\n               min(distSP(t, s.x), distSP(t, s.y)));\n}\n\nconst int MN = 110;\nL sl[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P p[5];\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[j] = P(x, y) + polar<R>(r, radNor(deg2rad(aa)));\n            }\n            for (int j = 0; j < 5; j++) {\n                sl[i][j] = L(p[j], p[(j+2)%5]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSS(sl[i][k], sl[j][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\n// XY座標\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-10;\nconst double INF = 1e+12;\nconst double PI = acos(-1.0);\ntypedef complex<double> P;\n\n// 内積(dot product) a・b = |a||b|cosθ \ndouble dot(P a, P b){\n\treturn real( conj(a) * b );\n}\n\n// 外積(cross product) |a×b| = |a||b|sinθ\ndouble cross(P a, P b){\n\treturn imag( conj(a) * b );\n}\n\n// 度からラジアンに変換する.\ndouble to_rad(double deg){\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を a ラジアンだけ回転した点を返す.\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を angle ラジアンだけ回転した点を返す.\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 線分クラス\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){\n\t\ta = a_; b = b_;\n\t}\n\t\n\t// 点 p と線分の距離を返す.\n\tdouble distance(P p){\n\t\tif( dot(b-a,p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b,p-b) < EPS ) return abs(p-b);\n\t\treturn abs( cross(b-a,p-a) ) / abs(b-a) ;\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n\tbool is_intersection(const Segment& s){\n\t\treturn ( cross(b-a,s.a-a) * cross(b-a,s.b-a) < EPS && \n\t\t\t\t cross(s.b-s.a,b-s.a) * cross(s.b-s.a,b-s.a) < EPS );\n\t}\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tdouble A = this->distance(s.a);\n\t\tdouble B = this->distance(s.b);\n\t\tdouble C = s.distance( (*this).a );\n\t\tdouble D = s.distance( (*this).b );\n\t\tif( this->is_intersection( s ) ) { // 交差するとき\t\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) || this->contain(s.b) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}else if( s.contain( a ) || s.contain( b ) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}else{\n\t\t\t\t\treturn min( min(A,B) , min(C,D) );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn min( min(A,B) , min(C,D) );\n\t}\n\t// デバッグ出力\n\tvoid print(){\n\t\tprintf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n\t}\n};\n\nint main(){\n\t// n := 星の数, m := スタート, l := ゴール\n\tint n, m, l;\n\twhile( scanf(\"%d %d %d\", &n, &m, &l) , n || m || l ){\n\t\tm--; l--;\n\t\t// v[i] := i 番目の星 (5つの線分)\n\t\tvector< vector<Segment> > v;\n\t\t \n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r );\n\t\t\tdouble angle = to_rad( a + 90 );\n\t\t\tP p1( x + r*cos(angle) , y + r*sin(angle) );\n\t\t\tP p2 = rot2( P(x,y) , p1 , to_rad(72) );\n\t\t\tP p3 = rot2( P(x,y) , p2 , to_rad(72) );\n\t\t\tP p4 = rot2( P(x,y) , p3 , to_rad(72) );\n\t\t\tP p5 = rot2( P(x,y) , p4 , to_rad(72) );\n\t\t\t// vs := 5 つの線分\n\t\t\tvector<Segment> vs;\n\t\t\tvs.push_back( Segment(p1,p3) );\n\t\t\tvs.push_back( Segment(p3,p5) );\n\t\t\tvs.push_back( Segment(p5,p2) );\n\t\t\tvs.push_back( Segment(p2,p4) );\n\t\t\tvs.push_back( Segment(p4,p1) );\n\t\t\tv.push_back( vs );\n\t\t}\n\t\tdouble G[101][101];\n\t\tfor(int i=0 ; i < 101 ; i++ ){\n\t\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tdouble d = INF;\n\t\t\t\tfor(int k1 = 0 ; k1 < v[i].size() ; k1++ ){\n\t\t\t\t\tfor(int k2 = 0 ; k2 < v[j].size() ; k2++ ){\n\t\t\t\t\t\tSegment s1 = v[i][k1];\n\t\t\t\t\t\tSegment s2 = v[j][k2];\n\t\t\t\t\t\td = min( d , s1.distance(s2) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i][j] = G[j][i] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\tG[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8f\\n\", G[m][l]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 4);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nbool intersectSP(const line_t &s, const xy_t &p) {\n  return abs(s.first - p) + abs(s.second - p) - abs(direction(s)) < EPS;\n}\n\nbool intersectSS(const line_t &s, const line_t &t) {\n  return ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n         ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\nxy_t projection(const line_t &l, const xy_t &p) {\n  double t = dot(p - l.first, direction(l) / norm(direction(l)));\n  return l.first + t*(direction(l));\n}\n\ndouble distanceSP(const line_t &s, const xy_t &p) {\n  const xy_t r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.first - p), abs(s.second - p));\n}\n\ndouble distanceSS(const line_t &s, const line_t &t) {\n  if (intersectSS(s, t)) return 0;\n  \n  return min(min(distanceSP(s, t.second), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first ), distanceSP(t, s.second)));\n}\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n    \n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\nstruct star {\n  int x, y, a, r;\n\n  vector<xy_t> points() const {\n    vector<xy_t> ps;\n    xy_t   center = xy_t(x, y);\n    double theta  = (double)a / 180 * M_PI + M_PI / 2;\n    REP(i, 5) {\n      // cout << center + polar((double)r, theta + M_PI * i * 2 / 5) << endl;\n      ps.push_back(center + polar((double)r, theta + M_PI * i * 2 / 5));\n    }\n    return ps;\n  }\n  \n  vector<line_t> segments() const {\n    vector<xy_t>   ps = this->points();\n    vector<line_t> res;\n\n    REP(i, ps.size()) REP(j, i){\n      res.push_back(line_t(ps[j], ps[i]));\n    }\n    return res;\n  }\n};\n\ndouble distance(const star &s, const star &t){\n  vector<line_t> seg_ss = s.segments();\n  vector<line_t> seg_ts = t.segments();\n  double res = 1e9;\n\n  for (line_t seg_s : seg_ss){\n    for (line_t seg_t : seg_ts){\n      res = min(res, distanceSS(seg_s, seg_t));\n    }\n  }\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, L;\n  while (cin >> N >> M >> L && N + M + L){\n    vector<star> stars(N);\n    vector<vector<double> > dist(N, vector<double>(N));\n    REP(i, N){\n      cin >> stars[i].x >> stars[i].y >> stars[i].a >> stars[i].r;\n    }\n\n    REP(i, N) REP(j, N){\n      dist[i][j] = distance(stars[i], stars[j]);\n    }\n\n    REP(k, N) REP(i, N) REP(j, N){\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n    printf(\"%.20lf\\n\", dist[L - 1][M - 1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n\ntypedef ld Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nconst Weight INF =1e14;\n\nvoid shortestPath(const Graph &g, int s,\n\t\t  vector<Weight> &dist, vector<int> &prev) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, -1);\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n    for(auto f=g[e.dst].begin(); f!=g[e.dst].end();f++) {\n      if (dist[f->dst] > e.weight+f->weight) {\n\tdist[f->dst] = e.weight+f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n}\n\n\nint main(){\n  int N,M,L;\n  while(cin >> N >> M >> L,N){\n    M--;\n    L--;\n    Graph g(5*N);\n    vector<Line> ls(5*N);\n    for(int i=0;i<N;i++){\n      ld x,y,a,r;\n      cin >> x >> y >> a >> r;\n      vector<Point> ps(5);\n      for(int j=0;j<5;j++){\n\tld b=a+j*72;\n\tb=b*pi/180;\n\tps[j]=Point(x-r*sin(b), y+r*cos(b));\n      }\n      for(int j=0;j<5;j++)\n\tls[i*5+j]=Line(ps[j], ps[(j+2)%5]);\n    }\n    for(int from=0;from<5*N;from++){\n      for(int to=from+1;to<5*N;to++){\n\tg[from].push_back(Edge(from,to,dist_ss(ls[to],ls[from])));\n\tg[to].push_back(Edge(to,from,dist_ss(ls[to],ls[from])));\n      }\n    }\n    vector<Weight> dist;\n    vector<int> prev;\n    shortestPath(g,M*5,dist,prev);\n    printf(\"%.10Lf\\n\",dist[L*5]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <iomanip>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P, P> SIDE;\n\ntypedef struct{\n\tint x, y, a, r;\n\tvector<SIDE> side;\n}STAR;\n\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n/*\n// ベクトルaの絶対値を求める\ndouble length = abs(a);\n\n// 2点a,b間の距離を求める\ndouble distance = abs(a-b);\n\n// ベクトルaの単位ベクトルを求める\nP b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nP n1 = a * P(0, 1);\nP n2 = a * P(0, -1);\n\n// ベクトルaの単位法線ベクトルun1,un2を求める\nP un1 = (a * P(0, +1)) / abs(a);\nP un2 = (a * P(0, -1)) / abs(a);\n*/\n\n// 回転\nP rotate(P p, int a) {\n  double arg = M_PI / 180 * a;\n  return p * P(cos(arg), sin(arg));\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n\n/*\n// 点cが線分a,b上にあるかないか(1)\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 ) &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\n// 点cが線分a,b上にあるかないか(2)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n*/\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n/*\n//円の交点\npair<P> intersection_circle(P p1,P p2,double r1,double r2){\n  double d = abs(p2-p1);\n  double th = acos((d*d+r1*r1-r2*r2)/(2*d*r1));\n  return make_pair(p1 + polar( r1, arg(p2-p1)+th ), polar( r1, arg(p2-p1)-th ) );\n}\n*/\n\ndouble dist(STAR start, STAR end)\n{\n\tdouble dis = 1000000000;\n\tfor(int i = 0; i < 5; i++) {\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tdis = min(dis, distance_ls_p(start.side[i].first, start.side[i].second, end.side[j].first));\n\t\t\tdis = min(dis, distance_ls_p(start.side[i].first, start.side[i].second, end.side[j].second));\n\t\t}\n\t}\n\treturn dis;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif(N == 0) break;\n\t\tvector<STAR> stars;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<SIDE> tmp;\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tP start = rotate(P(0, r), a + 72 * j) + P(x, y);\n\t\t\t\tP end = rotate(P(0, r), a + 72 * (j + 1)) + P(x, y);\n\t\t\t\ttmp.push_back(SIDE(start, end));\n\t\t\t}\n\t\t\tSTAR star = {x, y, a, r, tmp};\n\t\t\tstars.push_back(star);\n\t\t}\n\t\tdouble distance[100][100];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tdistance[i][j] = dist(stars[i], stars[j]);\n\t\t\t\t//cout << distance[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tdistance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << setprecision(10) << distance[M-1][L-1] << endl;\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "// This code is from http://dai1741.github.io/maximum-algo-2012/cpp/geometry/geometries2d.h\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <math.h>\n#include <complex>\n#include <iomanip>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n// 主に以下の資料を参考に作成した。\n// - http://www.prefield.com/algorithm\n// - http://www.deqnotes.net/acmicpc/2d_geometry/\n// - https://github.com/infnty/acm/tree/master/lib/geometry\n// - サークルの先輩が作ったライブラリ\n\n/* 基本要素 */\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n#define INF 10000000007\nstatic const double pi = 3.1415926535897932384626;\n\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線(Line)・線分(Segment)は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n\n\n/* 円 */\n\nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n\nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n\nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n\n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n\nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\n// 2円の交点\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\n// 点pから円aへの接線の接点\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ここでNaNも弾かれる\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n\n// 2円の共通接線。返される各直線に含まれる頂点は円との接点となる\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // 重複する接線を無視（重複していいならこの行不要）\n    }\n  }\n  return ls;\n}\n\n// 三角形の外心。点a,b,cは同一線上にあってはならない\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n\n// 点aと点bを通り、半径がrの円の中心を返す\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // 必要なら !LE(d,r) として円1つになる側へ丸める\n  D dN = sqrt(r*r - d*d);          // 必要なら max(r*r - d*d, 0) とする\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n\n// 点aと点bを通り、直線lに接する円の中心\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n\n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n\n// 点集合を含む最小の円の中心\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n\n\n/* 多角形 */\n\n// 頂点の順序（sortやmax_elementに必要）\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\n// 凸判定。縮退を認めないならccwの判定部分を != 1 とする\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n\n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\n// 凸多角形の内部判定　O(logn)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n\n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n\n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n\n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\n// 凸多角形の直径（最遠点対）\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n\n// 多角形の符号付面積\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\n\n// 多角形の幾何学的重心\nP centroid(const VP& ps) {\n  int n = ps.size();\n  D aSum = 0;\n  P c;\n  rep (i, n) {\n    D a = cross(ps[i], ps[(i+1) % n]);\n    aSum += a;\n    c += (ps[i] + ps[(i+1) % n]) * a;\n  }\n  return 1 / aSum / 3 * c;\n}\n\n// ボロノイ領域\nVP voronoiCell(P p, const VP& ps, const VP& outer) {\n  VP cl = outer;\n  rep (i, ps.size()) {\n    if (EQ(norm(ps[i]-p), 0)) continue;\n    P h = (p+ps[i])*0.5;\n    cl = convexCut(cl, h, h + (ps[i]-h)*P(0,1) );\n  }\n  return cl;\n}\n\n/* 幾何グラフ */\n\nstruct Edge {\n  int from, to;\n  D cost;\n  Edge(int from, int to, D cost) : from(from), to(to), cost(cost) {}\n};\nstruct Graph {\n  int n;\n  vector<vector<Edge> > edges;\n  Graph(int n) : n(n), edges(n) {}\n  void addEdge(Edge e) {\n    edges[e.from].push_back(e);\n    edges[e.to].push_back(Edge(e.to, e.from, e.cost));\n  }\n};\n\n// 線分アレンジメント（線分の位置関係からグラフを作成）\nGraph segmentArrangement(const vector<L>& segs, VP& ps) {\n  int n = segs.size();\n  rep (i, n) {\n    ps.push_back(segs[i].first);\n    ps.push_back(segs[i].second);\n    rep (j, i) {\n      if (isecSS(                 segs[i].first, segs[i].second, segs[j].first, segs[j].second))\n        ps.push_back(crosspointLL(segs[i].first, segs[i].second, segs[j].first, segs[j].second));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n  int m = ps.size();\n  Graph gr(m);\n  vector<pair<D, int> > list;\n  rep (i, n) {\n    list.clear();\n    rep (j, m) {\n      if (isecSP(segs[i].first, segs[i].second, ps[j]))\n        list.push_back(make_pair(norm(segs[i].first-ps[j]), j));\n    }\n    sort(list.begin(), list.end());\n    rep (j, list.size() - 1) {\n      int a = list[j  ].second;\n      int b = list[j+1].second;\n      gr.addEdge(Edge(a, b, abs(ps[a]-ps[b])));\n    }\n  }\n  return gr;\n}\n\n// 可視グラフ（点集合から見える位置へ辺を張ったグラフ）\nGraph visibilityGraph(const VP& ps, const vector<VP>& objs) {\n  int n = ps.size();\n  Graph gr(n);\n  rep (i,n) rep (j,i) {\n    P a = ps[i], b = ps[j];\n    if (!EQ(norm(a-b), 0)) rep (k, objs.size()) {\n      const VP& obj = objs[k];\n      int inStA = inConvex(a, obj);\n      int inStB = inConvex(b, obj);\n      if ((inStA ^ inStB) % 2 || inStA * inStB != 1 && inConvex((a+b)*0.5, obj) == 1) goto skip;\n      rep (l, obj.size()) {\n        P cur = obj[l];\n        P next = obj[(l + 1) % obj.size()];\n        if (isecSS(a, b, cur, next) && !isecSP(cur, next, a) && !isecSP(cur, next, b)) goto skip;\n      }\n    }\n    gr.addEdge( Edge(i, j, abs(a-b)) );\n    skip: {}\n  }\n  return gr;\n}\n\n\n/* その他 */\n\n// 重複する線分を併合する\nvector<L> mergeSegments(vector<L> segs) {\n  int n = segs.size();\n  rep (i,n) if (segs[i].second < segs[i].first) swap(segs[i].second, segs[i].first);\n\n  rep (i,n) rep (j,i) {\n    L &l1 = segs[i], &l2 = segs[j];\n    if (EQ(cross(l1.second-l1.first, l2.second-l2.first), 0)\n        && isecLP(l1.first, l1.second, l2.first)\n        && ccw   (l1.first, l1.second, l2.second) != 2\n        && ccw   (l2.first, l2.second, l1.second) != 2) {\n      segs[j] = L(min(l1.first, l2.first), max(l1.second, l2.second));\n      segs[i--] = segs[--n];\n      break;\n    }\n  }\n  segs.resize(n);\n  return segs;\n}\n\n\n// この辺にコードを載せるほどでもないが重要な定理とか図とか書いておくとよい気がします\n\n// 余弦定理\n// △ABC において、a = BC, b = CA, c = AB としたとき\n// a^2 = b^2 + c^2 ? 2bc cos ∠CAB\n\n// ヘロンの公式\n// 3辺の長さがa,b,cである三角形の面積T\n// T = sqrt{ s(s-a)(s-b)(s-c) }, s = (a+b+c)/2\n\n// ピックの定理\n// 多角形の頂点が全て格子点上にあり、内部に穴がないとき\n// S = i + b/2 - 1 (S:多角形の面積, i: 多角形の内部にある格子点の数, b: 辺上の格子点の数)\n\nint n,m,l;\n\nvector<vector<double>> dist;\nvector<vector<double>> vx;\nvector<vector<double>> vy;\n\ndouble dist_f(double x1,double x2,double y1,double y2)\n{\n\treturn (sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\nint main()\n{\n\n\twhile(cin >> n >> m >> l and n!=0)\n\t{\n\t\tdist=vector<vector<double>>(n,vector<double>(n,INF));\n\t\tvx=vector<vector<double>>(n,vector<double>(5,INF));\n\t\tvy=vector<vector<double>>(n,vector<double>(5,INF));\n\n\t\tvector<vector<L>> star_line(n,vector<L>(5));\n\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y,a,r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tint dig=72*j+90+a;\n\t\t\t\tdouble rad=(double)dig*pi/180.0;\n\t\t\t\tvx[i][j]=x+r*cos(rad);\n\t\t\t\tvy[i][j]=y+r*sin(rad);\n\n\t\t\t\t// cout << vx[i][j] << \" : \" << vy[i][j] << endl;\n\t\t\t}\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tstar_line[i][j]=L(P(vx[i][j],vy[i][j]),P(vx[i][(j+2)%5],vy[i][(j+2)%5]));\n\t\t\t}\n\t\t}\n\n\t\t//cerr << \"in end\" << endl;\n\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t{\n\t\t\t\t\tdist[i][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble mn=INF;\n\t\t\t\tfor(int ii=0;ii<5;ii++)\n\t\t\t\t{\n\t\t\t\t\tfor(int jj=0;jj<5;jj++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble tmp=dist_f(vx[i][ii],vx[j][jj],vy[i][ii],vy[j][jj]);\n\t\t\t\t\t\ttmp = distSS(star_line[i][ii].first,star_line[i][ii].second,star_line[j][jj].first,star_line[j][jj].second);\n\t\t\t\t\t\tif(tmp<mn)\n\t\t\t\t\t\t\tmn=tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dist[i][j]>mn)\n\t\t\t\t\tdist[i][j]=mn;\n\t\t\t\t// cerr << i << \" \" << j << \" \" << dist[i][j] << endl;\n\t\t\t}\n\n\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tdouble tmp=dist[i][k]+dist[k][j];\n\t\t\t\t\tif(tmp<dist[i][j])\n\t\t\t\t\t\tdist[i][j]=tmp;\n\t\t\t\t}\n\n\t\tcout << fixed << setprecision(15) <<  dist[m-1][l-1] << endl;\n\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]),amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, M, L; cin >> N >> M >> L;\n\t\tif (!N)break;\n\t\tvector<vector<Line>>stars(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong double x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tPoint center(x, y);\n\t\t\tvector<Point>pos;\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\tPoint np = center + r*Point(cos((90+a+ 72.0*j)*dtop), sin((90 + a + 72.0*j)*dtop));\n\t\t\t\tpos.push_back(np);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\tLine nl(pos[(j * 2) % 5], pos[(j * 2 + 2) % 5] );\n\t\t\t\tstars[i].push_back(nl);\n\t\t\t}\n\t\t}\n\t\tvector<vector<long double>>dists(N, vector<long double>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tdists[i][j] = getdis(stars[i], stars[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tdists[i][j] = min(dists[i][j],dists[i][k] + dists[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<fixed<<setprecision(22)<< dists[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2402&lang=jp\ntypedef long long ll;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nld theta = 72.0*pi / 180;\nstruct star {\n\tld x, y, a, r;\n\tvector<Point> P;\n\tvector<Line> L;\n\tstar() {}\n\tstar(ld x, ld y, ld a, ld r) :x(x), y(y), a(a), r(r) {\n\t\tld w = (90.0 + a)*pi / 180;\n\t\tfor (int i = 0; i < 5;i++) {\n\t\t\tld px = x + r * cos(w + theta*i);\n\t\t\tld py = y + r * sin(w + theta*i);\n\t\t\tP.push_back(Point(px, py));\n\t\t}\n\t\tfor (int i = 0; i < 5;i++) {\n\t\t\tL.push_back(Line(P[i], P[(i + 2) % 5]));\n\t\t}\n\t}\n};\n\nconst ld INF = 1e9;\n\nld getCost(star& s1, star& s2) {\n\tld ret = INF;\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0;j < 5;j++) {\n\t\t\tret = min(ret, dist_ss(s1.L[i], s2.L[j]));\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N | M | L) {\n\t\tM--; L--;\n\t\tvector<star> Star(N);\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tld x, y, a, r; cin >> x >> y >> a >> r;\n\t\t\tStar[i] = star(x, y, a, r);\n\t\t}\n\t\tvector<vector<ld>> dist(N, vector<ld>(N, INF));\n\t\tfor (int i = 0; i < N;i++) dist[i][i] = 0.0;\n\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tfor (int j = i + 1; j < N;j++) {\n\t\t\t\tld cost = getCost(Star[i], Star[j]);\n\t\t\t\tdist[i][j] = cost;\n\t\t\t\tdist[j][i] = cost;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tfor (int j = 0; j < N;j++) {\n\t\t\t\tfor (int k = 0; k < N;k++) {\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(20) << dist[M][L] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;\t//counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;\t\t//c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;\t\t\t\t\t\t\t//a--c--b on line\n}\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv*cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n)\n\t{\n\t\tm--; l--;\n\t\tvector<Line> ls;\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<Point> p(5);\n\t\t\tREP(i, 5) p[i] = (Point(x, y) + Point(0, r) * Point(cos((a + i * 72) / 180 * PI), sin((a + i * 72) / 180 * PI)));\n\t\t\tREP(i, 5)\n\t\t\t{\n\t\t\t\tls.push_back(Line(p[i], p[(i + 2) % 5]));\n\t\t\t}\n\t\t}\n\t\tvector<weight> d(ls.size());\n\t\tGraph g(ls.size());\n\t\tREP(i, ls.size())REP(j, i)\n\t\t{\n\t\t\tg[i].push_back(edge{ j, dist_ss(ls[i], ls[j]) });\n\t\t\tg[j].push_back(edge{ i, dist_ss(ls[i], ls[j]) });\n\t\t}\n\t\tdijkstra(g, d, m * 5);\n\t\tcout << D10 << d[l * 5] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nPoly rotate_poly(Poly po,Point c,R a){//???????¨???????\n    REP(i,po.size()){\n        po[i] = Point(po[i].real() - c.real(),po[i].imag() - c.imag());\n        po[i] = po[i] * Point(cos(a),sin(a));\n        po[i] = Point(po[i].real() + c.real(),po[i].imag() + c.imag());\n    }\n    return po;\n}\n\nR convert_deg_to_rad(R deg){\n    return deg / 180.0 * M_PI;\n}\n\nint N, M, L;\nPoly star[100];\n\nbool input() {\n  cin>>N>>M>>L;\n  R x, y, a, r;\n  REP(i, N) {\n    star[i].clear();\n    cin>>x>>y>>a>>r;\n    R ar = convert_deg_to_rad(a+90.0);\n    REP(j,5) {\n      star[i].pb(Point(x, y)+r*Point(cos(ar), sin(ar)));\n      ar += convert_deg_to_rad(72.0);\n    }\n  }\n  return N!=0;\n}\n\n#define INF 1000000000.0\nR G[100][100];\n\nvoid solve() {\n  fill((R *)G, (R *)G+10000, INF);\n  REP(i,N) {\n    G[i][i] = 0.0;\n  }\n\n  R dis;\n  REP(i, N) {\n    FOR(j, i+1, N) {\n      dis = INF;\n      REP(k, 5) {\n        REP(l, 5) {\n          dis = min(dis,dis_ss(Line(star[i][k],star[i][(k + 2) % 5]), Line(star[j][l], star[j][(l+2)%5])) );\n        }\n      }\n      G[i][j] = dis;\n      G[j][i] = dis;\n      //cout<<i<<','<<j<<':'<<dis<<endl;\n    }\n  }\n  REP(k,N){\n    REP(i,N){\n      REP(j,N){\n        G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n      }\n    }\n  }\n  cout<<G[M-1][L-1]<<endl;\n}\n\nint main() {\n  while(input()) {\n    /*REP(i, N) {\n      REP(j, 5) {\n        cout<<star[i][j]<<' ';\n      }\n      cout<<endl;\n    }*/\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nconst double PI = 3.141592653589;\n\ndouble deg2rad(double deg) {\n  return deg*PI/180;\n}\n\nP rotate(P p, P c, double d) {\n  return c+(p-c)*P(cos(d),sin(d));\n}\n\n\n#include <cstdio>\n\nconst int INF = 100000000;\nL star[200][5];\ndouble d[200][200];\n\ndouble diststar(int i,int j){\n  double ans = 1000000;\n  for (int ii=0; ii<5; ii++)\n    for (int ji=0; ji<5; ji++) {\n      ans = min(ans,distanceSS(star[i][ii],star[j][ji]));\n    }\n  return ans;\n}\n\nint main() {\n  int n,m,l;\n  while(scanf(\"%d %d %d\",&n,&m,&l),n) {\n    for(int i=0; i<n; i++) {\n      double x,y,a,r;\n      scanf(\"%lf %lf %lf %lf\",&x,&y,&a,&r);\n      P c(x,y),up(x,y+r);\n      for (int j=0; j<5; j++) {\n\tP f = rotate(up,c,deg2rad(j*72+a));\n\tP t = rotate(up,c,deg2rad((j+1)*72+a));\n\tstar[i][j] = L(f,t);\n      }\n    }\n\n    for (int i=0; i<n; i++)\n      for (int j=0; j<n; j++) \n\td[i][j] = (i==j?0:diststar(i,j));\n\n    for (int k=0; k<n; k++)\n      for (int i=0; i<n; i++)\n\tfor (int j=0; j<n; j++)\n\t  d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n    printf(\"%.8f\\n\",d[m-1][l-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n#include <complex>\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\ninline double cross(const Point& a, const Point& b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n  return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n  b -= a; c -= a;\n  double len = abs(b) * abs(c);\n  if(cross(b, c) > +EPS * len) return +1; // counter-clockwise\n  if(cross(b, c) < -EPS * len) return -1; // clockwise\n  if(dot(b, c) < 0) return +2; // c--a--b\n  if(norm(b) < norm(c)) return -2; // a--b--c\n  return 0; // a--c--b \n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ntypedef pair<double, int> P;\nint main(){\n  int N, M, L;\n  while(cin>>N>>M>>L && N){\n    M--; L--;\n    double x[100], y[100], a[100], r[100];\n    REP(i, N){\n      cin>>x[i]>>y[i]>>a[i]>>r[i];\n    }\n    vector<Line> lines(N * 5);\n    REP(i, N){\n      Point ps[5];\n      REP(j, 5) ps[j] = Point(x[i] + r[i] * cos(M_PI*(90.0 + a[i] + 72 * j)/180.0), y[i] + r[i] * sin(M_PI*(90.0 + a[i] + 72 * j)/180));\n      REP(j, 5) lines[5 * i + j] = Line(ps[j], ps[(j + 2) % 5]);\n    }\n    vector<double> dist(N * 5, INF);\n    priority_queue<P, vector<P>, greater<P> > que;\n    REP(i, 5){\n      dist[5 * M + i] = 0;\n      que.push(P(0, 5 * M + i));\n    }\n    double distance[500][500];\n    REP(i, 5 * N) REP(j, 5 * N) distance[i][j] = distanceSS(lines[i], lines[j]);\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int u = p.second;\n      if(dist[u] != p.first) continue;\n      REP(i, N * 5){\n        double next = dist[u] + distance[u][i];\n        if(next < dist[i]){\n          dist[i] = next;\n          que.push(P(next, i));\n        }\n      }\n    }\n    printf(\"%.10f\\n\", dist[5*L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<cassert>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main() {\n\tld n, m, l;\n\twhile (scanf(\"%Le %Le %Le\",&n,&m,&l), n) {\n\t\tvector<vector<Line>>star(n, vector<Line>(5));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tld x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<Point>s(5);\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\ts[j] = Point(x + r * sin(-a/180*pi), y + r * cos(a/180*pi));\n\t\t\t\ta += 144;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tstar[i][j] = Line(s[j], s[j + 1]);\n\t\t\t}\n\t\t\tstar[i][4] = Line(s[4], s[0]);\n\t\t}\n\t\tvector<vector<ld>>cost(n, vector<ld>(n,(ld)0));\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tld ma=(ld)99999999.9999;\n\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\tfor (int li = 0; li < 5; li++) {\n\t\t\t\t\t\tma =min(ma, dist_ss(star[i][k], star[j][li]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcost[i][j] = cost[j][i] = ma;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\tif (cost[j][k] > cost[j][i] + cost[k][i])cost[j][k] = cost[j][i] + cost[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%10Le\", cost[m - 1][l - 1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e10\n#define EPS (1e-10)    //誤差\ntypedef complex<double> P;\n\nstruct star{\n    P point[5];    \n};\n\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n\n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n\n\nstar ch(double x, double y, double a, double r){\n    \n    star res;\n    res.point[0] = P(0, r);    \n    \n    //a度左に回転\n    res.point[0] *= exp(P(0.0, a*M_PI/180.0));\n\n    //P(cos(), sin())\n\n    //72度回転　→　回収を五回繰り返す\n    for(int i = 1; i < 5; i++){\n        res.point[i] = res.point[i - 1] * exp(P(0.0, 2.0*M_PI/5.0));        \n    }\n\n    for(int i = 0; i < 5; i++){\n        res.point[i] += P(x, y);        \n    }\n\n    return res;\n}\n\ndouble Distance(P p11, P p12, P p21, P p22){\n\n    if(is_intersected_ls(p11, p12, p21, p22)) return 0.0;\n    double ans = INF;\n    ans = min(ans, distance_ls_p(p11, p12, p21));\n    ans = min(ans, distance_ls_p(p11, p12, p22));\n    ans = min(ans, distance_ls_p(p21, p22, p11));\n    ans = min(ans, distance_ls_p(p21, p22, p12));\n    return ans;\n}\n\n//星間の距離を返す\ndouble make_dis(star st1, star st2){\n    \n    double res = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            P p11, p12, p21, p22;\n            p11 = st1.point[i];\n            p12 = st1.point[(i + 2) % 5];\n\n            p21= st2.point[j];\n            p22 = st2.point[(j + 2) % 5];\n            res = min(res, Distance(p11, p12, p21, p22));\n        }\n    }\n\n    return res;\n}\n\n//幾何入門\nint main(){\n    \n    while(1){\n\n        int n, m, l; cin >> n >> m >> l;\n        if(!n) break;\n        m--;\n        l--;\n\n        //星の構造体\n        vector<star> st(n);\n\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            //入力から星の構造体を返す\n            st[i] = ch(x, y, a, r);\n        }\n\n        vector<vector<double> > dis(n, vector<double> (n, INF));\n\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                if(i == j) dis[i][j] = dis[j][i] = 0.0;\n                else dis[i][j] = dis[j][i] = make_dis(st[i], st[j]);\n            }\n        }\n\n        //ワーシャルフロイド\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n                }\n            }\n        }\n\n        /*for(int i = 0; i < n; i++){\n            cerr << \"star \" << i << endl;\n            for(int j = 0; j < 5; j++){\n                cerr << st[i].point[j].real() << \" \" << st[i].point[j].imag() << endl;\n            }\n        }*/\n\n        printf(\"%.10f\\n\", dis[m][l]);\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nint N,M,L;\n \n\nconst double EPS (1e-10);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n\tpoint() : x(0), y(0) {}\n\tpoint(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tvoid operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tvoid operator-=(const point &a){x -= a.x; y -= a.y;}\n\tpoint operator*(const double a)const{ return point(a*x,a*y); }\n\tpoint operator*=(const double a)const{ x *= a; y *= a; }\n\tpoint operator/(const double a)const{ return point(a/x,a/y); }\n\tpoint operator/=(const double a)const{ x /= a; y /= a; }\n\n\tT abs()const{return std::sqrt(x*x+y*y); } /* note --- o : sqrt x : abs */\n\tT dot(const point &a)const{ return x*a.x + y*a.y;}\n\tT cross(const point &a)const{ return x*a.y - y*a.x;}\n\tpoint rot(double theta)const{\n\t\treturn point(x*cos(theta)-y*sin(theta),x*sin(theta)+y*cos(theta));\n}\n};\n \ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n\tsegment() : a(point<T>()), b(point<T>()) {}\n\tsegment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n\tT abs()const{return (a-b).abs(); }\n\tT dist(const point<T>& c)const{\n\t\tif ( (b-a).dot(c-a) < EPS ) return (c-a).abs();\n\t\tif ( (a-b).dot(c-b) < EPS ) return (c-b).abs();\n\t\treturn std::abs((b-a).cross(c-a)) / (b-a).abs(); \n\t}\n\tbool intersect(const segment& c)const{\n\t\tif(max(a.x,b.x)+EPS<min(c.a.x,c.b.x)\n\t\t\t|| max(a.y,b.y)+EPS<min(c.a.y,c.b.y)\n\t\t\t|| max(c.a.x,c.b.x)+EPS<min(a.x,b.x)\n\t\t\t|| max(c.a.y,c.b.y)+EPS<min(a.y,b.y)) return false;\n\t\treturn ( (b-a).cross(c.a-a) * (b-a).cross(c.b-a) < EPS ) &&\n\t\t( (c.b-c.a).cross(a-c.a) * (c.b-c.a).cross(b-c.a) < EPS );\n\t}\n\tT dist(const segment& s){\n\t\tif(intersect(s)) return 0;\n\t\treturn min(\tmin(dist(s.a),dist(s.b)),\n\t\t\tmin(s.dist(a),s.dist(b)) );\n\t}\n};\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\nP pt[101][5];\ndouble dp[101][101];\n\ndouble get_min(int m,int n){\n    if(m==n) return 0;\n    double mn = INT_MAX;\n\tstatic int idx[] = {0,2,4,1,3,0};\n    for (int i = 0; i < 5; i++){\n\t\tS s = S(pt[n][idx[i]],pt[n][idx[i + 1]]);\n        for (int j = 0; j < 5; j++){\n\t\t\tS t = S(pt[m][idx[j]],pt[m][idx[j + 1]]);\n\t\t\tmn = min(mn,s.dist(t));\n        }\n    }\n    return mn;\n}\n \nint main()\n{\n    while(cin>>N>>M>>L,(N||M||L)){\n        for (int i = 0; i < N; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + P(r,0.0).rot(alpha);\n            }\n        }\n \n        for(int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                dp[i][j] = get_min(i,j);\n \n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++)\n                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n \n        printf(\"%.20lf\\n\",dp[M - 1][L - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct point { double x, y; };\nstruct line { point p, q; };\n\nint N, M, L, X[100], Y[100], A[100], R[100];\ndouble d[100][100];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td < 0 && ta * tb < 0;\n}\n\ndouble distance(line l, point p) {\n  double x0 = p.x, y0 = p.y;\n  double x1 = l.p.x, y1 = l.p.y;\n  double x2 = l.q.x, y2 = l.q.y;\n  double a = x2 - x1;\n  double b = y2 - y1;\n  double a2 = a * a;\n  double b2 = b * b;\n  double r2 = a2 + b2;\n  double tt = -(a*(x1 - x0) + b*(y1 - y0));\n  if(tt < 0) return sqrt((x1 - x0)*(x1-x0) + (y1 - y0)*(y1-y0));\n  if(tt > r2) return sqrt((x2 - x0)*(x2 - x0) + (y2 - y0)*(y2 - y0));\n  double f1 = a*(y1 - y0) - b*(x1 - x0);\n  return sqrt((f1*f1)/r2);\n}\n\ndouble distance_star(int a, int b) {\n  point pa[5], pb[5];\n  REP(i, 0, 5) {\n    double xa = X[a] + R[a] * cos((double) (A[a] + 72 * i + 90) / 180 * M_PI);\n    double ya = Y[a] + R[a] * sin((double) (A[a] + 72 * i + 90) / 180 * M_PI);\n    double xb = X[b] + R[b] * cos((double) (A[b] + 72 * i + 90) / 180 * M_PI);\n    double yb = Y[b] + R[b] * sin((double) (A[b] + 72 * i + 90) / 180 * M_PI);\n    pa[i] = (point) { xa, ya };\n    pb[i] = (point) { xb, yb };\n  }\n\n  REP(i, 0, 5) REP(j, 0, 5) {\n    line la = (line) { pa[i], pa[(i + 2) % 5] };\n    line lb = (line) { pb[j], pb[(j + 2) % 5] };\n    if(intersect(la, lb)) return 0;\n  }\n\n  double dist = 1e10;\n  REP(i, 0, 5) REP(j, 0, 5) {\n    line la = (line) { pa[i], pa[(i + 2) % 5] };\n    line lb = (line) { pb[i], pb[(i + 2) % 5] };\n    dist = min(dist, distance(la, pb[j]));\n    dist = min(dist, distance(lb, pa[j]));\n  }\n\n  return dist;\n}\n\nint main(void) {\n  while(cin >> N >> M >> L, N || M || L) {\n    M--;\n    L--;\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> A[i] >> R[i];\n\n    REP(i, 0, N) REP(j, 0, N) d[i][j] = distance_star(i, j);\n    REP(k, 0, N) REP(i, 0, N) REP(j, 0, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    printf(\"%.8lf\\n\", d[M][L]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\n#define EPS 1e-07\n#define INF 1e8\n\ntemplate<class T>\nstruct point{\n  T x,y;\n  \n  point (){}\n  point (T _x, T _y) : x(_x), y(_y){}\n\n  point &operator+=(const point &a){ x+=a.x; y+=a.y; }\n  point &operator-=(const point &a){ x-=a.x; y-=a.y; }\n  point operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n  point operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n  operator point<double>()const{ return (point<double>){x,y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\nstruct line{\n  point<T> a,b;\n  operator line<double>()const{ return (line<double>){a,b}; }\n};\n\ntemplate<class T>\nstruct segment{\n  point<T> a,b;\n \n  segment(){}\n  segment(point<T> _a, point<T> _b) : a(_a), b(_b) {}\n\n  operator line<T>()const{ return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b){\n  return a.x * b.x + a.y * b.y;\n}\n\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b){\n  return a.x * b.y - b.x * a.y;\n}\n\nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n  double rdir=cross(b-a,c-a);\n  if(rdir >  EPS) return CCW;\n  if(rdir < -EPS) return CW;\n  return ON;\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b){\n  return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n  if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n  if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n  return (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p){\n  if(dot(S.b-S.a,p-S.a)<=0) return dist(p,S.a);\n  if(dot(S.a-S.b,p-S.b)<=0) return dist(p,S.b);\n  return abs(cross(S.b-S.a,p-S.a))/dist(S.a,S.b);\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n  if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n     || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n     || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n     || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n  return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b) <=0 \n    && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b) <= 0;\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1, const segment<T> &S2){\n  if(intersect(S1,S2)) return 0;\n  return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n\t\t  min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\npoint<double> get_point(double x, double y, double a, double r, long long int tt){\n  const double cnt_ang  = M_PI * ( a + tt * 144 + 90 ) / 180;\n  const double cnt_x    = 1.00 * r * cos( cnt_ang ) + x;\n  const double cnt_y    = 1.00 * r * sin( cnt_ang ) + y;\n  \n  return point<double>(cnt_x, cnt_y);\n}\n\nint main() {\n\n  while( true ) {\n\n    long long int n, m, l;\n    cin >> n >> m >> l;\n    if ( n == 0 ) break;\n\n    vector< vector< segment<double> > > stars;\n\n    for ( long long int i = 0; i < n; i++ ) {\n      double in_x, in_y, in_a, in_r;\n      \n      cin >> in_x >> in_y >> in_a >> in_r;\n      \n      vector<segment<double> > segments;\n      \n      for(long long int tt = 0; tt < 5; tt++){\n\tsegments.push_back(segment<double>(get_point(in_x, in_y, in_a, in_r, tt), \n\t\t\t\t\t   get_point(in_x, in_y, in_a, in_r, (tt + 1) % 5)));\n      }\n\n      stars.push_back(segments);\n    }\n\n    \n\n    double len[101][101];\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tlen[i][j] = i == j ? 0 : INF;\n      }\n    }  \n    \n    for( long long int from_star = 0; from_star < n; from_star++){\n      vector<segment<double> > from_segs = stars[from_star];\n      \n      for(long long to_star = from_star + 1; to_star < n; to_star++){\n\tvector<segment<double> > to_segs = stars[to_star];\n\t\n\tfor(long long from_seg_no = 0; from_seg_no < 5; from_seg_no++){\n\t  for(long long to_seg_no = 0; to_seg_no < 5; to_seg_no++){\n\t    const double dist_ss = dist(from_segs[from_seg_no], to_segs[to_seg_no]);\n\t    \n\t    len[from_star][to_star] = min(len[from_star][to_star], dist_ss);\n\t    len[to_star][from_star] = min(len[to_star][from_star], dist_ss);\n\t    //cout << from_star << \"(\" << from_seg_no << \")\"  << \" \" << to_star << \"(\" << to_seg_no << \")\" << \" \" << dist_ss << endl;\n\t  }\n\t}\n      }  \n    }\n\n    for ( long long int k = 0; k < n; k++ ) {    \n      for ( long long int i = 0; i < n; i++ ) {\n\tfor ( long long int j = 0; j < n; j++ ) {\n\t  len[i][j] = min( len[i][j], len[i][k] + len[k][j] );\n\t}\n      }\n    }\n\n    cout << fixed << setprecision(10) << len[m-1][l-1] << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equlas(a, b) (fabs((a) - (b)) < EPS)\n#define INF (1e9+7)\n#define PI acos(-1)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point (double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator - (Point p) {\n        return Point(x - p.x, y - p.y);\n    }\n\n    Point operator * (double c) {\n        return Point(c * x, c * y);\n    }\n\n    Point operator / (double c) {\n        return Point(x / c, y / c);\n    }\n\n    bool operator < (const Point &p) {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n\n    bool operator == (const Point &p) {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n\n    bool operator != (const Point &p) {\n        return (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n    }\n\n    double norm() {\n        return (x * x + y * y);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n\n    Point rotatePoint(Point s, int angle) {\n        Point tmp(x - s.x, y - s.y);\n        double a = angle * PI / 180.0;\n\n        return Point(\n                    tmp.x * cos(a) - tmp.y * sin(a) + s.x, \n                    tmp.x * sin(a) + tmp.y * cos(a) + s.y);\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot (Vector a, Vector b) {\n    return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross (Vector a, Vector b) {\n    return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(Vector a) {\n    return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\ndouble distL(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distS (Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distL(s, p);\n}\n\nconst int CCW = 1;\nconst int CW = -1;\nconst int ONBACK = 2;\nconst int ONFRONT = -2;\nconst int ONSEG = 0;\n\nint ccw (Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if (cross(a, b) > EPS) return CCW;\n    if (cross(a, b) < -EPS) return CW;\n    if (dot(a, b) < -EPS) return ONBACK;\n    if (a.norm() < b.norm()) return ONFRONT;\n    return ONSEG;\n}\n\nbool intersect (Point a, Point b, Point c, Point d) {\n    return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distSS (Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distS(s1, s2.p1), distS(s1, s2.p2)), min(distS(s2, s1.p1), distS(s2, s1.p2)));\n}\n\nclass Star {\npublic:\n    Point p;\n    vector<Point> v;\n    vector<Segment> sg;\n    int r, a;\n\n    Star (Point p = Point(), int a = 0, int r = 0) : p(p), a(a), r(r) {}\n\n    void setVandSG () {\n        v.resize(5);\n        sg.resize(5);\n        Point topp(p.x, p.y + r);\n        int cnt = 0;\n\n        for (int i = 0; i < 5; ++i) {\n            v[i] = topp.rotatePoint(p, a + 72 * i);\n        }\n\n        for (int i = 0; i < 3; ++i) {\n            sg[cnt] = Segment(v[i], v[i + 2]);\n            cnt++;\n            if (i + 3 <= 4) sg[cnt] = Segment(v[i], v[i + 3]);\n            cnt++;\n        }\n    }\n\n};\n\nint n, m, l, x, y, a, r;\ndouble d[110][110];\nvector<Star> star;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cout << fixed;\n    cout.precision(20);\n\n    while (cin >> n >> m >> l, n | m | l) {\n        // initialize\n        star.resize(n);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == j) d[i][j] = 0.0;\n                else d[i][j] = INF;\n            }\n        }\n\n        //input\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> a >> r;\n            star[i] = Star(Point(double(x), double(y)), a, r);\n            star[i].setVandSG();\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < 5; ++k) {\n                    for (int o = 0; o < 5; ++o) {\n                        if (i != j) d[i][j] = min(d[i][j], distSS(star[i].sg[k], star[j].sg[o]));\n                    }\n                }\n            }\n        }\n\n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        cout << d[m-1][l-1] << endl;\n\n        star.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint n,m,l;\nint x[100],y[100],a[100],r[100];\n\ndouble dist(int p,int q){\n  P pp[5];\n  P pq[5];\n  rep(i,5){\n    double ang=M_PI/2+M_PI*a[p]/180.+M_PI*2*i/5;\n    pp[i]=P(x[p],y[p])+(double)r[p]*P(cos(ang),sin(ang));\n  }\n  rep(i,5){\n    double ang=M_PI/2+M_PI*a[q]/180.+M_PI*2*i/5;\n    pq[i]=P(x[q],y[q])+(double)r[q]*P(cos(ang),sin(ang));\n  }\n\n  double ret=ssdist(line(pp[0],pp[2]),line(pq[0],pq[2]));\n  rep(i,5)rep(j,5)\n    ret=min(ret,\n\t    ssdist(line(pp[i],pp[(i+2)%5]),\n\t\t   line(pq[j],pq[(j+2)%5])));\n  return ret;\n}\ndouble cost[100][100];\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> a[i] >> r[i];\n  rep(i,n)rep(j,n) cost[i][j]=dist(i,j);\n  rep(k,n)rep(i,n)rep(j,n)\n    cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n  printf(\"%.8f\\n\",cost[m-1][l-1]);\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n >> m >> l && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  double x, y, a, r;\n  ST(){}\n  ST(double x, double y, double a, double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst double INF = 100000000.0;\nconst double EPS = 1e-8;\n\nint n, s, t;\nvector<ST> input;\ndouble dist[N][N];\n\ndouble dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec, vector<Point>& vec2){\n  Point o = Point(st.x, st.y);\n  Point p = Point(st.x, st.y + st.r);\n  for(int i=0;i<5;i++){\n    vec2.push_back(rotate(p, o, st.a+72.0*i));\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){vec2[i], vec2[i+1]});\n  }\n  vec.push_back((Segment){vec2[4], vec2[0]});\n}\n\ndouble calc_dist(ST pa, ST pb){\n  vector<Segment> a1, b1;\n  vector<Point> a2, b2;\n  get_seg(pa, a1, a2);\n  get_seg(pb, b1, b2);\n  double res = INF;\n  for(int i=0;i<a1.size();i++){\n    for(int j=0;j<b1.size();j++){\n      res = min(res, getDistance(a1[i], b1[j]));\n    }\n  }\n  for(int i=0;i<a2.size();i++){\n    for(int j=0;j<b2.size();j++){\n      res = min(res, abs(a2[i] - b2[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\ndouble solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.15f\\n\", (double)solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\ntypedef complex<D> P;  // Point\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nstatic const double pi = 3.141592653589793;\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nP rotateP(P a, P o ,D arg) { //点aを点oを中心に反時計周りにまわした複素数を返す。\n\ta -= o;\n\ta *= P(cos(arg / 180 * pi), sin(arg / 180 * pi));\n\ta += o;\n\treturn a;\n}\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n////////////////\n\nint N,M,L;\nint x,y,a,r;\n\nD ds(array<P, 5> a, array<P, 5> b) {\n\tD res = 1e30;\n\trep(i, 5) {\n\t\trep(j, 5) {\n\t\t\tres = min(res,distSS(a[i] , a[(i + 1) % 5], b[j], b[(j+ 1) % 5]));\n\t\t}\n\t}\n\treturn res;\n}\n\t\t\t\t\n\nint main() {\n\twhile(cin >> N >> M >> L, N) {\n\t\tvector<array<P, 5> > stars;\n\t\tM --; L--;\n\t\tfor(int n = 1; n <= N; n++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tP p0, p1, p2, p3, p4, p5;\n\t\t\tp0 = P(x, y);\n\t\t\tp1 = p0 + P(0, r);\n\t\t\tp1 = rotateP(p1, p0, a);\n\t\t\tp2 = rotateP(p1, p0, 144);\n\t\t\tp3 = rotateP(p2, p0, 144);\n\t\t\tp4 = rotateP(p3, p0, 144);\n\t\t\tp5 = rotateP(p4, p0, 144);\n\t\t\tstars.push_back({p1,p2,p3,p4,p5});\n\t\t}\n\t\t\n\t\tdouble table[110][110];\n\t\tfor(int n = 0; n < N; n++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tif(i == n) {\n\t\t\t\t\ttable[i][n] = 0;\n\t\t\t\t} else {\n\t\t\t\t\ttable[i][n] = ds(stars[i], stars[n]);\n\t\t\t\t\ttable[n][i] = table[i][n];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k, N) {\n\t\t\trep(i, N){\n\t\t\t\trep(j, N){\n\t\t\t\t\ttable[i][j] = min(table[i][j],table[i][k] + table[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << setprecision(20) << table[M][L] << endl;\n\t}\n}\n\t\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n\nvector<P> get_p(P a,double d,double r){\n  vector<P> res(5);\n  d=(d/360)*2*M_PI;\n  P p=P(0,r)*P(cos(d),sin(d));\n  res[0]=p+a;\n  d=2*M_PI/5;\n  for(int i=1;i<=4;i++){\n    p=p*P(cos(d),sin(d));\n    res[i]=p+a;\n  }\n  return res;\n}\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble G[N][N],x[N],y[N],d[N],r[N];\ndouble get_dis(int a,int b){\n  vector<P> A=get_p(P(x[a],y[a]),d[a],r[a]);\n  vector<P> B=get_p(P(x[b],y[b]),d[b],r[b]);\n  double res=1e9;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      res=min(res,getDistanceSS(L(A[i],A[(i+2)%5]),L(B[j],B[(j+2)%5])));\n  return res;\n}\n\nint main(){\n  while(1){\n  int n,s,g;\n  cin>>n>>s>>g;\n  if(!n&&!s&&!g)break;\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++)G[i][j]=1e9*(i!=j);\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>d[i]>>r[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(i!=j) G[i][j]=get_dis(i,j);\n  \n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  printf(\"%.20f\\n\",G[s-1][g-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tP pt[100][5];\n        for(int i = 0; i < n; i++){\n\t\t\tdouble x,y,a,r;\n            cin>>x>>y>>a>>r;\n            for(int j = 0; j < 5; j++){\n\t\t\t\tdouble alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n\t\t\t}\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    S s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    S t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point &p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point &p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nconst double PI = 3.1415926535;\nint main(){\n  int n,m,l;\n  while(cin>>n>>m>>l,n){\n    m--;l--;\n    int i,j,k,s,t;\n    double x,y,a,r;\n    Segment star[n][5];\n    for(i=0;i<n;i++){\n      cin>>x>>y>>a>>r;\n      Point p[5];\n      for(j=0;j<5;j++) {\n\tp[j].x=x-r*sin(PI/180.0*(a+72.0*j));\n\tp[j].y=y+r*cos(PI/180.0*(a+72.0*j));\n      }\n      for(j=0;j<5;j++) star[i][j]=Segment(p[j%5],p[(j+2)%5]);\n    }\n    double inf = 1 << 28;\n    double d[n][n];\n    fill(d[0],d[0]+n*n,inf);\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tif(i==j) continue;\n\tfor(s=0;s<5;s++){\n\t  for(t=0;t<5;t++){\n\t    d[i][j]=min(d[i][j],getDistance(star[i][s],star[j][t]));\n\t  }\n\t}\n      }\n    }\n    double v[n];\n    fill(v,v+n,inf);\n    bool used[n];\n    memset(used,0,sizeof(used));\n    typedef pair<double,int> P;\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(0,m));\n    while(!q.empty()){\n      a=q.top().first;k=q.top().second;q.pop();\n      if(used[k]||v[k]<=a) continue;\n      used[k]=true;v[k]=a;\n      for(i=0;i<n;i++) q.push(P(a+d[k][i],i));\n    }\n    printf(\"%.8f\\n\",v[l]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing  ld = long double;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(8);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_sp(Line(seg[i][ii], seg[i][(ii + 1) % 10]), seg[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\n// ??????????????¢????????????\n\n// ?????°??? ??? ??§??????\ndouble deg2rad(double x) {return x * M_PI / 180.0;}\n\n// ??? a ???????????¨???????????? b ??? z ????????¢???????????¨????????????\nP rotatePoint(P a, P b, double z) {\n    // ?????°????????´????????????\n    z = deg2rad(z);\n\n    b -= a;\n    double rx = b.X * cos(z) - b.Y * sin(z);\n    double ry = b.X * sin(z) + b.Y * cos(z);\n    P ret(rx, ry); ret += a;\n    return ret;\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// ??? a1, a2 ???????????¨??????????????¨??? b ??¨????????¢\ndouble dist_sp(P a1, P a2, P b) {\n    if( dot(a2-a1, b-a1) < EPS ) return abs(b - a1);\n    if( dot(a1-a2, b-a2) < EPS ) return abs(b - a2);\n    return abs( cross(a2-a1, b-a1) ) / abs(a2 - a1);\n}\n\n// ?????? a1, a2 ??¨ ?????? b1, b2 ??¨????????¢\n// Verified: CGL_2_D: Distance\n// isec_ss?????????????????§??????\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\ndouble dist_ss(P a1, P a2, P b1, P b2) {\n    if(isec_ss(a1, a2, b1, b2)) return 0;\n    return min( min(dist_sp(a1, a2, b1), dist_sp(a1, a2, b2)),\n                min(dist_sp(b1, b2, a1), dist_sp(b1, b2, a2)) );\n}\n\nint N, M, LS;\ndouble dist[110][110];\n\nsigned main() {\n    while(cin >> N >> M >> LS, N || M || LS) {\n        M--; LS--;\n        double x, y, a, r;\n        vector<P> ps[110];\n        vector<L> ls[110];\n        rep(i,0,N) {\n            cin >> x >> y >> a >> r;\n            P po = P(x, y), pt = P(x, y+r);\n            pt = rotatePoint(po, pt, a);\n            rep(j,0,5) {\n                double deg = 72.0 * j;\n                ps[i].push_back( rotatePoint(po, pt, deg) );\n            }\n            ls[i].push_back(L(ps[i][0], ps[i][2]));\n            ls[i].push_back(L(ps[i][0], ps[i][3]));\n            ls[i].push_back(L(ps[i][1], ps[i][3]));\n            ls[i].push_back(L(ps[i][1], ps[i][4]));\n            ls[i].push_back(L(ps[i][2], ps[i][4]));\n        }\n\n        rep(i,0,N) rep(j,0,N) {\n            dist[i][j] = INF;\n            rep(x,0,5) rep(y,0,5) {\n                double temp = dist_ss(ls[i][x].first, ls[i][x].second,\n                                      ls[j][y].first, ls[j][y].second);\n                chmin(dist[i][j], temp);\n            }\n        }\n\n        rep(k,0,N) rep(i,0,N) rep(j,0,N) {\n            chmin(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n        printf(\"%.12f\\n\", dist[M][LS]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\nconst int MN = 110;\nP p[MN][5];\nR g[MN][MN];\nint main() {\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l; m--; l--;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, a, r;\n            cin >> x >> y >> a >> r;\n            for (int j = 0; j < 5; j++) {\n                R aa = a + 90+72*j;\n                p[i][j] = P(x, y) + polar<R>(r, radNorP(deg2rad(aa)));\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                R r = 1e9;\n                for (int k = 0; k < 5; k++) {\n                    L u = L(p[i][k], p[i][(k+2)%5]);\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSP(u, p[j][l]));\n                    }\n                }\n                for (int k = 0; k < 5; k++) {\n                    L u = L(p[j][k], p[j][(k+2)%5]);\n                    for (int l = 0; l < 5; l++) {\n                        r = min(r, distSP(u, p[i][l]));\n                    }\n                }\n                g[i][j] = g[j][i] = r;\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.20Lf\\n\", g[m][l]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef complex<double> P;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > DBL_EPSILON)\n\t\treturn 1;\n\tif (cross(b, c) < -DBL_EPSILON)\n\t\treturn -1;\n\tif (dot(b, c) < -DBL_EPSILON)\n\t\treturn 2;\n\tif (norm(b) < norm(c) - DBL_EPSILON)\n\t\treturn 2;\n\treturn 0;\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\ndouble DistanceSP(P a, P b, P c) {\n\tif (dot(b - a, c - a) < DBL_EPSILON)\n\t\treturn abs(c - a);\n\tif (dot(a - b, c - b) < DBL_EPSILON)\n\t\treturn abs(c - b);\n\treturn abs(cross(b - a, c - a));\n}\ndouble DistaiceSS(P a, P b, P c, P d) {\n\tif (isIntersectSS(a, b, c, d)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a, b, c), DistanceSP(a, b, d)),\n\t\t\tmin(DistanceSP(c, d, a), DistanceSP(c, d, b)));\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta = M_PI / 2 + 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta), p.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(a1,p1.vertex)\n\t\tforeach(a2,p1.vertex)\n\t\t\tforeach(b1,p2.vertex)\n\t\t\t\tforeach(b2,p2.vertex) {\n\t\t\t\t\tm = min(m, DistaiceSS(*a1, *a2, *b1, *b2));\n\t\t\t\t}\n\treturn m;\n}\nint x, y, a, r;\n\ndouble dijk(int start, int goal) {\n\tvector<double> memo(N, DBL_MAX);\n\tpriority_queue<pair<double,int> > up;\n\tup.push(make_pair(0, start));\n\tmemo[start] = 0;\n\twhile (!up.empty()) {\n\t\tdouble cost = -up.top().first;\n\t\tint pos = up.top().second;\n\n\t\tup.pop();\n\t\tif (memo[pos] < cost)\n\t\t\tcontinue;\n\t\tif (pos == goal)\n\t\t\treturn cost;\n\t\tREP0(next,N) {\n\t\t\tif (links[pos][next] >= 0) {\n\t\t\t\tdouble ncost = cost + links[pos][next];\n\t\t\t\tif (memo[next] > ncost) {\n\t\t\t\t\tmemo[next] = ncost;\n\t\t\t\t\tup.push(make_pair(-ncost, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tcout << dijk(M - 1, L - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  double x, y, a, r;\n  ST(){}\n  ST(double x, double y, double a, double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst double INF = 100000000.0;\nconst double EPS = 1e-10;\n\nint n, s, t;\nvector<ST> input;\ndouble dist[N][N];\n\ndouble dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec, vector<Point>& vec2){\n  Point o = Point(st.x, st.y);\n  Point p = rotate(Point(st.x, st.y + st.r), o, st.a);\n  for(int i=0;i<5;i++){\n    vec2.push_back(p);\n    p = rotate(p, o, 72.0);\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){vec2[i], vec2[i+1]});\n  }\n  vec.push_back((Segment){vec2[4], vec2[0]});\n}\n\ndouble calc_dist(ST pa, ST pb){\n  vector<Segment> a1, b1;\n  vector<Point> a2, b2;\n  get_seg(pa, a1, a2);\n  get_seg(pb, b1, b2);\n  double res = INF;\n  for(int i=0;i<a1.size();i++){\n    for(int j=0;j<b1.size();j++){\n      res = min(res, getDistance(a1[i], b1[j]));\n    }\n  }\n  for(int i=0;i<a2.size();i++){\n    for(int j=0;j<b2.size();j++){\n      res = min(res, abs(a2[i] - b2[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\ndouble solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.20f\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m, l;\n\nvector<Point> p[110];\n\ndouble dist(Point p) { return abs(p); }//ベクトルpの絶対値\ndouble dist(Point a, Point b) {//2点間の距離\n\treturn abs(a - b);\n}\n\nPoint rot(Point p, double a) {//aはrad\n\tdouble x1 = p.real(), y1 = p.imag();\n\treturn Point(x1*cos(a) - y1*sin(a), x1*sin(a) + y1*cos(a));\n}\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t};\n\n\tdouble d[100010];\n\tvector<edge> G[100010];//各頂点からの辺\n\n\tvoid clear() {\n\t\trep(i, 100010)G[i].clear();\n\t}\n\n\tvoid dijkstra(int start) {\n\t\tfill(d, d + 100010, INF);\n\t\td[start] = 0;\n\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, start));\n\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second;\n\t\t\tif (d[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m >> l&&n + m + l) {\n\t\tm--; l--;\n\t\trep(i, 110)p[i].clear();\n\t\tdk.clear();\n\t\trep(i, n) {\n\t\t\tdouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tPoint po = Point(0, r);\n\t\t\tpo = rot(po, 2 * PI *a / 360);\n\t\t\trep(j, 5) {\n\t\t\t\t//cout << po.real() << \" \" << po.imag() << endl;\n\t\t\t\tp[i].push_back(po + Point(x, y));\n\t\t\t\tpo = rot(po, 2 * PI / 5);\n\t\t\t}\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\trep(j, 5) {\n\t\t//\t\tcout << p[i][j].real() << \" \" << p[i][j].imag() << endl;\n\t\t//\t}\n\t\t//}\n\t\trep(i, n) {\n\t\t\tFOR(j, i + 1, n) {\n\t\t\t\tdouble mind = INF;\n\t\t\t\trep(k, p[i].size()) {\n\t\t\t\t\trep(l, p[j].size()) {\n\t\t\t\t\t\tmind = min(dist(p[i][k], p[j][l]), mind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << mind << endl;\n\t\t\t\tdk.G[i].push_back({ j,mind });\n\t\t\t\tdk.G[j].push_back({ i,mind });\n\t\t\t}\n\t\t}\n\t\tdk.dijkstra(m);\n\t\tprintf(\"%.10lf\\n\", dk.d[l]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> \n#include <bitset> \n#include <cctype> \n#include <complex> \n#include <cmath> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <ctime> \n#include <deque> \n#include <functional> \n#include <iomanip> \n#include <iostream> \n#include <list> \n#include <map> \n#include <numeric> \n#include <queue> \n#include <set> \n#include <sstream> \n#include <stack> \n#include <string> \n#include <utility> \n#include <vector> \n   \nusing namespace std; \n   \ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;} \ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();} \ntemplate<class T> inline T sqr(T x) {return x*x;} \n   \ntypedef vector<int> vi; \ntypedef vector<vi> vvi; \ntypedef vector<string> vs; \ntypedef pair<int, int> pii; \ntypedef long long ll; \n   \n#define all(a)  (a).begin(),(a).end() \n#define rall(a) (a).rbegin(), (a).rend() \n#define pb push_back \n#define mp make_pair \n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i) \n#define exist(s,e) ((s).find(e)!=(s).end()) \n#define range(i,a,b) for(int i=(a);i<(b);++i) \n#define rep(i,n)  range(i,0,n) \n#define clr(a,b) memset((a), (b) ,sizeof(a)) \n#define dump(x)  cerr << #x << \" = \" << (x) << endl; \n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl; \n   \n   \nconst double eps = 1e-10; \nconst double pi  = acos(-1.0); \nconst ll INF =1LL << 62; \nconst int inf =1 << 30; \n   \n   \n// テ、ツサツ・テ、ツクツ?テ・ツケツセテ、ツスツ陛ゥツδィテ・ツ按?\ntemplate<class T> bool operator==(T a, T b){return abs(a-b) < eps;} \ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;} \n#define x real() \n#define y imag() \n#define mp make_pair \n   \ntypedef bool B; \ntypedef long double D; \ntypedef complex<D> P; \ntypedef pair <P,P> L; \ntypedef struct {P c;D r;} C; \ntypedef struct {P c;D a,b;} E; // テヲツ・ツ陛・ツ??」ツつづィツソツステ・ツ環?、ツコツ暗・ツョツ?\ntypedef vector <P>Pol; \n   \n// テ」ツつステ」ツδシテ」ツδ暗」ツ?ョテ」ツつュテ」ツδシ \nB cmp_x(const P &a,const P &b){ return (abs(a.x-b.x)<eps ) ?  a.y<b.y : a.x<b.x;}  // base x \nB cmp_y(const P &a,const P &b){ return (abs(a.y-b.y)<eps ) ?  a.x<b.x : a.y<b.y;}  // base y \nB cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg \n   \n   \n// テ・ツ淞コテヲツ慊ャテヲツ督催、ツスツ?\n// verify \nD ip(P a, P b) {return a.x * b.x + a.y * b.y;} \nD ep(P a, P b) {return a.x * b.y - a.y * b.x;} \nD sr(D a) {return sqrt(max(a, (D)0));} \nP vec(L l){return l.second-l.first;} \n   \n   \n// テァツつケ \nD ang (P p){return arg(p);} \nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base テ、ツクツュテ・ツソツ?\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );} \n   \n   \n// ccw  \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID }; \n   \nint ccw(P base, P a, P b) {              //テァツつケaテ」ツ?ィテァツつケbテ」ツ?古、ツクツ偲」ツ?暗」ツつ嘉」ツつ古」ツ?淌・ツ閉湘」ツ??」ツ?ォ \n  a -= base; b -= base; \n  if (ep(a, b) > 0)       return LEFT;    // counter clockwise \n  if (ep(a, b) < 0)      return RIGHT;   // clockwise \n  if (ip(a, b) < 0)      return BACK;    // b--base--a on line \n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line \n                         return MID;      // base--b--a on line  aテ」ツ?ィbテ」ツ?ョテァツキツ堙・ツ按?・ツ按、テ・ツョツ堙」ツ?ッテ」ツ?禿」ツつ?\n} \n   \n   \n   \nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;} \nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;} \n   \n   \n// テ、ツコツ、テァツつケ \nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));} \n   \n   \n// テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ィテァツキツ堙・ツ按?ゥツ鳴「テゥツ?」テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\n   \nB iLL(L l1,L l2){ return !ipar(l1,l2);} \nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;} \nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;} \nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;} \nB iSS(L a, L b) { \n    int cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second); \n    int cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second); \n    return ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT)); \n} \nB iSSs(L a, L b) { \n    int cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second); \n    int cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second); \n    return (cwa & cwb) == (LEFT | RIGHT); \n} \n   \n// テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ィテァツキツ堙・ツ按?ゥツ鳴「テゥツ?」テ」ツ?ョティツキツ敕ゥツ崢「 \n   \nD dLP(L l,P p){ return abs(ep(vec(l),p-l.first))/abs(vec(l));} \nD dSP(L s,P p){ \n    if (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first); \n    if (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second); \n    return dLP(s,p); \n} \nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);} \nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));} \nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));} \n   \n \nint main(void){\n    int n,s,t;\n    while(cin >> n,n){\n\n        cin >> s >> t;\n\t\ts--;t--;\n        \n\t\tD graph[110][110];\n\t\tD X[110],Y[110],a[110],r[110];\n\t\tL star[110][5];\n\n\t\trep(i,n) cin >> X[i] >> Y[i] >> a[i] >> r[i]; \n\t\trep(i,n) a[i]=a[i]/180.0*pi;\n\t\t\n\t\trep(i,n)rep(j,5){\n\t\t\tP base=P(X[i],Y[i]);\n\t\t\tD theta=a[i]+j*(2.0/5.0*pi)+pi/2;\n\t\t\tP p1=base+P(r[i],0);\n\t\t\tp1=rot(base,p1,theta);\n\t\t\ttheta=a[i]+(j+2)*(2.0/5.0*pi)+pi/2;\n\t\t\tP p2=base+P(r[i],0);\n\t\t\tp2=rot(base,p2,theta);\n\t\t\t//dump(base)dump(p1) dump(p2)\n\t\t\tstar[i][j]=L(p1,p2);\n\t\t}\n        \n\t\trep(i,n)rep(j,n){\n\t\t\tD res = INF;\n \t\t\trep (k,5)rep(l,5){\n    \t\t\tres = min(res,dSS(star[i][k], star[j][l]));\n\t\t\t}\n  \t\t\tgraph[i][j] = res;\n\t\t}\n\n \t\t\n        rep(k,n)rep(i,n)rep(j,n){\n            graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n        }\n \n        cout.precision(9);\n        cout << fixed << graph[s][t] << endl;\n    }\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\nvector<P> get_p(P a,double d,double r){\n  vector<P> res(5);\n  d=(d/360)*2*M_PI;\n  P p=P(0,r)*P(cos(d),sin(d));\n  res[0]=p+a;\n  d=2*M_PI/5;\n  for(int i=1;i<=4;i++){\n    p=p*P(cos(d),sin(d));\n    res[i]=p+a;\n  }\n  return res;\n}\n\n\ndouble G[N][N],x[N],y[N],d[N],r[N];\ndouble get_dis(int a,int b){\n  vector<P> A=get_p(P(x[a],y[a]),d[a],r[a]);\n  vector<P> B=get_p(P(x[b],y[b]),d[b],r[b]);\n  double res=1e9;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      res=min(res,getDistanceSS(L(A[i],A[(i+2)%5]),L(B[j],B[(j+2)%5])));\n  return res;\n}\n\nint main(){\n  while(1){\n  int n,s,g;\n  cin>>n>>s>>g;\n  if(!n&&!s&&!g)break;\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++)G[i][j]=1e9;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>d[i]>>r[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)G[i][j]=get_dis(i,j);\n  \n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  printf(\"%.20f\\n\",G[s-1][g-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*PI;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n\nint N,M,L;\nSegment s[1000];\n\ndouble D[1000];\n\n\nvoid solve(){\n    M--;L--;\n    Point rot(cos(toRad(72)),sin(toRad(72)));\n\n    rep(i,N){\n        double x,y,a,r;\n        cin>>x>>y>>a>>r;\n        Point p0(x,y);\n        Point p(0,r);\n        p*=Point(cos(toRad(a)),sin(toRad(a)));\n        for(int j=0;j<5;j++){\n            s[i*5+j]=Segment(p0+p,p0+p*rot*rot);\n            p*=rot;\n        }\n    }\n\n    fill_n(D,N*5,1e12);\n    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>>que;\n    rep(i,5)D[M*5+i]=0,que.push({0,M*5+i});\n\n    while(que.size()){\n        double d;\n        int v;\n        tie(d,v)=que.top();\n        que.pop();\n        if(D[v]<d)continue;\n\n        rep(i,N*5){\n            double cost=getDistanceSS(s[v],s[i]);\n            if(D[i]<=D[v]+cost)continue;\n            D[i]=D[v]+cost;\n            que.push({D[i],i});\n        }\n    }\n\n    double ans=1e12;\n    rep(i,5)chmin(ans,D[L*5+i]);\n    printf(\"%.20f\\n\",ans);\n}\nsigned main(){\n    while(cin>>N>>M>>L,N||M||L)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-9, pi = acos(ld(-1.0));\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\n// Line\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\n// counter clockwise\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\n// 点pから直線lに下ろした垂線の足\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\n// 直線lと線分mが交点を持つか\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点pが線分s上に存在するか\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\n// 線分sと点pの距離\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分sと線分tの距離\nld dist_ss(L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  return min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nstruct Star {\n  vector<L> lines;\n};\n\nld d(Star s1, Star s2) {\n  ld mind = 1000000000.0;\n  REP(i,5)REP(j,5){\n    mind = min(mind,dist_ss(s1.lines[i],s2.lines[j]));\n  }\n  return mind;\n}\n\nint main() {\n  while(1){\n    int n,m,l;\n    cin>>n>>m>>l;\n    --m;--l;\n    vector<Star> s;\n    if(!n)break;\n    REP(i,n){\n      ld x,y,a,r;\n      cin>>x>>y>>a>>r;\n      P p = polar<ld>(r, a/180.0*pi+pi/2.0);\n      P c(x,y);\n      Star st;\n      REP(j,5){\n        st.lines.emplace_back(p*polar<ld>(1.0,2.0*j*pi/2.5)+c,p*polar<ld>(1.0,2.0*(j+1)*pi/2.5)+c);\n      }\n      s.push_back(st);\n    }\n    vector<vector<ld>> dist(n,vector<ld>(n));\n    REP(i,n)REP(j,n){\n      if(i==j){\n        dist[i][j]=0.0;\n      }else{\n        dist[i][j] = d(s[i],s[j]);\n      }\n    }\n    REP(k,n)REP(i,n)REP(j,n)\n      dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n    cout << setprecision(15) << fixed << dist[m][l] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.1415926535897932384626433832795028841971\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvector<P> f(double x, double y, double a, double r){\n    \n    vector<P> ret(5);\n    P vec = P(0.0, r);\n    P add = P(x, y);\n    // a度 左に回転\n    P t = P(cos(a * PI / 180.0), sin(a * PI / 180.0));\n    vec = vec * t;\n    ret[0] = vec + add;\n    t = P(cos(72.0 * PI / 180.0), sin(72.0 * PI / 180.0));\n    for(int i = 1; i < 5; i++){\n        vec = vec * t;\n        ret[i] = vec + add;\n    }\n\n    return ret;\n}\n\ndouble dis(vector<P> a, vector<P> b){\n    double ret = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            if(is_intersected_ls(a[i], a[(i + 2) % 5], b[j], b[(j + 2) % 5])) ret = 0.0;\n            ret = min(ret, distance_ls_p(b[j], b[(j + 2) % 5], a[i]));\n            ret = min(ret, distance_ls_p(b[j], b[(j + 2) % 5], a[(i + 2) % 5]));\n            ret = min(ret, distance_ls_p(a[i], a[(i + 2) % 5], b[j]));\n            ret = min(ret, distance_ls_p(a[i], a[(i + 2) % 5], b[(j + 2) % 5]));\n\n        }\n    }\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<P> > v(n, vector<P> (5));\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            v[i] = f(x, y, a, r);\n        }\n    \n\n        vector<vector<double> > g(n, vector<double> (n, INF));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                g[i][j] = min(g[i][j], dis(v[i], v[j]));\n            }\n        }\n\n       for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n\n        printf(\"%.14f\\n\", g[m - 1][n - 1]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n#include <complex>\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\ninline double cross(const Point& a, const Point& b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n  return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n  b -= a; c -= a;\n  double len = abs(b) * abs(c);\n  if(cross(b, c) > +EPS * len) return +1; // counter-clockwise\n  if(cross(b, c) < -EPS * len) return -1; // clockwise\n  if(dot(b, c) < 0) return +2; // c--a--b\n  if(norm(b) < norm(c)) return -2; // a--b--c\n  return 0; // a--c--b \n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ntypedef pair<double, int> P;\nint main(){\n  int N, M, L;\n  while(cin>>N>>M>>L && N){\n    M--; L--;\n    double x[100], y[100], a[100], r[100];\n    REP(i, N){\n      cin>>x[i]>>y[i]>>a[i]>>r[i];\n    }\n    vector<Line> lines(N * 5);\n    REP(i, N){\n      Point ps[5];\n      REP(j, 5) ps[j] = Point(x[i] + r[i] * cos(M_PI*(90.0 + a[i] + 72 * j)/180.0), y[i] + r[i] * sin(M_PI*(90.0 + a[i] + 72 * j)/180));\n      REP(j, 5) lines[5 * i + j] = Line(ps[j], ps[(j + 2) % 5]);\n    }\n    vector<double> dist(N * 5, INF);\n    priority_queue<P, vector<P>, greater<P> > que;\n    REP(i, 5){\n      dist[5 * M + i] = 0;\n      que.push(P(0, 5 * M + i));\n    }\n    double distance[500][500];\n    REP(i, 5 * N) REP(j, 5 * N) distance[i][j] = distanceSS(lines[i], lines[j]);\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int u = p.second;\n      if(dist[u] != p.first) continue;\n      REP(i, N * 5){\n        double next = dist[u] + distance[u][i];\n        if(next < dist[i]){\n          dist[i] = next;\n          que.push(P(next, i));\n        }\n      }\n    }\n    printf(\"%.10f\\n\", dist[5*L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nconst double PI=acos(-1);\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs(d1)<Abs(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\ntypedef Line Segment;\n\nPoint Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\nbool InterLS(Line l,Segment s){\n\tPoint a=l.pos,b=l.pos+l.dir,c=s.pos,d=s.pos+s.dir;\n\treturn CCW(a,b,c)*CCW(a,b,d)<0;\n}\nbool InterSS(Segment a,Segment b){\n\treturn InterLS(a,b) && InterLS(b,a);\n}\ndouble DistLP(Line l,Point p){\n\treturn Abs(Proj(l,p)-p);\n}\ndouble DistSP(Segment s,Point p){\n\tint ccw=CCW(s.pos,s.pos+s.dir,Proj(s,p));\n\tif(ccw==-2)\n\t\treturn Abs(p-s.pos);\n\tif(ccw==2)\n\t\treturn Abs(p-(s.pos+s.dir));\n\treturn DistLP(s,p);\n}\ndouble DistLS(Line l,Segment s){\n\tif(InterLS(l,s)) return 0;\n\treturn min(DistLP(l,s.pos),DistLP(l,s.pos+s.dir));\n}\ndouble DistSS(Segment a,Segment b){\n\tif(InterSS(a,b)) return 0;\n\tdouble d1=min(DistSP(a,b.pos),DistSP(a,b.pos+b.dir));\n\tdouble d2=min(DistSP(b,a.pos),DistSP(b,a.pos+a.dir));\n\treturn min(d1,d2);\n}\n\nint main()\n{\n\tfor(int n,src,dst;cin>>n>>src>>dst,n|src|dst;){\n\t\tvi xs(n),ys(n),as(n),rs(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i]>>as[i]>>rs[i];\n\t\t\n\t\tvvd dp(n,vd(n,INFTY));\n\t\trep(i,n) rep(j,n){\n\t\t\tPoint p1[6],p2[6];\n\t\t\trep(k,6){\n\t\t\t\tp1[k]=Point(xs[i],ys[i])+Rot(Point(0,rs[i]),(as[i]+k*144)*PI/180);\n\t\t\t\tp2[k]=Point(xs[j],ys[j])+Rot(Point(0,rs[j]),(as[j]+k*144)*PI/180);\n\t\t\t}\n\t\t\trep(k,5) rep(l,5){\n\t\t\t\tSegment s1(p1[k],p1[k+1]-p1[k]);\n\t\t\t\tSegment s2(p2[k],p2[k+1]-p2[k]);\n\t\t\t\tdp[i][j]=min(dp[i][j],DistSS(s1,s2));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tcout<<setiosflags(ios::fixed)<<setprecision(15)<<dp[src-1][dst-1]<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\nusing ll = long long;\n\n#define INF 1e9\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n#define X real()\n#define Y imag()\nusing star = vector<Point>;\n\n\ndouble dot(Point a, Point b){\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b){\n    return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return +1;\n    if(cross(b,c) <-EPS) return -1;\n    if(dot(b,c)   <-EPS) return +2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\n\nbool isecSS(Point a1,Point a2,Point b1,Point b2){\n    return ccw(a1,a2,b1)+ccw(a1,a2,b2) <= 0 &&\n           ccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n\nbool isecSP(Point a1,Point a2,Point b){\n    return !ccw(a1,a2,b);\n}\n\nPoint proj(Point a1, Point a2, Point p){\n    return a1 + dot(a2-a1, p-a1)/norm(a2-a1)*(a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p){\n    Point r = proj(a1,a2,p);\n    if(isecSP(a1,a2,r)) return abs(r-p);\n    return min(abs(a1-p),abs(a2-p));\n}\n\n\ndouble distSS(Point a1,Point a2,Point b1,Point b2){\n    if(isecSS(a1,a2,b1,b2)) return 0;\n    return min({\n        distSP(a1,a2,b1),\n        distSP(a1,a2,b2),\n        distSP(b1,b2,a1),\n        distSP(b1,b2,a2)\n    });\n}\n\nstar make_star(double x,double y,double a,double r){\n    star s(5);\n    rep(i,5){\n        s[i] = Point(x,y) + polar(r, (90+a+144*i)*PI/180.0);\n    }\n    return s;\n}\n\ndouble dist_star(star s1, star s2){\n    double res = INF;\n    rep(i,5)rep(j,5){\n        double dist = distSS(s1[i],s1[(i+1)%5], s2[i],s2[(i+1)%5]);\n        res = min(res,dist);\n    }\n    return res;\n}\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L, N|M|L){\n        vector<star> st(N);\n        rep(i,N){\n            double x,y,a,r;\n            cin>>x>>y>>a>>r;\n            st[i] = make_star(x,y,a,r);\n        }\n        vector<vector<double>> d(N, vector<double>(N, INF));\n        rep(i,N) d[i][i] = 0;\n        rep(i,N)rep(j,i){\n            double dist = dist_star(st[i],st[j]);\n            d[i][j] = dist;\n            d[j][i] = dist;\n        }\n        rep(k,N)rep(i,N)rep(j,N) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n        printf(\"%.20f\\n\",d[M-1][L-1]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef pair<double,double> pdd;\n\nconst double pi = atan(1.0) * 4.0;\nconst double EPS = 1e-8;\n\ndouble cross(pdd x, pdd y) {\n\treturn x.first*y.second - x.second*y.first;\n}\n\ndouble dist(pdd x, pdd y) {\n\treturn sqrt((x.first-y.first)*(x.first-y.first) + (x.second-y.second)*(x.second-y.second));\n}\n\nint main() {\n\tint N, M, L;\n\twhile(scanf(\"%d %d %d\", &N, &M, &L), N) {\n\t\tvector< vector<pdd> > star(N);\n\t\trep(i, N) {\n\t\t\tint x, y, a, r;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &a, &r);\n\t\t\trep(j, 5) {\n\t\t\t\tdouble ang = (72.0 * j + a) * pi / 180.0;\n\t\t\t\tpdd p(x-r*sin(ang), y+r*cos(ang));\n\t\t\t\tstar[i].push_back(p);\n\t\t\t}\n\t\t}\n\t\tdouble cost[100][100];\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = 1e9;\n\t\t\t\tif(i==j) cost[i][j] = 0.0;\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd v1 = pdd(star[i][ii].first - star[i][(ii+2)%5].first, star[i][ii].second - star[i][(ii+2)%5].second);\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tpdd v2 = pdd(star[j][jj].first - star[j][(jj+2)%5].first, star[j][jj].second - star[j][(jj+2)%5].second);\n\t\t\t\t\t\tpdd u1 = pdd(star[i][ii].first - star[j][(jj+2)%5].first, star[i][ii].second - star[j][(jj+2)%5].second);\n\t\t\t\t\t\tpdd u2 = pdd(star[j][jj].first - star[i][(ii+2)%5].first, star[j][jj].second - star[i][(ii+2)%5].second);\n\t\t\t\t\t\tpdd w1 = pdd(star[i][ii].first - star[j][jj].first, star[i][ii].second - star[j][jj].second);\n\t\t\t\t\t\tpdd w2 = pdd(-w1.first, -w1.second);\n\t\t\t\t\t\tif( cross(v1,u1)*cross(v1,w1)<-EPS && cross(v2,u2)*cross(v2,w2)<-EPS ) {\n\t\t\t\t\t\t\tcost[i][j] = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\tpdd s = star[i][ii];\n\t\t\t\t\tpdd t = star[i][(ii+2)%5];\n\t\t\t\t\tdouble alp = 0.0f;\n\t\t\t\t\tif( abs(t.first-s.first) < EPS ) {\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tdouble miny = min(s.second, t.second);\n\t\t\t\t\t\t\tdouble maxy = max(s.second, t.second);\n\t\t\t\t\t\t\tif( miny <= star[j][jj].second && star[j][jj].second <= maxy ) {\n\t\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], abs(t.first - star[j][jj].first));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\talp = (t.second-s.second)/(t.first-s.first);\n\t\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\t\tpdd p = star[j][jj];\n\t\t\t\t\t\t\tdouble qx = (p.first+alp*p.second-alp*s.second+alp*alp*s.first) / (alp*alp+1.0);\n\t\t\t\t\t\t\tdouble qy = alp*(qx-s.first) + s.second;\n\t\t\t\t\t\t\tpdd q = pdd(qx,qy);\n\t\t\t\t\t\t\tif( dist(q,s)<dist(t,s) && dist(q,t)<dist(t,s) ) {\n\t\t\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(p,q));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(ii, 5) {\n\t\t\t\t\trep(jj, 5) {\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], dist(star[i][ii], star[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, N) {\n\t\t\trep(j, N) {\n\t\t\t\tcost[i][j] = cost[j][i] = min(cost[i][j], cost[j][i]);\n\t\t\t}\n\t\t}\n\t\trep(k, N) {\n\t\t\trep(i, N) {\n\t\t\t\trep(j, N) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", min(cost[M-1][L-1],cost[L-1][M-1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<vector>\n#include<map>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//線分p1-p2と線分q1-q2が交差するか\nbool intersecting(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//原点中心回転\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originを中心回転\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//二点間の距離\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//単位ベクトルに変換\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//線分と点の距離\ndouble dist_lp(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal= make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//法線ベクトル\n\tif(intersecting(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//線分同士の距離\ndouble dist_ll(P p1,P p2,P q1,P q2){\n\tif(intersecting(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_lp(p1,p2,q1),dist_lp(p1,p2,q2))\n\t\t,min(dist_lp(q1,q2,p1),dist_lp(q1,q2,p2)) );\n}\n//ラジアンに変換\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n\nvector<pair<P,P> > create_star(double x,double y,double a,double r){\n\tvector<pair<P,P> > res;\n\tvector<P> p;\n\tfor(int i=0;i<5;i++){\n\t\tdouble rad = radian(18+i*72);\n\t\tp.push_back( P(x,y) +rotate(P(r*cos(rad),r*sin(rad)) ,a) );\n\t}\n\tfor(int i=0;i<5;i++){\n\t\tres.push_back( make_pair(p[i],p[(i+2)%5]) );\n\t}\n\treturn res;\n}\ndouble dist_star(vector<pair<P,P> > &a,vector<pair<P,P> > &b){\n\tdouble res=INF;\n\tfor(int i=0;i<a.size();i++){\n\t\tfor(int j=0;j<b.size();j++){\n\t\t\tres = min(res, \n\t\t\t\tdist_ll(a[i].first,a[i].second,b[j].first,b[j].second) );\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tdouble d[100][100];\n\tvector<vector<pair<P,P> > > stars;\n\tint N,M,L;\n\tdouble x,y,a,r;\n\twhile(cin>>N>>M>>L, N||M||L){\n\t\tM--;\n\t\tL--;\n\t\tstars.clear();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tstars.push_back(create_star(x,y,radian(a),r));\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i;j<N;j++){\n\t\t\t\td[i][j]=d[j][i] = dist_star(stars[i],stars[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<N;k++)\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\tprintf(\"%.20f\\n\",d[M][L]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\ntypedef complex<double> PT;\ntypedef PT VC;\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b) / abs(l.fi-l.se));\n}\n\n// ??\\??????????????????????????????\n\n// ???????????´??????????????£???????????????false??????????????§??¨???\nbool has_intersec_seg_seg(SG a, SG b) {\n\tVC va, vb, vc;\n\tbool res = true;\n\tfor(int i = 0; i < 2; i++) {\n\t\tva = b.fi-a.fi; vb = b.se-a.fi; vc = a.se-a.fi;\n\t\tres = res && cross_prod(va, vc) * cross_prod(vb, vc) < EPS;\n\t\tswap(a,b);\n\t}\n\tres = res && abs(cross_prod(a.fi-a.se, b.fi-b.se)) > EPS;\n\treturn res;\n}\n\ndouble dist_pts_seg(PT p, SG a) {\n\tdouble res;\n\tres = min(abs(a.fi-p), abs(a.se-p));\n\tif(dot_prod(a.se - a.fi, p - a.fi) > -EPS\n\t\t\t&& dot_prod(a.fi - a.se, p - a.se) > -EPS)\n\t\tres = min(res, dist_pts_line(p, a));\n\treturn res;\n}\n\ndouble dist_seg_seg(SG a, SG b) {\n\tdouble res;\n\tfor(int i = 0; i < 2; i++) {\n\t\tres = min(dist_pts_seg(a.fi,b), dist_pts_seg(a.se,b));\n\t\tswap(a,b);\n\t}\n\tif(has_intersec_seg_seg(a,b))\n\t\tres = 0;\n\treturn res;\n}\n\n/* //???????????????\nint main() {\n\tSG a(PT(0,0),PT(0,2));\n\tSG b(PT(-1,1),PT(2,1));\n\tcout << dist_seg_seg(a,b) << endl;\n} // */\n\n//*\nint N, M, L;\nvector<vector<SG> > star;\ndouble edge[120][120];\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nvoid init() {\n\tstar.clear();\n\trep(i,120) {\n\t\trep(j,120)\n\t\t\tedge[i][j] = 1e9;\n\t\tedge[i][i] = 0;\n\t}\n}\n\nint main() {\n\twhile(cin >> N >> M >> L, N || M || L) {\n\t\tinit();\n\t\tM--; L--;\n\t\trep(i,N) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<PT> tmp;\n\t\t\tdouble theta = (a+90) / 180.0 * M_PI;\n\t\t\tdouble phi = 360.0 / 5.0 / 180.0 * M_PI;\n\t\t\trep(i,5) {\n\t\t\t\ttmp.push_back(polar((double)r, theta + phi * i) + PT(x,y));\n\t\t\t//\tcout << tmp[i] << endl;\n\t\t\t}\n\t\t\tvector<SG> push;\n\t\t\trep(i,5) {\n\t\t\t\tpush.push_back(SG(tmp[i],tmp[(i+2)%5]));\n\t\t\t}\n\t\t\tstar.push_back(push);\n\t\t}\n\n\t\trep(i,N) {\n\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\tdouble tmp = 1e9;\n\t\t\t\trep(k,5) {\n\t\t\t\t\trep(l, 5) {\n\t\t\t\t\t\ttmp = min(tmp, dist_seg_seg(star[i][k], star[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\trep(i,N) {\n\t\t\trep(j,N) {\n\t\t\t\trep(k,N) {\n\t\t\t\t\tedge[j][k] = min(edge[j][k], edge[j][i] + edge[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", edge[L][M]);\n\t}\n}\n// */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble dis[101][101];\nvector<Polygon> Stars;\nint N,M,L,x,y,a,r;\n\ndouble getDis(Polygon a,Polygon b){\n  double mind=inf;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      Segment s1(a[i],a[(i+2)%5]),s2(b[j],b[(j+2)%5]);\n      mind=min(getDistance(s1,s2),mind);\n    }\n  }\n  return mind;\n}\n\ndouble Dijkstra()\n{\n  priority_queue<pair<double,int> > PQ;\n  int color[101];\n  double d[101];\n  for(int i=0;i<N;i++){\n    d[i]=inf;\n    color[i]=0;\n  }\n  d[M-1]=0;\n  PQ.push(make_pair(0,M-1));\n  color[M-1]=0;\n  while(!PQ.empty()){\n    pair<double,int> p=PQ.top();PQ.pop();\n    int u=p.s;\n    color[u]=2;\n\n    if(d[u]<p.f*(-1))continue;\n\n    for(int i=0;i<N;i++){\n      if(color[i]==2 || dis[u][i]==inf)continue;\n      if(d[i]>dis[u][i]+d[u]){\n\td[i]=dis[u][i]+d[u];\n\tPQ.push(make_pair(d[i]*(-1),i));\n\tcolor[i]=1;\n      }\n    }\n  }\n  return d[L-1];\n}  \n\nint main()\n{\n  while(1){\n    cin>>N>>M>>L;\n    if(N+M+L==0)break;\n    Stars.clear();\n    for(int i=0;i<N;i++){\n      cin>>x>>y>>a>>r;\n      Polygon p;\n      for(int i=0;i<5;i++){\n\tp.push_back(PointRotation(Point(x,y),Point(x,y+r),(a+i*72)));\n      }\n      Stars.push_back(p);\n    }\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif(i==j)dis[i][j]=0;\n\telse dis[i][j]=getDis(Stars[i],Stars[j]);\n      }\n    }\n    printf(\"%.10f\\n\",Dijkstra());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define FOR(i, s, n) for (int i = (s); i < (n); i++)\n#define RFOR(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n#define ALL(a) a.begin(),a.end()\n#define IN(a,x,b) (a<=x && x<b)\n//const long long MOD = 1e9+7, INF = 1e18;\ntemplate<class T>inline bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nvoid warshall_floyd(int n,vector<vector<double>>&d){\n  FOR(i,0,n)FOR(j,0,n)FOR(k,0,n){\n    if(d[j][k]>d[j][i]+d[i][k])d[j][k]=d[j][i]+d[i][k];\n  }\n}\n\ndouble EPS = 1e-6;\nconst double INF = 1LL<<60;  \nconst double PI = acos(-1.0);\ndouble torad(int deg) {return (double)(deg) * PI / 180;}\ndouble todeg(double ang) {return ang * 180 / PI;}\n\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\n//交差判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;\n}\n\n//交差座標\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1 + (p2-p1) * ((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\n//線分と線分の公差判定\nbool crossLine(P A,P B,P C,P D){\n\tint flg = 0;\n\tif((A-B).det(C-D)==0){\n\t\tflg |= on_seg(A,B,C);\n\t\tflg |= on_seg(A,B,D);\n\t\tflg |= on_seg(C,D,A);\n\t\tflg |= on_seg(C,D,B);\n\t}else{\n\t\tP r = intersection(A,B,C,D);\n\t\tflg = on_seg(A,B,r) && on_seg(C,D,r);\n\t}\n\treturn flg;\n}\n\n//点と線分の最も近い座標\nP distanceLP(P A,P B,P p){\n\tP a,b;\n\tdouble r;\n\ta.x = B.x - A.x;\n\ta.y = B.y - A.y;\n\tb.x = p.x - A.x;\n\tb.y = p.y - A.y;\n\tr = (a.x*b.x + a.y*b.y) / (a.x*a.x + a.y*a.y);\n\t\n\tif( r<= 0 ){\n\t\treturn A;\n\t}else if( r>=1 ){\n\t\treturn B;\n\t}else{\n\t\tP result;\n\t\tresult.x = A.x + r*a.x;\n\t\tresult.y = A.y + r*a.y;\n\t\treturn result;\n\t}\n}\n\n//二点間の距離\ndouble distance(P A,P B){\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\n//線分と線分の最短距離\ndouble distanceLL(P A,P B,P C,P D){\n\tP a = distanceLP(C,D,A);\n\tP b = distanceLP(C,D,B);\n\tP c = distanceLP(A,B,C);\n\tP d = distanceLP(A,B,D);\n\tif(crossLine(A,B,C,D))return 0.0;\n\treturn min({distance(C,c),distance(C,d),distance(A,b),distance(A,a)});\n}\n\nint N,M,R;\n\ndouble solve(){\n\tvector<vector<P>>line(N,vector<P>(5));\n\tREP(i,N){\n\t\tdouble a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tREP(j,5){\n\t\t\tdouble kakudo = torad(90+c+j*72);\n\t\t\tline[i][j] = P(a+d*cos(kakudo),b+d*sin(kakudo));\n\t\t}\n\t}\n\tvector<vector<double>>d(N,vector<double>(N));\n\tREP(i,N){\n\t\tREP(j,N){\n\t\t\tdouble mi = INF;\n\t\t\tREP(k,5){\n\t\t\t\tREP(l,5){\n\t\t\t\t\tchmin(mi,distanceLL(line[i][k],line[i][(k+2)%5],line[j][l],line[j][(l+2)%5]));\n\t\t\t\t}\n\t\t\t}\n\t\t\td[i][j] = mi;\n\t\t}\n\t}\n\twarshall_floyd(N,d);\n\t/*\n\tREP(i,N){\n\t\tREP(j,N){\n\t\t\tif(j)cout<<\" \";\n\t\t\tcout<<d[i][j];\n\t\t}\n\t\tcout<<endl;\n\t}/*\n\tcout<<M<<\" \"<<R<<\" \"<<d[M-1][R-1]<<endl;*/\n\treturn d[M-1][R-1];\n}\n\nsigned main(){\n\tvector<double>ans;\n\twhile(cin>>N>>M>>R,N||M||R)ans.push_back(solve());\n\tfor(auto e:ans) cout << fixed << setprecision(20) << e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-7;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 2. * PI / 5.));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e9;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\nconst double PI=atan(1.0)*4;\nint N,M,L;\ndouble xs[101];\ndouble ys[101];\ndouble as[101];\ndouble rs[101];\nP starP[101][101];\npair<P,P> starEdges[101][101];\nstruct edge{\n\tint to;\n\tdouble cost;\n};\nvector<edge>G[10001];\nP roundPoint(P p,double a){\n\treturn P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\ndouble dot(P a,P b){\n\treturn (a.real()*b.real()+a.imag()*b.imag());\n}\ndouble cross(P a,P b){\n\treturn (a.real()*b.imag()-a.imag()*b.real());\n}\ndouble distance_ls_p(P a,P b,P c){\n\tif(dot(b-a,c-a)<EPS)return abs(c-a);\n\tif(dot(a-b,c-b)<EPS)return abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);\n}\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n\tif(abs(cross(a2-a1,b2-b1)<EPS))return false;\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS)&&\n\t\t(cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS);\n}\ntypedef pair<double,pii> pdi;\ndouble d[101][101];\nconst double INF=(1LL<<30);\ndouble dijkstra(){\n\tpriority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n\tfor(int i=0;i<101;i++)\n\t\tfor(int j=0;j<101;j++)\n\t\t\td[i][j]=INF;\n\tfor(int i=0;i<5;i++){\n\t\td[M][i]=0;\n\t\tpq.push(pdi(0,pii(M,i)));\n\t}\n\twhile(pq.size()){\n\t\tpdi p=pq.top();pq.pop();\n\t\tdouble ccost=p.first;\n\t\tint cnode=p.second.first;\n\t\tint cedge=p.second.second;\n\t\tif(!EQ(d[cnode][cedge],ccost)&&d[cnode][cedge]<ccost)continue;\n\t\tfor(int i=0;i<G[cnode*5+cedge].size();i++){\n\t\t\tedge &e=G[cnode*5+cedge][i];\n\t\t\tint tnode=(e.to)/5;\n\t\t\tint tedge=(e.to)%5;\n\t\t\tif(!EQ(d[tnode][tedge],ccost+e.cost)&&d[tnode][tedge]>ccost+e.cost){\n\t\t\t\td[tnode][tedge]=ccost+e.cost;\n\t\t\t\tpq.push(pdi(d[tnode][tedge],pii(tnode,tedge)));\n\t\t\t}\n\t\t}\n\t}\n\tdouble res=INF;\n\tfor(int i=0;i<5;i++){\n\t\tres=min(res,d[L][i]);\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\twhile(cin>>N>>M>>L&&(N|M|L)){\n\t\tM--;L--;\n\t\tfor(int i=0;i<10001;i++)\n\t\t\tG[i].clear();\n\t\tfor(int i=0;i<N;i++)\n\t\t\tcin>>xs[i]>>ys[i]>>as[i]>>rs[i];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tedge e;\n\t\t\t\te.cost=0;\n\t\t\t\tint from=i*5+j;\n\t\t\t\tint to=i*5+(j+1);\n\t\t\t\te.to=to;\n\t\t\t\tG[from].push_back(e);\n\t\t\t\te.to=from;\n\t\t\t\tG[to].push_back(e);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tP cp=P(xs[i],ys[i]);\n\t\t\tP up=P(xs[i],ys[i]+rs[i]);\n\t\t\tP base=P(0,rs[i]);\n\t\t\tP roundP=roundPoint(base,(1.0*as[i]/180)*PI);\n\t\t\tstarP[i][0]=roundP+cp;\n\t\t\tfor(int j=1;j<5;j++){\n\t\t\t\troundP=roundPoint(roundP,(72.0/180)*PI);\n\t\t\t\tstarP[i][j]=roundP+cp;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tstarEdges[i][j]=make_pair(starP[i][j],starP[i][(j+2)%5]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\t\tpair<P,P> &e1=starEdges[i][j];\n\t\t\t\t\t\tpair<P,P> &e2=starEdges[k][l];\n\t\t\t\t\t\t// クロスしてる場合\n\t\t\t\t\t\tif(is_intersected_ls(e1.first,e1.second,e2.first,e2.second)){\n\t\t\t\t\t\t\tint from=i*5+j;\n\t\t\t\t\t\t\tint to=k*5+l;\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=0;\n\t\t\t\t\t\t\te.to=to;\n\t\t\t\t\t\t\tG[from].push_back(e);\n\t\t\t\t\t\t\te.to=from;\n\t\t\t\t\t\t\tG[to].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//e1.first\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble dist=distance_ls_p(e2.first,e2.second,e1.first);\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=dist;\n\t\t\t\t\t\t\te.to=k*5+l;\n\t\t\t\t\t\t\tint from=i*5+j;\n\t\t\t\t\t\t\tint to=k*5+l;\n\t\t\t\t\t\t\tG[from].push_back(e);\n\t\t\t\t\t\t\te.to=from;\n\t\t\t\t\t\t\tG[to].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// e1.second\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble dist=distance_ls_p(e2.first,e2.second,e1.second);\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=dist;\n\t\t\t\t\t\t\te.to=k*5+l;\n\t\t\t\t\t\t\tint from=i*5+j;\n\t\t\t\t\t\t\tint to=k*5+l;\n\t\t\t\t\t\t\tG[from].push_back(e);\n\t\t\t\t\t\t\te.to=from;\n\t\t\t\t\t\t\tG[to].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=dijkstra();\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n}\n\nint main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\ntypedef complex<double> P;\n\nconst double EPS = 1e-8, INF = 1e12;\ndouble cross(const P &a, const P &b){\n\treturn imag(conj(a) * b);\n}\ndouble dot(const P &a, const P &b){\n\treturn real(conj(a) * b);\n}\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpb(a); pb(b);\n\t}\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c){\n\tb -= a; c -= a;\n\tif(cross(b, c) > EPS) return 1;\n\tif(cross(b, c) < -EPS) return -1;\n\tif(dot(b, c) < -EPS) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSP(const L &s, const P &p){\n\treturn ccw(p, s[0], s[1]) == 2;\n}\nbool intersectSS(const L &s, const L &t){\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nP projection(const L &l, const P &p){\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t * (l[0] - l[1]);\n}\ndouble distanceSP(const L &s, const P &p){\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t){\n\tif(intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nconst double PI = acos(-1);\nint n, m, l;\nint x[100], y[100], a[100], r[100];\ndouble dist[100][100];\n\nint main(){\n\twhile(cin >> n >> m >> l, n){\n\t\trep(i, n) cin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\tvector<G> stars;\n\t\trep(i, n){\n\t\t\tdouble t = a[i] * PI / 180;\n\t\t\tG star;\n\t\t\trep(j, 5){\n\t\t\t\tdouble tt = PI / 2 + t + PI * 0.4 * j;\n\t\t\t\tstar.pb(P(cos(tt), sin(tt)) * (double)r[i] + P(x[i], y[i]));\n\t\t\t}\n\t\t\tstars.pb(star);\n\t\t}\n\t\trep(i, n) rep(j, i){\n\t\t\tdouble mn = INF;\n\t\t\trep(l, 5) rep(k, 5){\n\t\t\t\tL la(stars[i][l], stars[i][(l + 2) % 5]);\n\t\t\t\tL lb(stars[j][k], stars[j][(k + 2) % 5]);\n\t\t\t\tmn = min(mn, distanceSS(la, lb));\n\t\t\t}\n\t\t\tdist[i][j] = dist[j][i] = mn;\n\t\t}\n\t\tpriority_queue<pair<double, int> > q;\n\t\tq.push(mp(0, m - 1));\n\t\tset<int> s;\n\t\twhile(!q.empty()){\n\t\t\tint c = q.top().second;\n\t\t\tdouble cc = q.top().first;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(c)) continue;\n\t\t\ts.insert(c);\n\t\t\t\n\t\t\tif(c == l - 1){\n\t\t\t\tprintf(\"%.9f\\n\", abs(cc));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i, n) q.push(mp(cc - dist[c][i], i));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nconstexpr double INF = numeric_limits<double>::max();\n\nconstexpr double EPS = 1e-8;\n\ndouble sq (const double v) { return v * v; }\n\nstruct Vec {\n    double x, y;\n    Vec () {}\n    ~Vec (){ }\n\n    Vec (double x_, double y_): x(x_), y(y_) {}\n\n    Vec operator + (const Vec& o) const { return Vec(x + o.x, y + o.y); }\n    Vec operator - (const Vec& o) const { return Vec(x - o.x, y - o.y); }\n};\n\ndouble inner_prod(const Vec p1, const Vec p2) { return p1.x * p2.x + p1.y * p2.y; }\n\nstruct line {\n    Vec p1, p2;\n\n    line (Vec p1_, Vec p2_): p1(p1_), p2(p2_) {}\n};\n\nstruct star {\n    double x, y, a, r;\n    star () {}\n    ~star () {}\n\n    star (double x_, double y_, double a_, double r_): x(x_), y(y_), a(a_), r(r_) {}\n\n    vector<Vec> get_vertices () {\n        vector<Vec> ret;\n\n        for (int j = 0; j < 5; ++j) {\n            const double rad = a + 72*j;\n\n            const double ret_x = x - r * sin(M_PI * rad / 180);\n            const double ret_y = y + r * cos(M_PI * rad / 180);\n\n            ret.emplace_back(ret_x, ret_y);\n        }\n\n        return ret;\n    }\n\n    vector<line> get_lines () {\n        vector<line> ret;\n\n        auto vs = get_vertices();\n        assert(vs.size() == 5);\n        for (int j = 0; j < 5; ++j) ret.emplace_back(vs[j], vs[(j+2)%5]);\n\n        return ret;\n    }\n};\n\ndouble dist_ps (const Vec p, const line l) {\n\n    if (inner_prod(p - l.p1, l.p2 - l.p1) <= 0 || inner_prod(p - l.p2, l.p1 - l.p2) <= 0) {\n        double d1 = sq(p.x - l.p1.x) + sq(p.y - l.p1.y);\n        double d2 = sq(p.x - l.p2.x) + sq(p.y - l.p2.y);\n\n        return min(d1, d2);\n    }\n\n    if (abs(l.p1.x * l.p2.y - l.p2.x * l.p1.y) < EPS) {\n        const double a = l.p1.x, b = l.p1.y;\n        return sq(a * p.x + b * p.y) / (a * a + b * b);\n    }\n\n    const double a = (l.p1.y - l.p2.y) / (l.p1.x * l.p2.y - l.p2.x * l.p1.y);\n    const double b = (l.p1.x - l.p2.x) / (l.p1.y * l.p2.x - l.p2.y * l.p1.x);\n    return sq(a * p.x + b * p.y + 1) / (a * a + b * b);\n}\n\ndouble dist2lines(const line l1, const line l2) {\n    double ans = numeric_limits<double>::max();\n    ans = min(ans, dist_ps(l1.p1, l2));\n    ans = min(ans, dist_ps(l1.p2, l2));\n    ans = min(ans, dist_ps(l2.p1, l1));\n    ans = min(ans, dist_ps(l2.p2, l1));\n    return ans;\n}\n\n// --------------------------------------------------\n\nstruct state {\n    int pos; double dist;\n    state (int pos_, double dist_): pos(pos_), dist(dist_) {}\n\n    bool operator < (const state& o) const {\n        return dist > o.dist;\n    }\n};\n\n// --------------------------------------------------\n\nint N, M, L;\ndouble x[100], y[100], a[100], r[100];\n\ndouble graph[100][100];\n\ndouble solve() {\n    for (int j = 0; j < N; ++j) fill(graph[j], graph[j]+N, INF);\n    for (int j = 0; j < N; ++j) graph[j][j] = 0;\n\n    vector<star> stars;\n    for (int j = 0; j < N; ++j) stars.emplace_back(x[j], y[j], a[j], r[j]);\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            star s1 = stars[j], s2 = stars[k];\n\n            vector<line> ls1 = s1.get_lines();\n            vector<line> ls2 = s2.get_lines();\n\n            for (auto& e: ls1) {\n                for (auto& f: ls2) {\n                    graph[j][k] = graph[k][j] = min(graph[j][k], sqrt(dist2lines(e, f)));\n                }\n            }\n        }\n    }\n\n    double min_dist[100];\n    fill(min_dist, min_dist+N, INF);\n    min_dist[M] = 0;\n\n    priority_queue<state> pq;\n    pq.emplace(M, 0);\n\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n\n        if (st.dist > min_dist[st.pos]) { continue; }\n\n        for (int j = 0; j < N; ++j) {\n            if (j == st.pos) continue;\n\n            if (min_dist[j] > st.dist + graph[st.pos][j]) {\n                min_dist[j] = st.dist + graph[st.pos][j];\n\n                pq.emplace(j, min_dist[j]);\n            }\n        }\n    }\n\n    return min_dist[L];\n}\n\nint main() {\n    line l1 = {{5, 0}, {15, 0}};\n    Vec p1 = {5, 0};\n\n    while (true) {\n        cin >> N >> M >> L;\n        if (N == 0 && M == 0 && L == 0) break;\n\n        --M; --L;\n\n        for (int j = 0; j < N; ++j) {\n            cin >> x[j] >> y[j] >> a[j] >> r[j];\n        }\n\n        printf(\"%.12f\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  double x, y, a, r;\n  ST(){}\n  ST(double x, double y, double a, double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst double INF = 1000000000.0;\nconst double EPS = 1e-8;\n\nint n, s, t;\nvector<ST> input;\ndouble dist[N][N];\n\ndouble dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec, vector<Point>& vec2){\n  Point o = Point(st.x, st.y);\n  Point p = Point(st.x, st.y + st.r);\n  for(int i=0;i<5;i++){\n    vec2.push_back(rotate(p, o, st.a+72.0*i));\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){vec2[i], vec2[i+1]});\n  }\n  vec.push_back((Segment){vec2[4], vec2[0]});\n}\n\ndouble calc_dist(ST pa, ST pb){\n  vector<Segment> a1, b1;\n  vector<Point> a2, b2;\n  get_seg(pa, a1, a2);\n  get_seg(pb, b1, b2);\n  double res = INF;\n  for(int i=0;i<a1.size();i++){\n    for(int j=0;j<b1.size();j++){\n      res = min(res, getDistance(a1[i], b1[j]));\n    }\n  }\n  for(int i=0;i<a2.size();i++){\n    for(int j=0;j<b2.size();j++){\n      res = min(res, abs(a2[i] - b2[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\ndouble solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.15f\\n\", (double)solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<complex>\n#include<iomanip>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\n#define EPS (1e-10)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\ntypedef complex<double> point;\n\nstatic const double pi = acos(-1.0);\n\ndouble dot(point a, point b){\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\n\ndouble cross(point a, point b){\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\nint is_orthogonal(point a1, point a2, point b1, point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n\nint is_parallel(point a1, point a2, point b1, point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// distance between the line ab and the point c\ndouble dis_lp(point a, point b, point c){\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// distance between the line segment ab and the point c\ndouble dis_lsp(point a, point b, point c){\n    if(dot(b-a, c-a)<0) return abs(c-a);\n    if(dot(a-b, c-b)<0) return abs(c-b);\n    return dis_lp(a, b, c);\n}\n\nint is_intersected(point a1, point a2, point b1, point b2){\n    return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1)<0) && \n           (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1)<0);\n}\n\n// rotation\npoint rotate(point a, double d){\n    point r = polar(1.0, d*2*pi/360);\n    return a*r;\n}\n\nint INF = 10e8;\nint n, m, l;\ndouble dis[100][100];\ndouble x[100];\ndouble y[100];\ndouble a[100];\ndouble r[100];\n\ncomplex<double> star[100][5];\n\nint main(){\n    while(1){\n        cin >> n >> m >> l;\n        if(n==0) break;\n\n        REP(i, n){\n            REP(j, n){\n                dis[i][j] = INF;\n            }\n        }\n\n        REP(i, n){\n            cin >> x[i] >> y[i] >> a[i] >> r[i];\n            point p = point(x[i], y[i]);\n            point t = point(0, r[i]);\n            REP(j, 5){\n                star[i][j] = p + rotate(t, (double)144*j+a[i]);\n            }\n        }\n\n        /*\n        REP(i, n){\n            REP(j, 5){\n                cout << star[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        REP(i, n){\n            REP(j, n){\n                REP(k, 5){\n                    REP(l, 5){\n                        if(is_intersected(star[i][k], star[i][(k+1)%5], star[j][l], star[j][(l+1)%5])){\n                            dis[i][j] = 0;\n                        }\n                    }\n                }\n            }\n        }\n\n        REP(i, n){\n            REP(j, n){\n                REP(k, 5){\n                    REP(l, 5){\n                        dis[i][j] = min(dis[i][j], dis_lsp(star[i][k], star[i][(k+1)%5], star[j][l]));\n                        dis[j][i] = min(dis[i][j], dis[j][i]);\n                    }\n                }\n            }\n        }\n\n        /*\n        REP(i, n){\n            REP(j, n){\n                cout << dis[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        REP(k, n){\n            REP(i, n){\n                REP(j, n){\n                    dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);\n                }\n            }\n        }\n\n        cout << fixed << setprecision(7) << dis[m-1][l-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<complex>\n#define INF 10000000.0\n#define pb push_back\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef __int64 ll;\ntypedef complex<double> Point;\ntypedef pair<double ,int > P;\nconst double PI=4*atan(1);\nvector<vector<Point> > p;\nint n,s,g;\ndouble dot(Point a, Point b){\n    return real( conj(a) * b );\n}\ndouble cross(Point a, Point b){\n    return imag( conj(a) * b );\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a)<=0 ) return abs(c-a);\n  if ( dot(a-b, c-b)<=0 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble cal(int a,int b){\n\tdouble ret=INF;\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=i+1;j<5;j++){\n\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t//cout<<distance_ls_p(p[a][i],p[a][j],p[b][k])<<endl;\n\t\t\t\t//cout<<distance_ls_p(p[b][i],p[b][j],p[a][k])<<endl;\n\t\t\t\tdouble u=distance_ls_p(p[a][i],p[a][j],p[b][k]),v=distance_ls_p(p[b][i],p[b][j],p[a][k]);\n\t\t\t\tif(ret>u)\n\t\t\t\tret=u;\n\t\t\t\tif(ret>v)\n\t\t\t\tret=v;\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<ret<<endl;\n\treturn ret;\n}\n\n\n\nint main(){\n\twhile(cin>>n>>s>>g,n||s||g){\n\t\tp.clear();\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,a,r;\n\t\t\tPoint pot;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tPoint c=Point(x,y);\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tp[i].pb(c+polar(r,PI*(a+(double)j*72.0+90.0)/180.0));\n\t\t\t}\n\t\t}\n\t\t//cout<<\"      \"<<distance_ls_p(p[0][4],p[0][1],p[2][2])<<endl;\n\n\t\t\n\t\tvector<vector<double> > cost(n,vector<double>(n,INF));\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble a=cal(i,j);\n\t\t\t\tcost[i][j]=a;\n\t\t\t\tcost[j][i]=a;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcout<<cost[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,s-1));\n\t\tvector<double> d(n,INF);\n\t\td[s-1]=0;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();\n\t\t\tint pos=q.second;\n\t\t\tdouble dist=q.first;\n\t\t\tque.pop();\n\t\t\tif(pos==g-1){\n\t\t\t\tprintf(\"%.8lf\\n\",dist);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dist>d[pos]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\n\t\t\t\tif(cost[pos][i]==INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cost[pos][i]+dist<d[i]){\n\t\t\t\t\tque.push(P(cost[pos][i]+dist,i));\n\t\t\t\t\td[i]=cost[pos][i]+dist;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cmath>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<29)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<Point> vp;\ntypedef vector<vp> vvp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\n\n\nint N,M,L;\n\nint main()\n{\n  while(cin >> N >> M >> L,N|M|L)\n    {\n      vvp info(N);\n      vvd G(N,vd(N));\n      rep(i,N)rep(j,N)G[i][j] = (i==j?0:inf);\n\n      rep(i,N)\n\t{\n\t  double x,y,a,r;\n\t  cin >> x >> y >> a >> r;\n\t  rep(j,5)\n\t    {\n\t      Point p = Point(0,r);\n\t      p = rotate(p,toRad(a+72*j));\n\t      info[i].push_back(Point(p.x+x,p.y+y));\n\t    }\n\t}\n\n      rep(i,N)//from\n\t{\n\t  //REP(j,i+1,N)//to\n\t  rep(j,N)\n\t    {\n\t      double mincost = inf;\n\n\t      rep(k,5)\n\t\t{\n\t\t  rep(l,5)\n\t\t    {\n\t\t      if(isIntersect(Segment(info[i][k],info[i][(k+2)%5]),Segment(info[j][l],info[j][(l+2)%5])) || isIntersect(Segment(info[i][k],info[i][(k+2)%5]),Segment(info[j][l],info[j][(l+3)%5])))\n\t\t\t{\n\t\t\t  mincost = 0;\n\t\t\t  break;\n\t\t\t}\t\t    \n\t\t      if(isIntersect(Segment(info[i][k],info[i][(k+3)%5]),Segment(info[j][l],info[j][(l+2)%5])) || isIntersect(Segment(info[i][k],info[i][(k+3)%5]),Segment(info[j][l],info[j][(l+3)%5])))\n\t\t\t{\n\t\t\t  mincost = 0;\n\t\t\t  break;\n\t\t\t}\t\t    \n\t\t    }\n\t\t  if(mincost == 0)break;\n\t\t}\n\n\t      if(mincost == 0)goto Next;\n\n\t      rep(k,5)//which node\n\t\t{\n\t\t  rep(l,5)//which segment\n\t\t    {\n\t\t      mincost = min(mincost,min(getDistanceSP(Segment(info[j][l],info[j][(l+2)%5]),info[i][k]),\n\t\t\t\t\t\tgetDistanceSP(Segment(info[j][l],info[j][(l+3)%5]),info[i][k])));\n\t\t    }\n\t\t}\n\n\t    Next:;\n\t      G[i][j] = G[j][i] = min(mincost,min(G[i][j],G[j][i]));\n\t    }\n\t}\n\n\n      rep(k,N)rep(i,N)rep(j,N)G[i][j] = min(G[i][j],\n\t\t\t\t\t    G[i][k]+G[k][j]);      \n\n      cout << setiosflags(ios::fixed) << setprecision(2000) << G[M-1][L-1] << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \ntemplate<typename T=int>inline T readT() {\n  char c = getchar_unlocked(); bool neg = (c=='-');\n  T res = neg?0:c-'0';\n  while(isdigit(c=getchar_unlocked())) res = res*10 + c-'0';\n  return neg?-res:res;\n}\ntemplate<typename T=int>inline void writeT(T x, char c='\\n'){\n  int d[20],i=0; if(x<0)putchar_unlocked('-'),x*=-1;\n  do{d[i++]=x%10;}while(x/=10); while(i--)putchar_unlocked('0'+d[i]);\n  putchar_unlocked(c);\n}\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\nusing Point = complex<double>;\n\nistream &operator>>(istream &is, Point &p)\n{\n    double a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\nostream &operator<<(ostream &os, Point &p)\n{\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nconst double  PI = acos(-1);\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\n//二つのスカラーが等しいか\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n//二つのベクトルが等しいか\n#define EQV(a, b) (EQ((a), real(), (b).real()) && EQ((a), imag(), (b).imag()))\n\nnamespace std\n{\nbool operator<(const Point &a, const Point &b)\n{\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nstruct Line\n{\n    Point a, b;\n    Line() {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    //a, bはそれぞれ座標を指す. これより一つの「line」に対して二個の点を持つことになる\n    Line(double A, double B, double C) // Ax + By = C\n    {\n        if (eq(A, 0))\n            a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0))\n            b = Point(C / A, 0), b = Point(C / A, 1);\n        else\n            a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p)\n    {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a)\n    {\n        return is >> a.a >> a.b;\n    }\n};\n\nstruct Segment : Line\n{\n    Segment() {}\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\ndouble dot(const Point a, const Point b)\n{\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(const Point a, const Point b)\n{\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nint ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS)\n        return +1; // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -EPS)\n        return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0)\n        return +2; // \"ONLINE_BACK\"\n    if (norm(b) < norm(c))\n        return -2; // \"ONLINE_FRONT\"\n    return 0;      // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b)\n{\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b)\n{\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p)\n{\n    return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p)\n{\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m)\n{\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p)\n{\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s)\n{\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m)\n{\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m)\n{\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\ndouble distance(const Point &a, const Point &b)\n{\n    return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p)\n{\n    return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m)\n{\n    return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p)\n{\n    Point r = projection(s, p);\n    if (intersect(s, r))\n        return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b)\n{\n    if (intersect(a, b))\n        return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s)\n{\n    if (intersect(l, s))\n        return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nusing ld= long double;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(18);\n    \n    int N, M, L;\n    while(cin >> N >> M >> L){\n        if(N == 0 && M == 0 && L == 0){\n            break;    \n        }\n        M--; L--;\n        vector<ld> x(N), y(N), a(N), r(N);\n\n        vector<Segment> vp[110];\n        for(int i=0; i<N; i++){\n            cin >> x[i] >> y[i] >> a[i] >> r[i];\n            vector<pair<ld, ld>> pts;\n            ld theta1 = a[i]*pi/180;\n            ld aa = -sin(theta1) * r[i];\n            ld bb = cos(theta1) * r[i];\n            pts.push_back(make_pair(aa + x[i], bb + y[i]));\n            // 原点に戻したとき(0, r[i])\n\n            \n\n            // x' = -sin0 * r[i] + x[i]\n            // y' = cos0 * r[i] + y[i]\n            \n            \n\n            ld theta2 = 72*pi/180;\n            for(int j=0; j<4; j++){\n                ld a2 = cos(theta2) * aa - sin(theta2) * bb;\n                ld b2 = sin(theta2) * aa + cos(theta2) * bb;\n                pts.push_back({a2+x[i], b2+y[i]});\n                aa = a2;\n                bb = b2;\n            }\n\n            // for(int j=0; j<pts.size(); j++){\n            //     cout << pts[j].first << \" \" << pts[j].second << endl;\n            // }\n            \n            for(int j=0; j<5; j++){\n                Segment s1(Point(pts[j].first, pts[j].second), Point(pts[(j+2)%5].first, pts[(j+2)%5].second));\n                vp[i].push_back(s1);\n            }\n        }\n\n        vector<double> dist(N, 1e15);\n        dist[M] = 0;\n        priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> q;\n        q.push({0, M});\n        while(q.size()){\n\n            auto p = q.top(); q.pop();\n            double c = p.first;\n            int v = p.second;\n\n            if(dist[v] < c) continue;\n\n            \n            for(int i=0; i<N; i++){\n                if(i == v) continue;\n\n                double mi = 1e15;\n                for(int j=0; j<5; j++){\n\n                    for(int k=0; k<5; k++){\n                        mi = min(mi, distance(vp[v][k], vp[i][j]));\n                    }\n                }\n                if(dist[i] > dist[v] + mi){\n                    dist[i] = dist[v] + mi;\n                    q.push({dist[i], i});\n                }\n            }\n            \n        }\n        cout << dist[L] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define pb push_back\n#define eb emplace_back\n\nint in(){int x;cin>>x;return x;}\n\nusing Real = double;\nusing Point = complex<Real>;\nconst Real EPS = 1e-8,PI = acos(-1);\ninline bool eq(Real a,Real b){ return fabs(b-a) < EPS;}\nPoint rotate(Real _theta,const Point &p){\n    Real theta = (_theta*PI/180);\n    return Point(cos(theta)*p.real()-sin(theta)*p.imag(),sin(theta)*p.real()+cos(theta)*p.imag());\n}\nstruct Segment {\n    Point a,b;\n    Segment()=default;\n    Segment(Point a,Point b):a(a),b(b){}\n};\nReal dot(const Point &a,const Point &b){\n    return real(a)*real(b)+imag(a)*imag(b);\n}\n\nPoint projection(const Segment &l,const Point &p){\n    double t = dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n    return l.a+(l.a-l.b)*t;\n}\nReal cross(const Point &a, const Point &b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  \n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return +2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersect(const Segment &s,const Point &p){\n    return ccw(s.a,s.b,p) == 0;\n}\nbool intersect(const Segment &s, const Segment &t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nReal distance(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(intersect(s,r)) return abs(r-p);\n    return min(abs(s.a-p),abs(s.b-p));\n}\nReal distance(const Segment &a, const Segment &b) {\n    if(intersect(a, b)) return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\nstruct Star{\n    Point center;\n    Real r;\n    Real theta;\n    Point p[5];\n    Segment s[5];\n    Star(int x,int y,int a,int r):r(r),theta(a){\n        center=Point(x,y);\n        rep(i,5){\n            Point P(0,r);\n            P = rotate(a+72*i,P);\n            p[i] = Point(center+P);\n        }\n        rep(i,5){\n            s[i] = Segment(p[i],p[(i+2)%5]);\n        }\n    }\n};\nReal distance(Star &x,Star &y){\n    Real d = 1e10;\n    rep(i,5){\n        rep(j,5){\n            d = min(d,distance(x.s[i],y.s[j]));\n        }\n    }\n    return d;\n}\n    \n\nmain(){\n    while(1){\n        int n=in(),m=in(),l=in();\n        if(!n)exit(0);\n        vector<Star> v;\n        rep(i,n){\n            int x=in(),y=in(),a=in(),r=in();\n            v.emplace_back(x,y,a,r);\n        }\n        Real mat[n][n];\n        rep(i,n){\n            rep(j,n){\n                if(i==j)mat[i][j]=0;\n                else mat[i][j] = distance(v[i],v[j]);\n            }\n        }\n        rep(k,n){\n            rep(i,n){\n                rep(j,n){\n                    mat[i][j] = min(mat[i][j],mat[i][k]+mat[k][j]);\n                }\n            }\n        }\n        cout << setprecision(15) << fixed << mat[m-1][l-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.14159265358979\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点と点の距離\ndouble dis(P a, P b){\n    return sqrt((a.real() - b.real()) * (a.real() - b.real()) + (a.imag() - b.imag()) * (a.imag() - b.imag()));\n}\n\nvector<P> f(double x, double y, double a, double r){\n    \n    vector<P> ret(5);\n    P vec = P(0.0, r);\n    P add = P(x, y);\n    // a度 左に回転\n    P t = P(cos(a * PI / 180.0), sin(a * PI / 180.0));\n    vec = vec * t;\n    ret[0] = vec + add;\n    t = P(cos(72.0 * PI / 180.0), sin(72.0 * PI / 180.0));\n    for(int i = 1; i < 5; i++){\n        vec = vec * t;\n        ret[i] = vec + add;\n    }\n\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<P> > v(n, vector<P> (5));\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            v[i] = f(x, y, a, r);\n        }\n    \n\n        vector<vector<double> > g(n, vector<double> (n, INF));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < 5; k++) for(int l = 0; l < 5; l++){\n                    g[i][j] = min(g[i][j], dis(v[i][k], v[j][l]));\n                }\n            }\n        }\n\n       for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n\n        printf(\"%.14f\\n\", g[m - 1][n - 1]);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<D,D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ninline P add(P a, P b){ return P(a.fs+b.fs, a.sc+b.sc);}\ninline P sub(P a, P b){ return P(a.fs-b.fs, a.sc-b.sc);}\ninline D abs(P x){return sqrt(x.fs*x.fs + x.sc*x.sc);}\n\n//for vector\ninline D dot(P a, P b){return a.fs*b.fs+a.sc*b.sc;}\ninline D cross(P a, P b){return a.fs*b.sc-a.sc*b.fs;}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(v.fs*cos(s) - v.sc*sin(s), v.fs*sin(s) + v.sc*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b = sub(b,a); c = sub(c,a);\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(sub(a.sc,a.fs),sub(x,a.fs))<EPS)return abs(sub(x,a.fs));\n  if(dot(sub(a.fs,a.sc),sub(x,a.sc))<EPS)return abs(sub(x,a.sc));\n  return abs(cross(sub(a.sc,a.fs),sub(x,a.fs)))/abs(sub(a.sc,a.fs));\n}\n\nD g[111][111],d[111];\nL starl[111][5];\nP starv[111][5],c,p;\nint n,m,l,x,y,a,r;\nbool use[111];\n\nint main(){\n  while(scanf(\"%d%d%d\",&n,&m,&l), n){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      c = P(x,y), p = P(0,r);\n      for(int j=0;j<5;j++)starv[i][j] = add(c,rotate(p,PI*(a+j*72)/180));\n      for(int j=0;j<5;j++)starl[i][j] = L(starv[i][j],starv[i][(j+2)%5]);\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : starl[i]){\n\t  for(L b : starl[j]){\n\t    if(is_cp(a,b)){dis = 0; break;}\n\t  }\n\t}\n\tif(dis>EPS){\n\t  for(P a : starv[i]){\n\t    for(L b : starl[j])dis = min(dis, seg_p_dis(b,a));\n\t  }\n\t  for(P a : starv[j]){\n\t    for(L b : starl[i])dis = min(dis, seg_p_dis(b,a));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n      g[i][i] = 0;\n    }\n    \n    for(int i=0;i<n;i++)d[i] = 1e9;\n    d[m-1] = 0;\n    memset(use,0,sizeof(use));\n    \n    for(;;){\n      int v = -1;\n      for(int u=0;u<n;u++){\n\tif(!use[u] && (v<0 || d[v] > d[u]))v = u;\n      }\n      \n      if(v<0 || v==l-1)break;\n      use[v] = 1;\n      \n      for(int u=0;u<n;u++){\n\td[u] = min(d[u],d[v]+g[u][v]);\n      }\n    }\n    \n    printf(\"%.9lf\\n\",d[l-1]);\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,x,y) i=(x);i<(y);i++\n#define rep(i,n) for(int i=0,i##_len=n;i<i##_len;i++)\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Line> make_star(ld x, ld y, ld a, ld r){\n  int d = 5;\n  ld rad = 4 * pi / 5;\n  Point p(x, y);\n  Point v(0, r);\n  ld aa = a / 180.0 * pi;\n  v *= Point(cos(aa), sin(aa));\n  Point rot(cos(rad), sin(rad));\n  vector<Line> res;\n  rep(i, d){\n    res.emplace_back(v + p,v * rot + p);\n    v *= rot;\n  }\n  return res;\n}\n\ntemplate <typename Cost>\nstruct CEdge {\n  int from, to;\n  Cost cost;\n  CEdge(int s, int t, Cost c) : from(s), to(t), cost(c) {}\n};\n\ntemplate<typename Cost> using CGraph = vector<vector<CEdge<Cost>>>;\n\ntemplate <typename Cost>\nvoid add_edge(CGraph<Cost> &g, int from, int to, Cost cost) {\n  g[from].emplace_back(from, to, cost);\n}\n\nconst int inf = 1e9;\n\ntemplate <typename Cost>\nvector<Cost> dijkstra(const CGraph<Cost> &g, int s, Cost zero = 0) {\n  vector<Cost> d(g.size(), inf);\n  d[s] = zero;\n  using P = pair<Cost,int>;\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(zero, s));\n  while (!que.empty()) {\n    Cost dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    for (const auto &e: g[v]) {\n      if (d[e.to] <= d[v] + e.cost) continue;\n      d[e.to] = d[v] + e.cost;\n      que.push(P(d[e.to], e.to));\n    }\n  }\n  return d;\n}\n\nld dist_stars (vector<Line> s, vector<Line> t){\n  ld res = 1e30l;\n  for(auto&& ss: s){\n    for(auto&& tt: t){\n      res = min(res, dist_ss(ss, tt));\n    }\n  }\n  return res;\n}\n\nvoid svg(){\ncerr << \"<?xml version='1.0' standalone='no'?>\" << endl;\ncerr << \"<svg  width='1000px' height='1000px' viewBox='0 -400 400 400' xmlns='http://www.w3.org/2000/svg'>\" << endl;\ncerr << \"<style>line { stroke: black; }</style>\" << endl;\ncerr << \"<line x1='100' y1='0' x2='0' y2='-100'/>\" << endl;\n\n}\nvoid gvs(){\ncerr << \"</svg>\" << endl;\n}\n\nvoid draw_line(Line l){\n  const ld z = 10;\n  cerr << \"<line x1='\" << real(l.a) * z << \"' y1='\" << -imag(l.a) * z\n    << \"' x2='\" << real(l.b) * z << \"' y2='\" << -imag(l.b) * z<< \"' />\" << endl;\n}\n\n\nsigned main(){\n  int n, m, l;\n  while(cin >> n >> m >> l, n != 0){\n    vector<vector<Line>> stars(n);\n    rep(i, n){\n      int x, y, a, r; cin >> x >> y >> a >> r;\n      stars[i] = make_star(x, y, a, r);\n    }\n    CGraph<ld> g(n);\n    vector<vector<ld>> dp(n, vector<ld>(n, inf));\n\n    rep(i, n){\n      rep(j, n){\n        dp[i][j] = dist_stars(stars[i], stars[j]);\n      }\n    }\n    rep(k, n)rep(i,n)rep(j,n){\n      dp[i][j]=min(dp[i][k]+dp[k][j], dp[i][j]);\n    }\n    cout << std::setprecision(24) << dp[m-1][l-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nbool intersectSP(const line_t &s, const xy_t &p) {\n  return abs(s.first - p) + abs(s.second - p) - abs(direction(s)) < EPS;\n}\n\nbool intersectSS(const line_t &s, const line_t &t) {\n  return ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n         ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\nxy_t projection(const line_t &l, const xy_t &p) {\n  double t = dot(p - l.first, direction(l)) / norm(direction(l));\n  return l.first + t*(direction(l));\n}\n\ndouble distanceSP(const line_t &s, const xy_t &p) {\n  const xy_t r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.first - p), abs(s.second - p));\n}\n\ndouble distanceSS(const line_t &s, const line_t &t) {\n  if (intersectSS(s, t)) return 0;\n  \n  return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nstruct star {\n  int x, y, a, r;\n  \n  vector<xy_t> points() const {\n    vector<xy_t> ps;\n    xy_t   center = xy_t(x, y);\n    double theta  = (double)a / 180 * M_PI + M_PI / 2;\n    REP(i, 5) {\n      ps.push_back(center + polar((double)r, theta + M_PI * i * 2 / 5));\n    }\n    return ps;\n  }\n  \n  vector<line_t> segments() const {\n    vector<xy_t>   ps = this->points();\n    vector<line_t> res;\n\n    REP(i, ps.size()) REP(j, i){\n      res.push_back(line_t(ps[j], ps[i]));\n    }\n    return res;\n  }\n};\n\ndouble distance(const star &s, const star &t){\n  vector<line_t> seg_ss = s.segments();\n  vector<line_t> seg_ts = t.segments();\n  double res = 1e9;\n\n  for (line_t seg_s : seg_ss){\n    for (line_t seg_t : seg_ts){\n      res = min(res, distanceSS(seg_s, seg_t));\n    }\n  }\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, L;\n  while (cin >> N >> M >> L && N + M + L){\n    vector<star> stars(N);\n    vector<vector<double> > dist(N, vector<double>(N));\n    REP(i, N){\n      cin >> stars[i].x >> stars[i].y >> stars[i].a >> stars[i].r;\n    }\n\n    REP(i, N) REP(j, N){\n      dist[i][j] = distance(stars[i], stars[j]);\n    }\n\n    REP(k, N) REP(i, N) REP(j, N){\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n    printf(\"%.20lf\\n\", dist[L - 1][M - 1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nbool isIntersect(vector<P> a,vector<P> b){\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      if(isIntersect(L(a[i],a[(i+2)%5]),L(b[j],b[(j+2)%5])))return 1;\n    return 0;\n}\n\nvector<P> get_p(P a,double d,double r){\n  vector<P> res(5);\n  d=(d/360)*2*M_PI;\n  P p=P(0,r)*P(cos(d),sin(d));\n  res[0]=p+a;\n  d=2*M_PI/5;\n  for(int i=1;i<=4;i++){\n    p=p*P(cos(d),sin(d));\n    res[i]=p+a;\n  }\n  return res;\n}\n\ndouble G[N][N],x[N],y[N],d[N],r[N];\n\ndouble get_dis(int a,int b){\n  vector<P> A=get_p(P(x[a],y[a]),d[a],r[a]);\n  vector<P> B=get_p(P(x[b],y[b]),d[b],r[b]);\n  double res=1e9;\n  if(isIntersect(A,B))return 0;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)res=min(res,abs(A[i]-B[j]));\n  return res;\n}\n\nint main(){\n  while(1){\n  int n,s,g;\n  cin>>n>>s>>g;\n  if(!n&&!s&&!g)break;\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++)G[i][j]=1e9*(i!=j);\n  \n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>d[i]>>r[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(i!=j) G[i][j]=get_dis(i,j);\n  \n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  printf(\"%.10f\\n\",G[s-1][g-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tdouble x,y;\n};\n\nstruct Line{\n\tvoid set(double arg_x1,double arg_y1,double arg_x2,double arg_y2){\n\t\tx1 = arg_x1;\n\t\ty1 = arg_y1;\n\t\tx2 = arg_x2;\n\t\ty2 = arg_y2;\n\t}\n\n\tdouble x1,y1,x2,y2;\n};\n\nInfo roll(double x, double y, double rad)\n{\n\tInfo ret;\n\n\tret.x = x*cos(rad)-y*sin(rad);\n\tret.y = x*sin(rad)+y*cos(rad);\n\n\treturn ret;\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\ndouble calc(Info left,Info right){\n\treturn sqrt((left.x-right.x)*(left.x-right.x)+(left.y-right.y)*(left.y-right.y));\n}\n\n\n\nInfo info[101][5];\n\nint N,start,goal;\ndouble dist[101][101];\n\nvoid func(){\n\n\tdouble x,y,degree,r;\n\n\tInfo tmp;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lf %lf %lf %lf\",&x,&y,&degree,&r);\n\n\t\ttmp = roll(0.0,r,degree*M_PI/180.0);\n\n\t\tinfo[i][0].x = x+tmp.x;\n\t\tinfo[i][0].y = y+tmp.y;\n\n\t\tfor(int k = 1; k <= 4; k++){\n\t\t\ttmp = roll(info[i][k-1].x-x,info[i][k-1].y-y,(2.0*M_PI/5.0));\n\t\t\tinfo[i][k].x = x+tmp.x;\n\t\t\tinfo[i][k].y = y+tmp.y;\n\t\t}\n\t}\n\n\tdouble tmp_min,tmp_dist;\n\n\t Line left[5],right[5];\n\t bool isCross;\n\n\tfor(int i = 1; i <= N; i++){ //???i????????????\n\t\tleft[0].set(info[i][0].x,info[i][0].y,info[i][3].x,info[i][3].y);\n\t\tleft[1].set(info[i][3].x,info[i][3].y,info[i][1].x,info[i][1].x);\n\t\tleft[2].set(info[i][2].x,info[i][2].y,info[i][0].x,info[i][0].y);\n\t\tleft[3].set(info[i][1].x,info[i][1].y,info[i][4].x,info[i][4].y);\n\t\tleft[4].set(info[i][4].x,info[i][4].y,info[i][2].x,info[i][2].y);\n\n\t\tfor(int k = i; k <= N; k++){\n\t\t\tif(i != k){\n\t\t\t\ttmp_min = DBL_MAX;\n\n\t\t\t\tright[0].set(info[k][0].x,info[k][0].y,info[k][3].x,info[k][3].y);\n\t\t\t\tright[1].set(info[k][3].x,info[k][3].y,info[k][1].x,info[k][1].x);\n\t\t\t\tright[2].set(info[k][2].x,info[k][2].y,info[k][0].x,info[k][0].y);\n\t\t\t\tright[3].set(info[k][1].x,info[k][1].y,info[k][4].x,info[k][4].y);\n\t\t\t\tright[4].set(info[k][4].x,info[k][4].y,info[k][2].x,info[k][2].y);\n\n\t\t\t\tisCross = false;\n\t\t\t\tfor(int a = 0; a < 5; a++){\n\t\t\t\t\tfor(int b = 0; b < 5; b++){\n\t\t\t\t\t\tif(func(left[a].x1,left[a].y1,left[a].x2,left[a].y2,right[b].x1,right[b].y1)*\n\t\t\t\t\t\t\t\tfunc(left[a].x1,left[a].y1,left[a].x2,left[a].y2,right[b].x2,right[b].y2) <= 0 &&\n\t\t\t\t\t\t\t\t\t\tfunc(right[b].x1,right[b].y1,right[b].x2,right[b].y2,left[a].x1,left[a].y1)*\n\t\t\t\t\t\t\t\t\t\t\tfunc(right[b].x1,right[b].y1,right[b].x2,right[b].y2,left[a].x2,left[a].y2) <= 0){\n\t\t\t\t\t\t\tisCross = true;\n\t\t\t\t\t\t\ttmp_min = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif(isCross)break;\n\t\t\t\t}\n\n\t\t\t\tif(!isCross){\n\t\t\t\t\tfor(int a = 0; a < 5; a++){\n\t\t\t\t\t\tfor(int b = 0; b < 5; b++){\n\t\t\t\t\t\t\ttmp_dist = calc(info[i][a],info[k][b]);\n\t\t\t\t\t\t\ttmp_min = min(tmp_min,tmp_dist);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdist[i][k] = tmp_min;\n\t\t\t\tdist[k][i] = tmp_min;\n\t\t\t}else{\n\t\t\t\tdist[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int mid = 1; mid <= N; mid++){\n\t\tfor(int st = 1; st <= N; st++){\n\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\tdist[st][gl] = min(dist[st][gl],dist[st][mid]+dist[mid][gl]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.20lf\\n\",dist[start][goal]);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&start,&goal);\n\t\tif(N == 0 && start == 0 && goal == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<double,int>pdi;\n\nconst int MAX_N = 102;\n\nstruct edge{\n    int to;\n    double cost;\n};\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble d[MAX_N];\nvector<edge> G[MAX_N];\nint n;\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<pdi,vector<pdi>,greater<pdi> > que;\n\td[s] = 0;\n\tque.push(pdi(0.0,s));\n\twhile(!que.empty()){\n\t\tpdi p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tque.push(pdi(d[G[v][i].to],G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + (projection(l, p) - p)*2.0;\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint main()\n{\n    while(1){\n        int s,t;\n    \tscanf(\"%d%d%d\",&n,&s,&t);\n        if(n == 0 && s == 0 && t == 0){\n            break;\n        }\n        vector<L> star[MAX_N];\n        rep(i,n){\n            G[i].clear();\n        }\n    \trep(i,n){\n            vector<P> star_pos;\n            int x,y,a,r;\n            scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n            rep(j,5){\n                star_pos.push_back(P(-sin((a+72.0*j)*M_PI/180.0)*r + x,cos((a+72.0*j)*M_PI/180.0)*r + y));\n            }\n            rep(j,5){\n                star[i].push_back(L(star_pos[j],star_pos[(j+2)%5]));\n            }\n    \t}\n        rep(i,n){\n            rep(j,n){\n                if(i != j){\n                    double mn = INF;\n                    rep(k,star[i].size()){\n                        rep(l,star[j].size()){\n                            mn = min(mn,distanceSS(star[i][k],star[j][l]));\n                        }\n                    }\n                    G[i].push_back((edge){j,mn});\n                }\n            }\n        }\n        fill(d,d+n,INF);\n        dijkstra(s-1);\n        printf(\"%.12lf\\n\",d[t-1]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2402.cc: Milky Way\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int PN = 5;\nconst double PI = acos(-1.0);\nconst double DINF = 1.0e10;\n  \n/* typedef */\n\ntypedef pair<double,int> pdi;\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  bool operator==(const Pt pt) const { return x == pt.x && y == pt.y; }\n  Pt<T> operator+(const Pt pt) const { return Pt<T>(x + pt.x, y + pt.y); }\n  Pt<T> operator-() const { return Pt<T>(-x, -y); }\n  Pt<T> operator-(const Pt pt) const { return Pt<T>(x - pt.x, y - pt.y); }\n  Pt<T> operator*(T t) const { return Pt<T>(x * t, y * t); }\n  Pt<T> operator/(T t) const { return Pt<T>(x / t, y / t); }\n  T dot(Pt v) const { return x * v.x + y * v.y; }\n  T cross(Pt v) const { return x * v.y - y * v.x; }\n  Pt<T> mid(const Pt pt) { return Pt<T>((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt<T> rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt<T>(c * x - s * y, s * x + c * y);\n  }\n\n  Pt<T> rot90() { return Pt<T>(-y, x); }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n\n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n  void print() { print(\"%.6lf\"); }\n};\n\ntypedef Pt<double> pt;\ntypedef vector<pt> vpt;\n\nstruct CL {\n  pt p;\n  double t0, t1;\n  CL() {}\n  CL(const pt& _p, double _t0, double _t1) : p(_p), t0(_t0), t1(_t1) {}\n};\n\n/* global variables */\n\npt pts[MAX_N][PN];\ndouble ds[MAX_N][MAX_N], dists[MAX_N];\n\n/* subroutines */\n\nbool cross_lines(const pt& ap, const pt av, const pt& bp, const pt bv, CL& cl) {\n  double op01 = av.cross(bv);\n  //if (op01 == 0.0) return false; /* need to handle parallel?? */\n\n  if (op01 == 0.0) {\n    pt v = bp - ap;\n    if (v.cross(av) != 0.0) return false;\n\n    pt a1 = ap + av;\n    pt b1 = bp + bv;\n\n    return\n      ((bp - ap).dot(b1 - ap) <= 0.0 ||\n       (bp - a1).dot(b1 - a1) <= 0.0 ||\n       (ap - bp).dot(a1 - bp) <= 0.0 ||\n       (ap - b1).dot(a1 - b1) <= 0.0);\n  }\n\n  pt v = bp - ap;\n  double op0 = v.cross(av);\n  double op1 = v.cross(bv);\n\n  double t0 = op1 / op01;\n  double t1 = op0 / op01;\n\n  cl.p = bv * t1 + bp;\n  cl.t0 = t0;\n  cl.t1 = t1;\n\n  return true;\n  //return (0.0 <= cl.t0 && cl.t0 <= 1.0 && 0.0 <= cl.t1 && cl.t1 <= 1.0);\n}\n\nbool cross_segs(const pt& ap, const pt av, const pt& bp, const pt bv, CL& cl) {\n  if (! cross_lines(ap, av, bp, bv, cl)) return false;\n  return (0.0 <= cl.t0 && cl.t0 <= 1.0 && 0.0 <= cl.t1 && cl.t1 <= 1.0);\n}\n\ndouble dist_pt_seg(pt &p, pt &bp, pt &bv) {\n  pt v0 = p - bp;\n  if (v0.dot(bv) < 0.0) return v0.d();\n  pt v1 = p - (bp + bv);\n  if (v1.dot(-bv) < 0.0) return v1.d();\n\n  CL cl;\n  pt pv = bv.rot90();\n  cross_lines(p, pv, bp, bv, cl);\n  return (cl.p - p).d();\n}\n\ndouble dist_segs(pt &ap, pt &av, pt &bp, pt &bv) {\n  double mind = dist_pt_seg(ap, bp, bv);\n  pt ap0 = ap + av;\n  double d = dist_pt_seg(ap0, bp, bv);\n  if (mind > d) mind = d;\n  d = dist_pt_seg(bp, ap, av);\n  if (mind > d) mind = d;\n  pt bp0 = bp + bv;\n  d = dist_pt_seg(bp0, ap, av);\n  if (mind > d) mind = d;\n  return mind;\n}\n\ndouble dist_stars(int s0, int s1) {\n  double mind = DINF;\n  for (int i = 0; i < PN; i++) {\n    pt &ap = pts[s0][i];\n    pt av = pts[s0][(i + 2) % PN] - ap;\n    for (int j = 0; j < PN; j++) {\n      pt &bp = pts[s1][j];\n      pt bv = pts[s1][(j + 2) % PN] - bp;\n      double d = dist_segs(ap, av, bp, bv);\n      if (mind > d) mind = d;\n    }\n  }\n  return mind;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (n == 0) break;\n    m--, l--;\n    \n    double dth = PI * 2 / PN;\n    \n    for (int i = 0; i < n; i++) {\n      double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      double th0 = PI * (90 + a) / 180;\n\n      for (int j = 0; j < PN; j++) {\n\tdouble th = th0 + dth * j;\n\tpts[i][j].x = x + r * cos(th);\n\tpts[i][j].y = y + r * sin(th);\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      ds[i][i] = 0.0;\n      for (int j = i + 1; j < n; j++)\n\tds[i][j] = ds[j][i] = dist_stars(i, j);\n      dists[i] = DINF;\n    }\n\n    dists[m] = 0.0;\n    priority_queue<pdi> q;\n    q.push(pdi(0.0, m));\n\n    while (! q.empty()) {\n      pdi u = q.top(); q.pop();\n      double ud = -u.first;\n      int &ui = u.second;\n      if (dists[ui] != ud) continue;\n      if (ui == l) break;\n\n      for (int vi = 0; vi < n; vi++) {\n\tif (vi == ui) continue;\n\tdouble vd = ud + ds[ui][vi];\n\tif (dists[vi] > vd) {\n\t  dists[vi] = vd;\n\t  q.push(pdi(-vd, vi));\n\t}\n      }\n    }\n\n    printf(\"%.10lf\\n\", dists[l]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define eps (1e-10)\n#define INF (1e20)\n\nstatic const double PI = acos(-1);\nbool eq(double a,double b){\n  return ( -eps < a-b && a-b < eps);\n}\n\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n};\ntypedef Point Vector;\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n  Vector base(){\n    return p2-p1;\n  }\n};\ntypedef Segment Line;\n\nbool eq(Point a,Point b){ return (eq(a.x,b.x)&&eq(a.y,b.y)); }\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nVector rotate(Vector v,double ti){\n  return Point(v.x*cos(ti)-v.y*sin(ti),v.x*sin(ti)+v.y*cos(ti));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n  \nint ccw( Point p0, Point p1, Point p2 ){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if ( cross(a, b) > eps ) return COUNTER_CLOCKWISE;\n  if ( cross(a, b) < -eps ) return CLOCKWISE;\n  if ( dot(a, b) < -eps ) return ONLINE_BACK;\n  if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n \ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n\nint N,M,L;\ndouble G[100][100];\nvector<Segment> A[100];\n\ndouble solve(int a,int b){\n  double res=INF;\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      res=min(res,getDistance(A[a][i],A[b][j]));      \n  return res;\n}\n\nint main(){\n  double B=2.0*acos(-1.0)/5.0;\n  while(1){\n    \n    cin>>N>>M>>L;\n    if(N==0&&M==0&&L==0)break;\n    \n    for(int i=0;i<N;i++){\n      Point p;\n      Vector v;\n      double a;\n      cin>>p.x>>p.y>>a>>v.y;\n      a=a/360.0*2.0*acos(-1.0);\n      v.x=0;\n      v=rotate(v,a);\n      A[i].clear();\n      for(int j=0;j<5;j++){\n        A[i].push_back(Segment(p+v,p+rotate(v,B+B)));\n        v=rotate(v,B);\n      }\n    }\n  \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        G[i][j]=solve(i,j);\n  \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    printf(\"%.10f\\n\",G[M-1][L-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\n//for vector\n\ninline D dot(P x, P y){return real(conj(x)*y);}\n\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline D seg_seg_dis(L a,L b){\n  D res = 1e10;\n  res = min(res,seg_p_dis(a,b.fs));\n  res = min(res,seg_p_dis(a,b.sc));\n  res = min(res,seg_p_dis(b,a.fs));\n  res = min(res,seg_p_dis(b,a.sc));\n  return res;\n}\n\nint main(){\n  int n,m,l;\n  while(scanf(\"%d%d%d\",&n,&m,&l), n){\n    vector< vector<L> > stars(n);\n    for(int i=0;i<n;i++){\n      int x,y,a,r;\n      scanf(\"%d%d%d%d\",&x,&y,&a,&r);\n      P c = P(x,y);\n\n      vector<P> v(5);\n      P p = P(0,r);\n      for(int j=0;j<5;j++){\n\tv[j] = c+rotate(p,PI*(a+j*72)/180);\n      }\n      \n      vector<L> l(5);\n      for(int j=0;j<5;j++){\n\tl[j] = L(v[j],v[(j+2)%5]);\n      }\n      stars[i] = l;\n    }\n\n    vector< vector<D> > g(n, vector<D>(n,0));\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tD dis = 1e9;\n\tfor(L a : stars[i]){\n\t  for(L b : stars[j]){\n\t    if(is_cp(a,b)){\n\t      dis = 0;\n\t      break;\n\t    }else dis = min(dis, seg_seg_dis(a,b));\n\t  }\n\t}\n\tg[i][j] = g[j][i] = dis;\n      }\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    printf(\"%.9lf\\n\",g[m-1][l-1]);\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nconst double PI = 3.14159265358979323846264;\n\ndouble deg2rad(double deg) {\n  return deg*PI/180;\n}\n\nP rotate(P p, P c, double d) {\n  return c+(p-c)*P(cos(d),sin(d));\n}\n\n\n#include <cstdio>\n\nconst int INF = 1000000000;\nL star[200][5];\ndouble d[200][200];\n\ndouble diststar(int i,int j){\n  double ans = 1000000;\n  for (int ii=0; ii<5; ii++)\n    for (int ji=0; ji<5; ji++)\n      ans = min(ans,distanceSS(star[i][ii],star[j][ji]));\n  return ans;\n}\n\nint main() {\n  int n,m,l;\n  while(scanf(\"%d %d %d\",&n,&m,&l),n) {\n    for(int i=0; i<n; i++) {\n      double x,y,a,r;\n      scanf(\"%lf %lf %lf %lf\",&x,&y,&a,&r);\n      P c(x,y),up(x,y+r);\n      for (int j=0; j<5; j++) {\n\tP f = c + r*rotate(P(0,1),P(0,0),deg2rad(j*72+a));\n\tP t = c + r*rotate(P(0,1),P(0,0),deg2rad(((j+1)%5)*72+a));\n\tstar[i][j] = L(f,t);\n      }\n    }\n\n    for (int i=0; i<n; i++)\n      for (int j=0; j<n; j++)\n\td[i][j] = (i==j?0:diststar(i,j));\n\n    for (int k=0; k<n; k++)\n      for (int i=0; i<n; i++)\n\tfor (int j=0; j<n; j++)\n\t  d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n    printf(\"%.15f\\n\",d[m-1][l-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e10\n#define EPS (1e-10)    //誤差\ntypedef complex<double> P;\n\nstruct star{\n    P point[5];    \n};\n\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n\n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n\n\nstar ch(double x, double y, double a, double r){\n    \n    star res;\n    res.point[0] = P(0, r);    \n    \n    //a度左に回転\n    res.point[0] *= exp(P(0.0, a*M_PI/180.0));\n\n    //P(cos(), sin())\n\n    //72度回転　→　回収を五回繰り返す\n    for(int i = 1; i < 5; i++){\n        res.point[i] = res.point[i - 1] * exp(P(0.0, 2.0*M_PI/5.0));        \n    }\n\n    for(int i = 0; i < 5; i++){\n        res.point[i] += P(x, y);        \n    }\n\n    return res;\n}\n\n//星間の距離を返す\ndouble make_dis(star st1, star st2){\n    \n    double res = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            P p11, p12, p21, p22;\n            p11.real() = st1.point[i].real();\n            p11.imag() = st1.point[i].imag();\n            p12.real() = st1.point[(i + 2) % 5].real();\n            p12.imag() = st1.point[(i + 2) % 5].imag();\n\n            p21.real() = st2.point[i].real();\n            p21.imag() = st2.point[i].imag();\n            p22.real() = st2.point[(i + 2) % 5].real();\n            p22.imag() = st2.point[(i + 2) % 5].imag();\n\n\n            double ans = 1e10;\n            ans = min(ans, distance_ls_p(p11, p12, p21));\n            ans = min(ans, distance_ls_p(p11, p12, p22));\n            ans = min(ans, distance_ls_p(p21, p22, p11));\n            ans = min(ans, distance_ls_p(p21, p22, p12));\n            if(is_intersected_ls(p11, p12, p21, p22)) ans = 0.0;\n            res = min(res, ans);\n        }\n    }\n\n    return res;\n}\n\n//幾何入門\nint main(){\n    \n    while(1){\n\n        int n, m, l; cin >> n >> m >> l;\n        if(!n) break;\n\n        //星の構造体\n        vector<star> st(n);\n\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            //入力から星の構造体を返す\n            st[i] = ch(x, y, a, r);\n        }\n\n        vector<vector<double> > dis(n, vector<double> (n, INF));\n\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                if(i == n) dis[i][j] = dis[j][i] = 0.0;\n                else dis[i][j] = dis[j][i] = make_dis(st[i], st[j]);\n            }\n        }\n\n        //ワーシャルフロイド\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n                }\n            }\n        }\n\n        for(int i = 0; i < n; i++){\n            cerr << \"star \" << i << endl;\n            for(int j = 0; j < 5; j++){\n                cerr << st[i].point[j].real() << \" \" << st[i].point[j].imag() << endl;\n            }\n        }\n\n        printf(\"%.10f\\n\", dis[m-1][l-1]);\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\nint ccw(const Point& _a, const Point& _b, const Point&  _c) {\n\tVector ba = _b - _a, ca = _c - _a;\n\tif (cross(ba, ca) > EPS) return +1; // ccw\n\tif (cross(ba, ca) < -EPS) return -1; // cw\n\tif (dot(ba, ca) < -EPS) return +2; // c-a-b\n\tif (abs(ba) + EPS < abs(ca)) return -2; // a-b-c\n\treturn 0; // a-c-b\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nbool is_cross(const Segment& _a, const Segment& _b) {\n\treturn (ccw(_a.s, _a.e, _b.s) * ccw(_a.s, _a.e, _b.e) <= 0\n\t\t\t&& ccw(_b.s, _b.e, _a.s) * ccw(_b.s, _b.e, _a.e) <= 0);\n}\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tif (is_cross(a, b)) return 0.0;\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 0.4 * PI));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[4] + c, vp[1] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[3] + c, vp[0] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e5;\n\tfor_(i,0,5) for_(j,0,5) if (is_cross(a.vs[i], b.vs[j])) return 0.0;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_point_seg(a.vs[i].s, b.vs[j]));\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_point_seg(b.vs[i].s, a.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.20lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x, &y, &a, &r);\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.1415926535897932384626433832795028841971\ntypedef complex<double> P;\n \nstruct star{\n    P point[5];    \n};\n \n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvector<P> f(double x, double y, double a, double r){\n    \n    vector<P> ret(5);\n    P vec = P(0.0, r);\n    P add = P(x, y);\n    // a度 左に回転\n    P t = P(cos(a * PI / 180.0), sin(a * PI / 180.0));\n    vec = vec * t;\n    ret[0] = vec + add;\n    t = P(cos(72.0 * PI / 180.0), sin(72.0 * PI / 180.0));\n    for(int i = 1; i < 5; i++){\n        vec = vec * t;\n        ret[i] = vec + add;\n    }\n\n    return ret;\n}\n\ndouble dis(vector<P> a, vector<P> b){\n    double ret = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            if(is_intersected_ls(a[i], a[(i + 2) % 5], b[j], b[(j + 2) % 5])) ret = 0.0;\n            ret = min(ret, distance_ls_p(a[i], a[(i + 2) % 5], b[j]));\n            ret = min(ret, distance_ls_p(b[j], b[(j + 2) % 5], a[i]));\n        }\n    }\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<P> > v(n, vector<P> (5));\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            v[i] = f(x, y, a, r);\n        }\n    \n\n        vector<vector<double> > g(n, vector<double> (n, INF));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                g[i][j] = min(g[i][j], dis(v[i], v[j]));\n            }\n        }\n\n       for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n\n        printf(\"%.14f\\n\", g[m - 1][n - 1]);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define pb push_back\n#define eb emplace_back\n\nint in(){int x;cin>>x;return x;}\n\nusing Real = double;\nusing Point = complex<Real>;\nconst Real EPS = 1e-8,PI = acos(-1);\ninline bool eq(Real a,Real b){ return fabs(b-a) < EPS;}\nPoint rotate(Real _theta,const Point &p){\n    Real theta = (_theta*PI/180);\n    return Point(cos(theta)*p.real()-sin(theta)*p.imag(),sin(theta)*p.real()+cos(theta)*p.imag());\n}\nstruct Segment {\n    Point a,b;\n    Segment()=default;\n    Segment(Point a,Point b):a(a),b(b){}\n};\nReal dot(const Point &a,const Point &b){\n    return real(a)*real(b)+imag(a)*imag(b);\n}\n\nPoint projection(const Segment &l,const Point &p){\n    double t = dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n    return l.a+(l.a-l.b)*t;\n}\nReal cross(const Point &a, const Point &b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  \n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return +2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersect(const Segment &s,const Point &p){\n    return ccw(s.a,s.b,p) == 0;\n}\nbool intersect(const Segment &s, const Segment &t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nReal distance(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(intersect(s,r)) return abs(r-p);\n    return min(abs(s.a-p),abs(s.b-p));\n}\nReal distance(const Segment &a, const Segment &b) {\n    if(intersect(a, b)) return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\nstruct Star{\n    Point center;\n    Real r;\n    Real theta;\n    Point p[5];\n    Segment s[5];\n    Star(int x,int y,int a,int r):r(r),theta(a){\n        center=Point(x,y);\n        rep(i,5){\n            Point P(0,r);\n            P = rotate(a+72*i,P);\n            p[i] = Point(center+P);\n        }\n        rep(i,5){\n            s[i] = Segment(p[i],p[(i+2)%5]);\n        }\n    }\n};\nReal distance(Star &x,Star &y){\n    Real d = 1e10;\n    rep(i,5){\n        rep(j,5){\n            d = min(d,distance(x.s[i],y.s[j]));\n        }\n    }\n    return d;\n}\n    \n\nmain(){\n    while(1){\n        int n=in(),m=in(),l=in();\n        if(!n)exit(0);\n        vector<Star> v;\n        rep(i,n){\n            int x=in(),y=in(),a=in(),r=in();\n            v.emplace_back(x,y,a,r);\n        }\n        Real mat[n][n];\n        rep(i,n){\n            rep(j,n){\n                if(i==j)mat[i][j]=0;\n                else mat[i][j] = distance(v[i],v[j]);\n            }\n        }\n        rep(k,n){\n            rep(i,n){\n                rep(j,n){\n                    mat[i][j] = min(mat[i][j],mat[i][k]+mat[k][j]);\n                }\n            }\n        }\n        cout << setprecision(15) << fixed << mat[m-1][l-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define rep(i,n) for(int i=0,i##_len=n;i<i##_len;i++)\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Line> make_star(int x, int y, int a, int r){\n  int d = 5;\n  ld rad = 4 * pi / 5;\n  Point p(x, y);\n  Point v(0, r);\n  ld aa = a/180.0 * pi;\n  v *= Point(cos(aa), sin(aa));\n  Point rot(cos(rad), sin(rad));\n  vector<Line> res;\n  rep(i, d){\n    res.emplace_back(v + p,v * rot + p);\n    v *= rot;\n  }\n  return res;\n}\n\ntemplate <typename Cost>\nstruct CEdge {\n  int from, to;\n  Cost cost;\n  CEdge(int s, int t, Cost c) : from(s), to(t), cost(c) {}\n};\n\ntemplate<typename Cost> using CGraph = vector<vector<CEdge<Cost>>>;\n\ntemplate <typename Cost>\nvoid add_edge(CGraph<Cost> &g, int from, int to, Cost cost) {\n  g[from].emplace_back(from, to, cost);\n}\n\nconst int inf = 1e9;\n\ntemplate <typename Cost>\nvector<Cost> dijkstra(const CGraph<Cost> &g, int s, Cost zero = 0) {\n  vector<Cost> d(g.size(), inf);\n  d[s] = zero;\n  using P = pair<Cost,int>;\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(zero, s));\n  while (!que.empty()) {\n    Cost dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    for (const auto &e: g[v]) {\n      if (d[e.to] <= d[v] + e.cost) continue;\n      d[e.to] = d[v] + e.cost;\n      que.push(P(d[e.to], e.to));\n    }\n  }\n  return d;\n}\n\nld dist_stars (vector<Line> s, vector<Line> t){\n  ld res = 1e30l;\n  for(auto&& ss: s){\n    for(auto&& tt: t){\n      res = min(res, dist_ss(ss, tt));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n, m, l;\n  while(cin >> n >> m >> l, n != 0){\n    vector<vector<Line>> stars(n);\n    rep(i, n){\n      int x, y, a, r; cin >> x >> y >> a >> r;\n      stars[i] = make_star(x, y, a, r);\n    }\n    CGraph<ld> g(n);\n    rep(i, n){\n      rep(j, n){\n        add_edge(g, i, j, dist_stars(stars[i], stars[j]));\n      }\n    }\n    vector<ld> route = dijkstra(g, n - 1);\n    cout << std::setprecision(24) << route[m - 1] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nD eps=1e-9,pi=3.14159265358979,inf=1e100;\nP rot(int rad){\n\tdouble rd=(double)rad*pi/180;\n\treturn P(cos(rd),sin(rd));\n}\nD dot(P a,P b){\n\treturn real(conj(a)*b);\n}\nD cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(c-b)-abs(a-c))<eps) return -2;\n\tif(abs(abs(a-c)+abs(a-b)-abs(c-b))<eps) return 2;\n}\nP perp(L l,P p){\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\nbool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0 && ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nbool iSP(L s,P p){\n\treturn ccw(s.fs,s.sc,p)==0;\n}\nD dSP(L s,P p){\n\tP q=perp(s,p);\n\treturn iSP(s,q) ? abs(p-q) : min(abs(p-s.fs),abs(p-s.sc));\n}\nD dSS(L a,L b){\n\tif(iSS(a,b)) return 0;\n\treturn min(min(dSP(a,b.fs),dSP(a,b.sc)),min(dSP(b,a.fs),dSP(b,a.sc)));\n}\nvector<L> lines[100];\nD d[100][100];\nint main(){\n\twhile(true){\n\t\tint n,m,l;\n\t\tcin>>n>>m>>l;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tint x,y,a,r;\n\t\t\tcin>>x>>y>>a>>r;\n\t\t\tP p=P(0,r),o=P(x,y);\n\t\t\tP v=p*rot(a),nv;\n\t\t\tlines[i].clear();\n\t\t\trep(j,5){\n\t\t\t\tnv=v*rot(144);\n\t\t\t\tlines[i].pb(L(o+v,o+nv));\n\t\t\t\tv=nv;\n\t\t\t}\n\t\t}\n\t\trep(i,n) rep(j,n) if(i!=j){\n\t\t\td[i][j]=inf;\n\t\t\trep(k,5) rep(h,5) d[i][j]=min(d[i][j],dSS(lines[i][k],lines[j][h]));\n\t\t}\n\t\trep(i,n) rep(j,n) rep(k,n) d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\tprintf(\"%.9f\\n\",d[m-1][l-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define PI M_PI\n#define MAX_N 100\n#define INF 1e9\n\nclass Point{\npublic:\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nclass Segment{\npublic:\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nclass Star : public Point{\npublic:\n  double a,r;\n  vector<Segment> segs;\n  Star(){}\n  Star(Point p,double a,double r) : Point(p),a(a),r(r) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nPoint projection(const Segment &s,const Point &p){\n  Vector b = s.t-s.s;\n  double t = dot(p-s.s,b)/norm(b);\n  return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n  Point r = projection(s,p);\n  if(isIntersectSP(s,r)){ return abs(r-p); }\n  return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment a,const Segment b){\n  if(isIntersectSS(a,b)){ return 0; }\n  return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n             min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nistream &operator >> (istream &is,Star &s){\n  return is >> s.x >> s.y >> s.a >> s.r;\n}\n\ndouble toRad(double ang){ return ang*PI/180.0; }\n\nPoint rotate(const Point &bp,const Point &p,double th){\n  double x = p.x, y = p.y;\n  return Point(cos(th)*x-sin(th)*y+bp.x,sin(th)*x+cos(th)*y+bp.y);\n}\n\nvoid makeStar(vector<Star> &stars){\n  int N = stars.size();\n  for(int i = 0 ; i < N ; i++){\n    double x = stars[i].x, y = stars[i].y;\n    double r = stars[i].r, a = stars[i].a;\n    Point bp(x,y), p(x,y+r); p = p - bp;\n    p = rotate(bp,p,toRad(a));\n    vector<Point> ps(5);\n    for(int j = 0 ; j < 5 ; j++){\n      ps[j] = p;\n      p = p - bp;\n      p = rotate(bp,p,toRad(144));\n    }\n    stars[i].segs.resize(5);\n    for(int j = 0 ; j < 5 ; j++){\n      stars[i].segs[j] = Segment(ps[j],ps[(j+2)%5]);\n    }\n  }\n}\n\nint main(){\n  int N,M,L;\n  while(cin >> N >> M >> L, N){\n    vector<Star> stars(N);\n    M--; L--;\n    for(int i = 0 ; i < N ; i++){\n      cin >> stars[i];\n    }\n    makeStar(stars);\n    double d[MAX_N][MAX_N];\n    fill(d[0],d[0]+N*N,INF);\n    for(int i = 0 ; i < N ; i++){\n      d[i][i] = 0;\n      for(int j = i+1 ; j < N ; j++){\n        double dist = INF;\n        for(int k = 0 ; k < 5 ; k++){\n          for(int l = 0 ; l < 5 ; l++){\n            Segment s1 = stars[i].segs[k];\n            Segment s2 = stars[j].segs[l];\n            dist = min(dist,distanceSS(s1,s2));\n          }\n        }\n        d[i][j] = d[j][i] = dist;\n      }\n    }\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\",d[M][L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <iomanip>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N,S,G = 0;\n\ndouble l[110][110] = {};\ndouble nowL[110] = {};\nconst double PI = 3.14159265358979;\nstruct Star {\n\tconst int px, py,a;\n\tdouble x[5], y[5];\n\tStar(int _px, int _py, int _a, int _r) :px(_px),py(_py),a(_a) {\n\t\tfor (int i = 0; i < 5;i++) {\n\t\t\tx[i] = px + _r * cos((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t\ty[i] = py + _r * sin((90.0000000 + _a + i * 72.0000000)*PI / 180.00000000);\n\t\t}\n\t};\n};\n\nStar *s[105];\n\ndouble MinL(double x0, double y0, double x1, double y1, double x2, double y2) {\n\tdouble dx = x1 - x2, dy = y1 - y2;\n\tdouble x = (dx*dx*x0 - dx*dy*y0 + dy*(dx*y2 - dy*x2)) / (dx*dx - dy*dy);\n\tdouble d;\n\tif (min(x1, x2) <= x && x <= max(x1, x2)) {\n\t\td=abs(dy*x0 - dx*y0 + x1*y2 - x2*y1) / hypot(dx, dy); \n\t}\n\telse {\n\t\td=min(hypot(x1 - x0, y1 - y0), hypot(x2 - x0, y2 - y0));\n\t}\n\treturn d;\n}\n\nvoid CalcStar(int a, int b) {\n\tconst unsigned lineGoal[5]={2,3,4,0,1};\n\tdouble temp = 100000;\n\tfor (int i = 0; i < 5;i++) {\n\t\tfor (int j = 0; j < 5;j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[a]->x[i], s[a]->y[i],\n\t\t\t\ts[b]->x[j], s[b]->y[j],\n\t\t\t\ts[b]->x[lineGoal[j]], s[b]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\ttemp = min(temp,\n\t\t\tMinL(\n\t\t\t\ts[b]->x[i], s[b]->y[i],\n\t\t\t\ts[a]->x[j], s[a]->y[j],\n\t\t\t\ts[a]->x[lineGoal[j]], s[a]->y[lineGoal[j]])\n\t\t\t);\n\t\t}\n\t}\n\tl[b][a] = l[a][b] = temp;\n}\n\ndouble minCost[110];\nvoid Dijkstra(int _s,int _g) {\n\tfor (int i = 1; i <= N;i++) {\n\t\tminCost[i] = 1000000;\n\t}\n\tminCost[_s] = 0;\n\tstruct Node {\n\t\tint num;\n\t\tdouble cost;\n\t\tbool operator > (const Node& _node)const {\n\t\t\treturn cost > _node.cost;\n\t\t}\n\t};\n\tpriority_queue<Node,vector<Node>,greater<Node>> PQ;\n\tNode node = { _s, 0 };\n\tPQ.push( node );\n\twhile (!PQ.empty()){\n\t\tNode now = PQ.top(); PQ.pop();\n\t\tif (now.cost > minCost[now.num]) {\n\t\t\tcontinue;\n\t\t}\n\t\tminCost[now.num] = now.cost;\n\t\tif (now.num==_g) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= N;i++) {\n\t\t\tif (i!=now.num) {\n\t\t\t\tNode node = { i,now.cost + l[now.num][i] };\n\t\t\t\tPQ.push(node);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (true){\n\t\tcin >> N >> S >> G;\n\t\tif (N==0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\ts[i] = new Star(x, y, a, r);\n\t\t\tnowL[i] = 5000;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\t\tCalcStar(i, j);\n\t\t\t}\n\t\t}\n\t\tDijkstra(S, G);\n\t\tcout << fixed << setprecision(7) << minCost[G] << endl;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdelete s[i];\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 4);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nbool intersectSP(const line_t &s, const xy_t &p) {\n  return abs(s.first - p) + abs(s.second - p) - abs(direction(s)) < EPS;\n}\n\nbool intersectSS(const line_t &s, const line_t &t) {\n  return ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n         ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\nxy_t projection(const line_t &l, const xy_t &p) {\n  double t = dot(p - l.first, direction(l) / norm(direction(l)));\n  return l.first + t*(direction(l));\n}\n\ndouble distanceSP(const line_t &s, const xy_t &p) {\n  const xy_t r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.first - p), abs(s.second - p));\n}\n\ndouble distanceSS(const line_t &s, const line_t &t) {\n  if (intersectSS(s, t)) return 0;\n  \n  return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n    \n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\nstruct star {\n  int x, y, a, r;\n\n  vector<xy_t> points() const {\n    vector<xy_t> ps;\n    xy_t   center = xy_t(x, y);\n    double theta  = (double)a / 180 * M_PI + M_PI / 2;\n    REP(i, 5) {\n      // cout << center + polar((double)r, theta + M_PI * i * 2 / 5) << endl;\n      ps.push_back(center + polar((double)r, theta + M_PI * i * 2 / 5));\n    }\n    return ps;\n  }\n  \n  vector<line_t> segments() const {\n    vector<xy_t>   ps = this->points();\n    vector<line_t> res;\n\n    REP(i, ps.size()) REP(j, i){\n      res.push_back(line_t(ps[j], ps[i]));\n    }\n    return res;\n  }\n};\n\ndouble distance(const star &s, const star &t){\n  vector<line_t> seg_ss = s.segments();\n  vector<line_t> seg_ts = t.segments();\n  double res = 1e9;\n\n  for (line_t seg_s : seg_ss){\n    for (line_t seg_t : seg_ts){\n      res = min(res, distanceSS(seg_s, seg_t));\n    }\n  }\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, L;\n  while (cin >> N >> M >> L && N + M + L){\n    vector<star> stars(N);\n    vector<vector<double> > dist(N, vector<double>(N));\n    REP(i, N){\n      cin >> stars[i].x >> stars[i].y >> stars[i].a >> stars[i].r;\n    }\n\n    REP(i, N) REP(j, N){\n      dist[i][j] = distance(stars[i], stars[j]);\n    }\n\n    REP(k, N) REP(i, N) REP(j, N){\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n    printf(\"%.20lf\\n\", dist[L - 1][M - 1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( complex<double> a, complex<double> b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(complex<double> p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distancion(L,L); //線分:線分の距離(iteratorのdistanceと被るから留意)\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\n\nstruct edge{\n  int to;\n  double cost;\n  edge( int to, double cost):to(to),cost(cost){};\n};\nvector< vector< edge > > info;\n\nLLL comb( int x, int y, int a, int r){\n  G hosi(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  LLL ls(5);\n  for(int i = 0 ; i < 5 ; i++ ){\n    ls[i] = L( hosi[i * 2 % 5], hosi[(i + 1) * 2 % 5]);\n  }\n  return ls;\n}\ndouble dist( LLL a, LLL b){\n  double ret = INF;\n  for(int i = 0 ; i < a.size() ; i++ ){\n    for(int j = 0 ; j < b.size() ; j++ ){\n      ret = min( ret, distancion( a[i], b[i]));\n    }\n  }\n  return ret;\n}\ntypedef pair< double , int > Pi;\nbool used[101];\ndouble Dijkstra( int st, int gl){\n  priority_queue< Pi , vector< Pi > , greater< Pi > > que;\n  fill_n( used, 101, false);\n  que.push( Pi( 0.0, st));\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.sc == gl) return p.fr;\n    if(used[p.sc]++) continue;\n    for(int i = 0 ; i < info[p.sc].size() ; i++ )\n      que.push( Pi( info[p.sc][i].cost + p.fr, info[p.sc][i].to));\n  }\n}\n\nint main(){\n  int n, m, l;\n  vector< LLL  > stars( 101, LLL( 5));\n\n  while(cin >> n >> m >> l, l){\n    info.resize(n + 1);\n    for(int i = 1 ; i <= n ; i++ ){\n      int x, y, a, r;\n      cin >> x >> y >> a >> r;\n      LLL ret = comb( x, y, a, r);\n      copy( ret.begin(), ret.end(), stars[i].begin());\n    }\n\n    for(int i = 1 ; i <= n ; i++ ){\n      for(int j = n ; j > i ; j-- ){\n        double mindistance = dist( stars[i], stars[j]);\n        info[i].push_back( edge( j, mindistance));\n        info[j].push_back( edge( i, mindistance));\n      }\n    }\n    cout << fixed << setprecision(10) << Dijkstra( m, l) << endl;\n    info.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing  ld = long double;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(15);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_sp(Line(seg[i][ii], seg[i][(ii + 1) % 10]), seg[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define FOR(i,a,n) for(int i = (a);i < (n);i++)\ndouble PI = acos(-1);\nconst double EPS = 1e-10;\nconst double INF = 1e9;\nusing namespace std;\n\nint N,M,L;\n\nstruct Point{\n    double x,y;\n    Point operator - (const Point& p){ return Point{x-p.x,y-p.y};}\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\ndouble norm(Point a){return a.x*a.x+a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a,Point b){return a.x*b.y - a.y*b.x;}\n\nint ccw(Point p1,Point p2,Point p3){\n    Point a = {p2.x-p1.x, p2.y - p1.y};\n    Point b = {p3.x-p1.x, p3.y - p1.y};\n    if(cross(a,b) > EPS) return 1;\n    if(cross(a,b) < -EPS) return -1;\n    if(dot(a,b) < -EPS) return 2;\n    if(norm(a) < norm(b)) return -2;\n    return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1,s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < -EPS) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < -EPS) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n    \n\nSegment star[102][5];\ndouble mindist[102][102];\n\n\n\ndouble getdist(int u, int v){\n    REP(i,5){\n        REP(j,5){\n            if(intersect(star[u][i],star[v][j])){\n                    return 0;\n            }\n        }\n    }\n    double ans = INF;\n    REP(k,2){\n        if(k) swap(u,v);\n        REP(i,5){\n            REP(j,5){\n                ans = min(getDistSP(star[u][i],star[v][j].p1),ans);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>N>>M>>L,N){\n        REP(i,N){\n            int x,y,a,r;\n            cin>>x>>y>>a>>r;\n            Point p[5];\n            REP(j,5) p[j] = Point{x + r*sin((double)(72*j - a)/180*PI), y + r*cos((double)(72*j - a)/180*PI)};//star's vertex\n            REP(j,5){\n                star[i][j] = Segment{p[j], p[(j+2)%5]};\n            }\n        }\n\n        //caluculate min distance\n        REP(i,N){\n            FOR(j,i,N){\n                mindist[i][j] = mindist[j][i] = getdist(i,j);\n            }\n        }\n\n        //WF        \n        REP(k,N){\n            REP(i,N){\n                REP(j,N){\n                    mindist[i][j] = min(mindist[i][j], mindist[i][k] + mindist[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(8) << mindist[M-1][L-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <complex>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst long double EPS = 1e-9;\nconst long double PI = acos(-1);\ninline bool equals(long double a, long double b) { return abs(b - a) < EPS; }\nusing Point = complex<long double>;\nostream &operator<<(ostream &os, Point &p) { os << p.real() << \" \" << p.imag(); }\ninline Point rotate(long double theta, const Point &p) { return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag()); }\ninline long double to_degree(long double r) { return (r * 180.0 / PI); }\ninline long double to_radian(long double d) { return (d * PI / 180.0); }\nnamespace std { bool operator < (const Point &a, const Point &b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); } }\ninline long double dot(const Point &a, const Point &b) { return real(a) * real(b) + imag(a) * imag(b); }\ninline long double cross(const Point &a, const Point &b) { return real(a) * imag(b) - imag(a) * real(b); }\nstruct Line\n{\n    Point a, b;\n    Line(Point a, Point b) : a(a), b(b) {}\n};\nstruct Segment : Line { Segment(Point a, Point b) : Line(a, b) {} };\ninline int ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\ntemplate<typename T = Line>\ninline Point getProjection(const T &l, const Point &p)\n{\n    long double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n//点、直線、線分の交差\ninline bool isIntersect(const Line &l, const Point &p) { return abs(ccw(l.a, l.b, p)) != 1; }\ninline bool isIntersect(const Line &l, const Line &m) { return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS; }\ninline bool isIntersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }\ninline bool isIntersect(const Line &l, const Segment &s) { return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS; }\ninline bool isIntersect(const Segment &s, const Segment &t) { return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0; }\n//距離\ninline long double getDistance(const Point &a, const Point &b) { return abs(a - b); }\ninline long double getDistance(const Line &l, const Point &p) { return abs(p - getProjection(l, p)); }\ninline long double getDistance(const Segment &s, const Point &p)\n{\n    Point r = getProjection(s, p);\n    if(isIntersect(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\ninline long double getDistance(const Line &l, const Line &m) { return isIntersect(l, m) ? 0 : getDistance(l, m.a); }\ninline long double getDistance(const Segment &s1, const Segment &s2)\n{\n    if(isIntersect(s1, s2)) return 0;\n    return min({getDistance(s1, s2.a), getDistance(s1, s2.b), getDistance(s2, s1.a), getDistance(s2, s1.b)});\n}\nint N, M, L;\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    while(cin >> N >> M >> L, N or M or L)\n    {\n        vector<Point> s[N];\n        for(int i = 0; i < N; i++)\n        {\n            long double x, y, a, r; cin >> x >> y >> a >> r;\n            for(int j = 0; j < 5; j++)\n            {\n                long double rad = to_radian(72 * j + a + 90);\n                Point p = Point(r * cos(rad) + x, r * sin(rad) + y);\n                s[i].push_back(p);\n            }\n        }\n        vector<Segment> t[N];\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < 5; j++)\n            {\n                Segment l = Segment(s[i][j], s[i][(j + 2) % 5]);\n                t[i].push_back(l);\n            }\n        }\n        vector<vector<long double>> G(N, vector<long double>(N, 1e8));\n        for(int i = 0; i < N; i++) G[i][i] = 0.0;\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < N; j++)\n            {\n                if(i == j) continue;\n                long double dist = 1e8;\n                for(int a = 0; a < 5; a++)\n                {\n                    for(int b = 0; b < 5; b++) dist = min(dist, getDistance(t[i][a], t[j][b]));\n                }\n                G[i][j] = min(G[i][j], dist);\n            }\n        }\n        for(int k = 0; k < N; k++)\n        {\n            for(int i = 0; i < N; i++)\n            {\n                for(int j = 0; j < N; j++) G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n            }\n        }\n        cout << G[M - 1][L - 1] << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<long double> Point;\ntypedef pair<long double, int> P;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass ST{\npublic:\n  long double x, y, a, r;\n  ST(){}\n  ST(long double x, long double y, long double a, long double r) : x(x), y(y), a(a), r(r) {}\n};\n\nconst int N = 100;\nconst long double INF = 100000000.0;\nconst long double EPS = 1e-10;\n\nint n, s, t;\nvector<ST> input;\nlong double dist[N][N];\n\nlong double dot(Point a, Point b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\nlong double cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nlong double getDistanceLP(Line s, Point p){\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\nlong double getDistanceSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\nlong double getDistance(Segment s1, Segment s2){\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint rotate(Point p, Point o, long double dir){\n  Point res;\n  dir = M_PI * dir / 180.0;\n  p -= o;\n  res.real() = p.real() * cos(dir) - p.imag() * sin(dir);\n  res.imag() = p.real() * sin(dir) + p.imag() * cos(dir);\n  res += o;\n  return res;\n}\n\nvoid get_seg(ST st, vector<Segment>& vec, vector<Point>& vec2){\n  Point o = Point(st.x, st.y);\n  Point p = rotate(Point(st.x, st.y + st.r), o, st.a);\n  for(int i=0;i<5;i++){\n    vec2.push_back(p);\n    p = rotate(p, o, 72.0);\n  }\n  for(int i=0;i<4;i++){\n    vec.push_back((Segment){vec2[i], vec2[i+1]});\n  }\n  vec.push_back((Segment){vec2[4], vec2[0]});\n}\n\nlong double calc_dist(ST pa, ST pb){\n  vector<Segment> a1, b1;\n  vector<Point> a2, b2;\n  get_seg(pa, a1, a2);\n  get_seg(pb, b1, b2);\n  long double res = INF;\n  for(int i=0;i<a1.size();i++){\n    for(int j=0;j<b1.size();j++){\n      res = min(res, getDistance(a1[i], b1[j]));\n    }\n  }\n  for(int i=0;i<a2.size();i++){\n    for(int j=0;j<b2.size();j++){\n      res = min(res, abs(a2[i] - b2[j]));\n    }\n  }\n  return res;\n}\n\nvoid make_graph(){\n  fill(dist[0], dist[N], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = dist[j][i] = calc_dist(input[i], input[j]);\n    }\n  }\n}\n\nlong double solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[s][t];\n}\n\nmain(){\n  while(cin >> n >> s >> t && (n|s|t)){\n    input.clear();\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n      long double x, y, a, r;\n      cin >> x >> y >> a >> r;\n      input.push_back(ST(x, y, a, r));\n    }\n    make_graph();\n    printf(\"%.20f\\n\", (double)solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nDD dp[110][110] = { 0 };\n\nint main() {\n    int N, s, t;\n    while (cin >> N >> s >> t, N) {\n        --s, --t;\n        vector<vector<Point> > stars(N, vector<Point>(5));\n        for (int i = 0; i < N; ++i) {\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            for (int dir = 0; dir < 5; ++dir) {\n                double ang = torad(a + 90 + dir * 72);\n                Point p(x + r * cos(ang), y + r * sin(ang));\n                stars[i][dir] = p;\n            }\n        }\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                double dist = INF;\n                for (int di = 0; di < 5; ++di) {\n                    for (int dj = 0; dj < 5; ++dj) {\n                        double tmp = abs(stars[i][di] - stars[j][dj]);\n                        dist = min(dist, tmp);\n                    }\n                }\n                dp[i][j] = dist;\n            }\n        }\n        for (int k = 0; k < N; ++k)\n            for (int i = 0; i < N; ++i)\n                for (int j = 0; j < N; ++j)\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n        cout << fixed << setprecision(10) << dp[s][t] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing  ld = long double;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(15);\n\tcin.sync_with_stdio(false);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_ss(Line(seg[i][ii], seg[i][(ii + 1) % 10]), Line(seg[j][jj], seg[j][(jj + 1) % 10])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nconst double PI = 3.14159265358979323846264;\n\ndouble deg2rad(double deg) {\n  return deg*PI/180;\n}\n\nP rotate(P p, P c, double d) {\n  return c+(p-c)*P(cos(d),sin(d));\n}\n\n\n#include <cstdio>\n\nconst int INF = 1000000000;\nL star[100][5];\ndouble d[100][100];\n\ndouble diststar(int i,int j){\n  double ans = 1000000;\n  for (int ii=0; ii<5; ii++)\n    for (int ji=0; ji<5; ji++)\n      ans = min(ans,distanceSS(star[i][ii],star[j][ji]));\n  return ans;\n}\n\nint main() {\n  int n,m,l;\n  while(scanf(\"%d %d %d\",&n,&m,&l),n) {\n    for(int i=0; i<n; i++) {\n      double x,y,a,r;\n      scanf(\"%lf %lf %lf %lf\",&x,&y,&a,&r);\n      P c(x,y),up(x,y+r);\n      for (int j=0; j<5; j++) {\n\tP f = rotate(up,c,deg2rad(j*144+a));\n\tP t = rotate(up,c,deg2rad(((j+1)%5)*144+a));\n\tstar[i][j] = L(f,t);\n      }\n    }\n\n    for (int i=0; i<n; i++)\n      for (int j=0; j<n; j++)\n\td[i][j] = (i==j?0:diststar(i,j));\n\n    for (int k=0; k<n; k++)\n      for (int i=0; i<n; i++)\n\tfor (int j=0; j<n; j++)\n\t  d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n    printf(\"%.8f\\n\",d[m-1][l-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equlas(a, b) (fabs((a) - (b)) < EPS)\n#define INF (1e9+7)\n#define PI acos(-1)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point (double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator - (Point p) {\n        return Point(x - p.x, y - p.y);\n    }\n\n    Point operator * (double c) {\n        return Point(c * x, c * y);\n    }\n\n    Point operator / (double c) {\n        return Point(x / c, y / c);\n    }\n\n    bool operator < (const Point &p) {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n\n    bool operator == (const Point &p) {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n\n    bool operator != (const Point &p) {\n        return (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n    }\n\n    double norm() {\n        return (x * x + y * y);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n\n    Point rotatePoint(Point s, int angle) {\n        Point tmp(x - s.x, y - s.y);\n        double a = angle * PI / 180.0;\n\n        return Point(\n                    tmp.x * cos(a) - tmp.y * sin(a) + s.x, \n                    tmp.x * sin(a) + tmp.y * cos(a) + s.y);\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot (Vector a, Vector b) {\n    return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross (Vector a, Vector b) {\n    return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(Vector a) {\n    return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\ndouble distL(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distS (Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distL(s, p);\n}\n\nconst int CCW = 1;\nconst int CW = -1;\nconst int ONBACK = 2;\nconst int ONFRONT = -2;\nconst int ONSEG = 0;\n\nint ccw (Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if (cross(a, b) > EPS) return CCW;\n    if (cross(a, b) < -EPS) return CW;\n    if (dot(a, b) < -EPS) return ONBACK;\n    if (a.norm() < b.norm()) return ONFRONT;\n    return ONSEG;\n}\n\nbool intersect (Point a, Point b, Point c, Point d) {\n    return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distSS (Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distS(s1, s2.p1), distS(s1, s2.p2)), min(distS(s2, s1.p1), distS(s2, s1.p2)));\n}\n\nclass Star {\npublic:\n    Point p;\n    vector<Point> v;\n    vector<Segment> sg;\n    int r, a;\n\n    Star (Point p = Point(), int a = 0, int r = 0) : p(p), a(a), r(r) {}\n\n    void setVandSG () {\n        v.resize(5);\n        sg.resize(5);\n        Point topp(p.x, p.y + r);\n        int cnt = 0;\n\n        for (int i = 0; i < 5; ++i) {\n            v[i] = topp.rotatePoint(p, a + 72 * i);\n        }\n\n        for (int i = 0; i < 3; ++i) {\n            sg[cnt] = Segment(v[i], v[i + 2]);\n            cnt++;\n            if (i + 3 <= 4) sg[cnt] = Segment(v[i], v[i + 3]);\n            cnt++;\n        }\n    }\n\n};\n\nint n, m, l, x, y, a, r;\ndouble d[110][110];\nvector<Star> star;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cout << fixed;\n    cout.precision(10);\n\n    while (cin >> n >> m >> l, n | m | l) {\n        // initialize\n        star.resize(n);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == j) d[i][j] = 0.0;\n                else d[i][j] = INF;\n            }\n        }\n\n        //input\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> a >> r;\n            star[i] = Star(Point(double(x), double(y)), a, r);\n            star[i].setVandSG();\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < 5; ++k) {\n                    for (int o = 0; o < 5; ++o) {\n                        if (i != j) d[i][j] = min(d[i][j], distSS(star[i].sg[k], star[j].sg[o]));\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < n; ++k) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        cout << d[m-1][l-1] << endl;\n\n        star.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef complex < double > P;\ntypedef pair < P, P >      L;\ntypedef pair < P, P >      Ls;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l.fr, l.fr - l.sc) / norm( l.fr - l.sc);\n  return l.fr + t * ( l.fr - l.sc);\n}\nbool intersect( L a, P p){ //OK\n   return abs( a.fr - p) + abs( a.sc - p) - abs( a.fr - a.sc) < EPS;\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a.fr, a.sc, b.fr) * ccw( a.fr, a.sc, b.sc) <= 0 &&\n    ccw( b.fr, b.sc, a.fr) * ccw( b.fr, b.sc, a.sc) <= 0;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s.fr - p), abs( s.sc - p));\n}\ndouble distancion( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b.fr), distance( a, b.sc)),\n              min( distance( b, a.fr), distance( b, a.sc)));\n}\ndouble Degree_to_Radian(double n){\n  return n * M_PI / 180.0;\n}\ndouble Radian_to_Degree(double n){\n  return n * 180.0 / M_PI;\n}\n/* ここまでテンプレート */\ndouble info[100][100];\nint n, m, l;\nL stars[100][5];\nint table[][5] = {{0,0,1,1,2},{2,3,3,4,4}};\nP hosi[5];\nvoid add( double x, double y, double a, double r, int z){\n  for(int i = 0 ; i < 5 ; i++ ){\n    double theta = Degree_to_Radian(a + 72 * i);\n    double nx = r * sin( theta ), ny = r * cos( theta );\n    hosi[i] = P( x - nx, y + ny);\n  }\n  for(int i = 0 ; i < 5 ; i++ ){\n    stars[z][i] = L( hosi[table[0][i]], hosi[table[1][i]]);\n  }\n}\nint main(){ //vectorが重いかも\n  while(scanf(\"%d%d%d\", &n, &m, &l), n|m|l){\n    m--, l--;\n    for(int i = 0 ; i < n ; i++ ){\n      double x, y, a, r;\n      scanf(\"%lf%lf%lf%lf\", &x, &y, &a, &r);\n      add( x, y, a, r, i);\n    }\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = i + 1 ; j < n ; j++ ){\n        double dist = INF;\n        for(int a = 0 ; a < 5 ; a++ ){\n          for(int b = 0 ; b < 5 ; b++ ){\n            dist = min( dist, distancion( stars[i][a], stars[j][b]));\n          }\n        }\n        info[i][j] = info[j][i] = dist;\n      }\n    }\n    for(int k = 0; k < n; k++ ){\n      for(int i = 0; i < n; i++ ){\n        for(int j = 0; j < n; j++ ){\n          info[i][j] = min( info[i][j], info[i][k] + info[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\", info[m][l]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define INF 1e8\n#define EPS 1e-10\nusing namespace std;\n\nstruct edge{\n\tdouble cost;\n\tint t;\n\tedge(){}\n\tedge(int tt,double cc){\n\t\tt=tt;\n\t\tcost=cc;\n\t}\n};\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble cross(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).cross(p2-q)==0.0 && (p1-q).dot(p2-q)<=0;\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).cross(q1-p1)/(q2-q1).cross(p2-p1));\n}\n\nint n,S,T;\nint x[101],y[101],a[101],r[101];\nvector<edge> G[101];\n\ndouble dist(P a,P b){\n\treturn sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\ndouble check(P p1,P p2,P q1,P q2){\n\tif((p1-q1).dot(p2-q2)==0.0){\n\t\tif(on_seg(p1,p2,q1) || on_seg(p1,p2,q2) || on_seg(q1,q2,p1) || on_seg(q1,q2,p2))return 0.0;\n\t}else{\n\t\tP r=intersection(p1,p2,q1,q2);\n\t\tif(on_seg(p1,p2,r) && on_seg(q1,q2,r))return 0.0;\n\t}\n\tdouble res=INF;\n\tdouble d=(q1-p1).dot(p2-p1)/dist(p1,p2);\n\tif((q1-p1).dot(p2-p1)<=0.0){\n\t\tres=min(res,dist(p1,q1));\n\t}else if((q1-p1).dot(p2-p1)<(p2-p1).dot(p2-p1)){\n\t\tres=min(res,sqrt(pow(dist(p1,q1),2)-d*d));\n\t}else res=min(res,dist(p2,q1));\n\n\td=(q2-p1).dot(p2-p1)/dist(p1,p2);\n\tif((q2-p1).dot(p2-p1)<=0.0){\n\t\tres=min(res,dist(p1,q2));\n\t}else if((q2-p1).dot(p2-p1)<(p2-p1).dot(p2-p1)){\n\t\tres=min(res,sqrt(pow(dist(p1,q2),2)-d*d));\n\t}else res=min(res,dist(p2,q2));\n\n\tswap(p1,q1);\n\tswap(p2,q2);\n\n\td=(q1-p1).dot(p2-p1)/dist(p1,p2);\n\tif((q1-p1).dot(p2-p1)<=0.0){\n\t\tres=min(res,dist(p1,q1));\n\t}else if((q1-p1).dot(p2-p1)<(p2-p1).dot(p2-p1)){\n\t\tres=min(res,sqrt(pow(dist(p1,q1),2)-d*d));\n\t}else res=min(res,dist(p2,q1));\n\n\td=(q2-p1).dot(p2-p1)/dist(p1,p2);\n\tif((q2-p1).dot(p2-p1)<=0.0){\n\t\tres=min(res,dist(p1,q2));\n\t}else if((q2-p1).dot(p2-p1)<(p2-p1).dot(p2-p1)){\n\t\tres=min(res,sqrt(pow(dist(p1,q2),2)-d*d));\n\t}else res=min(res,dist(p2,q2));\n\treturn res;\n}\n\nstruct data{\n\tint v;\n\tdouble cost;\n\tdata(){}\n\tdata(int vv,double cc){\n\t\tv=vv;\n\t\tcost=cc;\n\t}\n\tbool operator <(const data& d1)const{\n\t\treturn cost>d1.cost;\n\t}\n};\n\ndouble dp[101];\n\ndouble dijk(){\n\tpriority_queue<data> que;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=INF;\n\t}\n\tque.push(data(S,0));\n\tdp[S]=0.0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v]<q.cost)continue;\n\t\tif(q.v==T)return q.cost;\n\t\tfor(int i=0;i<G[q.v].size();i++){\n\t\t\tedge e=G[q.v][i];\n\t\t\tif(e.cost+dp[q.v]<dp[e.t]){\n\t\t\t\tdp[e.t]=dp[q.v]+e.cost;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&S,&T);\n\t\tif(n+S+T==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tS--;\n\t\tT--;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&a[i],&r[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tP p1=P(x[i],y[i])+P((double)r[i]*cos((double)(a[i]+72.0*j+90.0)/180.0*M_PI),(double)r[i]*sin((double)(a[i]+72.0*j+90.0)/180.0*M_PI));\n\t\t\t\tP p2=P(x[i],y[i])+P((double)r[i]*cos((double)(a[i]+72.0*j+234.0)/180.0*M_PI),(double)r[i]*sin((double)(a[i]+72.0*j+234.0)/180.0*M_PI));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble co=INF;\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\t\tP p1=P(x[i],y[i])+P((double)r[i]*cos((double)(a[i]+72.0*k+90.0)/180.0*M_PI),(double)r[i]*sin((double)(a[i]+72.0*k+90.0)/180.0*M_PI));\n\t\t\t\t\t\tP p2=P(x[i],y[i])+P((double)r[i]*cos((double)(a[i]+72.0*k+234.0)/180.0*M_PI),(double)r[i]*sin((double)(a[i]+72.0*k+234.0)/180.0*M_PI));\n\t\t\t\t\t\tP q1=P(x[j],y[j])+P((double)r[j]*cos((double)(a[j]+72.0*l+90.0)/180.0*M_PI),(double)r[j]*sin((double)(a[j]+72.0*l+90.0)/180.0*M_PI));\n\t\t\t\t\t\tP q2=P(x[j],y[j])+P((double)r[j]*cos((double)(a[j]+72.0*l+234.0)/180.0*M_PI),(double)r[j]*sin((double)(a[j]+72.0*l+234.0)/180.0*M_PI));\n\t\t\t\t\t\tco=min(co,check(p1,p2,q1,q2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintf(\"%d %d %.10f\\n\",i,j,co);\n\t\t\t\tG[i].push_back(edge(j,co));\n\t\t\t\tG[j].push_back(edge(i,co));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nconst double pi = acos(-1);\n\ndouble torad(int deg){\n    return 1. * deg * pi / 180;\n}\n\nstruct Point{\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double norm() {return x * x + y * y; }\n    double abs() {return sqrt(norm()); }\n\n    bool operator < (const Point &p) const{\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n\n    bool operator == (const Point &p) const{\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nVector polar(double a, double r){\n    return Point(cos(r) * a, sin(r) * a);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// ベクトルと点の位置関係\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\n// 線分と点の距離\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\n// 線分と線分の距離\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2)) return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\nint main(){\n    while(1){\n        int n, m, l; cin>>n>>m>>l;\n        if(n == 0) return 0;\n        m--, l--;\n        vector<vector<Point>> star(n, vector<Point>(5));\n        for(int i=0; i<n; i++){\n            double x, y, a, r; cin>>x>>y>>a>>r;\n            for(int dir=0; dir<5; dir++){\n                double angle = 90 + dir * 72 + a;\n                Point np = polar(r, torad(angle));\n                double nx = x + np.x;\n                double ny = y + np.y;\n                star[i][dir] = Point(nx, ny);\n            }\n        }\n\n        vector<vector<double>> dist(n, vector<double>(n, 1e9));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                double cdist = 1e9;\n                for(int dir1=0; dir1<5; dir1++){\n                    for(int dir2=0; dir2<5; dir2++){\n                        Segment s1 = {Point(star[i][dir1]), Point(star[i][(dir1+2)%5])};\n                        Segment s2 = {Point(star[j][dir2]), Point(star[j][(dir2+2)%5])};\n\n                        cdist = min(cdist, getDistance(s1, s2));\n                    }\n                }\n\n                dist[i][j] = cdist;\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                for(int k=0; k<n; k++){\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n                }\n            }\n        }\n\n        printf(\"%.10f\\n\", dist[m][l]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n\n#define ARG5(a, b, c, d, NAME, ...) NAME\n#define REP(...) ARG5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define REP1(a) REP2(i, a)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) ARG5(__VA_ARGS__, REPR4, REPR3, REPR2, REPR1)(__VA_ARGS__)\n#define REPR1(a) REPR2(i, a)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')\n#define TMPL_T template <typename T>\n#define TMPL_TU template <typename T, typename U>\n#define mut auto\n#define let const auto\n\nusing Int = long long;\n// clang-format off\nnamespace extio {\nstd::string delimiter=\" \",pdelimiter=\" \";\nstd::string bracket_b=\"\",bracket_e=\"\";\nvoid chdelim(const std::string&s){delimiter=s;}\nvoid chpdelim(const std::string&s){pdelimiter=s;}\nvoid chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}\nTMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}\nTMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}\n}\nnamespace std {\nTMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}\nTMPL_T istream& operator>>(istream&is,tuple<int&,vector<T>&>x)\n{int N=get<0>(x);vector<T>&v=get<1>(x);v.clear();v.reserve(N);REP(i,N){T a;is>>a;v.emplace_back(a);}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<vector<T>&,int&>x){return is>>tie(get<1>(x),get<0>(x));}\nTMPL_T istream& operator>>(istream&is,tuple<int&,T*>x){int N=get<0>(x);T*v=get<1>(x);REP(i,N){is>>v[i];}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<T*,int&>x){return is>>tie(get<1>(x),get<0>(x));}\n}\nTMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\nTMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\n\ninline int in(){int x;std::cin>>x;return x;}\n\n// clang-format on\n// }}}\n\n//{{{ orliv::graph::Graph\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <limits>\n#include <vector>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  using weight_type = long double;\n  static constexpr weight_type INF = std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\nusing Weight = Edge::weight_type;\nusing Edges = std::vector<Edge>;\nusing Weights = std::vector<Weight>;\nusing Path = std::vector<int>;\nusing Nodes = std::vector<int>;\n}\nusing Graph = std::vector<graph::Edges>;\n}\n#endif\n//}}}\n//{{{ dijkstra.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n#include <algorithm>\n#include <limits>\n#include <queue>\nnamespace orliv {\nnamespace graph {\nnamespace shortest_path {\nnamespace util {\nPath buildPath(int t, std::vector<int>& prev) {\n  Path path;\n  for (int u = t; u >= 0; u = prev[u]) {\n    path.emplace_back(u);\n  }\n  std::reverse(path.begin(), path.end());\n  return std::move(path);\n}\n}\nWeights dijkstra(const Graph& g, int s, std::vector<int>& prev) {\n  const int V = g.size();\n  auto inf = Edge::INF;\n  Weights dist(V, inf);\n  prev.assign(V, -1);\n\n  dist[s] = 0;\n  std::priority_queue<Edge> pq;\n  for (pq.emplace(-2, s, 0); !pq.empty();) {\n    auto e = pq.top();\n    pq.pop();\n    if (prev[e.to] != -1) continue;\n    prev[e.to] = e.from;\n    for (const auto& f : g[e.to]) {\n      if (dist[f.to] <= e.w + f.w) continue;\n      pq.emplace(f.from, f.to, dist[f.to] = e.w + f.w);\n    }\n  }\n  return std::move(dist);\n}\nWeights dijkstra(const Graph& g, int s) {\n  std::vector<int> prev;\n  return std::move(dijkstra(g, s, prev));\n}\nstd::pair<Weight, Path> dijkstra(const Graph& g, int s, int t) {\n  std::vector<int> prev;\n  auto ws = dijkstra(g, s, prev);\n  auto path = util::buildPath(t, prev);\n  return std::move(std::make_pair(ws[t], std::move(path)));\n}\n}\n}\n}\n//}}}\n\nusing namespace std;\n\nusing Real = long double;\nusing P = std::complex<Real>;\n\nstruct Star {\n  std::vector<P> ps;\n  Star(Real x, Real y, Real a, Real r) {\n    P base(x, y);\n    P p = std::polar(r, (a + 90) / 180.0 * M_PI);\n    P rot = std::polar(1.0, 0.4 * M_PI);\n    REP(5) {\n      ps.emplace_back(p + base);\n      p *= rot;\n    }\n  }\n  Real dist(const Star& other) const {\n    Real d = 1e9;\n    for (let& p : ps) {\n      for (let& q : other.ps) {\n        d = min(d, abs(p - q));\n      }\n    }\n    return d;\n  }\n};\n\nsigned main() {\n  int N, M, L;\n  while (N = in(), M = in(), L = in(), N || M || L) {\n    orliv::Graph g(N);\n    vector<Star> stars;\n    REP(i, N) {\n      Real x = in(), y = in(), a = in(), r = in();\n      stars.emplace_back(x, y, a, r);\n    }\n    REP(i, N) REP(j, N) {\n      if (i == j) continue;\n      g[i].emplace_back(i, j, stars[i].dist(stars[j]));\n    }\n    printf(\"%.20Lf\\n\", orliv::graph::shortest_path::dijkstra(g, M - 1, L - 1).first);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return norm(outp(dir(), p - at(0))) / norm(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return norm(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return norm(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tvector<vector<S>> star(n);\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tR a, r;\n\t\t\tcin >> p >> a >> r;\n\t\t\tREP(j, 5){\n\t\t\t\tstar[i].emplace_back(p + polar(r, (90+a+j*144)/180.*PI), p + polar(r, (90+a+(j+1)*144)/180.*PI));\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>> g(n, vector<double>(n, INF));\n\t\tREP(i, n) g[i][i] = 0;\n\t\tREP(i, n)REP(j, n)REP(ik, 5)REP(jk, 5) g[i][j] = g[j][i] = min(g[j][i], star[i][ik].distance(star[j][jk]));\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tprintf(\"%.20f\\n\", g[m-1][l-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <numeric>\n#include <string>\n#include <iterator>\n#include <sstream>\n#include <map>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nint N,M,L;\n\ntypedef complex<double> P;\n\nP pt[101][5];\ndouble dp[101][101];\n\nconst double pi = 3.1415926535897932384626;\n\ndouble cross(P x, P y){\n\treturn x.real() * y.imag() - x.imag() * y.real();\n}\n\ndouble dot(P x, P y){\n\treturn x.real() * y.real() + x.imag() * y.imag();\n}\n\nbool intersep(P l1,P l2,P r1, P r2){\n\tif(cross(l2 - l1,r1 - l1) * cross(l2 - l1,r2 - l1) < 0){\n\t\tif(cross(r2 - r1,l1 - r1) * cross(r2 - r1, l2 - r1) < 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\ndouble get_len(P p, P l1, P l2){\n\tif(dot(p-l1,l2-l1) <= 0) return abs(p - l1);\n\tif(dot(p-l2,l1-l2) <= 0) return abs(p - l2);\n\tdouble cr = cross(p-l1,l2-l1);\n\treturn (abs(cr) / abs(l2-l1));\n}\n\ndouble get_min(int m,int n){\n\tif(m==n) return 0;\n\tdouble mn = INT_MAX;\n\tfor (int i = 0; i < 5; i++){\n\t\tfor (int j = 0; j < 5; j++){\n\t\t\tif(intersep(pt[m][i],pt[m][(i + 2)% 5], pt[n][j], pt[n][(j + 2) % 5])){\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\tmn = min(mn,get_len(pt[n][j],pt[m][i],pt[m][(i + 2)% 5]));\n\t\t\tmn = min(mn,get_len(pt[m][i],pt[n][j], pt[n][(j + 2) % 5]));\n\t\t}\n\t}\n\treturn mn;\n}\n\nint main()\n{\n\twhile(cin>>N>>M>>L,(N||M||L)){\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tdouble x,y,a,r;cin>>x>>y>>a>>r;\n\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\tdouble alpha = (18 + a + 72 * j)/ 180.0 * pi;\n\t\t\t\tdouble s = sin(alpha);\n\t\t\t\tdouble c = cos(alpha);\n\t\t\t\tP add = P(r,0.0) * P(c,s);\n\t\t\t\tpt[i][j] = P(x,y) + add;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tdp[i][j] = get_min(i,j);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tfor (int k = 0; k < N; k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.20lf\\n\",dp[M - 1][L - 1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nconst double PI = 3.14159265358979323846264;\n\ndouble deg2rad(double deg) {\n  return deg*PI/180;\n}\n\nP rotate(P p, P c, double d) {\n  return c+(p-c)*P(cos(d),sin(d));\n}\n\n\n#include <cstdio>\n\nconst int INF = 1000000000;\nL star[200][5];\ndouble d[200][200];\n\ndouble diststar(int i,int j){\n  double ans = 1000000;\n  for (int ii=0; ii<5; ii++)\n    for (int ji=0; ji<5; ji++)\n      ans = min(ans,distanceSS(star[i][ii],star[j][ji]));\n  return ans;\n}\n\nint main() {\n  int n,m,l;\n  while(scanf(\"%d %d %d\",&n,&m,&l),n) {\n    for(int i=0; i<n; i++) {\n      double x,y,a,r;\n      scanf(\"%lf %lf %lf %lf\",&x,&y,&a,&r);\n      P c(x,y),up(x,y+r);\n      for (int j=0; j<5; j++) {\n\tP f = c + r*rotate(P(0,1),P(0,0),deg2rad(j*72+a));\n\tP t = c + r*rotate(P(0,1),P(0,0),deg2rad((j+1)*72+a));\n\tstar[i][j] = L(f,t);\n      }\n    }\n\n    for (int i=0; i<n; i++)\n      for (int j=0; j<n; j++)\n\td[i][j] = (i==j?0:diststar(i,j));\n\n    for (int k=0; k<n; k++)\n      for (int i=0; i<n; i++)\n\tfor (int j=0; j<n; j++)\n\t  d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n    printf(\"%.15f\\n\",d[m-1][l-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    double x,y;\n    vec(){}\n    vec(double x, double y){\n        this->x=x; this->y=y;\n    }\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(double d){\n        return (vec){x*d,y*d};\n    }\n    double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\nconst double eps = 0.0000001;\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = ab.cross(ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(ab.dot(ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(ab.dot(ab)<ac.dot(ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nbool isInterSection(vec (&p)[4]){\n    switch(ccw(p[0],p[1],p[2])*ccw(p[0],p[1],p[3])){\n        case -1:\n        case -4:\n        case 0:\n            break;\n        default:\n            return false;\n    }\n    switch(ccw(p[2],p[3],p[0])*ccw(p[2],p[3],p[1])){\n        case -1:\n        case -4:\n        case 0:\n            break;\n        default:\n            return false;\n    }\n   return true;\n}\n\nvec interSection(vec (&p)[4]){\n    vec p23=p[3]-p[2],p02=p[2]-p[0],p01=p[1]-p[0];\n    double k = p23.cross(p02)/p23.cross(p01);\n    return p[0]+p01*k;\n}\n\ndouble dist(vec (&p)[4]){\n    if(isInterSection(p)) return 0;\n    double dist =1e5;\n    vec P;\n    P=p[0]+(p[1]-p[0])*((p[1]-p[0]).dot(p[2]-p[0])/(p[1]-p[0]).dot(p[1]-p[0]));\n    if(!ccw(p[0],p[1],P)){\n        dist = min(dist,(P-p[2]).norm());\n    }\n    P=p[0]+(p[1]-p[0])*((p[1]-p[0]).dot(p[3]-p[0])/(p[1]-p[0]).dot(p[1]-p[0]));\n    if(!ccw(p[0],p[1],P)){\n        dist = min(dist,(P-p[3]).norm());\n    }\n    P=p[2]+(p[3]-p[2])*((p[3]-p[2]).dot(p[0]-p[2])/(p[3]-p[2]).dot(p[3]-p[2]));\n    if(!ccw(p[2],p[3],P)){\n        dist = min(dist,(P-p[0]).norm());\n    }\n    P=p[2]+(p[3]-p[2])*((p[3]-p[2]).dot(p[1]-p[2])/(p[3]-p[2]).dot(p[3]-p[2]));\n    if(!ccw(p[2],p[3],P)){\n        dist = min(dist,(P-p[1]).norm());\n    }\n    dist = min(dist,(p[2]-p[0]).norm());\n    dist = min(dist,(p[2]-p[1]).norm());\n    dist = min(dist,(p[3]-p[0]).norm());\n    dist = min(dist,(p[3]-p[1]).norm());\n    return dist;\n}\n\ntypedef vector<vec> star;\n\ndouble dist(star& a, star& b){\n    vec p[4];\n    double d=1e8;\n    for(int i=0;i<5;i++){\n        p[0]=a[i];\n        p[1]=a[(i+2)%5];\n        for(int j=0;j<5;j++){\n            p[2]=b[j];\n            p[3]=b[(j+2)%5];\n            d=min(d,dist(p));\n        }\n    }\n    return d;\n}\n\nvector<star> S;\ntypedef pair<double,int> P;\ndouble D[100][100];\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L,N){\n        S.clear();\n        M--;L--;\n        for(int i=0;i<N;i++){\n            S.emplace_back();\n            star& s=S.back();\n            int x,y,a,r;\n            cin>>x>>y>>a>>r;\n            for(int i=0;i<5;i++){\n                double Px,Py;\n                Px=x+r*cos((90+a+72*i)/180.0*M_PI);\n                Py=y+r*sin((90+a+72*i)/180.0*M_PI);\n                s.emplace_back(Px,Py);\n            }\n        }\n        fill(D[0],D[100],1e8);\n        for(int i=0;i<N;i++){\n            D[i][i]=0;\n            for(int j=i+1;j<N;j++){\n                D[i][j]=D[j][i]=dist(S[i],S[j]);\n            }\n        }\n        priority_queue<P,vector<P>,greater<P>> que;//cost,to\n        double minimum[100];\n        fill(minimum,minimum+100,1e8);\n        que.emplace(0,M);\n        while(!que.empty()){\n            P p=que.top();que.pop();\n            double cost=p.first;\n            int v=p.second;\n            if(cost>minimum[v])continue;\n            if(v==L){\n                cout<<cost<<endl;\n                break;\n            }\n            for(int i=0;i<N;i++){\n                if(minimum[i]>cost+D[v][i]){\n                    minimum[i]=cost+D[v][i];\n                    que.emplace(minimum[i],i);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<utility>\n#include<queue>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\nconst ld eps = 1e-8, pi = acos(-1.0);\nstruct L { P a, b; };\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nld dist_pp(P p, P q) {\n  return abs(p - q);\n}\n\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  ld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n  ld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n  return min(a, b);\n}\n\nP rotate(ld deg, P p) {\n  ld rad = deg * pi / 180.0;\n  return polar(1.0000000000000l, rad) * p;\n}\n\nstruct Star { L e[5]; };\n\nld dist_stst(Star s, Star t) {\n  ld val = dist_ss(s.e[0], t.e[0]);\n  for (L ss : s.e) for (L ts : t.e) {\n    val = min(val, dist_ss(ss, ts));\n    val = min(val, \n          min(dist_pp(ss.a,ts.a),\n          min(dist_pp(ss.a,ts.b),\n          min(dist_pp(ss.b,ts.a), dist_pp(ss.b,ts.b)))));\n  }\n  return val;\n}\n\nint main() {\n  int n, m, l;\n  while (cin >> n >> m >> l and n) {\n    m--; l--;\n    vector<Star> stars(n);\n    for (Star &s : stars) {\n      ld x, y, a, r;\n      cin >> x >> y >> a >> r;\n      P center(x, y), d(0,r);\n      for (int i = 0; i < 5; i++) {\n        s.e[i].a = s.e[(i+4)%5].b = center + rotate(a + 72 * i, d);\n      }\n    }\n\n    vector<vector<ld>> dist(n);\n    for (vector<ld> &v : dist) {\n      v.reserve(n);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        dist[i][j] = dist_stst(stars[i], stars[j]);\n      }\n    }\n\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    cout << fixed << setprecision(30)<< dist[m][l] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <complex>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\ntypedef double R;\ntypedef complex<R> P;\ntypedef pair<P,P> L;\ntypedef pair<P,R> C;\ntypedef vector<P> Poly;\n\nconst double PI = acos(-1);\n#define x real()\n#define y imag()\n\nconst R EPS = 1e-9;\n\n\ninline bool near(const P& p,const P& q){ return abs(p-q)<EPS;}\n\nR dot(const P& p,const P& q){ return p.x*q.x+p.y*q.y;}\nR det(const P& p,const P& q){ return p.x*q.y-p.y*q.x;}\n\nenum LPposit{\n  P_CD = -2, //counter direction\n  P_CW = -1, //clock wise\n  P_OS = 0, //on segment\n  P_CCW = 1, //counter clock wise\n  P_D = 2 //direction\n};\n\ninline R ccw_b(const P& p,const P& q,const P& r){  return det(q-p,r-p);}\n\nLPposit ccw(const P& p, const P& q, const P& r){\n  R c = ccw_b(p,q,r);\n  if(c<-EPS) return P_CW;\n  if(c>EPS) return P_CCW;\n  if(dot(q-p,r-p)<-EPS) return P_CD;\n  if(dot(p-q,r-q)<-EPS) return P_D;\n  return P_OS;\n}\n\ninline R Sabs(const L& l){ return abs(l.first-l.second);}\ninline R LPdist(const L& l,const P& p){ return abs(ccw_b(l.first,l.second,p))/Sabs(l);}\n\nR SPdist(L l,P p){\n  R a = abs(l.first-p);\n  R b = abs(l.second-p);\n  R c = Sabs(l);\n  if(b*b+c*c>a*a && a*a+c*c>b*b) return LPdist(l,p);\n  return min(a,b);\n}\n\nbool crossS(const L& p,const L& q){\n  return\n    ccw(p.first,p.second,q.first)*ccw(p.first,p.second,q.second)<=0 &&\n    ccw(q.first,q.second,p.first)*ccw(q.first,q.second,p.second)<=0;\n}\n\nR SSdist(const L& a,const L& b){\n  if(crossS(a,b)) return 0;\n  double tmp = min(SPdist(a,b.first),SPdist(a,b.second));\n  return min(tmp, min(SPdist(b,a.first), SPdist(b,a.second)));\n}\n\n\nP intersect(const L& p,const L& q){\n  P vp = p.second-p.first;\n  P vq = q.second-q.first;\n  P c(det(vp,p.first), det(vq,q.first));\n  return P(det(c, P(vp.x, vq.x)), det(c, P(vp.y, vq.y))) / det(vp, vq);\n}\n\nR area(const Poly& p){\n  R ret = 0;\n  int n = p.size();\n  for(int i=0;i<n;++i) ret+=det(p[i],p[(i+1)%n]);\n  return abs(ret)/2;\n}\n\n/* ?????¨??´???????????? */\nvector<P> CLintersect(const L& l,const C& c){\n  vector<P> ret;\n  R di = LPdist(l,c.first);\n  R r = c.second;\n  if(di+EPS > r) return ret;\n  P v = l.second-l.first;\n  v/=abs(v);\n  P rv = v*P(0,1);\n  rv*=di;\n  if(LPdist(l,c.first+rv) > di+EPS) rv=-rv;\n  v*=sqrt(r*r-di*di);\n  ret.push_back(c.first+rv-v);\n  ret.push_back(c.first+rv+v);\n  return ret;\n}\n\n//circle, segment\nvector<P> CSintersect(const L& l,const C& c){\n  vector<P> u = CLintersect(l,c);\n  vector<P> ret;\n  for(int i=0;i<u.size();++i){\n    if(l.first.x <= u[i].x && u[i].x<=l.second.x &&\n       l.first.y <= u[i].y && u[i].y<=l.second.y)\n      ret.push_back(u[i]);\n  }\n  return ret;\n}\n\nvector<P> CCintersect(C c,C d){\n  vector<P> ret;\n  const R dist = abs(c.first-d.first);\n  const R cr = c.second;\n  const R dr = d.second;\n\n  if(dist > cr+dr) return ret;\n  if(dist < abs(cr-dr)) return ret;\n\n  const R s = (cr+dr+dist)/2;\n  const R area = sqrt(s*(s-cr)*(s-dr)*(s-dist));\n  const R h = 2*area/dist;\n\n  P v = d.first - c.first; v/=abs(v);\n  const P m = c.first+sqrt(cr*cr-h*h)*v;\n  const P n = v*P(0,1);\n\n  ret.push_back(m+n*h);\n  ret.push_back(m-n*h);\n  return ret;\n}\n\n/* ?????? */\nnamespace std{\n  bool operator < (const P& a,const P& b){\n    return a.x!=b.x?a.x<b.x : a.y<b.y;\n  }\n}\nPoly convexHull(vector<P> ps){\n  int n = ps.size();\n  sort(ps.begin(),ps.end());\n  Poly ret(2*n);\n  int m=0;\n  for(int i=0;i<n;++i){\n    while(m>=2 && ccw(ret[m-2],ret[m-1],ps[i])<0) --m;\n    ret[m++] = ps[i];\n  }\n  int t = m;\n  for(int i=n-2;i>=0;--i){\n    while(m>=t && ccw(ret[m-2], ret[m-1], ps[i])<0) --m;\n    ret[m++] = ps[i];\n  }\n\n  ret.resize(m-1);\n  return ret;\n}\n\nint inConvex(const Poly& ps, P p){\n  int n = ps.size();\n  int c = ccw(ps[n-1],p,ps[0]);\n  for(int i=0;i+1<n;++i)\n    if(ccw(ps[i],p,ps[i+1])!=c) return false;\n  return true;\n}\n\nint n;\nR G[101][101];\nconst R INF = 1<<29;\n\nR dist(const Poly& a,const Poly& b){\n  R ret = INF;\n  for(int i=0;i<5;++i)\n    for(int j=0;j<5;++j)\n      ret = min(ret, SSdist(L(a[i],a[(i+1)%5]),L(b[j],b[(j+1)%5])));\n  return ret;\n}\n\nR dijkstra(int s,int t){\n  double cost[101]={};\n  bool used[101]={};\n  for(int i=0;i<n;++i)\n    cost[i]=INF,used[i]=false;\n  cost[s]=0;\n  while(true){\n    double mincst = INF;\n    int id = -1;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mincst > cost[i]){\n\tid = i;\n\tmincst = cost[i];\n      }\n    }\n    if(id==-1) break;\n    used[id] = true;\n    for(int i=0;i<n;++i)\n      cost[i] = min(cost[i], cost[id]+G[id][i]);\n  }\n  return cost[t];\n}\n\nint main(){\n  const P rot = polar(1.0 ,0.8*PI);\n  int s,t;\n  while(cin>>n>>s>>t,n||s||t){\n    s--;t--;\n    vector<Poly> star(n);\n    for(int i=0;i<n;++i){\n      double a,b,c,d;\n      cin >> a >> b >> c >> d;\n      P up = P(0,1)*d;\n      up*=polar(1.0,PI*c/180);\n      for(int j=0;j<5;++j){\n\tstar[i].push_back(up+P(a,b));\n\tup*=rot;\n      }\n    }\n\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j] = G[j][i] = dist(star[i], star[j]);\n    \n    cout << fixed << setprecision(10) << dijkstra(s,t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define equal(a,b) (fabs(a-b) < EPS)\n#define PI M_PI\n#define MAX_N 100\n#define INF 1e9\n\nclass Point{\npublic:\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nclass Segment{\npublic:\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nclass Star : public Point{\npublic:\n  double a,r;\n  vector<Segment> segs;\n  Star(){}\n  Star(Point p,double a,double r) : Point(p),a(a),r(r) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nPoint projection(const Segment &s,const Point &p){\n  Vector b = s.t-s.s;\n  double t = dot(p-s.s,b)/norm(b);\n  return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n  Point r = projection(s,p);\n  if(isIntersectSP(s,r)){ return abs(r-p); }\n  return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment a,const Segment b){\n  if(isIntersectSS(a,b)){ return 0; }\n  return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n             min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nistream &operator >> (istream &is,Star &s){\n  return is >> s.x >> s.y >> s.a >> s.r;\n}\n\ndouble toRad(double ang){ return ang*PI/180.0; }\n\nPoint rotate(const Point &bp,const Point &p,double th){\n  double x = p.x, y = p.y;\n  return Point(cos(th)*x-sin(th)*y+bp.x,sin(th)*x+cos(th)*y+bp.y);\n}\n\nvoid makeStar(vector<Star> &stars){\n  int N = stars.size();\n  for(int i = 0 ; i < N ; i++){\n    double x = stars[i].x, y = stars[i].y;\n    double r = stars[i].r, a = stars[i].a;\n    Point bp(x,y), p(x,y+r);\n    p = p - bp;\n    p = rotate(bp,p,toRad(a));\n    vector<Point> ps(5);\n    for(int j = 0 ; j < 5 ; j++){\n      ps[j] = p;\n      p = p - bp;\n      p = rotate(bp,p,toRad(72));\n    }\n    stars[i].segs.resize(5);\n    for(int j = 0 ; j < 5 ; j++){\n      stars[i].segs[j] = Segment(ps[j],ps[(j+2)%5]);\n    }\n  }\n}\n\nint main(){\n  int N,M,L;\n  while(cin >> N >> M >> L, N){\n    vector<Star> stars(N);\n    M--; L--;\n    for(int i = 0 ; i < N ; i++){\n      cin >> stars[i];\n    }\n    makeStar(stars);\n    double d[MAX_N][MAX_N];\n    fill(d[0],d[0]+N*N,INF);\n    for(int i = 0 ; i < N ; i++){\n      d[i][i] = 0;\n      for(int j = i+1 ; j < N ; j++){\n        double dist = INF;\n        for(int k = 0 ; k < 5 ; k++){\n          for(int l = 0 ; l < 5 ; l++){\n            Segment s1 = stars[i].segs[k];\n            Segment s2 = stars[j].segs[l];\n            dist = min(dist,distanceSS(s1,s2));\n          }\n        }\n        d[i][j] = d[j][i] = dist;\n      }\n    }\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    printf(\"%.10f\\n\",d[M][L]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\nconst double EPS = 1e-6;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void readL() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\n\n\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\n// L:line,S:segment,P:point\nbool intersectSS( L &s,  L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L &s,  P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection( L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection( L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceSP( L &s,  P &p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS( L &s,  L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP( P &p, P &q){\n  return abs(p - q) ;\n}\nconst double PI = acos(-1);\ndouble d2r(int d){\n  return (1.0 * d/180)*PI;\n}\n\nclass star{\n  public:\n    P p[5],c;\n    L l[5];\n    star(){};\n    star(double x,double y,int a,double r){\n      int d = a + 90;\n      c = P(x,y);\n      rep(i,5){\n        p[i] = c + polar(r,d2r(d));\n        d += 72;\n      }\n      rep(i,5){\n        l[i] = L(p[i],p[(i+2)%5]);\n      }\n    }\n    P& operator[](int i){\n      return p[i];\n    }\n    bool operator<(const star &s) const {\n      return c < s.c;\n    }\n    void show(){\n      rep(i,5){\n        cout << p[i] << endl;\n      }\n      cout << endl;\n    }\n};\ndouble distanceStar(star &s, star &t){\n  double res = INF;\n  rep(i,5){\n    rep(j,5){\n      res = min(res,distanceSS(s.l[i],t.l[j]));\n    }\n  }\n  return res;\n}\n\ndouble dis[101][101];\ndouble ans[101][101];\n\nvoid warshall(int n){\n  rep(k,n){\n    rep(i,n){\n      rep(j,n){\n        dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j]);\n      }\n    }\n  } \n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n,m,l;\n  while(cin >> n >> m >> l,n+m+l){\n    --l,--m;\n    vector<pair<star,int>> vs(n);\n    double x,y,b,r;\n    rep(i,n){\n      cin >> x >> y >> b >> r;\n      vs[i] = mp(star(x,y,b,r),i);\n    }\n    REP(i,0,n){\n      rep(j,n){\n        dis[i][j] = distanceStar(vs[i].fi,vs[j].fi);\n      }\n    }\n    warshall(n);\n    fcout(10) << dis[l][m] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef double Double;\n\nconst Double EPS = 1e-7;\nconst Double PI = 3.1415926535;\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double x_, Double y_) : x(x_), y(y_) {}\n\t\n\tPoint operator + (const Point& a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\t\n\tPoint operator - (const Point& a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n} Vector;\n\nDouble norm(const Point& a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nDouble abs(const Point& a) {\n\treturn sqrt(norm(a));\n}\n\nDouble dot(const Vector& a, const Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nDouble cross(const Vector& a, const Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nDouble dist(const Point& a, const Point& b) {\n\treturn abs(a - b);\n}\n\nPoint rotate(const Point& p, Double s) {\n\treturn Point(p.x * cos(s) - p.y * sin(s),\n\t\t\t\t p.x * sin(s) + p.y * cos(s));\n}\n\ntypedef struct Line {\n\tPoint s, e;\n\tLine(Point s_, Point e_) : s(s_), e(e_) {}\n} Segment;\n\nDouble dist_point_line(const Point& p, const Line& l) {\n\treturn fabs(cross(p - l.s, l.e - l.s)) / abs(l.e - l.s);\n}\n\nDouble dist_point_seg(const Point& p, const Segment& s) {\n\tif (dot(s.e - s.s, p - s.s) < EPS) return abs(p - s.s);\n\tif (dot(s.s - s.e, p - s.e) < EPS) return abs(p - s.e);\n\treturn dist_point_line(p, s);\n}\n\nDouble dist_seg_seg(const Segment& a, const Segment& b) {\n\tDouble res = dist_point_seg(b.s, a);\n\tres = min(res, dist_point_seg(b.e, a));\n\tres = min(res, dist_point_seg(a.s, b));\n\tres = min(res, dist_point_seg(a.e, b));\n\treturn res;\n}\n\nstruct Star {\n\tvector< Segment > vs;\n\t\n\tStar(Point c, Double a, Double r) {\n\t\tvector< Point > vp;\n\t\tPoint uc(0, r);\n\t\tvp.push_back(rotate(uc, a * PI / 180.));\n\t\t\n\t\tfor_(i,0,4)\tvp.push_back(rotate(vp[i], 2. * PI / 5.));\n\t\t\n\t\tvs.push_back(Segment(vp[0] + c, vp[2] + c));\n\t\tvs.push_back(Segment(vp[0] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[3] + c));\n\t\tvs.push_back(Segment(vp[1] + c, vp[4] + c));\n\t\tvs.push_back(Segment(vp[2] + c, vp[4] + c));\n\t}\n};\n\nint N, M, L;\nvector< Star > vst;\n\nDouble dst[111][111];\n\nDouble dist_star(const Star& a, const Star& b) {\n\tDouble res = 1e7;\n\tfor_(i,0,5) for_(j,0,5) res = min(res, dist_seg_seg(a.vs[i], b.vs[j]));\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) for_(j,i+1,N) {\n\t\tdst[i][j] = dst[j][i] = dist_star(vst[i], vst[j]);\n\t}\n\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tdst[i][j] = min(dst[i][j], dst[i][k] + dst[k][j]);\n\t}\n\t\n\tprintf(\"%.9lf\\n\", dst[M-1][L-1]);\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tvst.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tDouble x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvst.push_back(Star(Point(x, y), a, r));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\nnamespace std {\n    bool operator<(const P&a, const P&b) {\n        return real(a) != real(b) ?\n            real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P &a, const P&b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P&a, const P&b) {\n    return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n    L(const P &a, const P&b) {\n        push_back(a); push_back(b);\n    }\n};\nint ccw(P a, P b, P c) {\n    b-=a, c-=a;\n    if (cross(b,c) > 0) return 1;\n    if (cross(b,c) < 0) return -1;\n    if (dot(b,c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;\n}\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P&p) {\n    const P r = projection(s,p);\n    if (intersectSP(s,r)) return abs(r-p);\n    return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n               min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\n\ndouble g[100][100];\n\nint main() {\n    int n, M, LL;\n    while(cin>>n>>M>>LL, n || M || LL) {\n        vector<vector<L> > stars;\n        for (int i=0; i<n; ++i) {\n            double x, y, a, r;\n            cin >> x >> y >> a >> r;\n            a = a/180*PI;\n            P p(0,r);\n            p *= P(cos(a), sin(a));\n            vector<P> v;\n            for (int j=0; j<5; ++j) {\n                v.push_back(P(x,y) + p);\n                p *= P(cos(PI*2/5), sin(PI*2/5));                \n            }\n            vector<L> ls;\n            ls.push_back(L(v[0],v[2]));\n            ls.push_back(L(v[0],v[3]));\n            ls.push_back(L(v[1],v[3]));\n            ls.push_back(L(v[1],v[4]));\n            ls.push_back(L(v[2],v[4]));\n            stars.push_back(ls);\n            // for (int j=0; j<5; ++j) {\n            //     cout << stars[i][j][0] << \" \" << stars[i][j][1] << endl;\n            // } cout << endl;\n        }\n        for (int i=0;i<n;++i) {\n            for(int j=0;j<=i;++j) {\n                double mi = INF;\n                for (int k=0; k<5; ++k) {\n                    for (int l=0; l<5; ++l) {\n                        mi = min(mi, distanceSS(stars[i][k], stars[j][l]));\n                        //cout << \"   \" << distanceSS(stars[i][k], stars[j][l]) << endl;\n                    }\n                }\n                g[i][j] = mi;\n                g[j][i] = mi;\n            }\n        }\n        // for (int i=0;i<n;++i) {\n        //     for(int j=0;j<n;++j) {\n        //         cout << g[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        for (int k=0; k<n; ++k) {\n            for (int i=0;i<n;++i) {\n                for(int j=0;j<n;++j) {\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        printf(\"%.12f\\n\", g[M-1][LL-1]);\n    } \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing  ld = long double;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nint main()\n{\n\tint N, M, L;\n\tconst ld phi2 = (3 + sqrtl(5)) / 2;\n\tcout << fixed << setprecision(15);\n\tcin.sync_with_stdio(false);\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<ld>> dis(N, vector<ld>(N, 10000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tvector<vector<Point>> seg(N, vector<Point>(10));\n\t\tvector<vector<Line>> segd(N, vector<Line>(10));\n\t\tvector<ld> x(N), y(N), a(N), r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tseg[i][j] = Point(x[i], y[i]) + Point(cosl((90 + a[i] + 36 * j) / 180.0 * pi), sinl((90 + a[i] + 36 * j) / 180 * pi)) * (j & 1 ? r[i] / phi2 : r[i]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tsegd[i][j] = Line(seg[i][j], seg[i][(j + 1) % 10]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int ii = 0; ii < 10; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; jj++) {\n\t\t\t\t\t\tdis[i][j] = min(dis[i][j], dist_ss(segd[i][ii], segd[j][jj]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[M - 1][L - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n#include <complex>\n\ntypedef complex<double> P;\n\ndouble x[100],y[100],a[100],r[100];\n\ndouble toRad(int deg){\n\treturn (double)deg*2*PI/360;\n}\n\nP getCoord(int i,int j){\n\tdouble xx=x[i]+r[i]*cos(toRad(90+a[i]+72*j));\n\tdouble yy=y[i]+r[i]*sin(toRad(90+a[i]+72*j));\n\treturn P(xx,yy);\n}\n\ndouble getDist(const P &left, const P &right){\n\treturn sqrt(pow(left.real()-right.real(),2)+pow(left.imag()-right.imag(),2));\n}\n\nstruct node{\n\tint n;\n\tdouble cost;\n\tnode(int n,double cost):n(n),cost(cost){}\n\tbool operator<(const node &other)const{\n\t\treturn cost>other.cost;\n\t}\n};\nconst int MAX=INT_MAX/10;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\ndouble cross(P a,P b){\n\treturn (a.real()*b.imag()-a.imag()*b.real());\n}\n#define EQ(a,b) (abs((a)-(b))<EPS)\nbool crossing(P a1,P a2,P b1,P b2){\n\tif(EQ(cross(a1-a2,b1-b2),0,0))return false;\n\treturn ( cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS)&&\n\t\t(cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS);\n\t//return (getDist(a,c)+getDist(c,b)<getDist(a,b)+EPS);\n}\n\nint main(){\n\tint N,M,L;\n\twhile(cin>>N>>M>>L,N){\n\t\tREP(i,N){\n\t\t\tcin>>x[i]>>y[i]>>a[i]>>r[i];\n\t\t}\n\t\t/*\n\t\tREP(i,N)REP(j,5){\n\t\t\tcout<<getCoord(i,j).x<<\",\"<<getCoord(i,j).y<<endl;\n\t\t}\n\t\t*/\n\t\tvvd dist(N,vd(N,MAX));\n\t\tREP(i,N){\n\t\t\tREP(j,5){\n\t\t\t\tREP(k,N){\n\t\t\t\t\tbool flag=false;\n\t\t\t\t\tREP(l,5){\n\t\t\t\t\t\tP left=getCoord(i,j);\n\t\t\t\t\t\tP left2=getCoord(i,(j+2)%5);\n\t\t\t\t\t\tP right=getCoord(k,l);\n\t\t\t\t\t\tP right2=getCoord(k,(l+2)%5);\n\t\t\t\t\t\tif(crossing(left,left2,right,right2)){\n\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\tdist[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!flag){\n\t\t\t\t\t\t\tdist[i][k]=min(dist[i][k],getDist(left,right));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvd cost(N,MAX);\n\n\t\tpriority_queue<node> q;\n\t\tREP(i,5){\n\t\t\tq.push(node(M-1,0));\n\t\t\tcost[M-1]=0;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tnode n=q.top();\n\t\t\tq.pop();\n\t\t\tif(n.cost>cost[n.n])continue;\n\n\t\t\tREP(i,N){\n\t\t\t\tif(dist[n.n][i]<MAX){\n\t\t\t\t\tdouble dd=cost[n.n]+dist[n.n][i];\n\t\t\t\t\tif(cost[i]>dd){\n\t\t\t\t\t\tcost[i]=dd;\n\t\t\t\t\t\tq.push(node(i,dd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", cost[L-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cmath>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<29)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<Point> vp;\ntypedef vector<vp> vvp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\n\n\nint N,M,L;\n\nint main()\n{\n  while(cin >> N >> M >> L,N|M|L)\n    {\n      vvp info(N);\n      vvd G(N,vd(N));\n      rep(i,N)rep(j,N)G[i][j] = (i==j?0:inf);\n\n      rep(i,N)\n\t{\n\t  double x,y,a,r;\n\t  cin >> x >> y >> a >> r;\n\t  rep(j,5)\n\t    {\n\t      Point p = Point(0,r);\n\t      p = rotate(p,toRad(a+72*j));\n\t      info[i].push_back(Point(p.x+x,p.y+y));\n\t    }\n\t}\n\n      rep(i,N)//from\n\t{\n\t  //REP(j,i+1,N)//to\n\t  rep(j,N)\n\t    {\n\t      double mincost = inf;\n\n\t      rep(k,5)\n\t\t{\n\t\t  rep(l,5)\n\t\t    {\n\t\t      if(isIntersect(Segment(info[i][k],info[i][(k+2)%5]),Segment(info[j][l],info[j][(l+2)%5])) || isIntersect(Segment(info[i][k],info[i][(k+2)%5]),Segment(info[j][l],info[j][(l+3)%5])))\n\t\t\t{\n\t\t\t  mincost = 0;\n\t\t\t  break;\n\t\t\t}\t\t    \n\t\t      if(isIntersect(Segment(info[i][k],info[i][(k+3)%5]),Segment(info[j][l],info[j][(l+2)%5])) || isIntersect(Segment(info[i][k],info[i][(k+3)%5]),Segment(info[j][l],info[j][(l+3)%5])))\n\t\t\t{\n\t\t\t  mincost = 0;\n\t\t\t  break;\n\t\t\t}\t\t    \n\t\t    }\n\t\t  if(mincost == 0)break;\n\t\t}\n\n\t      if(mincost == 0)goto Next;\n\n\t      rep(k,5)//which node\n\t\t{\n\t\t  rep(l,5)//which segment\n\t\t    {\n\t\t      mincost = min(mincost,min(getDistanceSP(Segment(info[j][l],info[j][(l+2)%5]),info[i][k]),\n\t\t\t\t\t\tgetDistanceSP(Segment(info[j][l],info[j][(l+3)%5]),info[i][k])));\n\t\t    }\n\t\t}\n\n\t    Next:;\n\t      G[i][j] = G[j][i] = min(mincost,min(G[i][j],G[j][i]));\n\t    }\n\t}\n\n\n      rep(k,N)rep(i,N)rep(j,N)G[i][j] = min(G[i][j],\n\t\t\t\t\t    G[i][k]+G[k][j]);      \n\n      cout << setiosflags(ios::fixed) << setprecision(20) << G[M-1][L-1] << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nconst double PI=acos(-1);\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\ntypedef Line Segment;\n\nPoint Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\nbool InterLS(Line l,Segment s){\n\tPoint a=l.pos,b=l.pos+l.dir,c=s.pos,d=s.pos+s.dir;\n\treturn CCW(a,b,c)*CCW(a,b,d)<0;\n}\nbool InterSS(Segment a,Segment b){\n\treturn InterLS(a,b) && InterLS(b,a);\n}\ndouble DistLP(Line l,Point p){\n\treturn Abs(Proj(l,p)-p);\n}\ndouble DistSP(Segment s,Point p){\n\tint ccw=CCW(s.pos,s.pos+s.dir,Proj(s,p));\n\tif(ccw==-2)\n\t\treturn Abs(p-s.pos);\n\tif(ccw==2)\n\t\treturn Abs(p-(s.pos+s.dir));\n\treturn DistLP(s,p);\n}\ndouble DistLS(Line l,Segment s){\n\tif(InterLS(l,s)) return 0;\n\treturn min(DistLP(l,s.pos),DistLP(l,s.pos+s.dir));\n}\ndouble DistSS(Segment a,Segment b){\n\tif(InterSS(a,b)) return 0;\n\tdouble d1=min(DistSP(a,b.pos),DistSP(a,b.pos+b.dir));\n\tdouble d2=min(DistSP(b,a.pos),DistSP(b,a.pos+a.dir));\n\treturn min(d1,d2);\n}\n\nint main()\n{\n\tfor(int n,src,dst;scanf(\"%d%d%d\",&n,&src,&dst),n|src|dst;){\n\t\tvi xs(n),ys(n),as(n),rs(n);\n\t\trep(i,n) scanf(\"%d%d%d%d\",&xs[i],&ys[i],&as[i],&rs[i]);\n\t\t\n\t\tvvd dp(n,vd(n,INFTY));\n\t\tint counter=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tPoint p1[6],p2[6];\n\t\t\trep(k,6){\n\t\t\t\tp1[k]=Point(xs[i],ys[i])+Rot(Point(0,rs[i]),(as[i]+k*144)*PI/180);\n\t\t\t\tp2[k]=Point(xs[j],ys[j])+Rot(Point(0,rs[j]),(as[j]+k*144)*PI/180);\n\t\t\t}\n\t\t\trep(k,5) rep(l,5){\n\t\t\t\tcounter++;\n\t\t\t\tSegment s1(p1[k],p1[k+1]-p1[k]);\n\t\t\t\tSegment s2(p2[l],p2[l+1]-p2[l]);\n\t\t\t\tdp[i][j]=min(dp[i][j],DistSS(s1,s2));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tprintf(\"%.10f\\n\",dp[src-1][dst-1]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<tuple>\n#include<complex>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmin(T &l, T r) {\n    bool res = l > r;\n    if (res) {\n        l = r;\n    }\n    return res;\n}\n#define IL inline\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\ntypedef bool B;\ntypedef double D;\nconst D EPS = 1e-8;\nIL D dot(P a, P b) {\n    return a.X*b.X + a.Y*b.Y;\n}\nIL D cross(P a, P b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n     IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n\n \n \nstruct cww {\n    cww() {\n        cout << fixed;\n        cout << setprecision(10);\n    }\n}star;\n \nIL D distance_P_LS(P p, LS ls) {\n    P a, b, c = p;\n    tie(a, b) = ls;\n    if (dot(b - a, c - a) < EPS)return abs(c - a);\n    if (dot(a - b, c - b) < EPS)return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n    IL B is_LS_LS(LS p, LS q) {\n        P a, b, c, d;\n        tie(a, b) = p;\n        tie(c, d) = q;\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n \n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS)return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\nP rot(P p, double r) {\n    return P(p.X*cos(r) - p.Y*sin(r), p.X*sin(r) + p.Y*cos(r));\n}\n \nconst D PI = acos(-1);\nconst D FI = 72.0 / 180.0*PI;\ntypedef pair<double, int> pp;\nconst int ss[][2] = { {0,2},{0,3},{1,3},{1,4},{2,4} };\ntypedef priority_queue<pp, vector<pp>, greater<pp>> QUE;\nint main() {\n    int N, M, L;\n    while (cin >> N >> M >> L, N) {\n        vector<LS> ls(5*N);\n        REP(i, N) {\n            double x, y,a,r;\n            cin >> x >> y >> a >> r;\n            P p(x, y);\n            vector<P> pt(5);\n            pt[0] = rot(P(0, r), a/180.0*PI);\n            REP(i, 4)pt[i + 1] = rot(pt[i], FI);\n            REP(j, 5) {\n                ls[i * 5 + j] = LS(p+pt[ss[j][0]], p+pt[ss[j][1]]);\n            }\n        }\n        vector<vector<double>> dist(N * 5, vector<double>(N * 5));\n        REP(i, 5*N)REP(j, 5*N) {\n            if (i == j)dist[i][j] = 0;\n            else dist[i][j] = distance_LS_LS(ls[i], ls[j]);\n        }\n        int S = 5 * (M - 1);\n        int G = 5 * (L - 1);\n \n \n \n \n \n        vector<double> res(N *5, 1e18);\n        res[S] = 0;\n        QUE que;\n        que.push(pp(0,S));\n        while (que.size()) {\n            int v; double cost;\n            tie(cost,v) = que.top();\n            que.pop();\n            if (cost > res[v])continue;\n            REP(u, 5 * N) if(u!=v){\n                double ncost = cost + dist[u][v];\n                if (chmin(res[u], ncost))que.push(pp(ncost, u));\n            }\n        }\n        cout << res[G] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\ntypedef complex<double> P;\nbool operator <(const P& a, const P& b) {\n\treturn abs(a) < abs(b);\n}\n\nint N, M, L;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n\treturn imag(conj(a) * b);\n}\n\ndouble ex(P a,P b,P c){\n\treturn cross(b-a,c-a);\n}\n\nint ccw(P a, P b, P c) {\n b -= a; c -= a;\n if (cross(b, c) > DBL_EPSILON) return +1; // counter clockwise\n if (cross(b, c) < -DBL_EPSILON) return -1; // clockwise\n if (dot(b, c) < -DBL_EPSILON) return +2; // c--a--b on line\n if (norm(b) < norm(c) - DBL_EPSILON) return -2; // a--b--c on line\n return 0; // a--c--b on line (or b == c)\n}\n\nbool isIntersectSS(P a1, P a2, P b1, P b2) {\n\t return ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n\t ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\ndouble DistanceSP(P a, P b, P c) {\n\tif (dot(b - a, c - a) < DBL_EPSILON)\n\t\treturn abs(c - a);\n\tif (dot(a - b, c - b) < DBL_EPSILON)\n\t\treturn abs(c - b);\n\treturn abs(cross(b - a, c - a))/abs(a-b);\n}\ndouble DistaiceSS(P a, P b, P c, P d) {\n\tif (isIntersectSS(a, b, c, d)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(DistanceSP(a, b, c), DistanceSP(a, b, d)),\n\t\t\tmin(DistanceSP(c, d, a), DistanceSP(c, d, b)));\n}\n\nvector<vector<double> > links;\n\nstruct Star {\n\tP p;\n\tint a;\n\tint r;\n\tStar(P p, int a, int r) :\n\t\t\tp(p), a(a), r(r) {\n\t\tinitVertex();\n\t}\n\tvector<P> vertex;\nprivate:\n\tvoid initVertex() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tdouble theta = M_PI / 2 + 2 * i * M_PI / 5 + a * M_PI / 180;\n\t\t\tvertex.push_back(\n\t\t\t\t\tP(p.real() + r * cos(theta), p.imag() + r * sin(theta)));\n\t\t}\n\t}\n};\nvector<pair<int,int> > edges;\n\ndouble getLength(Star p1, Star p2) {\n\tdouble m = DBL_MAX;\n\tforeach(ea,edges){\n\t\tP a1=p1.vertex[(*ea).first];\n\t\tP a2=p1.vertex[(*ea).second];\n\t\tforeach(eb,edges){\n\t\t\tP b1=p2.vertex[(*eb).first];\n\t\t\tP b2=p2.vertex[(*eb).second];\n//\t\t\tcout<< a1<<a2<< b1<< b2 <<endl;\n//\t\t\tcout<< DistaiceSS(a1, a2, b1, b2) <<endl;\n\t\t\tm = min(m, DistaiceSS(a1, a2, b1, b2));\n\t\t}\n\n\t}\n\treturn m;\n}\nint x, y, a, r;\n\ndouble dijk(int start, int goal) {\n\tvector<double> memo(N, DBL_MAX);\n\tpriority_queue<pair<double,int> > up;\n\tup.push(make_pair(0, start));\n\tmemo[start] = 0;\n\twhile (!up.empty()) {\n\t\tdouble cost = -up.top().first;\n\t\tint pos = up.top().second;\n\n\t\tup.pop();\n\t\tif (memo[pos] < cost)\n\t\t\tcontinue;\n\t\tif (pos == goal)\n\t\t\treturn cost;\n\t\tREP0(next,N) {\n\t\t\tif (links[pos][next] >= 0) {\n\t\t\t\tdouble ncost = cost + links[pos][next];\n\t\t\t\tif (memo[next] > ncost) {\n\t\t\t\t\tmemo[next] = ncost;\n\t\t\t\t\tup.push(make_pair(-ncost, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tedges.push_back(make_pair(0,2));\n\tedges.push_back(make_pair(0,3));\n\tedges.push_back(make_pair(1,4));\n\tedges.push_back(make_pair(1,3));\n\tedges.push_back(make_pair(2,4));\n\twhile (true) {\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0 && M == 0 && L == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tlinks.clear();\n\t\tvector<Star> stars;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(Star(P(x, y), a, r));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<double> ld;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tld.push_back(i==j?0:getLength(stars[i], stars[j]));\n\t\t\t}\n\t\t\tlinks.push_back(ld);\n\t\t}\n\t\tcout << setprecision(10)<< dijk(M - 1, L - 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\nstatic const double EPS = 1e-6;\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\nint ccw(const P& a, P b, P c)\n{\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) {\n    return +1;\n  } else if (cross(b, c) < -EPS) {\n    return -1;\n  } else if (dot(b, c) < -EPS) {\n    return +2;\n  } else if (dot(b, b) + EPS < dot(c, c)) {\n    return -2;\n  } else {\n    return 0;\n  }\n}\n\nstruct segment/*{{{*/\n{\n  P a, b;\n  segment() {}\n  segment(const P& x, const P& y) : a(x), b(y) {}\n\n  // AOJ 2402 Milkey Way\n  inline bool intersects(const segment& seg) const\n  {\n    return ccw(a, b, seg.a) * ccw(a, b, seg.b) <= 0\n      && ccw(seg.a, seg.b, a) * ccw(seg.a, seg.b, b) <= 0;\n  }\n\n  // AOJ 2402 Milkey Way\n  inline double distance(const P& p) const\n  {\n    if (dot(b-a, p-a) < EPS) {\n      return abs(p-a);\n    } else if (dot(a-b, p-b) < EPS) {\n      return abs(p-b);\n    } else {\n      return abs(cross(b-a, p-a))/abs(b-a);\n    }\n  }\n\n  // AOJ 2402 Milkey Way\n  inline double distance(const segment& seg) const\n  {\n    if (intersects(seg)) {\n      return 0;\n    } else {\n      return\n        min(\n            min(distance(seg.a), distance(seg.b)),\n            min(seg.distance(a), seg.distance(b)));\n    }\n  }\n};/*}}}*/\n\nint main() {\n    while(true) {\n        int N, M, L;\n        cin >> N >> M >> L;\n        if(!N && !M && !L) break;\n\n        vector<segment> segments;\n        vector<vector<double> > dist(N*5, vector<double>(N*5, 0));\n        for(int i = 0; i < N; ++i) {\n            int x, y, a, r;\n            cin >> x >> y >> a >> r;\n            P base(x, y);\n            P pos = polar(double(r), (a+90)*M_PI/180);\n            P rot = polar(double(1), 144*M_PI/180);\n            for(int i = 0; i < 5; ++i) {\n                P next = pos*rot;\n                segments.push_back(segment(base+pos, base+next));\n                pos = next;\n            }\n        }\n        for(int i = 0; i < segments.size(); ++i) {\n            for(int j = 0; j < i; ++j) {\n                dist[i][j] = dist[j][i] = segments[i].distance(segments[j]);\n            }\n        }\n\n        M--; L--;\n        priority_queue<pair<double, int> > q;\n        q.push(make_pair(0, 5*M));\n        vector<double> memo(segments.size(), 1.0/0.0);\n        memo[5*M] = 0;\n\n        double ans = -100;\n        while(!q.empty()) {\n            double cost = -q.top().first;\n            int pos = q.top().second;\n            q.pop();\n            if(cost > memo[pos]) continue;\n            if(pos/5 == L) {\n                ans = cost;\n                break;\n            }\n\n            for(int i = 0; i < segments.size(); ++i) {\n                double nc = cost + dist[pos][i];\n                if(nc < memo[i]) {\n                    memo[i] = nc;\n                    q.push(make_pair(-nc, i));\n                }\n            }\n        }\n\n        printf(\"%.7f\\n\", fabs(ans));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\ndouble dot(P a, P b) { return (a.real() * b.real() + a.imag() * b.imag()); }\ndouble det(P a, P b) { return (a.real() * b.imag() - a.imag() * b.real()); }\n\nint n, m, l, x[100], y[100], a[100], r[100];\n\nP p[100][5];\ndouble d[100][100];\n\ndouble distanceLSP(P a, P b, P c) {\n  if (dot(b-a, c-a) < EPS) return abs(c-a);\n  if (dot(a-b, c-b) < EPS) return abs(c-b);\n  return abs(det(b-a, c-a)) / abs(b-a);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d%d\", &n, &m, &l);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &a[i], &r[i]);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 5; j++) {\n        double S = (double)(a[i] + 72 * j) * M_PI / 180;\n        p[i][j] = P(x[i] - r[i] * sin(S), y[i] + r[i] * cos(S));\n      }\n    }\n    for (int i = 0; i < n; i++) d[i][i] = 0.0;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        double temp = distanceLSP(p[i][0], p[i][2], p[j][0]);\n        for (int k = 0; k < 5; k++) {\n          for (int z = 0; z < 5; z++) {\n            temp = min(temp, distanceLSP(p[i][k], p[i][(k + 2) % 5], p[j][z]));\n            temp = min(temp, distanceLSP(p[i][k], p[i][(k + 3) % 5], p[j][z]));\n            temp = min(temp, distanceLSP(p[j][k], p[j][(k + 2) % 5], p[i][z]));\n            temp = min(temp, distanceLSP(p[j][k], p[j][(k + 3) % 5], p[i][z]));\n          }\n        }\n        d[i][j] = d[j][i] = temp;\n      }\n    }\n    for (int k = 0; k < n; k++)\n      for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    printf(\"%.9f\\n\", d[m-1][l-1]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define inf 1.0e9\n#define eps 1.0e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tdouble add(double a, double b){\n\t\tif(abs(a+b) < eps * (abs(a) + abs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, ope.x);\n\t\ttmp.y = add(y, ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator-(const vec2d& ope){\n\t\tvec2d tmp;\n\t\ttmp.x = add(x, -ope.x);\n\t\ttmp.y = add(y, -ope.y);\n\t\treturn tmp;\n\t}\n\tvec2d operator*(const double& t){\n\t\tvec2d tmp;\n\t\ttmp.x = x * t;\n\t\ttmp.y = y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(const vec2d& ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(const vec2d& ope){\n\t\treturn add(x*ope.y,  -y*ope.x);\n\t}\n};\n\n\n\nbool PonL(vec2d p, vec2d q, vec2d c)\n{\n\treturn (p-c).cross(q-c) == 0 && (p-c).dot(q-c) <= 0;\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif( (q-p).dot(c-p) < 0) return distPP(p, c);\n\tif( (p-q).dot(c-q) < 0) return distPP(q, c);\n\treturn fabs( (q-p).cross(c-p) / distPP(p, q) );\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif( (q-p).cross(s-r) == 0){\n\t\tif(PonL(p, q, r) || PonL(p, q, s) || PonL(r, s, p) || PonL(r, s, q) ) return 0.0;\n\t}\n\telse{\n\t\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\t\tvec2d c = p + (q-p) * t;\n\t\tif(PonL(p, q, c) && PonL(r, s, c)) return 0.0;\n\t}\n\t\n\tdouble ret = inf;\n\tret = min(ret, distLP(p, q, r));\n\tret = min(ret, distLP(p, q, s));\n\tret = min(ret, distLP(r, s, p));\n\tret = min(ret, distLP(r, s, q));\n\t\n\treturn ret;\n}\n\n\n\nint N, M, L; \nint x[105], y[105], a[105], r[105];\nvec2d star[105][5];\ndouble dist[105][105];\n\ndouble dijkstra()\n{\n\tdouble d[105];\n\tbool used[105];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[M] = 0;\n\t\n\tint min_i, min_d;\n\twhile(1){\n\t\tmin_d = inf;\n\t\tmin_i = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tif(min_d > d[i]){\n\t\t\t\tmin_d = d[i];\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif(min_i == -1) break;\n\t\t\n\t\tused[min_i] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i]) continue;\n\t\t\td[i] = min(d[i], d[min_i] + dist[min_i][i]);\n\t\t}\n\t}\n\t\n\treturn d[L];\n}\n\ndouble distanceStar(int S, int T)\n{\n\tdouble ret = inf;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tret = min(ret, distLL(star[S][i*2%5], star[S][(i+1)*2%5], star[T][j*2%5], star[T][(j+1)*2%5]) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif( N == 0 && M == 0 && L == 0) break;\n\t\tM--, L--;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tstar[i][j].x = x[i] + r[i] * cos( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t\tstar[i][j].y = y[i] + r[i] * sin( (j * 72 + a[i] + 90) * M_PI / 180.0 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = distanceStar(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.12f\\n\", dijkstra());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\ntypedef complex<double> PT;\ntypedef PT VC;\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b) / abs(l.fi-l.se));\n}\n\n// ??\\??????????????????????????????\n\n// ???????????´??????????????£???????????????false??????????????§??¨???\nbool has_intersec_seg_seg(SG a, SG b) {\n\tVC va, vb, vc;\n\tbool res = true;\n\tfor(int i = 0; i < 2; i++) {\n\t\tva = b.fi-a.fi; vb = b.se-a.fi; vc = a.se-a.fi;\n\t\tres = res && cross_prod(va, vc) * cross_prod(vb, vc) < EPS;\n\t\tswap(a,b);\n\t}\n\tres = res && abs(cross_prod(a.fi-a.se, b.fi-b.se)) > EPS;\n\treturn res;\n}\n\ndouble dist_pts_seg(PT p, SG a) {\n\tdouble res;\n\tres = min(abs(a.fi-p), abs(a.se-p));\n\tif(dot_prod(a.se - a.fi, p - a.fi) > -EPS\n\t\t\t&& dot_prod(a.fi - a.se, p - a.se) > -EPS)\n\t\tres = min(res, dist_pts_line(p, a));\n\treturn res;\n}\n\ndouble dist_seg_seg(SG a, SG b) {\n\tdouble res = DBL_MAX;\n\tfor(int i = 0; i < 2; i++) {\n\t\tres = min(res, min(dist_pts_seg(a.fi,b), dist_pts_seg(a.se,b)));\n\t\tswap(a,b);\n\t}\n\tif(has_intersec_seg_seg(a,b))\n\t\tres = 0;\n\treturn res;\n}\n\n/* //???????????????\nint main() {\n\tSG a(PT(0,0),PT(0,2));\n\tSG b(PT(-1,1),PT(2,1));\n\tcout << dist_seg_seg(a,b) << endl;\n} // */\n\n//*\nint N, M, L;\nvector<vector<SG> > star;\ndouble edge[120][120];\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nvoid init() {\n\tstar.clear();\n\trep(i,120) {\n\t\trep(j,120)\n\t\t\tedge[i][j] = 1e9;\n\t\tedge[i][i] = 0;\n\t}\n}\n\nint main() {\n\twhile(cin >> N >> M >> L, N || M || L) {\n\t\tinit();\n\t\tM--; L--;\n\t\trep(i,N) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tvector<PT> tmp;\n\t\t\tdouble theta = (a+90) / 180.0 * M_PI;\n\t\t\tdouble phi = 360.0 / 5.0 / 180.0 * M_PI;\n\t\t\trep(i,5) {\n\t\t\t\ttmp.push_back(polar((double)r, theta + phi * i) + PT(x,y));\n\t\t\t//\tcout << tmp[i] << endl;\n\t\t\t}\n\t\t\tvector<SG> push;\n\t\t\trep(i,5) {\n\t\t\t\tpush.push_back(SG(tmp[i],tmp[(i+2)%5]));\n\t\t\t}\n\t\t\tstar.push_back(push);\n\t\t}\n\n\t\trep(i,N) {\n\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\tdouble tmp = 1e9;\n\t\t\t\trep(k,5) {\n\t\t\t\t\trep(l, 5) {\n\t\t\t\t\t\ttmp = min(tmp, dist_seg_seg(star[i][k], star[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\trep(i,N) {\n\t\t\trep(j,N) {\n\t\t\t\trep(k,N) {\n\t\t\t\t\tedge[j][k] = min(edge[j][k], edge[j][i] + edge[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", edge[L][M]);\n\t}\n}\n// */"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\nconst double PI=atan(1.0)*4;\nint N,M,L;\ndouble xs[101];\ndouble ys[101];\ndouble as[101];\ndouble rs[101];\nP starP[101][101];\npair<P,P> starEdges[101][101];\nstruct edge{\n\tint to;\n\tdouble cost;\n};\nvector<edge>G[10001];\nP roundPoint(P p,double a){\n\treturn P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\ndouble dot(P a,P b){\n\treturn (a.real()*b.real()+a.imag()*b.imag());\n}\ndouble cross(P a,P b){\n\treturn (a.real()*b.imag()-a.imag()*b.real());\n}\ndouble distance_ls_p(P a,P b,P c){\n\tif(dot(b-a,c-a)<EPS)return abs(c-a);\n\tif(dot(a-b,c-b)<EPS)return abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);\n}\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n\tif(abs(cross(a2-a1,b2-b1)<EPS))return false;\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS)&&\n\t\t(cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS);\n}\ntypedef pair<double,pii> pdi;\ndouble d[101][101];\nconst double INF=(1LL<<30);\ndouble dijkstra(){\n\tpriority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n\tfor(int i=0;i<101;i++)\n\t\tfor(int j=0;j<101;j++)\n\t\t\td[i][j]=INF;\n\tfor(int i=0;i<5;i++){\n\t\td[M][i]=0;\n\t\tpq.push(pdi(0,pii(M,i)));\n\t}\n\twhile(pq.size()){\n\t\tpdi p=pq.top();pq.pop();\n\t\tdouble ccost=p.first;\n\t\tint cnode=p.second.first;\n\t\tint cedge=p.second.second;\n\t\tif(!EQ(d[cnode][cedge],ccost)&&d[cnode][cedge]<ccost)continue;\n\t\tfor(int i=0;i<G[cnode*5+cedge].size();i++){\n\t\t\tedge &e=G[cnode*5+cedge][i];\n\t\t\tint tnode=(e.to)/5;\n\t\t\tint tedge=(e.to)%5;\n\t\t\tif(!EQ(d[tnode][tedge],ccost+e.cost)&&d[tnode][tedge]>ccost+e.cost){\n\t\t\t\td[tnode][tedge]=ccost+e.cost;\n\t\t\t\tpq.push(pdi(d[tnode][tedge],pii(tnode,tedge)));\n\t\t\t}\n\t\t}\n\t}\n\tdouble res=INF;\n\tfor(int i=0;i<5;i++){\n\t\tres=min(res,d[L][i]);\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\twhile(cin>>N>>M>>L&&(N|M|L)){\n\t\tM--;L--;\n\t\tfor(int i=0;i<10001;i++)\n\t\t\tG[i].clear();\n\t\tfor(int i=0;i<N;i++)\n\t\t\tcin>>xs[i]>>ys[i]>>as[i]>>rs[i];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tedge e;\n\t\t\t\te.cost=0;\n\t\t\t\tint from=i*5+j;\n\t\t\t\tint to=i*5+(j+1);\n\t\t\t\te.to=to;\n\t\t\t\tG[from].push_back(e);\n\t\t\t\te.to=from;\n\t\t\t\tG[to].push_back(e);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tP cp=P(xs[i],ys[i]);\n\t\t\tP up=P(xs[i],ys[i]+rs[i]);\n\t\t\tP base=P(0,rs[i]);\n\t\t\tP roundP=roundPoint(base,(1.0*as[i]/180)*PI);\n\t\t\tstarP[i][0]=roundP+cp;\n\t\t\tfor(int j=1;j<5;j++){\n\t\t\t\troundP=roundPoint(roundP,(72.0/180)*PI);\n\t\t\t\tstarP[i][j]=roundP+cp;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tstarEdges[i][j]=make_pair(starP[i][j],starP[i][(j+1)%5]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\t\tpair<P,P> &e1=starEdges[i][j];\n\t\t\t\t\t\tpair<P,P> &e2=starEdges[k][l];\n\t\t\t\t\t\t// クロスしてる場合\n\t\t\t\t\t\tif(is_intersected_ls(e1.first,e1.second,e2.first,e2.second)){\n\t\t\t\t\t\t\tint from=i*5+j;\n\t\t\t\t\t\t\tint to=k*5+l;\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=0;\n\t\t\t\t\t\t\te.to=to;\n\t\t\t\t\t\t\tG[from].push_back(e);\n\t\t\t\t\t\t\te.to=from;\n\t\t\t\t\t\t\tG[to].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//e1.first\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble dist=distance_ls_p(e2.first,e2.second,e1.first);\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=dist;\n\t\t\t\t\t\t\te.to=k*5+l;\n\t\t\t\t\t\t\tint from=i*5+j;\n\t\t\t\t\t\t\tint to=k*5+l;\n\t\t\t\t\t\t\tG[from].push_back(e);\n\t\t\t\t\t\t\te.to=from;\n\t\t\t\t\t\t\tG[to].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// e1.second\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble dist=distance_ls_p(e2.first,e2.second,e1.second);\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=dist;\n\t\t\t\t\t\t\te.to=k*5+l;\n\t\t\t\t\t\t\tint from=i*5+j;\n\t\t\t\t\t\t\tint to=k*5+l;\n\t\t\t\t\t\t\tG[from].push_back(e);\n\t\t\t\t\t\t\te.to=from;\n\t\t\t\t\t\t\tG[to].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=dijkstra();\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n}\nint main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-10;\ndouble add(double a,double b){\n    if(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\n\nconst double pi=acos(-1);\nint main(){\n    int n,m,l;\n    while(cin>>n>>m>>l){\n        if(n==0)break;\n        P x[n][5];\n        rep(i,n){\n            P c;\n            cin>>c.first>>c.second;\n            double a,b;\n            cin>>a>>b;\n            a*=pi/180;\n            rep(j,5){\n                P y;\n                y={-sin(a+2.0/5.0*j*pi),cos(a+2.0/5.0*j*pi)};\n                x[i][j]=c+y*b;\n            }\n        }\n        double d[n][n];\n        rep(i,n)rep(j,n)d[i][j]=inf;\n        rep(i,n)d[i][i]=0;\n        rep(i,n)rep(j,n){\n            if(i==j)continue;\n            rep(k,5)rep(l,5){\n                d[i][j]=min(d[i][j],dist(x[i][k],x[i][(k+2)%5],x[j][l]));\n                if(cross(x[i][k],x[i][(k+2)%5],x[j][l],x[j][(l+2)%5]))d[i][j]=0;\n            }\n        }\n        rep(i,n)rep(j,n)rep(k,n)d[j][k]=min(d[j][k],d[i][j]+d[i][k]);\n        cout<<fixed<<setprecision(12)<<d[m-1][l-1]<<endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \nint N,M,L;\n  \n \nconst double EPS (1e-10);\nconst double PI=acos(-1.0);\n \ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n \nP pt[101][5];\ndouble dp[101][101];\n \ndouble get_min(int m,int n){\n    if(m==n) return 0;\n    double mn = INT_MAX;\n    static int idx[] = {0,2,4,1,3,0};\n    for (int i = 0; i < 5; i++){\n        S s = S(pt[n][idx[i]],pt[n][idx[i + 1]]);\n        for (int j = 0; j < 5; j++){\n            S t = S(pt[m][idx[j]],pt[m][idx[j + 1]]);\n            mn = min(mn,dist(s,t));\n        }\n    }\n    return mn;\n}\n  \nint main()\n{\n    while(cin>>N>>M>>L,(N||M||L)){\n        for (int i = 0; i < N; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n  \n        for(int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                dp[i][j] = get_min(i,j);\n  \n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++)\n                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n  \n        printf(\"%.20lf\\n\",dp[M - 1][L - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    void operator+=(const point &a){x += a.x; y += a.y;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    void operator-=(const point &a){x -= a.x; y -= a.y;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point operator*=(const double a)const{ x *= a; y *= a; }\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point operator/=(const double a)const{ x /= a; y /= a; }\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n\n\ntypedef point<double> P;\ntypedef segment<double> S;\n\n\nint main(){\n    for(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n||m||l;){\n\t\tP pt[100][5];\n\t\tfor (int i = 0; i <n; i++){\n            double x,y,a,r;cin>>x>>y>>a>>r;\n            for (int j = 0; j < 5; j++){\n                double alpha = (18 + a + 72 * j)/ 180.0 * PI;\n                pt[i][j] = P(x,y) + rot(P(r,0.0),alpha);\n            }\n        }\n   \n        int f1[]={0,2,4,1,3,0};\n        double d[100][100];\n        for(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n                d[i][j] = 1e100;\n                 for(int a = 0; a < 5; a++)  for(int b = 0; b < 5; b++){\n                    S s(pt[i][f1[a]],pt[i][f1[a+1]]);\n                    S t(pt[j][f1[b]],pt[j][f1[b+1]]);\n                    d[i][j]=min(d[i][j],dist(s,t));\n                }\n            }\n        }\n   \n        for (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n   \n        printf(\"%.15f\\n\",d[m - 1][l - 1]);\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e10\n#define EPS (1e-10)    //誤差\ntypedef complex<double> P;\n\nstruct star{\n    P point[5];    \n};\n\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n\n//内積#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e10\n#define EPS (1e-10)    //誤差\ntypedef complex<double> P;\n\nstruct star{\n    P point[5];    \n};\n\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n\n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n\n\nstar ch(double x, double y, double a, double r){\n    \n    star res;\n    res.point[0] = P(0, r);    \n    \n    //a度左に回転\n    res.point[0] *= exp(P(0.0, a*M_PI/180.0));\n\n    //P(cos(), sin())\n\n    //72度回転　→　回収を五回繰り返す\n    for(int i = 1; i < 5; i++){\n        res.point[i] = res.point[i - 1] * exp(P(0.0, 2.0*M_PI/5.0));        \n    }\n\n    for(int i = 0; i < 5; i++){\n        res.point[i] += P(x, y);        \n    }\n\n    return res;\n}\n\ndouble Distance(P p11, P p12, P p21, P p22){\n\n    if(is_intersected_ls(p11, p12, p21, p22)) return 0.0;\n    double ans = INF;\n    ans = min(ans, distance_ls_p(p11, p12, p21));\n    ans = min(ans, distance_ls_p(p11, p12, p22));\n    ans = min(ans, distance_ls_p(p21, p22, p11));\n    ans = min(ans, distance_ls_p(p21, p22, p12));\n    return ans;\n}\n\n//星間の距離を返す\ndouble make_dis(star st1, star st2){\n    \n    double res = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            P p11, p12, p21, p22;\n            p11 = st1.point[i];\n            p12 = st1.point[(i + 2) % 5];\n\n            p21= st2.point[j];\n            p22 = st2.point[(j + 2) % 5];\n            res = min(res, Distance(p11, p12, p21, p22));\n        }\n    }\n\n    return res;\n}\n\n//幾何入門\nint main(){\n    \n    while(1){\n\n        int n, m, l; cin >> n >> m >> l;\n        if(!n) break;\n        m--;\n        l--;\n\n        //星の構造体\n        vector<star> st(n);\n\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            //入力から星の構造体を返す\n            st[i] = ch(x, y, a, r);\n        }\n\n        vector<vector<double> > dis(n, vector<double> (n, INF));\n\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                if(i == j) dis[i][j] = dis[j][i] = 0.0;\n                else dis[i][j] = dis[j][i] = make_dis(st[i], st[j]);\n            }\n        }\n\n        //ワーシャルフロイド\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n                }\n            }\n        }\n\n        /*for(int i = 0; i < n; i++){\n            cerr << \"star \" << i << endl;\n            for(int j = 0; j < 5; j++){\n                cerr << st[i].point[j].real() << \" \" << st[i].point[j].imag() << endl;\n            }\n        }*/\n\n        printf(\"%.10f\\n\", dis[m][l]);\n\n    }\n\n    return 0;\n}\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n\n\nstar ch(double x, double y, double a, double r){\n    \n    star res;\n    res.point[0] = P(0, r);    \n    \n    //a度左に回転\n    res.point[0] *= exp(P(0.0, a*M_PI/180.0));\n\n    //P(cos(), sin())\n\n    //72度回転　→　回収を五回繰り返す\n    for(int i = 1; i < 5; i++){\n        res.point[i] = res.point[i - 1] * exp(P(0.0, 2.0*M_PI/5.0));        \n    }\n\n    for(int i = 0; i < 5; i++){\n        res.point[i] += P(x, y);        \n    }\n\n    return res;\n}\n\n//星間の距離を返す\ndouble make_dis(star st1, star st2){\n    \n    double res = INF;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            P p11, p12, p21, p22;\n            p11.real() = st1.point[i].real();\n            p11.imag() = st1.point[i].imag();\n            p12.real() = st1.point[(i + 2) % 5].real();\n            p12.imag() = st1.point[(i + 2) % 5].imag();\n\n            p21.real() = st2.point[i].real();\n            p21.imag() = st2.point[i].imag();\n            p22.real() = st2.point[(i + 2) % 5].real();\n            p22.imag() = st2.point[(i + 2) % 5].imag();\n\n\n            double ans = 1e10;\n            ans = min(ans, distance_ls_p(p11, p12, p21));\n            ans = min(ans, distance_ls_p(p11, p12, p22));\n            ans = min(ans, distance_ls_p(p21, p22, p11));\n            ans = min(ans, distance_ls_p(p21, p22, p12));\n            if(is_intersected_ls(p11, p12, p21, p22)) ans = 0.0;\n            res = min(res, ans);\n        }\n    }\n\n    return res;\n}\n\n//幾何入門\nint main(){\n    \n    while(1){\n\n        int n, m, l; cin >> n >> m >> l;\n        if(!n) break;\n        m--;\n        l--;\n\n        //星の構造体\n        vector<star> st(n);\n\n        for(int i = 0; i < n; i++){\n            double x, y, a, r; cin >> x >> y >> a >> r;\n            //入力から星の構造体を返す\n            st[i] = ch(x, y, a, r);\n        }\n\n        vector<vector<double> > dis(n, vector<double> (n, INF));\n\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                if(i == j) dis[i][j] = dis[j][i] = 0.0;\n                else dis[i][j] = dis[j][i] = make_dis(st[i], st[j]);\n            }\n        }\n\n        //ワーシャルフロイド\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n                }\n            }\n        }\n\n        /*for(int i = 0; i < n; i++){\n            cerr << \"star \" << i << endl;\n            for(int j = 0; j < 5; j++){\n                cerr << st[i].point[j].real() << \" \" << st[i].point[j].imag() << endl;\n            }\n        }*/\n\n        printf(\"%.10f\\n\", dis[m][l]);\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return a * (a.dot(b) / a.length()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn contains(a, b.p) || contains(a, b.p + b.d)\n\t\t|| contains(b, a.p) || contains(b, a.p + a.d);\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) { return min(getDistance(perpendicular_foot(a, (Line)b), a), min(getDistance(b.p, a), getDistance(b.p + b.d, a))); }\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b) { return isCross(a, b) ? 0 : min(min(getDistance(a.p, b.p), getDistance(a.p, b.p + b.d)), min(getDistance(a.p + a.d, b.p), getDistance(a.p + a.d, b.p + b.d))); }\n\n// a から ta, bから tb だけ離れた点。ta=tb=r なら aとbに内接する円\ninline pair<pair<P2, P2>, pair<P2, P2>> get_distance_points(Line a, double ta, Line b, double tb)\n{\n\tassert(isCross(a, b));\n\n\tP2 va = a.d.orthogonal().direction() * ta;\n\tP2 vb = b.d.orthogonal().direction() * tb;\n\treturn make_pair(\n\t\tmake_pair(\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p - vb, b.d))\n\t\t), make_pair(\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p - vb, b.d))\n\t\t));\n}\n\n/// 円\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\n/// 長方形\nstruct Rect\n{\n\tP2 l, s;\n\tRect() : l(), s() { }\n\tRect(double x, double y, double w, double h) : l(x, y), s(w, h) { }\n\tRect(P2 location, P2 size) : l(location), s(size) { }\n\tbool Contains(const P2 &p) const { return p.x - l.x > -EPS && p.y - l.y > -EPS && p.x - (l.x + s.x) < EPS && p.y - (l.y + s.y) < EPS; } // 接してても真。\n};\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n#define M_PI       3.14159265358979323846\n// Milky Way\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tif (!N) { break; }\n\n\t\tvevector<LineSeg> segs(N);\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(int, x, y, a, r);\n\t\t\tREP(i, 5)\n\t\t\t{\n\t\t\t\tint j = i + 1;\n\t\t\t\tdouble ai = (i * 144 + 90 + a) % 360 * M_PI / 180.0;\n\t\t\t\tdouble aj = (j * 144 + 90 + a) % 360 * M_PI / 180.0;\n\t\t\t\tP2 center(x, y);\n\t\t\t\tP2 pi = center + P2(cos(ai), sin(ai)).direction() * r;\n\t\t\t\tP2 pj = center + P2(cos(aj), sin(aj)).direction() * r;\n\t\t\t\tLineSeg s = LineSeg::From2Point(pi, pj);\n\t\t\t\tsegs[_].push_back(s);\n\n\t\t\t\t//WRITE(s.p, s.d);\n\t\t\t}\n\t\t}\n\n\t\tvevector<Path<double>> graph(N);\n\t\tREP(i, N) REP(j, N)\n\t\t{\n\t\t\tdouble d = INF;\n\t\t\tREP(k, 5) REP(l, 5) d = min(d, getDistance(segs[i][k], segs[j][l]));\n\t\t\tgraph[i].push_back({ i, j, d });\n\t\t}\n\n\t\tprintf(\"%.16f\\n\", dijkstra(graph, L - 1, -1).first[M - 1]);\n\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-10;\ndouble add(double a,double b){\n    if(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\n\nconst double pi=acos(-1);\nint main(){\n    int n,s,t;\n    vector<double> ans;\n    while(cin>>n>>s>>t){\n        if(n==0)break;\n        P x[n][5];\n        rep(i,n){\n            P c;\n            cin>>c.first>>c.second;\n            double a,b;\n            cin>>a>>b;\n            a*=pi/180;\n            rep(j,5){\n                P y;\n                y={-sin(a+2.0/5.0*j*pi),cos(a+2.0/5.0*j*pi)};\n                x[i][j]=c+y*b;\n            }\n        }\n        double d[n][n];\n        rep(i,n)rep(j,n)d[i][j]=inf;\n        rep(i,n)d[i][i]=0;\n        rep(i,n)rep(j,n){\n            if(i==j)continue;\n            rep(k,5)rep(l,5){\n                d[i][j]=min(d[i][j],dist(x[i][k],x[i][(k+2)%5],x[j][l]));\n                if(cross(x[i][k],x[i][(k+2)%5],x[j][l],x[j][(l+2)%5]))d[i][j]=0;\n            }\n        }\n        rep(i,n)rep(j,n)d[i][j]=min(d[i][j],d[j][i]);\n        rep(i,n)rep(j,n)rep(k,n)d[j][k]=min(d[j][k],d[i][j]+d[i][k]);\n        cout<<fixed<<setprecision(12)<<d[s-1][t-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cmath>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<29)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<Point> vp;\ntypedef vector<vp> vvp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\n\n\nint N,M,L;\n\nint main()\n{\n  while(cin >> N >> M >> L,N|M|L)\n    {\n      vvp info(N);\n      vvd G(N,vd(N));\n      rep(i,N)rep(j,N)G[i][j] = (i==j?0:inf);\n\n      rep(i,N)\n\t{\n\t  double x,y,a,r;\n\t  cin >> x >> y >> a >> r;\n\t  rep(j,5)\n\t    {\n\t      Point p = Point(0,r);\n\t      p = rotate(p,toRad(a+72*j));\n\t      info[i].push_back(Point(p.x+x,p.y+y));\n\t    }\n\t}\n\n      rep(i,N)//from\n\t{\n\t  REP(j,i+1,N)//to\n\t    {\n\t      double mincost = inf;\n\n\t      rep(k,5)\n\t\t{\n\t\t  rep(l,5)\n\t\t    {\n\t\t      if(isIntersect(Segment(info[i][k],info[i][(k+2)%5]),Segment(info[j][l],info[j][(l+2)%5])) || isIntersect(Segment(info[i][k],info[i][(k+2)%5]),Segment(info[j][l],info[j][(l+3)%5])))\n\t\t\t{\n\t\t\t  mincost = 0;\n\t\t\t  break;\n\t\t\t}\t\t    \n\t\t      if(isIntersect(Segment(info[i][k],info[i][(k+3)%5]),Segment(info[j][l],info[j][(l+2)%5])) || isIntersect(Segment(info[i][k],info[i][(k+3)%5]),Segment(info[j][l],info[j][(l+3)%5])))\n\t\t\t{\n\t\t\t  mincost = 0;\n\t\t\t  break;\n\t\t\t}\t\t    \n\t\t    }\n\t\t  if(mincost == 0)break;\n\t\t}\n\n\t      if(mincost == 0)goto Next;\n\n\t      rep(k,5)//which node\n\t\t{\n\t\t  rep(l,5)//which segment\n\t\t    {\n\t\t      mincost = min(mincost,min(getDistanceSP(Segment(info[j][l],info[j][(l+2)%5]),info[i][k]),\n\t\t\t\t\t\tgetDistanceSP(Segment(info[j][l],info[j][(l+3)%5]),info[i][k])));\n\t\t    }\n\t\t}\n\n\t    Next:;\n\t      G[i][j] = G[j][i] = mincost;\n\t    }\n\t}\n\n\n      rep(k,N)rep(i,N)rep(j,N)G[i][j] = min(G[i][j],\n\t\t\t\t\t    G[i][k]+G[k][j]);      \n\n      cout << setiosflags(ios::fixed) << setprecision(10) << G[M-1][L-1] << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn s.a + (s.b - s.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\nconst double alpha = 72.0 / 180.0 * M_PI;\nstruct star {\n\tvector<segment> seg;\n\tstar(int x, int y, int a, int r) {\n\t\tvector<point> points;\n\t\tpoints.push_back(rotate(point(0, r), a / 180.0 * M_PI));\n\t\tfor(int i = 1; i < 5; ++i)\n\t\t\tpoints.push_back(rotate(points[i - 1], alpha));\n\n\t\tconst point margin(x, y);\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tpoints[i] = points[i] + margin;\n\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tseg.push_back(segment(points[i], points[(i + 2) % 5]));\n\t}\n};\n\nconst double INF = 10000.0;\n\ndouble dist(const star& s, const star& t) {\n\tdouble res = INF;\n\tfor(int i = 0; i < 5; ++i)\n\t\tfor(int j = 0; j < 5; ++j)\n\t\t\tchmin(res, dist(s.seg[i], t.seg[i]));\n\n\treturn res;\n}\n\nint n;\ndouble mat[100][100];\ndouble dijkstra(const int s, const int t) {\n\tvector<double> d(n, INF);\n\tvector<bool> used(n, false);\n\td[s] = 0;\n\n\tfor(;;) {\n\t\tint v = -1;\n\t\tfor(int u = 0; u < n; ++u)\n\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))\n\t\t\t\tv = u;\n\n\t\tif(v == t)\n\t\t\treturn d[t];\n\n\t\tused[v] = true;\n\t\tfor(int u = 0; u < n; ++u)\n\t\t\tchmin(d[u], d[v] + mat[v][u]);\n\t}\n}\n\n\nint main() {\n\tfor(int m, l; scanf(\"%d %d %d\", &n, &m, &l), n;) {\n\t\t--m; --l;\n\t\tvector<star> stars;\n\t\tstars.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y, a, r;\n\t\t\tcin >> x >> y >> a >> r;\n\t\t\tstars.push_back(star(x, y, a, r));\n\t\t}\n\n\t\tmemset(mat, 0, sizeof(mat));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst double d = dist(stars[i], stars[j]);\n\t\t\t\tmat[i][j] = mat[j][i] = d;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.20lf\\n\", dijkstra(m, l));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const double PI = acos(-1.0);\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nstruct segment\n{\n  P a, b;\n  segment() {}\n  segment(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool intersects(const segment& seg) const\n  {\n    return\n      max(a.real(), b.real()) >= min(seg.a.real(), seg.b.real())\n      && max(seg.a.real(), seg.b.real()) >= min(a.real(), b.real())\n      && max(a.imag(), b.imag()) >= min(seg.a.imag(), seg.b.imag())\n      && max(seg.a.imag(), seg.b.imag()) >= min(a.imag(), b.imag())\n      && cross(seg.b - seg.a, a - seg.a) * cross(seg.b - seg.b, b - seg.a) <= EPS\n      && cross(b - a, seg.a - a) * cross(b - a, seg.b - a) <= EPS;\n  }\n\n  inline double distance(const P& p) const\n  {\n    if (dot(b-a, p-a) < EPS) {\n      return abs(p-a);\n    } else if (dot(a-b, p-b) < EPS) {\n      return abs(p-b);\n    } else {\n      return abs(cross(b-a, p-a))/abs(b-a);\n    }\n  }\n\n  inline double distance(const segment& seg) const\n  {\n    if (intersects(seg)) {\n      return 0;\n    } else {\n      return\n        min(\n            min(distance(seg.a), distance(seg.b)),\n            min(seg.distance(a), seg.distance(b)));\n    }\n  }\n};\n\nstruct star\n{\n  segment segs[5];\n  star(double x, double y, double a, double r) {\n    P o(x, y);\n    P p(x, y + r);\n    p -= o;\n    P n = polar(1.0, a/180.0*PI);\n    p *= n;\n    P m = polar(1.0, 72.0/180.0*PI);\n    P ps[5];\n    for (int i = 0; i < 5; i++) {\n      ps[i] = o + p;\n      //fprintf(stderr, \"ps[%d] = (%g,%g)\\n\", i, ps[i].real(), ps[i].imag());\n      p *= m;\n    }\n    //fprintf(stderr, \"  => p = (%g,%g)\\n\", p.real(), p.imag());\n    for (int i = 0, j = 0; i < 5; i++) {\n      segs[i] = segment(ps[j], ps[(j+2) % 5]);\n      //fprintf(stderr, \"seg[%d] = (%g,%g) - (%g,%g)\\n\", i, segs[i].a.real(), segs[i].a.imag(), segs[i].b.real(), segs[i].b.imag());\n      j = (j+2) % 5;\n    }\n  }\n\n  double distance(const star& s) const\n  {\n    double ans = 1e10;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (segs[i].intersects(s.segs[j])) {\n          //fprintf(stderr, \"intersects!\\n\");\n          return 0.0;\n        }\n        //fprintf(stderr, \"seg[%d] - seg[%d]\\n\", i, j);\n        ans = min(ans, segs[i].distance(s.segs[j]));\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF && N != 0) {\n    --M; --L;\n    vector<star> stars;\n    for (int i = 0; i < N; i++) {\n      int x, y, a, r;\n      scanf(\"%d %d %d %d\", &x, &y, &a, &r);\n      stars.push_back(star(x, y, a, r));\n    }\n\n    vector<vector<double> > g(N, vector<double>(N));\n    for (int i = 0; i < N; i++) {\n      for (int j = i+1; j < N; j++) {\n        double d = stars[i].distance(stars[j]);\n        g[i][j] = g[j][i] = d;\n        //fprintf(stderr, \"%d - %d: %g\\n\", i, j, d);\n      }\n    }\n    priority_queue<pair<double,int> > q;\n    vector<double> dist(N, 1e10);\n    dist[M] = 0;\n    q.push(make_pair(0.0, M));\n    while (!q.empty()) {\n      const double d = -q.top().first;\n      const int n = q.top().second;\n      q.pop();\n      //fprintf(stderr, \"from n=%d\\n\", n);\n      if (n == L) {\n        printf(\"%.7f\\n\", fabs(d));\n        break;\n      }\n      for (int i = 0; i < N; i++) {\n        if (n == i) {\n          continue;\n        }\n        const double dd = d + g[n][i];\n        if (dd < dist[i]) {\n          //fprintf(stderr, \"  goto n=%d\\n\", i);\n          dist[i] = dd;\n          q.push(make_pair(-dd, i));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nbool intersectSP(const line_t &s, const xy_t &p) {\n  return abs(s.first - p) + abs(s.second - p) - abs(direction(s)) < EPS;\n}\n\nbool intersectSS(const line_t &s, const line_t &t) {\n  return ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n         ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\nxy_t projection(const line_t &l, const xy_t &p) {\n  double t = dot(p - l.first, direction(l)) / norm(direction(l));\n  return l.first + t*(direction(l));\n}\n\ndouble distanceSP(const line_t &s, const xy_t &p) {\n  const xy_t r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.first - p), abs(s.second - p));\n}\n\ndouble distanceSS(const line_t &s, const line_t &t) {\n  if (intersectSS(s, t)) return 0;\n  \n  return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nstruct star {\n  int x, y, a, r;\n  \n  vector<xy_t> points() const {\n    vector<xy_t> ps;\n    xy_t   center = xy_t(x, y);\n    double theta  = (double)a / 180 * M_PI + M_PI / 2;\n    REP(i, 5) {\n      ps.push_back(center + polar((double)r, theta + M_PI * i * 2 / 5));\n    }\n    return ps;\n  }\n  \n  vector<line_t> segments() const {\n    vector<xy_t>   ps = this->points();\n    vector<line_t> res;\n\n    REP(i, ps.size()) REP(j, i){\n      res.push_back(line_t(ps[j], ps[i]));\n    }\n    return res;\n  }\n};\n\ndouble distance(const star &s, const star &t){\n  vector<line_t> seg_ss = s.segments();\n  vector<line_t> seg_ts = t.segments();\n  double res = 1e9;\n\n  for (line_t seg_s : seg_ss){\n    for (line_t seg_t : seg_ts){\n      res = min(res, distanceSS(seg_s, seg_t));\n    }\n  }\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, L;\n  while (cin >> N >> M >> L && N + M + L){\n    vector<star> stars(N);\n    vector<vector<double> > dist(N, vector<double>(N));\n    REP(i, N){\n      cin >> stars[i].x >> stars[i].y >> stars[i].a >> stars[i].r;\n    }\n\n    REP(i, N) REP(j, N){\n      dist[i][j] = distance(stars[i], stars[j]);\n    }\n\n    REP(k, N) REP(i, N) REP(j, N){\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n    printf(\"%.20lf\\n\", dist[L - 1][M - 1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<complex>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef pair<double,int> PD;\ntypedef complex<double> P;\n\nconst double PI = acos(-1);\nP p[110][5];\nint n,m,l;\ndouble x[110],y[110],z[110],r[110];\nvector<PD> g[110];\ndouble d[110];\nconst P rotation = P(cos(72*PI/180),sin(72*PI/180) );\n\ndouble dot(P a,P b){return (a.real()*b.real() + a.imag() * b.imag());}\ndouble cross(P a,P b){return (a.real() * b.imag() - a.imag()*b.real());}\n\nbool is_intersect(P a1,P a2, P b1,P b2){\n  return (cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS)\n    && (cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1)<EPS );\n}\n\ndouble seg_dis(P a,P b,P c){\n  if(dot(b-a,c-a)<EPS)return abs(c-a);\n  if(dot(a-b,c-b)<EPS)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\ndouble star_dis(int n1, int n2){\n  double dis = 1e9;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      double tmp = seg_dis(p[n1][i],p[n1][(i+2)%5],p[n2][j]);\n      //cout << tmp << \" \"<< n1 << \" \" << n2 << \" \" << i << \" \" << j <<endl;\n      dis = min(dis,tmp);\n    }\n  }\n  return dis;\n}\n\nvoid make_star(void){\n  for(int i=0;i<n;i++){\n    p[i][0] = P(-r[i]*sin(z[i]*PI/180),r[i]*cos(z[i]*PI/180));\n    for(int j=1;j<5;j++){\n      p[i][j] = p[i][j-1] * rotation;\n    }\n    for(int j=0;j<5;j++){\n      p[i][j] += P(x[i],y[i]);\n    }\n  }\n}\n\nvoid make_graph(void){\n  make_star();\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      bool f = false;\n      for(int k1=0;k1<5;k1++){\n\tfor(int k2=0;k2<5;k2++){\n\t  f |= is_intersect(p[i][k1],p[i][(k1*2)%5],p[j][k2],p[j][(k2+2)%5]);\n\t  if(f)break;\n\t}\n      }\n      if(f){\n\tg[i].push_back(PD(0.0,j));\n\tg[j].push_back(PD(0.0,i));\n      }else{\n\tdouble star = min(star_dis(i,j), star_dis(j,i));\n\tg[i].push_back(PD(star,j));\n\tg[j].push_back(PD(star,i));\n      }\n    }\n  }\n}\n\nint main(){\n  \n  while(cin >> n >> m >> l , (n||m||l)){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    for(int i=0;i<n;i++)g[i].clear();\n    make_graph();\n    /*\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)g[i].size();j++){\n\tcout << g[i][j].second << \" \" <<  g[i][j].first << endl;\n      }\n    }\n    */\n    /*\n    for(int i=0;i<n;i++){\n      cout << i << endl;\n      for(int j=0;j<5;j++)cout << p[i][j].real() << \" \" << p[i][j].imag()<<endl;\n    }\n    */\n\n    for(int i=0;i<n;i++)d[i] = 1e9;\n    d[m-1] = 0.0;\n    priority_queue<PD,vector<PD>,greater<PD> > q;\n    q.push(PD(0.0,m-1));\n    \n    while(q.size()){\n      PD p = q.top(); q.pop();\n      double cost = p.first;\n      int pos = p.second;\n     \n      if(p.second == l-1)break;\n\n      for(int i=0;i<g[pos].size();i++){\n\tdouble dis = cost + g[pos][i].first;\n\tint next = g[pos][i].second;\n\n\tif(dis + EPS < d[next]){\n\t  d[next] = dis;\n\t  q.push(PD(dis,next));\n\t}\n      }\n    }\n    printf(\"%.8lf\\n\",d[l-1]);\n  }\n}\n    "
  },
  {
    "language": "C",
    "code": "// AOJ 2402: Milky Way\n// 2017.11.20 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 10000\ntypedef struct { int node; double t; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int n, double t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 1e10\n#define EPS 1e-9\n#define EQ(a, b) (fabs(a-b)<=EPS)\n\nint ppOnSeg(double x, double y, double x1, double y1, double x2, double y2)\n{\n    double d;\n    if (x1 > x2) d = x1, x1 = x2, x2 = d;\n    if (y1 > y2) d = y1, y1 = y2, y2 = d;\n    return (EQ(x1, x) || x1 <= x) && (EQ(x, x2) || x <= x2) &&\n\t\t   (EQ(y1, y) || y1 <= y) && (EQ(y, y2) || y <= y2) &&\n           EQ((y-y1)*(x2-x1), (y2-y1)*(x-x1));\n}\n\nint isCrossSeg(double x11, double y11, double x12, double y12,\n             double x21, double y21, double x22, double y22)\n{\n    double s11, s12, s21, s22;\n    int r = 0;\n\n    s11 = (x22-x21) * (y11-y21) + (y22-y21) * (x21-x11);\n    s12 = (x22-x21) * (y12-y21) + (y22-y21) * (x21-x12);\n    s21 = (x12-x11) * (y21-y11) + (y12-y11) * (x11-x21);\n    s22 = (x12-x11) * (y22-y11) + (y12-y11) * (x11-x22);\n\tif (EQ(s11, 0)) { if (!r) r = ppOnSeg(x11, y11, x21, y21, x22, y22); }\n    if (EQ(s12, 0)) { if (!r) r = ppOnSeg(x12, y12, x21, y21, x22, y22); }\n    if (EQ(s21, 0)) { if (!r) r = ppOnSeg(x21, y21, x11, y11, x12, y12); }\n    if (EQ(s22, 0)) { if (!r) r = ppOnSeg(x22, y22, x11, y11, x12, y12); }\n    if (!r) r = ((s11 <= 0 && s12 >= 0) || (s11 >= 0 && s12 <= 0)) &&\n                ((s21 <= 0 && s22 >= 0) || (s21 >= 0 && s22 <= 0));\n    return r;\n}\n\ndouble pp2pp(double x1, double y1, double x2, double y2)\n{\n\treturn hypot(x2-x1, y2-y1);\n}\n\ndouble pp2line(double x, double y, double sx, double sy, double ex, double ey, int *on)\n{\n   double us, ub;\n   double xx, yy;\n \n   us = ( x - sx) * (ex - sx) + ( y - sy) * (ey - sy);\n   ub = (ex - sx) * (ex - sx) + (ey - sy) * (ey - sy);\n \n   /* closest point falls within the line segment */\n   *on = (EQ(us, 0) || us >= 0) && (EQ(us, ub) || us <= ub);\n\n   if      (EQ(us, 0))  xx = (double)sx, yy = (double)sy; \n   else if (EQ(us, ub)) xx = (double)ex, yy = (double)ey;\n   else {\n      xx = sx + (ex - sx) * (double)us / (double)ub;\n      yy = sy + (ey - sy) * (double)us / (double)ub;\n   }\n   return hypot(x - xx, y - yy);\n}\n\ndouble distSeg2Seg(double x11, double y11, double x12, double y12,\n\t\t\t\t   double x21, double y21, double x22, double y22)\n{\n\tint on;\n\tdouble t, d = INF;\n\n\tif (isCrossSeg(x11, y11, x12, y12, x21, y21, x22, y22)) return 0;\n    t = pp2line(x11, y11, x21, y21, x22, y22, &on);\n\tif (on && t < d) d = t;\n\n\tt = pp2line(x12, y12, x21, y21, x22, y22, &on);\n\tif (on && t < d) d = t;\n\n\tt = pp2line(x21, y21, x11, y11, x12, y12, &on);\n\tif (on && t < d) d = t;\n\n\tt = pp2line(x22, y22, x11, y11, x12, y12, &on);\n\tif (on && t < d) d = t;\n\n    t = pp2pp(x11, y11, x21, y21);\n    if (t < d) d = t;\n\n    t = pp2pp(x11, y11, x22, y22);\n    if (t < d) d = t;\n\n    t = pp2pp(x12, y12, x21, y21);\n    if (t < d) d = t;\n\n\tt = pp2pp(x12, y12, x22, y22);\n\tif (t < d) d = t;\n\n\treturn d;\n}\n\n#define PI    3.1415926535897932384626433832795\n#define PI180 0.01745329251994329576923690768489\n\ntypedef struct { double x[5], y[5]; } T;\nT tbl[101]; int N;\ndouble dist[101][101];\nchar visited[101];\n\ndouble dijkstra(int start, int goal)\n{\n\tint i, s;\n\tdouble d;\n\n\tqsize = 0;\n\tmemset(visited, 0, sizeof(visited));\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].node, d = que[0].t; deq();\n\t\tif (s == goal) return d;\n\t\tif (visited[s]) continue;\n\t\tvisited[s] = 1;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tif (dist[s][i] == 0) continue;\n\t\t\tenq(i, d + dist[s][i]);\n\t\t}\n\t}\n\treturn INF;\n}\n\nvoid calcPos(int i, int x0, int y0, int a, int r)\n{\n\tint j;\n\tfor (a += 90, j = 0; j < 5; j++, a += 72) {\n\t\ttbl[i].x[j] = x0 + r*cos(a * PI180);\n\t\ttbl[i].y[j] = y0 + r*sin(a * PI180);\n\t}\n}\n\nvoid calcDist()\n{\n\tint i, j, ii, jj;\n\tdouble d, x;\n\tT *p, *q;\n\n\tmemset(dist, 0x55, sizeof(dist));\n\tfor (i = 0; i < N; i++) dist[i][i] = 0;\n\n\tfor (p = tbl, ii = 0; ii < N; ii++, p++) for (q = tbl+ii+1, jj = ii+1; jj < N; jj++, q++) {\n\t\td = INF;\n\t\tfor (i = 0; i < 5; i++) for ( j = 0; j < 5; j++) {\n\t\t\tx = distSeg2Seg(p->x[i], p->y[i], p->x[(i+2)%5], p->y[(i+2)%5],\n\t\t\t\t\t\t\tq->x[j], q->y[j], q->x[(j+2)%5], q->y[(j+2)%5]);\n\t\t\tif (x < d) d = x;\n\t\t\tif (EQ(d, 0)) goto done;\n\t\t}\ndone:\n\t\tdist[ii][jj] = dist[jj][ii] = d;\n\t}\n}\n\nint main()\n{\n\tint M, L, i, x, y, a, r;\n\t\n\twhile (scanf(\"%d%d%d\", &N, &M, &L) && N > 0) {\n\t\tM--, L--;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &a, &r);\n\t\t\tcalcPos(i, x, y, a, r);\n\t\t}\n\t\tif (M == L) { puts(\"0.00000000000000000000\"); continue; }\n\n\t\tcalcDist();\n\n\t\tprintf(\"%.20lf\\n\", dijkstra(M, L));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.1415926535897932384626\n#define INF 1e10\n\n#define sq(x) ((x) * (x))\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nint main(void) {\n\tint i, j, k, l;\n\tint n, vega, altair;\n\n\twhile (scanf(\"%d %d %d\", &n, &vega, &altair), n) {\n\t\tint x[100], y[100], a[100], r[100];\n\t\tdouble xx[100][5], yy[100][5];\n\t\tdouble d[100][100];\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d %d %d %d\", x + i, y + i, a + i, r + i);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfor (j = 0; j < 5; j++) {\n\t\t\t\tconst double theta = (90. + 72. * j + a[i]) * PI / 180.;\n\t\t\t\txx[i][j] = r[i] * cos(theta) + x[i];\n\t\t\t\tyy[i][j] = r[i] * sin(theta) + y[i];\n\t\t\t}\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\td[i][j] = i == j ? 0 : INF;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\tdouble min = INF;\n\t\t\t\tfor (k = 0; k < 5; k++)\n\t\t\t\t\tfor (l = 0; l < 5; l++)\n\t\t\t\t\t\tmin = min(min, sqrt(sq(xx[i][k] - xx[j][l]) + sq(yy[i][k] - yy[j][l])));\n\t\t\t\td[i][j] = d[j][i] = min;\n\t\t\t}\n\n\t\tfor (k = 0; k < n; k++)\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\tprintf(\"%.20f\\n\", d[vega - 1][altair - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2402: Milky Way\n// 2017.11.20 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 10000\ntypedef struct { int node; double t; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int n, double t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 1e10\n#define EPS 1e-9\n#define EQ(a, b) (fabs(a-b)<=EPS)\n\nint ppOnSeg(double x, double y, double x1, double y1, double x2, double y2)\n{\n    double d;\n    if (x1 > x2) d = x1, x1 = x2, x2 = d;\n    if (y1 > y2) d = y1, y1 = y2, y2 = d;\n    return (EQ(x1, x) || x1 <= x) && (EQ(x, x2) || x <= x2) &&\n\t\t   (EQ(y1, y) || y1 <= y) && (EQ(y, y2) || y <= y2) &&\n           EQ((y-y1)*(x2-x1), (y2-y1)*(x-x1));\n}\n\nint isCrossSeg(double x11, double y11, double x12, double y12,\n             double x21, double y21, double x22, double y22)\n{\n    double s11, s12, s21, s22;\n    int r = 0;\n\n    s11 = (x22-x21) * (y11-y21) + (y22-y21) * (x21-x11);\n    s12 = (x22-x21) * (y12-y21) + (y22-y21) * (x21-x12);\n    s21 = (x12-x11) * (y21-y11) + (y12-y11) * (x11-x21);\n    s22 = (x12-x11) * (y22-y11) + (y12-y11) * (x11-x22);\n\tif      (EQ(s11, 0)) { if (!r) r = ppOnSeg(x11, y11, x21, y21, x22, y22); }\n    else if (EQ(s12, 0)) { if (!r) r = ppOnSeg(x12, y12, x21, y21, x22, y22); }\n    else if (EQ(s21, 0)) { if (!r) r = ppOnSeg(x21, y21, x11, y11, x12, y12); }\n    else if (EQ(s22, 0)) { if (!r) r = ppOnSeg(x22, y22, x11, y11, x12, y12); }\n    else if (!r) r = ((s11 <= 0 && s12 >= 0) || (s11 >= 0 && s12 <= 0)) &&\n                     ((s21 <= 0 && s22 >= 0) || (s21 >= 0 && s22 <= 0));\n    return r;\n}\n\ndouble pp2pp(double x1, double y1, double x2, double y2)\n{\n\treturn hypot(x2-x1, y2-y1);\n}\n\ndouble pp2line(double x, double y, double sx, double sy, double ex, double ey, int *on)\n{\n   double us, ub;\n   double xx, yy;\n \n   us = ( x - sx) * (ex - sx) + ( y - sy) * (ey - sy);\n   ub = (ex - sx) * (ex - sx) + (ey - sy) * (ey - sy);\n \n   /* closest point falls within the line segment */\n   *on = (EQ(us, 0) || us >= 0) && (EQ(us, ub) || us <= ub);\n\n   if      (EQ(us, 0))  xx = sx, yy = sy; \n   else if (EQ(us, ub)) xx = ex, yy = ey;\n   else {\n      xx = sx + (ex - sx) * us / ub;\n      yy = sy + (ey - sy) * us / ub;\n   }\n   return hypot(x - xx, y - yy);\n}\n\ndouble distSeg2Seg(double x11, double y11, double x12, double y12,\n\t\t\t\t   double x21, double y21, double x22, double y22)\n{\n\tint on;\n\tdouble t, d = INF;\n\n\tif (isCrossSeg(x11, y11, x12, y12, x21, y21, x22, y22)) return 0;\n\n    t = pp2line(x11, y11, x21, y21, x22, y22, &on);\n\tif (on && t < d) d = t;\n\n\tt = pp2line(x12, y12, x21, y21, x22, y22, &on);\n\tif (on && t < d) d = t;\n\n\tt = pp2line(x21, y21, x11, y11, x12, y12, &on);\n\tif (on && t < d) d = t;\n\n\tt = pp2line(x22, y22, x11, y11, x12, y12, &on);\n\tif (on && t < d) d = t;\n\n    t = pp2pp(x11, y11, x21, y21);\n    if (t < d) d = t;\n\n    t = pp2pp(x11, y11, x22, y22);\n    if (t < d) d = t;\n\n    t = pp2pp(x12, y12, x21, y21);\n    if (t < d) d = t;\n\n\tt = pp2pp(x12, y12, x22, y22);\n\tif (t < d) d = t;\n\n\treturn d;\n}\n\n#define PI    3.1415926535897932384626433832795\n#define PI180 0.01745329251994329576923690768489\n\ntypedef struct { double x[5], y[5]; } T;\nT tbl[101]; int N;\ndouble dist[101][101];\nchar visited[101];\n\ndouble dijkstra(int start, int goal)\n{\n\tint i, s;\n\tdouble d;\n\n\tqsize = 0;\n\tmemset(visited, 0, sizeof(visited));\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].node, d = que[0].t; deq();\n\t\tif (s == goal) return d;\n\t\tif (visited[s]) continue;\n\t\tvisited[s] = 1;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tif (i == s || visited[i]) continue;\n\t\t\tenq(i, d + dist[s][i]);\n\t\t}\n\t}\n\treturn INF;\n}\n\nvoid calcPos(int i, int x0, int y0, int a, int r)\n{\n\tint j;\n\tfor (a += 90, j = 0; j < 5; j++, a += 72) {\n\t\ttbl[i].x[j] = x0 + r*cos(a * PI180);\n\t\ttbl[i].y[j] = y0 + r*sin(a * PI180);\n\t}\n}\n\nvoid calcDist()\n{\n\tint i, j, ii, jj;\n\tdouble d, x;\n\tT *p, *q;\n\n\tmemset(dist, 0x55, sizeof(dist));\n\tfor (i = 0; i < N; i++) dist[i][i] = 0;\n\n\tfor (p = tbl, ii = 0; ii < N; ii++, p++) for (q = tbl+ii+1, jj = ii+1; jj < N; jj++, q++) {\n\t\td = INF;\n\t\tfor (i = 0; i < 5; i++) for ( j = 0; j < 5; j++) {\n\t\t\tx = distSeg2Seg(p->x[i], p->y[i], p->x[(i+2)%5], p->y[(i+2)%5],\n\t\t\t\t\t\t\tq->x[j], q->y[j], q->x[(j+2)%5], q->y[(j+2)%5]);\n\t\t\tif (x < d) d = x;\n\t\t\tif (EQ(d, 0)) goto done;\n\t\t}\ndone:\n\t\tdist[ii][jj] = dist[jj][ii] = d;\n\t}\n}\n\nint main()\n{\n\tint M, L, i, x, y, a, r;\n\t\n\twhile (scanf(\"%d%d%d\", &N, &M, &L) && N > 0) {\n\t\tM--, L--;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &a, &r);\n\t\t\tcalcPos(i, x, y, a, r);\n\t\t}\n\t\tif (M == L) { puts(\"0.00000000000000000000\"); continue; }\n\n\t\tcalcDist();\n\n\t\tprintf(\"%.20lf\\n\", dijkstra(M, L));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nclass Star{\n    Point2D o;\n    Point2D[] t;\n    double a, r;\n\n    Star(double x, double y, double a, double r){\n        this.o = new Point2D.Double(x, y);\n        this.a = a;\n        this.r = r;\n\n        t = new Point2D[5];\n\n        for(int i = 0; i < 5; i++){\n            double theta = (90 + a + 72 * i) % 360;\n            theta = theta * Math.PI / 180;\n\n            double dx = r * Math.cos(theta);\n            double dy = r * Math.sin(theta);\n\n            t[i] = new Point2D.Double(x + dx, y + dy);\n        }\n    }\n}\n\npublic class Main{\n    final static double INF = 999999999;\n\n    static double distSS(Line2D la, Line2D lb){\n        return\n            Math.min(Math.min(la.ptSegDist(lb.getP1()), la.ptSegDist(lb.getP2())), \n                     Math.min(lb.ptSegDist(la.getP1()), lb.ptSegDist(la.getP2())));\n    }\n\n    static double calcDist(Star sa, Star sb){\n        double res = INF;\n\n        for(int i = 0; i < 5; i++){\n            Line2D a = new Line2D.Double(sa.t[i], sa.t[(i + 2) % 5]);\n\n            for(int j = 0; j < 5; j++){\n                Line2D b = new Line2D.Double(sb.t[j], sb.t[(j + 2) % 5]);\n\n                if(a.intersectsLine(b)){\n                    return 0;\n                }\n                else{\n                    res = Math.min(res, distSS(a, b));\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int N = sc.nextInt();\n            int M = sc.nextInt() - 1;\n            int L = sc.nextInt() - 1;\n            if(N == 0) break;\n\n            Star[] t = new Star[N];\n\n            for(int i = 0; i < N; i++){\n                double x = sc.nextDouble();\n                double y = sc.nextDouble();\n                double a = sc.nextDouble();\n                double r = sc.nextDouble();\n                t[i] = new Star(x, y, a, r);\n            }\n\n            double[][] dist = new double[N][N];\n\n            for(int i = 0; i < N; i++){\n                for(int j = i; j < N; j++){\n                    if(i == j) dist[i][j] = 0;\n                    else       dist[i][j] = dist[j][i] = calcDist(t[i], t[j]);\n                }\n            }\n\n            for(int k = 0; k < N; k++){\n                for(int i = 0; i < N; i++){\n                    for(int j = 0; j < N; j++){\n                        if(i == j) continue;\n                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                    }\n                }\n            }\n\n            System.out.printf(\"%.20f\\n\", dist[M][L]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n List<Star>                stars  = new LinkedList<Star>();\n HashMap<Set<Star>, Route> routes = new HashMap<Set<Star>, Route>();\n\n public Main(int n) {\n }\n\n void add(int index, Star s) {\n\tstars.add(s);\n\tcreateRoute(s);\n }\n\n void createRoute(Star s) {\n\tHashSet<Star> set = new HashSet<Star>();\n\tfor (Star target : stars) {\n\t Bridge bridge = new Bridge(target, s);\n\t set.clear();\n\t set.addAll(Arrays.asList(s, target));\n\t Route route;\n\t if (routes.containsKey(set)) {\n\t\troute = routes.get(set);\n\t\tif (route.getLength() >= bridge.getLength()) route\n\t\t  .set(bridge);\n\t } else {\n\t\troute = new Route(s, bridge, target);\n\t\troutes.put(set, route);\n\t\tfor (Star s2 : stars) {\n\t\t set.clear();\n\t\t set.addAll(Arrays.asList(s2, target));\n\t\t Route newR = new Route(s, route, routes.get(set), s2);\n\t\t routes.put(new HashSet<Star>(Arrays.asList(s, s2)),\n\t\t\t newR);\n\t\t}\n\t }\n\t}\n }\n\n double getLength(int num, int num2) {\n\tStar s1 = stars.get(num - 1);\n\tStar s2 = stars.get(num2 - 1);\n\tfinal List<Star> asList = Arrays.asList(s1, s2);\n\tfinal HashSet<Star> hashSet = new HashSet<Star>(asList);\n\treturn routes.get(hashSet).getLength();\n\n }\n\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\twhile (in.hasNext()) {\n\t int n = in.nextInt();\n\t int m = in.nextInt();\n\t int l = in.nextInt();\n\t if (n != 0) {\n\t\tMain main = new Main(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t int x = in.nextInt();\n\t\t int y = in.nextInt();\n\t\t int theta = in.nextInt();\n\t\t int r = in.nextInt();\n\t\t Star star = new Star(x, y, theta, r);\n\t\t main.add(i, star);\n\t\t}\n\t\tSystem.out.println(main.getLength(m, l));\n\t }\n\t}\n }\n}\n\nclass Star {\n static AffineTransform affin = new AffineTransform();\n final int              x, y;\n final List<Point2D>    pts;\n\n Star(int x, int y, int theta, int r) {\n\tthis.x = x;\n\tthis.y = y;\n\tPoint2D.Double orign = new Point2D.Double(x, y + r);\n\tfinal List<Point2D> tg = new ArrayList<Point2D>();\n\tfor (int i = 0; i < 5; i++) {\n\t final double j = Math.toRadians(theta + 360 / 5 * 2 * i);\n\t affin.setToRotation(j, x, y);\n\t final Point2D setP =\n\t\t affin.transform(orign, new Point2D.Double());\n\t tg.add(setP);\n\t}\n\tpts = Collections.unmodifiableList(tg);\n }\n\n static double getSpan(Star s1, Star s2) {\n\tfinal Line2D.Double s1L = new Line2D.Double();\n\tfinal Line2D.Double s2L = new Line2D.Double();\n\tdouble min = Double.MAX_VALUE;\n\tfor (int i = 0; i < 5; i++) {\n\t if (min != 0.0) {\n\t\ts1L.setLine(s1.pts.get(i), s1.pts.get((i + 1) % 5));\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t s2L.setLine(s2.pts.get(j), s2.pts.get((j + 1) % 5));\n\t\t if (min == 0.0 || s1L.intersectsLine(s2L)) {\n\t\t\tmin = 0.0;\n\t\t } else {\n\t\t\tmin = Math.min(min, s1L.ptSegDist(s2L.x1, s2L.y1));\n\t\t\tmin = Math.min(min, s1L.ptSegDist(s2L.x2, s2L.y2));\n\t\t\tmin = Math.min(min, s2L.ptSegDist(s1L.x1, s1L.y1));\n\t\t\tmin = Math.min(min, s2L.ptSegDist(s1L.x2, s1L.y2));\n\t\t }\n\t\t}\n\t }\n\t}\n\treturn min;\n }\n}\n\nabstract class Road {\n abstract double getLength();\n}\n\nclass Route extends Road {\n final Set<Star>  sideStar;\n final List<Road> route = new LinkedList<Road>();\n\n Route(Star s1, Bridge bridge, Star s2) {\n\tthis.sideStar = new HashSet<Star>(Arrays.asList(s1, s2));\n\troute.add(bridge);\n }\n\n public Route(Star s1, Route route2, Route route3, Star s2) {\n\tthis.sideStar = new HashSet<Star>(Arrays.asList(s1, s2));\n\troute.add(route2);\n\troute.add(route3);\n }\n\n void set(Road... routes) {\n\troute.clear();\n\troute.addAll(Arrays.asList(routes));\n }\n\n @Override\n double getLength() {\n\tdouble result = 0.0;\n\tfor (Road r : route) {\n\t result += r.getLength();\n\t}\n\treturn result;\n }\n}\n\nclass Bridge extends Road {\n final double span;\n\n Bridge(Star s1, Star s2) {\n\tspan = Star.getSpan(s1, s2);\n }\n\n @Override\n double getLength() {\n\treturn span;\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt()-1;\n\t\t\tint l = scan.nextInt()-1;\n\n\t\t\tif(n==0) break;\n\n\t\t\tArrayList<Line> lines = new ArrayList<>();\n\t\t\tArrayList<Point> points = new ArrayList<>();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tint a = scan.nextInt();\n\t\t\t\tint r = scan.nextInt();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tdouble x1 = x+r*Math.sin(Math.toRadians(a+j*72));\n\t\t\t\t\tdouble y1 = y+r*Math.cos(Math.toRadians(a+j*72));\n\t\t\t\t\tdouble x2 = x+r*Math.sin(Math.toRadians(a+(j+1)*72));\n\t\t\t\t\tdouble y2 = y+r*Math.cos(Math.toRadians(a+(j+1)*72));\n\n\t\t\t\t\tlines.add(new Line(x1,y1,x2,y2));\n\t\t\t\t\tpoints.add(new Point(x1,y1));\n\t\t\t\t\t//points.push(new Point(x2,y2));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble[][] graph = new double[n][n];\n\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i; j < n; j++) {\n\t\t\t\t\tdouble minLength = 999999999;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tfor(int p = 0; p < 5; p++) {\n\t\t\t\t\t\t\tminLength = Math.min(\n\t\t\t\t\t\t\t\tminLength,\n\t\t\t\t\t\t\t\tlines.get(i*5+k).getPointLength(points.get(j*5+p))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgraph[i][j] = minLength;\n\t\t\t\t\tgraph[j][i] = minLength;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tSystem.out.print(graph[i][j]+\",\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\n\t\t\tint startPos = m;\n\t\t\tdouble[] minArr = new double[n];\n\t\t\tboolean[] flagArr = new boolean[n];\n\t\t\twhile(true) {\n\t\t\t\tflagArr[startPos] = true;\n\t\t\t\tint minIndex = -1;\n\t\t\t\tdouble minLength = 999999999.9;\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tif(!flagArr[i]) {\n\t\t\t\t\t\tif(graph[startPos][i]<minLength) {\n\t\t\t\t\t\t\tminLength = graph[startPos][i];\n\t\t\t\t\t\t\tminIndex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(minIndex==-1) break;\n\t\t\t\tminArr[minIndex] = minArr[startPos]+minLength;\n\t\t\t\tstartPos = minIndex;\n\t\t\t}\n\n\t\t\tSystem.out.println(minArr[l]);\n\t\t}\n\t}\n}\n\nclass Line{\n\tdouble x1,y1,x2,y2;\n\tLine(double _x1, double _y1, double _x2, double _y2) {\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\tx2 = _x2;\n\t\ty2 = _y2;\n\t}\n\tdouble getPointLength(Point _point) {\n\t\t//return 5.0;\n\t\tdouble a = x1;\n\t\tdouble b = y1;\n\t\tdouble c = x2;\n\t\tdouble d = y2;\n\t\tdouble e = _point.x;\n\t\tdouble f = _point.y;\n\t\tdouble p = ((1-e)*(c-a)-(d-b)*(1-f))/((d-b)*(d-b)+(c-a)*(c-a));\n\t\tif(p>0&&p<1) {\n\t\t\tdouble g = a+(c-a)*p;\n\t\t\tdouble h = b+(d-b)*p;\n\t\t\treturn Math.sqrt((e-g)*(e-g)+(f-h)*(f-h));\n\t\t}\n\t\telse return Math.sqrt(Math.min((e-a)*(e-a)+(f-b)*(f-b),(e-c)*(e-c)+(f-d)*(f-d)));\n\t}\n}\n\nclass Point{\n\tdouble x,y;\n\tPoint(double _x, double _y) {\n\t\tx = _x;\n\t\ty = _y;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\t\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint M = sc.nextInt()-1;\n\t\t\tint L = sc.nextInt()-1;\n\t\t\tif(n == 0 && M == -1 && L == -1) break;\n\t\t\tPoint2D [][] point = new Point2D.Double[n][5];\n\t\t\tLine2D [][] line = new Line2D.Double[n][5];\n\t\t\t//input\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdouble x = sc.nextDouble();\n\t\t\t\tdouble y = sc.nextDouble();\n\t\t\t\tdouble a = sc.nextDouble();\n\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\t//each point\n\t\t\t\tfor(int j=0; j < 5; j++){\n\t\t\t\t\tdouble rad = Math.toRadians(-a + (double)j * 72);\n\t\t\t\t\tdouble endx = x + r * Math.sin(rad);\n\t\t\t\t\tdouble endy = y + r * Math.cos(rad);\n\t\t\t\t\tpoint[i][j] = new Point2D.Double(endx, endy);\n\t\t\t\t}\n\t\t\t\t//each line\n\t\t\t\tfor(int j=0; j < 5; j++){\n\t\t\t\t\tline[i][j] = new Line2D.Double(point[i][j] , point[i][(j+2)%5]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble [][] pass = new double[n][n];\n\t\t\t//calc\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tpass[i][i] = 0.0;\n\t\t\t\tfor(int j=i+1; j< n; j++){\n\t\t\t\t\tdouble ans = 1 << 24;\n\t\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\t\tfor(int l = 0; l < 5; l++){\n\t\t\t\t\t\t\tLine2D nowi = line[i][k];\n\t\t\t\t\t\t\tLine2D nowj = line[j][l];\n\t\t\t\t\t\t\tif(nowi.intersectsLine(nowj)){\n\t\t\t\t\t\t\t\tans = 0.0;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdouble res = getDis1(nowi,nowj);\n\t\t\t\t\t\t\tans = Math.min(ans, res);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpass[i][j] = ans; pass[j][i] = ans;\n\t\t\t\t}\n\t\t\t}//end i\n\t\t\t\n\t\t\t\n\t\t\tfor(int j=0; j < n; j++){\n\t\t\t\tfor(int i = 0;i < n; i++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tpass[i][k] = Math.min(pass[i][k], pass[i][j] + pass[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%1.16f\\n\",pass[M][L]);\n\t\t}\n\t}\n\n\tprivate double getDis1(Line2D a, Line2D b) {\n\t\tPoint2D a1 = a.getP1();\n\t\tPoint2D a2 = a.getP2();\n\t\tPoint2D b1 = b.getP1();\n\t\tPoint2D b2 = b.getP2();\n\t\tdouble res = getD(a1,a2,b1);\n\t\tres = Math.min(res, getD(a1,a2,b2));\n\t\tres = Math.min(res, getD(b1,b2,a1));\n\t\tres = Math.min(res, getD(b1,b2,a2));\n\t\treturn res;\n\t}\n\n\tprivate double getD(Point2D a, Point2D b, Point2D c) {\n\t\tPoint2D ba = getV(b,a);\n\t\tPoint2D ca = getV(c,a);\n\t\tPoint2D ab = getV(a,b);\n\t\tPoint2D cb = getV(c,b);\n\t\tdouble result;\n\t\tif(getDot(ba,ca) < EPS){\n\t\t\tresult = a.distance(c);\n\t\t}\n\t\telse if(getDot(ab,cb) < EPS){\n\t\t\tresult = c.distance(b);\n\t\t}\n\t\telse{\n\t\t\tresult = Math.abs(getCross(ba,ca)) / b.distance(a);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate double getCross(Point2D a, Point2D b) {\n\t\treturn (a.getX() * b.getY() - a.getY() * b.getX());\n\t}\n\n\tprivate double getDot(Point2D a, Point2D b) {\n\t\treturn (a.getX() * b.getX() + a.getY() * b.getY());\n\t}\n\n\tprivate Point2D getV(Point2D a, Point2D b) {\n\t\tPoint2D res = new Point2D.Double(a.getX() - b.getX(), a.getY() - b.getY());\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Milky Way\npublic class Main{\n\n\tfinal double EPS = 1e-10;\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] seg = {{0, 2},{0, 3},{1, 4},{1, 3},{2, 4}};\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), S = sc.nextInt(), T = sc.nextInt();\n\t\t\tif((n|S|T)==0)break;\n\t\t\tS--; T--;\n\t\t\tdouble[] cx = new double[n], cy = new double[n], a = new double[n], r = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcx[i] = sc.nextDouble(); cy[i] = sc.nextDouble(); a[i] = sc.nextDouble(); r[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tdouble[][][] p = new double[n][5][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tdouble x = -Math.sin((a[i]+72*k)*Math.PI/180)*r[i], y = Math.cos((a[i]+72*k)*Math.PI/180)*r[i];\n\t\t\t\t\tp[i][k][0] = cx[i]+x; p[i][k][1] = cy[i]+y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble[][] wf = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=1<<29;\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tdouble min = 1<<29;\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tdouble[] A = p[i][seg[k][0]], B = p[i][seg[k][1]];\n\t\t\t\t\tfor(int m=0;m<5;m++){\n\t\t\t\t\t\tdouble[] C = p[j][seg[m][0]], D = p[j][seg[m][1]];\n\t\t\t\t\t\tmin = Math.min(min, dist(A, B, C, D));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twf[i][j] = wf[j][i] = min;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tSystem.out.printf(\"%.10f\\n\", wf[S][T]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Milky Way\npublic class Main{\n\nfinal double EPS = 1e-10;\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble[] cp(double[] a, double[] b, double[] s, double[] t){\n\t\tdouble ds = distLP(a, b, s), dt = distLP(a, b, t);\n\t\tdouble k = ds/(ds+dt);\n\t\tdouble[] d = sub(t, s);\n\t\treturn new double[]{s[0]+k*d[0], s[1]+k*d[1]};\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] seg = {{0, 2},{0, 3},{1, 4},{1, 3},{2, 4}};\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), S = sc.nextInt(), T = sc.nextInt();\n\t\t\tif((n|S|T)==0)break;\n\t\t\tS--; T--;\n\t\t\tdouble[] cx = new double[n], cy = new double[n], a = new double[n], r = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcx[i] = sc.nextDouble(); cy[i] = sc.nextDouble(); a[i] = sc.nextDouble(); r[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tdouble[][][] p = new double[n][5][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tdouble x = -Math.sin((a[i]+72*k)*Math.PI/180)*r[i], y = Math.cos((a[i]+72*k)*Math.PI/180)*r[i];\n\t\t\t\t\tp[i][k][0] = cx[i]+x; p[i][k][1] = cy[i]+y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble[][] wf = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=1<<29;\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tdouble min = 1<<29;\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tdouble[] A = p[i][seg[k][0]], B = p[i][seg[k][1]];\n\t\t\t\t\tfor(int m=0;m<5;m++){\n\t\t\t\t\t\tdouble[] C = p[j][seg[m][0]], D = p[j][seg[m][1]];\n\t\t\t\t\t\tmin = Math.min(min, dist(A, B, C, D));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twf[i][j] = wf[j][i] = min;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tSystem.out.printf(\"%.10f\\n\", wf[S][T]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tdouble[][] dis = new double[n + 1][n + 1];\n\t\t\tStar[] stars = new Star[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(dis[i], Double.MAX_VALUE);\n\t\t\t\tdis[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tstars[i] = new Star(sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\tdis[i][j] = dis[j][i] = stars[i].minDistance(stars[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\tdis[i][j] = Math.min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.10f\\n\", dis[m][l]);\n\t\t}\n\t}\n}\n\nclass Star {\n\tLine[] ls = new Line[5];\n\n\tStar(double sx, double sy, double a, double r) {\n\t\tdouble x = sx - r * Math.sin(Math.PI * a / 180);\n\t\tdouble y = sy + r * Math.cos(Math.PI * a / 180);\n\t\tPoint2D.Double[] ps = new Point2D.Double[5];\n\t\tps[0] = new Point2D.Double(x, y);\n\t\tdouble cos = Math.cos(Math.PI * 72 / 180);\n\t\tdouble sin = Math.sin(Math.PI * 72 / 180);\n\t\tfor (int i = 1; i < 5; i++) {\n\t\t\tdouble xd = (cos * (x - sx) - sin * (y - sy)) + sx;\n\t\t\tdouble yd = (sin * (x - sx) + cos * (y - sy)) + sy;\n\t\t\tps[i] = new Point2D.Double(xd, yd);\n\t\t\tx = xd;\n\t\t\ty = yd;\n\t\t}\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tls[i] = new Line(ps[i], ps[(i + 1) % 5]);\n\t\t}\n\t}\n\n\tpublic double minDistance(Star star2) {\n\t\tStar star1 = this;\n\t\tdouble min = Double.MAX_VALUE;\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tmin = Math.min(min, star1.ls[i].minDistance(star2.ls[j]));\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic String toString() {\n\t\treturn this.ls[0] + \" \" + this.ls[1] + \" \" + this.ls[2] + \" \"\n\t\t\t\t+ this.ls[3] + \" \" + this.ls[4];\n\t}\n}\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Line2D.Double;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n==0 && m==0 && l==0) break;\n\t\t\t\n\t\t\tLine2D.Double[] z = new Line2D.Double[5*n];\n\t\t\tdouble[] x = new double[5*n];\n\t\t\tdouble[] y = new double[5*n];\n\t\t\tdouble[][] cost = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tArrays.fill(cost[i], Integer.MAX_VALUE);\n\t\t\t\tcost[i][i] = 0;\n\t\t\t}\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\tdouble a = sc.nextDouble();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tx[5*i+j] = p - Math.sin((a+72*j)*Math.PI/180)*r;\n\t\t\t\t\ty[5*i+j] = q + Math.cos((a+72*j)*Math.PI/180)*r;\n\t\t\t\t}\n\t\t\t\tz[5*i] = new Line2D.Double(x[5*i], y[5*i], x[5*i+2], y[5*i+2]);\n\t\t\t\tz[5*i+1] = new Line2D.Double(x[5*i+2], y[5*i+2], x[5*i+4], y[5*i+4]);\n\t\t\t\tz[5*i+2] = new Line2D.Double(x[5*i+4], y[5*i+4], x[5*i+1], y[5*i+1]);\n\t\t\t\tz[5*i+3] = new Line2D.Double(x[5*i+1], y[5*i+1], x[5*i+3], y[5*i+3]);\n\t\t\t\tz[5*i+4] = new Line2D.Double(x[5*i+3], y[5*i+3], x[5*i], y[5*i]);\n\t\t\t\t\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int c=0;c<5;c++){\n\t\t\t\t\t\tfor(int d=0;d<5;d++){\n\t\t\t\t\t\t\tif(z[5*i+c].intersectsLine(z[5*j+d])==true){\n\t\t\t\t\t\t\t\tmin = 0;\n\t\t\t\t\t\t\t\tc = 5;\n\t\t\t\t\t\t\t\td = 5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(min!=0){\n\t\t\t\t\t\tfor(int c=0;c<5;c++){\n\t\t\t\t\t\t\tfor(int d=0;d<5;d++){\n\t\t\t\t\t\t\t\tmin = Math.min(min, z[5*j+d].ptSegDist(x[5*i+c], y[5*i+c]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j] = min;\n\t\t\t\t\tcost[j][i] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(cost[j][i]!=Integer.MAX_VALUE && cost[i][k]!=Integer.MAX_VALUE){\n\t\t\t\t\t\t\tcost[j][k] = Math.min(cost[j][k], cost[j][i]+cost[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cost[m-1][l-1]);\t\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\tint n, s, g;\n\tdouble[][] map;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\ts = sc.nextInt(); g = sc.nextInt();\n\t\t\tif( (n|s|g) == 0 ) break;\n\t\t\ts--; g--;\n\t\t\t\n\t\t\tPent[] pents = new Pent[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tpents[i] = new Pent(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tmap = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\tmap[i][j] = map[j][i] = pents[i].d(pents[j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[j][k]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(map[s][g]);\n\t\t\t\n\t\t}\n\t}\n\t\n\tclass Pent {\n\t\tP[] ps;\n\t\tPent (double x, double y, double a, double r) {\n\t\t\tps = new P[5];\n\t\t\tfor(int i=0;i<5;i++) {\n\t\t\t\tps[i] = new P( -sin( (a + 72 * i) * PI / 180 ) * r + x, cos( (a + 72 * i) * PI / 180 ) * r + y );\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble d(Pent p) {\n\t\t\tdouble d = Double.MAX_VALUE;\n\t\t\tfor(int i=0;i<5;i++) for(int j=0;j<5;j++){\n\t\t\t\tif( cross(ps[i], ps[(i+2)%5], p.ps[j], p.ps[(j+2)%5] ) ) return 0;\n\t\t\t\td = min( disSP(ps[i], ps[(i+2)%5], p.ps[j]), d );\n\t\t\t\td = min( disSP(p.ps[i], p.ps[(i+2)%5], ps[j]), d );\n\t\t\t}\n\t\t\treturn d;\n\t\t}\n\t}\n\t\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).len();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).len();\n\t\treturn disLP(p1, p2, q);\n\t}\n\t\n\tdouble disLP(P p1, P p2, P q) {\n\t\treturn abs ( p1.sub(p2).det(q.sub(p2)) ) / p1.sub(p2).len();\n\t}\n\t\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\tif( max(p1.x, p2.x) + EPS < min(q1.x, q2.x) ) return false;\n\t\tif( max(p1.y, p2.x) + EPS < min(q1.y, q2.y) ) return false;\n\t\tif( max(q1.x, q2.x) + EPS < min(p1.x, p2.x) ) return false;\n\t\tif( max(q1.y, q2.x) + EPS < min(p1.y, p2.y) ) return false;\n\t\treturn abs( p1.sub(p2).det(q1) * p1.sub(p2).det(q2) ) < EPS &&\n\t\t\t   abs( q1.sub(q2).det(p1) * q1.sub(q2).det(p2) ) < EPS;\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP( double x, double y ) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tP add(P p) {\n\t\t\treturn new P(add(x,p.x), add(y,p.y));\n\t\t}\n\t\t\n\t\tP sub(P p) {\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tdouble dot(P p) {\n\t\t\treturn add( x*p.x, y*p.y );\n\t\t}\n\t\t\n\t\tdouble det(P p) {\n\t\t\treturn add( x*p.y, -y*p.x );\n\t\t}\n\t\t\n\t\tdouble len() {\n\t\t\tdouble abs = sqrt ( add(x*x, y*y) );\n\t\t\tif( abs(abs) < EPS ) return 0;\n\t\t\treturn abs;\n\t\t}\n\t\t\n\t\tdouble add(double a, double b) {\n\t\t\tif( abs(a+b) < EPS * ( abs(a) + abs(b) ) ) return 0;\n\t\t\treturn a+b;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew D().doIt();\n\t}\n\n\tclass D {\n\t\t//??????????????? EDS Point2D????????????\n\t\tfinal double EPS = 1.0e-08;\n\t\t//????????¨?????????Arrays.sort(data, com);\n\t\tComparator< Point2D > com = new Comparator<Point2D>(){\n\t\t\tpublic int compare(Point2D o1,Point2D o2) {\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t//?§????\n\t\tprivate double angle(Point2D p1, Point2D p2){\n\t\t\tdouble a = dot(p1, p2);\n\t\t\tdouble b = abs(p1);\n\t\t\tdouble c = abs(p2);\n\t\t\tdouble cosTheta  = Math.acos(a/b/c);\n\t\t\treturn Math.toDegrees(cosTheta);\n\t\t}\n\t\t\n\t\t//?????\\\n\t\tprivate double dot(Point2D p1, Point2D p2){\n\t\t\treturn p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t}\n\t\t//?????¢????±??????????????¬???????norm???sort?????????????????????\n\t\tprivate double abs(Point2D p){\n\t\t\treturn Math.sqrt(p.getX() * p.getX() + p.getY() * p.getY());\n\t\t}\n\t\t\n\t\t//????????¨??????????????¢\n\t\tprivate double distanceSS(Line2D l, Line2D m){\n\t\t\tdouble ans = 0.0;\n\t\t\tif(! l.intersectsLine(m)){\n\t\t\t\tdouble res1 = l.ptSegDist(m.getP1());\n\t\t\t\tdouble res2 = l.ptSegDist(m.getP2());\n\t\t\t\tdouble res3 = m.ptSegDist(l.getP1());\n\t\t\t\tdouble res4 = m.ptSegDist(l.getP2());\n\t\t\t\tans = Math.min(Math.min(res1, res2),Math.min(res3, res4));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t//????????¨?????????????????????\n\t\tprivate boolean isIntersectSS(Line2D l, Line2D m){\n\t\t\treturn l.intersectsLine(m);\n\t\t}\n\t\t\n\t\t//??????????????????\n\t\tdouble cost[][];\n\t\tdouble d[];\n\t\tboolean used[];\n\t\tint V;\n\t\tvoid dijkstra(int s){\n\t\t\td[s] = 0;\n\t\t\twhile(true){\n\t\t\t\tint v = -1;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))v = u;\n\t\t\t\t}\n\t\t\t\tif(v == -1)break;\n\t\t\t\tused[v] = true;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\td[u] = Math.min(d[u], d[v] + cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint start = sc.nextInt();\n\t\t\t\tint goal = sc.nextInt();\n\t\t\t\tif(n+start+goal == 0)break;\n\t\t\t\tV = n;\n\t\t\t\tcost = new double[V][V];\n\t\t\t\td = new double[V];\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\td[i] = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused = new boolean[V];\n\t\t\t\tPoint2D.Double stard[][] = new Point2D.Double[n][5];\n\t\t\t\tLine2D.Double starl[][] = new Line2D.Double[n][5];\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tPoint2D.Double sstar = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\t\tdouble radi = sc.nextDouble();\n\t\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstard[i][j] = new Point2D.Double(r*Math.sin(Math.toRadians(360+(72*j)-radi))+sstar.getX(),r*Math.cos(Math.toRadians(360+(72*j)-radi))+sstar.getY());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstarl[i][j] = new Line2D.Double(stard[i][j],stard[i][(j+1)%5]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\tfor(int m = 0;m < V;m++){\n\t\t\t\t\t\tif(i == m)continue;\n\t\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\t\tfor(int k = 0;k < 5;k++){\n\t\t\t\t\t\t\t\tif(isIntersectSS(starl[i][j],starl[m][k])){\n\t\t\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\t\t\tcost[m][i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcost[i][m] = Math.min(cost[i][m],distanceSS(starl[i][j],starl[m][k]));\n\t\t\t\t\t\t\t\t\tcost[m][i] = cost[i][m];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdijkstra(start-1);\n//\t\t\t\tfor(int i = 0;i < V;i++){\n//\t\t\t\t\tSystem.out.println(d[i]);\n//\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%.7f\\n\",d[goal-1]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tdouble[][] dis = new double[n + 1][n + 1];\n\t\t\tStar[] stars = new Star[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(dis[i], Double.MAX_VALUE);\n\t\t\t\tdis[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tstars[i] = new Star(sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\tdis[i][j] = dis[j][i] = stars[i].minDistance(stars[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\tdis[i][j] = Math.min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.10f\\n\", dis[m][l]);\n\t\t}\n\t}\n}\n\nclass Star {\n\tLine[] ls = new Line[5];\n\n\tStar(double sx, double sy, double a, double r) {\n\t\tdouble x = sx - r * Math.sin(Math.PI * a / 180);\n\t\tdouble y = sy + r * Math.cos(Math.PI * a / 180);\n\t\tPoint2D.Double[] ps = new Point2D.Double[5];\n\t\tps[0] = new Point2D.Double(x, y);\n\t\tdouble cos = Math.cos(Math.PI * 72 / 180);\n\t\tdouble sin = Math.sin(Math.PI * 72 / 180);\n\t\tfor (int i = 1; i < 5; i++) {\n\t\t\tdouble xd = (cos * (x - sx) - sin * (y - sy)) + sx;\n\t\t\tdouble yd = (sin * (x - sx) + cos * (y - sy)) + sy;\n\t\t\tps[i] = new Point2D.Double(xd, yd);\n\t\t\tx = xd;\n\t\t\ty = yd;\n\t\t}\n\t\tls[0] = new Line(ps[0], ps[2]);\n\t\tls[1] = new Line(ps[2], ps[4]);\n\t\tls[2] = new Line(ps[4], ps[1]);\n\t\tls[3] = new Line(ps[1], ps[3]);\n\t\tls[4] = new Line(ps[3], ps[0]);\n\t}\n\n\tpublic double minDistance(Star star2) {\n\t\tStar star1 = this;\n\t\tdouble min = Double.MAX_VALUE;\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tmin = Math.min(min, star1.ls[i].minDistance(star2.ls[j]));\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic String toString() {\n\t\treturn this.ls[0] + \" \" + this.ls[1] + \" \" + this.ls[2] + \" \"\n\t\t\t\t+ this.ls[3] + \" \" + this.ls[4];\n\t}\n}\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n    Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        new Main();\n    }\n    public Main() {\n        new AOJ2402().doIt();\n    }\n    class AOJ2402{\n        int n,m,l;\n        ArrayList<ArrayList<Line2D>> stars;\n        double[][] cost;\n        int INF = Integer.MAX_VALUE/2;\n        void makeLine(int x,int y,int a,int r){\n            stars.add(new ArrayList<Line2D>());\n            Point2D[] p = new Point2D[5];\n            int angle = -a;\n            for(int i=0;i<5;i++){\n                Robot robot = new Robot(x, y ,angle);\n                robot.fd(r);\n                p[i] = robot.toPoint();\n                //   System.out.println(p[i]);\n                angle+=72;\n            }\n            stars.get(stars.size()-1).add(new Line2D.Double(p[0],p[2]));\n            stars.get(stars.size()-1).add(new Line2D.Double(p[2],p[4]));\n            stars.get(stars.size()-1).add(new Line2D.Double(p[1],p[4]));\n            stars.get(stars.size()-1).add(new Line2D.Double(p[1],p[3]));\n            stars.get(stars.size()-1).add(new Line2D.Double(p[0],p[3]));\n//            for(int i=0;i<5;i++){\n//                Point2D p1 = p[i];\n//                Point2D p2 = p[(i+1)%5];\n//                Line2D l = new Line2D.Double(p1, p2);\n//                stars.get(stars.size()-1).add(l);\n//            }\n            //   for(int i=0;i<stars.get(stars.size()-1).size();i++){\n            //   System.out.println(stars.get(stars.size()-1).get(i).getP1()+\" \"+stars.get(stars.size()-1).get(i).getP2());\n            //   }\n        }\n        void input(){\n            for(int i=0;i<n;i++)makeLine(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n        }\n        void getMin(){\n            for(int i=0;i<n;i++)for(int s=i;s<n;s++){\n                if(s==i){\n                    cost[i][s]=cost[s][i]=0;continue;\n                }\n                double min = INF;\n                for(int k=0;k<5;k++)for(int j=0;j<5;j++){\n                    min = Math.min(min, segSegDist(stars.get(i).get(k),stars.get(s).get(j)));\n                }\n                cost[i][s] = cost[s][i] = min;\n            }\n        }\n \n        void solve(){\n            stars = new ArrayList<ArrayList<Line2D>>();//★の線\n            input();\n            cost = new double[n][n];\n            for(int i=0;i<n;i++)Arrays.fill(cost[i], INF);\n            getMin();\n//          for(int i=0;i<n;i++){\n//              for(int s=0;s<n;s++)System.out.print(cost[i][s]+\" \");\n//              System.out.println();\n//          }\n            PriorityQueue<State> q = new PriorityQueue<State>();\n            q.add(new State(m,0.0));\n            double memo[] = new double[n];\n            memo[m]=0.0;\n            double result = -1;\n            Arrays.fill(memo, INF);\n            while(q.size()>0){\n                State now = q.remove();\n//              System.out.println(now.v+\" \"+now.cost);\n                int v = now.v;\n                double c = now.cost;\n                if(v==l){\n                    result = c;\n                    break;\n                }\n                for(int i=0;i<n;i++)if(cost[v][i]!=INF){\n                    double ncost = c+cost[v][i];\n                    if(memo[i] <= ncost)continue;\n                    memo[i] = ncost;\n//                  System.out.println(v+\" \"+i+\" \"+ncost);\n                    q.add(new State(i, ncost));\n                }\n            }\n            System.out.printf(\"%.15f\\n\",result);\n        }\n        void doIt(){\n            while(in.hasNext()){\n                n = in.nextInt();\n                m = in.nextInt();\n                l =in.nextInt();\n                if(n+m+l==0)break;\n                m--;l--;\n                solve();\n            }\n        }\n \n        double segSegDist(Line2D l1,Line2D l2){\n            return l1.intersectsLine(l2)? 0:Math.min(Math.min(l1.ptSegDist(l2.getP1()),l1.ptSegDist(l2.getP2())),Math.min(l2.ptSegDist(l1.getP1()), l2.ptSegDist(l1.getP2())));\n        }\n \n        class Robot{\n            double x,y,angle;\n            public Robot(int x,int y, int angle) {\n                this.x = x;\n                this.y = y;\n                this.angle = angle;\n            }\n            void fd(int go){\n                x += Math.sin(Math.PI*angle/180.0)*go;\n                y += Math.cos(Math.PI*angle/180.0)*go;\n            }\n            Point2D toPoint(){\n                return new Point2D.Double(x,y);\n            }\n        }\n        class State implements Comparable<State>{\n            double cost;\n            int v;\n            public State(int v,double cost) {\n                this.v = v;\n                this.cost = cost;\n            }\n            public int compareTo(State o) {\n                if(this.cost > o.cost)return 1;\n                else if(this.cost < o.cost)return -1;\n                return 0;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew D().doIt();\n\t}\n\n\tclass D {\n\t\t//??????????????? EDS Point2D????????????\n\t\tfinal double EPS = 1.0e-08;\n\t\t//????????¨?????????Arrays.sort(data, com);\n\t\tComparator< Point2D > com = new Comparator<Point2D>(){\n\t\t\tpublic int compare(Point2D o1,Point2D o2) {\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t//?§????\n\t\tprivate double angle(Point2D p1, Point2D p2){\n\t\t\tdouble a = dot(p1, p2);\n\t\t\tdouble b = abs(p1);\n\t\t\tdouble c = abs(p2);\n\t\t\tdouble cosTheta  = Math.acos(a/b/c);\n\t\t\treturn Math.toDegrees(cosTheta);\n\t\t}\n\t\t\n\t\t//?????\\\n\t\tprivate double dot(Point2D p1, Point2D p2){\n\t\t\treturn p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t}\n\t\t//?????¢????±??????????????¬???????norm???sort?????????????????????\n\t\tprivate double abs(Point2D p){\n\t\t\treturn Math.sqrt(p.getX() * p.getX() + p.getY() * p.getY());\n\t\t}\n\t\t\n\t\t//????????¨??????????????¢\n\t\tprivate double distanceSS(Line2D l, Line2D m){\n\t\t\tdouble ans = 0.0;\n\t\t\tif(! l.intersectsLine(m)){\n\t\t\t\tdouble res1 = l.ptSegDist(m.getP1());\n\t\t\t\tdouble res2 = l.ptSegDist(m.getP2());\n\t\t\t\tdouble res3 = m.ptSegDist(l.getP1());\n\t\t\t\tdouble res4 = m.ptSegDist(l.getP2());\n\t\t\t\tans = Math.min(Math.min(res1, res2),Math.min(res3, res4));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t//????????¨?????????????????????\n\t\tprivate boolean isIntersectSS(Line2D l, Line2D m){\n\t\t\treturn l.intersectsLine(m);\n\t\t}\n\t\t\n\t\t//??????????????????\n\t\tdouble cost[][];\n\t\tdouble d[];\n\t\tboolean used[];\n\t\tint V;\n\t\tvoid dijkstra(int s){\n\t\t\td[s] = 0;\n\t\t\twhile(true){\n\t\t\t\tint v = -1;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))v = u;\n\t\t\t\t}\n\t\t\t\tif(v == -1)break;\n\t\t\t\tused[v] = true;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\td[u] = Math.min(d[u], d[v] + cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint start = sc.nextInt();\n\t\t\t\tint goal = sc.nextInt();\n\t\t\t\tif(n+start+goal == 0)break;\n\t\t\t\tV = n;\n\t\t\t\tcost = new double[V][V];\n\t\t\t\td = new double[V];\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\td[i] = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused = new boolean[V];\n\t\t\t\tPoint2D.Double stard[][] = new Point2D.Double[n][5];\n\t\t\t\tLine2D.Double starl[][] = new Line2D.Double[n][5];\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tPoint2D.Double sstar = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\t\tdouble radi = sc.nextDouble();\n\t\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstard[i][j] = new Point2D.Double(r*Math.sin(Math.toRadians(360+(72*j)-radi))+sstar.getX(),r*Math.cos(Math.toRadians(360+(72*j)-radi))+sstar.getY());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstarl[i][j] = new Line2D.Double(stard[i][j],stard[i][(j+1)%5]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\tfor(int m = 0;m < V;m++){\n\t\t\t\t\t\tif(i == m)continue;\n\t\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\t\tfor(int k = 0;k < 5;k++){\n\t\t\t\t\t\t\t\tif(isIntersectSS(starl[i][j],starl[m][k])){\n\t\t\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\t\t\tcost[m][i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcost[i][m] = Math.min(cost[i][m],distanceSS(starl[i][j],starl[m][k]));\n\t\t\t\t\t\t\t\t\tcost[m][i] = cost[i][m];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdijkstra(start-1);\n//\t\t\t\tfor(int i = 0;i < V;i++){\n//\t\t\t\t\tSystem.out.println(d[i]);\n//\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%.10f\\n\",d[goal-1]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVector2[][] p = new Vector2[n*5][2];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tVector2[] q = new Vector2[5];\n\t\t\t\tfor(int j=0;j<5;j++) {\n\t\t\t\t\tdouble rad = Math.toRadians(90 + a + j * 72);\n\t\t\t\t\tq[j] = new Vector2(x + Math.cos(rad) * r, y + Math.sin(rad) * r);\n//\t\t\t\t\tSystem.out.println(q[j]);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<5;j++) {\n\t\t\t\t\tp[i*5+j][0] = q[j];\n\t\t\t\t\tp[i*5+j][1] = q[(j+2)%5];\n\t\t\t\t}\n\t\t\t}\n\t\t\tGraph g = new Graph(n*5);\n\t\t\tfor(int i=0;i<n*5;i++) {\n\t\t\t\tfor(int j=i+1;j<n*5;j++) {\n\t\t\t\t\tg.addBidirectionalEdge(i, j, Vector2.distLineToLine(p[i][0], p[i][1], p[j][0], p[j][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble dist = g.minDistDijkstra((m-1)*5)[(l-1)*5];\n\t\t\tSystem.out.println(String.format(\"%.8f\", dist));\n\t\t}\n\t}\n\n}\nclass Vector2 {\n\tpublic double x;\n\tpublic double y;\n\tpublic Vector2(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic double dot(Vector2 v) {\n\t\treturn this.x*v.x+this.y*v.y;\n\t}\n\tpublic double cross(Vector2 v) {\n\t\treturn this.x*v.y-this.y*v.x;\n\t}\n\tpublic double norm() {\n\t\treturn Math.sqrt(this.x*this.x+this.y*this.y);\n\t}\n\tpublic Vector2 normalize() {\n\t\treturn divide(norm());\n\t}\n\tpublic Vector2 add(Vector2 v) {\n\t\treturn new Vector2(x+v.x,y+v.y);\n\t}\n\tpublic Vector2 subtract(Vector2 v) {\n\t\treturn new Vector2(x-v.x,y-v.y);\n\t}\n\tpublic Vector2 multiply(double k) {\n\t\treturn new Vector2(x*k,y*k);\n\t}\n\tpublic Vector2 divide(double k) {\n\t\treturn new Vector2(x/k,y/k);\n\t}\n\tpublic double dist(Vector2 p1) {\n\t\treturn p1.subtract(this).norm();\n\t}\n\tpublic static double distLineToLine(Vector2 p0,Vector2 p1,Vector2 p2,Vector2 p3) {\n\t\tif (intersects(p0, p1, p2, p3)) {\n\t\t\treturn 0;\n\t\t}\n\t\tdouble dist = Double.POSITIVE_INFINITY;\n\t\tdist = Math.min(dist, distLineToPoint(p0, p1, p2));\n\t\tdist = Math.min(dist, distLineToPoint(p0, p1, p3));\n\t\tdist = Math.min(dist, distLineToPoint(p2, p3, p0));\n\t\tdist = Math.min(dist, distLineToPoint(p2, p3, p1));\n\t\treturn dist;\n\t}\n\tpublic static boolean intersects(Vector2 p0,Vector2 p1,Vector2 p2,Vector2 p3) {\n\t\tVector2 v1 = p1.subtract(p0);\n\t\tVector2 v2 = p3.subtract(p2);\n\t\tVector2 v = p2.subtract(p0);\n\t\tVector2 v_ = p2.subtract(p1);\n\t\tdouble a = v1.cross(v2);\n\t\tif(a==0) {\n\t\t\treturn v.cross(v_) == 0 && (v.dot(v_) <= 0 || p0.subtract(p2).dot(p0.subtract(p3)) <= 0);\n\t\t}else{\n\t\t\tdouble a1 = -v1.cross(v);\n\t\t\tdouble a2 = -v2.cross(v);\n\t\t\tif (a>0) {\n\t\t\t\treturn (0<=a1&&a1<=a&&0<=a2&&a2<=a);\n\t\t\t}else{\n\t\t\t\treturn (a<=a1&&a1<=0&&a<=a2&&a2<=0);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static double distLineToPoint(Vector2 r1,Vector2 r2,Vector2 p) {\n\t\tVector2 r12 = r2.subtract(r1);\n\t\tif (p.subtract(r1).dot(r12) * p.subtract(r2).dot(r12) >= 0) {\n\t\t\treturn Math.min(p.dist(r1), p.dist(r2));\n\t\t}else{\n\t\t\treturn Math.abs(r2.subtract(r1).normalize().cross(p.subtract(r1)));\n\t\t}\n\t}\n\tpublic String toString() {\n\t\treturn \"(\" + this.x + \",\" + this.y + \")\";\n\t}\n}\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void addBidirectionalEdge(int from,int to,double cost) {\n//\t\tSystem.out.println(from + \",\" + to + \",\" + cost);\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,double cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic double[] minDistDijkstra(int s) {\n\t\tdouble[] dist = new double[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tpublic Edge(int to,double cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tdouble dist;\n\t\tint id;\n\t\tpublic Node(double dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\t\t\tfinal int L = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0 && M == 0 && L == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[][][] lines = new Point2D[N][5][2];\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\tfinal int a = sc.nextInt();\n\t\t\t\tfinal int r = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int rotate = 0; rotate < 5; rotate++){\n\t\t\t\t\tfinal int cur_angle = a + (360 / 5) * 2 * rotate + 90;\n\t\t\t\t\t\n\t\t\t\t\tfinal double cur_x = x + r * Math.cos(Math.toRadians(cur_angle));\n\t\t\t\t\tfinal double cur_y = y + r * Math.sin(Math.toRadians(cur_angle));\n\t\t\t\t\t//System.out.println(rotate + \" : \" + cur_x + \" \" + cur_y);\n\t\t\t\t\t\n\t\t\t\t\tfinal int prev_rotate = (5 + rotate - 2) % 5;\n\t\t\t\t\t\n\t\t\t\t\tlines[i][rotate][0] = lines[i][prev_rotate][1] = new Point2D(cur_x, cur_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] dist = new double[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\tif(i == j){\n\t\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdist[i][j] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int from = 0; from < N; from++){\n\t\t\t\tfor(int to = from + 1; to < N; to++){\n\t\t\t\t\tdouble min = INF + 1;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(int from_edge = 0; from_edge < 5; from_edge++){\n\t\t\t\t\t\tfor(int to_edge = 0; to_edge < 5; to_edge++){\n\t\t\t\t\t\t\tmin = Math.min(min, Point2D.ss_dist\n\t\t\t\t\t\t\t\t\t(lines[from][from_edge][0],\n\t\t\t\t\t\t\t\t\t lines[from][from_edge][1],\n\t\t\t\t\t\t\t\t\t lines[to][to_edge][0],\n\t\t\t\t\t\t\t\t\t lines[to][to_edge][1]));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdist[from][to] = dist[to][from] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.printf(\"%.9f\\n\", dist[M - 1][L - 1]);\n\t\t}\n\t}\n}\n\nclass Point2D implements Comparable<Point2D>{\n   public double x;\n   public double y;\n\n   public static final double EPS = 1e-13;\n\n   public Point2D(double x, double y) {\n       this.x = x;\n       this.y = y;\n   }\n\n   public Point2D(Point2D point) {\n       this.x = point.x;\n       this.y = point.y;\n   }\n\n   public String toString() {\n       return \"<\" + x + \" ,\" + y + \">\";\n   }\n\n   @Override\n   public boolean equals(Object o) {\n       if (o instanceof Point2D) {\n           Point2D another = (Point2D) o;\n            \n           if(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n               return true;\n           }\n            \n           return false;\n       }\n       return false;\n   }\n    \n   @Override\n   public int compareTo(Point2D arg0) {\n       if(this.equals(arg0)){\n           return 0;\n       }else if(Point2D.eq(this.x, arg0.x)){\n           return Point2D.signum(this.y - arg0.y);\n       }else {\n           return Point2D.signum(this.x - arg0.x);\n       }\n   }\n\n   public Point2D add(double x, double y) {\n       return new Point2D(this.x + x, this.y + y);\n   }\n\n   public Point2D sub(double x, double y) {\n       return add(-x, -y);\n   }\n\n   public Point2D add(Point2D another) {\n       return add(another.x, another.y);\n   }\n\n   public Point2D sub(Point2D another) {\n       return sub(another.x, another.y);\n   }\n\n   public Point2D mul(double d) {\n       return new Point2D(this.x * d, this.y * d);\n   }\n\n   public Point2D div(double d) {\n       return new Point2D(this.x / d, this.y / d);\n   }\n\n   public double dot(double x, double y) {\n       return this.x * x + this.y * y;\n   }\n\n   public double dot(Point2D another) {\n       return dot(another.x, another.y);\n   }\n\n   public double cross(double x, double y) {\n       return this.x * y - this.y * x;\n   }\n\n   public double cross(Point2D another) {\n       return cross(another.x, another.y);\n   }\n\n   public double dist(double x, double y) {\n       return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n               * (this.y - y));\n   }\n\n   public double dist(Point2D another) {\n       return dist(another.x, another.y);\n   }\n\n   public double dist_o() {\n       return dist(0, 0);\n   }\n    \n   public double dist2(double x, double y) {\n       return (this.x - x) * (this.x - x) + (this.y - y) * (this.y - y);\n   }\n    \n   public double dist2(Point2D another) {\n       return dist2(another.x, another.y);\n   }\n\n   public Point2D unit() {\n       return div(dist_o());\n   }\n\n   public boolean pol(Point2D start, Point2D end) {\n       return end.sub(start).cross(this.sub(start)) < EPS;\n   }\n\n   public boolean pos(Point2D start, Point2D end) {\n       return (Math.abs(start.dist(this) + this.dist(end) - start.dist(end))  <  EPS);\n   }\n\n   public double pld(Point2D start, Point2D end) {\n       return Math.abs((end.sub(start).cross(this.sub(start)))\n               / end.sub(start).dist_o());\n   }\n    \n   public double psd(Point2D start, Point2D end) {\n       if (end.sub(start).dot(this.sub(start)) < EPS) {\n           return this.dist(start);\n       } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n           return this.dist(end);\n       } else {\n           return Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n       }\n   }\n    \n   public static int signum(double x){\n       return Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n   }\n    \n   public static boolean eq(double x, double y){\n       return signum(x - y) == 0;\n   }\n    \n   public static int ccw(Point2D p, Point2D r, Point2D s){\n       Point2D a = r.sub(p);\n       Point2D b = s.sub(p);\n        \n       final int sgn = Point2D.signum(a.cross(b));\n       if(sgn != 0){\n           return sgn;\n       }else if(a.dot(b) < -EPS){\n           return -1;\n       }else if(a.dist_o() < b.dist_o() - EPS){\n           return 1;\n       }else{\n           return 0;\n       }\n   }\n    \n   public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       return (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n               && (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n   }\n\n   public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n   }\n\n   public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       Point2D b = b2.sub(b1);\n       double d1 = Math.abs(b.cross(a1.sub(b1)));\n       double d2 = Math.abs(b.cross(a2.sub(b1)));\n       double t = d1 / (d1 + d2);\n       Point2D a = a2.sub(a1), v = a.mul(t);\n       return a1.add(v);\n   }\n\n   public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       Point2D a = a2.sub(a1);\n       Point2D b = b2.sub(b1);\n       double t = b.cross(b1.sub(a1)) / b.cross(a);\n       Point2D v = a.mul(t);\n       return a1.add(v);\n   }\n\n   public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n           double r2) {\n       double dis = p1.dist(p2);\n\n       if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n           return new Point2D[0]; // same\n       }\n\n       if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n           Point2D tmp = p2.sub(p1);\n           tmp = tmp.mul(r1 / tmp.dist_o());\n           Point2D ret[] = new Point2D[1];\n           ret[0] = p1.add(tmp);\n           return ret;\n       } else if (dis + EPS > r1 + r2) {\n           return new Point2D[0]; // out\n       }\n\n       double dis_m = Math.abs(r1 - r2);\n\n       if (dis_m + EPS > dis && dis_m - EPS < dis) {\n           Point2D tmp = null;\n           if (r1 > r2) {\n               tmp = p2.sub(p1);\n           } else {\n               tmp = p1.sub(p2);\n           }\n\n           double min = Math.min(r1, r2);\n\n           tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n           Point2D ret[] = new Point2D[1];\n           ret[0] = p1.add(tmp);\n           return ret;\n       } else if (dis_m + EPS > dis) {\n           return new Point2D[0]; // inner\n       } else {\n           Point2D ret[] = new Point2D[2];\n\n           double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                   / (2 * dis * r1));\n           double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n           ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                   * Math.sin(a + theta) + p1.y);\n           ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                   * Math.sin(a - theta) + p1.y);\n           return ret;\n       }\n   }\n    \n   public static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n       if(Point2D.intersect_s(start1, end1, start2, end2)){\n           return 0;\n       }else{\n           return Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n       }\n   }\n    \n   public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n           Point2D ans[]) {\n       if (c.pld(start, end) > r + EPS)\n           return;\n       Point2D v = end.sub(start).unit();\n       double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n               - start.dist(c) * start.dist(c) + r * r;\n       double t = -v.dot(start.sub(c));\n       double s = Math.sqrt(delta);\n       ans[0] = start.add(v.mul(t + s));\n       ans[1] = start.add(v.mul(t + s));\n   }\n\n   public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n       Point2D v = b.sub(a).unit();\n       v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n               (-1) * v.y, v.x);\n       return v.mul(p.pld(a, b));\n   }\n\n   public double area(Point2D a, Point2D b, Point2D c) {\n       return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n   }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), l = sc.nextInt();\n\t\t\tif ((n|m|l) == 0) break;\n\t\t\tm--; l--;\n\n\t\t\tStar[] stars = new Star[n];\n\t\t\tfor (int i=0;i<n;i++) stars[i] = new Star(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\n\t\t\tdouble[][] d = new double[n][n];\n\t\t\tfor (int i=0;i<n;i++) for (int j=i+1;j<n;j++) {\n//\t\t\t\tdebug(\"star\", i, j);\n\t\t\t\td[i][j] = d[j][i] = stars[i].dist(stars[j]);\n\t\t\t}\n\n\t\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\t\tSystem.out.println(d[m][l]);\n\t\t}\n\t}\n\n\n\tdouble distSS (P p1, P p2, P q1, P q2) {\n\t\tif (cross(p1, p2, q1, q2)) return 0.0;\n\t\tdouble min = INF;\n\t\tmin = min(min, disSP(p1, p2, q1));\n\t\tmin = min(min, disSP(p1, p2, q2));\n\t\tmin = min(min, disSP(q1, q2, p1));\n\t\tmin = min(min, disSP(q1, q2, p2));\n\t\treturn min;\n\t}\n\n\t//テァツつケテ」ツ?ィテァツキツ堙・ツ按?」ツ?ョティツキツ敕ゥツ崢「\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).abs();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).abs();\n\t\treturn disLP(p1, p2, q);\n\t}\n\n\t//テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ョティツキツ敕ゥツ崢「\n\tdouble disLP(P p1, P p2, P q) {\n\t\treturn Math.abs(p2.sub(p1).det(q.sub(p1))) / p2.sub(p1).abs();\n\t}\n\n\t//テァツキツ堙・ツ按?、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t}\n\n\t//テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ偲・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ古ァツ崢エテァツキツ堙ァツ環カテ」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ古」ツ?ィテ」ツ?ォテ」ツ?凝」ツ?湘、ツスツ催ァツスツョテゥツ鳴「テ、ツソツづ」ツつ津」ツ?ソテ」ツつ?\n\tint ccw (P a, P b, P c) {\n\t\tP s = b.sub(a);\n\t\tP t = c.sub(a);\n\t\tif( s.det(t) > EPS ) return 1;\n\t\tif( s.det(t) < -EPS ) return -1;\n\t\tif( s.dot(t) < -EPS ) return 2;\n\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\treturn 0;\n\t}\n\n\tclass Star {\n\t\tdouble[] x, y;\n\t\tStar(int px, int py, int sh, int r) {\n\t\t\tx = new double[5];\n\t\t\ty = new double[5];\n\t\t\tfor (int i=0;i<5;i++) {\n\t\t\t\tx[i] = 1.0 * px - sin(1.0 * (i * 72 + sh) / 180.0 * PI) * r;\n\t\t\t\ty[i] = 1.0 * py + cos(1.0 * (i * 72 + sh) / 180.0 * PI) * r;\n\t\t\t}\n\t\t}\n\n\t\tdouble dist(Star s) {\n\t\t\tdouble min = INF;\n\t\t\tfor (int i=0;i<5;i++) for (int j=0;j<5;j++ ) {\n\t\t\t\tP p1 = new P(x[i], y[i]), p2 = new P(x[(i+2)%5], y[(i+2)%5]),\n\t\t\t\t  q1 = new P(s.x[j], s.y[j]), q2 = new P(s.x[(j+2)%5], s.y[(j+2)%5]);\n\t\t\t\tmin = min(min, distSS(p1, p2, q1, q2));\n//\t\t\t\tdebug(i, j, min);\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t}\n\n\tpublic class P {\n\t\tdouble EPS = 1e-10;\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble add(double a, double b) {\t//ティツェツ、テ・ツキツョテ」ツつ津ィツ?εヲツ?ョ\n\t\t\tif( Math.abs(a+b) < EPS * ( Math.abs(a) + Math.abs(b) ) ) return 0;\n\t\t\treturn a + b;\n\t\t}\n\n\t\tP add(P p) {\t//テ・ツ陳?\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p) {\t//テ・ツキツョ\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\n\t\tP mlt(double k) {\n\t\t\treturn new P(x*k, y*k);\n\t\t}\n\n\t\tdouble dot(P p) {\t//テ・ツ??ァツゥツ?\n\t\t\t\treturn add(x*p.x, y*p.y);\n\t\t}\n\n\t\tdouble det(P p) {\t//テ・ツ、ツ姪ァツゥツ?\n\t\t\treturn add(x*p.y, -y*p.x);\n\t\t}\n\n\t\t//ティツキツ敕ゥツ崢「テァツウツサ\n\t\tdouble abs() {\n\t\t\tdouble ret = sqrt( add(x*x, y*y) );\n\t\t\tif ( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble abs(P p) {\n\t\t\tdouble dx = add( x, -p.x );\n\t\t\tdouble dy = add( y, -p.y );\n\t\t\tdouble ret = sqrt( add(dx*dx, dy*dy) );\n\t\t\tif( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew D().doIt();\n\t}\n\n\tclass D {\n\t\t//??????????????? EDS Point2D????????????\n\t\tfinal double EPS = 1.0e-08;\n\t\t//????????¨?????????Arrays.sort(data, com);\n\t\tComparator< Point2D > com = new Comparator<Point2D>(){\n\t\t\tpublic int compare(Point2D o1,Point2D o2) {\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t//?§????\n\t\tprivate double angle(Point2D p1, Point2D p2){\n\t\t\tdouble a = dot(p1, p2);\n\t\t\tdouble b = abs(p1);\n\t\t\tdouble c = abs(p2);\n\t\t\tdouble cosTheta  = Math.acos(a/b/c);\n\t\t\treturn Math.toDegrees(cosTheta);\n\t\t}\n\t\t\n\t\t//?????\\\n\t\tprivate double dot(Point2D p1, Point2D p2){\n\t\t\treturn p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t}\n\t\t//?????¢????±??????????????¬???????norm???sort?????????????????????\n\t\tprivate double abs(Point2D p){\n\t\t\treturn Math.sqrt(p.getX() * p.getX() + p.getY() * p.getY());\n\t\t}\n\t\t\n\t\t//????????¨??????????????¢\n\t\tprivate double distanceSS(Line2D l, Line2D m){\n\t\t\tdouble ans = 0.0;\n\t\t\tif(! l.intersectsLine(m)){\n\t\t\t\tdouble res1 = l.ptSegDist(m.getP1());\n\t\t\t\tdouble res2 = l.ptSegDist(m.getP2());\n\t\t\t\tdouble res3 = m.ptSegDist(l.getP1());\n\t\t\t\tdouble res4 = m.ptSegDist(l.getP2());\n\t\t\t\tans = Math.min(Math.min(res1, res2),Math.min(res3, res4));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t//????????¨?????????????????????\n\t\tprivate boolean isIntersectSS(Line2D l, Line2D m){\n\t\t\treturn l.intersectsLine(m);\n\t\t}\n\t\t\n\t\t//??????????????????\n\t\tdouble cost[][];\n\t\tdouble d[];\n\t\tboolean used[];\n\t\tint V;\n\t\tvoid dijkstra(int s){\n\t\t\td[s] = 0;\n\t\t\twhile(true){\n\t\t\t\tint v = -1;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))v = u;\n\t\t\t\t}\n\t\t\t\tif(v == -1)break;\n\t\t\t\tused[v] = true;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\td[u] = Math.min(d[u], d[v] + cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint start = sc.nextInt();\n\t\t\t\tint goal = sc.nextInt();\n\t\t\t\tif(n+start+goal == 0)break;\n\t\t\t\tV = n;\n\t\t\t\tcost = new double[V][V];\n\t\t\t\td = new double[V];\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\td[i] = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused = new boolean[V];\n\t\t\t\tPoint2D.Double stard[][] = new Point2D.Double[n][5];\n\t\t\t\tLine2D.Double starl[][] = new Line2D.Double[n][5];\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tPoint2D.Double sstar = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\t\tdouble radi = sc.nextDouble();\n\t\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstard[i][j] = new Point2D.Double(r*Math.sin(Math.toRadians((72*j)-radi))+sstar.getX(),r*Math.cos(Math.toRadians((72*j)-radi))+sstar.getY());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstarl[i][j] = new Line2D.Double(stard[i][j],stard[i][(j+1)%5]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\tfor(int m = 0;m < V;m++){\n\t\t\t\t\t\tif(i == m){\n\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\t\tfor(int k = 0;k < 5;k++){\n\t\t\t\t\t\t\t\tif(isIntersectSS(starl[i][j],starl[m][k])){\n\t\t\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\t\t\tcost[m][i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcost[i][m] = Math.min(cost[i][m],distanceSS(starl[i][j],starl[m][k]));\n\t\t\t\t\t\t\t\t\tcost[m][i] = cost[i][m];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdijkstra(start-1);\n\t\t\t\tSystem.out.printf(\"%.15f\\n\",d[goal-1]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Line2D.Double;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n==0 && m==0 && l==0) break;\n\t\t\t\n\t\t\tLine2D.Double[] z = new Line2D.Double[5*n];\n\t\t\tdouble[] x = new double[5*n];\n\t\t\tdouble[] y = new double[5*n];\n\t\t\tdouble[][] cost = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tArrays.fill(cost[i], Integer.MAX_VALUE);\n\t\t\t\tcost[i][i] = 0;\n\t\t\t}\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\tdouble a = sc.nextDouble();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tx[5*i+j] = p - Math.sin((a+72*j)*Math.PI/180)*r;\n\t\t\t\t\ty[5*i+j] = q + Math.cos((a+72*j)*Math.PI/180)*r;\n\t\t\t\t}\n\t\t\t\tz[5*i] = new Line2D.Double(x[5*i], y[5*i], x[5*i+2], y[5*i+2]);\n\t\t\t\tz[5*i+1] = new Line2D.Double(x[5*i+2], y[5*i+2], x[5*i+4], y[5*i+4]);\n\t\t\t\tz[5*i+2] = new Line2D.Double(x[5*i+4], y[5*i+4], x[5*i+1], y[5*i+1]);\n\t\t\t\tz[5*i+3] = new Line2D.Double(x[5*i+1], y[5*i+1], x[5*i+3], y[5*i+3]);\n\t\t\t\tz[5*i+4] = new Line2D.Double(x[5*i+3], y[5*i+3], x[5*i], y[5*i]);\n\t\t\t\t\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int c=0;c<5;c++){\n\t\t\t\t\t\tfor(int d=0;d<5;d++){\n\t\t\t\t\t\t\tmin = Math.min(min, z[5*j+d].ptSegDist(x[5*i+c], y[5*i+c]));\n\t\t\t\t\t\t\tmin = Math.min(min, z[5*i+c].ptSegDist(x[5*j+d], y[5*j+d]));\n\t\t\t\t\t\t\tif(z[5*j+d].intersectsLine(z[5*i+c])==true){\n\t\t\t\t\t\t\t\tmin = 0;\n\t\t\t\t\t\t\t\tc = 5;\n\t\t\t\t\t\t\t\td = 5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcost[i][j] = min;\n\t\t\t\t\tcost[j][i] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(cost[j][i]!=Integer.MAX_VALUE && cost[i][k]!=Integer.MAX_VALUE){\n\t\t\t\t\t\t\tcost[j][k] = Math.min(cost[j][k], cost[j][i]+cost[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cost[m-1][l-1]);\t\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew D().doIt();\n\t}\n\n\tclass D {\n\t\t//??????????????? EDS Point2D????????????\n\t\tfinal double EPS = 1.0e-08;\n\t\t//????????¨?????????Arrays.sort(data, com);\n\t\tComparator< Point2D > com = new Comparator<Point2D>(){\n\t\t\tpublic int compare(Point2D o1,Point2D o2) {\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t//?§????\n\t\tprivate double angle(Point2D p1, Point2D p2){\n\t\t\tdouble a = dot(p1, p2);\n\t\t\tdouble b = abs(p1);\n\t\t\tdouble c = abs(p2);\n\t\t\tdouble cosTheta  = Math.acos(a/b/c);\n\t\t\treturn Math.toDegrees(cosTheta);\n\t\t}\n\t\t\n\t\t//?????\\\n\t\tprivate double dot(Point2D p1, Point2D p2){\n\t\t\treturn p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t}\n\t\t//?????¢????±??????????????¬???????norm???sort?????????????????????\n\t\tprivate double abs(Point2D p){\n\t\t\treturn Math.sqrt(p.getX() * p.getX() + p.getY() * p.getY());\n\t\t}\n\t\t\n\t\t//????????¨??????????????¢\n\t\tprivate double distanceSS(Line2D l, Line2D m){\n\t\t\tdouble ans = 0.0;\n\t\t\tif(! l.intersectsLine(m)){\n\t\t\t\tdouble res1 = l.ptSegDist(m.getP1());\n\t\t\t\tdouble res2 = l.ptSegDist(m.getP2());\n\t\t\t\tdouble res3 = m.ptSegDist(l.getP1());\n\t\t\t\tdouble res4 = m.ptSegDist(l.getP2());\n\t\t\t\tans = Math.min(Math.min(res1, res2),Math.min(res3, res4));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t//????????¨?????????????????????\n\t\tprivate boolean isIntersectSS(Line2D l, Line2D m){\n\t\t\treturn l.intersectsLine(m);\n\t\t}\n\t\t\n\t\t//??????????????????\n\t\tdouble cost[][];\n\t\tdouble d[];\n\t\tboolean used[];\n\t\tint V;\n\t\tvoid dijkstra(int s){\n\t\t\td[s] = 0;\n\t\t\twhile(true){\n\t\t\t\tint v = -1;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))v = u;\n\t\t\t\t}\n\t\t\t\tif(v == -1)break;\n\t\t\t\tused[v] = true;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\td[u] = Math.min(d[u], d[v] + cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint start = sc.nextInt();\n\t\t\t\tint goal = sc.nextInt();\n\t\t\t\tif(n+start+goal == 0)break;\n\t\t\t\tV = n;\n\t\t\t\tcost = new double[V][V];\n\t\t\t\td = new double[V];\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\td[i] = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused = new boolean[V];\n\t\t\t\tPoint2D.Double stard[][] = new Point2D.Double[n][5];\n\t\t\t\tLine2D.Double starl[][] = new Line2D.Double[n][5];\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tPoint2D.Double sstar = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\t\tdouble radi = sc.nextDouble();\n\t\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstard[i][j] = new Point2D.Double(r*Math.sin(Math.toRadians((72*j)-radi))+sstar.getX(),r*Math.cos(Math.toRadians((72*j)-radi))+sstar.getY());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstarl[i][j] = new Line2D.Double(stard[i][j],stard[i][(j+2)%5]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\tfor(int m = 0;m < V;m++){\n\t\t\t\t\t\tif(i == m){\n\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\t\tfor(int k = 0;k < 5;k++){\n\t\t\t\t\t\t\t\tif(isIntersectSS(starl[i][j],starl[m][k])){\n\t\t\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\t\t\tcost[m][i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcost[i][m] = Math.min(cost[i][m],distanceSS(starl[i][j],starl[m][k]));\n\t\t\t\t\t\t\t\t\tcost[m][i] = cost[i][m];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdijkstra(start-1);\n\t\t\t\tSystem.out.printf(\"%.15f\\n\",d[goal-1]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\tint n, s, g;\n\tdouble[][] map;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\ts = sc.nextInt(); g = sc.nextInt();\n\t\t\tif( (n|s|g) == 0 ) break;\n\t\t\ts--; g--;\n\t\t\t\n\t\t\tPent[] pents = new Pent[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tpents[i] = new Pent(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tmap = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\tmap[i][j] = map[j][i] = pents[i].d(pents[j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[j][k]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.10f\\n\", map[s][g]);\n\t\t\t\n\t\t}\n\t}\n\t\n\tclass Pent {\n\t\tP[] ps;\n\t\tPent (double x, double y, double a, double r) {\n\t\t\tps = new P[5];\n\t\t\tfor(int i=0;i<5;i++) {\n\t\t\t\tps[i] = new P( -sin( (a + 72 * i) * PI / 180 ) * r + x, cos( (a + 72 * i) * PI / 180 ) * r + y );\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble d(Pent p) {\n\t\t\tdouble d = disSP(ps[0], ps[2], p.ps[0]);\n\t\t\tfor(int i=0;i<5;i++) for(int j=0;j<5;j++){\n\t\t\t\tif( cross(ps[i], ps[(i+2)%5], p.ps[j], p.ps[(j+2)%5] ) ) return 0;\n\t\t\t\td = min( disSP(ps[i], ps[(i+2)%5], p.ps[j]), d );\n\t\t\t\td = min( disSP(p.ps[i], p.ps[(i+2)%5], ps[j]), d );\n\t\t\t}\n\t\t\treturn d;\n\t\t}\n\t}\n\t\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).len();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).len();\n\t\treturn disLP(p1, p2, q);\n\t}\n\t\n\tdouble disLP(P p1, P p2, P q) {\n\t\tdouble abs = abs ( p1.sub(p2).det(q.sub(p2)) ) / p1.sub(p2).len();\n\t\tif( abs < EPS ) return 0;\n\t\treturn abs;\n\t}\n\t\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\tif( max(p1.x, p2.x) + EPS < min(q1.x, q2.x) ) return false;\n\t\tif( max(p1.y, p2.x) + EPS < min(q1.y, q2.y) ) return false;\n\t\tif( max(q1.x, q2.x) + EPS < min(p1.x, p2.x) ) return false;\n\t\tif( max(q1.y, q2.x) + EPS < min(p1.y, p2.y) ) return false;\n\t\treturn abs( p1.sub(p2).det(q1) * p1.sub(p2).det(q2) ) < EPS &&\n\t\t\t   abs( q1.sub(q2).det(p1) * q1.sub(q2).det(p2) ) < EPS;\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP( double x, double y ) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tP add(P p) {\n\t\t\treturn new P(add(x,p.x), add(y,p.y));\n\t\t}\n\t\t\n\t\tP sub(P p) {\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tdouble dot(P p) {\n\t\t\treturn add( x*p.x, y*p.y );\n\t\t}\n\t\t\n\t\tdouble det(P p) {\n\t\t\treturn add( x*p.y, -y*p.x );\n\t\t}\n\t\t\n\t\tdouble len() {\n\t\t\tdouble abs = sqrt ( add(x*x, y*y) );\n\t\t\tif( abs(abs) < EPS ) return 0;\n\t\t\treturn abs;\n\t\t}\n\t\t\n\t\tdouble add(double a, double b) {\n\t\t\tif( abs(a+b) < EPS * ( abs(a) + abs(b) ) ) return 0;\n\t\t\treturn a+b;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  class Visualizer extends JFrame {\n    Visualizer() {\n      JPanel p = new JPanel();\n      getContentPane().add(p);\n      setSize(1000, 1000);\n      setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n    }\n\n    ArrayList<Integer> x0 = new ArrayList<>();\n    ArrayList<Integer> y0 = new ArrayList<>();\n    ArrayList<Integer> x1 = new ArrayList<>();\n    ArrayList<Integer> y1 = new ArrayList<>();\n\n    @Override\n    public void paint(Graphics g) {\n      super.paint(g);\n      drawLine(g);\n    }\n\n    void drawLine(Graphics g) {\n      Graphics2D g2 = (Graphics2D) g;\n      for (int i = 0; i < x0.size(); ++i) {\n        int x0 = this.x0.get(i);\n        int y0 = this.y0.get(i);\n        int x1 = this.x1.get(i);\n        int y1 = this.y1.get(i);\n        Line2D lin = new Line2D.Float(x0, y0, x1, y1);\n        g2.draw(lin);\n      }\n    }\n\n    void drawLine(int x0, int y0, int x1, int y1) {\n      this.x0.add(x0 + 100);\n      this.y0.add(1000 - y0);\n      this.x1.add(x1 + 100);\n      this.y1.add(1000 - y1);\n    }\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Gobousei {\n    ArrayList<LineSegment> list;\n\n    Gobousei(int x, int y, int a, int r) {\n      ArrayList<Point2D> sub = new ArrayList<>();\n      for (int i = 0; i < 5; ++i) {\n        double kakudo = a + 90 + ((i * 2) % 5) * 360.0 / 5.;\n        double radian = kakudo * Math.PI / 180.;\n        double dx = x + r * Math.cos(radian);\n        double dy = y + r * Math.sin(radian);\n        sub.add(new Point2D.Double(dx, dy));\n      }\n      list = new ArrayList<>();\n      for (int i = 0; i < 5; ++i) {\n        Point2D left = sub.get(i);\n        Point2D right = sub.get((i + 1) % 5);\n        LineSegment l = new LineSegment(left.getX(), left.getY(), right.getX(), right.getY());\n        list.add(l);\n      }\n    }\n\n    void draw(Visualizer v) {\n      for (int i = 0; i < 5; ++i) {\n        LineSegment l = list.get(i);\n        v.drawLine((int) (l.x1 * 10), (int) (l.y1 * 10), (int) (l.x2 * 10), (int) (l.y2 * 10));\n      }\n    }\n\n    double distance(Gobousei g) {\n      double min = Double.MAX_VALUE;\n      for (LineSegment l : list) {\n        for (LineSegment r : g.list) {\n          min = Math.min(min, l.distance(r));\n        }\n      }\n      return min;\n    }\n  }\n\n  class Node {\n    double d;\n    int i;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n, m, l;\n      n = ni();\n      m = ni() - 1;\n      l = ni() - 1;\n      if (n == 0) {\n        break;\n      }\n      ArrayList<Gobousei> list = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        int x, y, a, r;\n        x = ni();\n        y = ni();\n        a = ni();\n        r = ni();\n        list.add(new Gobousei(x, y, a, r));\n      }\n//      Visualizer v = new Visualizer();\n//      for (Gobousei g : list) {\n//        g.draw(v);\n//      }\n//      v.setVisible(true);\n      Node atom = new Node();\n      atom.d = 0;\n      atom.i = m;\n      PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.d));\n      queue.add(atom);\n      boolean[] done = new boolean[n];\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (done[node.i]) {\n          continue;\n        }\n        done[node.i] = true;\n        if (node.i == l) {\n          System.out.println(node.d);\n          break;\n        }\n        for (int i = 0; i < n; ++i) {\n          if (node.i == i) {\n            continue;\n          }\n          Node next = new Node();\n          Gobousei left = list.get(node.i);\n          Gobousei right = list.get(i);\n          next.d = left.distance(right) + node.d;\n          next.i = i;\n          queue.add(next);\n        }\n      }\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Star {\n\t\tint[] radian = {90, 234, 18, 162, 306};\n\t\tPoint2D.Double[] points = new Point2D.Double[5];\n\t\tLine2D.Double[] lines = new Line2D.Double[5];\n\t\t\n\t\tStar(int x, int y, int a, int r) {\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tpoints[i] = new Point2D.Double(r * Math.cos((radian[i] + a) / 360.0 * 2 * Math.PI) + x, r * Math.sin((radian[i] + a) / 360.0 * 2 * Math.PI) + y);\n\t\t\t}\n\t\t\tfor (int i = 0; i < lines.length; i++) {\n\t\t\t\tlines[i] = new Line2D.Double(points[i], points[(i+1) % 5]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tString s = \"\";\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\ts += \"(\" + points[i].x + \" \" + points[i].y + \")\\n\";\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\tdouble culcDist(Star s1, Star s2) {\n\t\tdouble res = Double.MAX_VALUE;\n\t\tfor (Line2D.Double line1 : s1.lines) {\n\t\t\tfor (Line2D.Double line2 : s2.lines) {\n\t\t\t\tif (line1.intersectsLine(line2)) return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Line2D.Double line1 : s1.lines) {\n\t\t\tfor (Point2D.Double point2 : s2.points) {\n\t\t\t\tres = Math.min(res, line1.ptSegDist(point2));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor (Line2D.Double line2 : s2.lines) {\n\t\t\tfor (Point2D.Double point1 : s1.points) {\n\t\t\t\tres = Math.min(res, line2.ptSegDist(point1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Point2D.Double point2 : s2.points) {\n\t\t\tfor (Point2D.Double point1 : s1.points) {\n\t\t\t\t//System.out.println(point2.distance(point1));\n\t\t\t\tres = Math.min(res, point2.distance(point1));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t/* -----------Dijkstra---------- */\n\tpublic class Dijkstra {\n\t\tprotected final static int INF = 1_000_000_000;\n\t\t\n\t\tclass State implements Comparable<State> {\n\t\t\tint n;\n\t\t\t\n\t\t\tState(int n) {\n\t\t\t\tthis.n = n;\n\t\t\t}\n\n\t\t\tpublic int compareTo(State s) {\n\t\t\t\tdouble c1 = res.minCost[n], c2 = res.minCost[s.n];\n\t\t\t\tif (c1 < c2) return -1;\n\t\t\t\telse if (c1 > c2) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDijkstraResult res;\n\t\tdouble[][] edge;\n\t\t\n\t\tDijkstra(double[][] edge) {\n\t\t\tthis.edge = edge;\n\t\t}\n\t\t\n\t\tDijkstraResult doit(int start) {\n\t\t\tint n = edge.length;\n\t\t\tres = new DijkstraResult(n);\n\t\t\tArrays.fill(res.minCost, Dijkstra.INF);\n\t\t\t\n\t\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(start));\n\t\t\tres.minCost[start] = 0;\n\t\t\tres.path[start] = start;\n\t\t\t\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tState s = pq.poll();\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (res.minCost[i] > res.minCost[s.n] + edge[s.n][i]) {\n\t\t\t\t\t\tres.minCost[i] = res.minCost[s.n] + edge[s.n][i];\n\t\t\t\t\t\tres.path[i] = s.n;\n\t\t\t\t\t\tpq.add(new State(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * it contains minCost and path from start node to each nodes.\n\t * @author hiro116s\n\t *\n\t */\n\tclass DijkstraResult {\n\t\tdouble[] minCost;\n\t\tint[] path;\n\t\t\n\t\tDijkstraResult(int n) {\n\t\t\tminCost = new double[n];\n\t\t\tpath = new int[n];\n\t\t}\n\t}\n\t\n\t/*-------------end--------------*/\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt(), l = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tStar[] stars = new Star[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt(), y = in.nextInt(), a = in.nextInt(), r = in.nextInt();\n\t\t\t\tstars[i] = new Star(x, y, a, r);\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] edge = new double[n][n];\n\t\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tedge[i][j] = culcDist(stars[i], stars[j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\t\t//System.out.println(stars[i].toString());\n\t\t\t\t//System.out.println(Arrays.toString(edge[i]));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(new Dijkstra(edge).doit(m-1).minCost[l-1]);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Solve{\n\tfinal Scanner in = new Scanner(System.in);\n\t\n\tstatic final double INF = 1e9;\n\tboolean solve(){\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt()-1;\n\t\tint l = in.nextInt()-1;\n\t\tif(n == 0) return false;\n\t\tdouble[][] dist = new double[n][n];\n\t\tStar[] st = new Star[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tst[i] = new Star(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(j==i) continue;\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tdist[i][j] = dist[j][i] = st[i].dist(st[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0; k<n; k++)\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\tSystem.out.println(dist[m][l]);\n\t\treturn true;\n\t}\n//\t\n//\tString dump(double[][] d, int n){\n//\t\t\n//\t}\n\t\n}\n\nclass Star{\n\tPos[] p;\n\tstatic final double EPS = 1e-10;\n\tstatic final double INF = 1e9;\n\tStar(int x, int y, int a, int r){\n\t\tp = new Pos[5];\n\t\tfor(int i=0; i<5; i++){\n\t\t\tdouble px = x + Math.cos(Math.toRadians(a+90+144*i))*r;\n\t\t\tdouble py = y + Math.sin(Math.toRadians(a+90+144*i))*r;\n\t\t\tp[i] = new Pos(px, py);\n\t\t}\n\t}\n\t\n\tdouble dist(Star s){\n\t\tdouble res = INF;\n\t\tfor(int i=0; i<5; i++){\n\t\t\tPos p1 = p[i];\n\t\t\tPos p2 = p[(i+1)%5];\n\t\t\tres = Math.min(res, s.dist(p1, p2));\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tdouble dist(Pos p1, Pos p2){\n\t\tdouble res = INF;\n\t\tfor(int i=0; i<5; i++){\n\t\t\tres = Math.min(res, vecdist(p1, p2, p[i]));\n\t\t\tif(cross(p1, p2, p[i], p[(i+1)%5])) return 0;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tboolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\tif(cross(a1.x - a2.x, a1.y-a2.y, b1.x-b2.x, b1.y-b2.y) == 0\n\t\t\t\t&& cross(a1.x-a2.x, a1.y-a2.y, a1.x-b2.x, a1.y-b2.y) == 0){\n\t\t\tif(Math.abs(a1.dist2(b1)+a2.dist2(b1) - a1.dist2(a1)) < EPS\n\t\t\t\t\t|| Math.abs(a1.dist2(b2)+a2.dist2(b2) - a1.dist2(a2)) < EPS){\n\t\t\t\treturn true;\n\t\t\t}else return false;\n\t\t}\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tdouble vecdist(Pos a, Pos b, Pos c){\n\t\tif(dot(b.x - a.x, b.y-a.y, c.x - a.x, c.y-a.y) <= EPS)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= EPS){\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\t}\n\t\treturn Math.abs(triarea(a, b, c)/Math.sqrt(a.dist2(b)));\n\t}\n\t\n\tdouble dot (double x, double y, double x1, double y1){\n\t\treturn x*x1 + y*y1;\n\t}\n\t\n\tdouble triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tdouble cross(double x1, double y1, double x2, double y2){\n\t\treturn x1*y2 - x2*y1;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tPos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tdouble dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y);\n\t}\n}\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tSolve solve = new Solve();\n\t\twhile(solve.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n List<Star>                stars  = new LinkedList<Star>();\n HashMap<Set<Star>, Route> routes = new HashMap<Set<Star>, Route>();\n\n public Main(int n) {\n }\n\n void add(int index, Star s) {\n\tstars.add(s);\n\tcreateRoute(s);\n }\n\n void createRoute(Star s) {\n\tHashSet<Star> set = new HashSet<Star>();\n\tfor (Star target : stars) {\n\t Bridge bridge = new Bridge(target, s);\n\t set.clear();\n\t set.addAll(Arrays.asList(s, target));\n\t Route route;\n\t if (routes.containsKey(set)) {\n\t\troute = routes.get(set);\n\t\tif (route.getLength() >= bridge.getLength()) route\n\t\t  .set(bridge);\n\t } else {\n\t\troute = new Route(s, bridge, target);\n\t\troutes.put(set, route);\n\t\tfor (Star s2 : stars) {\n\t\t set.clear();\n\t\t set.addAll(Arrays.asList(s2, target));\n\t\t Route newR = new Route(s, route, routes.get(set), s2);\n\t\t routes.put(new HashSet<Star>(Arrays.asList(s, s2)),\n\t\t\t newR);\n\t\t}\n\t }\n\t}\n }\n\n double getLength(int num, int num2) {\n\tStar s1 = stars.get(num - 1);\n\tStar s2 = stars.get(num2 - 1);\n\tfinal List<Star> asList = Arrays.asList(s1, s2);\n\tfinal HashSet<Star> hashSet = new HashSet<Star>(asList);\n\treturn routes.get(hashSet).getLength();\n\n }\n\n public static void main(String[] args) {\n\tScanner in = new Scanner(\"1 1 1\" +\n\t  \" 5 5 0 5\" +\n\t  \" 2 1 2\" +\n\t  \" 5 5 0 5\" +\n\t  \" 15 5 0 5\" +\n\t  \" 3 2 3\" +\n\t  \" 15 15 0 5\" +\n\t  \" 5 5 10 5\" +\n\t  \" 25 25 20 5\" +\n\t  \" 0 0 0\");\n\twhile (in.hasNext()) {\n\t int n = in.nextInt();\n\t int m = in.nextInt();\n\t int l = in.nextInt();\n\t if (n != 0) {\n\t\tMain main = new Main(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t int x = in.nextInt();\n\t\t int y = in.nextInt();\n\t\t int theta = in.nextInt();\n\t\t int r = in.nextInt();\n\t\t Star star = new Star(x, y, theta, r);\n\t\t main.add(i, star);\n\t\t}\n\t\tSystem.out.println(main.getLength(m, l));\n\t }\n\t}\n }\n}\n\nclass Star {\n static AffineTransform affin = new AffineTransform();\n final int              x, y;\n final List<Point2D>    pts;\n\n Star(int x, int y, int theta, int r) {\n\tthis.x = x;\n\tthis.y = y;\n\tPoint2D.Double orign = new Point2D.Double(x, y + r);\n\tfinal List<Point2D> tg = new ArrayList<Point2D>();\n\tfor (int i = 0; i < 5; i++) {\n\t final double j = Math.toRadians(theta + 360 / 5 * 2 * i);\n\t affin.setToRotation(j, x, y);\n\t final Point2D setP =\n\t\t affin.transform(orign, new Point2D.Double());\n\t tg.add(setP);\n\t}\n\tpts = Collections.unmodifiableList(tg);\n }\n\n static double getSpan(Star s1, Star s2) {\n\tfinal Line2D.Double s1L = new Line2D.Double();\n\tfinal Line2D.Double s2L = new Line2D.Double();\n\tdouble min = Double.MAX_VALUE;\n\tfor (int i = 0; i < 5; i++) {\n\t if (min != 0.0) {\n\t\ts1L.setLine(s1.pts.get(i), s1.pts.get((i + 1) % 5));\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t s2L.setLine(s2.pts.get(j), s2.pts.get((j + 1) % 5));\n\t\t if (min == 0.0 || s1L.intersectsLine(s2L)) {\n\t\t\tmin = 0.0;\n\t\t } else {\n\t\t\tmin = Math.min(min, s1L.ptSegDist(s2L.x1, s2L.y1));\n\t\t\tmin = Math.min(min, s1L.ptSegDist(s2L.x2, s2L.y2));\n\t\t\tmin = Math.min(min, s2L.ptSegDist(s1L.x1, s1L.y1));\n\t\t\tmin = Math.min(min, s2L.ptSegDist(s1L.x2, s1L.y2));\n\t\t }\n\t\t}\n\t }\n\t}\n\treturn min;\n }\n}\n\nabstract class Road {\n abstract double getLength();\n}\n\nclass Route extends Road {\n final Set<Star>  sideStar;\n final List<Road> route = new LinkedList<Road>();\n\n Route(Star s1, Bridge bridge, Star s2) {\n\tthis.sideStar = new HashSet<Star>(Arrays.asList(s1, s2));\n\troute.add(bridge);\n }\n\n public Route(Star s1, Route route2, Route route3, Star s2) {\n\tthis.sideStar = new HashSet<Star>(Arrays.asList(s1, s2));\n\troute.add(route2);\n\troute.add(route3);\n }\n\n void set(Road... routes) {\n\troute.clear();\n\troute.addAll(Arrays.asList(routes));\n }\n\n @Override\n double getLength() {\n\tdouble result = 0.0;\n\tfor (Road r : route) {\n\t result += r.getLength();\n\t}\n\treturn result;\n }\n}\n\nclass Bridge extends Road {\n final double span;\n\n Bridge(Star s1, Star s2) {\n\tspan = Star.getSpan(s1, s2);\n }\n\n @Override\n double getLength() {\n\treturn span;\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Solve{\n\tfinal Scanner in = new Scanner(System.in);\n\t\n\tstatic final double INF = 1e9;\n\tboolean solve(){\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt()-1;\n\t\tint l = in.nextInt()-1;\n\t\tif(n == 0) return false;\n\t\tdouble[][] dist = new double[n][n];\n\t\tStar[] st = new Star[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tst[i] = new Star(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(j==i) continue;\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tdist[i][j] = dist[j][i] = st[i].dist(st[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0; k<n; k++)\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\tSystem.out.println(dist[m][l]);\n\t\treturn true;\n\t}\n//\t\n//\tString dump(double[][] d, int n){\n//\t\t\n//\t}\n\t\n}\n\nclass Star{\n\tPos[] p;\n\tstatic final double EPS = 1e-10;\n\tstatic final double INF = 1e9;\n\tStar(int x, int y, int a, int r){\n\t\tp = new Pos[5];\n\t\tfor(int i=0; i<5; i++){\n\t\t\tdouble px = x + Math.cos(Math.toRadians(a+90+144*i))*r;\n\t\t\tdouble py = y + Math.sin(Math.toRadians(a+90+144*i))*r;\n\t\t\tp[i] = new Pos(px, py);\n\t\t}\n\t}\n\t\n\tdouble dist(Star s){\n\t\tdouble res = INF;\n\t\tfor(int i=0; i<5; i++){\n\t\t\tPos p1 = p[i];\n\t\t\tPos p2 = p[(i+1)%5];\n\t\t\tres = Math.min(res, s.dist(p1, p2));\n\t\t\tres = Math.min(res, dist(s.p[i], s.p[(i+1)%5]));\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tdouble dist(Pos p1, Pos p2){\n\t\tdouble res = INF;\n\t\tfor(int i=0; i<5; i++){\n\t\t\tres = Math.min(res, vecdist(p1, p2, p[i]));\n\t\t\tif(cross(p1, p2, p[i], p[(i+1)%5])) return 0;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tboolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\tif(cross(a1.x - a2.x, a1.y-a2.y, b1.x-b2.x, b1.y-b2.y) == 0\n\t\t\t\t&& cross(a1.x-a2.x, a1.y-a2.y, a1.x-b2.x, a1.y-b2.y) == 0){\n\t\t\tif(Math.abs(a1.dist2(b1)+a2.dist2(b1) - a1.dist2(a1)) < EPS\n\t\t\t\t\t|| Math.abs(a1.dist2(b2)+a2.dist2(b2) - a1.dist2(a2)) < EPS){\n\t\t\t\treturn true;\n\t\t\t}else return false;\n\t\t}\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tdouble vecdist(Pos a, Pos b, Pos c){\n\t\tif(dot(b.x - a.x, b.y-a.y, c.x - a.x, c.y-a.y) <= EPS)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= EPS){\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\t}\n\t\treturn Math.abs(triarea(a, b, c)/Math.sqrt(a.dist2(b)));\n\t}\n\t\n\tdouble dot (double x, double y, double x1, double y1){\n\t\treturn x*x1 + y*y1;\n\t}\n\t\n\tdouble triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tdouble cross(double x1, double y1, double x2, double y2){\n\t\treturn x1*y2 - x2*y1;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tPos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tdouble dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y);\n\t}\n}\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tSolve solve = new Solve();\n\t\twhile(solve.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ2402().doIt();\n\t}\n\tclass AOJ2402{\n\t\tint n,m,l;\n\t\tArrayList<ArrayList<Line2D>> stars;\n\t\tdouble[][] cost;\n\t\tint INF = Integer.MAX_VALUE/2;\n\t\tvoid makeLine(int x,int y,int a,int r){\n\t\t\tstars.add(new ArrayList<Line2D>());\n\t\t\tPoint2D[] p = new Point2D[5];\n\t\t\tint angle = -a;\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tRobot robot = new Robot(x, y ,angle);\n\t\t\t\trobot.fd(r);\n\t\t\t\tp[i] = robot.toPoint();\n\t\t\t\t//\t System.out.println(p[i]);\n\t\t\t\tangle+=72;\n\t\t\t}\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tPoint2D p1 = p[i];\n\t\t\t\tPoint2D p2 = p[(i+1)%5];\n\t\t\t\tLine2D l = new Line2D.Double(p1, p2);\n\t\t\t\tstars.get(stars.size()-1).add(l);\n\t\t\t}\n\t\t\t//\t for(int i=0;i<stars.get(stars.size()-1).size();i++){\n\t\t\t//\t System.out.println(stars.get(stars.size()-1).get(i).getP1()+\" \"+stars.get(stars.size()-1).get(i).getP2());\n\t\t\t//\t }\n\t\t}\n\t\tvoid input(){\n\t\t\tfor(int i=0;i<n;i++)makeLine(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t}\n\t\tvoid getMin(){\n\t\t\tfor(int i=0;i<n;i++)for(int s=i;s<n;s++){\n\t\t\t\tif(s==i){\n\t\t\t\t\tcost[i][s]=cost[s][i]=0;continue;\n\t\t\t\t}\n\t\t\t\tdouble min = INF;\n\t\t\t\tfor(int k=0;k<5;k++)for(int j=0;j<5;j++){\n\t\t\t\t\tmin = Math.min(min, segSegDist(stars.get(i).get(k),stars.get(s).get(j)));\n\t\t\t\t}\n\t\t\t\tcost[i][s] = cost[s][i] = min;\n\t\t\t}\n\t\t}\n\n\t\tvoid solve(){\n\t\t\tstars = new ArrayList<ArrayList<Line2D>>();//★の線\n\t\t\tinput();\n\t\t\tcost = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++)Arrays.fill(cost[i], INF);\n\t\t\tgetMin();\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\tfor(int s=0;s<n;s++)System.out.print(cost[i][s]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\tq.add(new State(m,0.0));\n\t\t\tdouble memo[] = new double[n];\n\t\t\tmemo[m]=0.0;\n\t\t\tdouble result = -1;\n\t\t\tArrays.fill(memo, INF);\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n//\t\t\t\tSystem.out.println(now.v+\" \"+now.cost);\n\t\t\t\tint v = now.v;\n\t\t\t\tdouble c = now.cost;\n\t\t\t\tif(v==l){\n\t\t\t\t\tresult = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++)if(cost[v][i]!=INF){\n\t\t\t\t\tdouble ncost = c+cost[v][i];\n\t\t\t\t\tif(memo[i] <= ncost)continue;\n\t\t\t\t\tmemo[i] = ncost;\n//\t\t\t\t\tSystem.out.println(v+\" \"+i+\" \"+ncost);\n\t\t\t\t\tq.add(new State(i, ncost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.10f\\n\",result);\n\t\t}\n\t\tvoid doIt(){\n\t\t\twhile(in.hasNext()){\n\t\t\t\tn = in.nextInt();\n\t\t\t\tm = in.nextInt();\n\t\t\t\tl =in.nextInt();\n\t\t\t\tif(n+m+l==0)break;\n\t\t\t\tm--;l--;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\n\t\tdouble segSegDist(Line2D l1,Line2D l2){\n\t\t\treturn l1.intersectsLine(l2)? 0:Math.min(Math.min(l1.ptSegDist(l2.getP1()),l1.ptSegDist(l2.getP2())),Math.min(l2.ptSegDist(l1.getP1()), l2.ptSegDist(l1.getP2())));\n\t\t}\n\n\t\tclass Robot{\n\t\t\tdouble x,y,angle;\n\t\t\tpublic Robot(int x,int y, int angle) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.angle = angle;\n\t\t\t}\n\t\t\tvoid fd(int go){\n\t\t\t\tx += Math.sin(Math.PI*angle/180.0)*go;\n\t\t\t\ty += Math.cos(Math.PI*angle/180.0)*go;\n\t\t\t}\n\t\t\tPoint2D toPoint(){\n\t\t\t\treturn new Point2D.Double(x,y);\n\t\t\t}\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tdouble cost;\n\t\t\tint v;\n\t\t\tpublic State(int v,double cost) {\n\t\t\t\tthis.v = v;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\tpublic int compareTo(State o) {\n\t\t\t\tif(this.cost > o.cost)return 1;\n\t\t\t\telse if(this.cost < o.cost)return -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Star {\n\t\tint[] radian = {90, 234, 18, 162, 306};\n\t\tPoint2D.Double[] points = new Point2D.Double[5];\n\t\tLine2D.Double[] lines = new Line2D.Double[5];\n\t\t\n\t\tStar(int x, int y, int a, int r) {\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tpoints[i] = new Point2D.Double(r * Math.cos((radian[i] + a) / 360.0 * 2 * Math.PI) + x, r * Math.sin((radian[i] + a) / 360.0 * 2 * Math.PI) + y);\n\t\t\t}\n\t\t\tfor (int i = 0; i < lines.length; i++) {\n\t\t\t\tlines[i] = new Line2D.Double(points[i], points[(i+1) % 5]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tString s = \"\";\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\ts += \"(\" + points[i].x + \" \" + points[i].y + \")\\n\";\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\tdouble culcDist(Star s1, Star s2) {\n\t\tdouble res = Double.MAX_VALUE;\n\t\tfor (Line2D.Double line1 : s1.lines) {\n\t\t\tfor (Line2D.Double line2 : s2.lines) {\n\t\t\t\tif (line1.intersectsLine(line2)) return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Line2D.Double line1 : s1.lines) {\n\t\t\tfor (Point2D.Double point2 : s2.points) {\n\t\t\t\tres = Math.min(res, line1.ptSegDist(point2));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor (Line2D.Double line2 : s2.lines) {\n\t\t\tfor (Point2D.Double point1 : s1.points) {\n\t\t\t\tres = Math.min(res, line2.ptSegDist(point1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Point2D.Double point2 : s2.points) {\n\t\t\tfor (Point2D.Double point1 : s1.points) {\n\t\t\t\t//System.out.println(point2.distance(point1));\n\t\t\t\tres = Math.min(res, point2.distance(point1));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t/* -----------Dijkstra---------- */\n\tpublic class Dijkstra {\n\t\tfinal static int INF = 1000000000;\n\t\t\n\t\tclass State implements Comparable<State> {\n\t\t\tint n;\n\t\t\t\n\t\t\tState(int n) {\n\t\t\t\tthis.n = n;\n\t\t\t}\n\n\t\t\tpublic int compareTo(State s) {\n\t\t\t\tdouble c1 = res.minCost[n], c2 = res.minCost[s.n];\n\t\t\t\tif (c1 < c2) return -1;\n\t\t\t\telse if (c1 > c2) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDijkstraResult res;\n\t\tdouble[][] edge;\n\t\t\n\t\tDijkstra(double[][] edge) {\n\t\t\tthis.edge = edge;\n\t\t}\n\t\t\n\t\tDijkstraResult doit(int start) {\n\t\t\tint n = edge.length;\n\t\t\tres = new DijkstraResult(n);\n\t\t\tArrays.fill(res.minCost, Dijkstra.INF);\n\t\t\t\n\t\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(start));\n\t\t\tres.minCost[start] = 0;\n\t\t\tres.path[start] = start;\n\t\t\t\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tState s = pq.poll();\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (res.minCost[i] > res.minCost[s.n] + edge[s.n][i]) {\n\t\t\t\t\t\tres.minCost[i] = res.minCost[s.n] + edge[s.n][i];\n\t\t\t\t\t\tres.path[i] = s.n;\n\t\t\t\t\t\tpq.add(new State(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * it contains minCost and path from start node to each nodes.\n\t * @author hiro116s\n\t *\n\t */\n\tclass DijkstraResult {\n\t\tdouble[] minCost;\n\t\tint[] path;\n\t\t\n\t\tDijkstraResult(int n) {\n\t\t\tminCost = new double[n];\n\t\t\tpath = new int[n];\n\t\t}\n\t}\n\t\n\t/*-------------end--------------*/\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt(), l = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tStar[] stars = new Star[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt(), y = in.nextInt(), a = in.nextInt(), r = in.nextInt();\n\t\t\t\tstars[i] = new Star(x, y, a, r);\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] edge = new double[n][n];\n\t\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tedge[i][j] = culcDist(stars[i], stars[j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\t\t//System.out.println(stars[i].toString());\n\t\t\t\t//System.out.println(Arrays.toString(edge[i]));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(new Dijkstra(edge).doit(m-1).minCost[l-1]);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Star {\n\t\tint[] radian = {90, 234, 18, 162, 306};\n\t\tPoint2D.Double[] points = new Point2D.Double[5];\n\t\tLine2D.Double[] lines = new Line2D.Double[5];\n\t\t\n\t\tStar(int x, int y, int a, int r) {\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tpoints[i] = new Point2D.Double(r * Math.cos((radian[i] + a) / 360.0 * 2 * Math.PI) + x, r * Math.sin((radian[i] + a) / 360.0 * 2 * Math.PI) + y);\n\t\t\t}\n\t\t\tfor (int i = 0; i < lines.length; i++) {\n\t\t\t\tlines[i] = new Line2D.Double(points[i], points[(i+1) % 5]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tString s = \"\";\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\ts += \"(\" + points[i].x + \" \" + points[i].y + \")\\n\";\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\tdouble culcDist(Star s1, Star s2) {\n\t\tdouble res = Double.MAX_VALUE;\n\t\tfor (Line2D.Double line1 : s1.lines) {\n\t\t\tfor (Line2D.Double line2 : s2.lines) {\n\t\t\t\tif (line1.intersectsLine(line2)) return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Line2D.Double line1 : s1.lines) {\n\t\t\tfor (Point2D.Double point2 : s2.points) {\n\t\t\t\tres = Math.min(res, line1.ptSegDist(point2));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor (Line2D.Double line2 : s2.lines) {\n\t\t\tfor (Point2D.Double point1 : s1.points) {\n\t\t\t\tres = Math.min(res, line2.ptSegDist(point1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Point2D.Double point2 : s2.points) {\n\t\t\tfor (Point2D.Double point1 : s1.points) {\n\t\t\t\t//System.out.println(point2.distance(point1));\n\t\t\t\tres = Math.min(res, point2.distance(point1));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t/* -----------Dijkstra---------- */\n\tpublic class Dijkstra {\n\t\tfinal static int INF = 1_000_000_000;\n\t\t\n\t\tclass State implements Comparable<State> {\n\t\t\tint n;\n\t\t\t\n\t\t\tState(int n) {\n\t\t\t\tthis.n = n;\n\t\t\t}\n\n\t\t\tpublic int compareTo(State s) {\n\t\t\t\tdouble c1 = res.minCost[n], c2 = res.minCost[s.n];\n\t\t\t\tif (c1 < c2) return -1;\n\t\t\t\telse if (c1 > c2) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDijkstraResult res;\n\t\tdouble[][] edge;\n\t\t\n\t\tDijkstra(double[][] edge) {\n\t\t\tthis.edge = edge;\n\t\t}\n\t\t\n\t\tDijkstraResult doit(int start) {\n\t\t\tint n = edge.length;\n\t\t\tres = new DijkstraResult(n);\n\t\t\tArrays.fill(res.minCost, Dijkstra.INF);\n\t\t\t\n\t\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(start));\n\t\t\tres.minCost[start] = 0;\n\t\t\tres.path[start] = start;\n\t\t\t\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tState s = pq.poll();\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (res.minCost[i] > res.minCost[s.n] + edge[s.n][i]) {\n\t\t\t\t\t\tres.minCost[i] = res.minCost[s.n] + edge[s.n][i];\n\t\t\t\t\t\tres.path[i] = s.n;\n\t\t\t\t\t\tpq.add(new State(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * it contains minCost and path from start node to each nodes.\n\t * @author hiro116s\n\t *\n\t */\n\tclass DijkstraResult {\n\t\tdouble[] minCost;\n\t\tint[] path;\n\t\t\n\t\tDijkstraResult(int n) {\n\t\t\tminCost = new double[n];\n\t\t\tpath = new int[n];\n\t\t}\n\t}\n\t\n\t/*-------------end--------------*/\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt(), l = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tStar[] stars = new Star[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt(), y = in.nextInt(), a = in.nextInt(), r = in.nextInt();\n\t\t\t\tstars[i] = new Star(x, y, a, r);\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] edge = new double[n][n];\n\t\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tedge[i][j] = culcDist(stars[i], stars[j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\t\t//System.out.println(stars[i].toString());\n\t\t\t\t//System.out.println(Arrays.toString(edge[i]));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(new Dijkstra(edge).doit(m-1).minCost[l-1]);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew D().doIt();\n\t}\n\n\tclass D {\n\t\t//??????????????? EDS Point2D????????????\n\t\tfinal double EPS = 1.0e-08;\n\t\t//????????¨?????????Arrays.sort(data, com);\n\t\tComparator< Point2D > com = new Comparator<Point2D>(){\n\t\t\tpublic int compare(Point2D o1,Point2D o2) {\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t//?§????\n\t\tprivate double angle(Point2D p1, Point2D p2){\n\t\t\tdouble a = dot(p1, p2);\n\t\t\tdouble b = abs(p1);\n\t\t\tdouble c = abs(p2);\n\t\t\tdouble cosTheta  = Math.acos(a/b/c);\n\t\t\treturn Math.toDegrees(cosTheta);\n\t\t}\n\t\t\n\t\t//?????\\\n\t\tprivate double dot(Point2D p1, Point2D p2){\n\t\t\treturn p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t}\n\t\t//?????¢????±??????????????¬???????norm???sort?????????????????????\n\t\tprivate double abs(Point2D p){\n\t\t\treturn Math.sqrt(p.getX() * p.getX() + p.getY() * p.getY());\n\t\t}\n\t\t\n\t\t//????????¨??????????????¢\n\t\tprivate double distanceSS(Line2D l, Line2D m){\n\t\t\tdouble ans = 0.0;\n\t\t\tif(! l.intersectsLine(m)){\n\t\t\t\tdouble res1 = l.ptSegDist(m.getP1());\n\t\t\t\tdouble res2 = l.ptSegDist(m.getP2());\n\t\t\t\tdouble res3 = m.ptSegDist(l.getP1());\n\t\t\t\tdouble res4 = m.ptSegDist(l.getP2());\n\t\t\t\tans = Math.min(Math.min(res1, res2),Math.min(res3, res4));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t//????????¨?????????????????????\n\t\tprivate boolean isIntersectSS(Line2D l, Line2D m){\n\t\t\treturn l.intersectsLine(m);\n\t\t}\n\t\t\n\t\t//??????????????????\n\t\tdouble cost[][];\n\t\tdouble d[];\n\t\tboolean used[];\n\t\tint V;\n\t\tvoid dijkstra(int s){\n\t\t\td[s] = 0;\n\t\t\twhile(true){\n\t\t\t\tint v = -1;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))v = u;\n\t\t\t\t}\n\t\t\t\tif(v == -1)break;\n\t\t\t\tused[v] = true;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\td[u] = Math.min(d[u], d[v] + cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint start = sc.nextInt();\n\t\t\t\tint goal = sc.nextInt();\n\t\t\t\tif(n+start+goal == 0)break;\n\t\t\t\tV = n;\n\t\t\t\tcost = new double[V][V];\n\t\t\t\td = new double[V];\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\td[i] = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused = new boolean[V];\n\t\t\t\tPoint2D.Double stard[][] = new Point2D.Double[n][5];\n\t\t\t\tLine2D.Double starl[][] = new Line2D.Double[n][5];\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tPoint2D.Double sstar = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\t\tdouble radi = sc.nextDouble();\n\t\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstard[i][j] = new Point2D.Double(r*Math.sin(Math.toRadians(360+(72*j)-radi))+sstar.getX(),r*Math.cos(Math.toRadians(360+(72*j)-radi))+sstar.getY());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstarl[i][j] = new Line2D.Double(stard[i][j],stard[i][(j+1)%5]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\tfor(int m = 0;m < V;m++){\n\t\t\t\t\t\tif(i == m){\n\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\t\tfor(int k = 0;k < 5;k++){\n\t\t\t\t\t\t\t\tif(isIntersectSS(starl[i][j],starl[m][k])){\n\t\t\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\t\t\tcost[m][i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcost[i][m] = Math.min(cost[i][m],distanceSS(starl[i][j],starl[m][k]));\n\t\t\t\t\t\t\t\t\tcost[m][i] = cost[i][m];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdijkstra(start-1);\n\t\t\t\tSystem.out.printf(\"%.10f\\n\",d[goal-1]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), l = sc.nextInt();\n\t\t\tif ((n|m|l) == 0) break;\n\t\t\tm--; l--;\n\n\t\t\tStar[] stars = new Star[n];\n\t\t\tfor (int i=0;i<n;i++) stars[i] = new Star(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\n\t\t\tdouble[][] d = new double[n][n];\n\t\t\tfor (int i=0;i<n;i++) for (int j=i+1;j<n;j++) {\n//\t\t\t\tdebug(\"star\", i, j);\n\t\t\t\td[i][j] = d[j][i] = stars[i].dist(stars[j]);\n\t\t\t}\n\n\t\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\t\tSystem.out.println(d[m][l]);\n\t\t}\n\t}\n\n\n\tdouble distSS (P p1, P p2, P q1, P q2) {\n\t\tif (cross(p1, p2, q1, q2)) return 0.0;\n\t\tdouble min = INF;\n\t\tmin = min(min, disSP(p1, p2, q1));\n\t\tmin = min(min, disSP(p1, p2, q2));\n\t\tmin = min(min, disSP(q1, q2, p1));\n\t\tmin = min(min, disSP(q1, q2, p2));\n\t\treturn min;\n\t}\n\n\t//テァツつケテ」ツ?ィテァツキツ堙・ツ按?」ツ?ョティツキツ敕ゥツ崢「\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).abs();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).abs();\n\t\treturn disLP(p1, p2, q);\n\t}\n\n\t//テァツつケテ」ツ?ィテァツ崢エテァツキツ堙」ツ?ョティツキツ敕ゥツ崢「\n\tdouble disLP(P p1, P p2, P q) {\n\t\treturn Math.abs(p2.sub(p1).det(q.sub(p1))) / p2.sub(p1).abs();\n\t}\n\n\t//テァツキツ堙・ツ按?、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t}\n\n\t//テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ偲・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ古ァツ崢エテァツキツ堙ァツ環カテ」ツ?ェテ」ツ?ョテ」ツ?凝ッツシツ古」ツ?ィテ」ツ?ォテ」ツ?凝」ツ?湘、ツスツ催ァツスツョテゥツ鳴「テ、ツソツづ」ツつ津」ツ?ソテ」ツつ?\n\tint ccw (P a, P b, P c) {\n\t\tP s = b.sub(a);\n\t\tP t = c.sub(a);\n\t\tif( s.det(t) > EPS ) return 1;\n\t\tif( s.det(t) < -EPS ) return -1;\n\t\tif( s.dot(t) < -EPS ) return 2;\n\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\treturn 0;\n\t}\n\n\tclass Star {\n\t\tP[] p;\n\t\tStar(int px, int py, int sh, int r) {\n\t\t\tp = new P[5];\n\t\t\tfor (int i=0;i<5;i++) {\n\t\t\t\tp[i] = new P(1.0 * px - sin(1.0 * (i * 72 + sh) / 180.0 * PI) * r,\n\t\t\t\t\t\t\t 1.0 * py + cos(1.0 * (i * 72 + sh) / 180.0 * PI) * r);\n\t\t\t}\n\t\t}\n\n\t\tdouble dist(Star s) {\n\t\t\tdouble min = INF;\n\t\t\tfor (int i=0;i<5;i++) for (int j=0;j<5;j++ ) {\n\t\t\t\tmin = min(min, distSS(p[i], p[(i+2)%5], s.p[j], s.p[(j+2)%5]));\n//\t\t\t\tdebug(i, j, min);\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t}\n\n\tpublic class P {\n\t\tdouble EPS = 1e-10;\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble add(double a, double b) {\t//ティツェツ、テ・ツキツョテ」ツつ津ィツ?εヲツ?ョ\n\t\t\tif( Math.abs(a+b) < EPS * ( Math.abs(a) + Math.abs(b) ) ) return 0;\n\t\t\treturn a + b;\n\t\t}\n\n\t\tP add(P p) {\t//テ・ツ陳?\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p) {\t//テ・ツキツョ\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\n\t\tP mlt(double k) {\n\t\t\treturn new P(x*k, y*k);\n\t\t}\n\n\t\tdouble dot(P p) {\t//テ・ツ??ァツゥツ?\n\t\t\t\treturn add(x*p.x, y*p.y);\n\t\t}\n\n\t\tdouble det(P p) {\t//テ・ツ、ツ姪ァツゥツ?\n\t\t\treturn add(x*p.y, -y*p.x);\n\t\t}\n\n\t\t//ティツキツ敕ゥツ崢「テァツウツサ\n\t\tdouble abs() {\n\t\t\tdouble ret = sqrt( add(x*x, y*y) );\n\t\t\tif ( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble abs(P p) {\n\t\t\tdouble dx = add( x, -p.x );\n\t\t\tdouble dy = add( y, -p.y );\n\t\t\tdouble ret = sqrt( add(dx*dx, dy*dy) );\n\t\t\tif( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew D().doIt();\n\t}\n\n\tclass D {\n\t\t//??????????????? EDS Point2D????????????\n\t\tfinal double EPS = 1.0e-08;\n\t\t//????????¨?????????Arrays.sort(data, com);\n\t\tComparator< Point2D > com = new Comparator<Point2D>(){\n\t\t\tpublic int compare(Point2D o1,Point2D o2) {\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t//?§????\n\t\tprivate double angle(Point2D p1, Point2D p2){\n\t\t\tdouble a = dot(p1, p2);\n\t\t\tdouble b = abs(p1);\n\t\t\tdouble c = abs(p2);\n\t\t\tdouble cosTheta  = Math.acos(a/b/c);\n\t\t\treturn Math.toDegrees(cosTheta);\n\t\t}\n\t\t\n\t\t//?????\\\n\t\tprivate double dot(Point2D p1, Point2D p2){\n\t\t\treturn p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t}\n\t\t//?????¢????±??????????????¬???????norm???sort?????????????????????\n\t\tprivate double abs(Point2D p){\n\t\t\treturn Math.sqrt(p.getX() * p.getX() + p.getY() * p.getY());\n\t\t}\n\t\t\n\t\t//????????¨??????????????¢\n\t\tprivate double distanceSS(Line2D l, Line2D m){\n\t\t\tdouble ans = 0.0;\n\t\t\tif(! l.intersectsLine(m)){\n\t\t\t\tdouble res1 = l.ptSegDist(m.getP1());\n\t\t\t\tdouble res2 = l.ptSegDist(m.getP2());\n\t\t\t\tdouble res3 = m.ptSegDist(l.getP1());\n\t\t\t\tdouble res4 = m.ptSegDist(l.getP2());\n\t\t\t\tans = Math.min(Math.min(res1, res2),Math.min(res3, res4));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t//????????¨?????????????????????\n\t\tprivate boolean isIntersectSS(Line2D l, Line2D m){\n\t\t\treturn l.intersectsLine(m);\n\t\t}\n\t\t\n\t\t//??????????????????\n\t\tdouble cost[][];\n\t\tdouble d[];\n\t\tboolean used[];\n\t\tint V;\n\t\tvoid dijkstra(int s){\n\t\t\td[s] = 0;\n\t\t\twhile(true){\n\t\t\t\tint v = -1;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v]))v = u;\n\t\t\t\t}\n\t\t\t\tif(v == -1)break;\n\t\t\t\tused[v] = true;\n\t\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\t\td[u] = Math.min(d[u], d[v] + cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint start = sc.nextInt();\n\t\t\t\tint goal = sc.nextInt();\n\t\t\t\tif(n+start+goal == 0)break;\n\t\t\t\tV = n;\n\t\t\t\tcost = new double[V][V];\n\t\t\t\td = new double[V];\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\td[i] = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused = new boolean[V];\n\t\t\t\tPoint2D.Double stard[][] = new Point2D.Double[n][5];\n\t\t\t\tLine2D.Double starl[][] = new Line2D.Double[n][5];\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tPoint2D.Double sstar = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\t\tdouble radi = sc.nextDouble();\n\t\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstard[i][j] = new Point2D.Double(r*Math.sin(Math.toRadians(360+(72*j)-radi))+sstar.getX(),r*Math.cos(Math.toRadians(360+(72*j)-radi))+sstar.getY());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\tstarl[i][j] = new Line2D.Double(stard[i][j],stard[i][(j+1)%5]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\t\tfor(int m = 0;m < V;m++){\n\t\t\t\t\t\tif(i == m)continue;\n\t\t\t\t\t\tfor(int j = 0;j < 5;j++){\n\t\t\t\t\t\t\tfor(int k = 0;k < 5;k++){\n\t\t\t\t\t\t\t\tif(isIntersectSS(starl[i][j],starl[m][k])){\n\t\t\t\t\t\t\t\t\tcost[i][m] = 0;\n\t\t\t\t\t\t\t\t\tcost[m][i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcost[i][m] = Math.min(cost[i][m],distanceSS(starl[i][j],starl[m][k]));\n\t\t\t\t\t\t\t\t\tcost[m][i] = cost[i][m];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdijkstra(start-1);\n//\t\t\t\tfor(int i = 0;i < V;i++){\n//\t\t\t\t\tSystem.out.println(d[i]);\n//\t\t\t\t}\n\t\t\t\tSystem.out.println(d[goal-1]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\t\t\tfinal int L = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0 && M == 0 && L == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[][][] lines = new Point2D[N][5][2];\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\tfinal int a = sc.nextInt();\n\t\t\t\tfinal int r = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int rotate = 0; rotate < 5; rotate++){\n\t\t\t\t\tfinal int cur_angle = a + (360 / 5) * 2 * rotate + 90;\n\t\t\t\t\t\n\t\t\t\t\tfinal double cur_x = x + r * Math.cos(Math.toRadians(cur_angle));\n\t\t\t\t\tfinal double cur_y = y + r * Math.sin(Math.toRadians(cur_angle));\n\t\t\t\t\t//System.out.println(rotate + \" : \" + cur_x + \" \" + cur_y);\n\t\t\t\t\t\n\t\t\t\t\tfinal int prev_rotate = (5 + rotate - 2) % 5;\n\t\t\t\t\t\n\t\t\t\t\tlines[i][rotate][0] = lines[i][prev_rotate][1] = new Point2D(cur_x, cur_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] dist = new double[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\tif(i == j){\n\t\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdist[i][j] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int from = 0; from < N; from++){\n\t\t\t\tfor(int to = from + 1; to < N; to++){\n\t\t\t\t\tdouble min = INF;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(int from_edge = 0; from_edge < 5; from_edge++){\n\t\t\t\t\t\tfor(int to_edge = 0; to_edge < 5; to_edge++){\n\t\t\t\t\t\t\tmin = Math.min(min, Point2D.ss_dist\n\t\t\t\t\t\t\t\t\t(lines[from][from_edge][0],\n\t\t\t\t\t\t\t\t\t lines[from][from_edge][1],\n\t\t\t\t\t\t\t\t\t lines[to][to_edge][0],\n\t\t\t\t\t\t\t\t\t lines[to][to_edge][1]));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdist[from][to] = dist[to][from] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.printf(\"%.9f\\n\", dist[M - 1][L - 1]);\n\t\t}\n\t}\n}\n\nclass Point2D implements Comparable<Point2D>{\n   public double x;\n   public double y;\n\n   public static final double EPS = 1e-8;\n\n   public Point2D(double x, double y) {\n       this.x = x;\n       this.y = y;\n   }\n\n   public Point2D(Point2D point) {\n       this.x = point.x;\n       this.y = point.y;\n   }\n\n   public String toString() {\n       return \"<\" + x + \" ,\" + y + \">\";\n   }\n\n   @Override\n   public boolean equals(Object o) {\n       if (o instanceof Point2D) {\n           Point2D another = (Point2D) o;\n            \n           if(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n               return true;\n           }\n            \n           return false;\n       }\n       return false;\n   }\n    \n   @Override\n   public int compareTo(Point2D arg0) {\n       if(this.equals(arg0)){\n           return 0;\n       }else if(Point2D.eq(this.x, arg0.x)){\n           return Point2D.signum(this.y - arg0.y);\n       }else {\n           return Point2D.signum(this.x - arg0.x);\n       }\n   }\n\n   public Point2D add(double x, double y) {\n       return new Point2D(this.x + x, this.y + y);\n   }\n\n   public Point2D sub(double x, double y) {\n       return add(-x, -y);\n   }\n\n   public Point2D add(Point2D another) {\n       return add(another.x, another.y);\n   }\n\n   public Point2D sub(Point2D another) {\n       return sub(another.x, another.y);\n   }\n\n   public Point2D mul(double d) {\n       return new Point2D(this.x * d, this.y * d);\n   }\n\n   public Point2D div(double d) {\n       return new Point2D(this.x / d, this.y / d);\n   }\n\n   public double dot(double x, double y) {\n       return this.x * x + this.y * y;\n   }\n\n   public double dot(Point2D another) {\n       return dot(another.x, another.y);\n   }\n\n   public double cross(double x, double y) {\n       return this.x * y - this.y * x;\n   }\n\n   public double cross(Point2D another) {\n       return cross(another.x, another.y);\n   }\n\n   public double dist(double x, double y) {\n       return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n               * (this.y - y));\n   }\n\n   public double dist(Point2D another) {\n       return dist(another.x, another.y);\n   }\n\n   public double dist_o() {\n       return dist(0, 0);\n   }\n    \n   public double dist2(double x, double y) {\n       return (this.x - x) * (this.x - x) + (this.y - y) * (this.y - y);\n   }\n    \n   public double dist2(Point2D another) {\n       return dist2(another.x, another.y);\n   }\n\n   public Point2D unit() {\n       return div(dist_o());\n   }\n\n   public boolean pol(Point2D start, Point2D end) {\n       return end.sub(start).cross(this.sub(start)) < EPS;\n   }\n\n   public boolean pos(Point2D start, Point2D end) {\n       return (Math.abs(start.dist(this) + this.dist(end) - start.dist(end))  <  EPS);\n   }\n\n   public double pld(Point2D start, Point2D end) {\n       return Math.abs((end.sub(start).cross(this.sub(start)))\n               / end.sub(start).dist_o());\n   }\n    \n   public double psd(Point2D start, Point2D end) {\n       if (end.sub(start).dot(this.sub(start)) < EPS) {\n           return this.dist(start);\n       } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n           return this.dist(end);\n       } else {\n           return Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n       }\n   }\n    \n   public static int signum(double x){\n       return Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n   }\n    \n   public static boolean eq(double x, double y){\n       return signum(x - y) == 0;\n   }\n    \n   public static int ccw(Point2D p, Point2D r, Point2D s){\n       Point2D a = r.sub(p);\n       Point2D b = s.sub(p);\n        \n       final int sgn = Point2D.signum(a.cross(b));\n       if(sgn != 0){\n           return sgn;\n       }else if(a.dot(b) < -EPS){\n           return -1;\n       }else if(a.dist_o() < b.dist_o() - EPS){\n           return 1;\n       }else{\n           return 0;\n       }\n   }\n    \n   public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       return (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n               && (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n   }\n\n   public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n   }\n\n   public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       Point2D b = b2.sub(b1);\n       double d1 = Math.abs(b.cross(a1.sub(b1)));\n       double d2 = Math.abs(b.cross(a2.sub(b1)));\n       double t = d1 / (d1 + d2);\n       Point2D a = a2.sub(a1), v = a.mul(t);\n       return a1.add(v);\n   }\n\n   public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       Point2D a = a2.sub(a1);\n       Point2D b = b2.sub(b1);\n       double t = b.cross(b1.sub(a1)) / b.cross(a);\n       Point2D v = a.mul(t);\n       return a1.add(v);\n   }\n\n   public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n           double r2) {\n       double dis = p1.dist(p2);\n\n       if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n           return new Point2D[0]; // same\n       }\n\n       if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n           Point2D tmp = p2.sub(p1);\n           tmp = tmp.mul(r1 / tmp.dist_o());\n           Point2D ret[] = new Point2D[1];\n           ret[0] = p1.add(tmp);\n           return ret;\n       } else if (dis + EPS > r1 + r2) {\n           return new Point2D[0]; // out\n       }\n\n       double dis_m = Math.abs(r1 - r2);\n\n       if (dis_m + EPS > dis && dis_m - EPS < dis) {\n           Point2D tmp = null;\n           if (r1 > r2) {\n               tmp = p2.sub(p1);\n           } else {\n               tmp = p1.sub(p2);\n           }\n\n           double min = Math.min(r1, r2);\n\n           tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n           Point2D ret[] = new Point2D[1];\n           ret[0] = p1.add(tmp);\n           return ret;\n       } else if (dis_m + EPS > dis) {\n           return new Point2D[0]; // inner\n       } else {\n           Point2D ret[] = new Point2D[2];\n\n           double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                   / (2 * dis * r1));\n           double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n           ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                   * Math.sin(a + theta) + p1.y);\n           ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                   * Math.sin(a - theta) + p1.y);\n           return ret;\n       }\n   }\n    \n   public static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n       if(Point2D.intersect_s(start1, end1, start2, end2)){\n           return 0;\n       }else{\n           return Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n       }\n   }\n    \n   public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n           Point2D ans[]) {\n       if (c.pld(start, end) > r + EPS)\n           return;\n       Point2D v = end.sub(start).unit();\n       double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n               - start.dist(c) * start.dist(c) + r * r;\n       double t = -v.dot(start.sub(c));\n       double s = Math.sqrt(delta);\n       ans[0] = start.add(v.mul(t + s));\n       ans[1] = start.add(v.mul(t + s));\n   }\n\n   public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n       Point2D v = b.sub(a).unit();\n       v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n               (-1) * v.y, v.x);\n       return v.mul(p.pld(a, b));\n   }\n\n   public double area(Point2D a, Point2D b, Point2D c) {\n       return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n   }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\tint n, s, g;\n\tdouble[][] map;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\ts = sc.nextInt(); g = sc.nextInt();\n\t\t\tif( (n|s|g) == 0 ) break;\n\t\t\ts--; g--;\n\t\t\t\n\t\t\tPent[] pents = new Pent[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tpents[i] = new Pent(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tmap = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\tmap[i][j] = map[j][i] = pents[i].d(pents[j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[j][k]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(map[s][g]);\n\t\t\t\n\t\t}\n\t}\n\t\n\tclass Pent {\n\t\tP[] ps;\n\t\tPent (double x, double y, double a, double r) {\n\t\t\tps = new P[5];\n\t\t\tfor(int i=0;i<5;i++) {\n\t\t\t\tps[i] = new P( -sin( (a + 72 * i) * PI / 180 ) * r + x, cos( (a + 72 * i) * PI / 180 ) * r + y );\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble d(Pent p) {\n\t\t\tdouble d = disSP(ps[0], ps[2], p.ps[0]);\n\t\t\tfor(int i=0;i<5;i++) for(int j=0;j<5;j++){\n\t\t\t\tif( cross(ps[i], ps[(i+2)%5], p.ps[j], p.ps[(j+2)%5] ) ) return 0;\n\t\t\t\td = min( disSP(ps[i], ps[(i+2)%5], p.ps[j]), d );\n\t\t\t\td = min( disSP(p.ps[i], p.ps[(i+2)%5], ps[j]), d );\n\t\t\t}\n\t\t\treturn d;\n\t\t}\n\t}\n\t\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).len();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).len();\n\t\treturn disLP(p1, p2, q);\n\t}\n\t\n\tdouble disLP(P p1, P p2, P q) {\n\t\tdouble abs = abs ( p1.sub(p2).det(q.sub(p2)) ) / p1.sub(p2).len();\n\t\tif( abs < EPS ) return 0;\n\t\treturn abs;\n\t}\n\t\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\tif( max(p1.x, p2.x) + EPS < min(q1.x, q2.x) ) return false;\n\t\tif( max(p1.y, p2.x) + EPS < min(q1.y, q2.y) ) return false;\n\t\tif( max(q1.x, q2.x) + EPS < min(p1.x, p2.x) ) return false;\n\t\tif( max(q1.y, q2.x) + EPS < min(p1.y, p2.y) ) return false;\n\t\treturn abs( p1.sub(p2).det(q1) * p1.sub(p2).det(q2) ) < EPS &&\n\t\t\t   abs( q1.sub(q2).det(p1) * q1.sub(q2).det(p2) ) < EPS;\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP( double x, double y ) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tP add(P p) {\n\t\t\treturn new P(add(x,p.x), add(y,p.y));\n\t\t}\n\t\t\n\t\tP sub(P p) {\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tdouble dot(P p) {\n\t\t\treturn add( x*p.x, y*p.y );\n\t\t}\n\t\t\n\t\tdouble det(P p) {\n\t\t\treturn add( x*p.y, -y*p.x );\n\t\t}\n\t\t\n\t\tdouble len() {\n\t\t\tdouble abs = sqrt ( add(x*x, y*y) );\n\t\t\tif( abs(abs) < EPS ) return 0;\n\t\t\treturn abs;\n\t\t}\n\t\t\n\t\tdouble add(double a, double b) {\n\t\t\tif( abs(a+b) < EPS * ( abs(a) + abs(b) ) ) return 0;\n\t\t\treturn a+b;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\t\t\tfinal int L = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0 && M == 0 && L == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[][][] lines = new Point2D[N][5][2];\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\tfinal int a = sc.nextInt();\n\t\t\t\tfinal int r = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int rotate = 0; rotate < 5; rotate++){\n\t\t\t\t\tfinal int cur_angle = a + (360 / 5) * 2 * rotate + 90;\n\t\t\t\t\t\n\t\t\t\t\tfinal double cur_x = x + r * Math.cos(Math.toRadians(cur_angle));\n\t\t\t\t\tfinal double cur_y = y + r * Math.sin(Math.toRadians(cur_angle));\n\t\t\t\t\t//System.out.println(rotate + \" : \" + cur_x + \" \" + cur_y);\n\t\t\t\t\t\n\t\t\t\t\tfinal int prev_rotate = (5 + rotate - 1) % 5;\n\t\t\t\t\t\n\t\t\t\t\tlines[i][rotate][0] = lines[i][prev_rotate][1] = new Point2D(cur_x, cur_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] dist = new double[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\tif(i == j){\n\t\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdist[i][j] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int from = 0; from < N; from++){\n\t\t\t\tfor(int to = from + 1; to < N; to++){\n\t\t\t\t\tdouble min = INF;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(int from_edge = 0; from_edge < 5; from_edge++){\n\t\t\t\t\t\tfor(int to_edge = 0; to_edge < 5; to_edge++){\n\t\t\t\t\t\t\tmin = Math.min(min, Point2D.ss_dist\n\t\t\t\t\t\t\t\t\t(lines[from][from_edge][0],\n\t\t\t\t\t\t\t\t\t lines[from][from_edge][1],\n\t\t\t\t\t\t\t\t\t lines[to][to_edge][0],\n\t\t\t\t\t\t\t\t\t lines[to][to_edge][1]));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdist[from][to] = dist[to][from] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.printf(\"%.9f\\n\", dist[M - 1][L - 1]);\n\t\t}\n\t}\n}\n\nclass Point2D implements Comparable<Point2D>{\n   public double x;\n   public double y;\n\n   public static final double EPS = 1e-8;\n\n   public Point2D(double x, double y) {\n       this.x = x;\n       this.y = y;\n   }\n\n   public Point2D(Point2D point) {\n       this.x = point.x;\n       this.y = point.y;\n   }\n\n   public String toString() {\n       return \"<\" + x + \" ,\" + y + \">\";\n   }\n\n   @Override\n   public boolean equals(Object o) {\n       if (o instanceof Point2D) {\n           Point2D another = (Point2D) o;\n            \n           if(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n               return true;\n           }\n            \n           return false;\n       }\n       return false;\n   }\n    \n   @Override\n   public int compareTo(Point2D arg0) {\n       if(this.equals(arg0)){\n           return 0;\n       }else if(Point2D.eq(this.x, arg0.x)){\n           return Point2D.signum(this.y - arg0.y);\n       }else {\n           return Point2D.signum(this.x - arg0.x);\n       }\n   }\n\n   public Point2D add(double x, double y) {\n       return new Point2D(this.x + x, this.y + y);\n   }\n\n   public Point2D sub(double x, double y) {\n       return add(-x, -y);\n   }\n\n   public Point2D add(Point2D another) {\n       return add(another.x, another.y);\n   }\n\n   public Point2D sub(Point2D another) {\n       return sub(another.x, another.y);\n   }\n\n   public Point2D mul(double d) {\n       return new Point2D(this.x * d, this.y * d);\n   }\n\n   public Point2D div(double d) {\n       return new Point2D(this.x / d, this.y / d);\n   }\n\n   public double dot(double x, double y) {\n       return this.x * x + this.y * y;\n   }\n\n   public double dot(Point2D another) {\n       return dot(another.x, another.y);\n   }\n\n   public double cross(double x, double y) {\n       return this.x * y - this.y * x;\n   }\n\n   public double cross(Point2D another) {\n       return cross(another.x, another.y);\n   }\n\n   public double dist(double x, double y) {\n       return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n               * (this.y - y));\n   }\n\n   public double dist(Point2D another) {\n       return dist(another.x, another.y);\n   }\n\n   public double dist_o() {\n       return dist(0, 0);\n   }\n    \n   public double dist2(double x, double y) {\n       return (this.x - x) * (this.x - x) + (this.y - y) * (this.y - y);\n   }\n    \n   public double dist2(Point2D another) {\n       return dist2(another.x, another.y);\n   }\n\n   public Point2D unit() {\n       return div(dist_o());\n   }\n\n   public boolean pol(Point2D start, Point2D end) {\n       return end.sub(start).cross(this.sub(start)) < EPS;\n   }\n\n   public boolean pos(Point2D start, Point2D end) {\n       return (Math.abs(start.dist(this) + this.dist(end) - start.dist(end))  <  EPS);\n   }\n\n   public double pld(Point2D start, Point2D end) {\n       return Math.abs((end.sub(start).cross(this.sub(start)))\n               / end.sub(start).dist_o());\n   }\n    \n   public double psd(Point2D start, Point2D end) {\n       if (end.sub(start).dot(this.sub(start)) < EPS) {\n           return this.dist(start);\n       } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n           return this.dist(end);\n       } else {\n           return Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n       }\n   }\n    \n   public static int signum(double x){\n       return Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n   }\n    \n   public static boolean eq(double x, double y){\n       return signum(x - y) == 0;\n   }\n    \n   public static int ccw(Point2D p, Point2D r, Point2D s){\n       Point2D a = r.sub(p);\n       Point2D b = s.sub(p);\n        \n       final int sgn = Point2D.signum(a.cross(b));\n       if(sgn != 0){\n           return sgn;\n       }else if(a.dot(b) < -EPS){\n           return -1;\n       }else if(a.dist_o() < b.dist_o() - EPS){\n           return 1;\n       }else{\n           return 0;\n       }\n   }\n    \n   public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       return (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n               && (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n   }\n\n   public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n   }\n\n   public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       Point2D b = b2.sub(b1);\n       double d1 = Math.abs(b.cross(a1.sub(b1)));\n       double d2 = Math.abs(b.cross(a2.sub(b1)));\n       double t = d1 / (d1 + d2);\n       Point2D a = a2.sub(a1), v = a.mul(t);\n       return a1.add(v);\n   }\n\n   public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n           Point2D b2) {\n       Point2D a = a2.sub(a1);\n       Point2D b = b2.sub(b1);\n       double t = b.cross(b1.sub(a1)) / b.cross(a);\n       Point2D v = a.mul(t);\n       return a1.add(v);\n   }\n\n   public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n           double r2) {\n       double dis = p1.dist(p2);\n\n       if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n           return new Point2D[0]; // same\n       }\n\n       if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n           Point2D tmp = p2.sub(p1);\n           tmp = tmp.mul(r1 / tmp.dist_o());\n           Point2D ret[] = new Point2D[1];\n           ret[0] = p1.add(tmp);\n           return ret;\n       } else if (dis + EPS > r1 + r2) {\n           return new Point2D[0]; // out\n       }\n\n       double dis_m = Math.abs(r1 - r2);\n\n       if (dis_m + EPS > dis && dis_m - EPS < dis) {\n           Point2D tmp = null;\n           if (r1 > r2) {\n               tmp = p2.sub(p1);\n           } else {\n               tmp = p1.sub(p2);\n           }\n\n           double min = Math.min(r1, r2);\n\n           tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n           Point2D ret[] = new Point2D[1];\n           ret[0] = p1.add(tmp);\n           return ret;\n       } else if (dis_m + EPS > dis) {\n           return new Point2D[0]; // inner\n       } else {\n           Point2D ret[] = new Point2D[2];\n\n           double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                   / (2 * dis * r1));\n           double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n           ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                   * Math.sin(a + theta) + p1.y);\n           ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                   * Math.sin(a - theta) + p1.y);\n           return ret;\n       }\n   }\n    \n   public static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n       if(Point2D.intersect_s(start1, end1, start2, end2)){\n           return 0;\n       }else{\n           return Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n       }\n   }\n    \n   public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n           Point2D ans[]) {\n       if (c.pld(start, end) > r + EPS)\n           return;\n       Point2D v = end.sub(start).unit();\n       double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n               - start.dist(c) * start.dist(c) + r * r;\n       double t = -v.dot(start.sub(c));\n       double s = Math.sqrt(delta);\n       ans[0] = start.add(v.mul(t + s));\n       ans[1] = start.add(v.mul(t + s));\n   }\n\n   public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n       Point2D v = b.sub(a).unit();\n       v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n               (-1) * v.y, v.x);\n       return v.mul(p.pld(a, b));\n   }\n\n   public double area(Point2D a, Point2D b, Point2D c) {\n       return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n   }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\tint n, s, g;\n\tdouble[][] map;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\ts = sc.nextInt(); g = sc.nextInt();\n\t\t\tif( (n|s|g) == 0 ) break;\n\t\t\ts--; g--;\n\t\t\t\n\t\t\tPent[] pents = new Pent[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tpents[i] = new Pent(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tmap = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) {\n\t\t\t\tmap[i][j] = map[j][i] = pents[i].d(pents[j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[j][k]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.10f\\n\", map[s][g]);\n\t\t\t\n\t\t}\n\t}\n\t\n\tclass Pent {\n\t\tP[] ps;\n\t\tPent (double x, double y, double a, double r) {\n\t\t\tps = new P[5];\n\t\t\tfor(int i=0;i<5;i++) {\n\t\t\t\tps[i] = new P( -sin( (a + 72 * i) * PI / 180 ) * r + x, cos( (a + 72 * i) * PI / 180 ) * r + y );\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble d(Pent p) {\n\t\t\tdouble d = disSP(ps[0], ps[2], p.ps[0]);\n\t\t\tfor(int i=0;i<5;i++) for(int j=0;j<5;j++){\n\t\t\t\tif( cross(ps[i], ps[(i+2)%5], p.ps[j], p.ps[(j+2)%5] ) ) return 0;\n\t\t\t\td = min( disSP(ps[i], ps[(i+2)%5], p.ps[j]), d );\n\t\t\t\td = min( disSP(p.ps[i], p.ps[(i+2)%5], ps[j]), d );\n\t\t\t}\n\t\t\treturn d;\n\t\t}\n\t}\n\t\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).len();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).len();\n\t\treturn disLP(p1, p2, q);\n\t}\n\t\n\tdouble disLP(P p1, P p2, P q) {\n\t\tdouble abs = abs ( p1.sub(p2).det(q.sub(p2)) ) / p1.sub(p2).len();\n\t\tif( abs < EPS ) return 0;\n\t\treturn abs;\n\t}\n\t\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t}\n\t\n\tint ccw (P a, P b, P c) {\n\t\tP s = b.sub(a);\n\t\tP t = c.sub(a);\n\t\tif( s.det(t) > EPS ) return 1;\n\t\tif( s.det(t) < -EPS ) return -1;\n\t\tif( s.dot(t) < -EPS ) return 2;\n\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\treturn 0;\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP( double x, double y ) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tP add(P p) {\n\t\t\treturn new P(add(x,p.x), add(y,p.y));\n\t\t}\n\t\t\n\t\tP sub(P p) {\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tdouble dot(P p) {\n\t\t\treturn add( x*p.x, y*p.y );\n\t\t}\n\t\t\n\t\tdouble det(P p) {\n\t\t\treturn add( x*p.y, -y*p.x );\n\t\t}\n\t\t\n\t\tdouble len() {\n\t\t\tdouble abs = sqrt ( add(x*x, y*y) );\n\t\t\tif( abs(abs) < EPS ) return 0;\n\t\t\treturn abs;\n\t\t}\n\t\t\n\t\tdouble add(double a, double b) {\n\t\t\tif( abs(a+b) < EPS * ( abs(a) + abs(b) ) ) return 0;\n\t\t\treturn a+b;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<utility>\n#include<queue>\n#include<cmath>\n#include<iomanip>\n\ntypedef long double ld;\ntypedef std::complex<ld> P;\nconst ld eps = 1e-8, pi = acos(-1.0);\nstruct L { P a, b; };\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n      : lhs.real() < rhs.real();\n  }\n}\n\nusing namespace std;\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\n\nP is_ll(L s, L t){\n  P sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nld dist_pp(P p, P q) {\n  return abs(p - q);\n}\n\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  ld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n  ld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n  return min(a, b);\n}\n\nP rotate(ld deg, P p) {\n  ld rad = deg * pi / 180.0;\n  return polar((ld)1.0, rad) * p;\n}\n\nstruct Star { L e[5]; };\n\nld dist_stst(Star s, Star t) {\n  ld val = dist_ss(s.e[0], t.e[0]);\n  for (L ss : s.e) for (L ts : t.e) {\n    val = min(val, dist_ss(ss, ts));\n  }\n  return val;\n}\n\nint main() {\n  int n, m, l;\n  while (cin >> n >> m >> l and n) {\n    m--; l--;\n    vector<Star> stars(n);\n    for (Star &s : stars) {\n      int x, y ,a, r;\n      cin >> x >> y >> a >> r;\n      P center(x, y);\n      for (int i = 0; i < 5; i++) {\n        s.e[i].a = \n          center + polar((ld)r, (90 + a + 72 * i) * pi / 180.0);\n        s.e[i].b = \n          center + polar((ld)r, (90 + a + 72 * (i + 2)) * pi / 180.0);\n      }\n    }\n\n    vector<vector<ld>> dist(n);\n    for (vector<ld> &v : dist) {\n      v.reserve(n);\n    }\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        dist[i][j] = dist_stst(stars[i], stars[j]);\n      }\n    }\n\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    cout << fixed << setprecision(30)<< dist[m][l] << endl;\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\n\ninclude Math\n\n\n\nclass Heap\n\n\trequire 'forwardable'\n\n\textend Forwardable\n\n\n\n\tdef initialize\n\n\t\t@array = []\n\n\t\t@index = {}\n\n\tend\n\n\n\n\tdef add(obj, key)\n\n\t\t@array << [obj, key]\n\n\t\t@index[obj] = @array.size - 1\n\n\t\tlift_up(@array.size - 1)\n\n\tend\n\n\n\n\tdef swap(i, j)\n\n\t\tu = @array[i]\n\n\t\tv = @array[j]\n\n\t\t@index[u[0]], @index[v[0]] = j, i\n\n\t\t@array[i], @array[j] = v, u\n\n\tend\n\n\n\n\tdef lift_up(i)\n\n\t\treturn if i == 0\n\n\t\tj = (i - 1) / 2\n\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\n\t\t\tswap(i, j)\n\n\t\t\tlift_up(j)\n\n\t\tend\n\n\tend\n\n\n\n\tdef del_min\n\n\t\traise \"heap is empty!\" if empty?\n\n\t\tmin = @array[0]\n\n\t\tif size > 1\n\n\t\t\tswap(0, @array.size-1)\n\n\t\t\t@array.pop\n\n\t\t\tlift_down(0)\n\n\t\telse\n\n\t\t\t@array.pop\n\n\t\tend\n\n\t\t@index.delete(min[0])\n\n\t\tmin\n\n\tend\n\n\n\n\tdef inc_key(obj, diff)\n\n\t\ti = @index[obj]\n\n\t\t@array[i][1] += diff\n\n\t\tlift_down(i)\n\n\tend\n\n\n\n\tdef dec_key(obj, diff)\n\n\t\ti = @index[obj]\n\n\t\t@array[i][1] -= diff\n\n\t\tlift_up(i)\n\n\tend\n\n\n\n\tdef update_key(obj, new_key)\n\n\t\ti = @index[obj]\n\n\t\treturn unless i\n\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\n\t\t@array[i][1] = new_key\n\n\t\tlift_up(i)\n\n\tend\n\n\n\n\tdef min_obj\n\n\t\t@array[0][0]\n\n\tend\n\n\n\n\tdef min_key\n\n\t\t@array[0][1]\n\n\tend\n\n\n\n\tdef lift_down(i)\n\n\t\tj = 2 * i + 1\n\n\t\tk = j + 1\n\n\t\tif k >= size\n\n\t\t\treturn if j >= size\n\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\n\t\t\t\tswap(i, j)\n\n\t\t\t\tlift_down(j)\n\n\t\t\tend\n\n\t\telse\n\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\n\t\t\t\tswap(i, l)\n\n\t\t\t\tlift_down(l)\n\n\t\t\tend\n\n\t\tend\n\n\tend\n\n\n\n\tdef_delegators :@array, :empty?, :size\n\nend\n\n\n\nmodule Graphical\n\n\trequire 'set'\n\n\n\n\tdef get_path_by_bfs(s, t)\n\n\t\tprev_node = {}\n\n\t\treached = Set[s]\n\n\t\tqueue = [s]\n\n\t\twhile !queue.empty? \n\n\t\t\tu = queue.shift\n\n\t\t\teach_out_connection_of(u){|v, _|\n\n\t\t\t\tnext if reached.include?(v)\t\n\n\t\t\t\treached << v\n\n\t\t\t\tqueue << v\n\n\t\t\t\tprev_node[v] = u\n\n\n\n\t\t\t\tif v == t\n\n\t\t\t\t\tpath = [v]\n\n\t\t\t\t\twhile v = prev_node[v]\n\n\t\t\t\t\t\tpath.unshift v\n\n\t\t\t\t\tend\n\n\t\t\t\t\treturn path\n\n\t\t\t\tend\n\n\t\t\t}\n\n\t\tend\t\n\n\t\treturn nil\n\n\tend\n\n\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\n\t\treached << s\n\n\t\treturn [s] if s == t\n\n\t\teach_out_connection_of(s){|v|\n\n\t\t\tnext if reached.include?(v)\n\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\n\t\t\treturn [s] + path if path\n\n\t\t}\n\n\t\tnil\n\n\tend\n\n\n\n\tdef reachable_from(s, max_depth = nil)\n\n\t\treached = Set[s]\n\n\t\tqueue = [s]\n\n\t\tdepth = 0\n\n\t\tloop {\n\n\t\t\tbreak if max_depth && depth >= max_depth\n\n\t\t\tnext_queue = []\n\n\t\t\tuntil queue.empty?\n\n\t\t\t\tu = queue.shift\n\n\t\t\t\teach_out_connection_of(u){|v, _|\n\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\treached << v\n\n\t\t\t\t\tnext_queue << v\n\n\t\t\t\t}\n\n\t\t\tend\n\n\t\t\tbreak if next_queue.empty?\n\n\t\t\tqueue = next_queue\n\n\t\t\tdepth += 1\n\n\t\t}\n\n\t\treturn reached\n\n\tend\n\n\n\n\tdef bfs(start)\n\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\n\t\treached = Set[*start.to_a]\n\n\t\tqueue = []\n\n\t\tstart.each{|s| queue << s}\n\n\t\tdist = {}\n\n\t\tloop.with_index {|_, depth|\n\n\t\t\tnext_queue = []\n\n\t\t\tuntil queue.empty?\n\n\t\t\t\tu = queue.shift\n\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\n\t\t\t\tdist[u] = depth\n\n\t\t\t\teach_out_connection_of(u){|v, _|\n\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\treached << v\n\n\t\t\t\t\tnext_queue << v\n\n\t\t\t\t}\n\n\t\t\tend\n\n\t\t\tbreak if next_queue.empty?\n\n\t\t\tqueue = next_queue\n\n\t\t}\n\n\t\tblock_given? ? nil : dist\n\n\tend\n\n\n\n\tdef dijkstra(start)\n\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\n\t\th = Heap.new\n\n\t\treached = Set[*start.to_a]\n\n\t\tstart.each{|s| h.add(s, 0)}\n\n\n\n\t\tdist = {}\n\n\t\tuntil h.empty?\n\n\t\t\tu, key = h.del_min\n\n\t\t\treturn key if block_given? && yield(u, key)\n\n\t\t\tdist[u] = key\n\n\t\t\teach_out_connection_of(u){|v, l|\n\n\t\t\t\td = dist[u] + l\n\n\t\t\t\tif reached.include?(v)\n\n\t\t\t\t\th.update_key(v, d)\n\n\t\t\t\telse\n\n\t\t\t\t\th.add(v, d)\n\n\t\t\t\t\treached << v\n\n\t\t\t\tend\n\n\t\t\t}\n\n\t\tend\n\n\t\tblock_given? ? nil : dist\n\n\tend\n\n\n\n\tdef bidir_dijkstra(s, t)\n\n\t\tf_dist = {}\n\n\t\tb_dist = {}\n\n\n\n\t\tf_heap = Heap.new\n\n\t\tb_heap = Heap.new\n\n\n\n\t\tf_heap.add(s, 0)\n\n\t\tb_heap.add(t, 0)\n\n\n\n\t\tf_reached = Set[s]\n\n\t\tb_reached = Set[t]\n\n\n\n\t\tf_current_dist = b_current_dist = 0\n\n\t\tbest = Float::INFINITY\n\n\n\n\t\tloop {\n\n\t\t\tif !f_heap.empty?\n\n\t\t\t\tu, key = f_heap.del_min\n\n\t\t\t\tf_dist[u] = key\n\n\t\t\t\tf_current_dist = key\n\n\t\t\t\teach_out_connection_of(u){|v, l|\n\n\t\t\t\t\td = f_dist[u] + l\n\n\t\t\t\t\tif b_dist[v]\n\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\n\t\t\t\t\t\tbest = path_len if path_len < best\n\n\t\t\t\t\tend\n\n\t\t\t\t\tif f_reached.include?(v)\n\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\n\t\t\t\t\telse\n\n\t\t\t\t\t\tf_heap.add(v, d)\n\n\t\t\t\t\t\tf_reached << v\n\n\t\t\t\t\tend\n\n\t\t\t\t}\n\n\t\t\tend\n\n\n\n\t\t\tif !b_heap.empty?\n\n\t\t\t\tu, key = b_heap.del_min\n\n\t\t\t\tb_dist[u] = key\n\n\t\t\t\tb_current_dist = key\n\n\t\t\t\teach_in_connection_of(u){|v, l|\n\n\t\t\t\t\td = b_dist[u] + l\n\n\t\t\t\t\tif f_dist[v]\n\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\n\t\t\t\t\t\tbest = path_len if path_len < best\n\n\t\t\t\t\tend\n\n\t\t\t\t\tif b_reached.include?(v)\n\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\n\t\t\t\t\telse\n\n\t\t\t\t\t\tb_heap.add(v, d)\n\n\t\t\t\t\t\tb_reached << v\n\n\t\t\t\t\tend\n\n\t\t\t\t}\n\n\t\t\tend\n\n\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\n\t\t}\n\n\tend\n\n\n\n\tdef a_star(start)\n\n\t\traise \"a_star need termination condition\" unless block_given?\n\n\t\th = Heap.new\n\n\t\treached = Set[start]\n\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\n\n\t\tdist = {}\n\n\t\tuntil h.empty?\n\n\t\t\tu, (e, d) = h.del_min\n\n\t\t\treturn d if yield(u, dist)\n\n\t\t\tdist[u] = d\n\n\t\t\teach_out_connection_of(u){|v, l|\n\n\t\t\t\td = dist[u] + l\n\n\t\t\t\te = d + a_star_heuristic(v)\n\n\t\t\t\tif reached.include?(v)\n\n\t\t\t\t\th.update_key(v, [e, d])\n\n\t\t\t\telse\n\n\t\t\t\t\th.add(v, [e, d])\n\n\t\t\t\t\treached << v\n\n\t\t\t\tend\n\n\t\t\t}\n\n\t\tend\n\n\t\tblock_given? ? nil : dist\n\n\tend\n\n\n\n\t#make_variations :bidir_dijkstra\n\n\n\n\tdef prim(start)\n\n\t\th = Heap.new\n\n\t\th.add(start, 0)\n\n\t\treached = Set[start]\n\n\t\ttree_len = 0\n\n\n\n\t\tuntil h.empty?\n\n\t\t\tu, key = h.del_min\n\n\t\t\ttree_len += key\n\n\n\n\t\t\teach_out_connection_of(u){|v, d|\n\n\t\t\t\tif reached.include?(v)\n\n\t\t\t\t\th.update_key(v, d)\n\n\t\t\t\telse\n\n\t\t\t\t\th.add(v, d)\n\n\t\t\t\t\treached << v\n\n\t\t\t\tend\n\n\t\t\t}\n\n\t\tend\n\n\t\ttree_len\n\n\tend\n\n\n\n\tdef each_layer_from(start)\n\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\n\t\treturn enum_for(__method__, start) unless block_given?\n\n\t\treached = Set[*start]\n\n\t\tcurrent_layer = start\n\n\n\n\t\tloop {\n\n\t\t\tyield current_layer\n\n\t\t\tnext_layer = []\n\n\t\t\tcurrent_layer.each{|u|\n\n\t\t\t\teach_out_connection_of(u){|v|\n\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\treached << v\n\n\t\t\t\t\tnext_layer << v\n\n\t\t\t\t}\n\n\t\t\t}\t\n\n\n\n\t\t\treturn if next_layer.empty?\n\n\t\t\tcurrent_layer = next_layer\n\n\t\t}\n\n\tend\n\nend\n\n\n\nclass Graph\n\n\tinclude Graphical\n\n\n\n\tdef initialize(*options)\n\n\t\t@options = Set[*options]\n\n\tend\n\n\n\n\tdef add_node(property = {})\n\n\t\tNode.new(property)\n\n\tend\n\n\n\n\tdef add_edge(u, v, property = {})\n\n\t\te = Edge.new(u, v, property)\n\n\t\tu.add_edge(e)\n\n\t\tv.add_edge(e)\n\n\t\te\n\n\tend\n\n\t\n\n\tdef del_edge(e)\n\n\t\tu, v = e.opposite.keys\n\n\t\tu.del_edge(e)\n\n\t\tv.del_edge(e)\n\n\t\te\n\n\tend\n\n\n\n\tclass Node\n\n\t\tdef initialize(property)\n\n\t\t\t@property = property\n\n\t\t\t@edges = Set.new\n\n\t\tend\n\n\n\n\t\tdef add_edge(e)\n\n\t\t\t@edges << e\n\n\t\tend\n\n\n\n\t\tdef del_edge(e)\n\n\t\t\t@edges.delete(e)\n\n\t\tend\n\n\n\n\t\tdef to_s\n\n\t\t\t@property[:name] || super\n\n\t\tend\n\n\n\n\t\tdef each_edge\n\n\t\t\t@edges.each{|e| \n\n\t\t\t\tyield e\n\n\t\t\t}\n\n\t\tend\n\n\n\n\t\tattr_reader :property\n\n\tend\n\n\n\n\tclass Edge\n\n\t\tdef initialize(u, v, property)\n\n\t\t\t@opposite = {u => v, v => u}\n\n\t\t\t@property = property\n\n\t\tend\n\n\t\tattr_reader :opposite, :property\n\n\n\n\t\tdef to_s\n\n\t\t\t@property[:name] || super\n\n\t\tend\n\n\n\n\t\tdef length\n\n\t\t\t@property[:length] || 1\n\n\t\tend\n\n\tend\n\n\n\n\tdef each_out_connection_of(u)\n\n\t\tu.each_edge{|e|\n\n\t\t\tyield(e.opposite[u], e.length)\n\n\t\t}\n\n\tend\n\n\n\n\talias :each_in_connection_of :each_out_connection_of\n\nend\n\n\n\ndef rotation_matrix(radian)\n\n\tMatrix[\n\n\t\t[Math.cos(radian), -Math.sin(radian)],\n\n\t\t[Math.sin(radian),  Math.cos(radian)]\n\n\t]\n\nend\n\n\n\nclass Line\n\n\tdef initialize(*args)\n\n\t\t@x1, @y1, @x2, @y2 = args\n\n\t\t@a = @y2 - @y1\n\n\t\t@b = @x1 - @x2\n\n\t\t@c = @a * @x1 + @b * @y1\n\n\tend\t\n\n\n\n\tdef distance(x, y)\n\n\t\tv1 = Vector[@x2 - @x1, @y2 - @y1]\n\n\t\tv2 = Vector[x - @x1, y - @y1]\n\n\t\tv3 = Vector[x - @x2, y - @y2]\n\n\t\tx = v1.inner_product(v2) / v1.r\n\n\n\n\t\td = sqrt([v2.r ** 2 - x ** 2, 0].max)\n\n\t\ta = v2.r\n\n\t\tb = v3.r\n\n\t\tc = v1.r\n\n\t\tif a * a + b * b - c * c < 0\n\n\t\t\td\n\n\t\telse\n\n\t\t\ta < b ? a : b\n\n\t\tend\n\n\tend\n\n\n\n\tdef parallel?(l)\n\n\t\t@a * l.b - @b * l.a == 0\n\n\tend\n\n\n\n\tdef cross?(l)\n\n\t\t(@a * l.x1 + @b * l.y1 - @c) * (@a * l.x2 + @b * l.y2 - @c) <= 0 and\n\n\t\t(l.a * @x1 + l.b * @y1 - l.c) * (l.a * @x2 + l.b * @y2 - l.c) <= 0\n\n\tend\n\n\n\n\tdef cross_point_vec(l)\n\n\t\tm = Matrix[\n\n\t\t\t[@a, @b],\n\n\t\t\t[l.a, l.b]\n\n\t\t\t]\n\n\t\tv = Vector[@c, l.c]\n\n\t\t(m.inv * v)\n\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\n\nend\n\n\n\nclass Star\n\n\tdef initialize(*args)\n\n\t\t@x, @y, @a, @r = args\n\n\t\tc = Vector[@x, @y]\n\n\t\tv = Vector[0, @r]\n\n\t\tv = rotation_matrix(@a * PI / 180) * v\n\n\t\t@points = (1..5).map do\n\n\t\t\t(c + v).tap { v = rotation_matrix(144 * PI / 180) * v }\n\n\t\tend\n\n\t\t@points\n\n\t\t@lines = (@points + [@points[0]]).each_cons(2).map do |p1, p2|\n\n\t\t\tLine.new(*p1, *p2)\n\n\t\tend\n\n\tend\n\n\t\n\n\tdef distance(star)\n\n\t\t@lines.each do |l1|\n\n\t\t\tstar.lines.each do |l2|\n\n\t\t\t\treturn 0 if l1.cross?(l2)\n\n\t\t\tend\n\n\t\tend\t\n\n\n\n\t\tds = []\n\n\t\t@points.each do |p|\n\n\t\t\tstar.lines.each do |l|\n\n\t\t\t\tds << l.distance(*p.to_a)\n\n\t\t\tend\n\n\t\tend\t\n\n\t\tstar.points.each do |p|\n\n\t\t\t@lines.each do |l|\n\n\t\t\t\tds << l.distance(*p.to_a)\n\n\t\t\tend\n\n\t\tend\t\n\n\t\tds.min\n\n\tend\n\n\n\n\tattr_reader :lines, :points\nend\n\nloop do\n\n\tn, m, l = gets.split.map(&:to_i)\n\n\tbreak if n == 0\n\n\tstars = (0..n-1).map { Star.new(*gets.split.map(&:to_i)) }\n\n\tg = Graph.new\n\n\tnodes = (0..n-1).map { g.add_node }\n\n\t(0..n-1).to_a.combination(2) do |i, j|\n\n\t\tg.add_edge(nodes[i], nodes[j], {:length => stars[i].distance(stars[j])})\n\n\tend\n\n\tp g.dijkstra([nodes[m-1]])[nodes[l-1]]\n\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ndef rotation_matrix(radian)\n\tMatrix[\n\t\t[Math.cos(radian), -Math.sin(radian)],\n\t\t[Math.sin(radian),  Math.cos(radian)]\n\t]\nend\n\nclass Line\n\t#ax + by = c\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\t\t@a = @y2 - @y1\n\t\t@b = @x1 - @x2\n\t\t@c = @a * @x1 + @b * @y1\n\tend\t\n\n\tdef distance(x, y)\n\t\ta = hypot(@x1 - x, @y1 - y)\n\t\tb = hypot(@x2 - x, @y2 - y)\n\t\tc = hypot(@x1 - @x2, @y1 - @y2)\n\t\treturn a if a*a + c*c < b*b\n\t\treturn b if b*b + c*c < a*a\n\t\t(@a * x + @b * y - @c).abs / sqrt(@a ** 2 + @b ** 2)\n\tend\n\n\tdef parallel?(l)\n\t\t(@a * l.b - @b * l.a).abs < 0.0001\n\tend\n\n\tdef cross?(l)\n\t\treturn false if parallel?(l)\n\t\t(@a * l.x1 + @b * l.y1 - @c) * (@a * l.x2 + @b * l.y2 - @c) <= 0.0001 and\n\t\t(l.a * @x1 + l.b * @y1 - l.c) * (l.a * @x2 + l.b * @y2 - l.c) <= 0.0001\n\tend\n\n\tdef cross_point_vec(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b]\n\t\t\t]\n\t\tv = Vector[@c, l.c]\n\t\t(m.inv * v)\n\tend\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nclass Star\n\tdef initialize(*args)\n\t\t@x, @y, @a, @r = args\n\t\tc = Vector[@x, @y]\n\t\tv = Vector[0, @r]\n\t\tv = rotation_matrix(@a * PI / 180) * v\n\t\t@points = (1..5).map do\n\t\t\t(c + v).tap { v = rotation_matrix(144 * PI / 180) * v }\n\t\tend\n\t\t@points\n\t\t@lines = (@points + [@points[0]]).each_cons(2).map do |p1, p2|\n\t\t\tLine.new(*p1, *p2)\n\t\tend\n\tend\n\t\n\tdef distance(star)\n\t\t@lines.each do |l1|\n\t\t\tstar.lines.each do |l2|\n\t\t\t\treturn 0 if l1.cross?(l2)\n\t\t\tend\n\t\tend\t\n\n\t\tds = []\n\t\t@points.each do |p|\n\t\t\tstar.lines.each do |l|\n\t\t\t\tds << l.distance(*p.to_a)\n\t\t\tend\n\t\tend\t\n\t\tstar.points.each do |p|\n\t\t\t@lines.each do |l|\n\t\t\t\tds << l.distance(*p.to_a)\n\t\t\tend\n\t\tend\t\n\t\tds.min\n\tend\n\n\tattr_reader :lines, :points\nend\n\nloop do\n\tn, m, l = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tstars = (0..n-1).map { Star.new(*gets.split.map(&:to_i)) }\n\tg = Graph.new\n\tnodes = (0..n-1).map { g.add_node }\n\t(0..n-1).to_a.combination(2) do |i, j|\n\t\tg.add_edge(nodes[i], nodes[j], {:length => stars[i].distance(stars[j])})\n\tend\n\tp g.dijkstra([nodes[m-1]])[nodes[l-1]]\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\n\ninclude Math\n\n\n\nclass Heap\n\n\trequire 'forwardable'\n\n\textend Forwardable\n\n\n\n\tdef initialize\n\n\t\t@array = []\n\n\t\t@index = {}\n\n\tend\n\n\n\n\tdef add(obj, key)\n\n\t\t@array << [obj, key]\n\n\t\t@index[obj] = @array.size - 1\n\n\t\tlift_up(@array.size - 1)\n\n\tend\n\n\n\n\tdef swap(i, j)\n\n\t\tu = @array[i]\n\n\t\tv = @array[j]\n\n\t\t@index[u[0]], @index[v[0]] = j, i\n\n\t\t@array[i], @array[j] = v, u\n\n\tend\n\n\n\n\tdef lift_up(i)\n\n\t\treturn if i == 0\n\n\t\tj = (i - 1) / 2\n\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\n\t\t\tswap(i, j)\n\n\t\t\tlift_up(j)\n\n\t\tend\n\n\tend\n\n\n\n\tdef del_min\n\n\t\traise \"heap is empty!\" if empty?\n\n\t\tmin = @array[0]\n\n\t\tif size > 1\n\n\t\t\tswap(0, @array.size-1)\n\n\t\t\t@array.pop\n\n\t\t\tlift_down(0)\n\n\t\telse\n\n\t\t\t@array.pop\n\n\t\tend\n\n\t\t@index.delete(min[0])\n\n\t\tmin\n\n\tend\n\n\n\n\tdef inc_key(obj, diff)\n\n\t\ti = @index[obj]\n\n\t\t@array[i][1] += diff\n\n\t\tlift_down(i)\n\n\tend\n\n\n\n\tdef dec_key(obj, diff)\n\n\t\ti = @index[obj]\n\n\t\t@array[i][1] -= diff\n\n\t\tlift_up(i)\n\n\tend\n\n\n\n\tdef update_key(obj, new_key)\n\n\t\ti = @index[obj]\n\n\t\treturn unless i\n\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\n\t\t@array[i][1] = new_key\n\n\t\tlift_up(i)\n\n\tend\n\n\n\n\tdef min_obj\n\n\t\t@array[0][0]\n\n\tend\n\n\n\n\tdef min_key\n\n\t\t@array[0][1]\n\n\tend\n\n\n\n\tdef lift_down(i)\n\n\t\tj = 2 * i + 1\n\n\t\tk = j + 1\n\n\t\tif k >= size\n\n\t\t\treturn if j >= size\n\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\n\t\t\t\tswap(i, j)\n\n\t\t\t\tlift_down(j)\n\n\t\t\tend\n\n\t\telse\n\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\n\t\t\t\tswap(i, l)\n\n\t\t\t\tlift_down(l)\n\n\t\t\tend\n\n\t\tend\n\n\tend\n\n\n\n\tdef_delegators :@array, :empty?, :size\n\nend\n\n\n\nmodule Graphical\n\n\trequire 'set'\n\n\n\n\tdef get_path_by_bfs(s, t)\n\n\t\tprev_node = {}\n\n\t\treached = Set[s]\n\n\t\tqueue = [s]\n\n\t\twhile !queue.empty? \n\n\t\t\tu = queue.shift\n\n\t\t\teach_out_connection_of(u){|v, _|\n\n\t\t\t\tnext if reached.include?(v)\t\n\n\t\t\t\treached << v\n\n\t\t\t\tqueue << v\n\n\t\t\t\tprev_node[v] = u\n\n\n\n\t\t\t\tif v == t\n\n\t\t\t\t\tpath = [v]\n\n\t\t\t\t\twhile v = prev_node[v]\n\n\t\t\t\t\t\tpath.unshift v\n\n\t\t\t\t\tend\n\n\t\t\t\t\treturn path\n\n\t\t\t\tend\n\n\t\t\t}\n\n\t\tend\t\n\n\t\treturn nil\n\n\tend\n\n\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\n\t\treached << s\n\n\t\treturn [s] if s == t\n\n\t\teach_out_connection_of(s){|v|\n\n\t\t\tnext if reached.include?(v)\n\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\n\t\t\treturn [s] + path if path\n\n\t\t}\n\n\t\tnil\n\n\tend\n\n\n\n\tdef reachable_from(s, max_depth = nil)\n\n\t\treached = Set[s]\n\n\t\tqueue = [s]\n\n\t\tdepth = 0\n\n\t\tloop {\n\n\t\t\tbreak if max_depth && depth >= max_depth\n\n\t\t\tnext_queue = []\n\n\t\t\tuntil queue.empty?\n\n\t\t\t\tu = queue.shift\n\n\t\t\t\teach_out_connection_of(u){|v, _|\n\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\treached << v\n\n\t\t\t\t\tnext_queue << v\n\n\t\t\t\t}\n\n\t\t\tend\n\n\t\t\tbreak if next_queue.empty?\n\n\t\t\tqueue = next_queue\n\n\t\t\tdepth += 1\n\n\t\t}\n\n\t\treturn reached\n\n\tend\n\n\n\n\tdef bfs(start)\n\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\n\t\treached = Set[*start.to_a]\n\n\t\tqueue = []\n\n\t\tstart.each{|s| queue << s}\n\n\t\tdist = {}\n\n\t\tloop.with_index {|_, depth|\n\n\t\t\tnext_queue = []\n\n\t\t\tuntil queue.empty?\n\n\t\t\t\tu = queue.shift\n\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\n\t\t\t\tdist[u] = depth\n\n\t\t\t\teach_out_connection_of(u){|v, _|\n\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\treached << v\n\n\t\t\t\t\tnext_queue << v\n\n\t\t\t\t}\n\n\t\t\tend\n\n\t\t\tbreak if next_queue.empty?\n\n\t\t\tqueue = next_queue\n\n\t\t}\n\n\t\tblock_given? ? nil : dist\n\n\tend\n\n\n\n\tdef dijkstra(start)\n\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\n\t\th = Heap.new\n\n\t\treached = Set[*start.to_a]\n\n\t\tstart.each{|s| h.add(s, 0)}\n\n\n\n\t\tdist = {}\n\n\t\tuntil h.empty?\n\n\t\t\tu, key = h.del_min\n\n\t\t\treturn key if block_given? && yield(u, key)\n\n\t\t\tdist[u] = key\n\n\t\t\teach_out_connection_of(u){|v, l|\n\n\t\t\t\td = dist[u] + l\n\n\t\t\t\tif reached.include?(v)\n\n\t\t\t\t\th.update_key(v, d)\n\n\t\t\t\telse\n\n\t\t\t\t\th.add(v, d)\n\n\t\t\t\t\treached << v\n\n\t\t\t\tend\n\n\t\t\t}\n\n\t\tend\n\n\t\tblock_given? ? nil : dist\n\n\tend\n\n\n\n\tdef bidir_dijkstra(s, t)\n\n\t\tf_dist = {}\n\n\t\tb_dist = {}\n\n\n\n\t\tf_heap = Heap.new\n\n\t\tb_heap = Heap.new\n\n\n\n\t\tf_heap.add(s, 0)\n\n\t\tb_heap.add(t, 0)\n\n\n\n\t\tf_reached = Set[s]\n\n\t\tb_reached = Set[t]\n\n\n\n\t\tf_current_dist = b_current_dist = 0\n\n\t\tbest = Float::INFINITY\n\n\n\n\t\tloop {\n\n\t\t\tif !f_heap.empty?\n\n\t\t\t\tu, key = f_heap.del_min\n\n\t\t\t\tf_dist[u] = key\n\n\t\t\t\tf_current_dist = key\n\n\t\t\t\teach_out_connection_of(u){|v, l|\n\n\t\t\t\t\td = f_dist[u] + l\n\n\t\t\t\t\tif b_dist[v]\n\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\n\t\t\t\t\t\tbest = path_len if path_len < best\n\n\t\t\t\t\tend\n\n\t\t\t\t\tif f_reached.include?(v)\n\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\n\t\t\t\t\telse\n\n\t\t\t\t\t\tf_heap.add(v, d)\n\n\t\t\t\t\t\tf_reached << v\n\n\t\t\t\t\tend\n\n\t\t\t\t}\n\n\t\t\tend\n\n\n\n\t\t\tif !b_heap.empty?\n\n\t\t\t\tu, key = b_heap.del_min\n\n\t\t\t\tb_dist[u] = key\n\n\t\t\t\tb_current_dist = key\n\n\t\t\t\teach_in_connection_of(u){|v, l|\n\n\t\t\t\t\td = b_dist[u] + l\n\n\t\t\t\t\tif f_dist[v]\n\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\n\t\t\t\t\t\tbest = path_len if path_len < best\n\n\t\t\t\t\tend\n\n\t\t\t\t\tif b_reached.include?(v)\n\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\n\t\t\t\t\telse\n\n\t\t\t\t\t\tb_heap.add(v, d)\n\n\t\t\t\t\t\tb_reached << v\n\n\t\t\t\t\tend\n\n\t\t\t\t}\n\n\t\t\tend\n\n\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\n\t\t}\n\n\tend\n\n\n\n\tdef a_star(start)\n\n\t\traise \"a_star need termination condition\" unless block_given?\n\n\t\th = Heap.new\n\n\t\treached = Set[start]\n\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\n\n\t\tdist = {}\n\n\t\tuntil h.empty?\n\n\t\t\tu, (e, d) = h.del_min\n\n\t\t\treturn d if yield(u, dist)\n\n\t\t\tdist[u] = d\n\n\t\t\teach_out_connection_of(u){|v, l|\n\n\t\t\t\td = dist[u] + l\n\n\t\t\t\te = d + a_star_heuristic(v)\n\n\t\t\t\tif reached.include?(v)\n\n\t\t\t\t\th.update_key(v, [e, d])\n\n\t\t\t\telse\n\n\t\t\t\t\th.add(v, [e, d])\n\n\t\t\t\t\treached << v\n\n\t\t\t\tend\n\n\t\t\t}\n\n\t\tend\n\n\t\tblock_given? ? nil : dist\n\n\tend\n\n\n\n\t#make_variations :bidir_dijkstra\n\n\n\n\tdef prim(start)\n\n\t\th = Heap.new\n\n\t\th.add(start, 0)\n\n\t\treached = Set[start]\n\n\t\ttree_len = 0\n\n\n\n\t\tuntil h.empty?\n\n\t\t\tu, key = h.del_min\n\n\t\t\ttree_len += key\n\n\n\n\t\t\teach_out_connection_of(u){|v, d|\n\n\t\t\t\tif reached.include?(v)\n\n\t\t\t\t\th.update_key(v, d)\n\n\t\t\t\telse\n\n\t\t\t\t\th.add(v, d)\n\n\t\t\t\t\treached << v\n\n\t\t\t\tend\n\n\t\t\t}\n\n\t\tend\n\n\t\ttree_len\n\n\tend\n\n\n\n\tdef each_layer_from(start)\n\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\n\t\treturn enum_for(__method__, start) unless block_given?\n\n\t\treached = Set[*start]\n\n\t\tcurrent_layer = start\n\n\n\n\t\tloop {\n\n\t\t\tyield current_layer\n\n\t\t\tnext_layer = []\n\n\t\t\tcurrent_layer.each{|u|\n\n\t\t\t\teach_out_connection_of(u){|v|\n\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\treached << v\n\n\t\t\t\t\tnext_layer << v\n\n\t\t\t\t}\n\n\t\t\t}\t\n\n\n\n\t\t\treturn if next_layer.empty?\n\n\t\t\tcurrent_layer = next_layer\n\n\t\t}\n\n\tend\n\nend\n\n\n\nclass Graph\n\n\tinclude Graphical\n\n\n\n\tdef initialize(*options)\n\n\t\t@options = Set[*options]\n\n\tend\n\n\n\n\tdef add_node(property = {})\n\n\t\tNode.new(property)\n\n\tend\n\n\n\n\tdef add_edge(u, v, property = {})\n\n\t\te = Edge.new(u, v, property)\n\n\t\tu.add_edge(e)\n\n\t\tv.add_edge(e)\n\n\t\te\n\n\tend\n\n\t\n\n\tdef del_edge(e)\n\n\t\tu, v = e.opposite.keys\n\n\t\tu.del_edge(e)\n\n\t\tv.del_edge(e)\n\n\t\te\n\n\tend\n\n\n\n\tclass Node\n\n\t\tdef initialize(property)\n\n\t\t\t@property = property\n\n\t\t\t@edges = Set.new\n\n\t\tend\n\n\n\n\t\tdef add_edge(e)\n\n\t\t\t@edges << e\n\n\t\tend\n\n\n\n\t\tdef del_edge(e)\n\n\t\t\t@edges.delete(e)\n\n\t\tend\n\n\n\n\t\tdef to_s\n\n\t\t\t@property[:name] || super\n\n\t\tend\n\n\n\n\t\tdef each_edge\n\n\t\t\t@edges.each{|e| \n\n\t\t\t\tyield e\n\n\t\t\t}\n\n\t\tend\n\n\n\n\t\tattr_reader :property\n\n\tend\n\n\n\n\tclass Edge\n\n\t\tdef initialize(u, v, property)\n\n\t\t\t@opposite = {u => v, v => u}\n\n\t\t\t@property = property\n\n\t\tend\n\n\t\tattr_reader :opposite, :property\n\n\n\n\t\tdef to_s\n\n\t\t\t@property[:name] || super\n\n\t\tend\n\n\n\n\t\tdef length\n\n\t\t\t@property[:length] || 1\n\n\t\tend\n\n\tend\n\n\n\n\tdef each_out_connection_of(u)\n\n\t\tu.each_edge{|e|\n\n\t\t\tyield(e.opposite[u], e.length)\n\n\t\t}\n\n\tend\n\n\n\n\talias :each_in_connection_of :each_out_connection_of\n\nend\n\n\n\ndef rotation_matrix(radian)\n\n\tMatrix[\n\n\t\t[Math.cos(radian), -Math.sin(radian)],\n\n\t\t[Math.sin(radian),  Math.cos(radian)]\n\n\t]\n\nend\n\n\n\nclass Line\n\n\tdef initialize(*args)\n\n\t\t@x1, @y1, @x2, @y2 = args\n\n\t\t@a = @y2 - @y1\n\n\t\t@b = @x1 - @x2\n\n\t\t@c = @a * @x1 + @b * @y1\n\n\tend\t\n\n\n\n\tdef distance(x, y)\n\n\t\tv1 = Vector[@x2 - @x1, @y2 - @y1]\n\n\t\tv2 = Vector[x - @x1, y - @y1]\n\n\t\tv3 = Vector[x - @x2, y - @y2]\n\n\t\tx = v1.inner_product(v2) / v1.r\n\n\n\n\t\td = sqrt([v2.r ** 2 - x ** 2, 0].max)\n\n\t\ta = v2.r\n\n\t\tb = v3.r\n\n\t\tc = v1.r\n\n\t\tif a * a + b * b - c * c < 0\n\n\t\t\td\n\n\t\telse\n\n\t\t\ta < b ? a : b\n\n\t\tend\n\n\tend\n\n\n\n\tdef parallel?(l)\n\n\t\t@a * l.b - @b * l.a == 0\n\n\tend\n\n\n\n\tdef cross?(l)\n\n\t\t(@a * l.x1 + @b * l.y1 + @c) * (@a * l.x2 + @b * l.y2 + @c) <= 0 and\n\n\t\t(l.a * @x1 + l.b * @y1 + l.c) * (l.a * @x2 + l.b * @y2 + l.c) <= 0\n\n\tend\n\n\n\n\tdef cross_point_vec(l)\n\n\t\tm = Matrix[\n\n\t\t\t[@a, @b],\n\n\t\t\t[l.a, l.b]\n\n\t\t\t]\n\n\t\tv = Vector[@c, l.c]\n\n\t\t(m.inv * v)\n\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\n\nend\n\n\n\nclass Star\n\n\tdef initialize(*args)\n\n\t\t@x, @y, @a, @r = args\n\n\t\tc = Vector[@x, @y]\n\n\t\tv = Vector[0, @r]\n\n\t\tv = rotation_matrix(@a * PI / 180) * v\n\n\t\t@points = (1..5).map do\n\n\t\t\t(c + v).tap { v = rotation_matrix(144 * PI / 180) * v }\n\n\t\tend\n\n\t\t@points\n\n\t\t@lines = (@points + [@points[0]]).each_cons(2).map do |p1, p2|\n\n\t\t\tLine.new(*p1, *p2)\n\n\t\tend\n\n\tend\n\n\t\n\n\tdef distance(star)\n\n\t\t@lines.each do |l1|\n\n\t\t\tstar.lines.each do |l2|\n\n\t\t\t\treturn 0 if l1.cross?(l2)\n\n\t\t\tend\n\n\t\tend\t\n\n\n\n\t\tds = []\n\n\t\t@points.each do |p|\n\n\t\t\tstar.lines.each do |l|\n\n\t\t\t\tds << l.distance(*p.to_a)\n\n\t\t\tend\n\n\t\tend\t\n\n\t\tstar.points.each do |p|\n\n\t\t\t@lines.each do |l|\n\n\t\t\t\tds << l.distance(*p.to_a)\n\n\t\t\tend\n\n\t\tend\t\n\n\t\tds.min\n\n\tend\n\n\n\n\tattr_reader :lines, :points\nend\n\nloop do\n\n\tn, m, l = gets.split.map(&:to_i)\n\n\tbreak if n == 0\n\n\tstars = (0..n-1).map { Star.new(*gets.split.map(&:to_i)) }\n\n\tg = Graph.new\n\n\tnodes = (0..n-1).map { g.add_node }\n\n\t(0..n-1).to_a.combination(2) do |i, j|\n\n\t\tg.add_edge(nodes[i], nodes[j], {:length => stars[i].distance(stars[j])})\n\n\tend\n\n\tp g.dijkstra([nodes[m-1]])[nodes[l-1]]\n\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        static if (op == \"+\") {\n            return Point(x + p.x, y + p.y);\n        } else if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n    Point opBinary(alias op)(double k) const {\n        static if (op == \"*\") {\n            return Point(x * k, y * k);\n        }\n    }\n}\ndouble norm(in Point p) {\n    return sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1; \n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;     \n    if (b.norm < c.norm) return -2;  \n    return 0;                       \n}\n\nstruct Segment {\n    Point a, b;\n}\nbool contains(in Segment s, in Point p) {\n    Point u = s.a - p,\n          v = s.b - p;\n    return abs(cross(u, v)) < EPS && dot(u, v) < -EPS;\n}\n\ndouble distance(in Point a, in Point b) {\n    double dx = a.x - b.x,\n           dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nPoint projection(in Segment s, in Point p) {\n    Point u = s.b - s.a,\n          v = p - s.a;\n    double n = u.norm;\n    return s.a + u * (dot(u, v) / (n * n));\n}\n\ndouble distance(in Segment s, in Point p) {\n    auto ret = min(distance(p, s.a), distance(p, s.b));\n    Point proj = s.projection(p);\n    if (s.contains(proj)) {\n        ret = min(ret, (p - proj).norm);\n    }\n    return ret;\n}\ndouble distance(in Point p, in Segment s) {\n    return distance(s, p);\n}\n\nbool intersect(in Segment s, in Segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble distance(in Segment s, in Segment t) {\n    if (intersect(s, t)) return 0;\n    return min( distance(s.a, t), distance(s.b, t),\n                distance(s, t.a), distance(s, t.b) );\n}\n\nvoid main() {\n\n    int N, M, L;\n    Segment[][] S;\n    \n    bool input() {\n        scanf(\"%d %d %d\\n\", &N, &M, &L);\n        if (N == 0 && M == 0 && L == 0) return false;\n        S = new Segment[][N];\n        foreach (i; 0 .. N) {\n            double x, y, a, r;\n            scanf(\"%lf %lf %lf %lf\\n\", &x, &y, &a, &r);\n            auto Ps = new Point[5];\n            double d = 2.0 * PI / 5.0;\n            a = 2.0 * PI / 360 * a;\n            foreach (j; 0 .. 5) {\n                Ps[j] = Point(x - r * sin(a + d * j), y + r * cos(a + d * j));\n            }\n            S[i] = new Segment[5];\n            foreach (j; 0 .. 5) {\n                S[i][j] = Segment(Ps[j], Ps[(j + 2) % 5]);\n            }\n        }\n        return true;\n    }\n\n    void solve() {\n        auto G = new double[][](N, N);\n        foreach (i; 0 .. N) G[i][] = 1e9;\n        M--; L--;\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                foreach (a; 0 .. 5) {\n                    foreach (b; 0 .. 5) {\n                        G[i][j] = min(G[i][j], distance(S[i][a], S[j][b]));\n                    }\n                }\n            }\n        }\n        foreach (k; 0 .. N) {\n            foreach (i; 0 .. N) {\n                foreach (j; 0 .. N) {\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                }\n            }\n        }\n        writefln(\"%.10f\", G[M][L]);\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        static if (op == \"+\") {\n            return Point(x + p.x, y + p.y);\n        } else if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n    double norm() const {\n        return sqrt(x * x + y * y);\n    }\n}\n\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1; \n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;     \n    if (b.norm < c.norm) return -2;  \n    return 0;                       \n}\n\nstruct Segment {\n    Point a, b;\n}\n\ndouble distance(in Point a, in Point b) {\n    double dx = a.x - b.x,\n           dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble distance(in Segment s, in Point p) {\n    Point u = s.b - s.a,\n          v = p - s.a;\n    return min( cross(u, v) / distance(s.a, s.b),\n                distance(p, s.a),\n                distance(p, s.b) );\n}\n\nbool intersect(in Segment s, in Segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble distance(in Segment s, in Segment t) {\n    if (intersect(s, t)) return 0;\n    return min( distance(s.a, t.a), distance(s.a, t.b),\n                distance(s.b, t.a), distance(s.b, t.b) );\n}\n\nvoid main() {\n\n    int N, M, L;\n    Segment[][] S;\n    \n    bool input() {\n        scanf(\"%d %d %d\\n\", &N, &M, &L);\n        if (N == 0 && M == 0 && L == 0) return false;\n        S = new Segment[][N];\n        foreach (i; 0 .. N) {\n            double x, y, a, r;\n            scanf(\"%lf %lf %lf %lf\\n\", &x, &y, &a, &r);\n            auto Ps = new Point[5];\n            double d = 2.0 * PI / 5.0;\n            a = 2.0 * PI / 360 * a;\n            foreach (j; 0 .. 5) {\n                Ps[j] = Point(x - r * sin(a + d * j), y + r * cos(a + d * j));\n            }\n            S[i] = new Segment[5];\n            foreach (j; 0 .. 5) {\n                S[i][j] = Segment(Ps[j], Ps[(j + 2) % 5]);\n            }\n        }\n        return true;\n    }\n\n    void solve() {\n        auto G = new double[][](N, N);\n        foreach (i; 0 .. N) G[i][] = 1e9;\n        M--; L--;\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                foreach (a; 0 .. 5) {\n                    foreach (b; 0 .. 5) {\n                        G[i][j] = min(G[i][j], distance(S[i][a], S[j][b]));\n                    }\n                }\n            }\n        }\n        foreach (k; 0 .. N) {\n            foreach (i; 0 .. N) {\n                foreach (j; 0 .. N) {\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                }\n            }\n        }\n        writefln(\"%.10f\", G[M][L]);\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        static if (op == \"+\") {\n            return Point(x + p.x, y + p.y);\n        } else if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n    double norm() const {\n        return sqrt(x * x + y * y);\n    }\n}\n\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // 蜿肴凾險亥捉繧?    if (cross(b, c) < -EPS) return -1;     // 譎りィ亥捉繧?    if (dot(b, c) < 0) return +2;          // c--a--b 逶エ邱?    if (b.norm < c.norm) return -2;    // a--b--c 逶エ邱?    return 0;                              // a--c--b 逶エ邱?}\n\nstruct Segment {\n    Point a, b;\n}\n\ndouble distance(in Point a, in Point b) {\n    double dx = a.x - b.x,\n           dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble distance(in Segment s, in Point p) {\n    Point u = s.b - s.a,\n          v = p - s.a;\n    return min( cross(u, v) / distance(s.a, s.b),\n                distance(p, s.a),\n                distance(p, s.b) );\n}\n\nbool intersect(in Segment s, in Segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble distance(in Segment s, in Segment t) {\n    if (intersect(s, t)) return 0;\n    return min( distance(s.a, t.a), distance(s.a, t.b),\n                distance(s.b, t.a), distance(s.b, t.b) );\n}\n\nvoid main() {\n\n    int N, M, L;\n    Segment[][] S;\n    \n    bool input() {\n        scanf(\"%d %d %d\\n\", &N, &M, &L);\n        if (N == 0 && M == 0 && L == 0) return false;\n        S = new Segment[][N];\n        foreach (i; 0 .. N) {\n            double x, y, a, r;\n            scanf(\"%lf %lf %lf %lf\\n\", &x, &y, &a, &r);\n            auto Ps = new Point[5];\n            double d = 2.0 * PI / 5.0;\n            a = 2.0 * PI / 360 * a;\n            foreach (j; 0 .. 5) {\n                Ps[j] = Point(x - r * sin(a + d * j), y + r * cos(a + d * j));\n            }\n            S[i] = new Segment[5];\n            foreach (j; 0 .. 5) {\n                S[i][j] = Segment(Ps[j], Ps[(j + 2) % 5]);\n            }\n        }\n        return true;\n    }\n\n    void solve() {\n        auto G = new double[][](N, N);\n        foreach (i; 0 .. N) G[i][] = 1e9;\n        M--; L--;\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                foreach (a; 0 .. 5) {\n                    foreach (b; 0 .. 5) {\n                        G[i][j] = min(G[i][j], distance(S[i][a], S[j][b]));\n                    }\n                }\n            }\n        }\n        foreach (k; 0 .. N) {\n            foreach (i; 0 .. N) {\n                foreach (j; 0 .. N) {\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                }\n            }\n        }\n        writefln(\"%.10f\", G[M][L]);\n    }\n\n    while (input) solve;\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        static if (op == \"+\") {\n            return Point(x + p.x, y + p.y);\n        } else if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n    double norm() const {\n        return sqrt(x * x + y * y);\n    }\n}\n\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // 蜿肴凾險亥捉繧?    if (cross(b, c) < -EPS) return -1;     // 譎りィ亥捉繧?    if (dot(b, c) < 0) return +2;          // c--a--b 逶エ邱?    if (b.norm < c.norm) return -2;    // a--b--c 逶エ邱?    return 0;                              // a--c--b 逶エ邱?}\n\nstruct Segment {\n    Point a, b;\n}\n\ndouble distance(in Point a, in Point b) {\n    double dx = a.x - b.x,\n           dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble distance(in Segment s, in Point p) {\n    Point u = s.b - s.a,\n          v = p - s.a;\n    return min( cross(u, v) / distance(s.a, s.b),\n                distance(p, s.a),\n                distance(p, s.b) );\n}\n\nbool intersect(in Segment s, in Segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble distance(in Segment s, in Segment t) {\n    if (intersect(s, t)) return 0;\n    return min( distance(s.a, t.a), distance(s.a, t.b),\n                distance(s.b, t.a), distance(s.b, t.b) );\n}\n\nvoid main() {\n\n    int N, M, L;\n    Segment[][] S;\n    \n    bool input() {\n        scanf(\"%d %d %d\\n\", &N, &M, &L);\n        if (N == 0 && M == 0 && L == 0) return false;\n        S = new Segment[][N];\n        foreach (i; 0 .. N) {\n            double x, y, a, r;\n            scanf(\"%lf %lf %lf %lf\\n\", &x, &y, &a, &r);\n            auto Ps = new Point[5];\n            double d = 2.0 * PI / 5.0;\n            a = 2.0 * PI / 360 * a;\n            foreach (j; 0 .. 5) {\n                Ps[j] = Point(x - r * sin(a + d * j), y + r * cos(a + d * j));\n            }\n            S[i] = new Segment[5];\n            foreach (j; 0 .. 5) {\n                S[i][j] = Segment(Ps[j], Ps[(j + 2) % 5]);\n            }\n        }\n        return true;\n    }\n\n    void solve() {\n        auto G = new double[][](N, N);\n        foreach (i; 0 .. N) G[i][] = 1e9;\n        M--; L--;\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                foreach (a; 0 .. 5) {\n                    foreach (b; 0 .. 5) {\n                        G[i][j] = min(G[i][j], distance(S[i][a], S[j][b]));\n                    }\n                }\n            }\n        }\n        foreach (k; 0 .. N) {\n            foreach (i; 0 .. N) {\n                foreach (j; 0 .. N) {\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                }\n            }\n        }\n        writefln(\"%.10f\", G[M][L]);\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef _kosa(a1, a2, b1, b2):\n    x1,y1,_ = a1\n    x2,y2,_ = a2\n    x3,y3,_ = b1\n    x4,y4,_ = b2\n\n    tc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3)\n    td = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4)\n    return tc*td < 0\n\ndef kosa(a1, a2, b1, b2):\n    return _kosa(a1,a2,b1,b2) and _kosa(b1,b2,a1,a2)\n\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\ndef distance3(p1, p2, p3):\n    x1,y1,_ = p1\n    x2,y2,_ = p2\n    x3,y3,_ = p3\n\n    ax = x2 - x1\n    ay = y2 - y1\n    bx = x3 - x1\n    by = y3 - y1\n\n    r = (ax*bx + ay*by) / (ax*ax+ay*ay)\n    if r <= 0:\n        return distance(x1,y1, x3,y3)\n    if r >= 1:\n        return distance(x2,y2, x3,y3)\n    return distance(x1 + r*ax, y1 + r*ay, x3,y3)\n\ndef main():\n    rr = []\n\n    def f(n,m,l):\n        aa = []\n        for i in range(n):\n            x,y,a,r = LI()\n            b = a / 360 * math.pi * 2 + math.pi / 2\n            t = []\n            for j in range(5):\n                c = b + math.pi * 2 / 5 * j\n                t.append((math.cos(c) * r + x, math.sin(c) * r + y, i))\n            for j in range(5):\n                aa.append((t[j], t[j-2]))\n        d = [[inf] * n for _ in range(n)]\n        for i in range(n*5):\n            a1,a2 = aa[i]\n            ii = a1[2]\n            for j in range(i+1,n*5):\n                b1,b2 = aa[j]\n                ji = b1[2]\n                if ii == ji or d[ii][ji] == 0:\n                    continue\n                if kosa(a1,a2,b1,b2):\n                    d[ii][ji] = 0\n                    continue\n                t = []\n                t.append(distance3(a1, a2, b1))\n                t.append(distance3(a1, a2, b2))\n                t.append(distance3(b1, b2, a1))\n                t.append(distance3(b1, b2, a2))\n                tm = min(t)\n                if d[ii][ji] > tm:\n                    d[ii][ji] = tm\n        e = collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1,n):\n                e[i].append((j, d[i][j]))\n                e[j].append((i, d[i][j]))\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in e[u]:\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n            return d\n\n        dk = search(m-1)\n\n        return dk[l-1]\n\n\n    while True:\n        n,m,l = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m,l))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef ky(p1, p2):\n    x1,y1,_ = p1\n    x2,y2,_ = p2\n    return ((x1-x2)**2 + (y1-y2)**2) ** 0.5\n\ndef distance(p1, p2, p3):\n    x1,y1,_ = p1\n    x2,y2,_ = p2\n    x3,y3,_ = p3\n\n    ax = x2 - x1\n    ay = y2 - y1\n    bx = x3 - x1\n    by = y3 - y1\n\n    r = (ax*bx + ay*by) / (ax*ax+ay*ay)\n    if r <= 0:\n        return ky(p1, p3)\n    if r >= 1:\n        return ky(p2, p3)\n    pt = (x1 + r*ax, y1 + r*ay, 0)\n    return ky(pt, p3)\n\ndef main():\n    rr = []\n\n    def f(n,m,l):\n        aa = []\n        for i in range(n):\n            x,y,a,r = LI()\n            b = a / 360 * math.pi * 2 + math.pi / 2\n            t = []\n            for j in range(5):\n                c = b + math.pi * 2 / 5 * j\n                t.append((math.cos(c) * r + x, math.sin(c) * r + y, i))\n            for j in range(5):\n                aa.append((t[j], t[j-2]))\n        d = [[inf] * n for _ in range(n)]\n        for i in range(n*5):\n            a1,a2 = aa[i]\n            ii = a1[2]\n            for j in range(i+1,n*5):\n                b1,b2 = aa[j]\n                ji = b1[2]\n                if ii == ji:\n                    continue\n                t = []\n                t.append(distance(a1, a2, b1))\n                t.append(distance(a1, a2, b2))\n                t.append(distance(b1, b2, a1))\n                t.append(distance(b1, b2, a2))\n                tm = min(t)\n                if d[ii][ji] > tm:\n                    d[ii][ji] = tm\n        e = collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1,n):\n                e[i].append((j, d[i][j]))\n                e[j].append((i, d[i][j]))\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in e[u]:\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n            return d\n\n        dk = search(m-1)\n\n        return dk[l-1]\n\n\n    while True:\n        n,m,l = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m,l))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from math import cos as cos_\nfrom math import sin as sin_\nfrom math import sqrt\nfrom math import radians\n\ndef cos(degree):\n    return cos_(radians(degree))\n\ndef sin(degree):\n    return sin_(radians(degree))\n\ndef five_points(x,y,a,r):\n    lis=[]\n    for i in range(5):\n        lis.append((x-r*sin(a-72*i*2),y+r*cos(a-72*i*2)))\n    lis.append(lis[0])\n    return lis\n\ndef distance2lines(r1,r2,r3,r4):\n    #check crossing\n    if (((r2[0]-r1[0])*(r3[1]-r1[1])-(r2[1]-r1[1])*(r3[0]-r1[0]))\\\n       *((r2[0]-r1[0])*(r4[1]-r1[1])-(r2[1]-r1[1])*(r4[0]-r1[0])) <= 0) and\\\n       (((r4[0]-r3[0])*(r1[1]-r3[1])-(r4[1]-r3[1])*(r1[0]-r3[0]))\\\n       *((r4[0]-r3[0])*(r2[1]-r3[1])-(r4[1]-r3[1])*(r2[0]-r3[0])) <= 0):\n        return 0\n    if (0<=((r2[0]-r1[0])*(r3[0]-r1[0])+(r2[1]-r1[1])*(r3[1]-r1[1]))<=((r2[0]-r1[0])**2+(r2[1]-r1[1])**2)):\n        d3=abs((r2[0]-r1[0])*(r3[1]-r1[1])-(r2[1]-r1[1])*(r3[0]-r1[0]))/sqrt((r2[1]-r1[1])**2+(r2[0]-r1[0])**2)\n    else:\n        d3=min(sqrt((r3[1]-r1[1])**2+(r3[0]-r1[0])**2),sqrt((r3[1]-r2[1])**2+(r3[0]-r2[0])**2))\n    if (0<=((r2[0]-r1[0])*(r4[0]-r1[0])+(r2[1]-r1[1])*(r4[1]-r1[1]))<=((r2[0]-r1[0])**2+(r2[1]-r1[1])**2)):\n        d4=abs((r2[0]-r1[0])*(r4[1]-r1[1])-(r2[1]-r1[1])*(r4[0]-r1[0]))/sqrt((r2[1]-r1[1])**2+(r2[0]-r1[0])**2)\n    else:\n        d4=min(sqrt((r4[1]-r1[1])**2+(r4[0]-r1[0])**2),sqrt((r4[1]-r2[1])**2+(r4[0]-r2[0])**2))\n    return min(d3,d4)\n    \n\ndef distance2stars(x1,y1,a1,r1,x2,y2,a2,r2):\n    star1=five_points(x1,y1,a1,r1)\n    star2=five_points(x2,y2,a2,r2)\n    ans=float('inf')\n    for i in range(5):\n        for j in range(5):\n            ans=min(ans,distance2lines(star1[i],star1[i+1],star2[j],star2[j+1]))\n            ans=min(ans,distance2lines(star2[i],star2[i+1],star1[j],star1[j+1]))\n    return ans\n\nN,M,L=map(int,input().split())\nwhile N!=0:\n    stars=[]\n    for i in range(N):\n        stars.append(tuple(map(int,input().split())))\n    d=[[0]*N for i in range(N)]\n    for i in range(N):\n        x1,y1,a1,r1=stars[i]\n        for j in range(i+1,N):\n            x2,y2,a2,r2=stars[j]\n            d[i][j]=distance2stars(x1,y1,a1,r1,x2,y2,a2,r2)\n    for i in range(N):\n        for j in range(0,i):\n            d[i][j]=d[j][i]\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n    print(d[M-1][L-1])\n    N,M,L=map(int,input().split())\n\n\n    \n\n"
  }
]