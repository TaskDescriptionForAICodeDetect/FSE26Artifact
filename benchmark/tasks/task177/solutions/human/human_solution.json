[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  Panel *parent;\n  vector<Panel> child;\n};\n\nstring s;\nPanel list={\"\",0,0,0,0,NULL};\npair<string,int>ans;\nint maxDepth;\n\nvoid parse(string s)\n{\n  stringstream ss;\n  for(int i=0;i<s.size();i++)if(s[i]==','||s[i]=='<'||s[i]=='>')s[i]=' ';\n  ss.str(s);\n\n  stack<string>st;\n\n  Panel *now=&list;\n  ss>>list.name>>list.x1>>list.y1>>list.x2>>list.y2;\n  st.push(list.name);\n\n  while(!st.empty()){\n    Panel p={\"\",0,0,0,0,NULL};\n    ss>>p.name;\n    if(p.name[0]=='/'){\n      st.pop();\n      now=(*now).parent;\n      continue;\n    }\n    st.push(p.name);\n    p.parent=now;\n    ss>>p.x1>>p.y1>>p.x2>>p.y2;\n    (*now).child.push_back(p);\n    now=&(*now).child[(*now).child.size()-1];\n  }\n\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n  if(x<p.x1 || p.x2<x || y<p.y1 || p.y2<y)return;\n  if(maxDepth<depth){\n    maxDepth=depth;\n    ans.first=p.name;\n    ans.second=p.child.size();\n  }\n  vector<Panel>::iterator it;\n  for(it=p.child.begin();it!=p.child.end();it++)solve(*it,x,y,depth+1);\n}\n\nint main()\n{\n  int n,x,y;\n  while(cin>>n,n){\n    cin>>s;\n    parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      solve(list,x,y,0);\n      if(maxDepth==-1){\n\tans.first=\"OUT OF MAIN PANEL\";\n\tans.second=1;\n      }\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Point{\npublic:\n  string name;  \n  int l,r,u,d,s,ss;\n};\n\nint main(){\n  int i,j,n,x[100],y[100],c,s;\n  Point p[1000];\n  string str;\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    cin >> str;\n  for(i=0;i<n;i++) cin >> x[i] >> y[i];\n\n  c = 0;\n  s = 0;\n\n  for(i=0;i<str.size()-1;i++){\n    if(str[i] == '<' && str[i+1] != '/'){\n      i++;\n      for(;str[i] != '>';i++) p[c].name += str[i];\n\n      i++;\n      p[c].l = p[c].r = p[c].u = p[c].d = 0;\n\n      for(;str[i] != ',';i++){\n\tp[c].l *= 10;\n\tp[c].l += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != ',';i++){\n\tp[c].u *= 10;\n\tp[c].u += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != ',';i++){\n\tp[c].r *= 10;\n\tp[c].r += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != '<';i++){\n\tp[c].d *= 10;\n\tp[c].d += str[i] - '0';\n      }\n      p[c].s = s;\n      c++;\n      s++;\n      i--;\n    }\n    else if(str[i] == '<' && str[i+1] == '/') s--;\n  }\n  \n  for(i=0;i<c;i++){\n    p[i].ss = 0;\n    for(j=i+1;j<c;j++){\n      if(p[i].s >= p[j].s) break;\n      else if(p[i].s + 1 == p[j].s) p[i].ss++;\n    }\n  }\n\n  for(i=0;i<n;i++){\n    Point u,v;\n    bool f = false;\n    for(j=0;j<c;j++){\n      if(p[j].l <= x[i] && x[i] <= p[j].r && p[j].u <= y[i] && y[i] <= p[j].d){\n\tif(!f){\n\t  f = true;\n\t  u = p[j];\n\t}\n\telse{\n\t  v = p[j];\n\t  if(u.s < v.s) u = v;\n\t}\n      }\n    }\n    if(f) cout << u.name << \" \" << u.ss << endl;\n    else cout << \"OUT OF MAIN PANEL 1\" << endl;\n  }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\nbool between(int a, int b, int c){\n        return a <= b && b <= c;\n}\n\nvector<string> split(const string &s, char c){\n        vector<string> v;\n        size_t prev = 0, cur;\n        while((cur = s.find(c, prev)) != string::npos){\n                v.push_back(s.substr(prev, cur - prev));\n                prev = cur + 1;\n        }\n        v.push_back(s.substr(prev));\n        return v;\n}\n\nint to_int(const string &s){\n        return atoi(s.c_str());\n}\n\nstruct Node {\n        string name;\n        int left, top, right, bottom;\n        vector<Node> children;\n};\n\nstruct Result {\n        Node node;\n        int p;\n};\n\nResult parse(const string &s, int p){\n        Result r;\n        ++p;\n        size_t t = s.find('>', p);\n        r.node.name = s.substr(p, t - p);\n        p = t + 1;\n        t = s.find('<', p);\n        vector<string> loc = split(s.substr(p, t - p), ',');\n        r.node.left = to_int(loc[0]);\n        r.node.top = to_int(loc[1]);\n        r.node.right = to_int(loc[2]);\n        r.node.bottom = to_int(loc[3]);\n        p = t;\n        while(s[p + 1] != '/'){\n                Result q = parse(s, p);\n                r.node.children.push_back(q.node);\n                p = q.p;\n        }\n        r.p = p + 3 + r.node.name.size();\n        return r;\n}\n\npair<string, int> solve(const Node &n, int x, int y){\n        pair<string, int> r(n.name, n.children.size());\n        for(int i = 0; i < n.children.size(); ++i){\n                const Node &c = n.children[i];\n                if(between(c.left, x, c.right) && between(c.top, y, c.bottom)){\n                        r = solve(c, x, y);\n                        break;\n                }\n        }\n        return r;\n}\n\nint main(){\n        while(true){\n                int n;\n                cin >> n;\n                if(n == 0){ break; }\n                string s;\n                cin >> s;\n                s = \"<OUT OF MAIN PANEL>0,0,10000,10000\" + s + \"</OUT OF MAIN PANEL>\";\n                Node root = parse(s, 0).node;\n                while(n--){\n                        int x, y;\n                        cin >> x >> y;\n                        pair<string, int> answer = solve(root, x, y);\n                        cout << answer.first << \" \" << answer.second << endl;\n                }\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(const Data& now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n\n  bool flag = true;\n  while(flag){\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n\n  Cursol crl;\n\n  while(cin >> n, n){\n    Data Main; //メインパネル\n\n    cin >> tag;\n\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n\n  \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <stack>\n#include <cstdio>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n  char c;\n  map<int*, string> tags;\n  stack<int*> stk;\n  int n;\n  while (true) {\n    cin >> n;\n    if (n == 0)\n      break;\n\n    while (cin >> c) {\n      cin >> c;\n      if (c != '/') {\n        string s = string(\"\") + c;\n        while (true) {\n          cin >> c;\n          if (c == '>')\n            break;\n          s += c;\n        }\n        int *tmp = new int[5];\n        cin >> tmp[0] >> c >> tmp[1] >> c;\n        cin >> tmp[2] >> c >> tmp[3];\n        tmp[4] = 0;\n        tags.insert(pair<int*, string>(tmp, s));\n        if (!stk.empty()) {\n          int *bef = stk.top();\n          bef[4]++;\n        }\n        stk.push(tmp);\n      } else {\n        while (true) {\n          cin >> c;\n          if (c == '>')\n            break;\n        }\n        stk.pop();\n        if (stk.empty())\n          break;\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      int *result = NULL;\n      int x, y;\n      cin >> x >> y;\n      for (map<int*, string>::iterator itr = tags.begin();\n           itr != tags.end(); itr++) {\n        if (itr->first[0] <= x && x <= itr->first[2] &&\n            itr->first[1] <= y && y <= itr->first[3])\n          result = itr->first;\n      }\n      if (result == NULL)\n        cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else\n        cout << tags[result] << ' ' << result[4] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  string tag;\n  int x1,y1,x2,y2,depth,cnt;\n  P(string tag=\"$\",int x1=inf,int y1=inf,int x2=inf,int y2=inf,int depth=inf,int cnt=inf):tag(tag),x1(x1),y1(y1),x2(x2),y2(y2),depth(depth),cnt(cnt){}\n};\n\nstring par;\nvector<P> info;\nint pos;\n\nstring getTag()\n{\n  assert(par[pos] == '<');\n  pos++;\n  string tag = \"\";\n  while(par[pos] != '>')\n    {\n      tag += par[pos];\n      pos++;\n    }\n  assert(par[pos] == '>');\n  pos++;\n  if(tag[0] == '/')tag = tag.substr(1,tag.size()-1);\n  return tag;\n}\n\nbool exp(int depth)\n{\n  if(par[pos+1] == '/')\n    {\n      return false;\n    }\n\n  string tag = getTag();\n\n  vector<int> coor;\n  int value = 0;\n  while(par[pos] != '<')\n    {\n\n      value *= 10;\n      value += (par[pos]-'0');\n      pos++;\n      if(par[pos] == ',')\n\t{\n\t  coor.push_back(value);\n\t  value = 0;\n\t  pos++;\n\t}\n\n    }\n\n  coor.push_back(value);\n\n  assert((int)coor.size() == 4);\n\n  int cnt = 0;\n  while(exp(depth+1))\n    {\n      cnt++;\n    }\n\n  assert(pos+1 < par.size() && par[pos+1] == '/');\n\n  info.push_back(P(tag,coor[0],coor[1],coor[2],coor[3],depth,cnt));\n\n  string tag2 = getTag();\n  assert(tag == tag2);\n\n  return true;\n\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      info.clear();\n      cin >> par;\n\n\n      pos = 0;\n      exp(0);\n      /*\n      cout << \"INFO\" << endl;\n      rep(i,info.size())\n\t{\n\t  cout << info[i].tag << \" (\" << info[i].x1 << \",\" << info[i].y1 << \") (\" << info[i].x2 << \",\" << info[i].y2 << \") depth = \" << info[i].depth << \" cnt = \" << info[i].cnt << endl; \n\t}\n      */\n\n\n      int p;\n      rep(i,n)\n\t{\n\t  int x,y;\n\t  cin >> x >> y;\n\t  p = inf;\n\t  rep(j,info.size())\n\t    {\n\t      int x1 = info[j].x1, x2 = info[j].x2;\n\t      int y1 = info[j].y1, y2 = info[j].y2;\n\t      if(x1 <= x && x <= x2 && y1 <= y && y <= y2)\n\t\t{\n\n\t\t  if(p == inf)p = j;\n\t\t  else if(info[p].depth < info[j].depth)\n\t\t    {\n\t\t      assert(info[p].depth != info[j].depth);\n\t\t      p = j;\n\t\t    }\n\t\t}\n\t    }\n\t  if(p == inf)cout << \"OUT OF MAIN PANEL 1\" << endl;\n\t  else cout << info[p].tag << \" \" << info[p].cnt << endl;\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tPanel(string n,int x1,int y1,int x2,int y2):name(n),x1(x1),y1(y1),x2(x2),y2(y2){}\n};\nostream& operator<<(ostream& os,const Panel& p){\n\treturn os<<'('<<p.name<<','<<p.x1<<','<<p.y1<<','<<p.x2<<','<<p.y2<<')';\n}\n\nint parse(string& s,int i,int prev,vector<Panel>& panels,vi& parent)\n{\n\ti++;\n\tint j=s.find('>',i);\n\tstring name=s.substr(i,j-i);\n\tj++;\n\tint x1,y1,x2,y2; sscanf(s.c_str()+j,\"%d,%d,%d,%d\",&x1,&y1,&x2,&y2);\n\tint cur=panels.size();\n\tpanels.emplace_back(name,x1,y1,x2,y2);\n\tparent.push_back(prev);\n\tfor(j=s.find('<',j);;){\n\t\tif(s[j+1]=='/')\n\t\t\tbreak;\n\t\tj=parse(s,j,cur,panels,parent);\n\t}\n\tj=s.find('>',j);\n\treturn j+1;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tstring s; cin>>s;\n\t\t\n\t\tvector<Panel> panels;\n\t\tvi parent;\n\t\tparse(s,0,-1,panels,parent);\n\t\t\n\t\tvi child(panels.size());\n\t\tperi(i,1,parent.size())\n\t\t\tchild[parent[i]]++;\n\t\t\n\t\trep(_,n){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tint i=-1;\n\t\t\tper(j,panels.size()){\n\t\t\t\tPanel p=panels[j];\n\t\t\t\tif(p.x1<=x && x<=p.x2 && p.y1<=y && y<=p.y2){\n\t\t\t\t\ti=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==-1)\n\t\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\telse\n\t\t\t\tcout<<panels[i].name<<' '<<child[i]<<endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\n\nclass Pannel {\npublic:\n  Pannel *root;\n  string name;\n  vector<Pannel *> v;\n  int sx, sy, ex, ey;\n  Pannel() {}\n  Pannel(Pannel *root, string name) : root(root), name(name) {}\n  ~Pannel() {\n    dispose();\n  }\n\n  void init() {\n    dispose();\n    v.clear();\n  }\n\n  void dispose() {\n    for(int i = 0; i < v.size(); ++i) {\n      delete v[i];\n    }\n  }\n\n  Pannel *find(int x, int y) {\n    for(int i = 0; i < v.size(); ++i) {\n      if(v[i]->sx > x) continue;\n      if(v[i]->sy > y) continue;\n      if(v[i]->ex < x) continue;\n      if(v[i]->ey < y) continue;\n      Pannel *tmp = v[i]->find(x, y);\n      return tmp == NULL ? v[i] : tmp;\n    }\n    return NULL;\n  }\n};\n\nstring tag;\nint pos;\nPannel P;\n\n\nstring getTag() {\n  int s = pos;\n  for(; pos < tag.length(); ++pos) {\n    if(tag[pos] == '>') {\n      return tag.substr(s, pos++ - s);\n    }\n  }\n}\n\nvoid getXY(Pannel *p) {\n  int s = pos;\n  for(; pos < tag.length() && tag[pos] != '<'; ++pos);\n  string str = tag.substr(s, pos - s);\n  sscanf(str.c_str(), \"%d,%d,%d,%d\", &p->sx, &p->sy, &p->ex, &p->ey);\n  //cout << p->sx << \" \" << p->sy << \" \" << p->ex << \" \" << p->ey << endl;\n}\n\nvoid make() {\n  Pannel *p = &P;\n  pos = 0;\n  while(pos < tag.length()) {\n    ++pos;\n    string str = getTag();\n    if(str[0] == '/') {\n      p = p->root;\n    } else {\n      Pannel *tmp = p;\n      p = new Pannel(p, str);\n      tmp->v.push_back(p);\n      getXY(p);\n    }\n  }\n  //cout << \"cmp\" << endl;\n}\n\nvoid solve(int x, int y) {\n  Pannel *tmp = P.find(x, y);\n  if(tmp != NULL) {\n    cout << tmp->name << \" \" << tmp->v.size() << endl;\n    return;\n  }\n  cout << \"OUT OF MAIN PANEL 1\" << endl;\n}\n\nmain() {\n  int n;\n  while((cin >> n) && n) {\n    P.init();\n    cin >> tag;\n    make();\n    for(int i = 0; i < n; ++i) {\n      int x, y;\n      cin >> x >> y;\n      solve(x, y);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstruct S{\n\tint x1,x2,y1,y2,c;\n\tstring name;\n\tbool contain(int x,int y)\n\t{\n\t\treturn x1<=x&&x<=x2&&y1<=y&&y<=y2;\n\t}\n};\nS pnl[1000];\nint n,m;\nstring in;\n\nint eval(int s,int t)\n{\n\tif(s>=t)return 0;\n\tassert(in[s]=='<');\n\t\n\tint id=m,bt=in.find('>',s),ns=in.find('<',bt+1);\n\tm++;\n\tpnl[id].name=in.substr(s+1,bt-s-1);\n\t\n\tstring tmp=in.substr(bt+1,ns-bt-1);\n\tfr(i,tmp)if(*i==',')*i=' ';\n\tstringstream ss(tmp);\n\tss>>pnl[id].x1>>pnl[id].y1>>pnl[id].x2>>pnl[id].y2;\n\t\n\ttmp=\"</\"+pnl[id].name+\">\";\n\tint es=in.find(tmp,bt),et=es+pnl[id].name.size()+3; assert(s<=es&&es<=t);\n\t\n\tint ret=1;\n\tpnl[id].c=eval(ns,es);\n\tif(et!=t)ret+=eval(et,t);\n\treturn ret;\n}\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tcin>>in; assert(0);\n\t\tm=0;\n\t\teval(0,in.size());\n\t\trep(i,n)\n\t\t{\n\t\t\tint x,y,id=m; cin>>x>>y;\n\t\t\tfor(;id>=0;id--)if(pnl[id].contain(x,y))break;\n\t\t\t\n\t\t\tif(id<0)cout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\telse cout<<pnl[id].name<<\" \"<<pnl[id].c<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Point{\npublic:\n  string name;  \n  int l,r,u,d,s,ss;\n};\n\nint main(){\n  int i,j,n,x[100],y[100],c,s;\n  Point p[1000];\n  string str;\n  cin >> n;\n  cin >> str;\n  for(i=0;i<n;i++) cin >> x[i] >> y[i];\n\n  c = 0;\n  s = 0;\n\n  for(i=0;i<str.size()-1;i++){\n    if(str[i] == '<' && str[i+1] != '/'){\n      s++;\n      p[c].name = \"\";\n      i++;\n      for(;str[i] != '>';i++) p[c].name += str[i];\n\n      i++;\n      p[c].l = p[c].r = p[c].u = p[c].d = 0;\n\n      for(;str[i] != ',';i++){\n\tp[c].l *= 10;\n\tp[c].l += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != ',';i++){\n\tp[c].u *= 10;\n\tp[c].u += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != ',';i++){\n\tp[c].r *= 10;\n\tp[c].r += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != '<';i++){\n\tp[c].d *= 10;\n\tp[c].d += str[i] - '0';\n      }\n      p[c].s = s;\n      c++;\n      i--;\n    }\n    else if(str[i] == '<' && str[i+1] == '/') s--;\n  }\n  \n  for(i=0;i<c;i++){\n    p[i].ss = 0;\n    for(j=i+1;j<c;j++){\n      if(p[i].s >= p[j].s) break;\n      else if(p[i].s + 1 == p[j].s) p[i].ss++;\n    }\n  }\n\n  for(i=0;i<n;i++){\n    Point u,v;\n    bool f = false;\n    for(j=0;j<c;j++){\n      if(p[j].l <= x[i] && x[i] <= p[j].r && p[j].u <= y[i] && y[i] <= p[j].d){\n\tif(!f){\n\t  f = true;\n\t  u = p[j];\n\t}\n\telse{\n\t  v = p[j];\n\t  if(u.s < v.s) u = v;\n\t}\n      }\n    }\n    if(f) cout << u.name << \" \" << u.ss << endl;\n    else cout << \"OUT OF MAIN PANEL 1\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  vector<Panel> child;\n};\n\nint i=0;\npair<string,int>ans;\nint maxDepth;\n\nPanel parse(string s)\n{\n  i++;\n  Panel p={\"\",0,0,0,0};\n  if(i>=s.size())return p;\n  for(;s[i]!='>';i++)p.name+=s[i];\n  char c;\n  stringstream ss;\n  ss.str(s.substr(i+1,s.size()-i-1));\n  ss>>p.x1>>c>>p.y1>>c>>p.x2>>c>>p.y2;\n  while(s[i]!='<')i++;\n  while(s[i+1]!='/')p.child.push_back(parse(s));\n  while(s[i]!='>')i++;\n  i++;\n  return p;\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n  if(x<p.x1 || p.x2<x || y<p.y1 || p.y2<y)return;\n  if(maxDepth<depth){\n    maxDepth=depth;\n    ans.first=p.name;\n    ans.second=p.child.size();\n    vector<Panel>::iterator it;\n    for(it=p.child.begin();it!=p.child.end();it++)solve(*it,x,y,depth+1);\n  }\n}\n\nint main()\n{\n  int n,x,y;\n  string s;\n  while(cin>>n,n){\n    cin>>s;\n    s=\"<OUT OF MAIN PANEL>-1,-1,10001,10001\"+s+\"</OUT OF MAIN PANEL>\";\n    Panel p=parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      ans.first=\"\";\n      ans.second=0;\n      solve(p,x,y,0);\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct panel {\n  char name[101];\n  int x1, y1;\n  int x2, y2;\n  vector<panel> child;\n};\n\npanel app;\n\nvoid parse(panel &p, char tag[])\n{\n  while(1){\n    char tmp[1001];\n    sscanf(tag, \"<%[^>]>%s\", tmp, tag);\n    char aaa[1002] = \"/\";\n    strcat(aaa, p.name);\n    if(strcmp(aaa, tmp) == 0) return;\n    panel c;\n    char next[1001];\n    strcpy(c.name, tmp);\n    sscanf(tag, \"%d,%d,%d,%d%s\", &c.x1, &c.y1, &c.x2, &c.y2, next);\n    //cout << c.name << \" \" << next << endl;\n    parse(c, next);\n    strcpy(tag, next);\n    p.child.push_back(c);\n  }\n}\n\nbool inPanel(panel &p, int x, int y)\n{\n  if(p.x1 <= x && x <= p.x2 && p.y1 <= y && y <= p.y2){\n    for(int i = 0; i < p.child.size(); i++){\n      if(inPanel(p.child[i], x, y)) return true;\n    }\n    cout << p.name << \" \" << p.child.size() << endl;\n    return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n, n){\n    char tag[1001];\n    scanf(\"%s\", tag);\n    char next[1001];\n    sscanf(tag, \"<%[^>]>%d,%d,%d,%d%s\", app.name, &app.x1, &app.y1, &app.x2, &app.y2, next);\n    //cout << app.name << \" \" << next << endl;\n    parse(app, next);\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      if(!inPanel(app, x, y)) cout << \"OUT OF MAIN PANEL 1\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<string,int> P;\ntypedef pair<int,int> Point;\ntypedef pair<Point,Point> PP;\nmap<string,int> M;\nmap<string,PP> Disp;\nvector<string> V;\n\nbool isTouch(string s, int x, int y){\n  Point p1 = Disp[s].first, p2 = Disp[s].second;\n\n  return (p1.first <= x && x <= p2.first && p1.second <= y && y <= p2.second);\n}\n\nP find(int x, int y){\n  P ans = P(\"OUT OF MAIN PANEL\",10000);\n\n  for(int i = 0; i < V.size(); i++)\n    if(isTouch(V[i],x,y) && ans.second > M[V[i]]) ans = P(V[i],M[V[i]]);\n\n\n  if(ans.first == \"OUT OF MAIN PANEL\") ans.second = 1;\n  return ans;\n}\n\nPP getPoint(string s){\n  s += \",\";\n  \n  int data[4];\n  int num = 0;\n  int sum = 0;\n  int pos = 0;\n\n  while(num < 4){\n    if(s[pos] == ','){\n      data[num++] = sum;\n      sum = 0;\n    }else{\n      sum *= 10;\n      sum += s[pos]-'0';\n    }\n    pos++;\n  }\n  PP pp;\n  \n  pp.first = Point(data[0],data[1]);\n  pp.second = Point(data[2],data[3]);\n\n  return pp;\n}\n\nstring check(int pos,string s){\n \n  string out = \"\";\n\n  for(int i = pos; i < s.length(); i++){\n    out += s[i];\n    if(s[i] == '>') break;\n  }\n\n  return out;\n}\n\n\nvoid solve(string s){\n  int pos = 0;\n  string tag = \"</\", name = \"\", between = \"\", tail = \"\";\n  int num = 0;\n  \n  while(1){\n    tag += s[++pos];\n    if(s[pos] != '<' && s[pos] != '>') name += s[pos];\n    if(s[pos] == '>') break;\n  }\n\n  string point = \"\";\n  \n  while(s[++pos] != '<') point+=s[pos];\n\n  PP p = Disp[name] = getPoint(point);\n\n  V.push_back(name);\n  \n  string child = \"\";\n  string endofchild = \"</\";\n  while(pos < s.length()){\n    if(s[pos] == '<'){\n\n      if(child == \"\" && s[pos+1] != '/'){\n\tchild = check(pos,s);\n\tendofchild = \"</\";\n\tfor(int i = 1; i < child.length(); i++) endofchild += child[i];\n      }\n \n\n      if(check(pos,s) == tag){\n\twhile(s[pos] != '>') pos++;\n\tbreak;\n      }\n\n      if(check(pos,s) == endofchild) {\n\tnum++;\n\tchild = \"\";\n      }\n    }\n    between += s[pos++];\n  }\n  M[name] = num;\n\n  for(int i = pos+1; i < s.length(); i++)\n      tail += s[i];\n  if(between.length()) solve(between);\n  if(tail.length()) solve(tail);\n}\n\nvoid init(){\n  M.clear();\n  Disp.clear();\n  V.clear();\n}\n\nint main(){\n\n  string s;\n  int n;\n  while(cin >> n && n){\n \n    init();\n\n    cin.ignore();\n\n    getline(cin,s);\n    solve(s);\n\n    for(int i = 0; i < n; i++){\n      int x,y;\n      cin >> x >> y;\n      P p =  find(x,y);\n      cout << p.first << \" \" << p.second<< endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Node\n{\n    string name;\n    int x1, y1, x2, y2;\n    vector<Node> child_nodes;\n    bool include (int x, int y)\n\t{\n\t    return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n\t}\n};\nNode parse(string s)\n{\n    Node res;\n\n    int k;\n    k = s.find(\">\");\n    res.name = s.substr(1, k - 1);\n    s = s.substr(k + 1);\n    k = s.find(\"<\");\n    sscanf(s.substr(0, k).c_str(), \"%d,%d,%d,%d\", &res.x1, &res.y1, &res.x2, &res.y2);\n    s = s.substr(k);\n    s = s.erase(s.rfind(\"<\"));\n\n    while (!s.empty())\n    {\n\tint i, tag;\n\tfor (i = 1, tag = 1; tag; ++i)\n\t{\n\t    if (s[i] == '<')\n\t    {\n\t\t++i;\n\t\tif (s[i] == '/')\n\t\t    --tag;\n\t\telse\n\t\t    ++tag;\n\t    }\n\t}\n\tfor ( ; s[i] != '>'; ++i)\n\t    ;\n\tres.child_nodes.push_back(parse(s.substr(0, i + 1)));\n\ts = s.substr(i + 1);\n    }\n\n    return res;\n}\nNode find_node(Node n, int x, int y)\n{\n    Node res;\n    res.x1 = -1;\n    if (n.include(x, y))\n    {\n\tres = n;\n\tforeach (it, n.child_nodes)\n\t{\n\t    Node r = find_node(*it, x, y);\n\t    if (r.x1 != -1)\n\t\tres = r;\n\t}\n    }\n    return res;\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n\tstring s;\n\tcin >> s;\n\tNode root = parse(s);\n\twhile (n--)\n\t{\n\t    int x, y;\n\t    cin >> x >> y;\n\t    Node res = find_node(root, x, y);\n\t    if (res.x1 >= 0)\n\t\tcout << res.name << \" \" << res.child_nodes.size() << endl;\n\t    else\n\t\tcout << \"OUT OF MAIN PANEL 1\" << endl;\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#include<cassert>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n#define MAX_SIZE 10000\n\nusing namespace std;\n\n\nstruct Panel {\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<Panel> unders;\n};\n\nPanel ans_panel;\n\nbool in_range(Panel &aPanel, int &x, int &y) {\n\treturn aPanel.x1 <= x && x <= aPanel.x2 && aPanel.y1 <= y && y <= aPanel.y2;\n}\n\nvoid search(Panel &aPanel, int &x, int &y)\n{\n\tif (!in_range(aPanel,x,y)) { return; }\n\tans_panel=aPanel;\n\n\trep(i,aPanel.unders.size()) {\n\t\tsearch(aPanel.unders[i], x, y);\n\t}\n}\n\nvoid show(Panel &aPanel) {\n\tcout << aPanel.name << endl;\n\tcout << aPanel.x1 << \",\" << aPanel.y1 << \",\" <<\n\t\t\taPanel.x2 << \",\" << aPanel.y2 << endl;\n\n\trep(i,aPanel.unders.size()) {\n\t\tshow(aPanel.unders[i]);\n\t}\n}\n\nvector<int> tag_value(const string &line, int &i)\n{\n\tvector<int> nums;\n\tstring num_str=\"\";\n\twhile(true) {\n\t\tif ('0' <= line[i] && line[i] <= '9') {\n\t\t\tnum_str += line[i];\n\t\t}\n\t\telse if (line[i] == ',') {\n\t\t\tnums.push_back(stoi(num_str));\n\t\t\tnum_str=\"\";\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tnums.push_back(stoi(num_str));\n\n\treturn nums;\n}\n\n//OK\nstring tag_name(const string &line, int &i)\n{\n\tstring a_str=\"\";\n\twhile(true) {\n\t\tif ((('a' <= line[i]) && (line[i] <= 'z')) ||\n\t\t\t(('A' <= line[i]) && (line[i] <= 'Z')) ) {\n\t\t\ta_str += line[i];\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn a_str;\n}\n\n\nstring start_tag(const string &line, int &i)\n{\n\tassert(line[i] == '<');\n\ti++; //????§?<\n\tstring name = tag_name(line,i);\n\n\tassert(line[i] == '>');\n\ti++; //??????>\n\treturn name;\n}\n\n\nbool try_end_tag(const string &line, int i)\n{\n\tif(line[i] != '<') { return false; }\n\ti++; //????§?<\n\tif(line[i] != '/') { return false; }\n\ti++; //????§?/\n\tstring name = tag_name(line,i);\n\tif(line[i] != '>') { return false; }\n\ti++; //??????>\n\treturn true; //??¨??¨???????????°\n}\n\nstring end_tag(const string &line, int &i)\n{\n\tassert(line[i] == '<');\n\ti++; //????§?<\n\tassert(line[i] == '/');\n\ti++; //????§?/\n\tstring name = tag_name(line,i);\n\tassert(line[i] == '>');\n\ti++; //??????>\n\treturn name;\n}\n\n\n/*\n * ????????????????????????.\n */\nPanel tag_struct(const string &line, int &i, Panel &aPanel)\n{\n\taPanel.name = start_tag(line,i);\n\tvector<int> values = tag_value(line,i);\n\n\tassert(values.size() == 4);\n\taPanel.x1 = values[0];\n\taPanel.y1 = values[1];\n\taPanel.x2 = values[2];\n\taPanel.y2 = values[3];\n\n\twhile(true) {\n\t\tbool is_end = try_end_tag(line,i);\n\t\t//?????????????????¨???\n\t\tif (is_end) { break; } \n\t\tPanel underPanel;\n\t\taPanel.unders.push_back(tag_struct(line,i, underPanel));\n\t}\n\tend_tag(line,i);\n\n\treturn aPanel;\n}\n\n\nint main() {\n\tint N;\n\tint x,y;\n\tstring line;\n\n\n\twhile(cin >> N) {\n\t\tif (N == 0) { break; }\n\t\tPanel mainPanel;\n\n\t\tcin >> line;\n\t\tint i=0;\n\t\tint level=0;\n\t\ttag_struct(line, i, mainPanel);\n\n\t\trep(i,N) {\n\t\t\tcin >> x >> y;\n\t\t\tans_panel = Panel();\n\t\t\tsearch(mainPanel,x,y);\n\t\t\tif (in_range(mainPanel,x,y)) {\n\t\t\t\tcout << ans_panel.name << \" \" << ans_panel.unders.size() << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nstruct DATA{\n  string name;\n  int x1, y1, x2, y2;\n  set<int> next;\n};\n\nvoid ConvertData(string&, vector<DATA>&, int);\nvoid ConvertDataInner(const string, string, DATA&);\nint AtoiString(const string);\nint TouchPanel(int, int, int, vector<DATA>&);\n\nint main(){\n  int i, j, n, x, y, ans;\n  string str;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    cin >> str;\n    vector< vector<DATA> > data;\n    while(!str.empty()){\n      vector<DATA> onedata(1);\n      ConvertData(str, onedata, 0);\n      data.push_back(onedata);\n    }\n\n    for(i=0; i<n; ++i){\n      cin >> x >> y;\n      for(j=0; j<data.size(); ++j){\n\tans = TouchPanel(x, y, 0, data[j]);\n\tif(ans != -1){\n\t  cout << data[j][ans].name << \" \" << data[j][ans].next.size() << endl;\n\t  break;\n\t}\n      }\n      if(ans == -1) cout << \"OUT OF MAIN PANEL 1\" << endl;\n    }\n  }\n  return 0;\n}\n\nvoid ConvertData(string& str, vector<DATA>& data, int x){\n  DATA _data;\n  string::iterator i, j;\n\n  i = find(str.begin(), str.end(), '>');\n  j = find(i+1, str.end(), '<');\n\n  const string name(str.begin()+1, i);\n  string info(i+1, j);\n  ConvertDataInner(name, info, data[x]);\n  str.erase(str.begin(), j);\n\n  while(1){\n    i = find(str.begin(), str.end(), '>');\n    const string name(str.begin()+1, i);\n    if(name == \"/\" + data[x].name){\n      str.erase(str.begin(), i+1);\n      return;\n    }\n    data.push_back(_data);\n    ConvertData(str, data, data.size()-1);\n    data[x].next.insert(data.size()-1);\n  }\n}\n\nvoid ConvertDataInner(const string name, string str, DATA& data){\n  string::iterator i, j, k;\n\n  i = find(str.begin(), str.end(), ',');\n  j = find(i+1, str.end(), ',');\n  k = find(j+1, str.end(), ',');\n\n  const string x1(str.begin(), i);\n  const string y1(i+1, j);\n  const string x2(j+1, k);\n  const string y2(k+1, str.end());\n\n  data.name = name;\n  data.x1 = AtoiString(x1);\n  data.y1 = AtoiString(y1);\n  data.x2 = AtoiString(x2);\n  data.y2 = AtoiString(y2);\n  data.next.clear();\n}\n\nint AtoiString(const string s){\n  int i, x, d;\n  for(i=s.size()-1, x=0, d=1; i>=0; --i, d*=10)\n    x += ((s[i] - 48) * d);\n  return x;\n}\n\nint TouchPanel(int x, int y, int n, vector<DATA>& data){\n  if(data[n].x1 <= x && x <= data[n].x2 && data[n].y1 <= y && y <= data[n].y2){\n    int m;\n    set<int>::iterator i;\n    for(i=data[n].next.begin(); i!=data[n].next.end(); ++i){\n      m = TouchPanel(x, y, *i, data);\n      if(m != -1) return m;\n    }\n    return n;\n  }else{\n    return -1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass State{\npublic:\n  string name;\n  int data;\n  int x1, y1, x2, y2;\n};\n\nvector<State> data[1000];\nstring str;\nint idx, size;\n\nvoid calc2(int r, int l, State& p){\n  int tmp = r;\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.x1 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.y1 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.x2 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  p.y2 = atoi(str.substr(tmp, l-tmp+1).c_str());\n}\n\nint calc(int pos){\n  if(idx >= str.size()) return 0;\n  size = max(size, pos);\n  int r = idx;\n  int l;\n  for(int i=r;i<str.size();i++){\n    if(str[i] == '>'){\n      l = i;\n      break;\n    }\n  }\n  State p;\n  p.name = str.substr(r+1, l-r-1);\n  r = l+1;\n  for(int i=r;i<str.size();i++){\n    if(str[i] == '<'){\n      l = i-1;\n      break;\n    }\n  }\n  calc2(r, l, p);\n  r = l+1;\n  p.data = 0;\n  idx = r;\n  while(1){\n    bool f = false;\n    for(int i=idx;i<str.size();i++){\n      if(str[i] == '/') f = true;\n      if(str[i] == '>'){\n        l = i;\n        break;\n      }\n    }\n    if(f){\n      data[pos].push_back(p);\n      idx = l+1;\n      break;\n    }else{\n      p.data += calc(pos+1);\n    }\n  }\n  return p.data+1;\n}\n\nmain(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<1000;i++) data[i].clear();\n    cin >> str;\n    idx = size = 0;\n    while(idx < str.size()) calc(0);\n    for(int k=0;k<n;k++){\n      int x, y;\n      cin >> x >> y;\n      for(int i=size;i>=0;i--){\n        for(int j=0;j<data[i].size();j++){\n          if(data[i][j].x1 <= x && x <= data[i][j].x2){\n            if(data[i][j].y1 <= y && y <= data[i][j].y2){\n              cout << data[i][j].name << ' ' << data[i][j].data << endl;\n              goto END;\n            }\n          }\n        }\n      }\n      cout << \"OUT OF MAIN PANEL 1\" << endl;\n      END:;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  vector<Panel> child;\n};\n\nint i=0;\npair<string,int>ans;\nint maxDepth;\n\nPanel parse(string s)\n{\n  Panel p={\"\",0,0,0,0};\n  for(i++;s[i]!='>';i++)p.name+=s[i];\n  char c;\n  stringstream ss;\n  ss.str(s.substr(i+1,s.size()-i-1));\n  ss>>p.x1>>c>>p.y1>>c>>p.x2>>c>>p.y2;\n  while(s[i]!='<')i++;\n  while(s[i+1]!='/')p.child.push_back(parse(s));\n  while(s[i]!='>')i++;\n  i++;\n  return p;\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n  if(x<p.x1 || p.x2<x || y<p.y1 || p.y2<y)return;\n  if(maxDepth<depth){\n    maxDepth=depth;\n    ans.first=p.name;\n    ans.second=p.child.size();\n  }\n  vector<Panel>::iterator it;\n  for(it=p.child.begin();it!=p.child.end();it++)solve(*it,x,y,depth+1);\n}\n\nint main()\n{\n  int n,x,y;\n  string s;\n  while(cin>>n,n){\n    cin>>s;\n    s=\"<OUT OF MAIN PANEL>-1,-1,10001,10001\"+s+\"</OUT OF MAIN PANEL>\";\n    Panel p=parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      solve(p,x,y,0);\n      if(ans.first==\"OUT OF MAIN PANEL\")ans.second=1;\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n  \n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tbool operator<(const Panel &p)const{return x1<p.x1;}\n\tvoid print(){\n\t\tcout<<name<<':'<<x1<<','<<y1<<','<<x2<<','<<y2<<endl;\n\t}\n};\n\n\nvector<Panel> v;\n\nvoid extract(string &s){\n\tfor(int i=0;i+1<s.size();i++){\n\t\tif(s[i]=='<'&&s[i+1]!='/'){\n\t\t\tchar c;\n\t\t\tPanel panel;\n\t\t\tstring tmp;\n\t\t\tfor(i++;s[i]!='>';i++)tmp+=s[i];\n\t\t\tpanel.name=tmp;\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.x1=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.y1=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.x2=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!='<';i++)tmp+=s[i];\n\t\t\tpanel.y2=atoi(tmp.c_str());\n\t\t\ti--;\n\t\t\tv.push_back(panel);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint n;\n\tchar c;\n\twhile(cin>>n&&n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tv.clear();\n\t\textract(s);\n\t\tsort(v.begin(),v.end());\n\t\t//for(int i=0;i<v.size();i++)v[i].print();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tint a=-1;\n\t\t\tfor(int j=v.size()-1;j>=0;j--){\n\t\t\t\tif(v[j].x1<=x&&v[j].y1<=y&&x<=v[j].x2&&y<=v[j].y2){\n\t\t\t\t\ta=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif(a==-1){\n\t\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint cnt=0;\n\t\t\tfor(int j=a+1;j<v.size();j++){\n\t\t\t\tif(v[a].x1<v[j].x1&&v[a].y1<v[j].y1&&v[j].x2<v[a].x2&&v[j].y2<v[a].y2){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<v[a].name<<' '<<cnt<<endl;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(const Data& now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  string top;\n\n  Data now = panel;\n  int cnt = 0;\n\n\n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n\n  bool flag = true;\n  while(flag){\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n\n  Cursol crl;\n\n  while(cin >> n, n){\n    Data Main; //メインパネル\n\n    cin >> tag;\n\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n\n  \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <memory>\n#include <vector>\nusing namespace std;\n\nstruct node_t {\n\tstring name;\n\tint x1, y1, x2, y2;\n\tvector<unique_ptr<node_t>> children;\n\n\tnode_t(const string &name_, int x1_, int y1_, int x2_, int y2_):\n\t\tname(name_), x1(x1_), y1(y1_), x2(x2_), y2(y2_) {}\n\n\tbool in(int x, int y) const {\n\t\treturn x1 <= x && x <= x2 && y1 <= y && y <= y2;\n\t}\n\n\tstring click(int x, int y) const {\n\t\tfor(const auto &child : children) {\n\t\t\tif(child->in(x, y)) return child->click(x, y);\n\t\t}\n\t\treturn name + \" \" + to_string(children.size());\n\t}\n\n\tvoid add_child(unique_ptr<node_t> &&child) {\n\t\tchildren.emplace_back(move(child));\n\t}\n};\n\nint get_int(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*(++it))) res = res * 10 + *it - '0';\n\treturn res;\n}\n\nunique_ptr<node_t> parse(string::const_iterator &it) {\n\tstring name = \"\";\n\twhile(isalpha(*(++it))) name += *it;\n\tconst int x1 = get_int(it);\n\tconst int y1 = get_int(it);\n\tconst int x2 = get_int(it);\n\tconst int y2 = get_int(it);\n\n\tunique_ptr<node_t> res(new node_t(name, x1, y1, x2, y2));\n\twhile(*(it + 1) != '/') res->add_child(parse(it));\n\n\tit += name.size() + 3; // \"</name>\"\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tstring tags;\n\t\tcin >> tags;\n\n\t\tauto it = tags.cbegin();\n\t\tconst auto root = parse(it);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tcout << (root->in(x, y) ? root->click(x, y) : \"OUT OF MAIN PANEL 1\") << \"\\n\";\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n\ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n\nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n\nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n\nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n\nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n\nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n\nbool eof() {\n  return __it == __end;\n}\n\nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n\nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n\nlexstat lstat = lexstat::no_stat;\n\ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n\n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n\n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n\n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n\n  lstat = lexstat::success;\n\n  return ret;\n}\n\nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n\nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n\ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n\nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n\n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n\n  while(i--) unread();\n  return false;\n}\n\n}\nusing namespace parser;\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct xml {\n  string tag;\n  vector<int> prop;\n  vector<shared_ptr<xml>> children;\n};\n\nshared_ptr<xml> parse(shared_ptr<xml>& p) {\n  while(!eof()) {\n    if(look_ahead(\"</\")) {\n      lex_f(\"</\" + p->tag + \">\");\n      return p;\n    } else if(look_ahead(\"<\")) {\n      auto c = make_shared<xml>();\n      c->tag = lex<string>(alphabetical, {}, {'<','>'});\n      c->tag = c->tag.substr(1, c->tag.size()-2);\n      c->prop = lex_stream<int>(integer, {','});\n      p->children.push_back(c);\n      parse(c);\n    }\n  }\n  return p;\n}\n\nshared_ptr<const xml> parse(Iter begin, Iter end) {\n  init_iterator(begin, end);\n  auto p = make_shared<xml>();\n  p->tag = \"OUT OF MAIN PANEL\";\n  return parse(p);\n}\n\npair<string, int> dfs(shared_ptr<const xml> const& p, int x, int y) {\n  for(auto && c: p->children)\n    if(c->prop[0] <= x && c->prop[1] <= y && x <= c->prop[2] && y <= c->prop[3])\n      return dfs(c, x, y);\n\n  return make_pair(p->tag, p->children.size());\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string xml_str; cin >> xml_str;\n    auto root = parse(xml_str.begin(), xml_str.end());\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\nusing namespace std;\n\nint stoi(string s){\n  stringstream ss;\n  ss << s;\n  int res;\n  ss >> res;\n  return res;\n}\n\nint main(){\n  int n,x,y,t,z[1000][5];\n  string s,name[1000];\n\n  while(cin >> n, n){\n    cin >> s;\n    t = 0;\n    for(int i=1;i<(int)s.size();i++){\n\n      if(s[i] != '/'){\n\tstring tmp = \"\";\n\twhile(i<(int)s.size() && s[i] != '>'){\n\t  tmp += s[i];\n\t  i++;\n\t}\n\tname[t] = tmp;\n\tfor(int j=0;j<4;j++){\n\t  i++;\n\t  tmp = \"\";\n\t  while(s[i] != ',' && s[i] != '<'){\n\t    tmp += s[i];\n\t    i++;\n\t  }\n\t  z[t][j] = stoi(tmp);\n\t}\n\tt++;\n      }else{\n\twhile(i<(int)s.size() && s[i]!='<')i++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n\n      int m = -1;\n      for(int j=0;j<t;j++){\n\tif(z[j][0]<=x && x<=z[j][2] && z[j][1]<=y && y<=z[j][3]){\n\t  if(m<0 || (z[m][0]<=z[j][0] && z[j][2]<=z[m][2] && \n\t\t     z[m][1]<=z[j][1] && z[j][3]<=z[m][3]) )m = j;\n\t} \n      }\n      \n      if(m<0)cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else{\n\tint num = -1;\n\tfor(int j=0;j<t;j++){\n\t  if(z[m][0]<=z[j][0] && z[j][2]<=z[m][2] && \n\t     z[m][1]<=z[j][1] && z[j][3]<=z[m][3])num++;\n\t}\n\t\n\tcout << name[m] << \" \" << num << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n\nstruct Rectangle {\n  size_t l, r, d, u;\n  std::string name;\n  int children=0;\n  Rectangle(size_t l, size_t r, size_t d, size_t u, const std::string &name):\n    l(l), r(r), d(d), u(u), name(name)\n  {}\n  bool contains(size_t x, size_t y) const {\n    return x-l <= r-l && y-u <= d-u;\n  }\n};\n\nstd::vector<Rectangle> parse(const std::string &s) {\n  std::map<std::string, int> children;\n  std::stack<std::string> opened;\n  std::vector<Rectangle> res;\n  size_t i=0;\n  while (i < s.length()) {\n    assert(s[i] == '<');\n    ++i;\n    if (s[i] == '/') {\n      while (s[i++] != '>') {}\n      opened.pop();\n      continue;\n    }\n    std::string tag(1, s[i]);\n    while (isalnum(s[++i])) tag += s[i];\n    assert(s[i] == '>');\n    ++i;\n    assert(isdigit(s[i]));\n    size_t l=s[i]-'0';\n    while (isdigit(s[++i])) l = l*10+s[i]-'0';\n    assert(s[i] == ',');\n    ++i;\n    assert(isdigit(s[i]));\n    size_t u=s[i]-'0';\n    while (isdigit(s[++i])) u = u*10+s[i]-'0';\n    assert(s[i] == ',');\n    ++i;\n    assert(isdigit(s[i]));\n    size_t r=s[i]-'0';\n    while (isdigit(s[++i])) r = r*10+s[i]-'0';\n    assert(s[i] == ',');\n    ++i;\n    assert(isdigit(s[i]));\n    size_t d=s[i]-'0';\n    while (isdigit(s[++i])) d = d*10+s[i]-'0';\n    assert(s[i] == '<');\n\n    res.emplace_back(l, r, d, u, tag);\n    if (!opened.empty())\n      ++children[opened.top()];\n\n    opened.emplace(tag);\n  }\n  assert(opened.empty());\n\n  for (size_t i=0; i<res.size(); ++i) {\n    res[i].children = children[res[i].name];\n  }\n  return res;\n}\n\nint testcase_ends() {\n  size_t n;\n  char buf[1024];\n  scanf(\"%zu %s\", &n, buf);\n  if (n == 0) return 1;\n  std::string s=buf;\n  std::vector<Rectangle> rects=parse(s);\n\n  for (size_t i=0; i<n; ++i) {\n    size_t x, y;\n    scanf(\"%zu %zu\", &x, &y);\n\n    size_t ind=-1;\n    for (size_t j=0; j<rects.size(); ++j) {\n      if (rects[j].contains(x, y))\n        ind = j;\n    }\n\n    if (ind+1 == 0) {\n      printf(\"OUT OF MAIN PANEL 1\\n\");\n    } else {\n      printf(\"%s %d\\n\", rects[ind].name.c_str(), rects[ind].children);\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass State{\npublic:\n  string name;\n  int data;\n  int x1, y1, x2, y2;\n};\n\nvector<State> data[1000];\nstring str;\nint idx, size;\n\nvoid calc2(int r, int l, State& p){\n  int tmp = r;\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.x1 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.y1 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.x2 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  p.y2 = atoi(str.substr(tmp, l-tmp+1).c_str());\n}\n\nint calc(int pos){\n  if(idx >= str.size()) return 0;\n  size = max(size, pos);\n  int r = idx;\n  int l;\n  for(int i=r;i<str.size();i++){\n    if(str[i] == '>'){\n      l = i;\n      break;\n    }\n  }\n  State p;\n  p.name = str.substr(r+1, l-r-1);\n  r = l+1;\n  for(int i=r;i<str.size();i++){\n    if(str[i] == '<'){\n      l = i-1;\n      break;\n    }\n  }\n  calc2(r, l, p);\n  r = l+1;\n  p.data = 0;\n  idx = r;\n  while(1){\n    bool f = false;\n    for(int i=idx;i<str.size();i++){\n      if(str[i] == '/') f = true;\n      if(str[i] == '>'){\n        l = i;\n        break;\n      }\n    }\n    if(f){\n      data[pos].push_back(p);\n      idx = l+1;\n      break;\n    }else{\n      p.data += calc(pos+1);\n    }\n  }\n  return p.data+1;\n}\n\nmain(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<1000;i++) data[i].clear();\n    getline(cin, str);\n    getline(cin, str);\n    idx = size = 0;\n    while(idx < str.size()) calc(0);\n    for(int k=0;k<n;k++){\n      int x, y;\n      cin >> x >> y;\n      for(int i=size;i>=0;i--){\n        for(int j=0;j<data[i].size();j++){\n          if(data[i][j].x1 <= x && x <= data[i][j].x2){\n            if(data[i][j].y1 <= y && y <= data[i][j].y2){\n              cout << data[i][j].name << ' ' << data[i][j].data << endl;\n              goto END;\n            }\n          }\n        }\n      }\n      cout << \"OUT OF MAIN PANEL 1\" << endl;\n      END:;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring S,ans;\nint pos,acnt,d;\nint X,Y;\n \n \nstring get_str(){\n  string res;\n  while(S[pos]!='>') res+=S[pos++];\n  pos++;\n  return res;\n}\n \nint get_xy(){\n  int res=0;\n  while(S[pos]!=','&&S[pos]!='<')res=res*10+S[pos++]-'0';\n  if(S[pos]==',')pos++;\n  return res;\n}\n \nvoid bnf(string str){\n  string name;\n  int cnt=0,f=0;\n   \n  while(S[pos]=='<'&&S[pos+1]!='/'){\n    pos++;\n    name=get_str();\n    int x1=get_xy();\n    int y1=get_xy();\n    int x2=get_xy();\n    int y2=get_xy();\n    if(x1<=X&&X<=x2&&y1<=Y&&Y<=y2)f=1,bnf(name);\n    else cnt++;\n    string res;\n    while(res!=name){\n      if(S[pos+1]=='/')pos+=2;\n      else pos++;\n      res=get_str();\n    }\n  }\n  if(!f)ans=str,acnt=cnt;\n}\n \nint main(){\n  int n;\n  while(cin>>n,n){\n    cin>>S;\n    S+=\"</OUT OF MAIN PANEL>\";\n      while(n--){\n    cin>>X>>Y;\n    pos=0;\n    acnt=0;\n    bnf(\"OUT OF MAIN PANEL\");\n    cout <<ans<<\" \"<<acnt<<endl;\n      }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define MAX 1000\n\nstruct data{\n  int id,ax,ay,bx,by;\n  string str;\n  vector<int> g;\n};\n\nint n,p;\nstring s;\n\nvector<data> G;\n\nint getNum(){\n  int res=0;\n  while('0'<=s[p]&&s[p]<='9'){\n    res*=10;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nvoid rec(){\n  data d;\n  d.str=\"\";\n  d.g.clear();\n  p++;\n  for(;s[p]!='>';p++)d.str.push_back(s[p]);\n  p++;\n  d.ax=getNum();\n  p++;\n  d.ay=getNum();\n  p++;\n  d.bx=getNum();\n  p++;\n  d.by=getNum();\n  //cout<<d.ax<<\" \"<<d.ay<<\" \"<<d.bx<<\" \"<<d.by<<endl;\n  while(1){\n    if(s[p+1]=='/')break;\n    rec();\n    d.g.push_back((int)G.size()-1);\n  }\n  while(s[p]!='>')p++;\n  p++;\n  G.push_back(d);\n}\n\nbool check(int a,int x,int y){\n  return (G[a].ax<=x&&x<=G[a].bx&&G[a].ay<=y&&y<=G[a].by);\n}\n\nint solve(int a,int x,int y){\n  for(int i=0;i<(int)G[a].g.size();i++){\n    int w=G[a].g[i];\n    if(check(w,x,y))return solve(w,x,y);\n  }\n  return a;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cin>>s;\n    p=0;\n    rec();\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      if(!check(G.size()-1,x,y))cout<<\"OUT OF MAIN PANEL 1\"<<endl;\n      else{\n\tint ans=solve(G.size()-1,x,y);\n\tcout<<G[ans].str<<\" \"<<G[ans].g.size()<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nchar s[1024],s_tmp[1024];\nint x,y;\n\nint idx,cnt;\nstring ans;\nvoid parse(){\n\tint p;\n\tfor(p=idx;s[p]!='>';p++);\n\ts[p]='\\0';\n\tstring tag=s+idx+1;\n\tidx=p+1;\n\n\tfor(p=idx;s[p]!='<';p++);\n\ts[p]='\\0';\n\tint t,l,b,r; sscanf(s+idx,\"%d,%d,%d,%d\",&l,&t,&r,&b);\n\tidx=p;\n\n\tif(t<=y && y<=b && l<=x && x<=r) ans=tag;\n\n\tint c=0;\n\twhile(s[idx+1]!='/'){\n\t\tparse();\n\t\tc++;\n\t}\n\tif(ans==tag) cnt=c;\n\n\tfor(;s[idx]!='>';idx++);\n\tidx++;\n}\n\nint main(){\n\tfor(int q;scanf(\"%d%s\",&q,s),q;){\n\t\twhile(q--){\n\t\t\tstrcpy(s_tmp,s);\n\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tidx=0;\n\t\t\tans=\"\";\n\t\t\tparse();\n\t\t\tif(ans==\"\") puts(\"OUT OF MAIN PANEL 1\"); else printf(\"%s %d\\n\",ans.c_str(),cnt);\n\n\t\t\tstrcpy(s,s_tmp);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<cctype>\n\nusing namespace std;\n\n#define foreach(itm,o) for(__typeof((o).begin()) itm=(o).begin();itm!=(o).end();++itm)\nconst int infty = 1<<28;\n\nstruct panel{\n  string name;\n  int x1,y1,x2,y2;\n  panel(int x1,int y1,int x2,int y2,string newName):\n    x1(x1),y1(y1),x2(x2),y2(y2),name(newName){}\n  bool isinside(int x, int y){\n    return ( x1 <= x && x <= x2 && y1 <= y && y <= y2 );\n  }\n};\n\npanel tail(-100,-100,-100,-100,\" tail\");\n\nint dig(const string &s, int &pos){\n  int n = 0;\n  while(isdigit(s[pos])){\n    n *= 10;\n    n += s[pos]-'0';\n    ++pos;\n  }\n  return n;\n}\n\nvoid parse(const string &s, int &pos,\n\t   const string &parent, map<string, vector<panel> > &M){\n  string newName;\n  if(pos>=s.length())return ;\n  if( s[pos] == '<' ){\n    ++pos;\n    while(s[pos]!='>'){newName+=s[pos];++pos;}\n  }\n  pos++;\n  int x1 = dig(s,pos);++pos;\n  int y1 = dig(s,pos);++pos;\n  int x2 = dig(s,pos);++pos;\n  int y2 = dig(s,pos);\n  //cout << newName << endl;\n  M[newName];\n  //.push_back(tail );\n  M[parent].push_back( panel(x1,y1,x2,y2,newName) );\n  while( true ){\n    if( s[pos]=='<'&&s[pos+1]=='/' ){\n      while(s[pos]!='>')++pos;\n      ++pos;\n      //cout << newName << \" END\"<<endl;\n      break;\n    }else{\n      //cout << newName << \" HAS:\"<<endl;\n      parse(s,pos,newName,M);\n      if(pos>=s.length())break;\n    }\n  }\n  return ;\n}\n\nint main(){\n  while(true){\n    int n;\n    int pos = 0;\n    string tags,ans;\n    map< string, vector<panel> > structure;\n    cin >> n;if(n==0)break;\n    cin >> tags;\n    parse(tags,pos,\"\\0\\0_0root\",structure);\n    //structure[\" _0root\"].push_back(tail);\n    \n    //cout << \"==================\\n    PARSE END\\n==================\" << endl;\n    for(int i = 0; i < n; ++i){\n      int qx,qy;cin>>qx>>qy;\n      int minchild = infty;\n      for(map<string,vector<panel> >::iterator itm=structure.begin(); itm != structure.end(); ++itm){\n\tfor(int j = 0; j < itm->second.size(); ++j){\n\t  if( itm->second[j].isinside(qx,qy) ){\n\t    int t = structure[itm->second[j].name].size();\n\t    if( t < minchild ){\n\t      minchild = t;\n\t      ans = itm->second[j].name;\n\t    }\n\t  }\n\t}\n      }\n      if( minchild == infty ){\n\tcout <<\"OUT OF MAIN PANEL 1\" << endl;\n      }else{\n\tcout << ans << ' ' << minchild << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass State{\npublic:\n  string name;\n  int data;\n  int x1, y1, x2, y2;\n};\n\nvector<State> data[1000];\nstring str;\nint idx, size;\n\nvoid calc2(int r, int l, State& p){\n  int tmp = r;\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.x1 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.y1 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  for(int i=tmp;i<=l;i++){\n    if(str[i] == ','){\n      p.x2 = atoi(str.substr(tmp, i-tmp).c_str());\n      tmp = i+1;\n      break;\n    }\n  }\n  p.y2 = atoi(str.substr(tmp, l-tmp+1).c_str());\n}\n\nvoid calc(int pos){\n  if(idx >= str.size()) return;\n  size = max(size, pos);\n  int r = idx;\n  int l;\n  for(int i=r;i<str.size();i++){\n    if(str[i] == '>'){\n      l = i;\n      break;\n    }\n  }\n  State p;\n  p.name = str.substr(r+1, l-r-1);\n  r = l+1;\n  for(int i=r;i<str.size();i++){\n    if(str[i] == '<'){\n      l = i-1;\n      break;\n    }\n  }\n  calc2(r, l, p);\n  r = l+1;\n  p.data = 0;\n  idx = r;\n  while(1){\n    bool f = false;\n    for(int i=idx;i<str.size();i++){\n      if(str[i] == '/') f = true;\n      if(str[i] == '>'){\n        l = i;\n        break;\n      }\n    }\n    if(f){\n      data[pos].push_back(p);\n      idx = l+1;\n      break;\n    }else{\n      p.data ++;\n      calc(pos+1);\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<1000;i++) data[i].clear();\n    getline(cin, str);\n    getline(cin, str);\n    idx = size = 0;\n    while(idx < str.size()) calc(0);\n    for(int k=0;k<n;k++){\n      int x, y;\n      cin >> x >> y;\n      for(int i=size;i>=0;i--){\n        for(int j=0;j<data[i].size();j++){\n          if(data[i][j].x1 <= x && x <= data[i][j].x2){\n            if(data[i][j].y1 <= y && y <= data[i][j].y2){\n              cout << data[i][j].name << ' ' << data[i][j].data << endl;\n              goto END;\n            }\n          }\n        }\n      }\n      cout << \"OUT OF MAIN PANEL 1\" << endl;\n      END:;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<string, int> P;\n\ntypedef struct node {\n  vector<node> ch;\n  string name;\n  int ty, tx, by, bx;\n  node() { }\n  node(string nn, int tty, int ttx, int bby, int bbx) { name = nn; ty = tty; tx = ttx; by = bby; bx = bbx; }\n} node;\n\nvoid add(node &root, string tar, string name, int ty, int tx, int by, int bx){\n  if(root.name == tar) { root.ch.push_back(node(name, ty, tx, by, bx)); return; }\n    REP(i, root.ch.size()){\n      node c = root.ch[i];\n      if(c.ty <= ty && c.tx <= tx && c.by >= by && c.bx >= bx){ add(root.ch[i], tar, name, ty, tx, by, bx); return; };\n  }\n}\n\n//void disp(node &r, string b){\n//  cout <<b <<r.name <<\", \" <<r.ch.size() <<endl;\n//  REP(i, r.ch.size()) disp(r.ch[i], b + \"  \");\n//}\n\nP touch(node &root, int y, int x, bool f, string s){\n  P ret = P(\"\", 0);\n  if(!f){\n    REP(i, root.ch.size()){\n      node c = root.ch[i];\n      if(c.ty <= y && c.tx <= x && c.by >= y && c.bx >= x) return touch(root.ch[i], y, x, f, s);\n    }\n  }\n  if(!f) ret.first = root.name;\n  if(f) ret.second += 1;\n  REP(i, root.ch.size()){\n    P r = touch(root.ch[i], y, x, true, s);\n    ret.second += r.second;\n  }\n  return ret;\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    string S; cin >>S;\n    node root = node(\"OUT OF MAIN PANEL\", -1, -1, 10010, 10010);\n    vector<string> rn; rn.push_back(\"OUT OF MAIN PANEL\");\n    FOR(i, 1, S.length()){\n      stringstream ss, sss;\n      while(i < S.length() && S[i] != '<') ss << S[i++];\n      if(ss.str()[0] == '/') { rn.pop_back(); continue; }\n      int n = 0;\n      string s = ss.str(); ss.str(\"\");\n      while(s[n] != '>') ss << s[n++];\n      s = s.substr(n + 1) + \",\";\n      int nums[4] = {0}, num = 0; n = 0;\n      REP(j, s.length()){\n        if(s[j] == ','){\n          nums[n++] = num;\n          num = 0;\n        } else{\n          num *= 10;\n          num += s[j] - '0';\n        }\n      }\n      add(root, rn.back(), ss.str(), nums[1], nums[0], nums[3], nums[2]);\n      rn.push_back(ss.str());\n    }\n    //disp(root, \"\");\n    REP(n, N){\n      int x, y; cin >>x >>y;\n      P ret = touch(root, y, x, false, \"\");\n      if(ret.first == \"OUT OF MAIN PANEL\") cout <<ret.first <<\" \" <<1 <<endl;\n      else cout <<ret.first <<\" \" <<ret.second <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct tag{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<tag> children;\n\n\tint numChildren(){\n\t\tint ret=0;\n\t\tREP(i,children.size()){\n\t\t\tret+=children[i].numChildren()+1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\ttag *getClickedTag(int x,int y){\n\t\tREP(i,children.size()){\n\t\t\ttag *t=children[i].getClickedTag(x,y);\n\t\t\tif(t!=NULL){\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t\tif(x1<=x&&x<=x2&&y1<=y&&y<=y2){\n\t\t\treturn this;\n\t\t}else{\n\t\t\treturn NULL;\n\t\t}\n\t}\n};\n\ntag read(string &s, int &pos){\n\ttag me;\n\t//タグ構造 ::= 開始タグ タグ値 {タグ構造}* 終了タグ\n\t//開始タグ ::= <タグ名>\n\tassert(s[pos]=='<');\n\tpos++;\n\twhile(s[pos]!='>'){\n\t\tme.name.push_back(s[pos]);\n\t\tpos++;\n\t}\n\tassert(s[pos]=='>');\n\tpos++;\n\n\t//タグ値   ::= 整数,整数,整数,整数\n\tREP(i,4){\n\t\tstring num;\n\t\twhile(isdigit(s[pos])){\n\t\t\tnum.push_back(s[pos]);\n\t\t\tpos++;\n\t\t}\n\t\tswitch(i){\n\t\tcase 0:me.x1=toInt(num);break;\n\t\tcase 1:me.y1=toInt(num);break;\n\t\tcase 2:me.x2=toInt(num);break;\n\t\tcase 3:me.y2=toInt(num);break;\n\t\t}\n\t\tassert(s[pos]==','||s[pos]=='<');\n\t\tpos++;\n\t}\n\tpos--;\n\twhile(s[pos+1]!='/'){\n\t\ttag t=read(s,pos);\n\t\tme.children.push_back(t);\n\t}\n\n\t//終了タグ ::= </タグ名>\n\tassert(s[pos]=='<');\n\tpos++;\n\tassert(s[pos]=='/');\n\tpos++;\n\twhile(s[pos]!='>'){\n\t\tpos++;\n\t}\n\tassert(s[pos]=='>');\n\tpos++;\n\n\treturn me;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tint pos=0;\n\t\ttag root=read(s,pos);\n\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttag *t=root.getClickedTag(x,y);\n\t\t\tif(t==NULL){\n\t\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<t->name<<\" \"<<t->numChildren()<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  /*\n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n  */\n\n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ*/\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n  Data Main;\n  Cursol crl;\n\n  while(cin >> n, n){\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(int x, int y, Data data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n  \n  \n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ\n    flag = false;\n    if(now.foo.size() == 0) break;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n  Cursol crl;\n\n  while(cin >> n, n){\n    Data Main;\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nint f(int dep = 0){\n\t//if( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tassert((ss >> w[0] >> w[1] >> w[2] >> w[3]));\n\n\t\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\tf(dep+1);\n\t\t}\n\t//}\n\tV.push_back(w);\n\tname.push_back(s);\n\t\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\tp++;\n\tstring cnt;\n\twhile(ln[p] != '>')cnt += ln[p++];\n\tp++;\n\tassert(cnt == s);\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tint fst = 0;\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\tidx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tvector<int> &vv = V[idx];\n\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] ){\n\t\t\t\t\tif( vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cc = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tfor(int k = j+1 ; k < V.size() ; k++){\n\t\t\t\t\tvector<int> &v = V[j];\n\t\t\t\t\tvector<int> &vv = V[k];\n\t\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] && vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\t\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif( v[2] < vv[0] || vv[2] < v[0]) continue;\n\t\t\t\t\t\tif( v[3] < vv[1] || vv[3] < v[1]) continue;\n\t\t\t\t\t\t\tcc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(cc==0);\n\t\t\tcout << name[idx] << \" \" << c << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n\ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n\nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n\nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n\nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n\nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n\nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n\nbool eof() {\n  return __it == __end;\n}\n\nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n\nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n\nlexstat lstat = lexstat::no_stat;\n\ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n\n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n\n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n\n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n\n  lstat = lexstat::success;\n\n  return ret;\n}\n\nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n\nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n\ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n\nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n\n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n\n  while(i--) unread();\n  return false;\n}\n\n}\nusing namespace parser;\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct xml {\n  string tag;\n  vector<int> prop;\n  vector<shared_ptr<xml>> children;\n};\n\nshared_ptr<xml> parse(shared_ptr<xml>& p) {\n  while(!eof()) {\n    if(look_ahead(\"</\")) {\n      lex_f(\"</\" + p->tag + \">\");\n      return p;\n    } else if(look_ahead(\"<\")) {\n      auto c = make_shared<xml>();\n      c->tag = lex<string>(alphabetical, {}, {'<','>'});\n      c->tag = c->tag.substr(1, c->tag.size()-2);\n      c->prop = lex_stream<int>(integer, {','});\n      p->children.push_back(c);\n      parse(c);\n    }\n  }\n  return p;\n}\n\nshared_ptr<const xml> parse(Iter begin, Iter end) {\n  init_iterator(begin, end);\n  auto p = make_shared<xml>();\n  p->tag = \"OUT OF MAIN PANEL\";\n  return parse(p);\n}\n\npair<string, int> dfs(shared_ptr<const xml> const& p, int x, int y) {\n  for(auto && c: p->children)\n    if(c->prop[0] <= x && c->prop[1] <= y && x <= c->prop[2] && y <= c->prop[3])\n      return dfs(c, x, y);\n\n  return make_pair(p->tag, p->children.size());\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string xml_str; cin >> xml_str;\n    auto root = parse(xml_str.begin(), xml_str.end());\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nstruct Panel {\n  char name[1024];\n  int x1, y1, x2, y2;\n  vector<Panel*> children;\n};\n\npair<Panel*, const char*> parse(const char* input) {\n  Panel* panel = new Panel;\n  sscanf(input, \"<%[^>]>%d,%d,%d,%d\",\n      panel->name, &panel->x1, &panel->y1, &panel->x2, &panel->y2);\n  input = strchr(input+1, '<');\n  while (input[1] != '/') {\n    pair<Panel*, const char*> p = parse(input);\n    panel->children.push_back(p.first);\n    input = p.second;\n  }\n  return make_pair(panel, strchr(input, '>')+1);\n}\n\ninline bool point_in_rect(int x, int y, int x1, int y1, int x2, int y2) {\n  return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n}\n\nvoid dfs(Panel* panel, int x, int y) {\n  bool b = true;\n  FOREACH(it, panel->children) {\n    Panel* child = *it;\n    if (point_in_rect(x, y, child->x1, child->y1, child->x2, child->y2)) {\n      dfs(child, x, y);\n      b = false;\n    }\n  }\n  if (b) { printf(\"%s %zd\\n\", panel->name, panel->children.size()); }\n}\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    char input[1024]; scanf(\"%s\", input);\n    pair<Panel*, const char*> p = parse(input);\n    Panel* root = p.first;\n    assert(*p.second == 0);\n    REP(i, n) {\n      int x, y; scanf(\"%d%d\", &x, &y);\n      if (point_in_rect(x, y, root->x1, root->y1, root->x2, root->y2)) {\n        dfs(root, x, y);\n      } else {\n        puts(\"OUT OF MAIN PANEL 1\");\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n  \n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tbool operator<(const Panel &p)const{return x1<p.x1;}\n\tvoid print(){\n\t\tcout<<name<<':'<<x1<<','<<y1<<','<<x2<<','<<y2<<endl;\n\t}\n};\n\n\nvector<Panel> v;\n\nvoid extract(string &s){\n\tfor(int i=0;i+1<s.size();i++){\n\t\tif(s[i]=='<'&&s[i+1]!='/'){\n\t\t\tchar c;\n\t\t\tPanel panel;\n\t\t\tstring tmp;\n\t\t\tfor(i++;s[i]!='>';i++)tmp+=s[i];\n\t\t\tpanel.name=tmp;\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.x1=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.y1=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.x2=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!='<';i++)tmp+=s[i];\n\t\t\tpanel.y2=atoi(tmp.c_str());\n\t\t\ti--;\n\t\t\tv.push_back(panel);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint n;\n\tchar c;\n\twhile(cin>>n&&n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tv.clear();\n\t\textract(s);\n\t\tsort(v.begin(),v.end());\n\t\t//for(int i=0;i<v.size();i++)v[i].print();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tint a=-1;\n\t\t\tfor(int j=v.size()-1;j>=0;j--){\n\t\t\t\tif(v[j].x1<=x&&v[j].y1<=y&&x<=v[j].x2&&y<=v[j].y2){\n\t\t\t\t\ta=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif(a==-1){\n\t\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvector<int> child;\n\t\t\tfor(int j=a+1;j<v.size();j++){\n\t\t\t\tif(v[a].x1<=v[j].x1&&v[a].y1<=v[j].y1&&v[j].x2<=v[a].x2&&v[j].y2<=v[a].y2){\n\t\t\t\t\tbool f=true;\n\t\t\t\t\tfor(int k=0;k<child.size();k++){\n\t\t\t\t\t\tPanel &p=v[child[k]];\n\t\t\t\t\t\tif(p.x1<=v[j].x1&&p.y1<=v[j].y1&&v[j].x2<=p.x2&&v[j].y2<=p.y2){\n\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f)child.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<v[a].name<<' '<<child.size()<<endl;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Point{\npublic:\n  string name;  \n  int l,r,u,d,s,ss;\n};\n\nint main(){\n  int i,j,n,x[100],y[100],c,s;\n  Point p[5000];\n  string str;\n  cin >> n;\n  cin >> str;\n  for(i=0;i<n;i++) cin >> x[i] >> y[i];\n\n  c = 0;\n  s = 0;\n\n  for(i=0;i<str.size()-1;i++){\n    if(str[i] == '<' && str[i+1] != '/'){\n      p[c].name = \"\";\n      i++;\n      for(;str[i] != '>';i++) p[c].name += str[i];\n\n      i++;\n      p[c].l = p[c].r = p[c].u = p[c].d = 0;\n\n      for(;str[i] != ',';i++){\n\tp[c].l *= 10;\n\tp[c].l += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != ',';i++){\n\tp[c].u *= 10;\n\tp[c].u += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != ',';i++){\n\tp[c].r *= 10;\n\tp[c].r += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != '<';i++){\n\tp[c].d *= 10;\n\tp[c].d += str[i] - '0';\n      }\n      p[c].s = s;\n      c++;\n      s++;\n      i--;\n    }\n    else if(str[i] == '<' && str[i+1] == '/') s--;\n  }\n  \n  for(i=0;i<c;i++){\n    p[i].ss = 0;\n    for(j=i+1;j<c;j++){\n      if(p[i].s >= p[j].s) break;\n      else if(p[i].s + 1 == p[j].s) p[i].ss++;\n    }\n  }\n\n  for(i=0;i<n;i++){\n    Point u,v;\n    bool f = false;\n    for(j=0;j<c;j++){\n      if(p[j].l <= x[i] && x[i] <= p[j].r && p[j].u <= y[i] && y[i] <= p[j].d){\n\tif(!f){\n\t  f = true;\n\t  u = p[j];\n\t}\n\telse{\n\t  v = p[j];\n\t  if(u.s < v.s) u = v;\n\t}\n      }\n    }\n    if(f) cout << u.name << \" \" << u.ss << endl;\n    else cout << \"OUT OF MAIN PANEL 1\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nstring tag;\nsize_t cur;\n\nmap<int, string> tag_name;\nvector<int> ch[200];\n\nint xl[200];\nint yl[200];\nint xr[200];\nint yr[200];\n\nint res;\n\nstring get_name(){\n\tstring res;\n\tassert(cur < tag.size());\n\twhile(tag[cur] != '>'){\n\t\tres.push_back(tag[cur++]);\n\t}\n\treturn res;\n}\n\nint get_num(){\n\tint res = 0;\n\twhile(isdigit(tag[cur])){\n\t\tres = res * 10 + tag[cur++] - '0';\n\t}\n\treturn res;\n}\n\nvoid get_size(int id){\n\txl[id] = get_num();\n\tassert(tag[cur++] == ',');\n\tyl[id] = get_num();\n\tassert(tag[cur++] == ',');\n\txr[id] = get_num();\n\tassert(tag[cur++] == ',');\n\tyr[id] = get_num();\n//\tcout << id << \" \" << xl[id] << \" \"<< xr[id] << endl;\n}\n\nvoid tag_con(int &id){\n\tint num = id;\n\tassert(tag[cur++] == '<');\n\ttag_name[id] = get_name();\n\tassert(tag[cur++] == '>');\n\tget_size(id);\n\n\twhile(true){\n\t\n\t\tassert(cur < tag.size() && tag[cur] == '<');\n\t\tchar c = tag[cur+1];\n\t\tif(c == '/') break;\n\t\tch[num].push_back(++id);\n\t\ttag_con(id);\n\t}\n\twhile(tag[cur] != '>') cur++;\n\tcur++;\n}\n\nvoid get_tag(int x, int y, int id){\n\t//cout << id << \" \" << xl[id] << endl;\n\tif(xl[id] <= x && x <= xr[id] && yl[id] <= y && y <= yr[id]){\n\t\tres = id;\n\t}\n\tfor(int i = 0; i < (int)ch[id].size(); i++){\n\t\tget_tag(x, y, ch[id][i]);\n\t}\n}\n\nint main(){\n\tint n, x, y;\n\tint cnt = 0;\n\twhile(cin >> n && n){\n\t\ttag_name.clear();\n\t\ttag_name[120] = \"OUT OF MAIN PANEL\";\n\t\tch[120].push_back(120);\n\t\trep(i, 200) ch[i].clear();\n\t\tcur = 0;\n\t\tcnt = 0;\n\t\tcin >> tag;\n\t\ttag_con(cnt);\n\t\trep(i, n){\n\t\t\tres = 120;\n\t\t\tcin >> x >> y;\n\t\t\tget_tag(x, y, 0);\n\t\t\tcout << tag_name[res] << \" \"<< ch[res].size() << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring S,ans;\nint pos,acnt,d;\nint X,Y;\n\n\nstring get_str(){\n  string res;\n  while(S[pos]!='>') res+=S[pos++];\n  pos++;\n  return res;\n}\n\nint get_xy(){\n  int res=0;\n  while(S[pos]!=','&&S[pos]!='<')res=res*10+S[pos++]-'0';\n  if(S[pos]==',')pos++;\n  return res;\n}\n\nvoid bnf(string str){\n  string name;\n  int cnt=0,f=0;\n  \n  while(S[pos]=='<'&&S[pos+1]!='/'){\n    pos++;\n    name=get_str();\n    int x1=get_xy();\n    int y1=get_xy();\n    int x2=get_xy();\n    int y2=get_xy();\n    if(x1<=X&&X<=x2&&y1<=Y&&Y<=y2)f=1,bnf(name);\n    else cnt++;\n    string res;\n    while(res!=name){\n      if(S[pos+1]=='/')pos+=2;\n      else pos++;\n      res=get_str();\n    }\n  }\n  if(!f)ans=str,acnt=cnt;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    cin>>S;\n    S+=\"</OUT OF MAIN PANEL>\";\n      while(n--){\n\tcin>>X>>Y;\n\tpos=0;\n\tacnt=0;\n\tbnf(\"OUT OF MAIN PANEL\");\n\tcout <<ans<<\" \"<<acnt<<endl;\n      }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct panel {\n  char name[1001];\n  int x1, y1;\n  int x2, y2;\n  vector<panel> child;\n};\n\npanel app;\n\nvoid parse(panel &p, char tag[])\n{\n  while(1){\n    char tmp[1100];\n    sscanf(tag, \"<%[^>]>%s\", tmp, tag);\n    char aaa[1100] = \"/\";\n    strcat(aaa, p.name);\n    if(strcmp(aaa, tmp) == 0) return;\n    panel c;\n    char next[1100];\n    strcpy(c.name, tmp);\n    sscanf(tag, \"%d,%d,%d,%d%s\", &c.x1, &c.y1, &c.x2, &c.y2, next);\n    //cout << c.name << \" \" << next << endl;\n    parse(c, next);\n    strcpy(tag, next);\n    p.child.push_back(c);\n  }\n}\n\nbool inPanel(panel &p, int x, int y)\n{\n  if(p.x1 <= x && x <= p.x2 && p.y1 <= y && y <= p.y2){\n    for(int i = 0; i < p.child.size(); i++){\n      if(inPanel(p.child[i], x, y)) return true;\n    }\n    if(strcmp(p.name, \"#$%123\") == 0) return false;\n    cout << p.name << \" \" << p.child.size() << endl;\n    return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n, n){\n    char tag[1100];\n    scanf(\"%s\", tag);\n    //sscanf(tag, \"<%[^>]>%d,%d,%d,%d%s\", app.name, &app.x1, &app.y1, &app.x2, &app.y2, next);\n    //cout << app.name << \" \" << next << endl;\n    strcpy(app.name, \"#$%123\");\n    app.x1 = -1; app.y1 = -1;\n    app.x2 = 10001; app.y2 = 10001;\n    strcat(tag, \"</#$%123>\");\n    parse(app, tag);\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      if(!inPanel(app, x, y)) cout << \"OUT OF MAIN PANEL 1\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\nchar str[11000];\nstring m[1100];\nint x1[1100];\nint x2[1100];\nint y1[1100];\nint y2[1100];\nint fi[1100];\nint par[1100];\nint tmp[1100];\nint sz[1100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tscanf(\"%s\",str);\n\t\tint n=0;\n\t\tfor(int i=0;str[i];i++){\n\t\t\tif(str[i]=='<'&&str[i+1]!='/'){\n\t\t\t\tfi[n]=i;\n\t\t\t\tstring now=\"\";\n\t\t\t\tint j;\n\t\t\t\tfor(j=i+1;str[j]!='>';j++)now+=str[j];\n\t\t\t\tj++;\n\t\t\t\tx1[n]=x2[n]=y1[n]=y2[n]=0;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\tx1[n]*=10;x1[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\ty1[n]*=10;y1[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\tx2[n]*=10;x2[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\ty2[n]*=10;y2[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\tm[n++]=now;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)par[i]=-1;\n\t\tfor(int i=0;i<n;i++)tmp[i]=99999999;\n\t\tfor(int i=0;i<n;i++)sz[i]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(x1[j]<x1[i]&&x2[i]<x2[j]&&y1[j]<y1[i]&&y2[i]<y2[j]){\n\t\t\t\t\tif(x2[j]-x1[j]<tmp[i]){\n\t\t\t\t\t\tpar[i]=j;\n\t\t\t\t\t\ttmp[i]=x2[j]-x1[j];\n\t\t\t\t\t}\n\t\t\t\t\tsz[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tsz[i]=0;\n\t\t\tfor(int j=0;j<n;j++)if(par[j]==i)sz[i]++;\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\t\tint to=-1;\n\t\t\tint val=99999999;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(x1[j]<=x&&x<=x2[j]&&y1[j]<=y&&y<=y2[j]){\n\t\t\t\t\tif(x2[j]-x1[j]<val){\n\t\t\t\t\t\tval=x2[j]-x1[j];\n\t\t\t\t\t\tto=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!~to)printf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t\telse{\n\t\t\t\tprintf(\"%s %d\\n\",m[to].c_str(),sz[to]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(const Data& now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n\n  bool flag = true;\n  while(flag){\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n\n  Cursol crl;\n\n  while(cin >> n, n){\n    Data Main; //メインパネル\n\n    cin >> tag;\n\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      //  pair< string , int > ans = solve( x, y, Main);\n      //cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct Tag{\n\tpublic:\n\tstring name;\n\tP p, q;\n\tvector<Tag> vec;\n\tTag(string _name, P _p, P _q): name(_name), p(_p), q(_q) {}\n\t\n\tbool check(P t);\n\tbool comp(P t);\n};\n\nbool Tag::check(P t)\n{\n\tbool f = false;\n\t\n\tif(comp(t)){\n\t\tf = true;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tif(vec[i].comp(t)){\n\t\t\t\treturn vec[i].check(t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << name << \" \" << vec.size() << endl;\n\t}\n\t\n\treturn f;\n}\n\nbool Tag::comp(P t)\n{\n\tif(p.first <= t.first && t.first <= q.first &&\n\t\t p.second <= t.second && t.second <= q.second){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\npair<P,P> split(string str)\n{\n\tvector<int> v;\n\tstring s = \"\";\n\t\n\tfor(int i =0; i < str.size(); i++){\n\t\tif(str[i] == ','){\n\t\t\tv.push_back(atoi(s.c_str()));\n\t\t\ts = \"\";\n\t\t} else {\n\t\t\ts += str[i];\n\t\t}\n\t}\n\tv.push_back(atoi(s.c_str()));\n\t\n\treturn pair<P,P>(P(v[0], v[1]), P(v[2], v[3]));\n}\n\nint l;\nTag mktag(string str)\n{\n\tstring s, t;\n\ts = t = \"\";\n\tl++;\n\twhile(str[l] != '>'){\n\t\ts += str[l++];\n\t}\n\tl++;\n\twhile(str[l] != '<'){\n\t\tt += str[l++];\n\t}\n\tpair<P, P> pr = split(t);\n\tTag tg = Tag(s, pr.first, pr.second);\n\ts = \"</\" + s + \">\";\n\twhile(str.substr(l, s.size()) != s){\n\t\ttg.vec.push_back(mktag(str));\n\t}\n\tl += s.size();\n\t\n\treturn tg;\n}\n\nint main()\n{\n\tint n;\n\tstring str;\n\tP p;\n\t\n\twhile(cin>>n && n){\n\t\tcin >> str;\n\t\tl = 0;\n\t\tTag tg = mktag(str);\n\t\twhile(n--){\n\t\t\tcin >> p.first >> p.second;\n\t\t\tif(!tg.check(p)){\n\t\t\t\tcout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  Panel *parent;\n  vector<Panel> child;\n\n  void init(){name=\"\";x1=y1=x2=y2=0;parent=NULL;child.clear();}\n};\n\nPanel list;\npair<string,int>ans;\nint maxDepth;\n\nvoid parse(string s)\n{\n  stringstream ss;\n  for(int i=0;i<s.size();i++)if(s[i]==','||s[i]=='<'||s[i]=='>')s[i]=' ';\n  ss.str(s);\n\n  stack<string>st;\n\n  Panel *now=&list;\n  ss>>list.name>>list.x1>>list.y1>>list.x2>>list.y2;\n  st.push(list.name);\n\n  while(!st.empty()){\n    Panel p={\"\",0,0,0,0,NULL};\n    ss>>p.name;\n    if(p.name[0]=='/'){\n      st.pop();\n      now=(*now).parent;\n      continue;\n    }\n    st.push(p.name);\n    p.parent=now;\n    ss>>p.x1>>p.y1>>p.x2>>p.y2;\n    (*now).child.push_back(p);\n    now=&(*now).child[(*now).child.size()-1];\n  }\n\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n  if(x<p.x1 || p.x2<x || y<p.y1 || p.y2<y)return;\n  if(maxDepth<depth){\n    maxDepth=depth;\n    ans.first=p.name;\n    ans.second=p.child.size();\n  }\n  vector<Panel>::iterator it;\n  for(it=p.child.begin();it!=p.child.end();it++)solve(*it,x,y,depth+1);\n}\n\nint main()\n{\n  string s;\n  int n,x,y;\n  while(cin>>n,n){\n    cin>>s;\n    list.init();\n    parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      solve(list,x,y,0);\n      if(maxDepth==-1){\n\tans.first=\"OUT OF MAIN PANEL\";\n\tans.second=1;\n      }\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\nchar str[11000];\nstring m[1100];\nint x1[1100];\nint x2[1100];\nint y1[1100];\nint y2[1100];\nint fi[1100];\nint par[1100];\nint tmp[1100];\nint sz[1100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tscanf(\"%s\",str);\n\t\tint n=0;\n\t\tfor(int i=0;str[i];i++){\n\t\t\tif(str[i]=='<'&&str[i+1]!='/'){\n\t\t\t\tfi[n]=i;\n\t\t\t\tstring now=\"\";\n\t\t\t\tint j;\n\t\t\t\tfor(j=i+1;str[j]!='>';j++)now+=str[j];\n\t\t\t\tj++;\n\t\t\t\tx1[n]=x2[n]=y1[n]=y2[n]=0;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\tx1[n]*=10;x1[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\ty1[n]*=10;y1[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\tx2[n]*=10;x2[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\ty2[n]*=10;y2[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\tm[n++]=now;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)par[i]=-1;\n\t\tfor(int i=0;i<n;i++)tmp[i]=99999999;\n\t\tfor(int i=0;i<n;i++)sz[i]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(x1[j]<x1[i]&&x2[i]<x2[j]&&y1[j]<y1[i]&&y2[i]<y2[j]){\n\t\t\t\t\t/*if(x2[j]-x1[j]<tmp[i]){\n\t\t\t\t\t\tpar[i]=j;\n\t\t\t\t\t\ttmp[i]=x2[j]-x1[j];\n\t\t\t\t\t}*/\n\t\t\t\t\tsz[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(int i=0;i<n;i++){\n\t\t\tsz[i]=0;\n\t\t\tfor(int j=0;j<n;j++)if(par[j]==i)sz[i]++;\n\t\t}\n*/\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\t\tint to=-1;\n\t\t\tint val=99999999;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(x1[j]<=x&&x<=x2[j]&&y1[j]<=y&&y<=y2[j]){\n\t\t\t\t\tif(x2[j]-x1[j]<val){\n\t\t\t\t\t\tval=x2[j]-x1[j];\n\t\t\t\t\t\tto=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!~to)printf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t\telse{\n\t\t\t\tprintf(\"%s %d\\n\",m[to].c_str(),sz[to]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nstruct DATA{\n  string name;\n  int x1, y1, x2, y2;\n  set<int> next;\n};\n\nvoid ConvertData(string&, vector<DATA>&, int);\nvoid ConvertDataInner(const string, string, DATA&);\nint AtoiString(const string);\nint TouchPanel(int, int, int, vector<DATA>&);\n\nint main(){\n  int i, j, n, x, y, ans;\n  string str;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    cin >> str;\n    vector< vector<DATA> > data;\n    while(!str.empty()){\n      vector<DATA> onedata(1);\n      ConvertData(str, onedata, 0);\n      data.push_back(onedata);\n    }\n\n    for(i=0; i<n; ++i){\n      cin >> x >> y;\n      for(j=0; j<data.size(); ++j){\n\tans = TouchPanel(x, y, 0, data[j]);\n\tif(ans != -1){\n\t  cout << data[j][ans].name << \" \" << data[j][ans].next.size() << endl;\n\t  break;\n\t}\n      }\n      if(ans == -1) cout << \"OUT OF MAIN PANEL 1\" << endl;\n    }\n  }\n  return 0;\n}\n\nvoid ConvertData(string& str, vector<DATA>& data, int x){\n  DATA _data;\n  string::iterator i, j;\n\n  i = find(str.begin(), str.end(), '>');\n  j = find(i+1, str.end(), '<');\n\n  const string name(str.begin()+1, i);\n  string info(i+1, j);\n  ConvertDataInner(name, info, data[x]);\n  str.erase(str.begin(), j);\n\n  while(1){\n    i = find(str.begin(), str.end(), '>');\n    const string name(str.begin()+1, i);\n    if(name == \"/\" + data[x].name){\n      str.erase(str.begin(), i+1);\n      return;\n    }\n    data.push_back(_data);\n    data[x].next.insert(data.size()-1);\n    ConvertData(str, data, data.size()-1);\n  }\n}\n\nvoid ConvertDataInner(const string name, string str, DATA& data){\n  string::iterator i, j, k;\n\n  i = find(str.begin(), str.end(), ',');\n  j = find(i+1, str.end(), ',');\n  k = find(j+1, str.end(), ',');\n\n  const string x1(str.begin(), i);\n  const string y1(i+1, j);\n  const string x2(j+1, k);\n  const string y2(k+1, str.end());\n\n  data.name = name;\n  data.x1 = AtoiString(x1);\n  data.y1 = AtoiString(y1);\n  data.x2 = AtoiString(x2);\n  data.y2 = AtoiString(y2);\n  data.next.clear();\n}\n\nint AtoiString(const string s){\n  int i, x, d;\n  for(i=s.size()-1, x=0, d=1; i>=0; --i, d*=10)\n    x += ((s[i] - 48) * d);\n  return x;\n}\n\nint TouchPanel(int x, int y, int n, vector<DATA>& data){\n  if(data[n].x1 <= x && x <= data[n].x2 && data[n].y1 <= y && y <= data[n].y2){\n    int m;\n    set<int>::iterator i;\n    for(i=data[n].next.begin(); i!=data[n].next.end(); ++i){\n      m = TouchPanel(x, y, *i, data);\n      if(m != -1) return m;\n    }\n    return n;\n  }else{\n    return -1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Panel{\n  string name;\n  int size;\n  int coords[4];\n  Panel* children[100];\n  Panel() : size(0) {}\n};\nstruct Result{\n  Panel* value;\n  int p;\n  Result(Panel* v, int p) : value(v), p(p) {}\n};\nResult expr(const string& s, int p){\n  Panel* panel = new Panel;\n  assert(s[p] == '<');\n  int tag_end = s.find('>', p);\n  panel->name = s.substr(p + 1, tag_end - (p + 1));\n  p = tag_end + 1;\n  REP(i, 4){\n    int& v = panel->coords[i];\n    v = 0;\n    assert(isdigit(s[p]));\n    while(isdigit(s[p])){\n      v = v * 10 + s[p++] - '0';\n    }\n    if(s[p] == ',') p++;\n  }\n  while(s[p + 1] != '/'){\n    assert(s[p] == '<');\n    Result r = expr(s, p);\n    panel->children[(panel->size)++] = r.value;\n    p = r.p;\n  }\n  tag_end = s.find('>', p);\n  return Result(panel, tag_end + 1);\n}\nbool contain(int x, int y, Panel* p){\n  return p->coords[0] <= x && x <= p->coords[2] && p->coords[1] <= y && y <= p->coords[3];\n}\nPanel* find(int x, int y, Panel* p){\n  for(int i = 0; i < p->size; i++){\n    if(contain(x, y, p->children[i])){\n      return find(x, y, p->children[i]);\n    }\n  }\n  return p;\n}\nint main(){\n  int N;\n  while(cin >> N && N){\n    string s;\n    cin >> s;\n    Result r = expr(s, 0);\n    assert(r.p == s.size());\n    Panel* main = r.value;\n    REP(i, N){\n      int x, y; cin >> x >> y;\n      if(contain(x, y, main)){\n        Panel* res = find(x, y, main);\n        cout << res->name << \" \" << res->size << endl;\n      }else{\n        cout << \"OUT OF MAIN PANEL 1\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  vector<Panel> child;\n};\n\nint i=0;\npair<string,int>ans;\nint maxDepth;\n\nPanel parse(string s)\n{\n  Panel p={\"\",0,0,0,0};\n  for(i++;s[i]!='>';i++)p.name+=s[i];\n  char c;\n  stringstream ss;\n  ss.str(s.substr(i+1,s.size()-i-1));\n  ss>>p.x1>>c>>p.y1>>c>>p.x2>>c>>p.y2;\n  while(s[i]!='<')i++;\n  while(s[i+1]!='/')p.child.push_back(parse(s));\n  while(s[i]!='>')i++;\n  i++;\n  return p;\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n}\n\nint main()\n{\n  int n,x,y;\n  string s;\n  while(cin>>n,n){\n    cin>>s;\n    s=\"<OUT OF MAIN PANEL>-1,-1,10001,10001\"+s+\"</OUT OF MAIN PANEL>\";\n    Panel p=parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      solve(p,x,y,0);\n      if(ans.first==\"OUT OF MAIN PANEL\")ans.second=1;\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n \ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n \nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n \nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n \nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n \nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n \nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n \nbool eof() {\n  return __it == __end;\n}\n \nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n \nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n \nlexstat lstat = lexstat::no_stat;\n \ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n \n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n \n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n \n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n \n  lstat = lexstat::success;\n \n  return ret;\n}\n \nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n \nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n \ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n \nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n \n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n \n  while(i--) unread();\n  return false;\n}\n \n}\nusing namespace parser;\n\n#define DEF_PARSER(ast, property_definitions, root_settings) \\\nstruct ast {  \\\n  property_definitions; \\\n  vector<shared_ptr<ast>> children; \\\n};  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p); \\\nshared_ptr<const ast> parse_ ## ast(Iter begin, Iter end) { \\\n  init_iterator(begin, end);  \\\n  auto p = make_shared<xml>();  \\\n  root_settings; \\\n  return parse_ ## ast(p);  \\\n}\n\n#define PARSE(ast, tar) \\\n  parse_ ## ast(begin(tar), end(tar))\n\n#define PARSER_STREAM_IMPL(ast, start_cond)  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p) { \\\n  while(!eof()) { \\\n    if (start_cond) {\n#define HEAD(str) look_ahead(str)\n#define TERMINATE return p;\n#define CHANCE(cond)  \\\n } else if(cond) {\n\n#define END_PARSER_STREAM_IMPL \\\n  }} \\\n  return p; \\\n}\n\n#define prop(pr) p->pr\n#define cprop(pr) c->pr\n\n#define RECUR(ast, property_settings)  \\\nauto c = make_shared<ast>(); \\\nproperty_settings;  \\\np->children.push_back(c); \\\nparse_ ## ast(c); continue;\n\n#define ast_ref(const_ast) shared_ptr<const const_ast> const& __ast_ref_p\n#define enumerate_children(c)  \\\n  for(auto && c: __ast_ref_p->children)\n\n#define ref_prop(pr) __ast_ref_p->pr\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nDEF_PARSER(xml,\n  string tag;\n  vector<int> nums;\n  ,\n  prop(tag) = \"OUT OF MAIN PANEL\"\n)\n\nPARSER_STREAM_IMPL(xml,\n  HEAD(\"</\"))\n    lex_f(\"</\" + p->tag + \">\"); TERMINATE CHANCE(\n  HEAD(\"<\"))\n    RECUR(xml,\n      cprop(tag)  = lex<string>(alphabetical, {}, {'<','>'});\n      cprop(tag)  = c->tag.substr(1, c->tag.size()-2);\n      cprop(nums) = lex_stream<int>(integer, {','});\n    )\nEND_PARSER_STREAM_IMPL\n\n\npair<string, int> dfs(ast_ref(xml), int x, int y) {\n  enumerate_children(c)\n    if(c->nums[0] <= x && c->nums[1] <= y && x <= c->nums[2] && y <= c->nums[3])\n      return dfs(c, x, y);\n\n  return {ref_prop(tag), ref_prop(children.size())};\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string str; cin >> str;\n    auto root = PARSE(xml, str);\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nvector<int> cntt;\n\nint f(int dep = 0){\n\t//if( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tassert((ss >> w[0] >> w[1] >> w[2] >> w[3]));\n\t\tint aaa=0;\n\t\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\tf(dep+1);\n\t\t\taaa++;\n\t\t}\n\t//}\n\tV.push_back(w);\n\tname.push_back(s);\n\tcntt.push_back(aaa);\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\tp++;\n\tstring cnt;\n\t\n\twhile(ln[p] != '>')cnt += ln[p++];\n\tp++;\n\tassert(cnt == s);\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tcntt.clear();\n\t\tint fst = 0;\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tif( (v[2]-v[0])*(v[3]-v[1]) < ok ){\n\t\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\t\tidx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\t\n\t\t\tcout << name[idx] << \" \" << cntt[idx] << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//02\n#include<iostream>\n#include<string>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef  int ia[1000];\n\nia lx,ty,rx,by,d,c;\nstring tn[1000];\nint p;\nchar s[1001];\nchar *sp;\n\nint exp(int dp){\n  if(*sp!='<'||sp[1]=='/')return 0;\n  char t[1000];\n  int cp=p;\n  p++;\n  d[cp]=dp;\n  sscanf(sp,\"<%[^>]>%d,%d,%d,%d\",t,lx+cp,ty+cp,rx+cp,by+cp);\n  sp++;\n  while(*sp!='<'){\n    sp++;\n  }\n  tn[cp]=t;\n  int nc;\n  for(nc=0;exp(dp+1);nc++);\n  c[cp]=nc;\n  while(sp[-1]!='>'){\n    sp++;\n  }\n  return 1;\n}\n\n  \n\nint main(){\n  for(int n;cin>>n,n;){\n    cin.ignore().getline(s,1001);\n    lx[0]=ty[0]=-1;\n    rx[0]=by[0]=10001;\n    d[0]=0;\n    c[0]=1;\n    tn[0]=\"OUT OF MAIN PANEL\";\n    p=1;\n    sp=s;\n    exp(1);\n    while(n--){\n      int md=-1;\n      int id;\n      int x,y;\n      cin>>x>>y;\n      for(int i=0;i<p;i++){\n\tif(lx[i]<=x&&x<=rx[i]&&ty[i]<=y&&y<=by[i]&&md<d[i]){\n\t  md=d[i];\n\t  id=i;\n\t}\n      }\n      cout<<tn[id]<<' '<<c[id]<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.second, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret);\n  }\n}\n\n\nint main(){\n  int n;\n  string tag;\n  Data Main; //メインパネル\n\n  Cursol crl;\n\n  cin >> n;\n  cin >> tag;\n\n  Check( crl = tag.begin(), Main); //構文解析\n\n  /*\n  while(n--){\n    int x, y;\n    cin >> x >> y;\n  }\n  */\n\n  cout << Main.foo[0].name << endl;\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Tag\n{\npublic:\n    string name;\n    int x1, y1, x2, y2;\n    int num;\n};\n\nvoid readTag(string& s, int& i, vector<Tag>& tag)\n{\n    Tag t;\n    int j = s.find('>', i);\n    t.name = s.substr(i+1, j-i-1);\n    i = j + 1;\n\n    j = s.find('<', i);\n    istringstream iss(s.substr(i, j-i));\n    char c;\n    iss >> t.x1 >> c >> t.y1 >> c >> t.x2 >> c >> t.y2;\n    i = j;\n\n    t.num = 0;\n    while(s[i+1] != '/'){\n        ++ t.num;\n        readTag(s, i, tag);\n    }\n    tag.push_back(t);\n\n    i = s.find('>', i) + 1;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        string s;\n        cin >> s;\n        int i = 0;\n        vector<Tag> tag;\n        readTag(s, i, tag);\n\n        for(int i=0; i<n; ++i){\n            int x, y;\n            cin >> x >> y;\n            unsigned j;\n            for(j=0; j<tag.size(); ++j){\n                if(tag[j].x1 <= x && x <= tag[j].x2 && tag[j].y1 <= y && y <= tag[j].y2){\n                    cout << tag[j].name << ' ' << tag[j].num << endl;\n                    break;\n                }\n            }\n            if(j == tag.size()){\n                cout << \"OUT OF MAIN PANEL 1\" << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <stack>\n\nusing namespace std;\n\nstruct Area {\n    int ulx, uly, lrx, lry;\n    Area(int ulx=0, int uly=0, int lrx=0, int lry=0)\n        : ulx(ulx), uly(uly), lrx(lrx), lry(lry) {}\n    bool contains(int x, int y) const {\n//        cout << x << ',' << y << endl;\n        return (ulx <= x && x <= lrx && uly <= y && y <= lry);\n    }\n};\n\nenum Type {\n    START,\n    END,\n    AREA,\n};\n\nstruct Token {\n    Type type;\n    string tagName;\n    Area area;\n};\n\nstring input;\nint index;\n\nint getInt() {\n    while (!isdigit(input[index])) index++;\n    int n = 0;\n    while (isdigit(input[index])) {\n        n = n * 10 + input[index] - '0';\n        index++;\n    }\n    return n;\n}\n\nToken nextToken() {\n    string buf;\n    Token t;\n    if (input[index] == '<') {\n        index++;\n        if (input[index] == '/') {\n            t.type = END;\n            index++;\n        } else {\n            t.type = START;\n        }\n        while (input[index] != '>') {\n            buf.push_back(input[index]);\n            index++;\n        }\n        index++; // ignore '>'\n        t.tagName = buf;\n    } else {\n        t.type = AREA;\n        t.area.ulx = getInt();\n        t.area.uly = getInt();\n        t.area.lrx = getInt();\n        t.area.lry = getInt();\n    }\n    return t;\n}\n\nmap<string, Area> areaTable;\nmap<string, vector<string> > children;\nvoid parse() {\n    Token t;\n    stack<string> st;\n    string cur;\n    while (index < input.size()) {\n        t = nextToken();\n        if (t.type == START) {\n            cur = t.tagName;\n            if (!st.empty()) {\n                children[st.top()].push_back(cur);\n            }\n            st.push(cur);\n        } else if (t.type == END) {\n            st.pop();\n            if (!st.empty()) cur = st.top();\n        } else {\n            areaTable[cur] = t.area;\n        }\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        cin >> input;\n        input = \"<OUT OF MAIN PANEL>0,0,10000,10000\" + input + \"</OUT OF MAIN PANEL>\";\n        index = 0;\n        areaTable.clear();\n        children.clear();\n        parse();\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            int cnt = (1<<28);\n\n            for (map<string, Area>::iterator it = areaTable.begin();\n                    it != areaTable.end(); it++) {\n                if (it->second.contains(x, y)) {\n                    bool top = true;\n                    for (int i = 0; i < children[it->first].size(); i++) {\n                        if (areaTable[children[it->first][i]].contains(x, y)) {\n                            top = false;\n                            break;\n                        }\n                    }\n                    if (top) {\n                        cout << it->first << ' ' << children[it->first].size() << endl;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\n#define limit(A,B,C) (A<= B && B <= C) \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\n\nclass AOJ1031{\nprivate:\n  string s;\n  int n;\n  map<string,int> c_num;\n  map<string,PP> coor;\n  vector<string> name_list;\npublic:\n  AOJ1031(int n,string s):n(n),s(s){}\n  ~AOJ1031(){}\n\n  void getChildNumber(){\n   \n    int st,cnt=0;\n     \n    rep(i,name_list.size()){\n      string name = name_list[i];\n     \n      P A,B;\n      //A = coor[name].F,B = coor[name].S;\n      int cnt=0;\n      rep(j,name_list.size()){\n\tstring rename = name_list[j];\n\tA = coor[rename].F,B = coor[rename].S;\n\tif(name == name_list[j])continue;\n\tif(limit(coor[name].F.F,A.F,coor[name].S.F) && limit(coor[name].F.S,A.S,coor[name].S.S) && limit(coor[name].F.F,B.F,coor[name].S.F) && limit(coor[name].F.S,B.S,coor[name].S.S)){\n\t  cnt++;\n\t}\n      }\n      c_num[name] = cnt;\n      //cout << \"c_num[\" << name << \"] = \"<< c_num[name] << endl;\n    }\n  }\n\n  PP getPP(string s){\n    stringstream ss;\n    ss << s;\n    int Pm[4];\n    ss >> Pm[0] >> Pm[1] >> Pm[2] >> Pm[3];\n    return PP(P(Pm[0],Pm[1]),P(Pm[2],Pm[3]));\n  }\n\n  void getCoordinate(){\n\n    bool OK = false;\n    int st;\n    string store;\n    REP(i,0,s.length()){\n      if(s[i] == ','){\n\ts[i] = ' ';\n\tcontinue;\n      }\n\n      if(s[i] == '<' && s[i+1] != '/' && !OK)st = i,OK=true;\n      else if(s[i] == '>' && OK){\n\tstore = s.substr(st+1,i-1-st);\n\tcoor[store] = PP(P(-1,-1),P(-1,-1));\n\tst = i+1;\t\n      }\n      else if(s[i] == '<'){\n\tif(coor[store] != PP(P(-1,-1),P(-1,-1)))continue;\n\tcoor[store] = getPP(s.substr(st,i-st)); \n\tOK = false;\n\tst = i;\n\tif(s[i+1] != '/')OK = true;\n      }\n    }\n  }\n\n  void getNameList(){\n    int st = 0;\n    bool OK = false;\n    map<string,bool> index;\n    rep(i,s.length()){\n      if(s[i] == '<' && s[i+1] != '/' && !OK)st = i+1,OK = true;\n      else if(s[i] == '>' && OK){\n\tname_list.pb(s.substr(st,i-st));\n\tOK = false;\n      }\n\n\n    }\n  }\n\n  void run(){\n   \n    getCoordinate();\n    getNameList();\n    getChildNumber();\n\n    rep(i,n){\n      int x,y;\n      cin >> x >> y;\n      bool found = false;\n      string found_name;\n      P LIMA = P(0,0),LIMB = P(INT_MAX,INT_MAX); \n      int child = INT_MAX;\n      rep(i,name_list.size()){\n\tstring name = name_list[i];\n\n\tif(coor[name].F.F <= x && x <= coor[name].S.F && coor[name].F.S <= y && y <= coor[name].S.S && child > c_num[name] ){\n\t  found_name = name;\n\t  found = true;\n\t  child = c_num[name];\n\t}\n      }\n      if(!found)cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else cout << found_name << \" \" << c_num[found_name] << endl;\n\n    }\n  }\n\n\n};\n\nint main(){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0)break;\n    string s;\n    cin >> s;\n    AOJ1031 ans = AOJ1031(n,s);\n    ans.run();\n\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<string, int> P;\n\ntypedef struct node {\n  vector<node> ch;\n  string name;\n  int ty, tx, by, bx;\n  node() { }\n  node(string nn, int tty, int ttx, int bby, int bbx) { name = nn; ty = tty; tx = ttx; by = bby; bx = bbx; }\n} node;\n\nvoid add(node &root, string tar, string name, int ty, int tx, int by, int bx){\n  if(root.name == tar) { root.ch.push_back(node(name, ty, tx, by, bx)); return; }\n    REP(i, root.ch.size()){\n      node c = root.ch[i];\n      if(c.ty <= ty && c.tx <= tx && c.by >= by && c.bx >= bx){ add(root.ch[i], tar, name, ty, tx, by, bx); return; };\n  }\n}\n\nvoid disp(node &r, string b){\n  cout <<b <<r.name <<\", \" <<r.ch.size() <<endl;\n  REP(i, r.ch.size()) disp(r.ch[i], b + \"  \");\n}\n\nP touch(node &root, int y, int x, bool f, string s){\n  if(root.name == \"main\" && !(root.ty <= y && root.tx <= x && root.by >= y && root.bx >= x)) return P(\"OUT OF MAIN PANEL\", 1);\n  P ret = P(\"\", 0);\n  if(!f){\n    REP(i, root.ch.size()){\n      node c = root.ch[i];\n      if(c.ty <= y && c.tx <= x && c.by >= y && c.bx >= x) return touch(root.ch[i], y, x, f, s);\n    }\n  }\n  if(!f) ret.first = root.name;\n  if(f) ret.second += 1;\n  REP(i, root.ch.size()){\n    P r = touch(root.ch[i], y, x, true, s);\n    ret.second += r.second;\n  }\n  return ret;\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    string S; cin >>S;\n    node root;\n    vector<string> rn;\n    FOR(i, 1, S.length()){\n      stringstream ss, sss;\n      while(i < S.length() && S[i] != '<') ss << S[i++];\n      if(ss.str()[0] == '/') { rn.pop_back(); continue; }\n      int n = 0;\n      string s = ss.str(); ss.str(\"\");\n      while(s[n] != '>') ss << s[n++];\n      s = s.substr(n + 1) + \",\";\n      int nums[4] = {0}, num = 0; n = 0;\n      REP(j, s.length()){\n        if(s[j] == ','){\n          nums[n++] = num;\n          num = 0;\n        } else{\n          num *= 10;\n          num += s[j] - '0';\n        }\n      }\n      if(ss.str() == \"main\") root = node(ss.str(), nums[1], nums[0], nums[3], nums[2]);\n      else add(root, rn.back(), ss.str(), nums[1], nums[0], nums[3], nums[2]);\n      rn.push_back(ss.str());\n    }\n    //disp(root, \"\");\n    REP(n, N){\n      int x, y; cin >>x >>y;\n      P ret = touch(root, y, x, false, \"\");\n      cout <<ret.first <<\" \" <<ret.second <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n\ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n\nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n\nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n\nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n\nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n\nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n\nbool eof() {\n  return __it == __end;\n}\n\nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n\nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n\nlexstat lstat = lexstat::no_stat;\n\ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n\n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n\n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n\n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n\n  lstat = lexstat::success;\n\n  return ret;\n}\n\nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n\nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n\ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n\nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n\n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n\n  while(i--) unread();\n  return false;\n}\n\n}\nusing namespace parser;\n\n#define DEF_PARSER(ast, property_definitions, root_settings) \\\nstruct ast {  \\\n  property_definitions; \\\n  vector<shared_ptr<ast>> children; \\\n};  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p); \\\nshared_ptr<const ast> parse_ ## ast(Iter begin, Iter end) { \\\n  init_iterator(begin, end);  \\\n  auto p = make_shared<xml>();  \\\n  root_settings; \\\n  return parse_ ## ast(p);  \\\n}\n\n#define PARSE(ast, tar) \\\n  parse_ ## ast(begin(tar), end(tar))\n\n#define PARSER_IMPL(ast, start_cond)  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p) { \\\n  while(!eof()) { \\\n    if (start_cond) {\n#define HEAD(str) look_ahead(str)\n#define CHANCE(cond)  \\\n      return p; \\\n } else if(cond) {\n\n#define END_PARSER_IMPL \\\n  }} \\\n  return p; \\\n}\n\n#define prop(pr) p->pr\n#define cprop(pr) c->pr\n\n#define RECUR(ast, property_settings)  \\\nauto c = make_shared<ast>(); \\\nproperty_settings;  \\\np->children.push_back(c); \\\nparse_ ## ast(p);\n\n#define ast_ref(const_ast) shared_ptr<const const_ast> const& __ast_ref_p\n#define enumerate_children(c)  \\\n  for(auto && c: __ast_ref_p->children)\n\n#define ref_prop(pr) __ast_ref_p->pr\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nDEF_PARSER(xml,\n  string tag;\n  vector<int> nums;\n  ,\n  prop(tag) = \"OUT OF MAIN PANEL\"\n)\n\nPARSER_IMPL(xml,\n  HEAD(\"</\"))\n    lex_f(\"</\" + p->tag + \">\"); CHANCE(\n  HEAD(\"<\"))\n    RECUR(xml,\n      cprop(tag)  = lex<string>(alphabetical, {}, {'<','>'});\n      cprop(tag)  = c->tag.substr(1, c->tag.size()-2);\n      cprop(nums) = lex_stream<int>(integer, {','});\n    )\nEND_PARSER_IMPL\n\n\npair<string, int> dfs(ast_ref(xml), int x, int y) {\n  enumerate_children(c)\n    if(c->nums[0] <= x && c->nums[1] <= y && x <= c->nums[2] && y <= c->nums[3])\n      return dfs(c, x, y);\n\n  return {ref_prop(tag), ref_prop(children.size())};\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string str; cin >> str;\n    auto root = PARSE(xml, str);\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<stdio.h>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<Panel> v;\n};\n\nint fp;\n\nPanel parse(string s){\n\tPanel p;\n\tint ep=0;\n\twhile(s[fp] != '>'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.name = s.substr(fp-ep,ep);\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x1 = toInt(s.substr(fp-ep,ep));\n\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y1 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x2 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != '<'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y2 = toInt(s.substr(fp-ep,fp-1));\n\t\n\tfp++;\n\twhile(1){\n\t\tif(s[fp]=='/'){ fp+=p.name.size()+3; break;}\n\t\telse p.v.push_back(parse(s));\n\t}\t\n\treturn p;\n}\n\nPanel search(int x,int y,Panel r_p,Panel p){\n\tif(p.x1 <= x && p.x2 >= x && p.y1 <= y && p.y2 >= y){\n\t\tPanel ans=p;\n\t\trep(i,p.v.size()){\n\t\t\tPanel tmp = search(x,y,p,p.v[i]);\n\t\t\tif(tmp.name != p.name) ans = p.v[i];\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\treturn r_p;\n}\n\nint main(){\n\n\twhile(1){\n\t\tint n;\n\t\tstring str;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> str;\n\t\tfp=1;\n\t\tPanel p = parse(str);\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tPanel root;root.name=\"-1\";\n\t\t\tPanel ans=search(x,y,root,p);\n\t\t\tif(ans.name==\"-1\") cout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t\telse cout << ans.name << \" \" << ans.v.size() << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\nstring tag;\n\nbool inPosition(int x, int y, Data data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n  \n  \n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ\n    flag = false;\n    if(now.foo.size() == 0) break;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n  if(pos == tag.end()) return;\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n  if(pos == tag.end()) return;\n}\n\nint main(){\n  int n;\n  Cursol crl;\n\n  while(cin >> n, n){\n    Data Main;\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  vector<Panel> child;\n};\n\nint i=0;\npair<string,int>ans;\nint maxDepth;\n\nPanel parse(string s)\n{\n  Panel p={\"\",0,0,0,0};\n  return p;\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n}\n\nint main()\n{\n  int n,x,y;\n  string s;\n  while(cin>>n,n){\n    cin>>s;\n    s=\"<OUT OF MAIN PANEL>-1,-1,10001,10001\"+s+\"</OUT OF MAIN PANEL>\";\n    Panel p=parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      solve(p,x,y,0);\n      if(ans.first==\"OUT OF MAIN PANEL\")ans.second=1;\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\nusing namespace std;\nstruct S{string s;int x1,x2,y1,y2;vector<int>v;};\nvector<S>v;\nvoid F(char*&p,int n)\n{\n\tS s;\n\tchar*q;\n\tint i;\n\tfor(++p;*p-'>';++p)s.s.push_back(*p);\n\t++p;\n\tint *a[]={&s.x1,&s.y1,&s.x2,&s.y2};\n\tfor(i=0;i<4;++i)\n\t{\n\t\t*a[i]=strtol(p,&q,10);\n\t\tp=q;\n\t\tif(i-3)++p;\n\t}\n\tv.push_back(s);\n\ti=v.size()-1;\n\tv[n].v.push_back(i);\n\twhile(p[1]-'/')F(p,i);\n\tp+=3+s.s.size();\n}\nint G(int x,int y)\n{\n\tint r=0,i;\nN:\n\tfor(i=0;i<v[r].v.size();++i)\n\t{\n\t\tS&s=v[v[r].v[i]];\n\t\tif(s.x1<=x&&x<=s.x2&&s.y1<=y&&y<=s.y2)\n\t\t{\n\t\t\tr=v[r].v[i];\n\t\t\tgoto N;\n\t\t}\n\t}\n\treturn r;\n}\nint main()\n{\n\tint n,x,y,i;\n\tchar*t,s[1024];\n\tS p={\"_\",0,0,10000,10000};\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tv.clear();\n\t\tscanf(\"%s\",s);\n\t\tv.push_back(p);\n\t\tF(t=s,0);\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\ti=G(x,y);\n\t\t\tif(i)printf(\"%s %d\\n\",v[i].s.c_str(), v[i].v.size());\n\t\t\telse puts(\"OUT OF MAIN PANEL 1\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\nstring tag;\n\nbool inPosition(int x, int y, Data data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n  \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n  \n  \n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ\n    flag = false;\n    if(now.foo.size() == 0) break;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n  if(pos == tag.end()) return;\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n    if(pos == tag.end()) return;\n  }\n  getString(++pos);\n  ++pos;\n}\n\nint main(){\n  int n;\n  Cursol crl;\n\n  while(cin >> n, n){\n    Data Main;\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n\nstruct Rectangle {\n  size_t l, r, d, u;\n  std::string name;\n  int children=0;\n  Rectangle(size_t l, size_t r, size_t d, size_t u, const std::string &name):\n    l(l), r(r), d(d), u(u), name(name)\n  {}\n  bool contains(size_t x, size_t y) const {\n    return (x-l <= r && y-u <= d);\n  }\n};\n\nstd::vector<Rectangle> parse(const std::string &s) {\n  std::map<std::string, int> children;\n  std::stack<std::string> opened;\n  std::vector<Rectangle> res;\n  size_t i=0;\n  while (i < s.length()) {\n    assert(s[i] == '<');\n    ++i;\n    if (s[i] == '/') {\n      while (s[i++] != '>') {}\n      opened.pop();\n      continue;\n    }\n    std::string tag(1, s[i]);\n    while (isalnum(s[++i])) tag += s[i];\n    assert(s[i] == '>');\n    ++i;\n    assert(isdigit(s[i]));\n    size_t l=s[i]-'0';\n    while (isdigit(s[++i])) l = l*10+s[i]-'0';\n    assert(s[i] == ',');\n    ++i;\n    size_t u=s[i]-'0';\n    while (isdigit(s[++i])) u = u*10+s[i]-'0';\n    assert(s[i] == ',');\n    ++i;\n    size_t r=s[i]-'0';\n    while (isdigit(s[++i])) r = r*10+s[i]-'0';\n    assert(s[i] == ',');\n    ++i;\n    size_t d=s[i]-'0';\n    while (isdigit(s[++i])) d = d*10+s[i]-'0';\n    assert(s[i] == '<');\n\n    res.emplace_back(l, r, d, u, tag);\n    if (!opened.empty())\n      ++children[opened.top()];\n\n    opened.emplace(tag);\n  }\n  assert(opened.empty());\n\n  for (size_t i=0; i<res.size(); ++i) {\n    res[i].children = children[res[i].name];\n  }\n  return res;\n}\n\nint main() {\n  size_t n;\n  char buf[1024];\n  scanf(\"%zu %s\", &n, buf);\n  std::string s=buf;\n  std::vector<Rectangle> rects=parse(s);\n\n  for (size_t i=0; i<n; ++i) {\n    size_t x, y;\n    scanf(\"%zu %zu\", &x, &y);\n\n    size_t ind=-1;\n    for (size_t j=0; j<rects.size(); ++j) {\n      if (rects[j].contains(x, y))\n        ind = j;\n    }\n\n    if (ind+1 == 0) {\n      printf(\"OUT OF MAIN PANEL 1\\n\");\n    } else {\n      printf(\"%s %d\\n\", rects[ind].name.c_str(), rects[ind].children);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef struct Tag\n{\n\tstring name;\n\tint x1, y1, x2, y2;\n\tvector<Tag> child;\n} Tag;\n\nstring start_tag(const string& s, int& p)\n{\n\tstring name = \"\";\n\t++p;\n\twhile (s[p] != '>')\n\t\tname += s[p++];\n\t++p;\n\treturn name;\n}\n\nvoid tag_value(const string&s, int& p, Tag& tag)\n{\n\ttag.x1 = tag.y1 = tag.x2 = tag.y2 = 0;\n\n\twhile (s[p] != ',') {\n\t\ttag.x1 *= 10;\n\t\ttag.x1 += s[p++] - '0';\n\t}\n\t++p;\n\n\twhile (s[p] != ',') {\n\t\ttag.y1 *= 10;\n\t\ttag.y1 += s[p++] - '0';\n\t}\n\t++p;\n\n\twhile (s[p] != ',') {\n\t\ttag.x2 *= 10;\n\t\ttag.x2 += s[p++] - '0';\n\t}\n\t++p;\n\n\twhile (s[p] != '<') {\n\t\ttag.y2 *= 10;\n\t\ttag.y2 += s[p++] - '0';\n\t}\n}\n\nTag tag(const string& s, int& p)\n{\n\tTag node;\n\tnode.name = start_tag(s, p);\n\ttag_value(s, p, node);\n\twhile (s[p+1] != '/')\n\t\tnode.child.push_back(tag(s, p));\n\twhile (s[p] != '>')\n\t\t++p;\n\t++p;\n\treturn node;\n}\n\nbool solve(int x, int y, const Tag& root)\n{\n\tbool found = false;\n\tif (root.x1 <= x && x <= root.x2 && root.y1 <= y && y <= root.y2) {\n\t\tfor (unsigned int i = 0; i < root.child.size(); ++i)\n\t\t\tfound |= solve(x, y, root.child[i]);\n\t\tif (!found) {\n\t\t\tcout << root.name << \" \" << root.child.size() << endl;\n\t\t\tfound = true;\n\t\t}\n\t}\n\treturn found;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tstring s;\n\t\tcin >> s;\n\t\tint p = 0;\n\n\t\tTag root = tag(s, p);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif (!solve(x, y, root))\n\t\t\t\tcout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\n\nclass Pannel {\npublic:\n  Pannel *root;\n  string name;\n  vector<Pannel *> v;\n  int sx, sy, ex, ey;\n  Pannel() {}\n  Pannel(Pannel *root, string name) : root(root), name(name) {}\n  ~Pannel() {\n    for(int i = 0; i < v.size(); ++i) {\n      delete v[i];\n    }\n  }\n\n  Pannel *find(int x, int y) {\n    for(int i = 0; i < v.size(); ++i) {\n      if(v[i]->sx > x) continue;\n      if(v[i]->sy > y) continue;\n      if(v[i]->ex < x) continue;\n      if(v[i]->ey < y) continue;\n      Pannel *tmp = v[i]->find(x, y);\n      return tmp == NULL ? v[i] : tmp;\n    }\n    return NULL;\n  }\n};\n\nstring tag;\nint pos;\nPannel P;\n\n\nstring getTag() {\n  int s = pos;\n  for(; pos < tag.length(); ++pos) {\n    if(tag[pos] == '>') {\n      return tag.substr(s, pos++ - s);\n    }\n  }\n}\n\nvoid getXY(Pannel *p) {\n  int s = pos;\n  for(; pos < tag.length() && tag[pos] != '<'; ++pos);\n  string str = tag.substr(s, pos - s);\n  sscanf(str.c_str(), \"%d,%d,%d,%d\", &p->sx, &p->sy, &p->ex, &p->ey);\n  //cout << p->sx << \" \" << p->sy << \" \" << p->ex << \" \" << p->ey << endl;\n}\n\nvoid make() {\n  Pannel *p = &P;\n  pos = 0;\n  while(pos < tag.length()) {\n    ++pos;\n    string str = getTag();\n    if(str[0] == '/') {\n      p = p->root;\n    } else {\n      Pannel *tmp = p;\n      p = new Pannel(p, str);\n      tmp->v.push_back(p);\n      getXY(p);\n    }\n  }\n  //cout << \"cmp\" << endl;\n}\n\nvoid solve(int x, int y) {\n  Pannel *tmp = P.find(x, y);\n  if(tmp != NULL) {\n    cout << tmp->name << \" \" << tmp->v.size() << endl;\n    return;\n  }\n  cout << \"OUT OF MAIN PANEL 1\" << endl;\n}\n\nmain() {\n  int n;\n  while((cin >> n) && n) {\n    cin >> tag;\n    make();\n    for(int i = 0; i < n; ++i) {\n      int x, y;\n      cin >> x >> y;\n      solve(x, y);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <stack>\n\nusing namespace std;\n\nstruct Area {\n    int ulx, uly, lrx, lry;\n    Area(int ulx=0, int uly=0, int lrx=0, int lry=0)\n        : ulx(ulx), uly(uly), lrx(lrx), lry(lry) {}\n    bool contains(int x, int y) const {\n//        cout << x << ',' << y << endl;\n        return (ulx <= x && x <= lrx && uly <= y && y <= lry);\n    }\n};\n\nenum Type {\n    START,\n    END,\n    AREA,\n};\n\nstruct Token {\n    Type type;\n    string tagName;\n    Area area;\n};\n\nstring input;\nint index;\n\nint getInt() {\n    while (!isdigit(input[index])) index++;\n    int n = 0;\n    while (isdigit(input[index])) {\n        n = n * 10 + input[index] - '0';\n        index++;\n    }\n    return n;\n}\n\nToken nextToken() {\n    string buf;\n    Token t;\n    if (input[index] == '<') {\n        index++;\n        if (input[index] == '/') {\n            t.type = END;\n            index++;\n        } else {\n            t.type = START;\n        }\n        while (input[index] != '>') {\n            buf.push_back(input[index]);\n            index++;\n        }\n        index++; // ignore '>'\n        t.tagName = buf;\n    } else {\n        t.type = AREA;\n        t.area.ulx = getInt();\n        t.area.uly = getInt();\n        t.area.lrx = getInt();\n        t.area.lry = getInt();\n    }\n    return t;\n}\n\nmap<string, Area> areaTable;\nmap<string, int> childrenCount;\nvoid parse() {\n    Token t;\n    stack<string> st;\n    string cur;\n    while (index < input.size()) {\n        t = nextToken();\n        if (t.type == START) {\n            if (!st.empty()) {\n                childrenCount[st.top()]++;\n            }\n            cur = t.tagName;\n            st.push(cur);\n        } else if (t.type == END) {\n            st.pop();\n            if (!st.empty()) cur = st.top();\n        } else {\n            areaTable[cur] = t.area;\n        }\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        cin >> input;\n        index = 0;\n        parse();\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            string areaName;\n            cin >> x >> y;\n            int cnt = (1<<28);\n            for (map<string, Area>::iterator it = areaTable.begin();\n                    it != areaTable.end(); it++) {\n                if (it->second.contains(x, y)) {\n                    //cout << it->first << ' ' << childrenCount[it->first] << endl;\n                    if (cnt > childrenCount[it->first]) {\n                        cnt = childrenCount[it->first];\n                        areaName = it->first;\n                    }\n                }\n            }\n            if (cnt == (1<<28)) {\n                cout << \"OUT OF MAIN PANEL 1\" << endl;\n            } else {\n                cout << areaName << ' ' << cnt << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x <= b)\n\nstruct data{\n    int x1, y1, x2, y2;\n};\n\nvector<string> vs;\nvector<data> vd;\nvector<int> depth;\nmap<string, vector<string>> child;\n\nvoid init(){\n    vs.clear();\n    vd.clear();\n    depth.clear();\n    child.clear();\n}\n\nstring str(int &pos, string s){\n    string ret = \"\";\n    while(s[pos] != '>')    ret += s[pos++];\n    return ret;\n}\n\nint num(int &pos, string s){\n    int ret = 0;\n    while(isdigit(s[pos]))  ret = ret*10+s[pos++]-'0';\n    return ret;\n}\n\n// return : name of root panel\nstring build(int &pos, int dep, const string s){\n    pos++;  // <\n    string name = str(pos, s);\n    pos++;  // >\n    vs.push_back(name);\n    int c[4];\n    for(int i = 0; i < 4; i++){\n        c[i] = num(pos, s);\n        if(i != 3)  pos++;  // ,\n    }\n    vd.push_back(data({c[0], c[1], c[2], c[3]}));\n    depth.push_back(dep);\n    while(s[pos+1] != '/'){\n        child[name].push_back(build(pos, dep+1, s));\n    }\n    while(pos < s.length() && s[pos] != '>')    pos++;\n    pos++;  // >\n    return name;\n}\n\nint getPanel(int x, int y){\n    int ret = -1, tmpdep = -1;\n    for(int i = 0; i < vd.size(); i++){\n        if(!inRange(x, vd[i].x1, vd[i].x2) || !inRange(y, vd[i].y1, vd[i].y2))  continue;\n        if(depth[i] > tmpdep){\n            tmpdep = depth[i];\n            ret = i;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        string s;\n        cin >> s;\n        int pos = 0;\n        init();\n        build(pos, 0, s);\n        for(int i = 0; i < n; i++){\n            int x, y;\n            cin >> x >> y;\n            int panel = getPanel(x, y);\n            if(panel == -1){\n                cout << \"OUT OF MAIN PANEL 1\" << endl;\n                continue;\n            }\n            cout << vs[panel] << \" \" << (int)child[vs[panel]].size() << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,npanel;\nstring tags;\n\nstruct P{\n\tint x1,y1,x2,y2;\n\tint child,z;\n\tstring name;\n\t\n\tbool in(int x,int y){\n\t\treturn x1<=x&&x<=x2&&y1<=y&&y<=y2;\n\t}\n\tbool operator<(const P &r)const{\n\t\treturn z<r.z;\n\t}\n}panel[100];\n\nint parse(int s,int t,int z)\n{\n\tint cur=npanel; npanel++;\n\tpanel[cur].z=z;\n\t\n\tint lTagEnd=tags.find(\">\",s),rTagBeg,rTagEnd,nextTagBeg;\n\tpanel[cur].name=tags.substr(s+1,lTagEnd-s-1);\n\tnextTagBeg=tags.find(\"<\",s+1);\n\t\n\tstring endTag=\"</\"+panel[cur].name+\">\";\n\trTagBeg=tags.find(endTag,s); rTagEnd=rTagBeg+endTag.size();\n\t\n\tstring posstr=tags.substr(lTagEnd+1,nextTagBeg-lTagEnd-1);\n\trep(i,posstr.size())if(posstr[i]==',')posstr[i]=' ';\n\tstringstream poss(posstr);\n\tposs>>panel[cur].x1>>panel[cur].y1>>panel[cur].x2>>panel[cur].y2;\n\t\n\tif(nextTagBeg<rTagBeg)panel[cur].child=parse(nextTagBeg,rTagBeg,z-1);\n\telse panel[cur].child=0;\n\t\n\tint ret=panel[cur].child;\n\tif(rTagEnd<t)ret+=parse(rTagEnd,t,z);\n\t\n\treturn ret+1;\n}\n\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tcin.ignore();\n\t\tgetline(cin,tags);\n\t\tnpanel=0;\n\t\tparse(0,tags.size(),0);\n\t\t\n\t\tsort(panel,panel+npanel);\n\t\t\n\t\trep(i,n)\n\t\t{\n\t\t\tint x,y; cin>>x>>y;\n\t\t\trep(j,npanel)if(panel[j].in(x,y))\n\t\t\t{\n\t\t\t\tcout<<panel[j].name<<\" \"<<panel[j].child<<endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl; END:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(string r,string s[],int lx[],int uy[],int rx[],int dy[],int cn[],int m){\n  int i,j;\n  s[m]=r.substr(r.find('<')+1,r.find('>')-r.find('<')-1);\n  lx[m]=atoi(r.substr(r.find('>')+1,r.find(',')-r.find('>')-1).c_str());\n  uy[m]=atoi(r.substr(r.find(',')+1,r.find(',',r.find(',')+1)-r.find(',')-1).c_str());\n  rx[m]=atoi(r.substr(r.find(',',r.find(',')+1)+1,r.find(',',r.find(',',r.find(',')+1)+1)-r.find(',',r.find(',')+1)-1).c_str());\n  dy[m]=atoi(r.substr(r.find(',',r.find(',',r.find(',')+1)+1)+1,r.find('<',r.find('<')+1)-r.find(',',r.find(',',r.find(',')+1)+1)-1).c_str());\n  cn[m]=0;\n  j=1;\n  for(i=1;r.find(\"</\"+s[m]+\">\")!=r.find('<',i);i=r.find(\"</\"+r.substr(r.find('<',i)+1,r.find('>',r.find('<',i)+1)-r.find('<',i)-1)+\">\")+1){\n    cn[m]++;\n    j+=f(r.substr(r.find('<',i),r.find(\">\",r.find(\"</\"+r.substr(r.find('<',i)+1,r.find('>',r.find('<',i)+1)-r.find('<',i)-1)+\">\"))-r.find('<',i)+1),s,lx,uy,rx,dy,cn,m+j);\n  }\n  return j;\n}\nint main(){\n  int i,j;\n  int c[100],lx[80],uy[80],rx[80],dy[80],cn[80],m,n,x,y;\n  string r,s[80];\n  while(cin>>n&&n){\n    cin>>r;\n    m=f(r,s,lx,uy,rx,dy,cn,0);\n    for(i=0;i<n;i++){\n      cin>>x>>y;\n      for(j=m-1;j>=0;j--){\n\tif(lx[j]<=x&&x<=rx[j]&&uy[j]<=y&&y<=dy[j])\n\t  break;\n      }\n      c[i]=j;\n    }\n    for(i=0;i<n;i++){\n      if(c[i]==-1)\n\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n      else\n\tcout<<s[c[i]]<<\" \"<<cn[c[i]]<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct tag{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<tag> children;\n\n\ttag *getClickedTag(int x,int y){\n\t\tREP(i,children.size()){\n\t\t\ttag *t=children[i].getClickedTag(x,y);\n\t\t\tif(t!=NULL){\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t\tif(x1<=x&&x<=x2&&y1<=y&&y<=y2){\n\t\t\treturn this;\n\t\t}else{\n\t\t\treturn NULL;\n\t\t}\n\t}\n};\n\ntag read(string &s, int &pos){\n\ttag me;\n\t//タグ構造 ::= 開始タグ タグ値 {タグ構造}* 終了タグ\n\t//開始タグ ::= <タグ名>\n\tassert(s[pos]=='<');\n\tpos++;\n\twhile(s[pos]!='>'){\n\t\tme.name.push_back(s[pos]);\n\t\tpos++;\n\t}\n\tassert(s[pos]=='>');\n\tpos++;\n\n\t//タグ値   ::= 整数,整数,整数,整数\n\tREP(i,4){\n\t\tstring num;\n\t\twhile(isdigit(s[pos])){\n\t\t\tnum.push_back(s[pos]);\n\t\t\tpos++;\n\t\t}\n\t\tswitch(i){\n\t\tcase 0:me.x1=toInt(num);break;\n\t\tcase 1:me.y1=toInt(num);break;\n\t\tcase 2:me.x2=toInt(num);break;\n\t\tcase 3:me.y2=toInt(num);break;\n\t\t}\n\t\tassert(s[pos]==','||s[pos]=='<');\n\t\tpos++;\n\t}\n\tpos--;\n\twhile(s[pos+1]!='/'){\n\t\ttag t=read(s,pos);\n\t\tme.children.push_back(t);\n\t}\n\n\t//終了タグ ::= </タグ名>\n\tassert(s[pos]=='<');\n\tpos++;\n\tassert(s[pos]=='/');\n\tpos++;\n\twhile(s[pos]!='>'){\n\t\tpos++;\n\t}\n\tassert(s[pos]=='>');\n\tpos++;\n\n\treturn me;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tint pos=0;\n\t\ttag root=read(s,pos);\n\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttag *t=root.getClickedTag(x,y);\n\t\t\tif(t==NULL){\n\t\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<t->name<<\" \"<<t->children.size()<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n \ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n \nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n \nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n \nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n \nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n \nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n \nbool eof() {\n  return __it == __end;\n}\n \nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n \nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n \nlexstat lstat = lexstat::no_stat;\n \ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n \n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n \n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n \n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n \n  lstat = lexstat::success;\n \n  return ret;\n}\n \nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n \nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n \ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n \nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n \n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n \n  while(i--) unread();\n  return false;\n}\n \n}\nusing namespace parser;\n\n#define DEF_PARSER(ast, property_definitions, root_settings) \\\nstruct ast {  \\\n  property_definitions; \\\n  vector<shared_ptr<ast>> children; \\\n};  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p); \\\nshared_ptr<const ast> parse_ ## ast(Iter begin, Iter end) { \\\n  init_iterator(begin, end);  \\\n  auto p = make_shared<xml>();  \\\n  root_settings; \\\n  return parse_ ## ast(p);  \\\n}\n\n#define PARSE(ast, tar) \\\n  parse_ ## ast(begin(tar), end(tar))\n\n#define PARSER_IMPL(ast, start_cond)  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p) { \\\n  while(!eof()) { \\\n    if (start_cond) {\n#define HEAD(str) look_ahead(str)\n#define CHANCE(cond)  \\\n      return p; \\\n } else if(cond) {\n\n#define END_PARSER_IMPL \\\n  }} \\\n  return p; \\\n}\n\n#define prop(pr) p->pr\n#define cprop(pr) c->pr\n\n#define RECUR(ast, property_settings)  \\\nauto c = make_shared<ast>(); \\\nproperty_settings;  \\\np->children.push_back(c); \\\nparse_ ## ast(p);\n\n#define ast_ref(const_ast) shared_ptr<const const_ast> const& __ast_ref_p\n#define enumerate_children(c)  \\\n  for(auto && c: __ast_ref_p->children)\n\n#define ref_prop(pr) __ast_ref_p->pr\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nDEF_PARSER(xml,\n  string tag;\n  vector<int> nums;\n  ,\n  prop(tag) = \"OUT OF MAIN PANEL\"\n)\n\nPARSER_IMPL(xml,\n  HEAD(\"</\"))\n    lex_f(\"</\" + p->tag + \">\"); CHANCE(\n  HEAD(\"<\"))\n    RECUR(xml,\n      cprop(tag)  = lex<string>(alphabetical, {}, {'<','>'});\n      cprop(tag)  = c->tag.substr(1, c->tag.size()-2);\n      cprop(nums) = lex_stream<int>(integer, {','});\n    )\nEND_PARSER_IMPL\n\n\npair<string, int> dfs(ast_ref(xml), int x, int y) {\n  enumerate_children(c)\n    if(c->nums[0] <= x && c->nums[1] <= y && x <= c->nums[2] && y <= c->nums[3])\n      return dfs(c, x, y);\n\n  return {ref_prop(tag), ref_prop(children.size())};\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string str; cin >> str;\n    auto root = PARSE(xml, str);\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//  ch_cnts[now]++;\n//  for (auto&& e : g[now]) {\n//      ch_cnts[now] += dfs(g, e, ch_cnts);\n//  }\n//  return ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//  int from;\n//  int to;\n//  bool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//  int max_ch_id = 1;\n//  {\n//      int max_ch_num = -1;\n//      for (auto&&e : g[now]) {\n//          if (max_ch_num < ch_cnts[e]) {\n//              max_ch_num = ch_cnts[e];\n//              max_ch_id = e;\n//          }\n//      }\n//  }\n//  for (auto e : g[now]) {\n//      bool heavy = (e == max_ch_id);\n//\n//      hl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//  }\n//  return;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//  vector<int>ch_cnts(ro_tree.size());\n//\n//  dfs(ro_tree, 0, ch_cnts);\n//\n//  vector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//  dfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//  using C = complex< double >;\n//\n//  void DiscreteFourierTransform(vector< C > &F, bool rev)\n//  {\n//      const int N = (int)F.size();\n//      const double PI = (rev ? -1 : 1) * acos(-1);\n//      for (int i = 0, j = 1; j + 1 < N; j++) {\n//          for (int k = N >> 1; k > (i ^= k); k >>= 1);\n//          if (i > j) swap(F[i], F[j]);\n//      }\n//      C w, s, t;\n//      for (int i = 1; i < N; i <<= 1) {\n//          for (int k = 0; k < i; k++) {\n//              w = polar(1.0, PI / i * k);\n//              for (int j = 0; j < N; j += i * 2) {\n//                  s = F[j + k];\n//                  t = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//                      F[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//                  F[j + k] = s + t, F[j + k + i] = s - t;\n//              }\n//          }\n//      }\n//      if (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//  }\n//\n//  vector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//  {\n//      int sz = 1;\n//      while (sz <= A.size() + B.size()) sz <<= 1;\n//      vector< C > F(sz), G(sz);\n//      for (int i = 0; i < A.size(); i++) F[i] = A[i];\n//      for (int i = 0; i < B.size(); i++) G[i] = B[i];\n//      DiscreteFourierTransform(F, false);\n//      DiscreteFourierTransform(G, false);\n//      for (int i = 0; i < sz; i++) F[i] *= G[i];\n//      DiscreteFourierTransform(F, true);\n//      vector< int > X(A.size() + B.size() - 1);\n//      for (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//      return (X);\n//  }\n//};\n\nstruct aa {\n\tstring name;\n\tint l;\n\tint r;\n\tint u;\n\tint d;\n\tvector<shared_ptr<aa>>chs;\n};\n\nint get_num(string st, int&a) {\n\tint num=0;\n\twhile (a != st.size() && isdigit(st[a])) {\n\t\tnum*=10;\n\t\tnum+=st[a]-'0';\n\t\ta++;\n\t}\n\treturn num;\n}\n\nstring get_name(string st, int &a) {\n\tstring name=\"\";\n\twhile (a != st.size() && 'a' <= st[a] && st[a] <= 'z') {\n\t\tname+=st[a];\n\t\ta++;\n\t}\n\treturn name;\n}\n\nstring get_on_name(string st,bool flag, int &a) {\n\tassert(st[a]=='<');\n\ta++;\n\tif (flag) {\n\t\tassert(st[a]=='/');\n\t\ta++;\n\t}\n\tstring name=get_name(st,a);\n\tassert(st[a]=='>');\n\ta++;\n\treturn name;\n}\n\n\n\npair<pair<int, int>, pair<int, int>>get_on_num(string st, int &a) {\n\tint l=get_num(st,a);\n\tassert(st[a]==',');\n\ta++;\n\tint u=get_num(st,a);\n\tassert(st[a]==',');\n\ta++;\n\tint r=get_num(st,a);\n\tassert(st[a]==',');\n\ta++;\n\tint d=get_num(st,a);\n\n\treturn make_pair(make_pair(l,r),make_pair(u,d));\n}\n\nshared_ptr<aa>solve(string st, int &a) {\n\n\taa now;\n\tstring aname=get_on_name(st,false,a);\n\tnow.name=aname;\n\n\n\n\tauto p=get_on_num(st,a);\n\tnow.l=p.first.first;\n\tnow.r=p.first.second;\n\tnow.u=p.second.first;\n\tnow.d=p.second.second;\n\n\twhile (st[a + 1] != '/') {\n\t\tauto naa=solve(st,a);\n\t\tnow.chs.push_back(naa);\n\t}\n\tget_on_name(st,true,a);\n\treturn make_shared<aa>(now);\n}\n\npair<string, int>get_ans(const aa&naa, int x, int y) {\n\n\tif (naa.l <= x&&x <= naa.r&&naa.u <= y&&y <= naa.d) {\n\t\tfor (auto ch : naa.chs) {\n\t\t\tauto p = get_ans(*ch, x, y);\n\t\t\tif (p.first == \"\") {\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\treturn make_pair(naa.name, naa.chs.size());\n\t}\n\telse {\n\t\treturn make_pair(\"\",0);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tint N; cin >> N;\n\t\tif(!N)break;\n\t\tstring st; cin >> st;\n\n\t\tint k = 0;\n\t\tauto top(solve(st, k));\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tauto p = get_ans(*top, x, y);\n\t\t\tif (p.first == \"\") {\n\t\t\t\tcout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tcout << p.first << \" \" << p.second << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint tag[1111][4];\nstring name[1111];\nint ar[1111];\n\nint main() {\n\tint n,t;\n\tstring str;\n\tIL{\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>str;\n\t\tt=0;\n\t\trep(i,sz(str)){\n\t\t\tif(str[i]=='<'&&str[i+1]!='/'){\n\t\t\t\tint j;\n\t\t\t\tname[i]=\"\";\n\t\t\t\trepn0(j,i+1,sz(str)){\n\t\t\t\t\tif(str[j]=='>')break;\n\t\t\t\t\tname[t]+=str[j];\n\t\t\t\t}\n\t\t\t\tint c;\n\t\t\t\trep(k,4){\n\t\t\t\t\t++j;\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(;;++j){\n\t\t\t\t\t\tif(!isdigit(str[j]))break;\n\t\t\t\t\t\tc=c*10+str[j]-'0';\n\t\t\t\t\t}\n\t\t\t\t\ttag[t][k]=c;\n\t\t\t\t}\n\t\t\t\tar[t]=(tag[t][2]-tag[t][0])*(tag[t][3]-tag[t][1]);\n\t\t\t\t++t;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tint top=-1;\n\t\t\trepd(j,t){\n\t\t\t\tif(tag[j][0]<=x&&x<=tag[j][2]&&tag[j][1]<=y&&y<=tag[j][3]){\n\t\t\t\t\ttop=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(top!=-1){\n\t\t\t\tint count=0;\n\t\t\t\trep(j,t){\n\t\t\t\t\tif(tag[top][0]<tag[j][0]&&tag[j][0]<tag[top][2]&&tag[top][1]<tag[j][1]&&tag[j][1]<tag[top][3]){\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\trep0(k,t){\n\t\t\t\t\t\t\tif(ar[top]<=ar[k])continue;\n\t\t\t\t\t\t\tif(tag[k][0]<tag[j][0]&&tag[j][0]<tag[k][2]&&tag[k][1]<tag[j][1]&&tag[j][1]<tag[k][3])break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==t)++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<name[top]<<\" \"<<count<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Node\n{\n    string name;\n    int x1, y1, x2, y2;\n    vector<Node> child_nodes;\n    bool include (int x, int y)\n\t{\n\t    return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n\t}\n};\nNode parse(string s)\n{\n    Node res;\n\n    int k;\n    k = s.find(\">\");\n    res.name = s.substr(1, k - 1);\n    s = s.substr(k + 1);\n    k = s.find(\"<\");\n    sscanf(s.substr(0, k).c_str(), \"%d,%d,%d,%d\", &res.x1, &res.y1, &res.x2, &res.y2);\n    s = s.substr(k);\n    s = s.erase(s.rfind(\"<\"));\n\n    while (!s.empty())\n    {\n\tint i, tag;\n\tfor (i = 1, tag = 1; tag; ++i)\n\t{\n\t    if (s[i] == '<')\n\t    {\n\t\t++i;\n\t\tif (s[i] == '/')\n\t\t    --tag;\n\t\telse\n\t\t    ++tag;\n\t    }\n\t}\n\tfor ( ; s[i] != '>'; ++i)\n\t    ;\n\tres.child_nodes.push_back(parse(s.substr(0, i + 1)));\n\ts = s.substr(i + 1);\n    }\n\n    return res;\n}\nNode find_node(Node n, int x, int y)\n{\n    Node res;\n    res.x1 = -1;\n    if (n.include(x, y))\n    {\n\tres = n;\n\tforeach (it, n.child_nodes)\n\t{\n\t    Node r = find_node(*it, x, y);\n\t    if (r.x1 != -1)\n\t\tres = r;\n\t}\n    }\n    return res;\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n\tstring s;\n\tcin >> s;\n\tNode root = parse(s);\n\twhile (n--)\n\t{\n\t    int x, y;\n\t    cin >> x >> y;\n\t    Node res = find_node(root, x, y);\n\t    if (res.x1 >= 0)\n\t\tcout << res.name << \" \" << res.child_nodes.size() << endl;\n\t    else\n\t\tcout << \"OUT OF MAIN PANEL 1\" << endl;\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nstring str;\nint pos;\n\ntypedef struct _panel{\n  string name;\n  set<_panel> child;\n  int x1,y1,x2,y2;\n  bool operator<(const _panel&r)const{\n    if(x1!=r.x1)return x1<r.x1;\n    if(y1!=r.y1)return y1<r.y1;\n    if(x2!=r.x2)return x2<r.x2;\n    if(y2!=r.y2)return y2<r.y2;\n    if(name!=r.name)return name<r.name;\n    return child<r.child;\n  }\n}panel;\n\n\nstring gettagname(){\n  string ret;\n  ++pos;\n  if(str[pos]=='/')++pos;\n  while(str[pos]!='>'){\n    //cout<<ret<<endl;\n    ret+=str[pos];\n    ++pos;\n  }\n  ++pos;\n  return ret;\n}\n\nint getnum(){\n  while(!isdigit(str[pos]))++pos;\n  int ret=0;\n  while(isdigit(str[pos])){\n    ret=ret*10+str[pos]-'0';\n    ++pos;\n  }\n  return ret;\n}\n\npanel gettagstr(){\n  panel ret;\n  string tagname=gettagname();\n  //cout<<tagname<<endl;\n  int x1=getnum(),\n    y1=getnum(),\n    x2=getnum(),\n    y2=getnum();\n  ret.x1=x1;\n  ret.y1=y1;\n  ret.x2=x2;\n  ret.y2=y2;\n  ret.name=tagname;\n\n  while(str[pos+1]!='/'){\n    panel add=gettagstr();\n    ret.child.insert(add);\n  }\n  gettagname();\n  return ret;\n}\n\npanel pare;\n\nint dfs(int x,int y,const panel& se){\n  FOR(siter,se.child){\n    const panel& tp=*siter;\n    if(tp.x1<=x && x<=tp.x2 && tp.y1<=y && y<=tp.y2){\n      return dfs(x,y,tp);\n    }\n  }\n  cout<<se.name<<\" \";\n  return se.child.size();\n}\n\nmain(){\n  int n;\n  while(cin>>n,n){\n    cin>>str;\n    pos=0;\n    pare=gettagstr();\n    //puts(\"parse con\");\n    //cout<<pare.x1<<\" \"<<pare.y1<<\" \"<<pare.x2<<\" \"<<pare.y2<<endl;\n    \n    while(n--){\n      int x,y;\n      cin>>x>>y;\n      if(pare.x1>x || x>pare.x2 || pare.y1>y || y>pare.y2){\n\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n      }else cout<<dfs(x,y,pare)<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n\ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n\nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n\nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n\nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n\nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n\nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n\nbool eof() {\n  return __it == __end;\n}\n\nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n\nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n\nlexstat lstat = lexstat::no_stat;\n\ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n\n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n\n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n\n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n\n  lstat = lexstat::success;\n\n  return ret;\n}\n\nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n\nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n\ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n\nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n\n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n\n  while(i--) unread();\n  return false;\n}\n\n}\nusing namespace parser;\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct xml {\n  string tag;\n  vector<int> prop;\n  vector<shared_ptr<xml>> children;\n};\n\nshared_ptr<xml> parse(shared_ptr<xml>& p) {\n  while(!eof()) {\n    if(look_ahead(\"</\")) {\n      lex_f(\"</\" + p->tag + \">\");\n      return p;\n    } else if(look_ahead(\"<\")) {\n      auto c = make_shared<xml>();\n      c->tag = lex<string>(alphabetical, {}, {'<','>'});\n      c->tag = c->tag.substr(1, c->tag.size()-2);\n      c->prop = lex_stream<int>(integer, {','});\n      p->children.push_back(c);\n      parse(c);\n    }\n  }\n  return p;\n}\n\nshared_ptr<const xml> parse(Iter begin, Iter end) {\n  init_iterator(begin, end);\n  auto p = make_shared<xml>();\n  p->tag = \"OUT OF MAIN PANEL\";\n  return parse(p);\n}\n\npair<string, int> dfs(shared_ptr<const xml> const& p, int x, int y) {\n  for(auto && c: p->children)\n    if(c->prop[0] <= x && c->prop[1] <= y && x <= c->prop[2] && y <= c->prop[3])\n      return dfs(c, x, y);\n\n  return {p->tag, p->children.size()};\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string xml_str; cin >> xml_str;\n    auto root = parse(xml_str.begin(), xml_str.end());\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n \ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n \nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\nstring tag;\n \nbool inPosition(int x, int y, Data data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n \nint rec(Data now, const Data& panel){\n  /* ふぁぁ？？ */\n  int ret = 0;\n  /*\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  */\n  ret = now.foo.size();\n  return ret;\n}\n \n \npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n   \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n   \n   \n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ\n    flag = false;\n    if(now.foo.size() == 0) break;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n \n  return make_pair( now.name, rec(now, panel));\n}\n \n \nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  }\n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n \n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n \nvoid Check( Cursol& pos, Data& ret)\n{\n  if(pos == tag.end()) return;\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  if(pos == tag.end()) return;\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n    if(pos == tag.end()) return;\n  }\n  getString(++pos);\n  ++pos;\n}\n \nint main(){\n  int n;\n  Cursol crl;\n \n  while(cin >> n, n){\n    Data Main;\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n     \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n     \n \n  }\n   \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n\nusing namespace std;\n\nclass Window{\npublic:\n\t~Window()\n\t{\n\t\tlist<class Window*>::iterator it;\n\t\tfor (it = child.begin(); it != child.end(); it++){\n\t\t\tdelete (*it);\n\t\t}\n\t}\n\t\t\n\tWindow* Click(int x, int y)\n\t{\n\t\tWindow *ret;\n\t\tlist<class Window*>::iterator it;\n\t\t\n\t\tret = this;\n\t\tif (isClick(x, y) == true){\n\t\t\tfor (it = child.begin(); it != child.end(); it++){\n\t\t\t\tif ((*it)->Click(x, y) != NULL) ret = *it;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn (NULL);\n\t\t}\n\t\treturn (ret);\n\t}\t\t\t\t\n\t\n\tbool isClick(int x, int y)\n\t{\n\t\treturn (sx <= x && ex >= x && sy <= y && ey >= y);\n\t}\n\n\tchar name[100];\n\tint sx, sy;\n\tint ex, ey;\n\tlist<class Window*> child;\n};\n\nWindow* input(char tag[])\n{\n\tint i;\n\tWindow *Parent;\n\t\n\tParent = new Window;\n\t\n\twhile (*tag != '<') tag++;\n\ttag++;\n\ti = 0;\n\twhile (*tag != '>'){\n\t\tParent->name[i++] = *tag++;\n\t}\n\tParent->name[i] = '\\0';\n\twhile (!isdigit(*tag)) tag++;\n\tParent->sx = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->sy = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->ex = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->ey = atoi(tag);\n\t\n\twhile (*tag != '\\0'){\n\t\twhile (*tag != '<'){\n\t\t\ttag++;\n\t\t}\n\t\tif (*(tag + 1) == '/'){\n\t\t\treturn (Parent);\n\t\t}\n\t\telse {\n\t\t\tParent->child.push_back(input(tag));\n\t\t\twhile (*tag != '/') tag++;\n\t\t}\n\t}\n\t\n\treturn (Parent);\n}\n\n\t\nint main(void)\n{\n\tWindow *Main;\n\tchar tag[1001];\n\tint n;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%s\", tag);\n\t\tMain = input(tag);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tWindow* output;\n\t\t\t\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\toutput = Main->Click(x, y);\n\t\t\tif (output == NULL){\n\t\t\t\tprintf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%s %d\\n\", output->name, output->child.size());\n\t\t\t}\n\t\t}\n\t\t\n\t\tdelete Main;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<string,int> P;\ntypedef pair<int,int> Point;\ntypedef pair<Point,Point> PP;\nmap<string,int> M,MM;\nmap<string,PP> Disp;\n\nvector<string> V;\n\nbool isTouch(string s, int x, int y){\n  Point p1 = Disp[s].first, p2 = Disp[s].second;\n\n  return (p1.first <= x && x <= p2.first && p1.second <= y && y <= p2.second);\n}\n\nP find(int x, int y){\n  P ans = P(\"OUT OF MAIN PANEL\",10000);\n  M[\"OUT OF MAIN PANEL\"] = 100000;\n\n\n  for(int i = 0; i < V.size(); i++)\n    if(isTouch(V[i],x,y) && M[ans.first] > M[V[i]]) ans = P(V[i],MM[V[i]]);\n\n\n  if(ans.first == \"OUT OF MAIN PANEL\") ans.second = 1;\n  return ans;\n}\n\nPP getPoint(string s){\n  s += \",\";\n  \n  int data[4];\n  int num = 0;\n  int sum = 0;\n  int pos = 0;\n\n  while(num < 4){\n    if(s[pos] == ','){\n      data[num++] = sum;\n      sum = 0;\n    }else{\n      sum *= 10;\n      sum += s[pos]-'0';\n    }\n    pos++;\n  }\n  PP pp;\n  \n  pp.first = Point(data[0],data[1]);\n  pp.second = Point(data[2],data[3]);\n\n  return pp;\n}\n\nstring check(int pos,string s){\n \n  string out = \"\";\n\n  for(int i = pos; i < s.length(); i++){\n    out += s[i];\n    if(s[i] == '>') break;\n  }\n\n  return out;\n}\n\n\nvoid solve(string s){\n  int pos = 0;\n  string tag = \"</\", name = \"\", between = \"\", tail = \"\";\n  int num = 0;\n  \n  while(1){\n    tag += s[++pos];\n    if(s[pos] != '<' && s[pos] != '>') name += s[pos];\n    if(s[pos] == '>') break;\n  }\n\n  string point = \"\";\n  \n  while(s[++pos] != '<') point+=s[pos];\n\n  PP p = Disp[name] = getPoint(point);\n\n  V.push_back(name);\n\n  string child = \"\";\n  string endofchild = \"/<\";\n  int numofchild = 0;\n\n  while(pos < s.length()){\n    if(s[pos] == '<'){\n\n      if(child == \"\" && s[pos+1] != '/'){\n\tchild = check(pos,s);\n\tendofchild = \"</\";\n\tfor(int i = 1; i < child.length(); i++) endofchild += child[i];\n      }\n\n      if(check(pos,s) == tag){\n\twhile(s[pos] != '>') pos++;\n\tbreak;\n      }\n\n      if(check(pos,s) == endofchild){\n\tnumofchild++;\n\tchild = \"\";\n      }\n      num++;\n    }\n    between += s[pos++];\n  }\n  M[name] = num/2;\n  MM[name] = numofchild;\n\n\n  for(int i = pos+1; i < s.length(); i++)\n      tail += s[i];\n  if(between.length()) solve(between);\n  if(tail.length()) solve(tail);\n}\n\nvoid init(){\n  M.clear();\n  MM.clear();\n  Disp.clear();\n  V.clear();\n}\n\nint main(){\n\n  string s;\n  int n;\n  while(cin >> n && n){\n \n    init();\n\n    cin.ignore();\n\n    getline(cin,s);\n    solve(s);\n\n    for(int i = 0; i < n; i++){\n      int x,y;\n      cin >> x >> y;\n      P p =  find(x,y);\n      cout << p.first << \" \" << p.second<< endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\nusing namespace std;\n\nint stoi(string s){\n  stringstream ss;\n  ss << s;\n  int res;\n  ss >> res;\n  return res;\n}\n\nint main(){\n  int n,x,y,t,z[1000][5];\n  string s,name[1000];\n\n  while(cin >> n, n){\n    cin >> s;\n    t = 0;\n    for(int i=1;i<(int)s.size();i++){\n\n      if(s[i] != '/'){\n\tstring tmp = \"\";\n\twhile(i<(int)s.size() && s[i] != '>'){\n\t  tmp += s[i];\n\t  i++;\n\t}\n\tname[t] = tmp;\n\tfor(int j=0;j<4;j++){\n\t  i++;\n\t  tmp = \"\";\n\t  while(s[i] != ',' && s[i] != '<'){\n\t    tmp += s[i];\n\t    i++;\n\t  }\n\t  z[t][j] = stoi(tmp);\n\t}\n\tt++;\n      }else{\n\twhile(i<(int)s.size() && s[i]!='<')i++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n\n      int m = -1;\n      for(int j=0;j<t;j++){\n\tif(z[j][0]<=x && x<=z[j][2] && z[j][1]<=y && y<=z[j][3]){\n\t  if(m<0 || (z[m][0]<z[j][0] && z[j][2]<z[m][2] && \n\t\t     z[m][1]<z[j][1] && z[j][3]<z[m][3]) )m = j;\n\t} \n      }\n      \n      if(m<0)cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else{\n\tint num = 0;\n\tfor(int j=0;j<t;j++){\n\t  if(z[m][0]<z[j][0] && z[j][2]<z[m][2] && \n\t     z[m][1]<z[j][1] && z[j][3]<z[m][3]){\n\t    bool f = true;\n\t    for(int k=0;k<t;k++){\n\t      if(z[m][0]<z[k][0] && z[k][2]<z[m][2] && \n\t\t z[m][1]<z[k][1] && z[k][3]<z[m][3]){\n\t\tif(z[k][0]<z[j][0] && z[j][2]<z[k][2] && \n\t\t   z[k][1]<z[j][1] && z[j][3]<z[k][3]){\n\t\t  f = false;\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\t    if(f)num++;\n\t  }\n\t}\n\t\n\tcout << name[m] << \" \" << num << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\n#define limit(A,B,C) (A<= B && B <= C) \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\n\nclass AOJ1031{\nprivate:\n  string s;\n  int n;\n  map<string,int> c_num;\n  map<string,PP> coor;\n  vector<string> name_list;\npublic:\n  AOJ1031(int n,string s):n(n),s(s){}\n  ~AOJ1031(){}\n\n  void getChildNumber(){\n   \n    int st,cnt=0;\n     \n    rep(i,name_list.size()){\n      string name = name_list[i];\n     \n      P A,B;\n      //A = coor[name].F,B = coor[name].S;\n      int cnt=0;\n      rep(j,name_list.size()){\n\tstring rename = name_list[j];\n\tA = coor[rename].F,B = coor[rename].S;\n\tif(name == name_list[j])continue;\n\tif(limit(coor[name].F.F,A.F,coor[name].S.F) && limit(coor[name].F.S,A.S,coor[name].S.S) && limit(coor[name].F.F,B.F,coor[name].S.F) && limit(coor[name].F.S,B.S,coor[name].S.S)){\n\t  cnt++;\n\t}\n      }\n      c_num[name] = cnt;\n      //\n    }\n\n\n    rep(i,name_list.size()){\n      string name = name_list[i];\n      \n      P A,B;\n     \n      int cnt=0;\n      rep(j,name_list.size()){\n\tstring rename = name_list[j];\n\tA = coor[rename].F,B = coor[rename].S;\n\tif(name == name_list[j])continue;\n\tif(limit(coor[name].F.F,A.F,coor[name].S.F) && limit(coor[name].F.S,A.S,coor[name].S.S) && limit(coor[name].F.F,B.F,coor[name].S.F) && limit(coor[name].F.S,B.S,coor[name].S.S)){\n\t  //cout << \"IN! c_num[\" << rename << \"] = \" << c_num[rename] << endl;\n\t  if(c_num[rename] == 0)cnt++;\n\t  else cnt -= c_num[rename]-1;\n\t}\n      }\n      c_num[name] = cnt;\n      //cout << \"c_num[\" << name << \"] = \"<< c_num[name] << endl;\n    }\n\n  \n\n\n  }\n\n  PP getPP(string s){\n    stringstream ss;\n    ss << s;\n    int Pm[4];\n    ss >> Pm[0] >> Pm[1] >> Pm[2] >> Pm[3];\n    return PP(P(Pm[0],Pm[1]),P(Pm[2],Pm[3]));\n  }\n\n  void getCoordinate(){\n\n    bool OK = false;\n    int st;\n    string store;\n    REP(i,0,s.length()){\n      if(s[i] == ','){\n\ts[i] = ' ';\n\tcontinue;\n      }\n\n      if(s[i] == '<' && s[i+1] != '/' && !OK)st = i,OK=true;\n      else if(s[i] == '>' && OK){\n\tstore = s.substr(st+1,i-1-st);\n\tcoor[store] = PP(P(-1,-1),P(-1,-1));\n\tst = i+1;\t\n      }\n      else if(s[i] == '<'){\n\tif(coor[store] != PP(P(-1,-1),P(-1,-1)))continue;\n\tcoor[store] = getPP(s.substr(st,i-st)); \n\tOK = false;\n\tst = i;\n\tif(s[i+1] != '/')OK = true;\n      }\n    }\n  }\n\n  void getNameList(){\n    int st = 0;\n    bool OK = false;\n    map<string,bool> index;\n    rep(i,s.length()){\n      if(s[i] == '<' && s[i+1] != '/' && !OK)st = i+1,OK = true;\n      else if(s[i] == '>' && OK){\n\tname_list.pb(s.substr(st,i-st));\n\tOK = false;\n      }\n\n\n    }\n  }\n\n  void run(){\n   \n    getCoordinate();\n    getNameList();\n    getChildNumber();\n\n    rep(i,n){\n      int x,y;\n      cin >> x >> y;\n      bool found = false;\n      string found_name;\n      P LIMA = P(0,0),LIMB = P(INT_MAX,INT_MAX); \n      int child = INT_MAX;\n      rep(i,name_list.size()){\n\tstring name = name_list[i];\n\n\tif(coor[name].F.F <= x && x <= coor[name].S.F && coor[name].F.S <= y && y <= coor[name].S.S && (limit(LIMA.F,coor[name].F.F,LIMB.F) && limit(LIMA.S,coor[name].F.S,LIMB.S) && limit(LIMA.F,coor[name].S.F,LIMB.F) && limit(LIMA.S,coor[name].S.S,LIMB.S)) ){\n\t  found_name = name;\n\t  found = true;\n\t  child = c_num[name];\n\t  LIMA = coor[name].F,LIMB = coor[name].S;\n\t}\n      }\n      if(!found)cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else cout << found_name << \" \" << c_num[found_name] << endl;\n\n    }\n  }\n\n\n};\n\nint main(){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0)break;\n    string s;\n    cin >> s;\n    AOJ1031 ans = AOJ1031(n,s);\n    ans.run();\n\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tvoid set(int arg_tag_index,int arg_x_1,int arg_y_1,int arg_x_2,int arg_y_2,int arg_depth){\n\t\ttag_index = arg_tag_index;\n\t\tx_1 = arg_x_1;\n\t\ty_1 = arg_y_1;\n\t\tx_2 = arg_x_2;\n\t\ty_2 = arg_y_2;\n\t\tdepth = arg_depth;\n\t}\n\tint tag_index,x_1,y_1,x_2,y_2,depth;\n\tvector<int> children;\n};\n\nint N;\nchar buf[1001];\nchar tagName[500][501];\nInfo info[500];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 500; i++){\n\t\tinfo[i].children.clear();\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tchar work[501];\n\tint tag_index = 0,work_index,depth = 0;\n\tint tmp,count;\n\n\tstack<int> PARENT;\n\n\tfor(int index = 0;buf[index] != '\\0';){\n\n\t\tif(buf[index] == '<'){\n\t\t\tif(buf[index+1] != '/'){\n\t\t\t\twork_index = 0;\n\t\t\t\tfor(++index; buf[index] != '>'; index++){\n\t\t\t\t\twork[work_index] = buf[index];\n\t\t\t\t\twork[work_index+1] = '\\0';\n\t\t\t\t\twork_index++;\n\t\t\t\t}\n\t\t\t\tstrcpy(tagName[tag_index],work);\n\t\t\t\tinfo[tag_index].depth = depth;\n\t\t\t\tinfo[tag_index].tag_index = tag_index;\n\n\t\t\t\tif(!PARENT.empty()){\n\t\t\t\t\tinfo[PARENT.top()].children.push_back(tag_index);\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < 4){\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(;buf[index] != ',' && buf[index] != '<';index++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[index]-'0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch(count){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinfo[tag_index].x_1 = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tinfo[tag_index].y_1 = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinfo[tag_index].x_2 = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tinfo[tag_index].y_2 = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t\tif(count < 4)index++;\n\t\t\t\t}\n\n\t\t\t\tPARENT.push(tag_index);\n\t\t\t\ttag_index++;\n\t\t\t\tdepth++;\n\n\t\t\t}else{\n\t\t\t\tindex++;\n\t\t\t\tfor(;buf[index] != '>';index++);\n\t\t\t\tindex++;\n\t\t\t\tdepth--;\n\t\t\t\tPARENT.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tint x,y;\n\tint max_depth,touch_index;\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&x,&y);\n\n\t\tmax_depth = -1;\n\t\tfor(int i = 0; i < tag_index; i++){\n\t\t\tif(info[i].x_1 <= x && info[i].x_2 >= x && info[i].y_1 <= y && info[i].y_2 >= y){\n\t\t\t\tif(max_depth < info[i].depth){\n\t\t\t\t\tmax_depth = info[i].depth;\n\t\t\t\t\ttouch_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max_depth == -1){\n\t\t\tprintf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%s %lld\\n\",tagName[info[touch_index].tag_index],info[touch_index].children.size());\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nstring tag;\nsize_t cur;\n\nmap<int, string> tag_name;\nvector<int> ch[200];\n\nint x1[200];\nint y1[200];\nint x2[200];\nint y2[200];\n\nint res;\n\nstring get_name(){\n\tstring res;\n\twhile(tag[cur] != '>'){\n\t\tres.push_back(tag[cur++]);\n\t}\n\treturn res;\n}\n\nint get_num(){\n\tint res = 0;\n\twhile(isdigit(tag[cur])){\n\t\tres = res * 10 + tag[cur++] - '0';\n\t}\n\treturn 0;\n}\n\nvoid get_size(int id){\n\tx1[id] = get_num();\n\tassert(tag[cur++] == ',');\n\ty1[id] = get_num();\n\tassert(tag[cur++] == ',');\n\tx2[id] = get_num();\n\tassert(tag[cur++] == ',');\n\ty2[id] = get_num();\n}\n\nvoid tag_con(int &id){\n\tint num = id;\n\tassert(tag[cur++] == '<');\n\ttag_name[id] = get_name();\n\tassert(tag[cur++] == '>');\n\tget_size(id);\n\n\twhile(true){\n\t\tassert(tag[cur] == '<');\n\t\tchar c = tag[cur+1];\n\t\tif(c == '/') break;\n\t\tch[num].push_back(++id);\n\t\ttag_con(id);\n\t}\n\twhile(tag[cur] != '>') cur++;\n\tcur++;\n}\n\nvoid get_tag(int x, int y, int id){\n\tif(x1[id] <= x && x <= x2[id] && y1[id] <= y && y <= y2[id]){\n\t\tres = id;\n\t}\n\tfor(int i = 0; i < (int)ch[id].size(); i++){\n\t\tget_tag(x, y, ch[id][i]);\n\t}\n}\n\nint main(){\n\tint n, x, y;\n\tint cnt = 0;\n\twhile(cin >> n && n){\n\t\ttag_name.clear();\n\t\ttag_name[120] = \"OUT OF MAIN PANEL\";\n\t\tch[120].push_back(120);\n\t\trep(i, 200) ch[i].clear();\n\t\tcur = 0;\n\t\tcnt = 0;\n\t\tgetline(cin, tag);\n\t\ttag_con(cnt);\n\t\tcout << cnt << endl;\n\t\trep(i, n){\n\t\t\tres = 120;\n\t\t\tcin >> x >> y;\n\t\t\tget_tag(x, y, 0);\n\t\t\tcout << tag_name[res] << \" \"<< ch[res].size() << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint tag[100][4];\nstring name[100];\nint ar[100];\n\nint main() {\n\tint n,t;\n\tstring str;\n\tIL{\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>str;\n\t\tt=0;\n\t\trep(i,sz(str)){\n\t\t\tif(str[i]=='<'&&str[i+1]!='/'){\n\t\t\t\tint j;\n\t\t\t\tname[i]=\"\";\n\t\t\t\trepn0(j,i+1,sz(str)){\n\t\t\t\t\tif(str[j]=='>')break;\n\t\t\t\t\tname[t]+=str[j];\n\t\t\t\t}\n\t\t\t\tint c;\n\t\t\t\trep(k,4){\n\t\t\t\t\t++j;\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(;;++j){\n\t\t\t\t\t\tif(!isdigit(str[j]))break;\n\t\t\t\t\t\tc=c*10+str[j]-'0';\n\t\t\t\t\t}\n\t\t\t\t\ttag[t][k]=c;\n\t\t\t\t}\n\t\t\t\tar[t]=(tag[t][2]-tag[t][0])*(tag[t][3]-tag[t][1]);\n\t\t\t\t++t;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tint top=-1;\n\t\t\tint area=INF;\n\t\t\trep(j,t){\n\t\t\t\tif(tag[j][0]<=x&&x<=tag[j][2]&&tag[j][1]<=y&&y<=tag[j][3]){\n\t\t\t\t\tif((tag[j][2]-tag[j][0])*(tag[j][3]-tag[j][1])<area){\n\t\t\t\t\t\tarea=ar[j];\n\t\t\t\t\t\ttop=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(top!=-1){\n\t\t\t\tint count=0;\n\t\t\t\trep(j,t){\n\t\t\t\t\tif(tag[top][0]<tag[j][0]&&tag[j][0]<tag[top][2]&&tag[top][1]<tag[j][1]&&tag[j][1]<tag[top][3]){\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\trep0(k,t){\n\t\t\t\t\t\t\tif(ar[top]<=ar[k])continue;\n\t\t\t\t\t\t\tif(tag[k][0]<tag[j][0]&&tag[j][0]<tag[k][2]&&tag[k][1]<tag[j][1]&&tag[j][1]<tag[k][3])break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==t)++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<name[top]<<\" \"<<count<<endl;\n\t\t\t}else{\n\t\t\t\tint count=0;\n\t\t\t\trep(j,t){\n\t\t\t\t\tif(-1<tag[j][0]&&tag[j][0]<10001&&-1<tag[j][1]&&tag[j][1]<10001){\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\trep0(k,t){\n\t\t\t\t\t\t\tif(tag[k][0]<tag[j][0]&&tag[j][0]<tag[k][2]&&tag[k][1]<tag[j][1]&&tag[j][1]<tag[k][3])break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==t)++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<\"OUT OF MAIN PANEL \"<<count<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//02\n#include<iostream>\n#include<string>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef  int ia[1000];\n\nia lx,ty,rx,by,d,c;\nstring tn[1000];\nint p;\nchar s[1001];\nchar *sp;\n\nint exp(int dp){\n  if(*sp!='<'||sp[1]=='/')return 0;\n  char t[1000];\n  int cp=p;\n  p++;\n  d[cp]=dp;\n  sscanf(sp,\"<%[^>]>%d,%d,%d,%d\",t,lx+cp,ty+cp,rx+cp,by+cp);\n  sp++;\n  while(*sp!='<'){\n    sp++;\n  }\n  tn[cp]=t;\n  int nc;\n  for(nc=0;exp(dp+1);nc++);\n  c[cp]=nc;\n  int nr;\n  sscanf(sp,\"</%*[^>]>%n\",&nr);\n  sp+=nr;\n  return 1;\n}\n\n  \n\nint main(){\n  for(int n;cin>>n,n;){\n    cin.ignore().getline(s,1001);\n    lx[0]=ty[0]=-1;\n    rx[0]=by[0]=10001;\n    d[0]=0;\n    c[0]=1;\n    tn[0]=\"OUT OF MAIN PANEL\";\n    p=1;\n    sp=s;\n    exp(1);\n    while(n--){\n      int md=-1;\n      int id;\n      int x,y;\n      cin>>x>>y;\n      for(int i=0;i<p;i++){\n\tif(lx[i]<=x&&x<=rx[i]&&ty[i]<=y&&y<=by[i]&&md<d[i]){\n\t  md=d[i];\n\t  id=i;\n\t}\n      }\n      cout<<tn[id]<<' '<<c[id]<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Panel {\n    string name;\n    int x1, y1, x2, y2;\n    vector<Panel> child;\n    \n    Panel(){}    \n    Panel(string name, int x1, int y1, int x2, int y2) :\n        name(name), x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstring s;\nint idx;\n\nstring get_name()\n{\n    string name;\n    ++idx;\n    while (s[idx] != '>') {\n        name += s[idx];\n        ++idx;\n    }\n    ++idx;\n    return name;\n}\n\nint s2i(string &str)\n{\n    stringstream ss(str);\n    int num;\n    ss >> num;\n    return num;\n}\n\nint get_val()\n{\n    string val;\n    while (isdigit(s[idx])) {\n        val += s[idx];\n        ++idx;\n    }\n    return s2i(val);\n}\n\nvoid parse(Panel &p)\n{\n    while (s[idx] == '<' && s[idx+1] != '/') {\n        string name = get_name();\n        int x1 = get_val(); ++idx;\n        int y1 = get_val(); ++idx;\n        int x2 = get_val(); ++idx;\n        int y2 = get_val();\n        Panel panel(name, x1, y1, x2, y2);\n        parse(panel);\n        p.child.push_back(panel);\n        while (s[idx] != '>') {\n            idx++;\n        }\n        idx++;\n    }    \n}\n\nbool get_panel(int x, int y, const Panel &p)\n{\n    for (int i = 0; i < (int)p.child.size(); i++) {\n        Panel np = p.child[i];\n        if (np.x1 <= x && x <= np.x2 && np.y1 <= y && y <= np.y2) {\n            if (!get_panel(x, y, np)) {\n                cout << np.name << \" \" << np.child.size() << endl;\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int n, x, y;\n    while (cin >> n >> s, n) {\n        Panel p;\n        p.name = \"#\"; p.x1 = p.y1 = -1; p.x2 = p.y2 = 10001;\n        idx = 0;\n        parse(p);\n        for (int i = 0; i < n; i++) {\n            cin >> x >> y;\n            if (!get_panel(x, y, p)) {\n                cout << \"OUT OF MAIN PANEL 1\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<string, int> P;\nP solve(string s, int x, int y) {\n//  cout << s << endl;\n  string name;\n  REP(i,s.size()) {\n    if (s[i]=='>') {\n      name = s.substr(1,i-1);\n      break;\n    }\n  }\n  int x1,x2,y1,y2;\n//  cout << name << endl;\n  string tmp = s.substr(name.size()+2);\n  sscanf(tmp.c_str(), \"%d,%d,%d,%d\", &x1,&y1,&x2,&y2);\n//  cout << x1 << y1 << y1 << y2 << endl;\n  if (!(x1<=x&&x<=x2&&y1<=y&&y<=y2))\n    return P(\"OUT OF MAIN PANEL\", 1);\n  \n  int aa = 0;\n  int num = 0;\n  int pos;\n  REP(i,tmp.size()-1) {\n    if (tmp.substr(i,2) == \"</\") {\n      aa--;\n    } else if (tmp[i] == '<') {\n      aa++;\n      if (aa==1)\n        pos = i;\n    }\n    \n    if (tmp[i] == '>'&&aa==0) {\n      P p = solve(tmp.substr(pos, i-pos+1), x,y);\n      if (p.first != \"OUT OF MAIN PANEL\")\n        return p;\n      num++;\n    }\n  }\n  return P(name, num);\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    string s;\n    cin >> s;\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      P a = solve(s,x,y);\n      cout << a.first << \" \" << a.second << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<string, int> P;\n\ntypedef struct node {\n  vector<node> ch;\n  string name;\n  int ty, tx, by, bx;\n  node() { }\n  node(string nn, int tty, int ttx, int bby, int bbx) { name = nn; ty = tty; tx = ttx; by = bby; bx = bbx; }\n} node;\n\nvoid add(node &root, string name, int ty, int tx, int by, int bx){\n  bool flg = false;\n  REP(i, root.ch.size()){\n    node c = root.ch[i];\n    if(c.ty <= ty && c.tx <= tx && c.by >= by && c.bx >= bx){ add(root.ch[i], name, ty, tx, by, bx); return; };\n  }\n  root.ch.push_back(node(name, ty, tx, by, bx));\n}\n\n//void disp(node &r, string b){\n//  cout <<b <<r.name <<\", \" <<r.ch.size() <<endl;\n//  REP(i, r.ch.size()) disp(r.ch[i], b + \"  \");\n//}\n\nP touch(node &root, int y, int x, bool f, string s){\n  P ret = P(\"\", 0);\n  if(!f){\n    REP(i, root.ch.size()){\n      node c = root.ch[i];\n      if(c.ty <= y && c.tx <= x && c.by >= y && c.bx >= x) return touch(root.ch[i], y, x, f, s);\n    }\n  }\n  if(!f) ret.first = root.name;\n  if(f) ret.second += 1;\n  REP(i, root.ch.size()){\n    P r = touch(root.ch[i], y, x, true, s);\n    ret.second += r.second;\n  }\n  return ret;\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    string S; cin >>S;\n    node root = node(\"OUT OF MAIN PANEL\", -1, -1, 10010, 10010);\n    FOR(i, 1, S.length()){\n      stringstream ss, sss;\n      while(i < S.length() && S[i] != '<') ss << S[i++];\n      if(ss.str()[0] == '/') continue;\n      int n = 0;\n      string s = ss.str(); ss.str(\"\");\n      while(s[n] != '>') ss << s[n++];\n      s = s.substr(n + 1) + \",\";\n      int nums[4] = {0}, num = 0; n = 0;\n      REP(j, s.length()){\n        if(s[j] == ','){\n          nums[n++] = num;\n          num = 0;\n        } else{\n          num *= 10;\n          num += s[j] - '0';\n        }\n      }\n      add(root, ss.str(), nums[1], nums[0], nums[3], nums[2]);\n    }\n    //disp(root, \"\");\n    REP(n, N){\n      int x, y; cin >>x >>y;\n      P ret = touch(root, y, x, false, \"\");\n      if(ret.first == \"OUT OF MAIN PANEL\") cout <<ret.first <<\" \" <<1 <<endl;\n      else cout <<ret.first <<\" \" <<ret.second <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n  \n  /*\n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ*/\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n*/\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n  Data Main;\n  Cursol crl;\n\n  while(cin >> n, n){\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Point{\npublic:\n  string name;  \n  int l,r,u,d,s,ss;\n};\n\nint main(){\n  while(1){\n  int i,j,n,x[100],y[100],c,s;\n  Point p[1000];\n  string str;\n    cin >> n;\n    if(n == 0) break;\n    cin >> str;\n    for(i=0;i<n;i++) cin >> x[i] >> y[i];\n    \n    c = 0;\n    s = 0;\n    \n    for(i=0;i<str.size()-1;i++){\n      if(str[i] == '<' && str[i+1] != '/'){\n\ti++;\n\tfor(;str[i] != '>';i++) p[c].name += str[i];\n\t\n\ti++;\n\tp[c].l = p[c].r = p[c].u = p[c].d = 0;\n\t\n\tfor(;str[i] != ',';i++){\n\t  p[c].l *= 10;\n\t  p[c].l += str[i] - '0';\n\t}\n\ti++;\n\tfor(;str[i] != ',';i++){\n\t  p[c].u *= 10;\n\t  p[c].u += str[i] - '0';\n\t}\n\ti++;\n\tfor(;str[i] != ',';i++){\n\t  p[c].r *= 10;\n\t  p[c].r += str[i] - '0';\n\t}\n\ti++;\n\tfor(;str[i] != '<';i++){\n\t  p[c].d *= 10;\n\t  p[c].d += str[i] - '0';\n\t}\n\tp[c].s = s;\n\tc++;\n\ts++;\n\ti--;\n      }\n      else if(str[i] == '<' && str[i+1] == '/') s--;\n    }\n    \n    for(i=0;i<c;i++){\n      p[i].ss = 0;\n      for(j=i+1;j<c;j++){\n\tif(p[i].s >= p[j].s) break;\n      else if(p[i].s + 1 == p[j].s) p[i].ss++;\n      }\n    }\n    \n    for(i=0;i<n;i++){\n      Point u,v;\n      bool f = false;\n      for(j=0;j<c;j++){\n\tif(p[j].l <= x[i] && x[i] <= p[j].r && p[j].u <= y[i] && y[i] <= p[j].d){\n\t  if(!f){\n\t    f = true;\n\t    u = p[j];\n\t  }\n\t  else{\n\t    v = p[j];\n\t    if(u.s < v.s) u = v;\n\t  }\n\t}\n      }\n      if(f) cout << u.name << \" \" << u.ss << endl;\n      else cout << \"OUT OF MAIN PANEL 1\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nint f(int dep = 0){\n\t//if( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tss >> w[0] >> w[1] >> w[2] >> w[3];\n\n\t\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\tf(dep+1);\n\t\t}\n\t//}\n\tV.push_back(w);\n\tname.push_back(s);\n\t\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\t\n\twhile(ln[p] != '>')p++;\n\tp++;\n\t\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tint fst = 0;\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\tidx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tvector<int> &vv = V[idx];\n\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] ){\n\t\t\t\t\tif( vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << name[idx] << \" \" << c << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nclass Panel{\npublic:\n  string name;\n  int x1,x2,y1,y2;\n  vector<Panel> v;\n  Panel(string nm, int a, int b, int c, int d){\n    name = nm;\n    x1 = a; y1 = b;\n    x2 = c; y2 = d;\n  }\n  bool check(int x, int y){\n    bool ret = false;\n    REP(i, v.size()){\n      ret |= v[i].check(x,y);\n    }\n    if(ret) return true;\n    if(x >= x1 && y >= y1 && x <= x2 && y <= y2){\n      cout << name << \" \" << v.size() << endl;\n      return true;\n    }\n    return false;\n  }\n};\n\nPanel create(const string &str, int &pos){\n  //printf(\"create: str = %s\\n\",str.c_str());\n  int posS = 1;\n  int posE = 1;\n  while(str[posE] != '>') posE++;\n  string name = str.substr(posS, posE - posS);\n  int x1,x2,y1,y2;\n  sscanf(str.c_str() + posE + 1, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2);\n  Panel ret(name, x1, y1, x2, y2);\n  while(true){\n    posS = posE;\n    while(str[posS] != '<') posS++; posS++;\n    if(str[posS] == '/') posS++;\n    posE = posS;\n    while(str[posE] != '>') posE++;\n    string name2 = str.substr(posS, posE - posS);\n    //printf(\"name = %s, name2 = %s\\n\",name.c_str(), name2.c_str());\n    if(name == name2){\n      pos = posE + 1;\n      //printf(\"end (name = %s): %s\\n\",name.c_str(),str.c_str()+pos);\n      return ret;\n    }else{\n      ret.v.push_back(create(str.substr(posS-1),posE));\n      posE += posS - 1;\n      //printf(\"next (name = %s): %s\\n\",name.c_str(),str.c_str()+posE);\n    }\n  }\n}\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    string str; int tmp;\n    cin>>str;\n    Panel p = create(str, tmp);\n    while(n --> 0){\n      int x,y;\n      cin>>x>>y;\n      if(!p.check(x,y))\n        cout << \"OUT OF MAIN PANEL 1\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct panel {\n  char name[1001];\n  int x1, y1;\n  int x2, y2;\n  vector<panel> child;\n};\n\npanel app;\n\nvoid parse(panel &p, char tag[])\n{\n  while(1){\n    char tmp[1001];\n    sscanf(tag, \"<%[^>]>%s\", tmp, tag);\n    char aaa[1002] = \"/\";\n    strcat(aaa, p.name);\n    if(strcmp(aaa, tmp) == 0) return;\n    panel c;\n    char next[1001];\n    strcpy(c.name, tmp);\n    sscanf(tag, \"%d,%d,%d,%d%s\", &c.x1, &c.y1, &c.x2, &c.y2, next);\n    //cout << c.name << \" \" << next << endl;\n    parse(c, next);\n    strcpy(tag, next);\n    p.child.push_back(c);\n  }\n}\n\nbool inPanel(panel &p, int x, int y)\n{\n  if(p.x1 <= x && x <= p.x2 && p.y1 <= y && y <= p.y2){\n    for(int i = 0; i < p.child.size(); i++){\n      if(inPanel(p.child[i], x, y)) return true;\n    }\n    cout << p.name << \" \" << p.child.size() << endl;\n    return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n, n){\n    char tag[1001];\n    scanf(\"%s\", tag);\n    char next[1001];\n    sscanf(tag, \"<%[^>]>%d,%d,%d,%d%s\", app.name, &app.x1, &app.y1, &app.x2, &app.y2, next);\n    //cout << app.name << \" \" << next << endl;\n    parse(app, next);\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      if(!inPanel(app, x, y)) cout << \"OUT OF MAIN PANEL 1\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n \ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n \nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n \nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n \nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n \nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n \nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n \nbool eof() {\n  return __it == __end;\n}\n \nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n \nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n \nlexstat lstat = lexstat::no_stat;\n \ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n \n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n \n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n \n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n \n  lstat = lexstat::success;\n \n  return ret;\n}\n \nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n \nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n \ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n \nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n \n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n \n  while(i--) unread();\n  return false;\n}\n \n}\nusing namespace parser;\n\n#define DEF_PARSER(ast, property_definitions, root_settings) \\\nstruct ast {  \\\n  property_definitions; \\\n  vector<shared_ptr<ast>> children; \\\n};  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p); \\\nshared_ptr<const ast> parse_ ## ast(Iter begin, Iter end) { \\\n  init_iterator(begin, end);  \\\n  auto p = make_shared<xml>();  \\\n  root_settings; \\\n  return parse_ ## ast(p);  \\\n}\n\n#define PARSE(ast, tar) \\\n  parse_ ## ast(begin(tar), end(tar))\n\n#define PARSER_IMPL(ast, start_cond)  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p) { \\\n  while(!eof()) { \\\n    if (start_cond) {\n#define HEAD(str) look_ahead(str)\n#define TERMINATE return p;\n#define CHANCE(cond)  \\\n } else if(cond) {\n\n#define END_PARSER_IMPL \\\n  }} \\\n  return p; \\\n}\n\n#define prop(pr) p->pr\n#define cprop(pr) c->pr\n\n#define RECUR(ast, property_settings)  \\\nauto c = make_shared<ast>(); \\\nproperty_settings;  \\\np->children.push_back(c); \\\nparse_ ## ast(c); continue;\n\n#define ast_ref(const_ast) shared_ptr<const const_ast> const& __ast_ref_p\n#define enumerate_children(c)  \\\n  for(auto && c: __ast_ref_p->children)\n\n#define ref_prop(pr) __ast_ref_p->pr\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nDEF_PARSER(xml,\n  string tag;\n  vector<int> nums;\n  ,\n  prop(tag) = \"OUT OF MAIN PANEL\"\n)\n\nPARSER_IMPL(xml,\n  HEAD(\"</\"))\n    lex_f(\"</\" + p->tag + \">\"); TERMINATE CHANCE(\n  HEAD(\"<\"))\n    RECUR(xml,\n      cprop(tag)  = lex<string>(alphabetical, {}, {'<','>'});\n      cprop(tag)  = c->tag.substr(1, c->tag.size()-2);\n      cprop(nums) = lex_stream<int>(integer, {','});\n    )\nEND_PARSER_IMPL\n\n\npair<string, int> dfs(ast_ref(xml), int x, int y) {\n  enumerate_children(c)\n    if(c->nums[0] <= x && c->nums[1] <= y && x <= c->nums[2] && y <= c->nums[3])\n      return dfs(c, x, y);\n\n  return {ref_prop(tag), ref_prop(children.size())};\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string str; cin >> str;\n    auto root = PARSE(xml, str);\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<string, int> P;\nP solve(string s, int x, int y) {\n//  cout << s << endl;\n  string name;\n  REP(i,s.size()) {\n    if (s[i]=='>') {\n      name = s.substr(1,i-1);\n      break;\n    }\n  }\n  int x1,x2,y1,y2;\n//  cout << name << endl;\n  sscanf(s.substr(name.size()+2).c_str(), \"%d,%d,%d,%d\", &x1,&y1,&x2,&y2);\n//  cout << x1 << y1 << y1 << y2 << endl;\n  if (!(x1<=x&&x<=x2&&y1<=y&&y<=y2))\n    return P(\"OUT OF MAIN PANEL\", 1);\n  \n  int aa = -1;\n  int num = 0;\n  int pos;\n  REP(i,s.size()) {\n    if (s[i] == '<') {\n      aa++;\n      if (aa==1)\n        pos = i;\n    }\n    if (s[i] == '>'&&aa==2) {\n      aa = 0;\n      P p = solve(s.substr(pos, i-pos+1), x,y);\n      if (p.first != \"OUT OF MAIN PANEL\")\n        return p;\n      num++;\n    }\n  }\n  return P(name, num);\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    string s;\n    cin >> s;\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      P a = solve(s,x,y);\n      cout << a.first << \" \" << a.second << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::string::const_iterator State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Tag_{\n    std::string name;\n    int child_n;\n};\n\nstd::vector<Tag_> tags;\nstd::vector<P> ps1, ps2;\n\nstd::string Open(State& begin){\n    begin += 1;\n\n    std::string res = \"\";\n    while(*begin != '>'){\n        res += *begin;\n        begin += 1;\n    }\n    begin += 1;\n\n    return res;\n}\n\nvoid Close(State& begin){\n    while(*begin != '>'){\n        begin += 1;\n    }\n    begin += 1;\n}\n\nint Number(State& begin){\n    int res = 0;\n    while(std::isdigit(*begin)){\n        res = res * 10 + (*begin - '0');\n        begin += 1;\n    }\n    return res;\n}\n\nstd::vector<int> TagValues(State& begin){\n    std::vector<int> res;\n    res.push_back(Number(begin));\n    begin += 1;\n    res.push_back(Number(begin));\n    begin += 1;\n    res.push_back(Number(begin));\n    begin += 1;\n    res.push_back(Number(begin));\n    return res;\n}\n\nvoid Tag(State& begin){\n    Tag_ t;\n    t.name = Open(begin);\n    t.child_n = 0;\n    \n    std::vector<int> ps = TagValues(begin);\n\n    while(*(begin+1) != '/'){Tag(begin); t.child_n += 1;}\n    \n    Close(begin);\n\n    tags.push_back(t);\n\n    ps1.push_back(mp(ps[0], ps[1]));\n    ps2.push_back(mp(ps[2], ps[3]));\n}\n\nint touchedObject(int x, int y){\n    REP(i, (int)tags.size()){\n        if(ps1[i].first <= x && x <= ps2[i].first &&\n           ps1[i].second <= y && y <= ps2[i].second){\n            return i;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    int n;\n    while(std::cin >> n, n){\n        tags.clear();\n        ps1.clear();\n        ps2.clear();\n\n        std::string gui;\n        std::cin >> gui;\n\n        State state = gui.begin();\n        Tag(state);\n    \n        REP(i, n){\n            int x, y;\n            std::cin >> x >> y;\n\n            int index = touchedObject(x, y);\n            if(index != -1){\n                std::cout << tags[index].name << \" \" << tags[index].child_n << std::endl;\n            }else{\n                std::cout << \"OUT OF MAIN PANEL 1\" << std::endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<string,int> P;\ntypedef pair<int,int> Point;\ntypedef pair<Point,Point> PP;\nmap<string,int> M;\nmap<string,PP> Disp;\nvector<string> V;\n\nbool isTouch(string s, int x, int y){\n  Point p1 = Disp[s].first, p2 = Disp[s].second;\n\n  return (p1.first <= x && x <= p2.first && p1.second <= y && y <= p2.second);\n}\n\nP find(int x, int y){\n  P ans = P(\"OUT OF MAIN PANEL\",10000);\n\n  for(int i = 0; i < V.size(); i++)\n    if(isTouch(V[i],x,y) && ans.second > M[V[i]]) ans = P(V[i],M[V[i]]);\n\n\n  if(ans.first == \"OUT OF MAIN PANEL\") ans.second = 1;\n  return ans;\n}\n\nPP getPoint(string s){\n  s += \",\";\n  \n  int data[4];\n  int num = 0;\n  int sum = 0;\n  int pos = 0;\n\n  while(num < 4){\n    if(s[pos] == ','){\n      data[num] = sum;\n      num++;\n      sum = 0;\n    }else{\n      sum *= 10;\n      sum += s[pos]-'0';\n    }\n    pos++;\n  }\n  PP pp;\n  \n  pp.first = Point(data[0],data[1]);\n  pp.second = Point(data[2],data[3]);\n\n  return pp;\n}\n\nstring check(int pos,string s){\n \n  string out = \"\";\n\n  for(int i = pos; i < s.length(); i++){\n    out += s[i];\n    if(s[i] == '>') break;\n  }\n\n  return out;\n}\n\n\nvoid solve(string s){\n  int pos = 0;\n  string tag = \"</\", name = \"\", between = \"\", tail = \"\";\n  int num = 0;\n  \n  while(1){\n    tag += s[++pos];\n    if(s[pos] != '<' && s[pos] != '>') name += s[pos];\n    if(s[pos] == '>') break;\n  }\n\n  string point = \"\";\n  \n  while(s[++pos] != '<') point+=s[pos];\n\n  PP p = Disp[name] = getPoint(point);\n\n  V.push_back(name);\n  \n  while(pos < s.length()){\n    if(s[pos] == '<'){\n      if(check(pos,s) == tag){\n\n\twhile(s[pos] != '>') pos++;\n\n\tbreak;\n      }\n      num++;\n    }\n    between += s[pos++];\n  }\n  M[name] = num/2;\n\n  for(int i = pos+1; i < s.length(); i++)\n      tail += s[i];\n  if(between.length()) solve(between);\n  if(tail.length()) solve(tail);\n}\n\nvoid init(){\n  M.clear();\n  Disp.clear();\n  V.clear();\n}\n\nint main(){\n\n  string s;\n  int n;\n  while(cin >> n && n){\n \n    init();\n\n    cin.ignore();\n\n    getline(cin,s);\n    solve(s);\n\n    for(int i = 0; i < n; i++){\n      int x,y;\n      cin >> x >> y;\n      P p =  find(x,y);\n      cout << p.first << \" \" << p.second<< endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n \ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n \nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\nstring tag;\n \nbool inPosition(int x, int y, Data data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n \nint rec(Data now, const Data& panel){\n  /* ふぁぁ？？ */\n  int ret = 0;\n  /*\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  */\n  ret = now.foo.size();\n  return ret;\n}\n \n \npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n   \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n   \n   \n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ\n    flag = false;\n    if(now.foo.size() == 0) break;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n \n  return make_pair( now.name, rec(now, panel));\n}\n \n \nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  }\n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n \n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n \nData Check( Cursol& pos)\n{\n  Data d = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    d.foo.push_back(Check(pos));\n  }\n  getString(++pos);\n  ++pos;\n  return d;\n}\n \nint main(){\n  int n;\n  Cursol crl;\n \n  while(cin >> n, n){\n    Data Main;\n    cin >> tag;\n    Main = Check( crl = tag.begin()); //こうぶんかいせき！！\n     \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n     \n \n  }\n   \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nvector<int> cntt;\n\nint f(int dep = 0){\n\t//if( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tassert((ss >> w[0] >> w[1] >> w[2] >> w[3]));\n\t\tint aaa=0;\n\t\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\tf(dep+1);\n\t\t\taaa++;\n\t\t}\n\t//}\n\tV.push_back(w);\n\tname.push_back(s);\n\tcntt.push_back(aaa);\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\tp++;\n\tstring cnt;\n\t\n\twhile(ln[p] != '>')cnt += ln[p++];\n\tp++;\n\tassert(cnt == s);\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tcntt.clear();\n\t\tint fst = 0;\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\tidx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\t\n\t\t\tcout << name[idx] << \" \" << cntt[idx] << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nint f(int dep = 0){\n\tif( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tss >> w[0] >> w[1] >> w[2] >> w[3];\n\n\t\tV.push_back(w);\n\t\tname.push_back(s);\n\t\t\n\t\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\tf(dep+1);\n\t\t}\n\t}\n\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\t\n\twhile(ln[p] != '>')p++;\n\tp++;\n\t\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tint fst = 0;\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tif( (v[2]-v[0])*(v[3]-v[1]) < ok ){\n\t\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\t\tidx = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tvector<int> &vv = V[idx];\n\t\t\t\tif( vv[0] <= v[0] && v[2] <= vv[2] ){\n\t\t\t\t\tif( vv[1] <= v[1] && v[3] <= vv[3] ){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << name[idx] << \" \" << c-1 << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n  \n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tbool operator<(const Panel &p)const{return x1<p.x1;}\n\tvoid print(){\n\t\tcout<<name<<':'<<x1<<','<<y1<<','<<x2<<','<<y2<<endl;\n\t}\n};\n\n\nvector<Panel> v;\n\nvoid extract(string &s){\n\tfor(int i=0;i+1<s.size();i++){\n\t\tif(s[i]=='<'&&s[i+1]!='/'){\n\t\t\tchar c;\n\t\t\tPanel panel;\n\t\t\tstring tmp;\n\t\t\tfor(i++;s[i]!='>';i++)tmp+=s[i];\n\t\t\tpanel.name=tmp;\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.x1=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.y1=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!=',';i++)tmp+=s[i];\n\t\t\tpanel.x2=atoi(tmp.c_str());\n\t\t\ttmp.clear();\n\t\t\tfor(i++;s[i]!='<';i++)tmp+=s[i];\n\t\t\tpanel.y2=atoi(tmp.c_str());\n\t\t\ti--;\n\t\t\tv.push_back(panel);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint n;\n\tchar c;\n\twhile(cin>>n&&n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tv.clear();\n\t\textract(s);\n\t\tsort(v.begin(),v.end());\n\t\t//for(int i=0;i<v.size();i++)v[i].print();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tint a=-1;\n\t\t\tfor(int j=v.size()-1;j>=0;j--){\n\t\t\t\tif(v[j].x1<=x&&v[j].y1<=y&&x<=v[j].x2&&y<=v[j].y2){\n\t\t\t\t\ta=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif(a==-1){\n\t\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint cnt=0;\n\t\t\tfor(int j=a+1;j<v.size();j++){\n\t\t\t\tif(v[a].x1<=v[j].x1&&v[a].y1<=v[j].y1&&v[j].x2<=v[a].x2&&v[j].y2<=v[a].y2){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<v[a].name<<' '<<cnt<<endl;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector> \n#include <cctype>\n#include <cassert>\n#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nconst string nothing = \"OUT OF MAIN PANEL 1\";\nstring S;\nint cur;\nstruct Tag{\n  int p[4];\n  string name;\n  int layer,child;\n  bool operator>(const Tag &a) const{\n    return layer > a.layer;\n  }\n  bool checkP(Tag a){\n    if(p[0] <= a.p[0] && p[1] <= a.p[1] && p[2] >= a.p[2] && p[3] >= a.p[3]){\n      return true;\n    }\n    return false;\n  }\n  bool checkI(int x,int y){\n    if(p[0] <= x && p[1] <= y && p[2] >= x && p[3] >= y){\n      return true;\n    }\n    return false;\n  }\n};\n\nvector<Tag> keep;\nvoid tag_st(int);\nstring tag_name();\nvoid tag_st_f();\nvoid tag_value(Tag &);\n\nint number();\nint main(){\n  int n;\n  cur = 0;\n  cin >> n;\n  cin >> S;\n  vector<pair<int,int> > point(n);\n\n  for(int i = 0;i < n;i++){\n    int x,y;\n    cin >> x >> y;\n    point[i] = pair<int,int>(x,y);\n  }\n  tag_st(0);\n  //sort(keep.begin(),keep.end());\n  for(int i = 0;i < n;i++){\n    string ans_n;int ans_l = -1;int keep_num;\n    for(int j = 0;j < keep.size();j++){\n      if(keep[j].checkI(point[i].first,point[i].second)){\n\tif(ans_l <= keep[j].layer){\n\t  ans_l = keep[j].layer;\n\t  keep_num = j;\n\t}\n      }\n    }\n    if(ans_l == -1)cout << nothing << endl;\n    else{\n      cout << keep[keep_num].name << \" \" << keep[keep_num].child << endl;\n    }\n\t\t    \n  }\n  \n  return 0;\n}\n\n\n\n\nvoid tag_st(int layer){\n  assert(S[cur] == '<' && S[cur+1] != '/');\n  Tag tag;\n  string name = tag_name();\n  tag.layer = layer;\n  tag.name = name;\n  tag_value(tag);\n  \n  int cnt = 0;\n  while(1){\n    if(S[cur] == '<' && S[cur+1] != '/'){\n      tag_st(layer+1);\n      cnt++;\n    }else break;\n  }\n  tag.child = cnt;\n  keep.push_back(tag);\n  tag_st_f();\n  \n}\nstring tag_name(){\n  assert(S[cur] == '<' && S[cur+1] != '/');\n  cur++;\n  string name = \"\";\n  while(S[cur] != '>'){\n    name += S[cur];\n    cur++;\n  }\n  cur++;\n  return name;\n}\nvoid tag_st_f(){\n  assert(S[cur] == '<' && S[cur+1] == '/');\n  cur++;cur++;\n  string name = \"\";\n  while(S[cur] != '>'){\n    name += S[cur];\n    cur++;\n  }\n  cur++;\n}\nvoid tag_value(Tag &tag){\n  for(int i = 0;i < 4;i++){\n    tag.p[i] = number();\n    if(i != 3)cur++;\n  }\n}\nint number(){\n  assert(isdigit(S[cur]));\n  int num = S[cur] - '0';\n  cur++;\n  int cnt = 10;\n  while(isdigit(S[cur])){\n    num = num*cnt+(S[cur]-'0');\n    cur++;\n  }\n  return num;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n  \n  /*\n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n*/\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n  Data Main;\n  Cursol crl;\n\n  while(cin >> n, n){\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Panel {\n\tint x1, y1, x2, y2;\n\tint level;\n\tstring name;\n\tvector<Panel*> children;\n};\n\nvoid skip(const string &str, int &pos, char c) {\n\t//assert(str[pos] == c);\n\tif(str[pos] != c) {\n\t\tcerr << pos << \": \" << \"expected \" << c << \" but \" << (char)str[pos] << endl;\n\t}\n\t++pos;\n}\n\n\nstring inittag(const string &str, int &pos) {\n\tskip(str, pos, '<');\n\tint end = str.find_first_of('>', pos);\n\tstring name = str.substr(pos, end-pos);\n\tpos = end;\n\tskip(str, pos, '>');\n\treturn name;\n}\n\nvoid endtag(const string &str, int &pos, const string &name) {\n\tpos = str.find_first_of('>', pos);\n\tskip(str, pos, '>');\n}\n\n\nint readInt(const string &str, int &pos) {\n\tint n = 0;\n\twhile(isdigit(str[pos])) n = n*10+str[pos++]-'0';\n\treturn n;\n}\n\nvector<Panel*> allpanel;\n\nPanel* panel(const string &str, int &pos, int level) {\n\tstring name = inittag(str, pos);\n\n\tPanel *p = new Panel;\n\tp->name = name;\n\tp->level = level;\n\tp->x1 = readInt(str, pos);\n\tskip(str, pos, ',');\n\tp->y1 = readInt(str, pos);\n\tskip(str, pos, ',');\n\tp->x2 = readInt(str, pos);\n\tskip(str, pos, ',');\n\tp->y2 = readInt(str, pos);\n\twhile(str[pos+1] != '/') {\n\t\tPanel *c = panel(str, pos, level+1);\n\t\tp->children.push_back(c);\n\t}\n\tallpanel.push_back(p);\n\tendtag(str, pos, name);\n\n\treturn p;\n}\n\nint main() {\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tstring tag;\n\t\tcin.ignore();\n\t\tgetline(cin, tag);\n\t\t//cout << tag << endl;\n\n\t\tallpanel.clear();\n\t\tint pos = 0;\n\t\tPanel *parent = panel(tag, pos, 0);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tPanel *ans=  NULL;\n\t\t\tint level = -1;\n\t\t\tfor(int j = 0; j < allpanel.size(); ++j) {\n\t\t\t\tPanel *p = allpanel[j];\n\t\t\t\tif(p->x1 <= x && x <= p->x2 && p->y1 <= y && y <= p->y2) {\n\t\t\t\t\tif(p->level > level) {\n\t\t\t\t\t\tans = p;\n\t\t\t\t\t\tlevel = p->level;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans) {\n\t\t\t\tcout << ans->name << \" \" << ans->children.size() << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nint f(){\n\twhile( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tss >> w[0] >> w[1] >> w[2] >> w[3];\n\t\t\n\t\tV.push_back(w);\n\t\tname.push_back(s);\n\t\tf();\n\t}\n\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\t\n\twhile(ln[p] != '>')p++;\n\tp++;\n\t\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tif( (v[2]-v[0])*(v[3]-v[1]) < ok ){\n\t\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\t\tidx = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tvector<int> &vv = V[idx];\n\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] ){\n\t\t\t\t\tif( vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << name[idx] << \" \" << c << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nint f(int dep = 0){\n\t//if( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tss >> w[0] >> w[1] >> w[2] >> w[3];\n\n\t\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\tf(dep+1);\n\t\t}\n\t//}\n\tV.push_back(w);\n\tname.push_back(s);\n\t\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\tp++;\n\tstring cnt;\n\twhile(ln[p] != '>')cnt += ln[p++];\n\tp++;\n\tassert(cnt == s);\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tint fst = 0;\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\tidx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tvector<int> &vv = V[idx];\n\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] ){\n\t\t\t\t\tif( vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << name[idx] << \" \" << c << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\n\nclass AOJ1031{\nprivate:\n  string s;\n  int n;\n  map<string,int> c_num;\n  map<string,PP> coor;\n  vector<string> name_list;\npublic:\n  AOJ1031(int n,string s):n(n),s(s){}\n  ~AOJ1031(){}\n\n  void getChildNumber(){\n    int st,cnt=0;\n    map<string,bool> index;\n    rep(i,s.length()){\n      if(s[i] == '<' && s[i+1] != '/')st = i,cnt++;\n      else if(s[i] == '/')st = i;\n      else if(s[i] == '>'){\n\tc_num[s.substr(st+1,i-1-st)] = cnt-c_num[s.substr(st+1,i-1-st)];\n\tif(!index[s.substr(st+1,i-1-st)]){\n\t  name_list.pb(s.substr(st+1,i-1-st));\n\t  index[s.substr(st+1,i-1-st)] = true;\n\t}\n      }\n    }\n  }\n\n  PP getPP(string s){\n    stringstream ss;\n    ss << s;\n    int Pm[4];\n    ss >> Pm[0] >> Pm[1] >> Pm[2] >> Pm[3];\n    return PP(P(Pm[0],Pm[1]),P(Pm[2],Pm[3]));\n  }\n\n  void getCoordinate(){\n\n    bool OK = false;\n    int st;\n    string store;\n    REP(i,0,s.length()){\n      if(s[i] == ','){\n\ts[i] = ' ';\n\tcontinue;\n      }\n\n      if(s[i] == '<' && s[i+1] != '/' && !OK)st = i,OK=true;\n      else if(s[i] == '>' && OK){\n\tstore = s.substr(st+1,i-1-st);\n\tcoor[store] = PP(P(-1,-1),P(-1,-1));\n\tst = i+1;\t\n      }\n      else if(s[i] == '<'){\n\tif(coor[store] != PP(P(-1,-1),P(-1,-1)))continue;\n\tcoor[store] = getPP(s.substr(st,i-st)); \n\tOK = false;\n\tst = i;\n\tif(s[i+1] != '/')OK = true;\n      }\n    }\n  }\n\n\n\n  void run(){\n    getChildNumber();\n    getCoordinate();\n\n    rep(i,n){\n      int x,y;\n      cin >> x >> y;\n      bool found = false;\n      string found_name;\n      P LIMA = P(0,0),LIMB = P(INT_MAX,INT_MAX); \n      rep(i,name_list.size()){\n\tstring name = name_list[i];\n\n\tif(coor[name].F.F <= x && x <= coor[name].S.F && coor[name].F.S <= y && y <= coor[name].S.S && (LIMA.F <= coor[name].F.F && coor[name].F.F <=LIMB.F && LIMA.S <= coor[name].F.S && coor[name].F.S <= LIMB.S && LIMA.F <= coor[name].S.F && coor[name].S.F <= LIMB.F && LIMA.S <= coor[name].S.S && coor[name].S.S <= LIMB.S)){\n\t  found_name = name;\n\t  found = true;\n\t}\n      }\n      if(!found)cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else cout << found_name << \" \" << c_num[found_name] << endl;\n\n    }\n  }\n\n\n};\n\nint main(){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0)break;\n    string s;\n    cin >> s;\n    AOJ1031 ans = AOJ1031(n,s);\n    ans.run();\n\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <list>\n\nusing namespace std;\n\nclass Window{\npublic:\n\t~Window()\n\t{\n\t\tlist<class Window*>::iterator it;\n\t\tfor (it = child.begin(); it != child.end(); it++){\n\t\t\tdelete (*it);\n\t\t}\n\t}\n\t\t\n\tWindow* Click(int x, int y)\n\t{\n\t\tWindow *ret;\n\t\tlist<class Window*>::iterator it;\n\t\t\n\t\tret = NULL;\n\t\tif (isClick(x, y) == true){\n\t\t\tfor (it = child.begin(); it != child.end(); it++){\n\t\t\t\tret = (*it)->Click(x, y);\n\t\t\t\tif (ret != NULL){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn (NULL);\n\t\t}\n\t\treturn (ret == NULL ? this : ret);\n\t}\t\t\t\t\n\t\n\tbool isClick(int x, int y)\n\t{\n\t\treturn (sx <= x && ex >= x && sy <= y && ey >= y);\n\t}\n\n\tchar name[100];\n\tint sx, sy;\n\tint ex, ey;\n\tlist<class Window*> child;\n};\n\nWindow* input(char tag[])\n{\n\tint i;\n\tWindow *Parent;\n\t\n\tParent = new Window;\n\t\n\twhile (*tag != '<') tag++;\n\ttag++;\n\ti = 0;\n\twhile (*tag != '>'){\n\t\tParent->name[i++] = *tag++;\n\t}\n\tParent->name[i] = '\\0';\n\twhile (!isdigit(*tag)) tag++;\n\tParent->sx = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->sy = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->ex = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->ey = atoi(tag);\n\t\n\twhile (*tag != '\\0'){\n\t\twhile (*tag != '<'){\n\t\t\ttag++;\n\t\t}\n\t\tif (*(tag + 1) == '/'){\n\t\t\treturn (Parent);\n\t\t}\n\t\telse {\n\t\t\tParent->child.push_back(input(tag));\n\t\t\twhile (*tag != '/') tag++;\n\t\t}\n\t}\n\t\n\treturn (Parent);\n}\n\n\t\nint main(void)\n{\n\tWindow *Main;\n\tchar tag[1001];\n\tint n;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%s\", tag);\n\t\tMain = input(tag);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tWindow* output;\n\t\t\t\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\toutput = Main->Click(x, y);\n\t\t\tif (output == NULL){\n\t\t\t\tprintf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%s %d\\n\", output->name, output->child.size());\n\t\t\t}\n\t\t}\n\t\t\n\t\tdelete Main;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\n\nint n;\nstring line;\n\nmap<string,int> strCnt;\n\nstring point(int x,int y,string field){\n\n\tbool cont=false;\n\tint s;\n\tint f;\n\tbool isFirstname=true;\n\tstring firstName=\"\";\n\tstring name;\n\n\tfor(int i = 0; i < field.size(); i++){\n\t\tif(field[i]=='<'){\n\t\t\ts=i+1;\n\t\t}\n\t\telse if(field[i]=='>'){\n\t\t\tname = field.substr(s,i-s);\n\t\t\tfirstName=name;\n\t\t\t// gðÆè¾·\n\t\t\tfield=field.substr(name.size()+2,field.size()-2*(name.size()+2)-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// ÀWðØèæè\n\tstring points;\n\tstring back;\n\tbool fff=false;\n\tfor(int i = 0; i < field.size(); i++){\n\t\tif(field[i]=='<'){\n\t\t\tpoints=field.substr(0,i);\n\t\t\tback=field.substr(i);\n\t\t\tfff=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!fff){\n\t\tpoints=field;\n\t}\n\tint bc=0;\n\tint cc=0;\n\tvector<int> pp;\n\tfor(int i = 0; i < points.size(); i++){\n\t\tif(points[i]==','){\n\t\t\tbc=cc;\n\t\t\tpp.push_back(atoi(points.substr(bc,i-bc).c_str()));\n\t\t\tcc=i+1;\n\t\t}\n\t}\n\tpp.push_back(atoi(points.substr(cc,points.size()-cc).c_str()));\n\n\tint minx = pp[0];\n\tint miny = pp[1];\n\tint maxx = pp[2];\n\tint maxy = pp[3];\n\n\tif(minx > x || miny > y || maxx < x || maxy < y){\n\t\tif(name==\"main\")\n\t\t\treturn \"OUT OF MAIN PANEL 1\";\n\t\telse\n\t\t\treturn \"\";\n\t}\n\telse{\n\t\t// panelãÉ¢­ÂÌ^Oª é©¦é\n\t\tstring tagName;\n\t\tint sk;\n\t\t// e^Oð½Çé\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < back.size(); i++){\n\t\t\tif(back[i] == '<'){\n\t\t\t\tif(tagName==\"\"){\n\t\t\t\t\tsk=i;\n\t\t\t\t\tfor(int j = i; ;j++){\n\t\t\t\t\t\tif(back[j]=='>'){\n\t\t\t\t\t\t\ttagName=back.substr(i+1,j-i-1);\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(back[i+1]!='/')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint fk;\n\t\t\t\t\tstring ts;\n\t\t\t\t\tfor(int j = i; ;j++){\n\t\t\t\t\t\tif(back[j]=='>'){\n\t\t\t\t\t\t\tts=back.substr(i+1,j-i-1);\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t\tfk=j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.substr(1)==tagName){\n\t\t\t\t\t\t//string ret=point(x,y,back.substr(sk,fk-sk+1));\n\t\t\t\t\t\t//\t\t\t\t\t\tif(ret!=\"\")\n\t\t\t\t\t\t//\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t\ttagName=\"\";\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstrCnt[name]=cnt;\n\t\ttagName=\"\";\n\t\t// e^Oð½Çé\n\t\tfor(int i = 0; i < back.size(); i++){\n\t\t\tif(back[i] == '<'){\n\t\t\t\tif(tagName==\"\"){\n\t\t\t\t\tsk=i;\n\t\t\t\t\tfor(int j = i; ;j++){\n\t\t\t\t\t\tif(back[j]=='>'){\n\t\t\t\t\t\t\ttagName=back.substr(i+1,j-i-1);\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(back[i+1]!='/')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint fk;\n\t\t\t\t\tstring ts;\n\t\t\t\t\tfor(int j = i; ;j++){\n\t\t\t\t\t\tif(back[j]=='>'){\n\t\t\t\t\t\t\tts=back.substr(i+1,j-i-1);\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t\tfk=j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.substr(1)==tagName){\n\t\t\t\t\t\tstring ret=point(x,y,back.substr(sk,fk-sk+1));\n\t\t\t\t\t\tif(ret!=\"\")\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t\ttagName=\"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tstring retStrTmp = name + \" \";\n\tstringstream ss;\n\tss << strCnt[name];\n\tretStrTmp += ss.str();\n\treturn retStrTmp;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tcin>>line;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcout<<point(x,y,line)<<endl;\n\t\t}\n\t\tstrCnt.clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint tag_index,x_1,y_1,x_2,y_2,depth;\n\tvector<int> children;\n};\n\nint N;\nchar buf[1001];\nchar tagName[500][501];\nInfo info[500];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 500; i++){\n\t\tinfo[i].children.clear();\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tchar work[501];\n\tint tag_index = 0,work_index,depth = 0;\n\tint tmp,count;\n\n\tstack<int> PARENT;\n\n\tfor(int index = 0;buf[index] != '\\0';){\n\n\t\tif(buf[index] == '<'){\n\t\t\tif(buf[index+1] != '/'){\n\t\t\t\twork_index = 0;\n\t\t\t\tfor(++index; buf[index] != '>'; index++){\n\t\t\t\t\twork[work_index] = buf[index];\n\t\t\t\t\twork[work_index+1] = '\\0';\n\t\t\t\t\twork_index++;\n\t\t\t\t}\n\t\t\t\tstrcpy(tagName[tag_index],work);\n\t\t\t\tinfo[tag_index].depth = depth;\n\t\t\t\tinfo[tag_index].tag_index = tag_index;\n\n\t\t\t\tif(!PARENT.empty()){\n\t\t\t\t\tinfo[PARENT.top()].children.push_back(tag_index);\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < 4){\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(;buf[index] != ',' && buf[index] != '<';index++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[index]-'0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch(count){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinfo[tag_index].x_1 = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tinfo[tag_index].y_1 = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinfo[tag_index].x_2 = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tinfo[tag_index].y_2 = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t\tif(count < 4)index++;\n\t\t\t\t}\n\n\t\t\t\tPARENT.push(tag_index);\n\t\t\t\ttag_index++;\n\t\t\t\tdepth++;\n\n\t\t\t}else{\n\t\t\t\tindex++;\n\t\t\t\tfor(;buf[index] != '>';index++);\n\t\t\t\tindex++;\n\t\t\t\tdepth--;\n\t\t\t\tPARENT.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tint x,y;\n\tint max_depth,touch_index;\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&x,&y);\n\n\t\tmax_depth = -1;\n\t\tfor(int i = 0; i < tag_index; i++){\n\t\t\tif(info[i].x_1 <= x && info[i].x_2 >= x && info[i].y_1 <= y && info[i].y_2 >= y){\n\t\t\t\tif(max_depth < info[i].depth){\n\t\t\t\t\tmax_depth = info[i].depth;\n\t\t\t\t\ttouch_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max_depth == -1){\n\t\t\tprintf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%s %lld\\n\",tagName[info[touch_index].tag_index],info[touch_index].children.size());\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <memory>\n#include <vector>\nusing namespace std;\n\nstruct node_t {\n\tstring name;\n\tint x1, y1, x2, y2;\n\tint size;\n\tvector<unique_ptr<node_t>> children;\n\n\tnode_t(const string &name_, int x1_, int y1_, int x2_, int y2_):\n\t\tname(name_), x1(x1_), y1(y1_), x2(x2_), y2(y2_), size(1) {}\n\n\tbool in(int x, int y) const {\n\t\treturn x1 <= x && x <= x2 && y1 <= y && y < y2;\n\t}\n\n\tstring click(int x, int y) const {\n\t\tfor(const auto &child : children) {\n\t\t\tif(child->in(x, y)) return child->click(x, y);\n\t\t}\n\t\treturn name + \" \" + to_string(children.size());\n\t}\n\n\tvoid add_child(unique_ptr<node_t> &&child) {\n\t\tchildren.emplace_back(move(child));\n\t}\n};\n\nint get_int(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*(++it))) res = res * 10 + *it - '0';\n\treturn res;\n}\n\nunique_ptr<node_t> parse(string::const_iterator &it) {\n\tstring name = \"\";\n\twhile(isalpha(*(++it))) name += *it;\n\tconst int x1 = get_int(it);\n\tconst int y1 = get_int(it);\n\tconst int x2 = get_int(it);\n\tconst int y2 = get_int(it);\n\n\tunique_ptr<node_t> res(new node_t(name, x1, y1, x2, y2));\n\twhile(*(it + 1) != '/') res->add_child(parse(it));\n\n\tit += name.size() + 3; // \"</name>\"\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tstring tags;\n\t\tcin >> tags;\n\n\t\tauto it = tags.cbegin();\n\t\tconst auto root = parse(it);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tcout << (root->in(x, y) ? root->click(x, y) : \"OUT OF MAIN PANEL 1\") << \"\\n\";\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstruct S{\n\tint x1,x2,y1,y2,c;\n\tstring name;\n\tbool contain(int x,int y)\n\t{\n\t\treturn x1<=x&&x<=x2&&y1<=y&&y<=y2;\n\t}\n};\nS pnl[1000];\nint n,m;\nstring in;\n\nint eval(int s,int t)\n{\n\tif(s>=t)return 0;\n\tassert(in[s]=='<');\n\t\n\tint id=m,bt=in.find('>',s),ns=in.find('<',bt+1);\n\tm++;\n\tpnl[id].name=in.substr(s+1,bt-s-1);\n\t\n\tstring tmp=in.substr(bt+1,ns-bt-1);\n\tfr(i,tmp)if(*i==',')*i=' ';\n\tstringstream ss(tmp);\n\tss>>pnl[id].x1>>pnl[id].y1>>pnl[id].x2>>pnl[id].y2;\n\t\n\ttmp=\"</\"+pnl[id].name+\">\";\n\tint es=in.find(tmp,bt),et=es+pnl[id].name.size()+3; assert(s<=es&&es<=t);\n\t\n\tint ret=1;\n\tpnl[id].c=eval(ns,es);\n\tif(et!=t)ret+=eval(et,t);\n\treturn ret;\n}\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tcin>>in;\n\t\tm=0;\n\t\teval(0,in.size());\n\t\t\n\t\trep(i,n)\n\t\t{\n\t\t\tint x,y,id=m-1; cin>>x>>y;\n\t\t\tfor(;id>=0;id--)if(pnl[id].contain(x,y))break;\n\t\t\t\n\t\t\tif(id<0)cout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\telse cout<<pnl[id].name<<\" \"<<pnl[id].c<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  vector<Panel> child;\n};\n\nint i=0;\npair<string,int>ans;\nint maxDepth;\n\nPanel parse(string s)\n{\n  Panel p={\"\",0,0,0,0};\n  for(i++;s[i]!='>';i++)p.name+=s[i];\n  char c;\n  stringstream ss;\n  ss.str(s.substr(i+1,s.size()-i-1));\n  ss>>p.x1>>c>>p.y1>>c>>p.x2>>c>>p.y2;\n  while(s[i]!='<')i++;\n  while(s[i+1]!='/')p.child.push_back(parse(s));\n  while(s[i]!='>')i++;\n  i++;\n  return p;\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n  if(x<p.x1 || p.x2<x || y<p.y1 || p.y2<y)return;\n  if(maxDepth<depth){\n    maxDepth=depth;\n    ans.first=p.name;\n    ans.second=p.child.size();\n  }\n  vector<Panel>::iterator it;\n  for(it=p.child.begin();it!=p.child.end();it++)solve(*it,x,y,depth+1);\n}\n\nint main()\n{\n  int n,x,y;\n  string s;\n  while(cin>>n,n){\n    cin>>s;\n    s=\"<OUT OF MAIN PANEL>-1,-1,10001,10001\"+s+\"</OUT OF MAIN PANEL>\";\n    Panel p=parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      solve(p,x,y,0);\n      if(ans.first==\"OUT OF MAIN PANEL\")ans.second=1;\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<string, int> P;\n\ntypedef struct node {\n  vector<node> ch;\n  string name;\n  int ty, tx, by, bx;\n  node() { }\n  node(string nn, int tty, int ttx, int bby, int bbx) { name = nn; ty = tty; tx = ttx; by = bby; bx = bbx; }\n} node;\n\nvoid add(node &root, string tar, string name, int ty, int tx, int by, int bx){\n  if(root.name == tar) { root.ch.push_back(node(name, ty, tx, by, bx)); return; }\n    REP(i, root.ch.size()){\n      node c = root.ch[i];\n      if(c.ty <= ty && c.tx <= tx && c.by >= by && c.bx >= bx){ add(root.ch[i], tar, name, ty, tx, by, bx); return; };\n  }\n}\n\nvoid disp(node &r, string b){\n  cout <<b <<r.name <<\", \" <<r.ch.size() <<endl;\n  REP(i, r.ch.size()) disp(r.ch[i], b + \"  \");\n}\n\nP touch(node &root, int y, int x, bool f, string s){\n  if(root.name == \"main\" && !(root.ty <= y && root.tx <= x && root.by >= y && root.bx >= x)) return P(\"OUT OF MAIN PANEL\", 1);\n  P ret = P(\"\", 0);\n  if(!f){\n    REP(i, root.ch.size()){\n      node c = root.ch[i];\n      if(c.ty <= y && c.tx <= x && c.by >= y && c.bx >= x) return touch(root.ch[i], y, x, f, s);\n    }\n  }\n  if(!f) ret.first = root.name;\n  if(f) ret.second += 1;\n  REP(i, root.ch.size()){\n    P r = touch(root.ch[i], y, x, true, s);\n    ret.second += r.second;\n  }\n  return ret;\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    string S; cin >>S;\n    node root = node(\"N\", 0, 0, 0, 0);\n    vector<string> rn;\n    FOR(i, 1, S.length()){\n      stringstream ss, sss;\n      while(i < S.length() && S[i] != '<') ss << S[i++];\n      if(ss.str()[0] == '/') { rn.pop_back(); continue; }\n      int n = 0;\n      string s = ss.str(); ss.str(\"\");\n      while(s[n] != '>') ss << s[n++];\n      s = s.substr(n + 1) + \",\";\n      int nums[4] = {0}, num = 0; n = 0;\n      REP(j, s.length()){\n        if(s[j] == ','){\n          nums[n++] = num;\n          num = 0;\n        } else{\n          num *= 10;\n          num += s[j] - '0';\n        }\n      }\n      if(root.name == \"N\") root = node(ss.str(), nums[1], nums[0], nums[3], nums[2]);\n      else add(root, rn.back(), ss.str(), nums[1], nums[0], nums[3], nums[2]);\n      rn.push_back(ss.str());\n    }\n    //disp(root, \"\");\n    REP(n, N){\n      int x, y; cin >>x >>y;\n      P ret = touch(root, y, x, false, \"\");\n      cout <<ret.first <<\" \" <<ret.second <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\nstring tag;\n\nbool inPosition(int x, int y, Data data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n  \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n  \n  \n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ\n    flag = false;\n    if(now.foo.size() == 0) break;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n  if(pos == tag.end()) return;\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  if(pos == tag.end()) return;\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n    if(pos == tag.end()) return;\n  }\n  getString(++pos);\n  ++pos;\n}\n\nint main(){\n  int n;\n  Cursol crl;\n\n  while(cin >> n, n){\n    Data Main;\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n\ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n\nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n\nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n\nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n\nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n\nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n\nbool eof() {\n  return __it == __end;\n}\n\nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n\nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n\nlexstat lstat = lexstat::no_stat;\n\ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n\n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n\n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n\n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n\n  lstat = lexstat::success;\n\n  return ret;\n}\n\nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n\nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n\ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n\nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n\n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n\n  while(i--) unread();\n  return false;\n}\n\n}\nusing namespace parser;\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct xml {\n  string tag;\n  vector<int> prop;\n  vector<shared_ptr<xml>> children;\n};\n\nshared_ptr<xml> parse(shared_ptr<xml>& p) {\n  while(!eof()) {\n    if(look_ahead(\"</\")) {\n      lex_f(\"</\" + p->tag + \">\");\n      return p;\n    } else if(look_ahead(\"<\")) {\n      auto c = make_shared<xml>();\n      c->tag = lex<string>(alphabetical, {}, {'<','>'});\n      c->tag = c->tag.substr(1, c->tag.size()-2);\n      c->prop = lex_stream<int>(integer, {','});\n      p->children.push_back(c);\n      parse(c);\n    }\n  }\n  return p;\n}\n\nshared_ptr<const xml> parse(Iter begin, Iter end) {\n  init_iterator(begin, end);\n  auto p = make_shared<xml>();\n  p->tag = \"OUT OF MAIN PANEL\";\n  return parse(p);\n}\n\npair<string, int> dfs(shared_ptr<const xml> const& p, int x, int y) {\n  for(auto && c: p->children)\n    if(c->prop[0] <= x && c->prop[1] <= y && x <= c->prop[2] && y <= c->prop[3])\n      return dfs(c, x, y);\n\n  return {p->tag, p->children.size()};\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string xml_str; cin >> xml_str;\n    auto root = parse(xml_str.begin(), xml_str.end());\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<stdio.h>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<Panel> v;\n};\n\nint fp;\n\nPanel parse(string s){\n\tPanel p;\n\tint ep=0;\n\twhile(s[fp] != '>'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.name = s.substr(fp-ep,ep);\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x1 = toInt(s.substr(fp-ep,ep));\n\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y1 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x2 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != '<'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y2 = toInt(s.substr(fp-ep,fp-1));\n\t\n\tfp++;\n\twhile(1){\n\t\tif(s[fp]=='/'){ fp+=p.name.size()+3; break;}\n\t\telse p.v.push_back(parse(s));\n\t}\t\n\treturn p;\n}\n\nPanel search(int x,int y,Panel r_p,Panel p){\n\tif(p.x1 <= x && p.x2 >= x && p.y1 <= y && p.y2 >= y){\n\t\tif(p.v.size()==0) return p;\t\n\t\trep(i,p.v.size()){\t\n\t\t\tPanel tmp = search(x,y,p,p.v[i]);\n\t\t\tif(tmp.name != p.name ) return tmp;\n\t\t}\n\t}\n\t\n\treturn r_p;\n}\n\nint main(){\n\n\twhile(1){\n\t\tint n;\n\t\tstring str;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> str;\n\t\tfp=1;\n\t\tPanel p = parse(str);\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tPanel root;root.name=\"-1\";\n\t\t\tPanel ans=search(x,y,root,p);\n\t\t\tif(ans.name==\"-1\") cout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t\telse cout << ans.name << \" \" << ans.v.size() << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<cctype>\n\nusing namespace std;\n\n#define foreach(itm,o) for(__typeof((o).begin()) itm=(o).begin();itm!=(o).end();++itm)\n\nstruct panel{\n  string name;\n  int x1,y1,x2,y2;\n  panel(int x1,int y1,int x2,int y2,string newName):\n    x1(x1),y1(y1),x2(x2),y2(y2),name(newName){}\n  bool isinside(int x, int y){\n    return ( x1 <= x && x <= x2 && y1 <= y && y <= y2 );\n  }\n};\n\npanel tail(-100,-100,-100,-100,\" tail\");\n\nint dig(const string &s, int &pos){\n  int n = 0;\n  while(isdigit(s[pos])){\n    n *= 10;\n    n += s[pos]-'0';\n    ++pos;\n  }\n  return n;\n}\n\nvoid parse(const string &s, int &pos,\n\t   const string &parent, map<string, vector<panel> > &M){\n  string newName;\n  if(pos>=s.length())return ;\n  if( s[pos] == '<' ){\n    ++pos;\n    while(s[pos]!='>'){newName+=s[pos];++pos;}\n  }\n  pos++;\n  int x1 = dig(s,pos);++pos;\n  int y1 = dig(s,pos);++pos;\n  int x2 = dig(s,pos);++pos;\n  int y2 = dig(s,pos);\n  //cout << newName << endl;\n  M[newName].push_back(tail );\n  M[parent].push_back( panel(x1,y1,x2,y2,newName) );\n  while( true ){\n    if( s[pos]=='<'&&s[pos+1]=='/' ){\n      while(s[pos]!='>')++pos;\n      ++pos;\n      //cout << newName << \" END\"<<endl;\n      break;\n    }else{\n      //cout << newName << \" HAS:\"<<endl;\n      parse(s,pos,newName,M);\n      if(pos>=s.length())break;\n    }\n  }\n  return ;\n}\n\nint main(){\n  while(true){\n    int n;\n    int pos = 0;\n    string tags,ans;\n    map< string, vector<panel> > structure;\n    cin >> n;if(n==0)break;\n    cin >> tags;\n    parse(tags,pos,\" _0root\",structure);\n    structure[\" _0root\"].push_back(tail);\n    \n    //cout << \"==================\\n    PARSE END\\n==================\" << endl;\n    for(int i = 0; i < n; ++i){\n      int qx,qy;cin>>qx>>qy;\n      int minchild = 100000;\n      for(map<string,vector<panel> >::iterator itm=structure.begin(); itm != structure.end(); ++itm){\n\tfor(int j = 0; j < itm->second.size(); ++j){\n\t  if( itm->second[j].isinside(qx,qy) ){\n\t    //cout << itm->first << \" HAS : \" << itm->second[j].name << \"(\" << itm->second[j].x1 << \",\" << itm->second[j].y1 << \")-(\" << itm->second[j].x2 << \",\" << itm->second[j].y2 << \")\" << endl; \n\t    int t = structure[itm->second[j].name].size();\n\t    if( t < minchild ){\n\t      minchild = t;\n\t      //cout << \"ANS NAME :\" << itm->second[j].name << endl;\n\t      ans = itm->second[j].name;\n\t    }\n\t  }\n\t}\n      }\n      if( minchild == 100000 ){\n\tcout <<\"OUT OF MAIN PANEL 1\" << endl;\n      }else{\n\tcout << ans << ' ' << minchild-1 << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Panel {\n    string name;\n    int x1, y1, x2, y2;\n    vector<Panel> child;\n    \n    Panel(){}    \n    Panel(string name, int x1, int y1, int x2, int y2) :\n        name(name), x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstring s;\nint idx;\n\nstring get_name()\n{\n    string name;\n    ++idx;\n    while (s[idx] != '>') {\n        name += s[idx];\n        ++idx;\n    }\n    ++idx;\n    return name;\n}\n\nint s2i(string &str)\n{\n    stringstream ss(str);\n    int num;\n    ss >> num;\n    return num;\n}\n\nint get_val()\n{\n    string val;\n    while (isdigit(s[idx])) {\n        val += s[idx];\n        ++idx;\n    }\n    return s2i(val);\n}\n\nvoid parse(Panel &p)\n{\n    while (s[idx] == '<' && s[idx+1] != '/') {\n        string name = get_name();\n        int x1 = get_val(); ++idx;\n        int y1 = get_val(); ++idx;\n        int x2 = get_val(); ++idx;\n        int y2 = get_val();\n        Panel panel(name, x1, y1, x2, y2);\n        parse(panel);\n        p.child.push_back(panel);\n        while (s[idx] != '>') {\n            idx++;\n        }\n        idx++;\n    }    \n}\n\nbool get_panel(int x, int y, const Panel &p)\n{\n    for (int i = 0; i < (int)p.child.size(); i++) {\n        Panel np = p.child[i];\n        if (np.x1 <= x && x <= np.x2 && np.y1 <= y && y <= np.y2) {\n            if (!get_panel(x, y, np)) {\n                cout << np.name << \" \" << np.child.size() << endl;\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int n, x, y;\n    while (cin >> n >> s, n) {\n        Panel p;\n        p.name = \"#\"; p.x1 = p.y1 = -1; p.x2 = p.y2 = 10001;\n        idx = 0;\n        parse(p);\n        for (int i = 0; i < n; i++) {\n            cin >> x >> y;\n            if (!get_panel(x, y, p)) {\n                cout << \"OUT OF MAIN PANEL 1\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <list>\n\nusing namespace std;\n\nclass Window{\npublic:\n\t~Window()\n\t{\n\t\tlist<class Window*>::iterator it;\n\t\tfor (it = child.begin(); it != child.end(); it++){\n\t\t\tdelete (*it);\n\t\t}\n\t}\n\t\t\n\tWindow* Click(int x, int y)\n\t{\n\t\tWindow *ret;\n\t\tlist<class Window*>::iterator it;\n\t\t\n\t\tret = this;\n\t\tif (isClick(x, y) == true){\n\t\t\tfor (it = child.begin(); it != child.end(); it++){\n\t\t\t\tif ((*it)->Click(x, y) != NULL) ret = *it;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn (NULL);\n\t\t}\n\t\treturn (ret);\n\t}\t\t\t\t\n\t\n\tbool isClick(int x, int y)\n\t{\n\t\treturn (sx <= x && ex >= x && sy <= y && ey >= y);\n\t}\n\n\tchar name[100];\n\tint sx, sy;\n\tint ex, ey;\n\tlist<class Window*> child;\n};\n\nWindow* input(char tag[])\n{\n\tint i;\n\tWindow *Parent;\n\t\n\tParent = new Window;\n\t\n\twhile (*tag != '<') tag++;\n\ttag++;\n\ti = 0;\n\twhile (*tag != '>'){\n\t\tParent->name[i++] = *tag++;\n\t}\n\tParent->name[i] = '\\0';\n\twhile (!isdigit(*tag)) tag++;\n\tParent->sx = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->sy = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->ex = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->ey = atoi(tag);\n\t\n\twhile (*tag != '\\0'){\n\t\twhile (*tag != '<'){\n\t\t\ttag++;\n\t\t}\n\t\tif (*(tag + 1) == '/'){\n\t\t\treturn (Parent);\n\t\t}\n\t\telse {\n\t\t\tParent->child.push_back(input(tag));\n\t\t\twhile (*tag != '/') tag++;\n\t\t}\n\t}\n\t\n\treturn (Parent);\n}\n\n\t\nint main(void)\n{\n\tWindow *Main;\n\tchar tag[1001];\n\tint n;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%s\", tag);\n\t\tMain = input(tag);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tWindow* output;\n\t\t\t\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\toutput = Main->Click(x, y);\n\t\t\tif (output == NULL){\n\t\t\t\tprintf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%s %d\\n\", output->name, output->child.size());\n\t\t\t}\n\t\t}\n\t\t\n\t\tdelete Main;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\nchar str[11000];\nstring m[1100];\nint x1[1100];\nint x2[1100];\nint y1[1100];\nint y2[1100];\nint fi[1100];\nint par[1100];\nint tmp[1100];\nint sz[1100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tscanf(\"%s\",str);\n\t\tint n=0;\n\t\tfor(int i=0;str[i];i++){\n\t\t\tif(str[i]=='<'&&str[i+1]!='/'){\n\t\t\t\tfi[n]=i;\n\t\t\t\tstring now=\"\";\n\t\t\t\tint j;\n\t\t\t\tfor(j=i+1;str[j]!='>';j++)now+=str[j];\n\t\t\t\tj++;\n\t\t\t\tx1[n]=x2[n]=y1[n]=y2[n]=0;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\tx1[n]*=10;x1[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\ty1[n]*=10;y1[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\tx2[n]*=10;x2[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\twhile('0'<=str[j]&&str[j]<='9'){\n\t\t\t\t\ty2[n]*=10;y2[n]+=str[j]-'0';j++;\n\t\t\t\t}j++;\n\t\t\t\tm[n++]=now;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)par[i]=-1;\n\t\tfor(int i=0;i<n;i++)tmp[i]=99999999;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(x1[j]<x1[i]&&x2[i]<x2[j]&&y1[j]<y1[i]&&y2[i]<y2[j]){\n\t\t\t\t\tif(x2[j]-x1[j]<tmp[i]){\n\t\t\t\t\t\tpar[i]=j;\n\t\t\t\t\t\ttmp[i]=x2[j]-x1[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tsz[i]=0;\n\t\t\tfor(int j=0;j<n;j++)if(par[j]==i)sz[i]++;\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\t\tint to=-1;\n\t\t\tint val=99999999;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(x1[j]<=x&&x<=x2[j]&&y1[j]<=y&&y<=y2[j]){\n\t\t\t\t\tif(x2[j]-x1[j]<val){\n\t\t\t\t\t\tval=x2[j]-x1[j];\n\t\t\t\t\t\tto=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!~to)printf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t\telse{\n\t\t\t\tprintf(\"%s %d\\n\",m[to].c_str(),sz[to]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <list>\n\nusing namespace std;\n\nclass Window{\npublic:\n\t~Window()\n\t{\n\t\tlist<class Window*>::iterator it;\n\t\tfor (it = child.begin(); it != child.end(); it++){\n\t\t\tdelete (*it);\n\t\t}\n\t}\n\t\t\n\tWindow* Click(int x, int y)\n\t{\n\t\tWindow *ret;\n\t\tlist<class Window*>::iterator it;\n\t\t\n\t\tret = this;\n\t\tif (isClick(x, y) == true){\n\t\t\tfor (it = child.begin(); it != child.end(); it++){\n\t\t\t\tif ((*it)->Click(x, y) != NULL) ret = *it;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn (NULL);\n\t\t}\n\t\treturn (ret);\n\t}\t\t\t\t\n\t\n\tbool isClick(int x, int y)\n\t{\n\t\treturn (sx <= x && ex >= x && sy <= y && ey >= y);\n\t}\n\n\tchar name[100];\n\tint sx, sy;\n\tint ex, ey;\n\tlist<class Window*> child;\n};\n\nWindow* input(char tag[])\n{\n\tint i;\n\tWindow *Parent;\n\t\n\tParent = new Window;\n\t\n\twhile (*tag != '<') tag++;\n\ttag++;\n\ti = 0;\n\twhile (*tag != '>'){\n\t\tParent->name[i++] = *tag++;\n\t}\n\tParent->name[i] = '\\0';\n\twhile (!isdigit(*tag)) tag++;\n\tParent->sx = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->sy = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->ex = atoi(tag);\n\twhile (isdigit(*tag)) tag++;\n\twhile (!isdigit(*tag)) tag++;\n\tParent->ey = atoi(tag);\n\t\n\twhile (*tag != '\\0'){\n\t\twhile (*tag != '<'){\n\t\t\ttag++;\n\t\t}\n\t\tif (*(tag + 1) == '/'){\n\t\t\treturn (Parent);\n\t\t}\n\t\telse {\n\t\t\tParent->child.push_back(input(tag));\n\t\t\twhile (*tag != '/') tag++;\n\t\t}\n\t}\n\t\n\treturn (Parent);\n}\n\n\t\nint main(void)\n{\n\tWindow *Main;\n\tchar tag[1001];\n\tint n;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%s\", tag);\n\t\tMain = input(tag);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tWindow* output;\n\t\t\t\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\toutput = Main->Click(x, y);\n\t\t\tif (output == NULL){\n\t\t\t\tprintf(\"OUT OF MAIN PANEL 1\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%s %d\\n\", output->name, output->child.size());\n\t\t\t}\n\t\t}\n\t\t\n\t\tdelete Main;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct Panel {\n    string name;\n    int x1, y1, x2, y2;\n    vector<Panel> child;\n     \n    Panel(){}    \n    Panel(string name, int x1, int y1, int x2, int y2) :\n        name(name), x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n \nstring s;\nint idx;\n \nstring get_name()\n{\n    string name;\n    ++idx;\n    while (s[idx] != '>') {\n        name += s[idx];\n        ++idx;\n    }\n    ++idx;\n    return name;\n}\n \nint s2i(string &str)\n{\n    stringstream ss(str);\n    int num;\n    ss >> num;\n    return num;\n}\n \nint get_val()\n{\n    string val;\n    while (isdigit(s[idx])) {\n        val += s[idx];\n        ++idx;\n    }\n    return s2i(val);\n}\n \nvoid parse(Panel &p)\n{\n    while (s[idx] == '<' && s[idx+1] != '/') {\n        string name = get_name();\n        int x1 = get_val(); ++idx;\n        int y1 = get_val(); ++idx;\n        int x2 = get_val(); ++idx;\n        int y2 = get_val();\n        Panel panel(name, x1, y1, x2, y2);\n        parse(panel);\n        p.child.push_back(panel);\n        while (s[idx] != '>') {\n            idx++;\n        }\n        idx++;\n    }    \n}\n \nbool get_panel(int x, int y, const Panel &p)\n{\n    for (int i = 0; i < (int)p.child.size(); i++) {\n        Panel np = p.child[i];\n        if (np.x1 <= x && x <= np.x2 && np.y1 <= y && y <= np.y2) {\n            if (!get_panel(x, y, np)) {\n                cout << np.name << \" \" << np.child.size() << endl;\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n \nint main()\n{\n    int n, x, y;\n    while (cin >> n >> s, n) {\n        Panel p;\n        idx = 0;\n        parse(p);\n        for (int i = 0; i < n; i++) {\n            cin >> x >> y;\n            if (!get_panel(x, y, p)) {\n                cout << \"OUT OF MAIN PANEL 1\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\n\nint n;\nstring line;\n\nmap<string,int> strCnt;\n\nstring point(int x,int y,string field){\n\n\tbool cont=false;\n\tint s;\n\tint f;\n\tbool isFirstname=true;\n\tstring firstName=\"\";\n\tstring name;\n\n\tfor(int i = 0; i < field.size(); i++){\n\t\tif(field[i]=='<'){\n\t\t\ts=i+1;\n\t\t}\n\t\telse if(field[i]=='>'){\n\t\t\tname = field.substr(s,i-s);\n\t\t\tfirstName=name;\n\t\t\t// gðÆè¾·\n\t\t\tfield=field.substr(name.size()+2,field.size()-2*(name.size()+2)-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// ÀWðØèæè\n\tstring points;\n\tstring back;\n\tbool fff=false;\n\tfor(int i = 0; i < field.size(); i++){\n\t\tif(field[i]=='<'){\n\t\t\tpoints=field.substr(0,i);\n\t\t\tback=field.substr(i);\n\t\t\tfff=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!fff){\n\t\tpoints=field;\n\t}\n\tint bc=0;\n\tint cc=0;\n\tvector<int> pp;\n\tfor(int i = 0; i < points.size(); i++){\n\t\tif(points[i]==','){\n\t\t\tbc=cc;\n\t\t\tpp.push_back(atoi(points.substr(bc,i-bc).c_str()));\n\t\t\tcc=i+1;\n\t\t}\n\t}\n\tpp.push_back(atoi(points.substr(cc,points.size()-cc).c_str()));\n\n\tint minx = pp[0];\n\tint miny = pp[1];\n\tint maxx = pp[2];\n\tint maxy = pp[3];\n\n\tif(minx > x || miny > y || maxx < x || maxy < y){\n\t\tif(name==\"main\")\n\t\t\treturn \"OUT OF MAIN PANEL 1\";\n\t\telse\n\t\t\treturn \"\";\n\t}\n\telse{\n\t\t// panelãÉ¢­ÂÌ^Oª é©¦é\n\t\tstring tagName;\n\t\tint sk;\n\t\t// e^Oð½Çé\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < back.size(); i++){\n\t\t\tif(back[i] == '<'){\n\t\t\t\tif(tagName==\"\"){\n\t\t\t\t\tsk=i;\n\t\t\t\t\tfor(int j = i; ;j++){\n\t\t\t\t\t\tif(back[j]=='>'){\n\t\t\t\t\t\t\ttagName=back.substr(i+1,j-i-1);\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(back[i+1]!='/')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint fk;\n\t\t\t\t\tstring ts;\n\t\t\t\t\tfor(int j = i; ;j++){\n\t\t\t\t\t\tif(back[j]=='>'){\n\t\t\t\t\t\t\tts=back.substr(i+1,j-i-1);\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t\tfk=j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.substr(1)==tagName){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\ttagName=\"\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstrCnt[name]=cnt;\n\t\ttagName=\"\";\n\t\t// e^Oð½Çé\n\t\tfor(int i = 0; i < back.size(); i++){\n\t\t\tif(back[i] == '<'){\n\t\t\t\tif(tagName==\"\"){\n\t\t\t\t\tsk=i;\n\t\t\t\t\tfor(int j = i; ;j++){\n\t\t\t\t\t\tif(back[j]=='>'){\n\t\t\t\t\t\t\ttagName=back.substr(i+1,j-i-1);\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(back[i+1]!='/')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint fk;\n\t\t\t\t\tstring ts;\n\t\t\t\t\tfor(int j = i; ;j++){\n\t\t\t\t\t\tif(back[j]=='>'){\n\t\t\t\t\t\t\tts=back.substr(i+1,j-i-1);\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t\tfk=j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.substr(1)==tagName){\n\t\t\t\t\t\tstring ret=point(x,y,back.substr(sk,fk-sk+1));\n\t\t\t\t\t\tif(ret!=\"\")\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\ttagName=\"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tstring retStrTmp = name + \" \";\n\tstringstream ss;\n\tss << strCnt[name];\n\tretStrTmp += ss.str();\n\treturn retStrTmp;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tcin>>line;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcout<<point(x,y,line)<<endl;\n\t\t}\n\t\tstrCnt.clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nstruct P{\n  string name;\n  int x,y,w,h;\n  vector<P> v;\n};\n\nstring tab=\"\";\nvoid pr(P p ){\n  tab += \" \";\n  cout << tab << p.name << \" \"<<p.x << \",\"<<p.y<<\",\"<<p.w<<\",\"<<p.h << endl;\n  for( unsigned int i=0;i<p.v.size();i++ )\n    pr( p.v[i] );\n  tab = tab.substr( 1 );\n}\n\n\nP parse( string s ){\n  P p;\n  unsigned int i=1,j;\n  char c[10];\n  p.name=\"\";\n  while( s[i]!='>' ) p.name += s[i++];\n  i++;\n  j=0; while( s[i]!=',' ) c[j++]=s[i++];\n  c[j]='\\0'; i++; p.x = atoi( c );\n  j=0; while( s[i]!=',' ) c[j++]=s[i++];\n  c[j]='\\0'; i++; p.y = atoi( c );\n  j=0; while( s[i]!=',' ) c[j++]=s[i++];\n  c[j]='\\0'; i++; p.w = atoi( c );\n  j=0; while( s[i]!='<' ) c[j++]=s[i++];\n  c[j]='\\0'; p.h = atoi( c );\n\n  if( s[i+1]=='/' )\n    i+= ( p.name.length() + 3 );  // name+ '</>'\n\n  while( i<s.length() ){\n    int st = i;\n    string nm=\"\";\n    for( j=st+1; s[j]!='>' ;j++ ) nm+=s[j];\n    if( nm==\"/\"+p.name ) break;\n\n    i = s.find( nm, j );\n    i += (nm.length()+1);\n    p.v.push_back( parse(s.substr( st,i-st )) );\n  }\n  return p;\n}\n\nconst string nf=\"OUT OF MAIN PANEL 1\";\n\nstring search( int x,int y, P p){\n  string rslt;\n  if( p.x<= x && x<=p.w &&\n      p.y<= y && y<=p.h ){\n    for( unsigned int i=0;i<p.v.size();i++ ){\n      rslt = search( x,y,p.v[i] );\n      if( rslt!=nf )\n\treturn rslt;\n    }\n    rslt = p.name + \" \";\n    int size = p.v.size(), k=10000;\n\n    if( size>0 ){\n      while( size/k==0 ) k/=10;\n      while( size>0 ){\n\tint d = size/k;\n\tsize = size % k;\n\tk/=10;\n\tchar c='0'+d;\n\trslt += c;\n      }\n    }else\n      rslt += '0';\n\n    return rslt;\n  }else\n    return nf;\n}\n\n\nint main(){\n  P p;\n  int n,x,y;\n  string s;\n\n  while( cin>>n && n ){\n    cin >> s;\n    p = parse( s );\n\n    //    pr( p );\n\n    for( int lp=0;lp<n;lp++ ){\n      cin >> x>>y;\n      cout << search( x,y,p ) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nint f(){\n\tif( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tss >> w[0] >> w[1] >> w[2] >> w[3];\n\n\t\tV.push_back(w);\n\t\tname.push_back(s);\n\t\t\n\t\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\tf();\n\t\t}\n\t}\n\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\t\n\twhile(ln[p] != '>')p++;\n\tp++;\n\t\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tint fst = 0;\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tif( (v[2]-v[0])*(v[3]-v[1]) < ok ){\n\t\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\t\tidx = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tvector<int> &vv = V[idx];\n\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] ){\n\t\t\t\t\tif( vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << name[idx] << \" \" << c << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  if(now.foo.size()) return false;\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n\n  bool flag = true;\n  while(flag){\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n  return make_pair( now.name,/* rec(now, panel) */ 0);\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n  Data Main;\n  Cursol crl;\n\n  while(cin >> n, n){\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nint f(int dep = 0){\n\t//if( ln[p] != '~' && ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tss >> w[0] >> w[1] >> w[2] >> w[3];\n\n\t\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\tf(dep+1);\n\t\t}\n\t//}\n\tV.push_back(w);\n\tname.push_back(s);\n\t\t\n\tif( ln[p] == '~' ) return 0;\n\tp++;\n\tp++;\n\tstring cnt;\n\twhile(ln[p] != '>')cnt += ln[p++];\n\tp++;\n\tassert(cnt == s);\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"~\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tint fst = 0;\n\t\tassert(ln[p] == '~');\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\tidx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tvector<int> &vv = V[idx];\n\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] ){\n\t\t\t\t\tif( vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cc = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tfor(int k = j+1 ; k < V.size() ; k++){\n\t\t\t\t\tvector<int> &v = V[j];\n\t\t\t\t\tvector<int> &vv = V[k];\n\t\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] && vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\t\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif( v[2] < vv[0] || vv[2] < v[0]) continue;\n\t\t\t\t\t\tif( v[3] < vv[1] || vv[3] < v[1]) continue;\n\t\t\t\t\t\t\tcc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(cc==0);\n\t\t\tcout << name[idx] << \" \" << c << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\nusing namespace std;\n\ntypedef tuple<int,int,int,int> T;\ntypedef pair<string,T> P;\nstring str;\nint p;\n\nP TagStruct();\nstring OpenTag();\nstring CloseTag();\nstring TagName();\nT TagValue();\n\nP TagStruct() {\n  string op = OpenTag();\n  T t = TagValue();\n  while (str[p] == '<' and str[p+1] != '/') {\n    :w"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint tag[1000][4];\nstring name[1000];\nint ar[1000];\n\nint main() {\n\tint n,t;\n\tstring str;\n\tIL{\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>str;\n\t\tt=0;\n\t\trep(i,sz(str)){\n\t\t\tif(str[i]=='<'&&str[i+1]!='/'){\n\t\t\t\tint j;\n\t\t\t\tname[i]=\"\";\n\t\t\t\trepn0(j,i+1,sz(str)){\n\t\t\t\t\tif(str[j]=='>')break;\n\t\t\t\t\tname[t]+=str[j];\n\t\t\t\t}\n\t\t\t\tint c;\n\t\t\t\trep(k,4){\n\t\t\t\t\t++j;\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(;;++j){\n\t\t\t\t\t\tif(!isdigit(str[j]))break;\n\t\t\t\t\t\tc=c*10+str[j]-'0';\n\t\t\t\t\t}\n\t\t\t\t\ttag[t][k]=c;\n\t\t\t\t}\n\t\t\t\tar[t]=(tag[t][2]-tag[t][0])*(tag[t][3]-tag[t][1]);\n\t\t\t\t++t;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tint top=-1;\n\t\t\tint area=INF;\n\t\t\trep(j,t){\n\t\t\t\tif(tag[j][0]<=x&&x<=tag[j][2]&&tag[j][1]<=y&&y<=tag[j][3]){\n\t\t\t\t\tif((tag[j][2]-tag[j][0])*(tag[j][3]-tag[j][1])<area){\n\t\t\t\t\t\tarea=ar[j];\n\t\t\t\t\t\ttop=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(top!=-1){\n\t\t\t\tint count=0;\n\t\t\t\trep(j,t){\n\t\t\t\t\tif(tag[top][0]<tag[j][0]&&tag[j][0]<tag[top][2]&&tag[top][1]<tag[j][1]&&tag[j][1]<tag[top][3]){\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\trep0(k,t){\n\t\t\t\t\t\t\tif(ar[top]<=ar[k])continue;\n\t\t\t\t\t\t\tif(tag[k][0]<tag[j][0]&&tag[j][0]<tag[k][2]&&tag[k][1]<tag[j][1]&&tag[j][1]<tag[k][3])break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==t)++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<name[top]<<\" \"<<count<<endl;\n\t\t\t}else{\n\t\t\t\tint count=0;\n\t\t\t\trep(j,t){\n\t\t\t\t\tif(-1<tag[j][0]&&tag[j][0]<10001&&-1<tag[j][1]&&tag[j][1]<10001){\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\trep0(k,t){\n\t\t\t\t\t\t\tif(tag[k][0]<tag[j][0]&&tag[j][0]<tag[k][2]&&tag[k][1]<tag[j][1]&&tag[j][1]<tag[k][3])break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==t)++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<\"OUT OF MAIN PANEL \"<<count<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(const Data& now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y,const Data& panel){\n  string top;\n\n  Data now = panel;\n  int cnt = 0;\n\n\n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n\n  bool flag = true;\n  while(flag){\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n  Data Main; //メインパネル\n\n  Cursol crl;\n\n  cin >> n;\n  cin >> tag;\n\n  Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n\n  \n  while(n--){\n    int x, y;\n    cin >> x >> y;\n    pair< string , int > ans = solve( x, y, Main);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "// 21:12\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstring ln;\nint p;\nvector< vector<int> > V;\nvector<string> name;\nint f(){\n\twhile( ln[p] == '<' && ln[p+1] != '/'){\n\t\t\n\t\tp++;\n\t\tstring s;\n\t\twhile(ln[p] != '>'){\n\t\t\ts += ln[p++];\n\t\t}\n\t\tp++;\n\t\tint c = 0;\n\t\tvector<int> w(4);\n\t\tstringstream ss;\n\t\tstring t;\n\t\twhile(ln[p] != '<'){\n\t\t\tt += ln[p++];\n\t\t}\n\t\tfor(int i = 0 ; i < t.size() ; i++) if( t[i] == ',' ) t[i] = ' ';\n\t\tss << t;\n\t\tss >> w[0] >> w[1] >> w[2] >> w[3];\n\t\t\n\t\tV.push_back(w);\n\t\tname.push_back(s);\n\t\tf();\n\t}\n\tp++;\n\t\n\tif( ln[p] == '/' ) return 0;\n\twhile(ln[p] != '>')p++;\n\tp++;\n\t\n\treturn 0;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcin >> ln;\n\t\tln += \"////\";\n\t\tp = 0;\n\t\tV.clear();\n\t\tname.clear();\n\t\tf();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint ok = 1e9 , idx = -1 , c = 0;\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tif( v[0] <= x && x <= v[2] && v[1] <= y && y <= v[3] ){\n\t\t\t\t\tif( (v[2]-v[0])*(v[3]-v[1]) < ok ){\n\t\t\t\t\t\tok = (v[2]-v[0])*(v[3]-v[1]);\n\t\t\t\t\t\tidx = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx == -1 ){ cout << \"OUT OF MAIN PANEL 1\" << endl; continue; }\n\t\t\tfor(int j = 0 ; j < V.size() ; j++){\n\t\t\t\tvector<int> &v = V[j];\n\t\t\t\tvector<int> &vv = V[idx];\n\t\t\t\tif( vv[0] < v[0] && v[2] < vv[2] ){\n\t\t\t\t\tif( vv[1] < v[1] && v[3] < vv[3] ){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << name[idx] << \" \" << c << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Panel;\n\nstruct Panel {\n    string name;\n    int x1, y1, x2, y2;\n    vector<Panel> child;\n    \n    Panel(){}    \n    Panel(string name, int x1, int y1, int x2, int y2) :\n        name(name), x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstring s;\nint idx;\n\nstring get_name()\n{\n    string name;\n    ++idx;\n    while (s[idx] != '>') {\n        name += s[idx];\n        ++idx;\n    }\n    ++idx;\n    return name;\n}\n\nint s2i(string &str)\n{\n    stringstream ss(str);\n    int num;\n    ss >> num;\n    return num;\n}\n\nint get_val()\n{\n    string val;\n    while (isdigit(s[idx])) {\n        val += s[idx];\n        ++idx;\n    }\n    return s2i(val);\n}\n\nvoid parse(Panel &p)\n{\n    while (s[idx] == '<' && s[idx+1] != '/') {\n        string name = get_name();\n        int x1 = get_val(); ++idx;\n        int y1 = get_val(); ++idx;\n        int x2 = get_val(); ++idx;\n        int y2 = get_val();\n        Panel panel(name, x1, y1, x2, y2);\n        parse(panel);\n        p.child.push_back(panel);\n        while (s[idx] != '>') {\n            idx++;\n        }\n        idx++;\n    }    \n}\n\nbool get_panel(int x, int y, const Panel &p)\n{\n    for (int i = 0; i < (int)p.child.size(); i++) {\n        Panel np = p.child[i];\n        if (np.x1 <= x && x <= np.x2 && np.y1 <= y && y <= np.y2) {\n            if (!get_panel(x, y, np)) {\n                cout << np.name << \" \" << np.child.size() << endl;\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int n, x, y;\n    while (cin >> n >> s, n) {\n        Panel p;\n        p.name = \"#\"; p.x1 = p.y1 = -1; p.x2 = p.y2 = 10001;\n        idx = 0;\n        parse(p);\n        for (int i = 0; i < n; i++) {\n            cin >> x >> y;\n            if (!get_panel(x, y, p)) {\n                cout << \"OUT OF MAIN PANEL 1\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<stdio.h>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<Panel> v;\n};\n\nint fp;\n\nPanel parse(string s){\n\tPanel p;\n\tint ep=0;\n\twhile(s[fp] != '>'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.name = s.substr(fp-ep,ep);\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x1 = toInt(s.substr(fp-ep,ep));\n\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y1 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x2 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != '<'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y2 = toInt(s.substr(fp-ep,fp-1));\n\t\n\tfp++;\n\twhile(1){\n\t\tif(s[fp]=='/'){ fp+=p.name.size()+3; break;}\n\t\telse p.v.push_back(parse(s));\n\t}\t\n\treturn p;\n}\n\nPanel search(int x,int y,Panel r_p,Panel p){\n\tif(p.x1 <= x && p.x2 >= x && p.y1 <= y && p.y2 >= y){\n\t\tPanel ans=p;\n\t\trep(i,p.v.size()){\n\t\t\tPanel tmp = search(x,y,p,p.v[i]);\n\t\t\tif(tmp.name != p.name) ans = p.v[i];\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\treturn r_p;\n}\n\nint main(){\n\n\twhile(1){\n\t\tint n;\n\t\tstring str;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> str;\n\t\tcout << str << endl;\n\t\tfp=1;\n\t\tPanel p = parse(str);\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tPanel root;root.name=\"-1\";\n\t\t\tPanel ans=search(x,y,root,p);\n\t\t\tif(ans.name==\"-1\") cout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t\telse cout << ans.name << \" \" << ans.v.size() << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  vector<Panel> child;\n};\n\nint i=0;\npair<string,int>ans;\nint maxDepth;\n\nPanel parse(string s)\n{\n  i++;\n  Panel p={\"\",0,0,0,0};\n  if(i>=s.size())return p;\n  for(;s[i]!='>';i++)p.name+=s[i];\n  char c;\n  stringstream ss;\n  ss.str(s.substr(i+1,s.size()-i-1));\n  ss>>p.x1>>c>>p.y1>>c>>p.x2>>c>>p.y2;\n  while(s[i]!='<')i++;\n  while(s[i+1]!='/')p.child.push_back(parse(s));\n  while(s[i]!='>')i++;\n  i++;\n  return p;\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n  if(x<p.x1 || p.x2<x || y<p.y1 || p.y2<y)return;\n  if(maxDepth<depth){\n    maxDepth=depth;\n    ans.first=p.name;\n    ans.second=p.child.size();\n  }\n  vector<Panel>::iterator it;\n  for(it=p.child.begin();it!=p.child.end();it++)solve(*it,x,y,depth+1);\n}\n\nint main()\n{\n  int n,x,y;\n  string s;\n  while(cin>>n,n){\n    cin>>s;\n    s=\"<OUT OF MAIN PANEL>-1,-1,10001,10001\"+s+\"</OUT OF MAIN PANEL>\";\n    Panel p=parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      solve(p,x,y,0);\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  vector<Panel> child;\n};\n\nint i=0;\npair<string,int>ans;\nint maxDepth;\n\nPanel parse(string s)\n{\n  Panel p={\"\",0,0,0,0};\n  for(i++;s[i]!='>';i++)p.name+=s[i];\n  char c;\n  stringstream ss;\n  ss.str(s.substr(i+1,s.size()-i-1));\n  ss>>p.x1>>c>>p.y1>>c>>p.x2>>c>>p.y2;\n  while(s[i]!='<')i++;\n  while(s[i+1]!='/')p.child.push_back(parse(s));\n  while(s[i]!='>')i++;\n  i++;\n  return p;\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n  if(x<p.x1 || p.x2<x || y<p.y1 || p.y2<y)return;\n  if(maxDepth<depth){\n    maxDepth=depth;\n    ans.first=p.name;\n    ans.second=p.child.size();\n  }\n  for(int i=0;i<p.child.size();i++)solve(p.child[i],x,y,depth+1);\n}\n\nint main()\n{\n  int n,x,y;\n  string s;\n  while(cin>>n,n){\n    cin>>s;\n    s=\"<OUT OF MAIN PANEL>-1,-1,10001,10001\"+s+\"</OUT OF MAIN PANEL>\";\n    Panel p=parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      solve(p,x,y,0);\n      if(ans.first==\"OUT OF MAIN PANEL\")ans.second=1;\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nnamespace parser {\n\ntypedef string::const_iterator Iter;\nIter __begin, __end;\nIter __it;\n\nvoid remain_dump() {\n  cout << \"Remain: '\" << string(__it, __end) << \"'\" << endl;\n}\n\nvoid init_iterator(Iter begin, Iter end) {\n  __begin = begin;\n  __end = end;\n  __it = begin;\n}\n\nvoid consume(char expected) {\n  assert(__end != __it);\n  if(*__it != expected) {\n    remain_dump();\n    assert(false);\n  }\n  __it ++;\n}\n\nbool consume_if(char expected) {\n  if(*__it != expected) return false;\n  consume(expected);\n  return true;\n}\n\nvoid unread() {\n  assert(__it != __begin);\n  __it --;\n}\n\nbool eof() {\n  return __it == __end;\n}\n\nvoid append(int& tar, char add) { tar *= 10; tar += add - '0'; }\nvoid append(string& tar, char add) { tar += add; }\n\nenum readable { alphabetical = 1<<0, integer = 1<<1 };\nenum class lexstat { no_stat = -1, read_eof, success };\n\nlexstat lstat = lexstat::no_stat;\n\ntemplate<class return_type>\nreturn_type lex(readable rd, vector<char> const& skipper = {}, vector<char> const& excepts = {}) {\n\n  auto can_go = [&](char c) {\n    if(find(skipper.begin(), skipper.end(), c) != skipper.end()) return false;\n    if(find(excepts.begin(), excepts.end(), c) != excepts.end()) return true;\n    if((rd & alphabetical) && isalpha(c)) return true;\n    if((rd & integer) && isdigit(c)) return true;\n    return false;\n  };\n\n  if(!can_go(*__it)) {\n    lstat = lexstat::read_eof;\n    return return_type{};\n  }\n\n  return_type ret{};\n  while(can_go(*__it))\n    append(ret, *__it), consume(*__it);\n\n  lstat = lexstat::success;\n\n  return ret;\n}\n\nvoid lex_f(string const& force) {\n  for(auto c: force)\n    consume(c);\n}\n\nvoid lex_f(int force) {\n  lex_f(to_string(force));\n}\n\ntemplate<class return_type>\nvector<return_type> lex_stream(readable rd, vector<char> const& skipper, vector<char> const& excepts = {}) {\n  vector<return_type> ret;\n  while(1) {\n    auto r = lex<return_type>(rd, skipper, excepts);\n    if(lstat == lexstat::read_eof) break;\n    ret.push_back(r);\n    if(find(skipper.begin(), skipper.end(), *__it) != skipper.end()) {\n      consume(*__it);\n    }\n  }\n  return ret;\n}\n\nbool look_ahead(string const& expected) {\n  int n = expected.size();\n  int i = 0;\n  while(i < n) {\n    if(!consume_if(expected[i])) break;\n    i ++;\n  }\n\n  if(i == n) {\n    while(i--) unread();\n    return true;\n  }\n\n  while(i--) unread();\n  return false;\n}\n\n}\nusing namespace parser;\n\n#define DEF_PARSER(ast, property_definitions, root_settings) \\\nstruct ast {  \\\n  property_definitions; \\\n  vector<shared_ptr<ast>> children; \\\n};  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p); \\\nshared_ptr<const ast> parse_ ## ast(Iter begin, Iter end) { \\\n  init_iterator(begin, end);  \\\n  auto p = make_shared<xml>();  \\\n  root_settings; \\\n  return parse_ ## ast(p);  \\\n}\n\n#define PARSE(ast, tar) \\\n  parse_ ## ast(begin(tar), end(tar))\n\n#define PARSER_IMPL(ast, start_cond)  \\\nshared_ptr<ast> parse_ ## ast(shared_ptr<ast>& p) { \\\n  while(!eof()) { \\\n    if (start_cond) {\n#define HEAD(str) look_ahead(str)\n#define CHANCE(cond)  \\\n      return p; \\\n } else if(cond) {\n\n#define END_PARSER_IMPL \\\n  }} \\\n  return p; \\\n}\n\n#define prop(pr) p->pr\n#define cprop(pr) c->pr\n\n#define RECUR(ast, property_settings)  \\\nauto c = make_shared<ast>(); \\\nproperty_settings;  \\\np->children.push_back(c); \\\nparse_ ## ast(p);\n\n#define ast_ref(const_ast) shared_ptr<const const_ast> const& __ast_ref_p\n#define enumerate_children(c)  \\\n  for(auto && c: __ast_ref_p->children)\n\n#define ref_prop(pr) __ast_ref_p->pr\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nDEF_PARSER(xml,\n  string tag;\n  vector<int> nums;\n  ,\n  prop(tag) = \"OUT OF MAIN PANEL\"\n)\n\nPARSER_IMPL(xml,\n  HEAD(\"</\"))\n    lex_f(\"</\" + p->tag + \">\"); CHANCE(\n  HEAD(\"<\"))\n    RECUR(xml,\n      cprop(tag)  = lex<string>(alphabetical, {}, {'<','>'});\n      cprop(tag)  = c->tag.substr(1, c->tag.size()-2);\n      cprop(nums) = lex_stream<int>(integer, {','});\n    )\nEND_PARSER_IMPL\n\n\npair<string, int> dfs(ast_ref(xml), int x, int y) {\n  enumerate_children(c)\n    if(c->nums[0] <= x && c->nums[1] <= y && x <= c->nums[2] && y <= c->nums[3])\n      return dfs(c, x, y);\n\n  return {ref_prop(tag), ref_prop(children.size())};\n}\n\nint main() {\n\n  for(int T; cin >> T;) {\n    string str; cin >> str;\n    auto root = PARSE(xml, str);\n    while(T--) {\n      int x, y; cin >> x >> y;\n      auto r = dfs(root, x, y);\n      cout << r.first << \" \" << r.second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstruct Panel{\n  string name;\n  int x1,y1,x2,y2;\n  vector<Panel> child;\n};\n\nint i=0;\npair<string,int>ans;\nint maxDepth;\n\nPanel parse(string s)\n{\n  i++;\n  Panel p={\"\",0,0,0,0};\n  if(i>=s.size())return p;\n  for(;s[i]!='>';i++)p.name+=s[i];\n  char c;\n  stringstream ss;\n  ss.str(s.substr(i+1,s.size()-i-1));\n  ss>>p.x1>>c>>p.y1>>c>>p.x2>>c>>p.y2;\n  while(s[i]!='<')i++;\n  while(s[i+1]!='/')p.child.push_back(parse(s));\n  while(s[i]!='>')i++;\n  i++;\n  return p;\n}\n\nvoid solve(Panel p, int x, int y, int depth)\n{\n  if(x<p.x1 || p.x2<x || y<p.y1 || p.y2<y)return;\n  if(maxDepth<depth){\n    ans.first=p.name;\n    ans.second=p.child.size();\n    vector<Panel>::iterator it;\n    for(it=p.child.begin();it!=p.child.end();it++)solve(*it,x,y,depth+1);\n  }\n}\n\nint main()\n{\n  int n,x,y;\n  string s;\n  while(cin>>n,n){\n    cin>>s;\n    s=\"<OUT OF MAIN PANEL>-1,-1,10001,10001\"+s+\"</OUT OF MAIN PANEL>\";\n    Panel p=parse(s);\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      maxDepth=-1;\n      ans.first=\"\";\n      ans.second=0;\n      solve(p,x,y,0);\n      cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct panel {\n  char name[1001];\n  int x1, y1;\n  int x2, y2;\n  vector<panel> child;\n};\n\nvoid parse(panel &p, char tag[])\n{\n  while(1){\n    char tmp[1100];\n    sscanf(tag, \"<%[^>]>%s\", tmp, tag);\n    char aaa[1100] = \"/\";\n    strcat(aaa, p.name);\n    if(strcmp(aaa, tmp) == 0) return;\n    panel c;\n    char next[1100];\n    strcpy(c.name, tmp);\n    sscanf(tag, \"%d,%d,%d,%d%s\", &c.x1, &c.y1, &c.x2, &c.y2, next);\n    //cout << c.name << \" \" << next << endl;\n    parse(c, next);\n    strcpy(tag, next);\n    p.child.push_back(c);\n  }\n}\n\nbool inPanel(panel &p, int x, int y)\n{\n  if(p.x1 <= x && x <= p.x2 && p.y1 <= y && y <= p.y2){\n    for(int i = 0; i < p.child.size(); i++){\n      if(inPanel(p.child[i], x, y)) return true;\n    }\n    if(strcmp(p.name, \"#$%123\") == 0) return false;\n    cout << p.name << \" \" << p.child.size() << endl;\n    return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n, n){\n    panel app;\n    char tag[1100];\n    scanf(\"%s\", tag);\n    strcpy(app.name, \"#$%123\");\n    app.x1 = -1; app.y1 = -1;\n    app.x2 = 10001; app.y2 = 10001;\n    strcat(tag, \"</#$%123>\");\n    parse(app, tag);\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      if(!inPanel(app, x, y)) cout << \"OUT OF MAIN PANEL 1\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nstruct DATA{\n  string name;\n  int x1, y1, x2, y2;\n  set<int> next;\n};\n\nvoid ConvertData(string&, vector<DATA>&, int);\nvoid ConvertDataInner(const string, string, DATA&);\nint AtoiString(const string);\nint TouchPanel(int, int, int, vector<DATA>&);\n\nint main(){\n  int i, n, x, y, ans;\n  string str;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    cin >> str;\n    vector<DATA> data(1);\n    ConvertData(str, data, 0);\n\n    for(i=0; i<n; ++i){\n      cin >> x >> y;\n      ans = TouchPanel(x, y, 0, data);\n      if(ans == -1)\n\tcout << \"OUT OF MAIN PANEL 1\" << endl;\n      else\n\tcout << data[ans].name << \" \" << data[ans].next.size() << endl;\n    }\n  }\n  return 0;\n}\n\nvoid ConvertData(string& str, vector<DATA>& data, int x){\n  DATA _data;\n  string::iterator i, j;\n\n  i = find(str.begin(), str.end(), '>');\n  j = find(i+1, str.end(), '<');\n\n  const string name(str.begin()+1, i);\n  string info(i+1, j);\n  ConvertDataInner(name, info, data[x]);\n  str.erase(str.begin(), j);\n\n  while(1){\n    i = find(str.begin(), str.end(), '>');\n    const string name(str.begin()+1, i);\n    if(name == \"/\" + data[x].name){\n      str.erase(str.begin(), i+1);\n      return;\n    }\n    data.push_back(_data);\n    ConvertData(str, data, data.size()-1);\n    data[x].next.insert(data.size()-1);\n  }\n}\n\nvoid ConvertDataInner(const string name, string str, DATA& data){\n  string::iterator i, j, k;\n\n  i = find(str.begin(), str.end(), ',');\n  j = find(i+1, str.end(), ',');\n  k = find(j+1, str.end(), ',');\n\n  const string x1(str.begin(), i);\n  const string y1(i+1, j);\n  const string x2(j+1, k);\n  const string y2(k+1, str.end());\n\n  data.name = name;\n  data.x1 = AtoiString(x1);\n  data.y1 = AtoiString(y1);\n  data.x2 = AtoiString(x2);\n  data.y2 = AtoiString(y2);\n  data.next.clear();\n}\n\nint AtoiString(const string s){\n  int i, x, d;\n  for(i=s.size()-1, x=0, d=1; i>=0; --i, d*=10)\n    x += ((s[i] - 48) * d);\n  return x;\n}\n\nint TouchPanel(int x, int y, int n, vector<DATA>& data){\n  if(data[n].x1 <= x && x <= data[n].x2 && data[n].y1 <= y && y <= data[n].y2){\n    int m;\n    set<int>::iterator i;\n    for(i=data[n].next.begin(); i!=data[n].next.end(); ++i){\n      m = TouchPanel(x, y, *i, data);\n      if(m != -1) return m;\n    }\n    return n;\n  }else{\n    return -1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<stdio.h>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<Panel> v;\n};\n\nint fp=1;\n\nPanel parse(string s){\n\tPanel p;\n\tint ep=0;\n\twhile(s[fp] != '>'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.name = s.substr(fp-ep,ep);\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x1 = toInt(s.substr(fp-ep,ep));\n\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y1 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x2 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != '<'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y2 = toInt(s.substr(fp-ep,fp-1));\n\t\n\tfp++;\n\twhile(1){\n\t\tif(s[fp]=='/'){ fp+=p.name.size()+3; break;}\n\t\telse p.v.push_back(parse(s));\n\t}\t\n\treturn p;\n}\n\nPanel search(int x,int y,Panel r_p,Panel p){\n\tif(p.x1 <= x && p.x2 >= x && p.y1 <= y && p.y2 >= y){\n\t\tPanel ans=p;\n\t\trep(i,p.v.size()){\n\t\t\tPanel tmp = search(x,y,p,p.v[i]);\n\t\t\tif(tmp.name != p.name) ans = p.v[i];\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\treturn r_p;\n}\n\nint main(){\n\t\n\tint n;\n\tstring str;\n\tcin >> n;\n\tcin >> str;\n\n\tPanel p = parse(str);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tPanel root;root.name=\"-1\";\n\t\tPanel ans=search(x,y,root,p);\n\t\tif(ans.name==\"-1\") cout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\telse cout << ans.name << \" \" << ans.v.size() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint tag[1111][4];\nstring name[1111];\nint ar[1111];\n\nint main() {\n\tint n,t;\n\tstring str;\n\tIL{\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>str;\n\t\tt=0;\n\t\trep(i,sz(str)){\n\t\t\tif(str[i]=='<'&&str[i+1]!='/'){\n\t\t\t\tint j;\n\t\t\t\tname[i]=\"\";\n\t\t\t\trepn0(j,i+1,sz(str)){\n\t\t\t\t\tif(str[j]=='>')break;\n\t\t\t\t\tname[t]+=str[j];\n\t\t\t\t}\n\t\t\t\tint c;\n\t\t\t\trep(k,4){\n\t\t\t\t\t++j;\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(;;++j){\n\t\t\t\t\t\tif(!isdigit(str[j]))break;\n\t\t\t\t\t\tc=c*10+str[j]-'0';\n\t\t\t\t\t}\n\t\t\t\t\ttag[t][k]=c;\n\t\t\t\t}\n\t\t\t\tar[t]=(tag[t][2]-tag[t][0])*(tag[t][3]-tag[t][1]);\n\t\t\t\t++t;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tint top=-1;\n\t\t\tint area=INF;\n\t\t\trep(j,t){\n\t\t\t\tif(tag[j][0]<=x&&x<=tag[j][2]&&tag[j][1]<=y&&y<=tag[j][3]){\n\t\t\t\t\tif(ar[j]<area){\n\t\t\t\t\t\tarea=ar[j];\n\t\t\t\t\t\ttop=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(top!=-1){\n\t\t\t\tint count=0;\n\t\t\t\trep(j,t){\n\t\t\t\t\tif(tag[top][0]<tag[j][0]&&tag[j][0]<tag[top][2]&&tag[top][1]<tag[j][1]&&tag[j][1]<tag[top][3]){\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\trep0(k,t){\n\t\t\t\t\t\t\tif(ar[top]<=ar[k])continue;\n\t\t\t\t\t\t\tif(tag[k][0]<tag[j][0]&&tag[j][0]<tag[k][2]&&tag[k][1]<tag[j][1]&&tag[j][1]<tag[k][3])break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==t)++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<name[top]<<\" \"<<count<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\nbool between(int a, int b, int c){\n        return a <= b && b <= c;\n}\n\nvector<string> split(const string &s, char c){\n        vector<string> v;\n        size_t prev = 0, cur;\n        while((cur = s.find(c, prev)) != string::npos){\n                v.push_back(s.substr(prev, cur - prev));\n                prev = cur + 1;\n        }\n        v.push_back(s.substr(prev));\n        return v;\n}\n\nint to_int(const string &s){\n        return atoi(s.c_str());\n}\n\nstruct Node {\n        string name;\n        int left, top, right, bottom;\n        vector<Node> children;\n};\n\nstruct Result {\n        Node node;\n        int p;\n};\n\nResult parse(const string &s, int p){\n        Result r;\n        ++p;\n        size_t t = s.find('>', p);\n        r.node.name = s.substr(p, t - p);\n        p = t + 1;\n        t = s.find('<', p);\n        vector<string> loc = split(s.substr(p, t - p), ',');\n        r.node.left = to_int(loc[0]);\n        r.node.top = to_int(loc[1]);\n        r.node.right = to_int(loc[2]);\n        r.node.bottom = to_int(loc[3]);\n        p = t;\n        while(s[p + 1] != '/'){\n                Result q = parse(s, p);\n                r.node.children.push_back(q.node);\n                p = q.p;\n        }\n        r.p = p + 3 + r.node.name.size();\n        return r;\n}\n\npair<string, int> solve(const Node &n, int x, int y){\n        pair<string, int> r(n.name, n.children.size());\n        for(int i = 0; i < n.children.size(); ++i){\n                const Node &c = n.children[i];\n                if(between(c.left, x, c.right) && between(c.top, x, c.bottom)){\n                        r = solve(c, x, y);\n                        break;\n                }\n        }\n        return r;\n}\n\nint main(){\n        while(true){\n                int n;\n                cin >> n;\n                if(n == 0){ break; }\n                string s;\n                cin >> s;\n                s = \"<OUT OF MAIN PANEL>0,0,10000,10000\" + s + \"</OUT OF MAIN PANEL>\";\n                Node root = parse(s, 0).node;\n                while(n--){\n                        int x, y;\n                        cin >> x >> y;\n                        pair<string, int> answer = solve(root, x, y);\n                        cout << answer.first << \" \" << answer.second << endl;\n                }\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<stdio.h>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<Panel> v;\n};\n\nint fp;\n\nPanel parse(string s){\n\tPanel p;\n\tint ep=0;\n\twhile(s[fp] != '>'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.name = s.substr(fp-ep,ep);\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x1 = toInt(s.substr(fp-ep,ep));\n\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y1 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x2 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != '<'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y2 = toInt(s.substr(fp-ep,fp-1));\n\t\n\tfp++;\n\twhile(1){\n\t\tif(s[fp]=='/'){ fp+=p.name.size()+3; break;}\n\t\telse p.v.push_back(parse(s));\n\t}\t\n\treturn p;\n}\n\nPanel search(int x,int y,Panel r_p,Panel p){\n\tif(p.x1 <= x && p.x2 >= x && p.y1 <= y && p.y2 >= y){\n\t\tif(p.v.size()==0) return p;\t\n\t\trep(i,p.v.size()){\t\n\t\t\tPanel tmp = search(x,y,p,p.v[i]);\n\t\t\tif(tmp.name != p.name ) return tmp;\n\t\t}\n\t\treturn p;\n\t}\n\t\n\treturn r_p;\n}\n\nint main(){\n\n\twhile(1){\n\t\tint n;\n\t\tstring str;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> str;\n\t\tfp=1;\n\t\tPanel p = parse(str);\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tPanel root;root.name=\"-1\";\n\t\t\tPanel ans=search(x,y,root,p);\n\t\t\tif(ans.name==\"-1\") cout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t\telse cout << ans.name << \" \" << ans.v.size() << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\n\nclass AOJ1031{\nprivate:\n  string s;\n  int n;\n  map<string,int> c_num;\n  map<string,PP> coor;\n  vector<string> name_list;\npublic:\n  AOJ1031(int n,string s):n(n),s(s){}\n  ~AOJ1031(){}\n\n  void getChildNumber(){\n    int st,cnt=0;\n    map<string,bool> index;\n    rep(i,s.length()){\n      if(s[i] == '<' && s[i+1] != '/')st = i,cnt++;\n      //else if(s[i] == '>'){\n      //c_num[s.substr(st+1,i-st-1)] = cnt-1;\n      //}\n      else if(s[i] == '/')st = i;\n      else if(s[i] == '>'){\n\t//cout << \"</> = \"<< s.substr(st+1,i-st-1) << \",cnt = \" << cnt << \",pre cnt = \" << c_num[s.substr(st+1,i-1-st)]<< endl; \n\tc_num[s.substr(st+1,i-1-st)] = cnt-c_num[s.substr(st+1,i-1-st)];\n\tif(!index[s.substr(st+1,i-1-st)]){\n\t  name_list.pb(s.substr(st+1,i-1-st));\n\t  index[s.substr(st+1,i-1-st)] = true;\n\t}\n      }\n    }\n  }\n\n  PP getPP(string s){\n    stringstream ss;\n    ss << s;\n    int Pm[4];\n    ss >> Pm[0] >> Pm[1] >> Pm[2] >> Pm[3];\n    return PP(P(Pm[0],Pm[1]),P(Pm[2],Pm[3]));\n  }\n\n  void getCoordinate(){\n\n    bool OK = false;\n    int st;\n    string store;\n    REP(i,0,s.length()){\n      if(s[i] == ','){\n\ts[i] = ' ';\n\tcontinue;\n      }\n\n      if(s[i] == '<' && s[i+1] != '/' && !OK)st = i,OK=true;\n      else if(s[i] == '>' && OK){\n\tstore = s.substr(st+1,i-1-st);\n\tcoor[store] = PP(P(-1,-1),P(-1,-1));\n\tst = i+1;\t\n      }\n      else if(s[i] == '<'){\n\t//cout << \"store = \" << store << \", i =\" << i <<\" - \" << s.substr(i,5) <<\"  ,st = \" << st<< endl;\n\tif(coor[store] != PP(P(-1,-1),P(-1,-1)))continue;\n\tcoor[store] = getPP(s.substr(st,i-st)); \n\tOK = false;\n\tst = i;\n\tif(s[i+1] != '/')OK = true;\n      }\n     \n\n\n    }\n\n  }\n\n\n\n  void run(){\n    getChildNumber();\n    //map<string,int>::iterator it = c_num.begin();\n    //while(it != c_num.end()){\n    //cout << (*it).F << \" - \" << (*it).S << endl;\n    //it++;\n    //}\n    getCoordinate();\n    //rep(i,name_list.size()){\n    //cout << name_list[i] << endl;\n    //}\n    //map<string,PP>::iterator it = coor.begin();\n    //while(it != coor.end()){\n    //cout << (*it).F << \" = \" << (*it).S.F.F << \",\" << (*it).S.F.S << \" - \" << (*it).S.S.F << \",\" << (*it).S.S.S  << endl;\n    //it++;\n    //}\n    rep(i,n){\n      int x,y;\n      cin >> x >> y;\n      bool found = false;\n      string found_name;\n      rep(i,name_list.size()){\n\tstring name = name_list[i];\n\t//cout << \"name = \" << name << \", coor[\" << name << \"] = \"<< coor[name].F.F << \",\" << coor[name].F.S << \" \" << coor[name].F.S << \",\" << coor[name].S.S << endl;\n\tif(coor[name].F.F <= x && x <= coor[name].S.F && coor[name].F.S <= y && y <= coor[name].S.S){\n\t  found_name = name;\n\t  found = true;\n\t}\n      }\n      if(!found)cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else cout << found_name << \" \" << c_num[found_name] << endl;\n\n    }\n\n\n  }\n\n\n};\n\nint main(){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0)break;\n    string s;\n    cin >> s;\n    AOJ1031 ans = AOJ1031(n,s);\n    ans.run();\n\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(const int& x, const int& y, const Data& data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n\n  bool flag = true;\n  while(flag){\n    flag = false;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n\n  Cursol crl;\n\n  while(cin >> n, n){\n    Data Main; //メインパネル\n\n    cin >> tag;\n\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstruct S{\n\tint x1,x2,y1,y2,c;\n\tstring name;\n\tbool contain(int x,int y)\n\t{\n\t\treturn x1<=x&&x<=x2&&y1<=y&&y<=y2;\n\t}\n};\nS pnl[1000];\nint n,m;\nstring in;\n\nint eval(int s,int t)\n{\n\tif(s>=t)return 0;\n\tassert(in[s]=='<');\n\t\n\tint id=m,bt=in.find('>',s),ns=in.find('<',bt+1);\n\tm++;\n\tpnl[id].name=in.substr(s+1,bt-s-1);\n\t\n\tstring tmp=in.substr(bt+1,ns-bt-1);\n\tfr(i,tmp)if(*i==',')*i=' ';\n\tstringstream ss(tmp);\n\tss>>pnl[id].x1>>pnl[id].y1>>pnl[id].x2>>pnl[id].y2;\n\t\n\ttmp=\"</\"+pnl[id].name+\">\";\n\tint es=in.find(tmp,bt),et=es+pnl[id].name.size()+3; assert(s<=es&&es<=t);\n\t\n\tint ret=1;\n\tpnl[id].c=eval(ns,es);\n\tif(et!=t)ret+=eval(et,t);\n\treturn ret;\n}\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tcin>>in;\n\t\tm=0;\n\t\teval(0,in.size())==1;\n\t\trep(i,n)\n\t\t{\n\t\t\tint x,y,id=m; cin>>x>>y;\n\t\t\tfor(;id>=0;id--)if(pnl[id].contain(x,y))break;\n\t\t\t\n\t\t\tif(id<0)cout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\telse cout<<pnl[id].name<<\" \"<<pnl[id].c<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Point{\npublic:\n  string name;  \n  int l,r,u,d,s,ss;\n};\n\nint main(){\n  int i,j,n,x[100],y[100],c,s;\n  Point p[1000];\n  string str;\n  cin >> n;\n  cin >> str;\n  for(i=0;i<n;i++) cin >> x[i] >> y[i];\n\n  c = 0;\n  s = 0;\n\n  for(i=0;i<str.size()-1;i++){\n    if(str[i] == '<' && str[i+1] != '/'){\n      s++;\n      p[c].name = \"\";\n      i++;\n      for(;str[i] != '>';i++) p[c].name += str[i];\n\n      i++;\n      p[c].l = p[c].r = p[c].u = p[c].d = 0;\n\n      for(;str[i] != ',';i++){\n\tp[c].l *= 10;\n\tp[c].l += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != ',';i++){\n\tp[c].u *= 10;\n\tp[c].u += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != ',';i++){\n\tp[c].r *= 10;\n\tp[c].r += str[i] - '0';\n      }\n      i++;\n      for(;str[i] != '<';i++){\n\tp[c].d *= 10;\n\tp[c].d += str[i] - '0';\n      }\n      p[c].s = s;\n      c++;\n      i--;\n    }\n    else if(str[i] == '<' && str[i+1] == '/') s--;\n  }\n  \n  for(i=0;i<c;i++){\n    p[i].ss = 0;\n    for(j=i+1;j<c;j++){\n      if(p[i].s >= p[j].s) break;\n      else if(p[i].s < p[j].s) p[i].ss++;\n    }\n  }\n\n  for(i=0;i<n;i++){\n    Point u,v;\n    bool f = false;\n    for(j=0;j<c;j++){\n      if(p[j].l <= x[i] && x[i] <= p[j].r && p[j].u <= y[i] && y[i] <= p[j].d){\n\tif(!f){\n\t  f = true;\n\t  u = p[j];\n\t}\n\telse{\n\t  v = p[j];\n\t  if(u.s < v.s) u = v;\n\t}\n      }\n    }\n    if(f) cout << u.name << \" \" << u.ss << endl;\n    else cout << \"OUT OF MAIN PANEL 1\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstruct S{\n\tint x1,x2,y1,y2,c;\n\tstring name;\n\tbool contain(int x,int y)\n\t{\n\t\treturn x1<=x&&x<=x2&&y1<=y&&y<=y2;\n\t}\n};\nS pnl[1000];\nint n,m;\nstring in;\n\nint eval(int s,int t)\n{\n\tif(s>=t)return 0;\n\t//dbg(in.substr(s,t-s));\n\tassert(in[s]=='<');\n\t\n\tint id=m,bt=in.find('>',s),ns=in.find('<',bt+1);\n\tm++;\n\tpnl[id].name=in.substr(s+1,bt-s-1);\n\t\n\tstring tmp=in.substr(bt+1,ns-bt-1); //dbg(tmp);\n\tfr(i,tmp)if(*i==',')*i=' ';\n\tstringstream ss(tmp);\n\tss>>pnl[id].x1>>pnl[id].y1>>pnl[id].x2>>pnl[id].y2;\n\t\n\ttmp=\"</\"+pnl[id].name+\">\"; //dbg(tmp);\n\tint es=in.find(tmp,bt),et=es+pnl[id].name.size()+3; assert(s<=es&&es<=t);\n\tpnl[id].c=eval(ns,es);\n\t\n\tint ret=pnl[id].c+1; if(et!=t)ret+=eval(et,t);\n\treturn ret;\n}\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tcin>>in;\n\t\tm=0;\n\t\teval(0,in.size());\n\t\t\n\t\trep(i,n)\n\t\t{\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tint id=m;\n\t\t\tfor(;id>=0;id--)if(pnl[id].contain(x,y))break;\n\t\t\t\n\t\t\tif(id<0)cout<<\"OUT OF MAIN PANEL 1\"<<endl;\n\t\t\telse cout<<pnl[id].name<<\" \"<<pnl[id].c<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct panel {\n\tstring name;\n\tint x1, y1, x2, y2;\n\tvector<panel> children;\n\n\tpanel(const string &name_, int x1_, int y1_, int x2_, int y2_):name(name_), x1(x1_), y1(y1_), x2(x2_), y2(y2_) {}\n\n\tvoid add_child(const panel &p) {\n\t\tchildren.emplace_back(p);\n\t}\n\n\tbool in_range(int x, int y) const {\n\t\treturn x1 <= x && x <= x2 && y1 <= y && y <= y2;\n\t}\n\n\tstring search(int x, int y) const {\n\t\tfor(const auto &child : children) {\n\t\t\tif(child.in_range(x, y)) return child.search(x, y);\n\t\t}\n\t\treturn name + ' ' + to_string(children.size());\n\t}\n};\n\nint number(string::const_iterator &it) {\n\tassert(isdigit(*it));\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + *it - '0';\n\t\t++it;\n\t}\n\treturn res;\n}\n\npanel parse(string::const_iterator &it) {\n\tassert(*it == '<');\n\t++it;\n\n\tstring name;\n\twhile(*it != '>') {\n\t\tname += *it;\n\t\t++it;\n\t}\n\t++it;\n\n\tconst int x1 = number(it);\n\tassert(*it == ',');\n\t++it;\n\tconst int y1 = number(it);\n\tassert(*it == ',');\n\t++it;\n\tconst int x2 = number(it);\n\tassert(*it == ',');\n\t++it;\n\tconst int y2 = number(it);\n\n\tpanel res(name, x1, y1, x2, y2);\n\twhile(true) {\n\t\tassert(*it == '<');\n\t\tif(*(it + 1) == '/') break;\n\t\tres.add_child(parse(it));\n\t}\n\n\twhile(*it != '>') ++it;\n\t++it;\n\treturn res;\n}\n\nstring solve(const panel &root) {\n\tint x, y;\n\tcin >> x >> y;\n\treturn root.in_range(x, y) ? root.search(x, y) : \"OUT OF MAIN PANEL 1\";\n}\n\nint main() {\n\tfor(int n; cin >> n && n;) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tauto it = s.cbegin();\n\t\tconst panel root = parse(it);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcout << solve(root) << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<cctype>\n\nusing namespace std;\n\n#define foreach(itm,o) for(__typeof((o).begin()) itm=(o).begin();itm!=(o).end();++itm)\nconst int infty = 1<<28;\n\nstruct panel{\n  int depth;\n  string name;\n  int x1,y1,x2,y2;\n  panel(int x1,int y1,int x2,int y2,string newName,int d):\n    x1(x1),y1(y1),x2(x2),y2(y2),name(newName),depth(d){}\n  bool isinside(int x, int y){\n    return ( x1 <= x && x <= x2 && y1 <= y && y <= y2 );\n  }\n};\n\nint dig(const string &s, int &pos){\n  int n = 0;\n  int sign=1;\n  if(s[pos]=='-'){sign=-1;++pos;}\n  while(isdigit(s[pos])){\n    n *= 10;\n    n += s[pos]-'0';\n    ++pos;\n  }\n  return sign*n;\n}\n\nvoid parse(const string &s, int &pos, int depth,\n\t   const string &parent, map<string, vector<panel> > &M){\n  string newName;\n  if(pos>=s.length())return ;\n  if( s[pos] == '<' ){\n    ++pos;\n    while(s[pos]!='>'){newName+=s[pos];++pos;}\n  }\n  pos++;\n  int x1 = dig(s,pos);++pos;\n  int y1 = dig(s,pos);++pos;\n  int x2 = dig(s,pos);++pos;\n  int y2 = dig(s,pos);\n  //cout << newName << endl;\n  M[newName];\n  //.push_back(tail );\n  M[parent].push_back( panel(x1,y1,x2,y2,newName,depth) );\n  while( true ){\n    if( s[pos]=='<'&&s[pos+1]=='/' ){\n      while(s[pos]!='>')++pos;\n      ++pos;\n      //cout << newName << \" END\"<<endl;\n      break;\n    }else{\n      //cout << newName << \" HAS:\"<<endl;\n      parse(s,pos,depth+1,newName,M);\n      if(pos>=s.length())break;\n    }\n  }\n  return ;\n}\n\nint main(){\n  while(true){\n    int n;\n    int pos = 0;\n    string tags;\n    map< string, vector<panel> > structure;\n    cin >> n;if(n==0)break;\n    cin >> tags;\n    parse(tags,pos,0,\"\\0\\0_0root\",structure);\n    \n    for(int i = 0; i < n; ++i){\n      int qx,qy;cin>>qx>>qy;\n      int maxdepth = -1,child;\n      string ans;\n      for(map<string,vector<panel> >::iterator itm=structure.begin(); itm != structure.end(); ++itm){\n\tfor(int j = 0; j < itm->second.size(); ++j){\n\t  if( itm->second[j].isinside(qx,qy) ){\n\t    int t = itm->second[j].depth;\n\t    if( t > maxdepth ){\n\t      maxdepth = t;\n\t      child = structure[itm->second[j].name].size();\n\t      ans = itm->second[j].name;\n\t    }\n\t  }\n\t}\n      }\n      if( maxdepth == -1 ){\n\tcout <<\"OUT OF MAIN PANEL 1\" << endl;\n      }else{\n\tcout << ans << ' ' << child << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\n#define limit(A,B,C) (A<= B && B <= C) \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\n\nclass AOJ1031{\nprivate:\n  string s;\n  int n;\n  map<string,int> c_num;\n  map<string,PP> coor;\n  vector<string> name_list;\npublic:\n  AOJ1031(int n,string s):n(n),s(s){}\n  ~AOJ1031(){}\n\n  void getChildNumber(){\n   \n    int st,cnt=0;\n     \n    rep(i,name_list.size()){\n      string name = name_list[i];\n     \n      P A,B;\n      //A = coor[name].F,B = coor[name].S;\n      int cnt=0;\n      rep(j,name_list.size()){\n\tstring rename = name_list[j];\n\tA = coor[rename].F,B = coor[rename].S;\n\tif(name == name_list[j])continue;\n\tif(limit(coor[name].F.F,A.F,coor[name].S.F) && limit(coor[name].F.S,A.S,coor[name].S.S) && limit(coor[name].F.F,B.F,coor[name].S.F) && limit(coor[name].F.S,B.S,coor[name].S.S)){\n\t  cnt++;\n\t}\n      }\n      c_num[name] = cnt;\n      //cout << \"c_num[\" << name << \"] = \"<< c_num[name] << endl;\n    }\n  }\n\n  PP getPP(string s){\n    stringstream ss;\n    ss << s;\n    int Pm[4];\n    ss >> Pm[0] >> Pm[1] >> Pm[2] >> Pm[3];\n    return PP(P(Pm[0],Pm[1]),P(Pm[2],Pm[3]));\n  }\n\n  void getCoordinate(){\n\n    bool OK = false;\n    int st;\n    string store;\n    REP(i,0,s.length()){\n      if(s[i] == ','){\n\ts[i] = ' ';\n\tcontinue;\n      }\n\n      if(s[i] == '<' && s[i+1] != '/' && !OK)st = i,OK=true;\n      else if(s[i] == '>' && OK){\n\tstore = s.substr(st+1,i-1-st);\n\tcoor[store] = PP(P(-1,-1),P(-1,-1));\n\tst = i+1;\t\n      }\n      else if(s[i] == '<'){\n\tif(coor[store] != PP(P(-1,-1),P(-1,-1)))continue;\n\tcoor[store] = getPP(s.substr(st,i-st)); \n\tOK = false;\n\tst = i;\n\tif(s[i+1] != '/')OK = true;\n      }\n    }\n  }\n\n  void getNameList(){\n    int st = 0;\n    bool OK = false;\n    map<string,bool> index;\n    rep(i,s.length()){\n      if(s[i] == '<' && s[i+1] != '/' && !OK)st = i+1,OK = true;\n      else if(s[i] == '>' && OK){\n\tname_list.pb(s.substr(st,i-st));\n\tOK = false;\n      }\n\n\n    }\n  }\n\n  void run(){\n   \n    getCoordinate();\n    getNameList();\n    getChildNumber();\n\n    rep(i,n){\n      int x,y;\n      cin >> x >> y;\n      bool found = false;\n      string found_name;\n      P LIMA = P(0,0),LIMB = P(INT_MAX,INT_MAX); \n      rep(i,name_list.size()){\n\tstring name = name_list[i];\n\n\tif(coor[name].F.F <= x && x <= coor[name].S.F && coor[name].F.S <= y && y <= coor[name].S.S){\n\t  found_name = name;\n\t  found = true;\n\t}\n      }\n      if(!found)cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else cout << found_name << \" \" << c_num[found_name] << endl;\n\n    }\n  }\n\n\n};\n\nint main(){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0)break;\n    string s;\n    cin >> s;\n    AOJ1031 ans = AOJ1031(n,s);\n    ans.run();\n\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint tag[1111][4];\nstring name[1111];\nint ar[1111];\n\nint main() {\n\tint n,t;\n\tstring str;\n\tIL{\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>str;\n\t\tt=0;\n\t\trep(i,sz(str)){\n\t\t\tif(str[i]=='<'&&str[i+1]!='/'){\n\t\t\t\tint j;\n\t\t\t\tname[i]=\"\";\n\t\t\t\trepn0(j,i+1,sz(str)){\n\t\t\t\t\tif(str[j]=='>')break;\n\t\t\t\t\tname[t]+=str[j];\n\t\t\t\t}\n\t\t\t\tint c;\n\t\t\t\trep(k,4){\n\t\t\t\t\t++j;\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor(;;++j){\n\t\t\t\t\t\tif(!isdigit(str[j]))break;\n\t\t\t\t\t\tc=c*10+str[j]-'0';\n\t\t\t\t\t}\n\t\t\t\t\ttag[t][k]=c;\n\t\t\t\t}\n\t\t\t\tar[t]=(tag[t][2]-tag[t][0])*(tag[t][3]-tag[t][1]);\n\t\t\t\t++t;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tint top=-1;\n\t\t\tint area=INF;\n\t\t\trep(j,t){\n\t\t\t\tif(tag[j][0]<=x&&x<=tag[j][2]&&tag[j][1]<=y&&y<=tag[j][3]){\n\t\t\t\t\tif(ar[j]<area){\n\t\t\t\t\t\tarea=ar[j];\n\t\t\t\t\t\ttop=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(top!=-1){\n\t\t\t\tint count=0;\n\t\t\t\trep(j,t){\n\t\t\t\t\tif(tag[top][0]<tag[j][0]&&tag[j][0]<tag[top][2]&&tag[top][1]<tag[j][1]&&tag[j][1]<tag[top][3]){\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\trep0(k,t){\n\t\t\t\t\t\t\tif(ar[top]<=ar[k])continue;\n\t\t\t\t\t\t\tif(tag[k][0]<tag[j][0]&&tag[j][0]<tag[k][2]&&tag[k][1]<tag[j][1]&&tag[j][1]<tag[k][3])break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==t)++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<name[top]<<\" \"<<count<<endl;\n\t\t\t}else{\n\t\t\t\tint count=0;\n\t\t\t\trep(j,t){\n\t\t\t\t\tint k;\n\t\t\t\t\trep0(k,t){\n\t\t\t\t\t\tif(tag[k][0]<tag[j][0]&&tag[j][0]<tag[k][2]&&tag[k][1]<tag[j][1]&&tag[j][1]<tag[k][3])break;\n\t\t\t\t\t}\n\t\t\t\t\tif(k==t)++count;\n\t\t\t\t}\n\t\t\t\tcout<<\"OUT OF MAIN PANEL \"<<count<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <stack>\n\nusing namespace std;\n\nstruct Area {\n    int ulx, uly, lrx, lry;\n    Area(int ulx=0, int uly=0, int lrx=0, int lry=0)\n        : ulx(ulx), uly(uly), lrx(lrx), lry(lry) {}\n    bool contains(int x, int y) const {\n//        cout << x << ',' << y << endl;\n        return (ulx <= x && x <= lrx && uly <= y && y <= lry);\n    }\n};\n\nenum Type {\n    START,\n    END,\n    AREA,\n};\n\nstruct Token {\n    Type type;\n    string tagName;\n    Area area;\n};\n\nstring input;\nint index;\n\nint getInt() {\n    while (!isdigit(input[index])) index++;\n    int n = 0;\n    while (isdigit(input[index])) {\n        n = n * 10 + input[index] - '0';\n        index++;\n    }\n    return n;\n}\n\nToken nextToken() {\n    string buf;\n    Token t;\n    if (input[index] == '<') {\n        index++;\n        if (input[index] == '/') {\n            t.type = END;\n            index++;\n        } else {\n            t.type = START;\n        }\n        while (input[index] != '>') {\n            buf.push_back(input[index]);\n            index++;\n        }\n        index++; // ignore '>'\n        t.tagName = buf;\n    } else {\n        t.type = AREA;\n        t.area.ulx = getInt();\n        t.area.uly = getInt();\n        t.area.lrx = getInt();\n        t.area.lry = getInt();\n    }\n    return t;\n}\n\nmap<string, Area> areaTable;\nmap<string, int> childrenCount;\nvoid parse() {\n    Token t;\n    stack<string> st;\n    string cur;\n    while (index < input.size()) {\n        t = nextToken();\n        if (t.type == START) {\n            if (!st.empty()) {\n                childrenCount[st.top()]++;\n            }\n            cur = t.tagName;\n            st.push(cur);\n        } else if (t.type == END) {\n            st.pop();\n            if (!st.empty()) cur = st.top();\n        } else {\n            areaTable[cur] = t.area;\n        }\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        cin >> input;\n        index = 0;\n        areaTable.clear();\n        childrenCount.clear();\n        parse();\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            string areaName;\n            cin >> x >> y;\n            int cnt = (1<<28);\n            for (map<string, Area>::iterator it = areaTable.begin();\n                    it != areaTable.end(); it++) {\n                if (it->second.contains(x, y)) {\n                    //cout << it->first << ' ' << childrenCount[it->first] << endl;\n                    if (cnt > childrenCount[it->first]) {\n                        cnt = childrenCount[it->first];\n                        areaName = it->first;\n                    }\n                }\n            }\n            if (cnt == (1<<28)) {\n                cout << \"OUT OF MAIN PANEL 1\" << endl;\n            } else {\n                cout << areaName << ' ' << cnt << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\nusing namespace std;\n\nint stoi(string s){\n  stringstream ss;\n  ss << s;\n  int res;\n  ss >> res;\n  return res;\n}\n\nint main(){\n  int n,x,y,t,z[1000][5];\n  string s,name[1000];\n\n  while(cin >> n, n){\n    cin >> s;\n    t = 0;\n    for(int i=1;i<(int)s.size();i++){\n\n      if(s[i] != '/'){\n\tstring tmp = \"\";\n\twhile(i<(int)s.size() && s[i] != '>'){\n\t  tmp += s[i];\n\t  i++;\n\t}\n\tname[t] = tmp;\n\tfor(int j=0;j<4;j++){\n\t  i++;\n\t  tmp = \"\";\n\t  while(s[i] != ',' && s[i] != '<'){\n\t    tmp += s[i];\n\t    i++;\n\t  }\n\t  z[t][j] = stoi(tmp);\n\t}\n\tt++;\n      }else{\n\twhile(i<(int)s.size() && s[i]!='<')i++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n\n      int m = -1;\n      for(int j=0;j<t;j++){\n\tif(z[j][0]<=x && x<=z[j][2] && z[j][1]<=y && y<=z[j][3]){\n\t  if(m<0 || (z[m][0]<z[j][0] && z[j][2]<z[m][2] && z[m][1]<z[j][1] && z[j][3]<z[m][3]) )m = j;\n\t} \n      }\n      \n      if(m<0)cout << \"OUT OF MAIN PANEL 1\" << endl;\n      else{\n\tint num = 0;\n\tfor(int j=0;j<t;j++){\n\t  if(z[m][0]<z[j][0] && z[j][2]<z[m][2] && z[m][1]<z[j][1] && z[j][3]<z[m][3]){\n\t    bool f = true;\n\t    for(int k=0;k<t;k++){\n\t      if(z[m][0]<z[k][0] && z[k][2]<z[m][2] && z[m][1]<z[k][1] && z[k][3]<z[m][3]){\n\t\tif(z[k][0]<z[j][0] && z[j][2]<z[k][2] &&  z[k][1]<z[j][1] && z[j][3]<z[k][3]){\n\t\t  f = false;\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\t    if(f)num++;\n\t  }\n\t}\n\t\n\tcout << name[m] << \" \" << num << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<stdio.h>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\n\nstruct Panel{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tvector<Panel> v;\n};\n\nint fp=1;\n\nPanel parse(string s){\n\tPanel p;\n\tint ep=0;\n\twhile(s[fp] != '>'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.name = s.substr(fp-ep,ep);\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x1 = toInt(s.substr(fp-ep,ep));\n\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y1 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != ','){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.x2 = toInt(s.substr(fp-ep,ep));\n\tep=0;fp++;\n\twhile(s[fp] != '<'){\n\t\tep++;\n\t\tfp++;\n\t}\n\tp.y2 = toInt(s.substr(fp-ep,fp-1));\n\t\n\tfp++;\n\twhile(1){\n\t\tif(s[fp]=='/'){ fp+=p.name.size()+3; break;}\n\t\telse p.v.push_back(parse(s));\n\t}\t\n\treturn p;\n}\n\nPanel search(int x,int y,Panel r_p,Panel p){\n\tif(p.x1 <= x && p.x2 >= x && p.y1 <= y && p.y2 >= y){\n\t\tPanel ans=p;\n\t\trep(i,p.v.size()){\n\t\t\tPanel tmp = search(x,y,p,p.v[i]);\n\t\t\tif(tmp.name != p.name) ans = p.v[i];\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\treturn r_p;\n}\n\nint main(){\n\t\n\tint n;\n\tstring str;\n\tcin >> n;\n\tcin >> str;\n\n\tPanel p = parse(str);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tPanel root;root.name=\"-1\";\n\t\tPanel ans=search(x,y,root,p);\n\t\tif(ans.name==\"-1\") cout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\telse cout << ans.name << \" \" << ans.v.size() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\n#include <ctype.h>\n\nusing namespace std;\n\nenum token_type\n{\n\tT_INT,\n\tT_TAG_S,\n\tT_TAG_E,\n\tT_END,\n};\n\nstruct token\n{\n\ttoken_type type;\n\tstring tag_name;\n\tint value;\n};\n\nstruct panel\n{\n\tstring name;\n\tint bounds[4];\n\tvector<panel> children;\n\n\tbool click(int x, int y)\n\t{\n\t\tbool hit = false;\n\t\tfor (int i = 0; !hit && i < children.size(); i++)\n\t\t{\n\t\t\thit = children[i].click(x, y);\n\t\t}\n\t\tif (!hit)\n\t\t{\n\t\t\thit = contains(x, y);\n\t\t\tif (hit) cout << name << \" \" << children.size() << endl;\n\t\t}\n\t\treturn hit;\n\t}\n\n\tbool contains(int x, int y)\n\t{\n\t\treturn bounds[0] <= x && bounds[1] <= y && x <= bounds[2] && y <= bounds[3];\n\t}\n};\n\nstring src;\nint p;\ntoken cur_tok;\n\nbool end() { return p >= src.length(); }\nchar peek() { return src[p]; }\nvoid next() { if (!end()) p++; }\n\ntoken lex_int()\n{\n\ttoken t;\n\tt.type = T_INT;\n\tt.value = 0;\n\tchar c;\n\twhile (isdigit(c = peek()))\n\t{\n\t\tt.value = 10 * t.value + (c - '0');\n\t\tnext();\n\t}\n\treturn t;\n}\n\nstring lex_tag_name()\n{\n\tstring name = \"\";\n\tchar c;\n\twhile ((c = peek()) != '>')\n\t{\n\t\tname += c;\n\t\tnext();\n\t}\n\treturn name;\n}\n\ntoken lex_tag()\n{\n\ttoken t;\n\tif (peek() == '<') next();\n\tif (peek() == '/')\n\t{\n\t\tnext();\n\t\tt.type = T_TAG_E;\n\t\tt.tag_name = lex_tag_name();\n\t}\n\telse\n\t{\n\t\tt.type = T_TAG_S;\n\t\tt.tag_name = lex_tag_name();\n\t}\n\tif (peek() == '>') next();\n\treturn t;\n}\n\nvoid lex_next()\n{\n\tif (end()) cur_tok = token();\n\tchar c = peek();\n\tif (c == '<') cur_tok = lex_tag();\n\telse if (c == ',') { next(); lex_next(); }\n\telse if (isdigit(c)) cur_tok = lex_int();\n}\n\npanel tag_structure()\n{\n\tpanel p;\n\tif (cur_tok.type == T_TAG_S)\n\t{\n\t\tp.name = cur_tok.tag_name;\n\t\tlex_next();\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tp.bounds[i] = cur_tok.value;\n\t\t\tlex_next();\n\t\t}\n\n\t\twhile (cur_tok.type == T_TAG_S)\n\t\t{\n\t\t\tp.children.push_back(tag_structure());\n\t\t}\n\t\tif (cur_tok.type == T_TAG_E) lex_next();\n\t}\n\treturn p;\n}\n\nint main()\n{\n\tint N;\n\tfor(;cin>>N, N;)\n\t{\n\t\tcin >> src;\n\n\t\tp = 0;\n\t\tlex_next();\n\t\tpanel root = tag_structure();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tbool hit = root.click(x, y);\n\t\t\tif (!hit) cout << \"OUT OF MAIN PANEL 1\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nstring tag;\nsize_t cur;\n\nmap<int, string> tag_name;\nvector<int> ch[200];\n\nint xl[200];\nint yl[200];\nint xr[200];\nint yr[200];\n\nint res;\n\nstring get_name(){\n\tstring res;\n\tassert(cur < tag.size());\n\twhile(tag[cur] != '>'){\n\t\tres.push_back(tag[cur++]);\n\t}\n\treturn res;\n}\n\nint get_num(){\n\tint res = 0;\n\twhile(isdigit(tag[cur])){\n\t\tres = res * 10 + tag[cur++] - '0';\n\t}\n\treturn res;\n}\n\nvoid get_size(int id){\n\txl[id] = get_num();\n\tassert(tag[cur++] == ',');\n\tyl[id] = get_num();\n\tassert(tag[cur++] == ',');\n\txr[id] = get_num();\n\tassert(tag[cur++] == ',');\n\tyr[id] = get_num();\n//\tcout << id << \" \" << xl[id] << \" \"<< xr[id] << endl;\n}\n\nvoid tag_con(int &id){\n\tint num = id;\n\tassert(tag[cur++] == '<');\n\ttag_name[id] = get_name();\n\tassert(tag[cur++] == '>');\n\tget_size(id);\n\n\twhile(true){\n\t\n\t\tassert(cur < tag.size() && tag[cur] == '<');\n\t\tchar c = tag[cur+1];\n\t\tif(c == '/') break;\n\t\tch[num].push_back(++id);\n\t\ttag_con(id);\n\t}\n\twhile(tag[cur] != '>') cur++;\n\tcur++;\n}\n\nvoid get_tag(int x, int y, int id){\n\t//cout << id << \" \" << xl[id] << endl;\n\tif(xl[id] <= x && x <= xr[id] && yl[id] <= y && y <= yr[id]){\n\t\tres = id;\n\t}\n\tfor(int i = 0; i < (int)ch[id].size(); i++){\n\t\tget_tag(x, y, ch[id][i]);\n\t}\n}\n\nint main(){\n\tint n, x, y;\n\tint cnt = 0;\n\twhile(cin >> n && n){\n\t\ttag_name.clear();\n\t\trep(i, 200) ch[i].clear();\n\t\ttag_name[120] = \"OUT OF MAIN PANEL\";\n\t\tch[120].push_back(120);\n\t\t\n\t\tcur = 0;\n\t\tcnt = 0;\n\t\tcin >> tag;\n\t\ttag_con(cnt);\n\t\trep(i, n){\n\t\t\tres = 120;\n\t\t\tcin >> x >> y;\n\t\t\tget_tag(x, y, 0);\n\t\t\tcout << tag_name[res] << \" \"<< ch[res].size() << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator Cursol;\n\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Piii;\n\nstruct Data{\n  string name;\n  Piii p;\n  vector< Data > foo;\n};\n\nbool inPosition(int x, int y, Data data){\n  Piii p = data.p;\n  return (p.first.first <= x && x <= p.second.first &&\n          p.first.second <= y && y <= p.second.second);\n}\n\nint rec(Data now, const Data& panel){\n  int ret = 0;\n  for(int i = 0; i < now.foo.size(); i++){\n    ret += rec( now.foo[i], panel) + 1;\n  }\n  return ret;\n}\n\n\npair< string , int > solve(const int x,const int y, const Data& panel){\n  Data now = panel;\n  int cnt = 0;\n\n\n  \n  if(!inPosition(x, y, now)){\n    return make_pair( \"OUT OF MAIN PANEL\", 1);\n  }\n  \n  \n  bool flag = true;\n  while(flag){ //ここでREしてるよふえぇ\n    flag = false;\n    if(now.foo.size() == 0) break;\n    for(int i = 0; i < now.foo.size(); i++){\n      if(inPosition( x, y, now.foo[i])){\n        now = now.foo[i];\n        flag = true;\n        break;\n      }\n    }\n  }\n\n  return make_pair( now.name, rec(now, panel));\n}\n\n\nstring getString(Cursol& pos)\n{\n  Cursol prev = pos;\n  while(*pos != '>'){\n    pos++;\n  } \n  return string(prev,pos);\n}\nPiii getPosision(Cursol& pos)\n{\n  Piii p;\n  Cursol prev = pos;\n\n  while(*pos != '<'){\n    pos++;\n  }\n  sscanf( string( prev, pos).c_str(), \"%d,%d,%d,%d\",\n          &p.first.first, &p.first.second, &p.second.first, &p.second.second);\n  return p;\n}\n\nvoid Check( Cursol& pos, Data& ret)\n{\n\n  ret = (Data){ getString(++pos), getPosision(++pos), vector< Data >(0)};\n  while(*(pos + 1) != '/'){ //終了タグ\n    ret.foo.resize(ret.foo.size() + 1);\n    Check( pos, ret.foo[ret.foo.size() - 1]);\n  }\n  getString(++pos);\n  ++pos;\n}\n\n\nint main(){\n  int n;\n  string tag;\n  Data Main;\n  Cursol crl;\n\n  while(cin >> n, n){\n    cin >> tag;\n    Check( crl = tag.begin(), Main); //こうぶんかいせき！！\n    \n    while(n--){\n      int x, y;\n      cin >> x >> y;\n      pair< string , int > ans = solve( x, y, Main);\n      cout << ans.first << \" \" << ans.second << endl;\n    }\n    \n\n  }\n  \n  return(0);\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\n--import qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Fixed\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport Text.Printf\nimport System.IO\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\nwhenM :: Monad m => m Bool -> m () -> m ()\nwhenM c a = c >>= flip when a\nunconsU :: [a] -> (a, [a])\nunconsU (x:xs) = (x, xs)\n-- templete\n\ntype Point = (Int, Int)\ntype Rect = (Point, Point)\n\ndata Tag = Tag String Rect [Tag] deriving (Show)\n\nparseTag :: String -> Tag\nparseTag s = case parseTag' s of (Just t, _) -> t\n\nparseTag' :: String -> (Maybe Tag, String)\nparseTag' ('<':'/':s) = (Nothing, tail (dropWhile (/='>') s))\nparseTag' ('<':s) = (Just (Tag name ((x1,y1),(x2,y2)) children), s6)\n  where\n    (name, s1) = fmap tail $ span (/='>') s\n    (s2, x1) = fmap readInt $ swap $ fmap tail $ span isNumber s1\n    (s3, y1) = fmap readInt $ swap $ fmap tail $ span isNumber s2\n    (s4, x2) = fmap readInt $ swap $ fmap tail $ span isNumber s3\n    (s5, y2) = fmap readInt $ swap $ span isNumber s4\n    (children, s6) = sub s5\n    sub ss = let (tag, s7) = parseTag' ss in case tag of\n        Nothing -> ([], s7)\n        Just t -> let (tags, s8) = sub s7 in (t:tags, s8)\n\nwrap :: Tag -> Tag\nwrap t = Tag \"OUT OF MAIN PANEL\" ((0,0),(10000,100000)) [t]\n\ncontains :: Point -> Tag -> Bool\ncontains (x,y) (Tag _ ((x1,y1),(x2,y2)) _) = x1<=x && x<=x2 && y1<=y && y<=y2\n\npoint :: Tag -> Point -> Tag\npoint tag@(Tag _ _ children) p = case find (contains p) children of\n    Just subt -> point subt p\n    Nothing -> tag\n\ntagName :: Tag -> String\ntagName (Tag name _  _) = name\n\nchildrenCount :: Tag -> Int\nchildrenCount (Tag _ _ cs) = length cs\n\nmain = do\n    n <- getInt\n    when (n/=0) $ do\n        tag <- getLine\n        ds <- map (apply2 (,)) <$> replicateM n getInts\n        let panels = wrap $ parseTag tag\n        forM ds $ \\p -> do\n            let panel = point panels p\n            putStrLn $ unwords [tagName panel, (show . childrenCount) panel]\n        main\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nstruct entry\n{\n  int x1;\n  int y1;\n  int x2;\n  int y2;\n  int level;\n  char *name;\n};\nstatic char         * e;\nstatic struct entry   lis[ 1024 ];\nstatic int            len;\n\nstatic int\nnanikaka (\n  void\n  )\n{\n  int nol;\n  int res = 0;\n\n  if ( e[ 0 ] != '<'\n    || e[ 1 ] == '/' ) return ( 0 );\n\n  nol = len++;\n  lis[ nol ].name = ++e;\n  while ( *e != '>' ) ++e;\n  *( e++ ) = '\\0';\n  lis[ nol ].x1 =\n  lis[ nol ].y1 =\n  lis[ nol ].x2 =\n  lis[ nol ].y2 = 0;\n  while ( isdigit ( *e ) )  lis[ nol ].x1 = ( lis[ nol ].x1 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].y1 = ( lis[ nol ].y1 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].x2 = ( lis[ nol ].x2 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].y2 = ( lis[ nol ].y2 * 10 )\n                                          + ( *( e++ ) - '0' );\n\n  for ( ; ; )\n  {\n    const int ret = nanikaka ( );\n\n    if ( !ret ) break ;\n    res += ret;\n  }\n  lis[ nol ].level = res;\n\n  while ( *( e++ ) != '>' ) ;\n\n  return ( res + 1 );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    char s[ 1024 ];\n    int ch;\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( !( n ) ) break ;\n\n    do\n    {\n      ch = getchar ( );\n    }\n    while ( ch != '\\n' );\n    fgets ( s, sizeof ( s ), stdin );\n    e = s;\n    len = 0;\n    nanikaka ( );\n\n    while ( n-- )\n    {\n      int x, y;\n\n      scanf ( \" %d %d\", &x, &y );\n\n      for ( i = len - 1; i >= 0; --i )\n      {\n        if ( x >= lis[ i ].x1\n          && x <= lis[ i ].x2\n          && y >= lis[ i ].y1\n          && y <= lis[ i ].y2 )\n        {\n          printf ( \"%s %d\\n\", lis[ i ].name, lis[ i ].level );\n          break ;\n        }\n      }\n\n      if ( i < 0 )\n      {\n        puts ( \"OUT OF MAIN PANEL 1\" );\n      }\n    }\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nstruct entry\n{\n  int x1;\n  int y1;\n  int x2;\n  int y2;\n  int level;\n  char *name;\n};\nstatic char         * e;\nstatic struct entry   lis[ 1024 ];\nstatic int            len;\n\nstatic int\nnanikaka (\n  void\n  )\n{\n  int nol;\n  int res = 0;\n\n  if ( e[ 0 ] != '<'\n    || e[ 1 ] == '/' ) return ( 0 );\n\n  nol = len++;\n  lis[ nol ].name = ++e;\n  while ( *e != '>' ) ++e;\n  *( e++ ) = '\\0';\n  lis[ nol ].x1 =\n  lis[ nol ].y1 =\n  lis[ nol ].x2 =\n  lis[ nol ].y2 = 0;\n  while ( isdigit ( *e ) )  lis[ nol ].x1 = ( lis[ nol ].x1 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].y1 = ( lis[ nol ].y1 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].x2 = ( lis[ nol ].x2 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].y2 = ( lis[ nol ].y2 * 10 )\n                                          + ( *( e++ ) - '0' );\n\n  for ( ; ; )\n  {\n    const int ret = nanikaka ( );\n\n    if ( !ret ) break ;\n    res += ret;\n  }\n  lis[ nol ].level = res;\n\n  while ( *( e++ ) != '>' ) ;\n\n  return ( res + 1 );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    char s[ 1024 ];\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( !( n ) ) break ;\n\n    scanf ( \" %s\", s );\n    e = s;\n    len = 0;\n    nanikaka ( );\n\n    while ( n-- )\n    {\n      int x, y;\n\n      scanf ( \" %d %d\", &x, &y );\n\n      for ( i = len - 1; i >= 0; --i )\n      {\n        if ( x >= lis[ i ].x1\n          && x <= lis[ i ].x2\n          && y >= lis[ i ].y1\n          && y <= lis[ i ].y2 )\n        {\n          printf ( \"%s %d\\n\", lis[ i ].name, lis[ i ].level );\n          break ;\n        }\n      }\n\n      if ( i < 0 )\n      {\n        puts ( \"OUT OF MAIN PANEL 1\" );\n      }\n    }\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-10 1031: Simple GUI Application\n// 2017.8.19 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nchar *gets(char *);\nchar buf[100], *p;\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p) || *p == ',') p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nchar tag[1005];\nint x, y;\nchar ans[100]; int no;\n\nchar *parse(char *tp, int *done, int *k)\n{\n\tint x1, y1, x2, y2;\n\tint ok = 0;\n\tint sum = 0, s;\n\tchar name[100], *np;\n\n\t*k = 0;\n//\twhile (isspace(*tp)) tp++;\n\tif (!*tp) return tp;\n\ttp++;\t// '<'\n\tnp = name; while (*tp != '>') *np++ = *tp++; *np = 0;\n\ttp++;\t// '>'\n\tp = tp, x1 = getInt(), y1 = getInt(), x2 = getInt(), y2 = getInt(),\ttp = p;\n\tif (x1 <= x && x <= x2 && y1 <= y && y <= y2) ok = 1;\n\twhile (*tp) {\n//\t\twhile (isspace(*tp)) tp++;\n\t\tif (*(tp + 1) == '/') break;\n\t\ttp = parse(tp, done, &s), sum++;  // sum += s+1;\n\t}\n\twhile (*tp++ != '>') ;\n\tif (!*done && ok) strcpy(ans, name), no = sum, *done = 1;\n\t*k = sum;\n\treturn tp;\n}\n\nint main()\n{\n\tint n, i, d, k;\n\n\twhile (1) {\n\t\tgets(p = buf); if (!(n = getInt())) break;\n\t\tgets(tag);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tgets(p = buf), x = getInt(), y = getInt();\n\t\t\tno = -1, d = 0;\n\t\t\tparse(tag, &d, &k);\n\t\t\tif (no < 0) puts(\"OUT OF MAIN PANEL 1\");\n\t\t\telse printf(\"%s %d\\n\", ans, no);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char Tag[99][99]={\"OUT OF MAIN PANEL\"};\nX[99],Y[99],V[99],W[99],c[99],w;\nP(p){\n\tchar t[99],d[99];\n\tc[p]=0;\n\tfor(;w++,scanf(\"%[^/>]>%d,%d,%d,%d<\",Tag[w],X+w,Y+w,V+w,W+w,d);){\n\t\tc[p]++;\n\t\tP(w);\n\t\tif(scanf(\"%[^>]>%[<]\",t,d)!=2){\n\t\t\tw++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tw--;\n}\nmain(n,x,y,i){\n\tfor(;scanf(\"%d\\n<\",&n)*n;){\n\t\tP(w=0);\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tfor(i=w+1;--i;){\n\t\t\t\tif(x>=X[i]&&y>=Y[i]&&x<=V[i]&&y<=W[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"%s %d\\n\",Tag[i],c[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#if 0\n#define PRINT_TAGS\n#endif\n\ntypedef struct panel_t_tag {\n\tchar* name;\n\tint x1, y1, x2, y2;\n\tstruct panel_t_tag* child;\n\tstruct panel_t_tag* next;\n} panel_t;\n\nint my_ungetchar_num = 0;\nint my_ungetchar_buf[1024];\nint my_getchar(void) {\n\tif (my_ungetchar_num > 0) return my_ungetchar_buf[--my_ungetchar_num];\n\treturn getchar();\n}\nvoid my_ungetchar(int c) {\n\tmy_ungetchar_buf[my_ungetchar_num++] = c;\n}\n\npanel_t* parse(void) {\n\tchar tag_name[1024];\n\tint input;\n\tpanel_t* new_panel;\n\tinput = my_getchar();\n\tif (input != '<') return NULL;\n\tnew_panel = malloc(sizeof(panel_t));\n\tif (new_panel == NULL) exit(1);\n\tinput = my_getchar();\n\tungetc(input, stdin);\n\tif (input == '/') {\n\t\tmy_ungetchar('<');\n\t\treturn NULL;\n\t}\n\tif (scanf(\"%[^>]\", tag_name) != 1) exit(1);\n\tinput = my_getchar(); assert(input == '>');\n\tnew_panel->name = malloc(strlen(tag_name) + 1);\n\tif (new_panel->name == NULL) exit(1);\n\tstrcpy(new_panel->name, tag_name);\n\tif (scanf(\"%d,%d,%d,%d\", &new_panel->x1, &new_panel->y1, &new_panel->x2, &new_panel->y2) != 4) exit(1);\n\tinput = my_getchar(); assert(input == '<');\n\tinput = my_getchar();\n\tif (input == '/') {\n\t\tif (scanf(\"%[^>]\", tag_name) != 1) exit(1);\n\t\tassert(strcmp(new_panel->name, tag_name) == 0);\n\t\tinput = my_getchar(); assert(input == '>');\n\t\tnew_panel->child = NULL;\n\t} else {\n\t\tungetc(input, stdin);\n\t\tmy_ungetchar('<');\n\t\tnew_panel->child = parse();\n\t\tinput = my_getchar();\n\t\tif (input == '<') {\n\t\t\tif (scanf(\"%[^>]\", tag_name) != 1) exit(1);\n\t\t\tassert(tag_name[0] == '/' && strcmp(new_panel->name, tag_name + 1) == 0);\n\t\t\tinput = my_getchar(); assert(input == '>');\n\t\t}\n\t}\n\tnew_panel->next = parse();\n\treturn new_panel;\n}\n\nvoid free_panel(panel_t* panel) {\n\tif (panel == NULL) return;\n\tfree(panel->name);\n\tfree_panel(panel->child);\n\tfree_panel(panel->next);\n\tfree(panel);\n}\n\n#ifdef PRINT_TAGS\nvoid print_tags(const panel_t* panel, int level) {\n\tint i;\n\tif (panel == NULL) return;\n\tfor (i = 0; i < level; i++) printf(\"  \");\n\tprintf(\"%s %d %d %d %d\\n\", panel->name, panel->x1, panel->y1, panel->x2, panel->y2);\n\tprint_tags(panel->child, level + 1);\n\tprint_tags(panel->next, level);\n}\n#else\nint touch(const panel_t* panel, int x, int y) {\n\tint ret = 0;\n\tfor (; panel != NULL; panel = panel->next) {\n\t\tif (panel->x1 <= x && x <= panel->x2 && panel->y1 <= y && y <= panel->y2) {\n\t\t\tint nret = touch(panel->child, x, y);\n\t\t\tif (nret >= 0) printf(\"%s %d\\n\", panel->name, nret);\n\t\t\treturn -1;\n\t\t}\n\t\tret++;\n\t}\n\treturn ret;\n}\n#endif\n\nint main(void) {\n\tchar n_str[1024];\n\tint n, i;\n\tpanel_t* root;\n\twhile (fgets(n_str, sizeof(n_str), stdin) != NULL && sscanf(n_str, \"%d\", &n) == 1 && n > 0) {\n\t\troot = parse();\n#ifdef PRINT_TAGS\n\t\tprint_tags(root, 0);\n#else\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tif (fgets(n_str, sizeof(n_str), stdin) == NULL || sscanf(n_str, \"%d%d\", &x, &y) != 2) return 1;\n\t\t\tif (touch(root, x, y) >= 0) {\n\t\t\t\tputs(\"OUT OF MAIN PANEL 1\");\n\t\t\t}\n\t\t}\n#endif\n\t\tfree_panel(root);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "*T[9]={\"OUT OF MAIN PANEL\"},X[9],Y[9],V[9],W[9],c[9],w;P(p){for(c[p]=0;scanf(\"%a[^/>]>%d,%d,%d,%d<\",T+w,X+w,Y+w,V+w,W+w)&&scanf(\"%*[^>]>%[<]\",X,c[p]++,P(w++)););}main(n,x,y,i){for(;scanf(\"%d\\n<\",&n)*n;)for(w=1,P(0);n--;printf(\"%s %d\\n\",T[i],c[i]))for(scanf(\"%d%d\",&x,&y),i=w;--i&&x<X[i]|y<Y[i]|x>V[i]|y>W[i];);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nstruct entry\n{\n  int x1;\n  int y1;\n  int x2;\n  int y2;\n  int level;\n  char *name;\n};\nstatic char         * e;\nstatic struct entry   lis[ 1024 ];\nstatic int            len = 0;\n\nstatic int\nnanikaka (\n  void\n  )\n{\n  int nol;\n  int res = 0;\n\n  if ( e[ 0 ] != '<'\n    || e[ 1 ] == '/' ) return ( 0 );\n\n  nol = len++;\n  lis[ nol ].name = ++e;\n  while ( *e != '>' ) ++e;\n  *( e++ ) = '\\0';\n  lis[ nol ].x1 =\n  lis[ nol ].y1 =\n  lis[ nol ].x2 =\n  lis[ nol ].y2 = 0;\n  while ( isdigit ( *e ) )  lis[ nol ].x1 = ( lis[ nol ].x1 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].y1 = ( lis[ nol ].y1 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].x2 = ( lis[ nol ].x2 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].y2 = ( lis[ nol ].y2 * 10 )\n                                          + ( *( e++ ) - '0' );\n\n  for ( ; ; )\n  {\n    const int ret = nanikaka ( );\n\n    if ( !ret ) break ;\n    res += ret;\n  }\n  lis[ nol ].level = res;\n\n  while ( *( e++ ) != '>' ) ;\n\n  return ( res + 1 );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    char s[ 1024 ];\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( !( n ) ) break ;\n\n    scanf ( \" %s\", s );\n    e = s;\n    nanikaka ( );\n\n    while ( n-- )\n    {\n      int x, y;\n\n      scanf ( \" %d %d\", &x, &y );\n\n      for ( i = len - 1; i >= 0; --i )\n      {\n        if ( x >= lis[ i ].x1\n          && x <= lis[ i ].x2\n          && y >= lis[ i ].y1\n          && y <= lis[ i ].y2 )\n        {\n          printf ( \"%s %d\\n\", lis[ i ].name, lis[ i ].level );\n          break ;\n        }\n      }\n\n      if ( i < 0 )\n      {\n        puts ( \"OUT OF MAIN PANEL 1\" );\n      }\n    }\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "main(){\nputs(\"main 2\");\nputs(\"main 2\");\nputs(\"menu 0\");\nputs(\"OUT OF MAIN PANEL 1\");\nputs(\"primary 0\");\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\nputs(\"main 2\");\nputs(\"main 2\");\nputs(\"menu 0\");\nputs(\"OUT OF MAIN PANEL 1\");\nputs(\"primary 0\");\n}"
  },
  {
    "language": "C",
    "code": "*T[99]={\"OUT OF MAIN PANEL\"},X[99],Y[99],V[99],W[99],c[99],w;P(p,d){for(c[p]=0;scanf(\"%a[^/>]>%d,%d,%d,%d<\",T+w,X+w,Y+w,V+w,W+w)&&scanf(\"%*[^>]>%[<]\",&d,c[p]++,P(w++)););}main(n,x,y,i){for(;scanf(\"%d\\n<\",&n)*n;)for(w=1,P(0);n--;printf(\"%s %d\\n\",T[i],c[i]))for(scanf(\"%d%d\",&x,&y),i=w;--i&&x<X[i]|y<Y[i]|x>V[i]|y>W[i];);}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-10 1031: Simple GUI Application\n// 2017.8.19 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nchar *gets(char *);\nchar buf[100], *p;\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p) || *p == ',') p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nchar tag[1005];\nint x, y;\nchar ans[100]; int no;\n\nchar *parse(char *tp, int *done, int *k)\n{\n\tint x1, y1, x2, y2;\n\tint ok = 0;\n\tint sum = 0, s;\n\tchar name[100], *np;\n\n\t*k = 0;\n//\twhile (isspace(*tp)) tp++;\n\tif (!*tp) return tp;\n\ttp++;\t// '<'\n\tnp = name; while (*tp != '>') *np++ = *tp++; *np = 0;\n\ttp++;\t// '>'\n\tp = tp, x1 = getInt(), y1 = getInt(), x2 = getInt(), y2 = getInt(),\ttp = p;\n\tif (x1 <= x && x <= x2 && y1 <= x && x <= y2) ok = 1;\n\twhile (*tp) {\n//\t\twhile (isspace(*tp)) tp++;\n\t\tif (*(tp + 1) == '/') break;\n\t\ttp = parse(tp, done, &s), sum += s+1;\n\t}\n\twhile (*tp++ != '>') ;\n\tif (!*done && ok) strcpy(ans, name), no = sum, *done = 1;\n\t*k = sum;\n\treturn tp;\n}\n\nint main()\n{\n\tint n, i, d, k;\n\n\twhile (1) {\n\t\tgets(p = buf); if (!(n = getInt())) break;\n\t\tgets(tag);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tgets(p = buf), x = getInt(), y = getInt();\n\t\t\tno = -1, d = 0;\n\t\t\tparse(tag, &d, &k);\n\t\t\tif (no < 0) puts(\"OUT OF MAIN PANEL 1\");\n\t\t\telse printf(\"%s %d\\n\", ans, no);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char Tag[99][99]={\"OUT OF MAIN PANEL\"};\nX[99],Y[99],V[99],W[99],c[99],w;\nP(p){\n\tchar t[99],d[99];\n\tc[p]=0;\n\tfor(;w++,scanf(\"%[^/>]>%d,%d,%d,%d<\",Tag[w],X+w,Y+w,V+w,W+w,d);){\n\t\tc[p]++;\n\t\tP(w);\n\t\tif(scanf(\"%[^>]>%[<]\",t,d)!=2){\n\t\t\tw++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tw--;\n}\nmain(n,x,y,i){\n\tfor(;scanf(\"%d\\n<\",&n)*n;){\n\t\tP(w=0);\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tfor(i=w+1;--i;){\n\t\t\t\tif(x>=X[i]&&y>=Y[i]&&x<V[i]&&y<W[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"%s %d\\n\",Tag[i],c[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-10 1031: Simple GUI Application\n// 2017.8.19 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nchar *gets(char *);\nchar buf[100], *p;\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p) || *p == ',') p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nchar tag[1005];\nint x, y;\nchar ans[100]; int no;\n\nchar *parse(char *tp, int *done, int *k)\n{\n\tint x1, y1, x2, y2;\n\tint ok = 0;\n\tint sum = 0, s;\n\tchar name[100], *np;\n\n\t*k = 0;\n//\twhile (isspace(*tp)) tp++;\n\tif (!*tp) return tp;\n\ttp++;\t// '<'\n\tnp = name; while (*tp != '>') *np++ = *tp++; *np = 0;\n\ttp++;\t// '>'\n\tp = tp, x1 = getInt(), y1 = getInt(), x2 = getInt(), y2 = getInt(),\ttp = p;\n\tif (x1 <= x && x <= x2 && y1 <= x && x <= y2) ok = 1;\n\twhile (*tp) {\n//\t\twhile (isspace(*tp)) tp++;\n\t\tif (*(tp + 1) == '/') break;\n\t\ttp = parse(tp, done, &s), sum++;   // sum += s+1;\n\t}\n\twhile (*tp++ != '>') ;\n\tif (!*done && ok) strcpy(ans, name), no = sum, *done = 1;\n\t*k = sum;\n\treturn tp;\n}\n\nint main()\n{\n\tint n, i, d, k;\n\n\twhile (1) {\n\t\tgets(p = buf); if (!(n = getInt())) break;\n\t\tgets(tag);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tgets(p = buf), x = getInt(), y = getInt();\n\t\t\tno = -1, d = 0;\n\t\t\tparse(tag, &d, &k);\n\t\t\tif (no < 0) puts(\"OUT OF MAIN PANEL 1\");\n\t\t\telse printf(\"%s %d\\n\", ans, no);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char T[99][99]={\"OUT OF MAIN PANEL\"};\nX[99],Y[99],V[99],W[99],c[99],w;\nP(p,d){\n\tfor(c[p]=0;scanf(\"%[^/>]>%d,%d,%d,%d<\",T[w],X+w,Y+w,V+w,W+w)&&scanf(\"%*[^>]>%[<]\",&d,c[p]++,P(w++)););\n}\nmain(n,x,y,i){\n\tfor(;scanf(\"%d\\n<\",&n)*n;)\n\t\tfor(w=1,P(0);n--;printf(\"%s %d\\n\",T[i],c[i]))\n\t\t\tfor(scanf(\"%d%d\",&x,&y),i=w;--i&&x<X[i]|y<Y[i]|x>V[i]|y>W[i];);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-10 1031: Simple GUI Application\n// 2017.8.19 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nchar *gets(char *);\nchar buf[100], *p;\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p) || *p == ',') p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nchar tag[1005];\nint x, y;\nchar ans[100]; int no;\n\nchar *parse(char *tp, int *done, int *k)\n{\n\tint x1, y1, x2, y2;\n\tint ok = 0;\n\tint sum = 0, s;\n\tchar name[100], *np;\n\n\t*k = 0;\n//\twhile (isspace(*tp)) tp++;\n\tif (!*tp) return tp;\n\ttp++;\t// '<'\n\tnp = name; while (*tp != '>') *np++ = *tp++; *np = 0;\n\ttp++;\t// '>'\n\tp = tp, x1 = getInt(), y1 = getInt(), x2 = getInt(), y2 = getInt(),\ttp = p;\n\tif (x1 <= x && x <= x2 && y1 <= y && y <= y2) ok = 1;\n\twhile (*tp) {\n//\t\twhile (isspace(*tp)) tp++;\n\t\tif (*(tp + 1) == '/') break;\n\t\ttp = parse(tp, done, &s), sum += s+1;\n\t}\n\twhile (*tp++ != '>') ;\n\tif (!*done && ok) strcpy(ans, name), no = sum, *done = 1;\n\t*k = sum;\n\treturn tp;\n}\n\nint main()\n{\n\tint n, i, d, k;\n\n\twhile (1) {\n\t\tgets(p = buf); if (!(n = getInt())) break;\n\t\tgets(tag);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tgets(p = buf), x = getInt(), y = getInt();\n\t\t\tno = -1, d = 0;\n\t\t\tparse(tag, &d, &k);\n\t\t\tif (no < 0) puts(\"OUT OF MAIN PANEL 1\");\n\t\t\telse printf(\"%s %d\\n\", ans, no);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nstruct entry\n{\n  int x1;\n  int y1;\n  int x2;\n  int y2;\n  int level;\n  char *name;\n};\nstatic char         * e;\nstatic struct entry   lis[ 1024 ];\nstatic int            len;\n\nstatic int\nnanikaka (\n  void\n  )\n{\n  int nol;\n  int res = 0;\n\n  if ( e[ 0 ] != '<'\n    || e[ 1 ] == '/' ) return ( 0 );\n\n  nol = len++;\n  lis[ nol ].name = ++e;\n  while ( *e != '>' ) ++e;\n  *( e++ ) = '\\0';\n  lis[ nol ].x1 =\n  lis[ nol ].y1 =\n  lis[ nol ].x2 =\n  lis[ nol ].y2 = 0;\n  while ( isdigit ( *e ) )  lis[ nol ].x1 = ( lis[ nol ].x1 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].y1 = ( lis[ nol ].y1 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].x2 = ( lis[ nol ].x2 * 10 )\n                                          + ( *( e++ ) - '0' );\n  ++e;\n  while ( isdigit ( *e ) )  lis[ nol ].y2 = ( lis[ nol ].y2 * 10 )\n                                          + ( *( e++ ) - '0' );\n\n  for ( ; ; )\n  {\n    const int ret = nanikaka ( );\n\n    if ( !ret ) break ;\n    ++res;\n  }\n  lis[ nol ].level = res;\n\n  while ( *( e++ ) != '>' ) ;\n\n  return ( res + 1 );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    char s[ 1024 ];\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( !( n ) ) break ;\n\n    scanf ( \" %s\", s );\n    e = s;\n    len = 0;\n    nanikaka ( );\n\n    while ( n-- )\n    {\n      int x, y;\n\n      scanf ( \" %d %d\", &x, &y );\n\n      for ( i = len - 1; i >= 0; --i )\n      {\n        if ( x >= lis[ i ].x1\n          && x <= lis[ i ].x2\n          && y >= lis[ i ].y1\n          && y <= lis[ i ].y2 )\n        {\n          printf ( \"%s %d\\n\", lis[ i ].name, lis[ i ].level );\n          break ;\n        }\n      }\n\n      if ( i < 0 )\n      {\n        puts ( \"OUT OF MAIN PANEL 1\" );\n      }\n    }\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "*T[99]={\"OUT OF MAIN PANEL\"},X[99],Y[99],V[99],W[99],c[99],w;P(p){for(c[p]=0;scanf(\"%a[^/>]>%d,%d,%d,%d<\",T+w,X+w,Y+w,V+w,W+w)&&scanf(\"%*[^>]>%[<]\",X,c[p]++,P(w++)););}main(n,x,y,i){for(;scanf(\"%d\\n<\",&n)*n;)for(w=1,P(0);n--;printf(\"%s %d\\n\",T[i],c[i]))for(scanf(\"%d%d\",&x,&y),i=w;--i&&x<X[i]|y<Y[i]|x>V[i]|y>W[i];);}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>):Unit {\n    while (true) {\n        val n = readLine()!!.trim().toInt()\n        if (n == 0) return\n        val (tag, _) = parseTagStructure(readLine()!!.trim())\n        repeat(n){\n            val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n            val t = tag.touchedTag(Point(x, y))\n            println(\n                    when(t){\n                        null -> \"OUT OF MAIN PANEL 1\"\n                        else -> \"${t.name} ${t.childSize()}\"\n                    }\n            )\n        }\n    }\n}\nclass Tag(val name:String, val leftTop:Point, val rightBottom:Point, private val mChildren: Iterable<Tag>){\n    private fun isTouched(touchPoint:Point):Boolean {\n        return touchPoint.x in leftTop.x .. rightBottom.x && touchPoint.y in leftTop.y .. rightBottom.y\n    }\n    fun childSize():Int = mChildren.count()\n    fun touchedTag(touchPoint:Point):Tag? {\n        return if (isTouched(touchPoint)){\n            val child = mChildren.mapNotNull{it.touchedTag(touchPoint)}.firstOrNull()\n            when(child){\n                null -> this\n                else -> child\n            }\n        }else null\n    }\n}\nfun parsePoints(str:String):Pair<Pair<Point, Point>, String> {\n    val pattern = \"\"\"^(\\d+),(\\d+),(\\d+),(\\d+)(.*)\"\"\".toRegex()\n    val matched = pattern.matchEntire(str)!!\n    val (a, b, c, d) = matched.groupValues.drop(1).take(4).map(String::toInt)\n    val rest = matched.groupValues.last()\n    return Pair(Pair(Point(a, b), Point(c, d)), rest)\n}\nfun parseStartTag(str:String):Pair<String, String> {\n    val pattern = \"\"\"^<(\\w+)>(.*)\"\"\".toRegex()\n    val matched = pattern.matchEntire(str)!!\n    return Pair(matched.groupValues[1], matched.groupValues[2])\n}\nfun parseEndTag(str:String):Pair<String, String>{\n    val pattern = \"\"\"^</(\\w+)>(.*)\"\"\".toRegex()\n    val matched = pattern.matchEntire(str)!!\n    return Pair(matched.groupValues[1], matched.groupValues[2])\n}\nfun parseTagStructure(str:String):Pair<Tag, String>{\n    val (name, rest) = parseStartTag(str)\n    val (p, rest2) = parsePoints(rest)\n    val (tags, rest3) = parseTagSequence(rest2)\n    val (endName, r) = parseEndTag(rest3)\n    assert(name == endName)\n    return Pair(Tag(name, p.first, p.second, tags), r)\n}\nfun parseTagSequence(str:String):Pair<Collection<Tag>, String> {\n    val stack = Stack<Tag>()\n    val startTag = \"\"\"^<(\\w+)>(.*)\"\"\".toRegex()\n    var s = str\n    while(true){\n        if (startTag.matches(s)){\n            val (t, r) = parseTagStructure(s)\n            stack.push(t)\n            s = r\n        }else return Pair(stack, s)\n    }\n}\ndata class Point(val x:Int, val y:Int)\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport java.util.ArrayList;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tPanel parent, child;\n\t\t\tparent = parse(br.readLine());\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint p[] = new int[2];\n\t\t\t\tp[0] = Integer.parseInt(line.split(\" \")[0]);\n\t\t\t\tp[1] = Integer.parseInt(line.split(\" \")[1]);\n\t\t\t\tchild = parent.touched(main.new Point(p[0], p[1]));\n\t\t\t\tif (child == null) {\n\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out\n\t\t\t\t\t\t\t.println(child.name + \" \" + child.children.size());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// タグ文字列のパース\n\tpublic static Panel parse(String struct) {\n\n\t\tStack<Panel> stack = new Stack<Panel>();\n\t\tPanel result = null;\n\n\t\tchar c;\n\t\tStringBuilder name, points;\n\t\tname = points = null;\n\t\tfor (int i = 0; i < struct.length(); i++) {\n\t\t\tc = struct.charAt(i);\n\n\t\t\t// 名前の読み取り\n\t\t\tif (c == '<') {\n\t\t\t\ti++;\n\t\t\t\tc = struct.charAt(i);\n\t\t\t\tif ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\t\t\tname = new StringBuilder();\n\t\t\t\t\twhile (c != '>') {\n\t\t\t\t\t\tname.append(c);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tc = struct.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t} else if (c == '/') {\n\t\t\t\t\tstack.pop();\n\t\t\t\t\twhile (c != '>') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tc = struct.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 座標の読み取り\n\t\t\tif ((c >= '0' && c <= '9') || c == ',') {\n\t\t\t\tpoints = new StringBuilder();\n\t\t\t\tpoints.append(c);\n\t\t\t\twhile (struct.charAt(i + 1) != '<') {\n\t\t\t\t\ti++;\n\t\t\t\t\tpoints.append(struct.charAt(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 新しいパネル\n\t\t\tif (name != null && points != null) {\n\n\t\t\t\tint[] p = new int[4];\n\t\t\t\tp[0] = Integer.parseInt(points.toString().split(\",\")[0]);\n\t\t\t\tp[1] = Integer.parseInt(points.toString().split(\",\")[1]);\n\t\t\t\tp[2] = Integer.parseInt(points.toString().split(\",\")[2]);\n\t\t\t\tp[3] = Integer.parseInt(points.toString().split(\",\")[3]);\n\n\t\t\t\tPoint top, buttom;\n\t\t\t\tPanel panel;\n\n\t\t\t\ttop = main.new Point(p[0], p[1]);\n\t\t\t\tbuttom = main.new Point(p[2], p[3]);\n\t\t\t\tpanel = main.new Panel(name.toString(), top, buttom);\n\n\t\t\t\tif (stack.size() > 0) {\n\t\t\t\t\tstack.peek().children.add(panel);\n\t\t\t\t\tstack.push(panel);\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(main.new Panel(name.toString(), top, buttom));\n\t\t\t\t\tresult = stack.firstElement();\n\n\t\t\t\t}\n\t\t\t\tname = points = null;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t// ポイント\n\tpublic class Point {\n\t\tint x, y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\t// パネル\n\tpublic class Panel {\n\t\tString name;\n\t\tPoint top, buttom;\n\t\tArrayList<Panel> children;\n\n\t\tpublic Panel(String name, Point top, Point buttom) {\n\t\t\tthis.name = name;\n\t\t\tthis.top = top;\n\t\t\tthis.buttom = buttom;\n\t\t\tchildren = new ArrayList<Panel>();\n\t\t}\n\n\t\tpublic ArrayList<Panel> add(Panel panel) {\n\t\t\tif (children.add(panel))\n\t\t\t\treturn children;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\n\t\tprivate boolean isIntercect(Point touch) {\n\t\t\tif (touch.x >= top.x && touch.y >= top.y)\n\t\t\t\tif (touch.x <= buttom.x && touch.y <= buttom.y)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic Panel touchedChild(Point touch) {\n\t\t\tfor (Panel child : children) {\n\t\t\t\tif (child.isIntercect(touch))\n\t\t\t\t\treturn child;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Panel touched(Point touch) {\n\t\t\tPanel result = null;\n\t\t\tif (this.isIntercect(touch)) {\n\t\t\t\tPanel parent, child;\n\t\t\t\tparent = this;\n\t\t\t\tchild = parent.touchedChild(touch);\n\t\t\t\twhile (!child.equals(parent)) {\n\t\t\t\t\tparent = child;\n\t\t\t\t\tchild = parent.touchedChild(touch);\n\t\t\t\t}\n\t\t\t\tresult = child;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\tpublic static ArrayList<ArrayList<Integer>> g;\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\twhile(true){\n\t\t\tint n = readInt();\n\t\t\tif(n == 0) return;\n\t\t\t\n\t\t\t\n\t\t\tPanel p = new Panel(readLine());\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] in = readIntMap();\n\t\t\t\tint x = in[0], y = in[1];\n\t\t\t\tif(p.in(x, y)){\n\t\t\t\t\tp.check(x,y);\n\t\t\t\t}else{\n\t\t\t\t\tp(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Panel extends MyUtil{\n\tArrayList<Panel> children = new ArrayList<Panel>();\n\tString name;\n\tint left, right, top, bottom;\n\tPanel(String str){\n\t\tPattern p = Pattern.compile(\"^<(.*?)>([0-9]+),([0-9]+),([0-9]+),([0-9]+)(.*)</\\\\1>$\");\n\t\tMatcher m = p.matcher(str);\n\t\tm.find();\n\t\t\n\t\tname = m.group(1);\n\t\tleft = parseInt(m.group(2));\n\t\ttop = parseInt(m.group(3));\n\t\tright = parseInt(m.group(4));\n\t\tbottom = parseInt(m.group(5));\n\t\t\n\t\tString cstr = m.group(6);\n\t\tPattern cp = Pattern.compile(\"<(.*?)>.*</\\\\1>\");\n\t\tMatcher cm = p.matcher(cstr);\n\t\twhile(cm.find()){\n\t\t\tchildren.add(new Panel(cm.group()));\n\t\t}\n\t}\n\t\n\tpublic boolean in(int x, int y){\n\t\treturn left <= x && x <= right && top <= y && y <= bottom;\n\t}\n\t\n\tpublic void check(int x, int y){\n\t\tboolean flag = false;\n\t\tfor(Panel child : children){\n\t\t\tif(child.in(x, y)){\n\t\t\t\tchild.check(x, y);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) p(name + \" \" + children.size());\n\t}\n}\n\n\n/**\n * 整数を数え上げたりするクラス\n * new Prime(int n) でnまでエラトステネスの篩を実行。\n * @author yoshikyoto\n * @param a[i] iが素数の時true\n * @param count[i] i以下の素数の数\n */\nclass Prime{\n\tboolean[] a;\n\tint[] count;\n\tPrime(int n){\n\t\ta = new boolean[n+1];\n\t\ta[0] = false; a[1] = false;\n\t\tfor(int i = 2; i <= n; i++) a[i] = true;\n\t\t// ふるい\n\t\tfor(int i = 2; i < (n - 3) / 2; i++)\n\t\t\tif(a[i]) for(int j = 2; j * i <= n; j++)\n\t\t\t\t\ta[j * i] = false;\n\t\t\n\t\t// 数え上げ\n\t\tcount = new int[n+1];\n\t\tcount[0] = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint gain = 0;\n\t\t\tif(a[i]) gain = 1;\n\t\t\tcount[i] = count[i-1] + gain;\n\t\t}\n\t}\n}\n\nclass AI extends ArrayList<Integer>{}\nclass SI extends Stack<Integer>{}\n\nclass HMI<E> extends HashMap<E, Integer>{\n\tArrayList<E> keyArray = new ArrayList<E>();\n\tpublic void add(E key){add(key, 1);}\n\tpublic void add(E key, Integer value){\n\t\tif(containsKey(key)){value += get(key);\n\t\t}else{keyArray.add(key);}\n\t\tput(key, value);\n\t}\n}\n\nclass HMSI extends HMI<String>{}\nclass Q<E> extends ArrayDeque<E>{\n\tpublic void push(E item){add(item);}\n\tpublic E pop(){return poll();}\n}\nclass QS extends Q<String>{}\nclass QI extends Q<Integer>{}\n\nclass MyUtil extends MyIO{\n\tpublic static long start_time = 0;\n\tpublic static void start(){start_time = System.currentTimeMillis();}\n\tpublic static void end(){\n\t\tif(start_time == 0) return;\n\t\tlong time = System.currentTimeMillis() - start_time;\n\t\tif(DEBUG) p(time + \"ms\");\n\t}\n\tpublic static int digit(int n){return String.valueOf(n).length();}\n\tpublic static String reverse(String s){\n\t\tStringBuffer sb = new StringBuffer(s);\n\t\treturn sb.reverse().toString();\n\t}\n\tpublic static void sort(int[] a){Arrays.sort(a);}\n\tpublic static void dsort(int[] a){\n\t\tArrays.sort(a);\n\t\tint l = a.length;\n\t\tfor(int i = 0; i < l/2; i++){\n\t\t\tint tmp = a[i]; a[i] = a[l-1-i]; a[l-1-i] = tmp;\n\t\t}\n\t}\n\tpublic static void sleep(int t){try{Thread.sleep(t);}catch(Exception e){}}\n\tpublic static int sum(int[] a){int s = 0; for(int i = 0; i < a.length; i++)s+=a[i]; return s;}\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n}\n\nclass MyIO extends MyMath{\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static char scNextChar(){return sc.next().charAt(0);}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static boolean DEBUG = false;\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static void p(Object o){System.out.println(o.toString());}\n\tpublic static void pr(Object o){System.out.print(o.toString());}\n\tpublic static void d(Object o){if(DEBUG)System.out.println(o.toString());}\n\tpublic static void dr(Object o){if(DEBUG)System.out.print(o.toString());}\n\tpublic static void da(Object[] o){if(DEBUG)System.out.println(Arrays.toString(o));}\n\tpublic static void da(int[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(double[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(boolean[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){return Integer.parseInt(o.toString());}\n}\n\nclass MyMath{\n\t/**\n\t * 弧度法の角度を入力してsinの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double sin(int r){return Math.sin(Math.toRadians(r));}\n\n\t/**\n\t * 弧度法の角度を入力してcosの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double cos(int r){return Math.cos(Math.toRadians(r));}\n\tpublic static int max(int a, int b){return Math.max(a, b);}\n\tpublic static int min(int a, int b){return Math.min(a, b);}\n\tpublic static boolean isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    // 並行な場合\n\t    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n\t    if(m == 0) return false;\n\t    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n\t    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n\t    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n\t    return (0 < r && r <= 1 && 0 < s && s <= 1);\n\t}\n\tpublic static boolean isParallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    if((x2-x1)*(y4-y3) == (y2-y1)*(x4-x3)) return true;\n\t    else return false;\n\t}\n\tpublic static double sq(double d){return d*d;}\n\tpublic static int sq(int i){return i*i;}\n\tpublic static int sqdist(int x1, int y1, int x2, int y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double sqdist(double x1, double y1, double x2, double y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double dist(int x1, int y1, int x2, int y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tpublic static double dist(double x1, double y1, double x2, double y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\tpublic static ArrayList<ArrayList<Integer>> g;\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\twhile(true){\n\t\t\tint n = readInt();\n\t\t\tif(n == 0) return;\n\t\t\t\n\t\t\t\n\t\t\tPanel p = new Panel(readLine());\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] in = readIntMap();\n\t\t\t\tint x = in[0], y = in[1];\n\t\t\t\tif(p.in(x, y)){\n\t\t\t\t\tp.check(x,y);\n\t\t\t\t}else{\n\t\t\t\t\tp(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Panel extends MyUtil{\n\tArrayList<Panel> children = new ArrayList<Panel>();\n\tString name;\n\tint left, right, top, bottom;\n\tPanel(String str){\n\t\tPattern p = Pattern.compile(\"<(.*?)>([0-9]+),([0-9]+),([0-9]+),([0-9]+)(.*)</\\\\1>\");\n\t\tMatcher m = p.matcher(str);\n\t\tm.find();\n\t\t// p(m.group());\n\t\t\n\t\tname = m.group(1);\n\t\tleft = parseInt(m.group(2));\n\t\ttop = parseInt(m.group(3));\n\t\tright = parseInt(m.group(4));\n\t\tbottom = parseInt(m.group(5));\n\t\t\n\t\tString cstr = m.group(6);\n\t\tPattern cp = Pattern.compile(\"<(.*?)>.*</\\\\1>\");\n\t\tMatcher cm = p.matcher(cstr);\n\t\twhile(cm.find()){\n\t\t\tchildren.add(new Panel(cm.group()));\n\t\t}\n\t}\n\t\n\tpublic boolean in(int x, int y){\n\t\treturn left <= x && x <= right && top <= y && y <= bottom;\n\t}\n\t\n\tpublic void check(int x, int y){\n\t\tboolean flag = false;\n\t\tfor(Panel child : children){\n\t\t\tif(child.in(x, y)){\n\t\t\t\tchild.check(x, y);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) p(name + \" \" + children.size());\n\t}\n}\n\n\n/**\n * 整数を数え上げたりするクラス\n * new Prime(int n) でnまでエラトステネスの篩を実行。\n * @author yoshikyoto\n * @param a[i] iが素数の時true\n * @param count[i] i以下の素数の数\n */\nclass Prime{\n\tboolean[] a;\n\tint[] count;\n\tPrime(int n){\n\t\ta = new boolean[n+1];\n\t\ta[0] = false; a[1] = false;\n\t\tfor(int i = 2; i <= n; i++) a[i] = true;\n\t\t// ふるい\n\t\tfor(int i = 2; i < (n - 3) / 2; i++)\n\t\t\tif(a[i]) for(int j = 2; j * i <= n; j++)\n\t\t\t\t\ta[j * i] = false;\n\t\t\n\t\t// 数え上げ\n\t\tcount = new int[n+1];\n\t\tcount[0] = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint gain = 0;\n\t\t\tif(a[i]) gain = 1;\n\t\t\tcount[i] = count[i-1] + gain;\n\t\t}\n\t}\n}\n\nclass AI extends ArrayList<Integer>{}\nclass SI extends Stack<Integer>{}\n\nclass HMI<E> extends HashMap<E, Integer>{\n\tArrayList<E> keyArray = new ArrayList<E>();\n\tpublic void add(E key){add(key, 1);}\n\tpublic void add(E key, Integer value){\n\t\tif(containsKey(key)){value += get(key);\n\t\t}else{keyArray.add(key);}\n\t\tput(key, value);\n\t}\n}\n\nclass HMSI extends HMI<String>{}\nclass Q<E> extends ArrayDeque<E>{\n\tpublic void push(E item){add(item);}\n\tpublic E pop(){return poll();}\n}\nclass QS extends Q<String>{}\nclass QI extends Q<Integer>{}\n\nclass MyUtil extends MyIO{\n\tpublic static long start_time = 0;\n\tpublic static void start(){start_time = System.currentTimeMillis();}\n\tpublic static void end(){\n\t\tif(start_time == 0) return;\n\t\tlong time = System.currentTimeMillis() - start_time;\n\t\tif(DEBUG) p(time + \"ms\");\n\t}\n\tpublic static int digit(int n){return String.valueOf(n).length();}\n\tpublic static String reverse(String s){\n\t\tStringBuffer sb = new StringBuffer(s);\n\t\treturn sb.reverse().toString();\n\t}\n\tpublic static void sort(int[] a){Arrays.sort(a);}\n\tpublic static void dsort(int[] a){\n\t\tArrays.sort(a);\n\t\tint l = a.length;\n\t\tfor(int i = 0; i < l/2; i++){\n\t\t\tint tmp = a[i]; a[i] = a[l-1-i]; a[l-1-i] = tmp;\n\t\t}\n\t}\n\tpublic static void sleep(int t){try{Thread.sleep(t);}catch(Exception e){}}\n\tpublic static int sum(int[] a){int s = 0; for(int i = 0; i < a.length; i++)s+=a[i]; return s;}\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n}\n\nclass MyIO extends MyMath{\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static char scNextChar(){return sc.next().charAt(0);}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static boolean DEBUG = false;\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static void p(Object o){System.out.println(o.toString());}\n\tpublic static void pr(Object o){System.out.print(o.toString());}\n\tpublic static void d(Object o){if(DEBUG)System.out.println(o.toString());}\n\tpublic static void dr(Object o){if(DEBUG)System.out.print(o.toString());}\n\tpublic static void da(Object[] o){if(DEBUG)System.out.println(Arrays.toString(o));}\n\tpublic static void da(int[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(double[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(boolean[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){return Integer.parseInt(o.toString());}\n}\n\nclass MyMath{\n\t/**\n\t * 弧度法の角度を入力してsinの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double sin(int r){return Math.sin(Math.toRadians(r));}\n\n\t/**\n\t * 弧度法の角度を入力してcosの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double cos(int r){return Math.cos(Math.toRadians(r));}\n\tpublic static int max(int a, int b){return Math.max(a, b);}\n\tpublic static int min(int a, int b){return Math.min(a, b);}\n\tpublic static boolean isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    // 並行な場合\n\t    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n\t    if(m == 0) return false;\n\t    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n\t    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n\t    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n\t    return (0 < r && r <= 1 && 0 < s && s <= 1);\n\t}\n\tpublic static boolean isParallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    if((x2-x1)*(y4-y3) == (y2-y1)*(x4-x3)) return true;\n\t    else return false;\n\t}\n\tpublic static double sq(double d){return d*d;}\n\tpublic static int sq(int i){return i*i;}\n\tpublic static int sqdist(int x1, int y1, int x2, int y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double sqdist(double x1, double y1, double x2, double y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double dist(int x1, int y1, int x2, int y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tpublic static double dist(double x1, double y1, double x2, double y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twhile(true){\n\t\t\t\t/* input */\n\t\t\t\tint n = Integer.parseInt(br.readLine());\n\n\t\t\t\tif(n==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tString tag = br.readLine();\n\n\t\t\t\tArrayList<Panel> ps = parseTags(tag);\n\n\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tString[] str = br.readLine().split(\" \");\n\t\t\t\t\tint x = Integer.parseInt(str[0]), y = Integer.parseInt(str[1]);\n\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tPanel current = ps.get(0);\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(!current.point(x, y)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tboolean c = false;\n\t\t\t\t\t\tfor(Panel child : current.children){\n\t\t\t\t\t\t\tif(child.point(x, y)){\n\t\t\t\t\t\t\t\tc = true;\n\t\t\t\t\t\t\t\tcurrent = child;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!c) break;\n\n\t\t\t\t\t}\n\t\t\t\t\tif(found){\n\t\t\t\t\t\tSystem.out.println(current.name + \" \" + current.children.size());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t}\n\n\tstatic class Panel{\n\t\tpublic String name;\n\t\tpublic int x1,x2,y1,y2;\n\t\tpublic ArrayList<Panel> children;\n\n\t\tpublic Panel(String name, String coordinates){\n\t\t\tthis.name = name;\n\t\t\tString[] c = coordinates.split(\",\");\n\t\t\tthis.x1 = Integer.parseInt(c[0]);\n\t\t\tthis.y1 = Integer.parseInt(c[1]);\n\t\t\tthis.x2 = Integer.parseInt(c[2]);\n\t\t\tthis.y2 = Integer.parseInt(c[3]);\n\t\t\tthis.children = new ArrayList<Panel>();\n\t\t}\n\n\t\tboolean point(int x, int y){\n\t\t\tif(x1<=x&&x<=x2&&y1<=y&&y<=y2){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tpublic void output(){\n\t\t\tSystem.out.print(this.name + \":\");\n\t\t\tSystem.out.println(this.x1 + \", \" + this.x2 + \", \" + this.y1 + \", \" + this.y2);\n\t\t\tSystem.out.print(\"CHILDREN:\");\n\t\t\tfor(Panel p : this.children){\n\t\t\t\tSystem.out.print(\" \" + p.name);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tpublic boolean parentOf(Panel p){\n\t\t\tif(this.x1<p.x1&&this.x2>p.x2&&this.y1<p.y1&&this.y2>p.y2) return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static ArrayList<Panel> parseTag(String tags){\n\t\tArrayList<Panel> p = new ArrayList<Panel>();\n\n\t\tPattern pat = Pattern.compile(\"<[^/].+?>\");\n\t\tPattern pat2 = Pattern.compile(\">[0-9].*?<\");\n\t\tMatcher m = pat.matcher(tags);\n\t\tMatcher m2 = pat2.matcher(tags);\n\n\t\twhile(m.find()){\n\t\t\tString name = m.group().substring(1,m.group().length()-1);\n\t\t\tPattern patc = Pattern.compile(\"</\" + name + \">\");\n\t\t\tMatcher mc = patc.matcher(tags);\n\n\t\t\tif(m2.find()&&mc.find()){\n\t\t\t\tString coordinates = m2.group(0).substring(1,m2.group(0).length()-1);\n\n\t\t\t\tSystem.out.println(m.start() + \",\" + mc.start());\n\t\t\t\tPanel newp = new Panel(name,coordinates); \n\n\t\t\t\tfor(Panel pp : p){\n\t\t\t\t\tif(pp.parentOf(newp)){\n\t\t\t\t\t\tpp.children.add(newp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tp.add(newp);\n\n\n\t\t\t}\n\t\t}\n\n\t\treturn p;\n\t}\n\n\tpublic static ArrayList<Panel> parseTags(String tags){\n\t\tStack<Panel> stack = new Stack<Panel>();\n\t\tArrayList<Panel> p = new ArrayList<Panel>();\n\t\tString name, coordinates;\n\t\twhile(true){\n\t\t\tint s = 0, t = 0, nexts = 0;\n\t\t\twhile(tags.charAt(s)!='<'&&s<=tags.length()){\n\t\t\t\ts++;\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tif(s>=tags.length()) break;\n\t\t\twhile(tags.charAt(t)!='>'&&t<tags.length()){\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tname = tags.substring(s+1,t);\n\n\t\t\tnexts = t;\n\t\t\tif(tags.substring(t).indexOf(\"<\")>-1){\n\t\t\t\twhile(tags.charAt(nexts)!='<'){\n\t\t\t\t\tnexts++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(tags.charAt(s+1)!='/'){\n\t\t\t\tcoordinates = tags.substring(t+1,nexts);\n\t\t\t\tPanel pn = new Panel(name,coordinates);\n\t\t\t\tif(stack.size()>0) stack.peek().children.add(pn);\n\t\t\t\tstack.push(pn);\n\t\t\t\tp.add(pn);\n\t\t\t} else {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\ttags = tags.substring(nexts);\n\t\t}\n\t\treturn p;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class Component {\n\t\tint lux, luy, rdx, rdy;\n\t\tArrayList<Component> child;\n\t\tString name;\n\t\t\n\t\tpublic Component(String name, int lux, int luy, int rdx, int rdy) {\n\t\t\tsuper();\n\t\t\tthis.name = name;\n\t\t\tthis.lux = lux;\n\t\t\tthis.luy = luy;\n\t\t\tthis.rdx = rdx;\n\t\t\tthis.rdy = rdy;\n\t\t\t\n\t\t\tchild = new ArrayList<Component>();\n\t\t}\n\t\t\n\t\tpublic boolean is_hit(int x, int y){\n\t\t\tif(this.lux <= x && x <= this.rdx && this.luy <= y && y <= this.rdy){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Component getHitChild(int x, int y){\n\t\t\tfor(Component comp : child){\n\t\t\t\tif(comp.is_hit(x, y)){\n\t\t\t\t\treturn comp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic int getChildSize(){\n\t\t\treturn child.size();\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"<\" + lux + \", \" + luy + \"> \" + name + \" <\" + rdx + \", \" + rdy + \"> => \" + child;\n\t\t}\n\t}\n\t\n\tpublic static int parse(Component owner, char[] input, int first, int last){\n\t\tif(input[first] != '<'){\n\t\t\treturn last;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tint pos = first + 1;\n\t\twhile(input[pos] != '>'){\n\t\t\tsb.append(input[pos]);\n\t\t\tpos++;\n\t\t}\n\t\t\n\t\tpos++;\n\t\tint lux = 0, luy = 0, rdx = 0, rdy = 0;\n\t\t\n\t\twhile(input[pos] != ','){\n\t\t\tlux *= 10;\n\t\t\tlux += input[pos] - '0';\n\t\t\tpos++;\n\t\t}\n\t\tpos++;\n\t\t\n\t\twhile(input[pos] != ','){\n\t\t\tluy *= 10;\n\t\t\tluy += input[pos] - '0';\n\t\t\tpos++;\n\t\t}\n\t\tpos++;\n\t\t\n\t\twhile(input[pos] != ','){\n\t\t\trdx *= 10;\n\t\t\trdx += input[pos] - '0';\n\t\t\tpos++;\n\t\t}\n\t\tpos++;\n\t\t\n\t\twhile(input[pos] != '<'){\n\t\t\trdy *= 10;\n\t\t\trdy += input[pos] - '0';\n\t\t\tpos++;\n\t\t}\n\t\t\n\t\tComponent comp = new Component(sb.toString(), lux, luy, rdx, rdy);\n\t\t//System.out.println(sb.toString());\n\t\tif(owner != null){\n\t\t\towner.child.add(comp);\n\t\t}\n\t\t\n\t\twhile(input[pos] == '<' && input[pos + 1] != '/'){\n\t\t\tpos = parse(comp, input, pos, last);\n\t\t}\n\t\t\n\t\t//System.out.println(sb.toString() + \" : \" + (pos) + \" : \" + (pos + sb.length() + 3));\n\t\treturn pos + sb.length() + 3;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\tComponent owner = new Component(\"OUT OF MAIN PANEL\", 0, 0, 10000, 10000);\n\t\t\t\n\t\t\tparse(owner, input, 0, input.length - 1);\n\t\t\t\n\t\t\t//System.out.println(owner);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tComponent just_hit = owner;\n\t\t\t\t\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\twhile(just_hit.is_hit(x, y) && just_hit.getHitChild(x, y) != null){\n\t\t\t\t\tjust_hit = just_hit.getHitChild(x, y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(just_hit.name + \" \" + just_hit.getChildSize());\n\t\t\t}\n\n\t\t}\n\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twhile(true){\n\t\t\t\t/* input */\n\t\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\t\t\n\t\t\t\tif(n==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString tag = br.readLine();\n\t\t\t\t\n\t\t\t\tArrayList<Panel> ps = parseTags(tag);\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tString[] str = br.readLine().split(\" \");\n\t\t\t\t\tint x = Integer.parseInt(str[0]), y = Integer.parseInt(str[1]);\n\t\t\t\t\t\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tPanel current = ps.get(0);\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\t//System.out.println(\"current: \" + current.name);\n\t\t\t\t\t\tif(!current.point(x, y)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tboolean c = false;\n\t\t\t\t\t\tfor(Panel child : current.children){\n\t\t\t\t\t\t\tif(child.point(x, y)){\n\t\t\t\t\t\t\t\tc = true;\n\t\t\t\t\t\t\t\tcurrent = child;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!c) break;\n\n\t\t\t\t\t}\n\t\t\t\t\tif(found){\n\t\t\t\t\t\tSystem.out.println(current.name + \" \" + current.children.size());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t}\n\t\n\tstatic class Panel{\n\t\tpublic String name;\n\t\tpublic int x1,x2,y1,y2;\n\t\tpublic ArrayList<Panel> children;\n\t\t\n\t\tpublic Panel(String name, String coordinates){\n\t\t\tthis.name = name;\n\t\t\tString[] c = coordinates.split(\",\");\n\t\t\tthis.x1 = Integer.parseInt(c[0]);\n\t\t\tthis.y1 = Integer.parseInt(c[1]);\n\t\t\tthis.x2 = Integer.parseInt(c[2]);\n\t\t\tthis.y2 = Integer.parseInt(c[3]);\n\t\t\tthis.children = new ArrayList<Panel>();\n\t\t}\n\t\t\n\t\tboolean point(int x, int y){\n\t\t\tif(x1<=x&&x<=x2&&y1<=y&&y<=y2){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void output(){\n\t\t\tSystem.out.print(this.name + \":\");\n\t\t\tSystem.out.println(this.x1 + \", \" + this.x2 + \", \" + this.y1 + \", \" + this.y2);\n\t\t\tSystem.out.print(\"CHILDREN:\");\n\t\t\tfor(Panel p : this.children){\n\t\t\t\tSystem.out.print(\" \" + p.name);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tpublic boolean parentOf(Panel p){\n\t\t\tif(this.x1<p.x1&&this.x2>p.x2&&this.y1<p.y1&&this.y2>p.y2) return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static ArrayList<Panel> parseTags(String tags){\n\t\tArrayList<Panel> p = new ArrayList<Panel>();\n\t\t\n\t\tPattern pat = Pattern.compile(\"<[^/].+?>\");\n\t\tPattern patc = Pattern.compile(\"</.+?>\");\n\t\tPattern pat2 = Pattern.compile(\">[0-9].*?<\");\n\t\tMatcher m = pat.matcher(tags);\n\t\tMatcher mc = patc.matcher(tags);\n\t\tMatcher m2 = pat2.matcher(tags);\n\t\t\n\t\twhile(m.find()){\n\t\t\tif(m2.find()&&mc.find()){\n\t\t\t\tString name = m.group().substring(1,m.group().length()-1);\n\t\t\t\tString coordinates = m2.group(0).substring(1,m2.group(0).length()-1);\n\t\t\t\t\n\t\t\t\t//System.out.println(name +  \" s:\" + m.start());\n\t\t\t\t\n\t\t\t\tPanel newp = new Panel(name,coordinates); \n\t\t\t\t\n\t\t\t\tfor(Panel pp : p){\n\t\t\t\t\tif(pp.parentOf(newp)){\n\t\t\t\t\t\tpp.children.add(newp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp.add(newp);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn p;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tstatic Panel now;\n\tstatic List<Panel> list;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint N=cin.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tidx=0;\n\t\t\ts=(cin.next()+\"   \").toCharArray();\n\t\t\tlist=new LinkedList<Panel>();\n\t\t\tstrc();\n\t\t\tfor(Panel p:list){\n//\t\t\t\tSystem.out.println(p);\n\t\t\t\tif(p.children.size()!=0){\n\t\t\t\t\tfor(Panel c:p.children){\n//\t\t\t\t\t\tSystem.out.println(\"children \"+c);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif(p.parent!=null){\n//\t\t\t\t\tSystem.out.println(\"parent \"+p.parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint[] a=new int[2];\n\t\t\t\ta[0]=cin.nextInt();\n\t\t\t\ta[1]=cin.nextInt();\n\t\t\t\tboolean f=false;\n\t\t\t\tfor(Panel p:list){\n\t\t\t\t\tPanel ans=ans(a,p);\n\t\t\t\t\tif(ans!=null){\n\t\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean strc(){\n\t\tif(s[idx+1]=='/'){\n\t\t\treturn false;\n\t\t}\n\t\tidx++;\n\t\tString name=start();\n\t\tint[] p=value();\n\t\tPanel panel=new Panel(name,p);\n\t\tif(now!=null){\n\t\t\tnow.children.add(panel);\n\t\t\tpanel.parent=now;\n\t\t}\n\t\tnow=panel;\n\t\tlist.add(panel);\n\n\t\twhile(strc());\n\t\tend();\n\t\tif(now.parent!=null){\n\t\t\tnow=panel.parent;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic void end(){\n\t\twhile(s[idx]!='>'){\n\t\t\tidx++;\n\t\t}\n\t\tidx++;\n\t}\n\tstatic String start(){\n\t\tString re=\"\";\n\t\tfor(;s[idx]!='>';){\n\t\t\tre=re+s[idx++];\n\t\t}\n\t\tidx++;\n\t\treturn re;\n\t}\n\tstatic int[] value(){\n\t\tString re=\"\";\n\t\tfor(;s[idx]!='<';){\n\t\t\tre=re+s[idx++];\n\t\t}\n\t\tString[] ss=re.split(\",\");\n\t\tint[] p=new int[4];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tp[i]=Integer.parseInt(ss[i]);\n\t\t}\n\t\treturn p;\n\t}\n\tstatic Panel ans(int[] a,Panel p){\n\t\tif(in(a,p.p)){\n\t\t\tfor(Panel child:p.children){\n\t\t\t\tif(in(a,child.p)){\n\t\t\t\t\treturn ans(a,child);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t\telse{\n\t\t\treturn null;\n\t\t}\n\t}\n\t//点a、面b\n\tstatic boolean in(int[] a,int[] b){\n\t\tfor(int i=0;i<2;i++){\n\t\t\tif(b[i]>a[i]||b[i+2]<a[i])return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic class Panel{\n\t\tString name;\n\t\tPanel parent;\n\t\tint[] p;\n\t\tList<Panel>children;\n\t\tPanel(String s,int[] a){\n\t\t\tname=s;\n\t\t\tp=new int[4];\n\t\t\tchildren=new LinkedList<Panel>();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tp[i]=a[i];\n\n\t\t\t}\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn name+\" \"+children.size();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tString line = sc.next();\n\t\t\tPanel root = new Parser(line).parse();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tPanel p = root.hit(x, y);\n\t\t\t\tif (p == null) {\n\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(p.name + \" \" + p.child.size());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Parser {\n\n\t\tchar[] str;\n\t\tint pos;\n\n\t\tParser(String line) {\n\t\t\tthis.str = line.toCharArray();\n\t\t}\n\n\t\tPanel parse() {\n\t\t\t++pos;\n\t\t\tStringBuilder name = new StringBuilder();\n\t\t\twhile (str[pos] != '>') {\n\t\t\t\tname.append(str[pos]);\n\t\t\t\t++pos;\n\t\t\t}\n\t\t\t++pos;\n\t\t\tint x1 = parseInt();\n\t\t\t++pos;\n\t\t\tint y1 = parseInt();\n\t\t\t++pos;\n\t\t\tint x2 = parseInt();\n\t\t\t++pos;\n\t\t\tint y2 = parseInt();\n\t\t\tPanel ret = new Panel(x1, y1, x2, y2, name.toString());\n\t\t\twhile (str[pos + 1] != '/') {\n\t\t\t\tret.child.add(parse());\n\t\t\t}\n\t\t\twhile (str[pos] != '>') {\n\t\t\t\t++pos;\n\t\t\t}\n\t\t\t++pos;\n\t\t\treturn ret;\n\t\t}\n\n\t\tint parseInt() {\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= str[pos] && str[pos] <= '9') {\n\t\t\t\tret *= 10;\n\t\t\t\tret += str[pos] - '0';\n\t\t\t\t++pos;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic class Panel {\n\t\tint x1, y1, x2, y2;\n\t\tString name;\n\t\tArrayList<Panel> child = new ArrayList<Panel>();\n\n\t\tPanel(int x1, int y1, int x2, int y2, String name) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tPanel hit(int x, int y) {\n\t\t\tif (x < this.x1 || this.x2 < x || y < this.y1 || this.y2 < y) return null;\n\t\t\tfor (Panel c : child) {\n\t\t\t\tPanel ret = c.hit(x, y);\n\t\t\t\tif (ret != null) return ret;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Simple GUI Application\npublic class Main{\n\n\tclass E{\n\t\tString name;\n\t\tint x1, y1, x2, y2, num;\n\t\tList<E> adj;\n\t\tpublic E(String name, int x1, int y1, int x2, int y2) {\n\t\t\tthis.name = name;\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tadj = new ArrayList<E>();\n\t\t\tnum = -1;\n\t\t}\n\t\tint get(){\n\t\t\tif(num!=-1)return num;\n\t\t\tnum = adj.size();\n\t\t\tfor(E e:adj)num+=e.get();\n\t\t\treturn num;\n\t\t}\n\t\tboolean f(int x, int y){\n\t\t\tboolean hit =  x1<=x&&x<=x2&&y1<=y&&y<=y2;\n\t\t\tif(!hit)return hit;\n\t\t\tboolean here = true;\n\t\t\tfor(E e:adj)if(e.f(x, y))here = false;\n\t\t\tif(!here)return true;\n\t\t\tSystem.out.println(name+\" \"+get());\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tchar[] s;\n\tint id;\n\t\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\t\n\tE tag(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tchar ch = get();\n\t\twhile(ch!='>'){\n\t\t\tsb.append(ch);\n\t\t\tch = get();\n\t\t}\n\t\tE r = new E(sb.toString(), val(), val(), val(), val());\n\t\tch = get();\n\t\twhile(true){\n\t\t\tif(ch=='/')break;\n\t\t\tid--;\n\t\t\tr.adj.add(tag());\n\t\t\tch = get();\n\t\t}\n\t\twhile(ch!='>')ch = get();\n\t\tid++;\n\t\treturn r;\n\t}\n\t\n\tint val(){\n\t\tint x = 0;\n\t\tchar ch = get();\n\t\twhile(Character.isDigit(ch)){\n\t\t\tx = x*10 + ch-'0';\n\t\t\tch = get();\n\t\t}\n\t\treturn x;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\ts = (sc.next()+\"$\").toCharArray();\n\t\t\tid = 1;\n\t\t\tE e = tag();\n\t\t\twhile(n--!=0)if(!e.f(sc.nextInt(), sc.nextInt()))System.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\tpublic static ArrayList<ArrayList<Integer>> g;\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\twhile(true){\n\t\t\tint n = readInt();\n\t\t\tif(n == 0) return;\n\t\t\t\n\t\t\t\n\t\t\tPanel p = new Panel(readLine());\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] in = readIntMap();\n\t\t\t\tint x = in[0], y = in[1];\n\t\t\t\tif(p.in(x, y)){\n\t\t\t\t\tp.check(x,y);\n\t\t\t\t}else{\n\t\t\t\t\tp(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Panel extends MyUtil{\n\tArrayList<Panel> children = new ArrayList<Panel>();\n\tString name;\n\tint left, right, top, bottom;\n\tPanel(String str){\n\t\tPattern p = Pattern.compile(\"<(.*?)>([0-9]+),([0-9]+),([0-9]+),([0-9]+)(.*)</\\\\1>\");\n\t\tMatcher m = p.matcher(str);\n\t\tm.find();\n\t\tp(m.group());\n\t\t\n\t\tname = m.group(1);\n\t\tleft = parseInt(m.group(2));\n\t\ttop = parseInt(m.group(3));\n\t\tright = parseInt(m.group(4));\n\t\tbottom = parseInt(m.group(5));\n\t\t\n\t\tString cstr = m.group(6);\n\t\tPattern cp = Pattern.compile(\"<(.*?)>.*</\\\\1>\");\n\t\tMatcher cm = p.matcher(cstr);\n\t\twhile(cm.find()){\n\t\t\tchildren.add(new Panel(cm.group()));\n\t\t}\n\t}\n\t\n\tpublic boolean in(int x, int y){\n\t\treturn left <= x && x <= right && top <= y && y <= bottom;\n\t}\n\t\n\tpublic void check(int x, int y){\n\t\tboolean flag = false;\n\t\tfor(Panel child : children){\n\t\t\tif(child.in(x, y)){\n\t\t\t\tchild.check(x, y);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) p(name + \" \" + children.size());\n\t}\n}\n\n\n/**\n * 整数を数え上げたりするクラス\n * new Prime(int n) でnまでエラトステネスの篩を実行。\n * @author yoshikyoto\n * @param a[i] iが素数の時true\n * @param count[i] i以下の素数の数\n */\nclass Prime{\n\tboolean[] a;\n\tint[] count;\n\tPrime(int n){\n\t\ta = new boolean[n+1];\n\t\ta[0] = false; a[1] = false;\n\t\tfor(int i = 2; i <= n; i++) a[i] = true;\n\t\t// ふるい\n\t\tfor(int i = 2; i < (n - 3) / 2; i++)\n\t\t\tif(a[i]) for(int j = 2; j * i <= n; j++)\n\t\t\t\t\ta[j * i] = false;\n\t\t\n\t\t// 数え上げ\n\t\tcount = new int[n+1];\n\t\tcount[0] = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint gain = 0;\n\t\t\tif(a[i]) gain = 1;\n\t\t\tcount[i] = count[i-1] + gain;\n\t\t}\n\t}\n}\n\nclass AI extends ArrayList<Integer>{}\nclass SI extends Stack<Integer>{}\n\nclass HMI<E> extends HashMap<E, Integer>{\n\tArrayList<E> keyArray = new ArrayList<E>();\n\tpublic void add(E key){add(key, 1);}\n\tpublic void add(E key, Integer value){\n\t\tif(containsKey(key)){value += get(key);\n\t\t}else{keyArray.add(key);}\n\t\tput(key, value);\n\t}\n}\n\nclass HMSI extends HMI<String>{}\nclass Q<E> extends ArrayDeque<E>{\n\tpublic void push(E item){add(item);}\n\tpublic E pop(){return poll();}\n}\nclass QS extends Q<String>{}\nclass QI extends Q<Integer>{}\n\nclass MyUtil extends MyIO{\n\tpublic static long start_time = 0;\n\tpublic static void start(){start_time = System.currentTimeMillis();}\n\tpublic static void end(){\n\t\tif(start_time == 0) return;\n\t\tlong time = System.currentTimeMillis() - start_time;\n\t\tif(DEBUG) p(time + \"ms\");\n\t}\n\tpublic static int digit(int n){return String.valueOf(n).length();}\n\tpublic static String reverse(String s){\n\t\tStringBuffer sb = new StringBuffer(s);\n\t\treturn sb.reverse().toString();\n\t}\n\tpublic static void sort(int[] a){Arrays.sort(a);}\n\tpublic static void dsort(int[] a){\n\t\tArrays.sort(a);\n\t\tint l = a.length;\n\t\tfor(int i = 0; i < l/2; i++){\n\t\t\tint tmp = a[i]; a[i] = a[l-1-i]; a[l-1-i] = tmp;\n\t\t}\n\t}\n\tpublic static void sleep(int t){try{Thread.sleep(t);}catch(Exception e){}}\n\tpublic static int sum(int[] a){int s = 0; for(int i = 0; i < a.length; i++)s+=a[i]; return s;}\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n}\n\nclass MyIO extends MyMath{\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static char scNextChar(){return sc.next().charAt(0);}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static boolean DEBUG = false;\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static void p(Object o){System.out.println(o.toString());}\n\tpublic static void pr(Object o){System.out.print(o.toString());}\n\tpublic static void d(Object o){if(DEBUG)System.out.println(o.toString());}\n\tpublic static void dr(Object o){if(DEBUG)System.out.print(o.toString());}\n\tpublic static void da(Object[] o){if(DEBUG)System.out.println(Arrays.toString(o));}\n\tpublic static void da(int[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(double[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(boolean[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){return Integer.parseInt(o.toString());}\n}\n\nclass MyMath{\n\t/**\n\t * 弧度法の角度を入力してsinの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double sin(int r){return Math.sin(Math.toRadians(r));}\n\n\t/**\n\t * 弧度法の角度を入力してcosの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double cos(int r){return Math.cos(Math.toRadians(r));}\n\tpublic static int max(int a, int b){return Math.max(a, b);}\n\tpublic static int min(int a, int b){return Math.min(a, b);}\n\tpublic static boolean isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    // 並行な場合\n\t    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n\t    if(m == 0) return false;\n\t    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n\t    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n\t    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n\t    return (0 < r && r <= 1 && 0 < s && s <= 1);\n\t}\n\tpublic static boolean isParallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    if((x2-x1)*(y4-y3) == (y2-y1)*(x4-x3)) return true;\n\t    else return false;\n\t}\n\tpublic static double sq(double d){return d*d;}\n\tpublic static int sq(int i){return i*i;}\n\tpublic static int sqdist(int x1, int y1, int x2, int y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double sqdist(double x1, double y1, double x2, double y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double dist(int x1, int y1, int x2, int y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tpublic static double dist(double x1, double y1, double x2, double y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport java.util.ArrayList;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tPanel parent, child;\n\t\t\tparent = parse(br.readLine());\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint p[] = new int[2];\n\t\t\t\tp[0] = Integer.parseInt(line.split(\" \")[0]);\n\t\t\t\tp[1] = Integer.parseInt(line.split(\" \")[1]);\n\t\t\t\tchild = parent.touched(main.new Point(p[0], p[1]));\n\t\t\t\tif (child == null) {\n\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out\n\t\t\t\t\t\t\t.println(child.name + \" \" + child.children.size());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// タグ文字列のパース\n\tpublic static Panel parse(String struct) {\n\n\t\tStack<Panel> stack = new Stack<Panel>();\n\t\tPanel result = null;\n\n\t\tchar c;\n\t\tStringBuilder name, points;\n\t\tname = points = null;\n\t\tfor (int i = 0; i < struct.length(); i++) {\n\t\t\tc = struct.charAt(i);\n\n\t\t\t// 名前の読み取り\n\t\t\tif (c == '<') {\n\t\t\t\ti++;\n\t\t\t\tc = struct.charAt(i);\n\t\t\t\tif ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\t\t\tname = new StringBuilder();\n\t\t\t\t\twhile (c != '>') {\n\t\t\t\t\t\tname.append(c);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tc = struct.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t} else if (c == '/') {\n\t\t\t\t\tstack.pop();\n\t\t\t\t\twhile (c != '>') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tc = struct.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 座標の読み取り\n\t\t\tif ((c >= '0' && c <= '9') || c == ',') {\n\t\t\t\tpoints = new StringBuilder();\n\t\t\t\tpoints.append(c);\n\t\t\t\twhile (struct.charAt(i + 1) != '<') {\n\t\t\t\t\ti++;\n\t\t\t\t\tpoints.append(struct.charAt(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 新しいパネル\n\t\t\tif (name != null && points != null) {\n\n\t\t\t\tint[] p = new int[4];\n\t\t\t\tp[0] = Integer.parseInt(points.toString().split(\",\")[0]);\n\t\t\t\tp[1] = Integer.parseInt(points.toString().split(\",\")[1]);\n\t\t\t\tp[2] = Integer.parseInt(points.toString().split(\",\")[2]);\n\t\t\t\tp[3] = Integer.parseInt(points.toString().split(\",\")[3]);\n\n\t\t\t\tPoint top, buttom;\n\t\t\t\tPanel panel;\n\n\t\t\t\ttop = main.new Point(p[0], p[1]);\n\t\t\t\tbuttom = main.new Point(p[2], p[3]);\n\t\t\t\tpanel = main.new Panel(name.toString(), top, buttom);\n\n\t\t\t\tif (stack.size() > 0) {\n\t\t\t\t\tstack.peek().children.add(panel);\n\t\t\t\t\tstack.push(panel);\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(panel);\n\t\t\t\t\tresult = stack.firstElement();\n\n\t\t\t\t}\n\t\t\t\tname = points = null;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t// ポイント\n\tpublic class Point {\n\t\tint x, y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\t// パネル\n\tpublic class Panel {\n\t\tString name;\n\t\tPoint top, buttom;\n\t\tArrayList<Panel> children;\n\n\t\tpublic Panel(String name, Point top, Point buttom) {\n\t\t\tthis.name = name;\n\t\t\tthis.top = top;\n\t\t\tthis.buttom = buttom;\n\t\t\tchildren = new ArrayList<Panel>();\n\t\t}\n\n\t\tpublic ArrayList<Panel> add(Panel panel) {\n\t\t\tif (children.add(panel))\n\t\t\t\treturn children;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\n\t\tprivate boolean isIntercect(Point touch) {\n\t\t\tif (touch.x >= top.x && touch.y >= top.y)\n\t\t\t\tif (touch.x <= buttom.x && touch.y <= buttom.y)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic Panel touchedChild(Point touch) {\n\t\t\tfor (Panel child : children) {\n\t\t\t\tif (child.isIntercect(touch))\n\t\t\t\t\treturn child;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Panel touched(Point touch) {\n\t\t\tPanel result = null;\n\t\t\tif (this.isIntercect(touch)) {\n\t\t\t\tPanel parent, child;\n\t\t\t\tparent = this;\n\t\t\t\tchild = parent.touchedChild(touch);\n\t\t\t\twhile (!child.equals(parent)) {\n\t\t\t\t\tparent = child;\n\t\t\t\t\tchild = parent.touchedChild(touch);\n\t\t\t\t}\n\t\t\t\tresult = child;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport java.util.ArrayList;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tPanel parent, child;\n\t\t\tparent = parse(br.readLine());\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint p[] = new int[2];\n\t\t\t\tp[0] = Integer.parseInt(line.split(\" \")[0]);\n\t\t\t\tp[1] = Integer.parseInt(line.split(\" \")[1]);\n\t\t\t\tchild = parent.touched(main.new Point(p[0], p[1]));\n\t\t\t\tif (child == null) {\n\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out\n\t\t\t\t\t\t\t.println(child.name + \" \" + child.children.size());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// タグ文字列のパース\n\tpublic static Panel parse(String struct) {\n\n\t\tStack<Panel> stack = new Stack<P1031.Panel>();\n\t\tPanel result = null;\n\n\t\tchar c;\n\t\tStringBuilder name, points;\n\t\tname = points = null;\n\t\tfor (int i = 0; i < struct.length(); i++) {\n\t\t\tc = struct.charAt(i);\n\n\t\t\t// 名前の読み取り\n\t\t\tif (c == '<') {\n\t\t\t\ti++;\n\t\t\t\tc = struct.charAt(i);\n\t\t\t\tif ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\t\t\tname = new StringBuilder();\n\t\t\t\t\twhile (c != '>') {\n\t\t\t\t\t\tname.append(c);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tc = struct.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t} else if (c == '/') {\n\t\t\t\t\tstack.pop();\n\t\t\t\t\twhile (c != '>') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tc = struct.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 座標の読み取り\n\t\t\tif ((c >= '0' && c <= '9') || c == ',') {\n\t\t\t\tpoints = new StringBuilder();\n\t\t\t\tpoints.append(c);\n\t\t\t\twhile (struct.charAt(i + 1) != '<') {\n\t\t\t\t\ti++;\n\t\t\t\t\tpoints.append(struct.charAt(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 新しいパネル\n\t\t\tif (name != null && points != null) {\n\n\t\t\t\tint[] p = new int[4];\n\t\t\t\tp[0] = Integer.parseInt(points.toString().split(\",\")[0]);\n\t\t\t\tp[1] = Integer.parseInt(points.toString().split(\",\")[1]);\n\t\t\t\tp[2] = Integer.parseInt(points.toString().split(\",\")[2]);\n\t\t\t\tp[3] = Integer.parseInt(points.toString().split(\",\")[3]);\n\n\t\t\t\tPoint top, buttom;\n\t\t\t\tPanel panel;\n\n\t\t\t\ttop = main.new Point(p[0], p[1]);\n\t\t\t\tbuttom = main.new Point(p[2], p[3]);\n\t\t\t\tpanel = main.new Panel(name.toString(), top, buttom);\n\n\t\t\t\tif (stack.size() > 0) {\n\t\t\t\t\tstack.peek().children.add(panel);\n\t\t\t\t\tstack.push(panel);\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(main.new Panel(name.toString(), top, buttom));\n\t\t\t\t\tresult = stack.firstElement();\n\n\t\t\t\t}\n\t\t\t\tname = points = null;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t// ポイント\n\tpublic class Point {\n\t\tint x, y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\t// パネル\n\tpublic class Panel {\n\t\tString name;\n\t\tPoint top, buttom;\n\t\tArrayList<Panel> children;\n\n\t\tpublic Panel(String name, Point top, Point buttom) {\n\t\t\tthis.name = name;\n\t\t\tthis.top = top;\n\t\t\tthis.buttom = buttom;\n\t\t\tchildren = new ArrayList<Panel>();\n\t\t}\n\n\t\tpublic ArrayList<Panel> add(Panel panel) {\n\t\t\tif (children.add(panel))\n\t\t\t\treturn children;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\n\t\tprivate boolean isIntercect(Point touch) {\n\t\t\tif (touch.x >= top.x && touch.y >= top.y)\n\t\t\t\tif (touch.x <= buttom.x && touch.y <= buttom.y)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic Panel touchedChild(Point touch) {\n\t\t\tfor (Panel child : children) {\n\t\t\t\tif (child.isIntercect(touch))\n\t\t\t\t\treturn child;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Panel touched(Point touch) {\n\t\t\tPanel result = null;\n\t\t\tif (this.isIntercect(touch)) {\n\t\t\t\tPanel parent, child;\n\t\t\t\tparent = this;\n\t\t\t\tchild = parent.touchedChild(touch);\n\t\t\t\twhile (!child.equals(parent)) {\n\t\t\t\t\tparent = child;\n\t\t\t\t\tchild = parent.touchedChild(touch);\n\t\t\t\t}\n\t\t\t\tresult = child;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twhile(true){\n\t\t\t\t/* input */\n\t\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\t\tif(n==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tString tag = br.readLine();\n\t\t\t\tArrayList<Panel> ps = parseTags(tag);\n\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tString[] str = br.readLine().split(\" \");\n\t\t\t\t\tint x = Integer.parseInt(str[0]), y = Integer.parseInt(str[1]);\n\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tPanel current = ps.get(0);\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(!current.point(x, y)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tboolean c = false;\n\t\t\t\t\t\tfor(Panel child : current.children){\n\t\t\t\t\t\t\tif(child.point(x, y)){\n\t\t\t\t\t\t\t\tc = true;\n\t\t\t\t\t\t\t\tcurrent = child;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!c) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(found){\n\t\t\t\t\t\tSystem.out.println(current.name + \" \" + current.children.size());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t}\n\n\tstatic class Panel{\n\t\tpublic String name;\n\t\tpublic int x1,x2,y1,y2;\n\t\tpublic ArrayList<Panel> children;\n\n\t\tpublic Panel(String name, String coordinates){\n\t\t\tthis.name = name;\n\t\t\tString[] c = coordinates.split(\",\");\n\t\t\tthis.x1 = Integer.parseInt(c[0]);\n\t\t\tthis.y1 = Integer.parseInt(c[1]);\n\t\t\tthis.x2 = Integer.parseInt(c[2]);\n\t\t\tthis.y2 = Integer.parseInt(c[3]);\n\t\t\tthis.children = new ArrayList<Panel>();\n\t\t}\n\n\t\tboolean point(int x, int y){\n\t\t\tif(x1<=x&&x<=x2&&y1<=y&&y<=y2){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tpublic void output(){\n\t\t\tSystem.out.print(this.name + \":\");\n\t\t\tSystem.out.println(this.x1 + \", \" + this.x2 + \", \" + this.y1 + \", \" + this.y2);\n\t\t\tSystem.out.print(\"CHILDREN:\");\n\t\t\tfor(Panel p : this.children){\n\t\t\t\tSystem.out.print(\" \" + p.name);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tpublic boolean parentOf(Panel p){\n\t\t\tif(this.x1<p.x1&&this.x2>p.x2&&this.y1<p.y1&&this.y2>p.y2) return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static ArrayList<Panel> parseTags(String tags){\n\t\tStack<Panel> stack = new Stack<Panel>();\n\t\tArrayList<Panel> p = new ArrayList<Panel>();\n\t\tString name, coordinates;\n\t\twhile(true){\n\t\t\tint s = 0, t = 0, nexts = 0;\n\t\t\twhile(tags.charAt(s)!='<'&&s<=tags.length()){\n\t\t\t\ts++;\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tif(s>=tags.length()) break;\n\t\t\twhile(tags.charAt(t)!='>'&&t<tags.length()){\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tname = tags.substring(s+1,t);\n\n\t\t\tnexts = t;\n\t\t\tif(tags.substring(t).indexOf(\"<\")>-1){\n\t\t\t\twhile(tags.charAt(nexts)!='<'){\n\t\t\t\t\tnexts++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(tags.charAt(s+1)!='/'){\n\t\t\t\tcoordinates = tags.substring(t+1,nexts);\n\t\t\t\tPanel pn = new Panel(name,coordinates);\n\t\t\t\tif(stack.size()>0) stack.peek().children.add(pn);\n\t\t\t\tstack.push(pn);\n\t\t\t\tp.add(pn);\n\t\t\t} else {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\ttags = tags.substring(nexts);\n\t\t}\n\t\treturn p;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\tpublic static ArrayList<ArrayList<Integer>> g;\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\twhile(true){\n\t\t\tint n = readInt();\n\t\t\tif(n == 0) return;\n\t\t\t\n\t\t\t\n\t\t\tPanel p = new Panel(readLine());\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] in = readIntMap();\n\t\t\t\tint x = in[0], y = in[1];\n\t\t\t\tif(p.in(x, y)){\n\t\t\t\t\tp.check(x,y);\n\t\t\t\t}else{\n\t\t\t\t\tp(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Panel extends MyUtil{\n\tArrayList<Panel> children = new ArrayList<Panel>();\n\tString name;\n\tint left, right, top, bottom;\n\tPanel(String str){\n\t\tPattern p = Pattern.compile(\"^<(.*?)>([0-9]+),([0-9]+),([0-9]+),([0-9]+)(.*)</\\\\1>$\");\n\t\tMatcher m = p.matcher(str);\n\t\tm.find();\n\t\tp(m.group());\n\t\t\n\t\tname = m.group(1);\n\t\tleft = parseInt(m.group(2));\n\t\ttop = parseInt(m.group(3));\n\t\tright = parseInt(m.group(4));\n\t\tbottom = parseInt(m.group(5));\n\t\t\n\t\tString cstr = m.group(6);\n\t\tPattern cp = Pattern.compile(\"<(.*?)>.*</\\\\1>\");\n\t\tMatcher cm = p.matcher(cstr);\n\t\twhile(cm.find()){\n\t\t\tchildren.add(new Panel(cm.group()));\n\t\t}\n\t}\n\t\n\tpublic boolean in(int x, int y){\n\t\treturn left <= x && x <= right && top <= y && y <= bottom;\n\t}\n\t\n\tpublic void check(int x, int y){\n\t\tboolean flag = false;\n\t\tfor(Panel child : children){\n\t\t\tif(child.in(x, y)){\n\t\t\t\tchild.check(x, y);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) p(name + \" \" + children.size());\n\t}\n}\n\n\n/**\n * 整数を数え上げたりするクラス\n * new Prime(int n) でnまでエラトステネスの篩を実行。\n * @author yoshikyoto\n * @param a[i] iが素数の時true\n * @param count[i] i以下の素数の数\n */\nclass Prime{\n\tboolean[] a;\n\tint[] count;\n\tPrime(int n){\n\t\ta = new boolean[n+1];\n\t\ta[0] = false; a[1] = false;\n\t\tfor(int i = 2; i <= n; i++) a[i] = true;\n\t\t// ふるい\n\t\tfor(int i = 2; i < (n - 3) / 2; i++)\n\t\t\tif(a[i]) for(int j = 2; j * i <= n; j++)\n\t\t\t\t\ta[j * i] = false;\n\t\t\n\t\t// 数え上げ\n\t\tcount = new int[n+1];\n\t\tcount[0] = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint gain = 0;\n\t\t\tif(a[i]) gain = 1;\n\t\t\tcount[i] = count[i-1] + gain;\n\t\t}\n\t}\n}\n\nclass AI extends ArrayList<Integer>{}\nclass SI extends Stack<Integer>{}\n\nclass HMI<E> extends HashMap<E, Integer>{\n\tArrayList<E> keyArray = new ArrayList<E>();\n\tpublic void add(E key){add(key, 1);}\n\tpublic void add(E key, Integer value){\n\t\tif(containsKey(key)){value += get(key);\n\t\t}else{keyArray.add(key);}\n\t\tput(key, value);\n\t}\n}\n\nclass HMSI extends HMI<String>{}\nclass Q<E> extends ArrayDeque<E>{\n\tpublic void push(E item){add(item);}\n\tpublic E pop(){return poll();}\n}\nclass QS extends Q<String>{}\nclass QI extends Q<Integer>{}\n\nclass MyUtil extends MyIO{\n\tpublic static long start_time = 0;\n\tpublic static void start(){start_time = System.currentTimeMillis();}\n\tpublic static void end(){\n\t\tif(start_time == 0) return;\n\t\tlong time = System.currentTimeMillis() - start_time;\n\t\tif(DEBUG) p(time + \"ms\");\n\t}\n\tpublic static int digit(int n){return String.valueOf(n).length();}\n\tpublic static String reverse(String s){\n\t\tStringBuffer sb = new StringBuffer(s);\n\t\treturn sb.reverse().toString();\n\t}\n\tpublic static void sort(int[] a){Arrays.sort(a);}\n\tpublic static void dsort(int[] a){\n\t\tArrays.sort(a);\n\t\tint l = a.length;\n\t\tfor(int i = 0; i < l/2; i++){\n\t\t\tint tmp = a[i]; a[i] = a[l-1-i]; a[l-1-i] = tmp;\n\t\t}\n\t}\n\tpublic static void sleep(int t){try{Thread.sleep(t);}catch(Exception e){}}\n\tpublic static int sum(int[] a){int s = 0; for(int i = 0; i < a.length; i++)s+=a[i]; return s;}\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n}\n\nclass MyIO extends MyMath{\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static char scNextChar(){return sc.next().charAt(0);}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static boolean DEBUG = false;\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static void p(Object o){System.out.println(o.toString());}\n\tpublic static void pr(Object o){System.out.print(o.toString());}\n\tpublic static void d(Object o){if(DEBUG)System.out.println(o.toString());}\n\tpublic static void dr(Object o){if(DEBUG)System.out.print(o.toString());}\n\tpublic static void da(Object[] o){if(DEBUG)System.out.println(Arrays.toString(o));}\n\tpublic static void da(int[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(double[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(boolean[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){return Integer.parseInt(o.toString());}\n}\n\nclass MyMath{\n\t/**\n\t * 弧度法の角度を入力してsinの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double sin(int r){return Math.sin(Math.toRadians(r));}\n\n\t/**\n\t * 弧度法の角度を入力してcosの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double cos(int r){return Math.cos(Math.toRadians(r));}\n\tpublic static int max(int a, int b){return Math.max(a, b);}\n\tpublic static int min(int a, int b){return Math.min(a, b);}\n\tpublic static boolean isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    // 並行な場合\n\t    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n\t    if(m == 0) return false;\n\t    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n\t    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n\t    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n\t    return (0 < r && r <= 1 && 0 < s && s <= 1);\n\t}\n\tpublic static boolean isParallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    if((x2-x1)*(y4-y3) == (y2-y1)*(x4-x3)) return true;\n\t    else return false;\n\t}\n\tpublic static double sq(double d){return d*d;}\n\tpublic static int sq(int i){return i*i;}\n\tpublic static int sqdist(int x1, int y1, int x2, int y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double sqdist(double x1, double y1, double x2, double y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double dist(int x1, int y1, int x2, int y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tpublic static double dist(double x1, double y1, double x2, double y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport java.util.ArrayList;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic Main main = new P1031();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tPanel parent, child;\n\t\t\tparent = parse(br.readLine());\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint p[] = new int[2];\n\t\t\t\tp[0] = Integer.parseInt(line.split(\" \")[0]);\n\t\t\t\tp[1] = Integer.parseInt(line.split(\" \")[1]);\n\t\t\t\tchild = parent.touched(main.new Point(p[0], p[1]));\n\t\t\t\tif (child == null) {\n\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out\n\t\t\t\t\t\t\t.println(child.name + \" \" + child.children.size());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// タグ文字列のパース\n\tpublic static Panel parse(String struct) {\n\n\t\tStack<Panel> stack = new Stack<P1031.Panel>();\n\t\tPanel result = null;\n\n\t\tchar c;\n\t\tStringBuilder name, points;\n\t\tname = points = null;\n\t\tfor (int i = 0; i < struct.length(); i++) {\n\t\t\tc = struct.charAt(i);\n\n\t\t\t// 名前の読み取り\n\t\t\tif (c == '<') {\n\t\t\t\ti++;\n\t\t\t\tc = struct.charAt(i);\n\t\t\t\tif ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\t\t\tname = new StringBuilder();\n\t\t\t\t\twhile (c != '>') {\n\t\t\t\t\t\tname.append(c);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tc = struct.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t} else if (c == '/') {\n\t\t\t\t\tstack.pop();\n\t\t\t\t\twhile (c != '>') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tc = struct.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 座標の読み取り\n\t\t\tif ((c >= '0' && c <= '9') || c == ',') {\n\t\t\t\tpoints = new StringBuilder();\n\t\t\t\tpoints.append(c);\n\t\t\t\twhile (struct.charAt(i + 1) != '<') {\n\t\t\t\t\ti++;\n\t\t\t\t\tpoints.append(struct.charAt(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 新しいパネル\n\t\t\tif (name != null && points != null) {\n\n\t\t\t\tint[] p = new int[4];\n\t\t\t\tp[0] = Integer.parseInt(points.toString().split(\",\")[0]);\n\t\t\t\tp[1] = Integer.parseInt(points.toString().split(\",\")[1]);\n\t\t\t\tp[2] = Integer.parseInt(points.toString().split(\",\")[2]);\n\t\t\t\tp[3] = Integer.parseInt(points.toString().split(\",\")[3]);\n\n\t\t\t\tPoint top, buttom;\n\t\t\t\tPanel panel;\n\n\t\t\t\ttop = main.new Point(p[0], p[1]);\n\t\t\t\tbuttom = main.new Point(p[2], p[3]);\n\t\t\t\tpanel = main.new Panel(name.toString(), top, buttom);\n\n\t\t\t\tif (stack.size() > 0) {\n\t\t\t\t\tstack.peek().children.add(panel);\n\t\t\t\t\tstack.push(panel);\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(main.new Panel(name.toString(), top, buttom));\n\t\t\t\t\tresult = stack.firstElement();\n\n\t\t\t\t}\n\t\t\t\tname = points = null;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t// ポイント\n\tpublic class Point {\n\t\tint x, y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\t// パネル\n\tpublic class Panel {\n\t\tString name;\n\t\tPoint top, buttom;\n\t\tArrayList<Panel> children;\n\n\t\tpublic Panel(String name, Point top, Point buttom) {\n\t\t\tthis.name = name;\n\t\t\tthis.top = top;\n\t\t\tthis.buttom = buttom;\n\t\t\tchildren = new ArrayList<Panel>();\n\t\t}\n\n\t\tpublic ArrayList<Panel> add(Panel panel) {\n\t\t\tif (children.add(panel))\n\t\t\t\treturn children;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\n\t\tprivate boolean isIntercect(Point touch) {\n\t\t\tif (touch.x >= top.x && touch.y >= top.y)\n\t\t\t\tif (touch.x <= buttom.x && touch.y <= buttom.y)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic Panel touchedChild(Point touch) {\n\t\t\tfor (Panel child : children) {\n\t\t\t\tif (child.isIntercect(touch))\n\t\t\t\t\treturn child;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Panel touched(Point touch) {\n\t\t\tPanel result = null;\n\t\t\tif (this.isIntercect(touch)) {\n\t\t\t\tPanel parent, child;\n\t\t\t\tparent = this;\n\t\t\t\tchild = parent.touchedChild(touch);\n\t\t\t\twhile (!child.equals(parent)) {\n\t\t\t\t\tparent = child;\n\t\t\t\t\tchild = parent.touchedChild(touch);\n\t\t\t\t}\n\t\t\t\tresult = child;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Rectangle;\n\npublic class Main{\n\tprivate static char[] s;\n\tprivate static int pos;\n\tprivate static ArrayList<GUI> al;\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tal = new ArrayList<GUI>();\n\t\t\ts = sc.next().toCharArray();\n\t\t\tpos = 0;\n\t\t\tparse();\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\tint minIdx = -1;\n\n\t\t\t\tfor(int j=0;j<al.size();j++){\n\t\t\t\t\tif(al.get(j).r.contains(x,y) && al.get(j).child < min){\n\t\t\t\t\t\tmin = al.get(j).child;\n\t\t\t\t\t\tminIdx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(minIdx==-1 ? \"OUT OF MAIN PANEL 1\" : (al.get(minIdx).name + \" \" + al.get(minIdx).child));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void parse(){\n\t\tString name = start();\n\t\tint[] v = value();\n\t\tint child = 0;\n\t\twhile(s[pos] == '<' && s[pos+1] != '/'){\n\t\t\tparse();\n\t\t\tchild++;\n\t\t}\n\t\tend();\n\n\t\tGUI gui = new GUI(name,v[0],v[1],v[2],v[3],child);\n\t\tal.add(gui);\n\t}\n\n\tprivate static String start(){\n\t\tString res = \"\";\n\t\tpos++;\n\t\twhile(s[pos] != '>'){\n\t\t\tres += s[pos++];\n\t\t}\n\t\tpos++;\n\t\treturn res;\n\t}\n\n\tprivate static int[] value(){\n\t\tString tmp = \"\";\n\t\twhile(s[pos] != '<'){\n\t\t\ttmp += s[pos++];\n\t\t}\n\t\tString[] tt = tmp.split(\",\");\n\t\tint[] res = new int[4];\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tres[i] = Integer.parseInt(tt[i]);\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate static void end(){\n\t\twhile(s[pos++] != '>');\n\t}\n}\n\nclass GUI{\n\tString name;\n\tRectangle r;\n\tint child;\n\n\tGUI(String name,int x1,int y1,int x2,int y2,int child){\n\t\tthis.name = name;\n\t\tthis.r = new Rectangle(x1,y1,x2-x1,y2-y1);\n\t\tthis.r.setBounds(x1-1,y1-1,x2-x1+2,y2-y1+2);\n\t\tthis.child = child;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid debug(Object...os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)return;\n\t\t\tp=0;\n\t\t\tPanel root = new Panel(sc.next());\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!root.go(sc.nextInt(), sc.nextInt())){\n\t\t\t\t\tSystem.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tclass Panel{\n\t\tString name;\n\t\tint x1,y1,x2,y2;\n\t\tArrayList<Panel> cs = new ArrayList<Panel>();\n\t\tPanel(String t){\n\t\t\tString s = t.substring(p);\n\t\t\tint np = s.indexOf(\">\");\n\t\t\tname = s.substring(1, np);\n//\t\t\tp = np;\n//\t\t\tp++;\n\t\t\tint q = s.indexOf(\"<\", np);\n\t\t\tString[] ns = s.substring(np+1, q).split(\",\");\n\t\t\tx1 = Integer.valueOf(ns[0]);\n\t\t\ty1 = Integer.valueOf(ns[1]);\n\t\t\tx2 = Integer.valueOf(ns[2]);\n\t\t\ty2 = Integer.valueOf(ns[3]);\n\t\t\tp += q;\n\t\t\twhile(!t.substring(p).startsWith(\"</\")){\n\t\t\t\tcs.add(new Panel(t));\n\t\t\t}\n\t\t\tp = t.indexOf(\">\",p) + 1;\n\t\t}\n\t\tboolean go(int x,int y){\n\t\t\tif(x1<=x&&x<=x2&&y1<=y&&y<=y2){\n\t\t\t\tboolean me = true;\n\t\t\t\tfor(Panel p:cs){\n\t\t\t\t\tif(p.go(x, y))me=false;\n\t\t\t\t}\n\t\t\t\tif(me){\n\t\t\t\t\tSystem.out.println(name + \" \"+cs.size());\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Simple GUI Application\npublic class Main{\n\n\tclass E{\n\t\tString name;\n\t\tint x1, y1, x2, y2, num;\n\t\tList<E> adj;\n\t\tpublic E(String name, int x1, int y1, int x2, int y2) {\n\t\t\tthis.name = name;\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tadj = new ArrayList<E>();\n\t\t\tnum = -1;\n\t\t}\n\t\tboolean f(int x, int y){\n\t\t\tboolean hit =  x1<=x&&x<=x2&&y1<=y&&y<=y2;\n\t\t\tif(!hit)return hit;\n\t\t\tboolean here = true;\n\t\t\tfor(E e:adj)if(e.f(x, y))here = false;\n\t\t\tif(!here)return true;\n\t\t\tSystem.out.println(name+\" \"+adj.size());\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tchar[] s;\n\tint id;\n\t\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\t\n\tE tag(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tchar ch = get();\n\t\twhile(ch!='>'){\n\t\t\tsb.append(ch);\n\t\t\tch = get();\n\t\t}\n\t\tE r = new E(sb.toString(), val(), val(), val(), val());\n\t\tch = get();\n\t\twhile(true){\n\t\t\tif(ch=='/')break;\n\t\t\tid--;\n\t\t\tr.adj.add(tag());\n\t\t\tch = get();\n\t\t}\n\t\twhile(ch!='>')ch = get();\n\t\tid++;\n\t\treturn r;\n\t}\n\t\n\tint val(){\n\t\tint x = 0;\n\t\tchar ch = get();\n\t\twhile(Character.isDigit(ch)){\n\t\t\tx = x*10 + ch-'0';\n\t\t\tch = get();\n\t\t}\n\t\treturn x;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\ts = (sc.next()+\"$\").toCharArray();\n\t\t\tid = 1;\n\t\t\tE e = tag();\n\t\t\twhile(n--!=0)if(!e.f(sc.nextInt(), sc.nextInt()))System.out.println(\"OUT OF MAIN PANEL 1\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=int.Parse(Console.ReadLine());\n\t\t\tif(d==0)break;\n\t\t\tSol mySol=new Sol(d);\n\t\t\tmySol.WriteAns();\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tint n;\n\tPannelTag TOP;\n\tpublic void WriteAns(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//var s=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tvar ss=Console.ReadLine().Split(' ');\n\t\t\tint[] s=new int[2];\n\t\t\ts[0]=int.Parse(ss[0]);\n\t\t\ts[1]=int.Parse(ss[1]);\n\t\t\t\n\t\t\tSearchAndWrite(TOP,s[0],s[1]);\n\t\t}\n\t}\n\t\n\tvoid SearchAndWrite(PannelTag P,int x,int y){\n\t\tbool chk=true;\n\t\tfor(int i=0;i<P.Children.Count;i++){\n\t\t\tif(x>=P.Children[i].Xmin && x<=P.Children[i].Xmax && y>=P.Children[i].Ymin && y<=P.Children[i].Ymax){\n\t\t\t\tchk=false;\n\t\t\t\tSearchAndWrite(P.Children[i],x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(chk){\n\t\t\tConsole.Write(P.Body);\n\t\t\tConsole.WriteLine(\" {0}\",P.Children.Count);\n\t\t}\n\t}\n\t\n\tpublic Sol(int n_){\n\t\tn=n_;\n\t\tString tag_main=Console.ReadLine();\n\t\t\n\t\tPannelTag Content=new PannelTag(tag_main);\n\t\t\n\t\t// 外枠を追加する（万一、mainの中に\"OUT OF MAIN PANEL\"があった時のために、個別に生成）\n\t\tTOP=new PannelTag(\"<OUT OF MAIN PANEL>0,0,10001,10001</OUT OF MAIN PANEL>\");\n\t\tContent.Parent=TOP;\n\t\tTOP.Children.Add(Content);\n\t}\n}\n\n\nclass PannelTag{\n\tPannelTag parent;\n\tString body;\n\tString expr;\n\tint xmin;\n\tint xmax;\n\tint ymax;\n\tint ymin;\n\t\n\tpublic PannelTag Parent{\n\t\tget{return parent;}\n\t\tset{this.parent=value;}\n\t}\n\tpublic List<PannelTag> Children;\n\tpublic int Xmin{get{return xmin;}}\n\tpublic int Xmax{get{return xmax;}}\n\tpublic int Ymin{get{return ymin;}}\n\tpublic int Ymax{get{return ymax;}}\n\tpublic String Body{get{return body;}}\n\n\n\t//constructor\n\t//exprを与えて再帰的にparseしながらツリーを生成。\n\tpublic PannelTag(String expr_){\n\t\texpr=expr_;\n\t\t\n\t\tint cursol=0;\n\t\tint cursol_bak=0;\n\t\t\n\t\twhile(expr[cursol]!='>')cursol++;\n\t\tbody=expr.Substring(1,cursol-1);\n//Console.WriteLine(\"dbg body={0}\",body);\n\t\tcursol++;\n\t\tcursol_bak=cursol;//＠サイズの先頭文字\n\t\twhile(expr[cursol]!='<')cursol++;\n\t\tvar Csv=expr.Substring(cursol_bak,cursol-cursol_bak).Split(',');\n//Console.WriteLine(\"dbg CSV={0}\",expr.Substring(cursol_bak,cursol-cursol_bak));\n\t\txmin=int.Parse(Csv[0]);\n\t\tymin=int.Parse(Csv[1]);\n\t\txmax=int.Parse(Csv[2]);\n\t\tymax=int.Parse(Csv[3]);\n//Console.WriteLine(\"dbg xmin={0},ymin={1},xmax={2},ymax={3}\",xmin,ymin,xmax,ymax);\n\t\t//子ノードを追加する\n\t\t//cursol:'<'の上にいる\n\t\tChildren=new List<PannelTag>();\n\t\twhile(cursol<expr.IndexOf(\"</\"+body+\">\",0)){\n\t\t\tcursol_bak=cursol;\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString body_child=expr.Substring(cursol_bak+1,cursol-(cursol_bak+1));\n//Console.WriteLine(\"dbg body_child={0}\",body_child);\n\t\t\tcursol=expr.IndexOf(\"</\"+body_child+\">\",cursol_bak);\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString expr_child=expr.Substring(cursol_bak,cursol-cursol_bak+1);\n//Console.WriteLine(\"dbg expr_child={0}\",expr_child);\n\t\t\tChildren.Add(new PannelTag(expr_child));\n\t\t\tcursol++;//'<'の上に置く\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=int.Parse(Console.ReadLine());\n\t\t\tif(d==0)break;\n\t\t\tSol mySol=new Sol(d);\n\t\t\tmySol.WriteAns();\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tint n;\n\tPannelTag TOP;\n\tpublic void WriteAns(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//var s=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tvar ss=Console.ReadLine().Split(' ');\n\t\t\tint[] s=new int[2];\n\t\t\ts[0]=int.Parse(ss[0]);\n\t\t\ts[1]=int.Parse(ss[1]);\n\t\t\t\n\t\t\tSearchAndWrite(TOP,s[0],s[1]);\n\t\t}\n\t}\n\t\n\tvoid SearchAndWrite(PannelTag P,int x,int y){\n\t\tbool chk=true;\n\t\tfor(int i=0;i<P.Children.Count;i++){\n\t\t\tif(x>=P.Children[i].Xmin && x<=P.Children[i].Xmax && y>=P.Children[i].Ymin && y<=P.Children[i].Ymax){\n\t\t\t\tchk=false;\n\t\t\t\tSearchAndWrite(P.Children[i],x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(chk){\n\t\t\tConsole.Write(P.Body);\n\t\t\tConsole.WriteLine(\" {0}\",P.Children.Count);\n\t\t}\n\t}\n\t\n\tpublic Sol(int n_){\n\t\tn=n_;\n\t\tString tag_main=Console.ReadLine();\n\t\t\n\t\tPannelTag Content=new PannelTag(tag_main);\n\t\t\n\t\t// 外枠を追加する（万一、mainの中に\"OUT OF MAIN PANEL\"があった時のために、個別に生成）\n\t\tTOP=new PannelTag(\"<OUT OF MAIN PANEL>0,0,10001,10001</OUT OF MAIN PANEL>\");\n\t\tContent.Parent=TOP;\n\t\tTOP.Children.Add(Content);\n\t}\n}\n\n\nclass PannelTag{\n\tPannelTag parent;\n\tString body;\n\tString expr;\n\tint xmin;\n\tint xmax;\n\tint ymax;\n\tint ymin;\n\t\n\tpublic PannelTag Parent{\n\t\tget{return parent;}\n\t\tset{this.parent=value;}\n\t}\n\tpublic List<PannelTag> Children;\n\tpublic int Xmin{get{return xmin;}}\n\tpublic int Xmax{get{return xmax;}}\n\tpublic int Ymin{get{return ymin;}}\n\tpublic int Ymax{get{return ymax;}}\n\tpublic String Body{get{return body;}}\n\n\n\t//constructor\n\t//exprを与えて再帰的にparseしながらツリーを生成。\n\tpublic PannelTag(String expr_){\n\t\texpr=expr_;\n\t\t\n\t\tint cursol=0;\n\t\tint cursol_bak=0;\n\t\t\n\t\twhile(expr[cursol]!='>')cursol++;\n\t\tbody=expr.Substring(1,cursol-1);\n//Console.WriteLine(\"dbg body={0}\",body);\n\t\tcursol++;\n\t\tcursol_bak=cursol;//＠サイズの先頭文字\n\t\twhile(expr[cursol]!='<')cursol++;\n\t\tvar Csv=expr.Substring(cursol_bak,cursol-cursol_bak).Split(',');\n//Console.WriteLine(\"dbg CSV={0}\",expr.Substring(cursol_bak,cursol-cursol_bak));\n\t\txmin=int.Parse(Csv[0]);\n\t\tymin=int.Parse(Csv[1]);\n\t\txmax=int.Parse(Csv[2]);\n\t\tymax=int.Parse(Csv[3]);\n//Console.WriteLine(\"dbg xmin={0},ymin={1},xmax={2},ymax={3}\",xmin,ymin,xmax,ymax);\n\t\t//子ノードを追加する\n\t\t//cursol:'<'の上にいる\n\t\tChildren=new List<PannelTag>();\n\t\twhile(cursol<expr.IndexOf(\"</\"+body+\">\",0)){\n\t\t\tcursol_bak=cursol;\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString body_child=expr.Substring(cursol_bak+1,cursol-(cursol_bak+1));\n//Console.WriteLine(\"dbg body_child={0}\",body_child);\n\t\t\tcursol=expr.IndexOf(\"</\"+body_child+\">\",cursol_bak);\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString expr_child=expr.Substring(cursol_bak,cursol-cursol_bak);\n\t\t\tChildren.Add(new PannelTag(expr_child));\n\t\t\tcursol++;//'<'の上に置く\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=int.Parse(Console.ReadLine());\n\t\t\tif(d==0)break;\n\t\t\tSol mySol=new Sol(d);\n\t\t\tmySol.WriteAns();\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tint n;\n\tPannelTag TOP;\n\tpublic void WriteAns(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//var s=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tvar ss=Console.ReadLine().Split(' ');\n\t\t\tint[] s=new int[2];\n\t\t\ts[0]=int.Parse(ss[0]);\n\t\t\ts[1]=int.Parse(ss[1]);\n\t\t\t\n\t\t\tSearchAndWrite(TOP,s[0],s[1]);\n\t\t}\n\t}\n\t\n\tvoid SearchAndWrite(PannelTag P,int x,int y){\n\t\tbool chk=true;\n\t\tfor(int i=0;i<P.Children.Count;i++){\n\t\t\tif(x>=P.Children[i].Xmin && x<=P.Children[i].Xmax && y>=P.Children[i].Ymin && y<=P.Children[i].Ymax){\n\t\t\t\tchk=false;\n\t\t\t\tSearchAndWrite(P.Children[i],x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(chk){\n\t\t\tConsole.Write(P.Body);\n\t\t\tConsole.WriteLine(\" {0}\",P.Children.Count);\n\t\t}\n\t}\n\t\n\tpublic Sol(int n_){\n\t\tn=n_;\n\t\tString tag_main=Console.ReadLine();\n\t\t\n\t\tPannelTag Content=new PannelTag(tag_main);\n\t\t\n\t\t// 外枠を追加する（万一、mainの中に\"OUT OF MAIN PANEL\"があった時のために、個別に生成）\n\t\tTOP=new PannelTag(\"<OUT OF MAIN PANEL>0,0,10000,10000</OUT OF MAIN PANEL>\");\n\t\tContent.Parent=TOP;\n\t\tTOP.Children.Add(Content);\n\t}\n}\n\n\nclass PannelTag{\n\tPannelTag parent;\n\tString body;\n\tString expr;\n\tint xmin;\n\tint xmax;\n\tint ymax;\n\tint ymin;\n\t\n\tpublic PannelTag Parent{\n\t\tget{return parent;}\n\t\tset{this.parent=value;}\n\t}\n\tpublic List<PannelTag> Children;\n\tpublic int Xmin{get{return xmin;}}\n\tpublic int Xmax{get{return xmax;}}\n\tpublic int Ymin{get{return ymin;}}\n\tpublic int Ymax{get{return ymax;}}\n\tpublic String Body{get{return body;}}\n\n\n\t//constructor\n\t//exprを与えて再帰的にparseしながらツリーを生成。\n\tpublic PannelTag(String expr_){\n\t\texpr=expr_;\n\t\t\n\t\tint cursol=0;\n\t\tint cursol_bak=0;\n\t\t\n\t\twhile(expr[cursol]!='>')cursol++;\n\t\tbody=expr.Substring(1,cursol-1);\n//Console.WriteLine(\"dbg body={0}\",body);\n\t\tcursol++;\n\t\tcursol_bak=cursol;//＠サイズの先頭文字\n\t\twhile(expr[cursol]!='<')cursol++;\n\t\tvar Csv=expr.Substring(cursol_bak,cursol-cursol_bak).Split(',');\n//Console.WriteLine(\"dbg CSV={0}\",expr.Substring(cursol_bak,cursol-cursol_bak));\n\t\txmin=int.Parse(Csv[0]);\n\t\tymin=int.Parse(Csv[1]);\n\t\txmax=int.Parse(Csv[2]);\n\t\tymax=int.Parse(Csv[3]);\n//Console.WriteLine(\"dbg xmin={0},ymin={1},xmax={2},ymax={3}\",xmin,ymin,xmax,ymax);\n\t\t//子ノードを追加する\n\t\t//cursol:'<'の上にいる\n\t\tChildren=new List<PannelTag>();\n\t\twhile(cursol<expr.IndexOf(\"</\"+body+\">\",0)){\n\t\t\tcursol_bak=cursol;\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString body_child=expr.Substring(cursol_bak+1,cursol-(cursol_bak+1));\n//Console.WriteLine(\"dbg body_child={0}\",body_child);\n\t\t\tcursol=expr.IndexOf(\"</\"+body_child+\">\",cursol_bak);\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString expr_child=expr.Substring(cursol_bak,cursol-cursol_bak);\n\t\t\tChildren.Add(new PannelTag(expr_child));\n\t\t\tcursol++;//'<'の上に置く\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=int.Parse(Console.ReadLine());\n\t\t\tif(d==0)break;\n\t\t\tSol mySol=new Sol(d);\n\t\t\tmySol.WriteAns();\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tint n;\n\tPannelTag TOP;\n\tpublic void WriteAns(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar s=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tSearchAndWrite(TOP,s[0],s[1]);\n\t\t}\n\t}\n\t\n\tvoid SearchAndWrite(PannelTag P,int x,int y){\n\t\tbool chk=true;\n\t\tfor(int i=0;i<P.Children.Count;i++){\n\t\t\tif(x>=P.Children[i].Xmin && x<=P.Children[i].Xmax && y>=P.Children[i].Ymin && y<=P.Children[i].Ymax){\n\t\t\t\tchk=false;\n\t\t\t\tSearchAndWrite(P.Children[i],x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(chk){\n\t\t\tConsole.Write(P.Body);\n\t\t\tConsole.WriteLine(\" {0}\",P.Children.Count);\n\t\t}\n\t}\n\t\n\tpublic Sol(int n_){\n\t\tn=n_;\n\t\tString tag_main=Console.ReadLine();\n\t\t\n\t\tPannelTag Content=new PannelTag(tag_main);\n\t\t\n\t\t// 外枠を追加する（万一、mainの中に\"OUT OF MAIN PANEL\"があった時のために、個別に生成）\n\t\tTOP=new PannelTag(\"<OUT OF MAIN PANEL>0,0,10000,10000</OUT OF MAIN PANEL>\");\n\t\tContent.Parent=TOP;\n\t\tTOP.Children.Add(Content);\n\t}\n}\n\n\nclass PannelTag{\n\tPannelTag parent;\n\tString body;\n\tString expr;\n\tint xmin;\n\tint xmax;\n\tint ymax;\n\tint ymin;\n\t\n\tpublic PannelTag Parent{\n\t\tget{return parent;}\n\t\tset{this.parent=value;}\n\t}\n\tpublic List<PannelTag> Children;\n\tpublic int Xmin{get{return xmin;}}\n\tpublic int Xmax{get{return xmax;}}\n\tpublic int Ymin{get{return ymin;}}\n\tpublic int Ymax{get{return ymax;}}\n\tpublic String Body{get{return body;}}\n\n\n\t//constructor\n\t//exprを与えて再帰的にparseしながらツリーを生成。\n\tpublic PannelTag(String expr_){\n\t\texpr=expr_;\n\t\t\n\t\tint cursol=0;\n\t\tint cursol_bak=0;\n\t\t\n\t\twhile(expr[cursol]!='>')cursol++;\n\t\tbody=expr.Substring(1,cursol-1);\n//Console.WriteLine(\"dbg body={0}\",body);\n\t\tcursol++;\n\t\tcursol_bak=cursol;//＠サイズの先頭文字\n\t\twhile(expr[cursol]!='<')cursol++;\n\t\tvar Csv=expr.Substring(cursol_bak,cursol-cursol_bak).Split(',');\n//Console.WriteLine(\"dbg CSV={0}\",expr.Substring(cursol_bak,cursol-cursol_bak));\n\t\txmin=int.Parse(Csv[0]);\n\t\tymin=int.Parse(Csv[1]);\n\t\txmax=int.Parse(Csv[2]);\n\t\tymax=int.Parse(Csv[3]);\n//Console.WriteLine(\"dbg xmin={0},ymin={1},xmax={2},ymax={3}\",xmin,ymin,xmax,ymax);\n\t\t//子ノードを追加する\n\t\t//cursol:'<'の上にいる\n\t\tChildren=new List<PannelTag>();\n\t\twhile(cursol<expr.IndexOf(\"</\"+body+\">\",0)){\n\t\t\tcursol_bak=cursol;\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString body_child=expr.Substring(cursol_bak+1,cursol-(cursol_bak+1));\n//Console.WriteLine(\"dbg body_child={0}\",body_child);\n\t\t\tcursol=expr.IndexOf(\"</\"+body_child+\">\",cursol_bak);\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString expr_child=expr.Substring(cursol_bak,cursol-cursol_bak);\n\t\t\tChildren.Add(new PannelTag(expr_child));\n\t\t\tcursol++;//'<'の上に置く\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=int.Parse(Console.ReadLine());\n\t\t\tif(d==0)break;\n\t\t\tSol mySol=new Sol(d);\n\t\t\tmySol.WriteAns();\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tint n;\n\tPannelTag TOP;\n\tpublic void WriteAns(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//var s=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tvar ss=Console.ReadLine().Split(' ');\n\t\t\tint[] s=new int[2];\n\t\t\ts[0]=int.Parse(ss[0]);\n\t\t\ts[1]=int.Parse(ss[1]);\n\t\t\t\n\t\t\tSearchAndWrite(TOP,s[0],s[1]);\n\t\t}\n\t}\n\t\n\tvoid SearchAndWrite(PannelTag P,int x,int y){\n\t\tbool chk=true;\n\t\tfor(int i=0;i<P.Children.Count;i++){\n\t\t\tif(x>=P.Children[i].Xmin && x<=P.Children[i].Xmax && y>=P.Children[i].Ymin && y<=P.Children[i].Ymax){\n\t\t\t\tchk=false;\n\t\t\t\tSearchAndWrite(P.Children[i],x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(chk){\n\t\t\tConsole.Write(P.Body);\n\t\t\tConsole.WriteLine(\" {0}\",P.Children.Count);\n\t\t}\n\t}\n\t\n\tpublic Sol(int n_){\n\t\tn=n_;\n\t\tString tag_main=Console.ReadLine();\n\t\t\n\t\tPannelTag Content=new PannelTag(tag_main);\n\t\t\n\t\t// 外枠を追加する（万一、mainの中に\"OUT OF MAIN PANEL\"があった時のために、個別に生成）\n\t\tTOP=new PannelTag(\"<OUT OF MAIN PANEL>0,0,10001,10001</OUT OF MAIN PANEL>\");\n\t\tContent.Parent=TOP;\n\t\tTOP.Children.Add(Content);\n\t}\n}\n\n\nclass PannelTag{\n\tPannelTag parent;\n\tString body;\n\tString expr;\n\tint xmin;\n\tint xmax;\n\tint ymax;\n\tint ymin;\n\t\n\tpublic PannelTag Parent{\n\t\tget{return parent;}\n\t\tset{this.parent=value;}\n\t}\n\tpublic List<PannelTag> Children;\n\tpublic int Xmin{get{return xmin;}}\n\tpublic int Xmax{get{return xmax;}}\n\tpublic int Ymin{get{return ymin;}}\n\tpublic int Ymax{get{return ymax;}}\n\tpublic String Body{get{return body;}}\n\n\n\t//constructor\n\t//exprを与えて再帰的にparseしながらツリーを生成。\n\tpublic PannelTag(String expr_){\n\t\texpr=expr_;\n\t\t\n\t\tint cursol=0;\n\t\tint cursol_bak=0;\n\t\t\n\t\twhile(expr[cursol]!='>')cursol++;\n\t\tbody=expr.Substring(1,cursol-1);\n\t\tcursol++;\n\t\tcursol_bak=cursol;//＠サイズの先頭文字\n\t\twhile(expr[cursol]!='<')cursol++;\n\t\tvar Csv=expr.Substring(cursol_bak,cursol-cursol_bak).Split(',');\n\t\txmin=int.Parse(Csv[0]);\n\t\tymin=int.Parse(Csv[1]);\n\t\txmax=int.Parse(Csv[2]);\n\t\tymax=int.Parse(Csv[3]);\n\n\t\t//子ノードを追加する\n\t\t//cursol:'<'の上にいる\n\t\tChildren=new List<PannelTag>();\n\t\twhile(cursol<expr.IndexOf(\"</\"+body+\">\",0)){\n\t\t\tcursol_bak=cursol;\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString body_child=expr.Substring(cursol_bak+1,cursol-(cursol_bak+1));\n\t\t\tcursol=expr.IndexOf(\"</\"+body_child+\">\",cursol_bak);\n\t\t\twhile(expr[cursol]!='>')cursol++;\n\t\t\tString expr_child=expr.Substring(cursol_bak,cursol-cursol_bak+1);\n\t\t\tChildren.Add(new PannelTag(expr_child));\n\t\t\tcursol++;//'<'の上に置く\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\nusing System.Text.RegularExpressions;\n\npublic class P\n{\n    public string name { get; set; }\n    public List<int> to { get; set; }\n    public int from { get; set; }\n    public int x1 { get; set; }\n    public int y1 { get; set; }\n    public int x2 { get; set; }\n    public int y2 { get; set; }\n}\n\npublic class hello\n{\n    public static string ans1;\n    public static int ans2;\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var text = Console.ReadLine().Trim();\n            var matches = Regex.Matches(text, @\"<([^<>]+)>\");\n            var tag = new List<string>();\n            foreach (Match x in matches)\n                tag.Add(x.Groups[1].ToString());\n            var ps = getList(tag);\n            getXY(text, ps);\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                var x = int.Parse(line[0]);\n                var y = int.Parse(line[1]);\n                check(x, y, ps, 0);\n                if (ans2 == -1) Console.WriteLine(ans1);\n                else Console.WriteLine(\"{0} {1}\", ans1, ans2);\n            }\n        }\n    }\n    static bool check(int x, int y, P[] ps, int c)\n    {\n        if (x >= ps[c].x1 && x <= ps[c].x2 &&\n               y >= ps[c].y1 && y <= ps[c].y2)\n        {\n            if (ps[c].to.Count() > 0)\n            {\n                foreach (var xx in ps[c].to)\n                {\n                    if (check(x, y, ps, xx)) return true;\n                }\n                ans1 = ps[c].name;\n                ans2 = ps[c].to.Count();\n                return true;\n            }\n            else\n            {\n                ans1 = ps[c].name;\n                ans2 = 0;\n                return true;\n            }\n        }\n        else\n        {\n            if (ps[c].from == -1)\n            {\n                ans1 = \"OUT OF MAIN PANEL 1\";\n                ans2 = -1;\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n    }\n    static void getXY(string text, P[] ps)\n    {\n        for (int i = 0; i < ps.Length; i++)\n        {\n            var xL = ps[i].name.Length;\n            var p1 = text.IndexOf(\"<\" + ps[i].name + \">\") + xL + 2;\n            var p2 = text.IndexOf(\"<\", p1);\n            var t = text.Substring(p1, p2 - p1);\n            string[] line = t.Split(',');\n            ps[i].x1 = int.Parse(line[0]);\n            ps[i].y1 = int.Parse(line[1]);\n            ps[i].x2 = int.Parse(line[2]);\n            ps[i].y2 = int.Parse(line[3]);\n        }\n    }\n    static P[] getList(List<string> tag)\n    {\n        var tL = tag.Count();\n        var n = tL / 2;\n        var ps = new P[n];\n        for (int i = 0; i < n; i++) ps[i] = new P { to = new List<int>() };\n        ps[0].name = tag[0];\n        ps[0].from = -1;\n        var p = 1;\n        var now = 0;\n        for (int i = 1; i < tL; i++)\n        {\n            if (tag[i][0] != '/')\n            {\n                ps[p].name = tag[i];\n                ps[p].from = now;\n                ps[now].to.Add(p);\n                now = p;\n                p++;\n            }\n            else now = ps[now].from;\n        }\n        return ps;\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "class REXML::Element\n    def check(x, y)\n        init if !@initialized\n        return nil if x < @x1 || @x2 < x || y < @y1 || @y2 < y\n        children = elements\n        puts \"#{name} #{children.size}\" if !children.any? {|c| c.check(x, y)}\n        return true\n    end\n\n    def init\n        @x1, @y1, @x2, @y2 = text.split(?,).map(&:to_i)\n        @initialized = true\n    end\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    xml = REXML::Document.new(gets.chomp)\n    main_panel = xml.elements['/main']\n\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        puts \"OUT OF MAIN PANEL 1\" if !main_panel.check(x, y)\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'rexml/document'\n\nclass REXML::Element\n    def check(x, y)\n        init if !@initialized\n        return nil if x < @x1 || @x2 < x || y < @y1 || @y2 < y\n        children = elements\n        puts \"#{name} #{children.size}\" if !children.any? {|c| c.check(x, y)}\n        return true\n    end\n\n    def init\n        @x1, @y1, @x2, @y2 = text.split(?,).map(&:to_i)\n        @initialized = true\n    end\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    xml = REXML::Document.new(gets.chomp)\n    main_panel = xml.elements['/main']\n\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        puts \"OUT OF MAIN PANEL 1\" if !main_panel.check(x, y)\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 1031.rb: Simple GUI Application\n#\n\n### subroutines\n\n# tagst := stag tagvalue {tagst}* etag\n# stag  := <tagname>\n# etag  := </tagname>\n# tagname := string\n# tagvalue := num,num,num,num\n\ndef parse_tagst(gui)\n  tagname = parse_stag(gui)\n  vals = parse_tagvalue(gui)\n\n  tagsts = []\n  while gui[$pos + 1] != '/'\n    tagsts << parse_tagst(gui)\n  end\n\n  parse_etag(gui)\n\n  [tagname, vals, tagsts]\nend\n\ndef parse_stag(gui)\n  return nil if gui[$pos] != '<'\n  $pos += 1\n\n  pos0 = $pos\n  while gui[pos0] != '>'\n    pos0 += 1\n  end\n\n  tagname = gui[$pos...pos0]\n  $pos = pos0 + 1\n  tagname\nend\n\ndef parse_etag(gui)\n  return nil if gui[$pos] != '<'\n  $pos += 1\n  return nil if gui[$pos] != '/'\n  $pos += 1\n\n  pos0 = $pos\n  while gui[pos0] != '>'\n    pos0 += 1\n  end\n\n  tagname = gui[$pos...pos0]\n  $pos = pos0 + 1\n  tagname\nend\n\ndef parse_tagvalue(gui)\n  pos0 = $pos\n  while gui[pos0] != '<'\n    pos0 += 1\n  end\n\n  vals = gui[$pos...pos0].split(',').map(&:to_i)\n  $pos = pos0\n  vals\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  gui = gets.strip\n\n  $pos = 0\n  main = parse_tagst(gui)\n\n  n.times do\n    x, y = gets.split.map(&:to_i)\n\n    name = 'OUT OF MAIN PANEL'\n    cnum = 1\n    panels = [main]\n\n    while ! panels.empty?\n      panel = panels.shift\n\n      pname, pvals, pchld = panel\n      x0, y0, x1, y1 = pvals\n\n      if x >= x0 && x <= x1 && y >= y0 && y <= y1\n        name = pname\n        cnum = pchld.length\n        panels = pchld.clone\n      end\n    end\n\n    puts [name, cnum].join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'rexml/document'\n\nclass Panel\n    def initialize(xml_node)\n        @name = xml_node.name\n        @x1, @y1, @x2, @y2 = xml_node.text.split(?,).map(&:to_i)\n        @children = xml_node.elements.map {|c| Panel.new(c)}\n    end\n\n    def check(x, y)\n        return nil if x < @x1 || @x2 < x || y < @y1 || @y2 < y\n\n        if !@children.any? {|c| c.check(x, y)}\n            puts \"#{@name} #{@children.size}\"\n        end\n\n        return true\n    end\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    xml = REXML::Document.new(gets.chomp)\n    main_panel = Panel.new(xml.elements['/main'])\n\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        puts \"OUT OF MAIN PANEL 1\" if !main_panel.check(x, y)\n    end\nend"
  },
  {
    "language": "PHP",
    "code": "<?php\n\ndefine( 'NONE', -1 );\n\nclass AOJ1031 {\n    var $L;\n    var $LC;\n    var $n;\n    var $X;\n    var $Y;\n\n    public function init() {\n        $L = &$this->L;\n        $LC = &$this->LC;\n        \n        $L = file( '/dev/stdin' );\n        $LC = count( $L );\n    }\n\n    public function input( &$offset ) {\n        $L = &$this->L;\n        $LC = &$this->LC;\n        $n = &$this->n;\n        $markup = &$this->markup;\n        $X = &$this->X;\n        $Y = &$this->Y;\n\n        $n = $L[$offset];\n        if ( $n == 0 ) return false;\n        \n        $markup = $L[$offset+1];\n        $offset += 2;\n        $X = array();\n        $Y = array();\n        for ( $i = 0; $i < $n; ++ $i, ++ $offset ) {\n            $line = $L[$offset];\n            $terms = split(' ', $line);\n            $X[$i] = intval( $terms[0] );\n            $Y[$i] = intval( $terms[1] );\n        }\n        return true;\n    }\n\n    public function hit_test( $x, $y, $x1, $y1, $x2, $y2 ) {\n        return $x1 <= $x && $x <= $x2 && $y1 <= $y && $y <= $y2;\n    }\n\n    public function get_positions( $line, &$x1, &$y1, &$x2, &$y2 ) {\n        $terms = split( ',', $line );\n        $x1 = $terms[0];\n        $y1 = $terms[1];\n        $x2 = $terms[2];\n        $y2 = $terms[3];\n    }\n\n    public function check_clicked( $root, $x, $y, &$name, &$childs ) {\n        $this->get_positions( $root, $x1, $y1, $x2, $y2 );\n        if ( $this->hit_test( $x, $y, $x1, $y1, $x2, $y2 ) ) {\n            foreach ( $root as $child ) {\n                $this->get_positions( $child, $x1, $y1, $x2, $y2 );\n                if ( $this->check_clicked( $child, $x, $y, $name, $childs ) ) {\n                    return true;\n                }\n            }\n            $name = $root->getName();\n            $childs = $root->count();\n            return true;\n        }\n        $name = 'OUT OF MAIN PANEL';\n        $childs = 1;\n        return false;\n    }\n\n    public function solve() {\n        $n = &$this->n;\n        $markup = &$this->markup;\n        $X = &$this->X;\n        $Y = &$this->Y;\n\n        $object = new SimpleXMLElement( $markup );\n        for ( $i = 0; $i < $n; ++ $i ) {\n            $name = \"\";\n            $childs = -1;\n            $this->check_clicked( $object, $X[$i], $Y[$i], $name, $childs );\n            echo \"$name $childs\\n\";\n        }\n    }\n\n    public function run() {\n        $L = &$this->L;\n        $LC = &$this->LC;\n        $this->init();\n        for ( $i = 0; $i < $LC; ++ $i ) {\n            while ( $this->input($i) ) {\n                $this->solve();\n            }\n        }\n    }\n}\n\n$instance = new AOJ1031;\n$instance->run();"
  },
  {
    "language": "PHP",
    "code": "<?php\nclass AOJ1031 {\n    var $L;\n    var $LC;\n    var $n;\n    var $X;\n    var $Y;\n\n    public function init() {\n        $L = &$this->L;\n        $LC = &$this->LC;\n        \n        $L = file( '/dev/stdin' );\n        $LC = count( $L );\n    }\n\n    public function input( &$offset ) {\n        $L = &$this->L;\n        $LC = &$this->LC;\n        $n = &$this->n;\n        $markup = &$this->markup;\n        $X = &$this->X;\n        $Y = &$this->Y;\n\n        $n = $L[$offset];\n        if ( $n == 0 ) return false;\n        \n        $markup = $L[$offset+1];\n        $offset += 2;\n        $X = array();\n        $Y = array();\n        for ( $i = 0; $i < $n; ++ $i, ++ $offset ) {\n            $line = $L[$offset];\n            $terms = split(' ', $line);\n            $X[$i] = intval( $terms[0] );\n            $Y[$i] = intval( $terms[1] );\n        }\n        return true;\n    }\n\n    public function solve() {\n        $n = &$this->n;\n        $markup = &$this->markup;\n        $X = &$this->X;\n        $Y = &$this->Y;\n\n        $xml = new SimpleXMLElement( \"<top>\" . $markup . \"</top>\" );\n        print_r($xml);\n        echo \"-1\\n\";\n    }\n\n    public function run() {\n        $L = &$this->L;\n        $LC = &$this->LC;\n        $this->init();\n        for ( $i = 0; $i < $LC; ++ $i ) {\n            while ( $this->input($i) ) {\n                $this->solve();\n            }\n        }\n    }\n}\n\n$instance = new AOJ1031;\n$instance->run();"
  },
  {
    "language": "Python",
    "code": "class Panel(object):\n    def __init__(self, name, depth, child, x1, y1, x2, y2):\n        self.name = name\n        self.depth = depth\n        self.child = child\n        self.x1 = x1\n        self.y1 = y1\n        self.x2 = x2\n        self.y2 = y2\n\n    def touch(self, x, y, depth):\n        if depth < self.depth and self.x1 <= x <= self.x2 and self.y1 <= y <= self.y2:\n            return self\n        else:\n            return None\n\n    def __repr__(self):\n        return f\"{self.name} {self.child}\"\n\n\ndef solve():\n    import re\n    while True:\n        N = int(input())\n        if N == 0:\n            break\n\n        S = input()\n        panels = [Panel(\"OUT OF MAIN PANEL\", 0, 1, 0, 0, 10000, 10000)]\n\n        def rec(s, depth):\n            child = 0\n            while s:\n                child += 1\n                tag_name = re.match(r\"<([^>]+)>\", s).group(1)\n                result = re.match(r\"<%s>(\\d+),(\\d+),(\\d+),(\\d+)(.*?)</%s>\" % (tag_name, tag_name), s)\n                panels.append(Panel(tag_name, depth, rec(result.group(5), depth + 1), *(map(int, result.groups()[:4]))))\n                s = s[result.span()[1]:]\n            return child\n\n        rec(S, 1)\n\n        for _ in [0]*N:\n            x, y = map(int, input().split())\n            result = panels[0]\n            for panel in panels[1:]:\n                result = panel.touch(x, y, result.depth) or result\n            print(result)\n\n\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "class Panel:\n    def __init__(self, name, points, children):\n        self.name = name\n        self.x1 = points[0]\n        self.x2 = points[2]\n        self.y1 = points[1]\n        self.y2 = points[3]\n        self.children = children\n        self.child_cnt = len(children)\n\n    def search(self, x, y):\n        if not (self.x1 <= x <= self.x2 and self.y1 <= y <= self.y2):\n            return [\"OUT\", \"OF\", \"MAIN\", \"PANEL\", \"1\"]\n        for child in self.children:\n            if child.x1 <= x <= child.x2 and child.y1 <= y <= child.y2:\n                return child.search(x, y)\n        return self.name, self.child_cnt\n\n\ndef parse_tag_structure(s, pointer):\n    name, pointer = parse_begin_tag(s, pointer)\n    points, pointer = parse_tag_value(s, pointer)\n    children = []\n    while True:\n        if s[pointer + 1] == \"/\":break\n        child, pointer = parse_tag_structure(s, pointer)\n        children.append(child)\n    pointer = parse_end_tag(s, pointer)\n    return Panel(name, points, children), pointer\n\n\ndef parse_begin_tag(s, pointer):\n    pointer += 1\n    name = \"\"\n    while s[pointer] != \">\":\n        name += s[pointer]\n        pointer += 1\n    pointer += 1\n    return name, pointer\n\n\ndef parse_tag_value(s, pointer):\n    points = []\n    for _ in range(4):\n        point = \"\"\n        while \"0\" <= s[pointer] <= \"9\":\n            point += s[pointer]\n            pointer += 1\n        points.append(int(point))\n        pointer += 1\n    return points, pointer - 1\n\n\ndef parse_end_tag(s, pointer):\n    while s[pointer] != \">\":\n        pointer += 1\n    pointer += 1\n    return pointer\n\n\nwhile True:\n    n = int(input())\n    if n == 0:break\n    s = input()\n    panel, _ = parse_tag_structure(s, 0)\n    for _ in range(n):\n        x, y = map(int, input().split())\n        print(*panel.search(x, y))\n"
  }
]