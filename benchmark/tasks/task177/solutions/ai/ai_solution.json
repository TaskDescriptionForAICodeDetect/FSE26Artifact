[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\ntypedef struct Panel {\n    char name[50];\n    int x1, y1, x2, y2;\n    struct Panel* parent;\n    struct Panel** children;\n    int child_count;\n} Panel;\n\nPanel* create_panel(const char* name, int x1, int y1, int x2, int y2) {\n    Panel* panel = (Panel*)malloc(sizeof(Panel));\n    strcpy(panel->name, name);\n    panel->x1 = x1;\n    panel->y1 = y1;\n    panel->x2 = x2;\n    panel->y2 = y2;\n    panel->parent = NULL;\n    panel->children = NULL;\n    panel->child_count = 0;\n    return panel;\n}\n\nvoid add_child(Panel* parent, Panel* child) {\n    parent->children = (Panel**)realloc(parent->children, (parent->child_count + 1) * sizeof(Panel*));\n    parent->children[parent->child_count++] = child;\n    child->parent = parent;\n}\n\nbool is_point_inside(Panel* panel, int x, int y) {\n    return x >= panel->x1 && x <= panel->x2 && y >= panel->y1 && y <= panel->y2;\n}\n\nPanel* find_deepest_panel(Panel* panel, int x, int y) {\n    if (!is_point_inside(panel, x, y)) {\n        return NULL;\n    }\n\n    for (int i = 0; i < panel->child_count; i++) {\n        Panel* child = panel->children[i];\n        Panel* found = find_deepest_panel(child, x, y);\n        if (found != NULL) {\n            return found;\n        }\n    }\n\n    return panel;\n}\n\nint count_directly_above(Panel* panel) {\n    if (panel->parent == NULL) {\n        return 0;\n    }\n\n    int count = 0;\n    Panel* parent = panel->parent;\n    for (int i = 0; i < parent->child_count; i++) {\n        Panel* sibling = parent->children[i];\n        if (sibling == panel) {\n            break;\n        }\n        if (sibling->x1 <= panel->x2 && sibling->x2 >= panel->x1 &&\n            sibling->y1 <= panel->y2 && sibling->y2 >= panel->y1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid free_panel(Panel* panel) {\n    for (int i = 0; i < panel->child_count; i++) {\n        free_panel(panel->children[i]);\n    }\n    free(panel->children);\n    free(panel);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    getchar(); // consume newline\n\n    char input[1000];\n    fgets(input, sizeof(input), stdin);\n\n    Panel* root = NULL;\n    Panel* current_parent = NULL;\n    Panel* panels[100];\n    int panel_count = 0;\n\n    char* token = strtok(input, \" \");\n    while (token != NULL) {\n        if (strcmp(token, \"<\") == 0) {\n            token = strtok(NULL, \" \");\n            char name[50];\n            int x1, y1, x2, y2;\n            sscanf(token, \"%[^:]:%d,%d,%d,%d\", name, &x1, &y1, &x2, &y2);\n            Panel* panel = create_panel(name, x1, y1, x2, y2);\n            panels[panel_count++] = panel;\n            if (root == NULL) {\n                root = panel;\n            } else {\n                add_child(current_parent, panel);\n            }\n            current_parent = panel;\n        } else if (strcmp(token, \">\") == 0) {\n            if (current_parent != NULL) {\n                current_parent = current_parent->parent;\n            }\n        }\n        token = strtok(NULL, \" \");\n    }\n\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        Panel* selected = find_deepest_panel(root, x, y);\n        if (selected == NULL) {\n            printf(\"OUT OF MAIN PANEL\\n\");\n        } else {\n            int above = count_directly_above(selected);\n            printf(\"%s %d\\n\", selected->name, above);\n        }\n    }\n\n    free_panel(root);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import javax.swing.*;\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class PanelTouchSelector {\n    private static class Panel {\n        String name;\n        Rectangle bounds;\n        List<Panel> children = new ArrayList<>();\n        Panel parent;\n\n        Panel(String name, Rectangle bounds) {\n            this.name = name;\n            this.bounds = bounds;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read number of touch points\n        int touchPointCount = scanner.nextInt();\n        scanner.nextLine();\n\n        // Read tagged structure\n        String taggedStructure = scanner.nextLine();\n\n        // Parse tagged structure\n        Panel rootPanel = parseTaggedStructure(taggedStructure);\n\n        // Process touch points\n        for (int i = 0; i < touchPointCount; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            processPoint(rootPanel, x, y);\n        }\n    }\n\n    private static Panel parseTaggedStructure(String structure) {\n        Stack<Panel> stack = new Stack<>();\n        Pattern pattern = Pattern.compile(\"<(\\\\w+):(\\\\d+),(\\\\d+),(\\\\d+),(\\\\d+)>\");\n\n        Matcher matcher = pattern.matcher(structure);\n        Panel rootPanel = null;\n\n        while (matcher.find()) {\n            String name = matcher.group(1);\n            int x = Integer.parseInt(matcher.group(2));\n            int y = Integer.parseInt(matcher.group(3));\n            int width = Integer.parseInt(matcher.group(4));\n            int height = Integer.parseInt(matcher.group(5));\n\n            Panel panel = new Panel(name, new Rectangle(x, y, width, height));\n\n            while (!stack.isEmpty() && !isContained(stack.peek().bounds, panel.bounds)) {\n                stack.pop();\n            }\n\n            if (!stack.isEmpty()) {\n                panel.parent = stack.peek();\n                stack.peek().children.add(panel);\n            } else {\n                rootPanel = panel;\n            }\n\n            stack.push(panel);\n        }\n\n        return rootPanel;\n    }\n\n    private static void processPoint(Panel root, int x, int y) {\n        Point point = new Point(x, y);\n        Panel selectedPanel = findPanelAtPoint(root, point);\n\n        if (selectedPanel == null) {\n            System.out.println(\"Out of panel\");\n        } else {\n            int ancestorCount = countAncestors(selectedPanel);\n            System.out.println(selectedPanel.name + \" \" + ancestorCount);\n        }\n    }\n\n    private static Panel findPanelAtPoint(Panel panel, Point point) {\n        if (!panel.bounds.contains(point)) {\n            return null;\n        }\n\n        for (Panel child : panel.children) {\n            Panel result = findPanelAtPoint(child, point);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return panel;\n    }\n\n    private static int countAncestors(Panel panel) {\n        int count = 0;\n        Panel current = panel.parent;\n        while (current != null) {\n            count++;\n            current = current.parent;\n        }\n        return count;\n    }\n\n    private static boolean isContained(Rectangle parent, Rectangle child) {\n        return parent.contains(child);\n    }\n}",
    "timestamp": "2025-08-05 18:57:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\nstruct Panel {\n    string name;\n    int x1, y1, x2, y2;\n    vector<Panel*> children;\n    Panel* parent;\n\n    Panel(string n, int x1, int y1, int x2, int y2) : name(n), x1(x1), y1(y1), x2(x2), y2(y2), parent(nullptr) {}\n\n    bool contains(int x, int y) const {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }\n};\n\nPanel* parsePanel(const string& s, int& pos) {\n    while (pos < s.size() && s[pos] != '<') pos++;\n    if (pos >= s.size()) return nullptr;\n    pos++;\n    if (s[pos] == '/') return nullptr;\n\n    string name;\n    while (pos < s.size() && s[pos] != ' ') name += s[pos++];\n    pos++;\n\n    int x1, y1, x2, y2;\n    string token;\n    while (pos < s.size() && s[pos] != 'x') pos++;\n    pos++;\n    while (pos < s.size() && isdigit(s[pos])) token += s[pos++];\n    x1 = stoi(token);\n    token.clear();\n    while (pos < s.size() && s[pos] != 'y') pos++;\n    pos++;\n    while (pos < s.size() && isdigit(s[pos])) token += s[pos++];\n    y1 = stoi(token);\n    token.clear();\n    while (pos < s.size() && s[pos] != 'x') pos++;\n    pos++;\n    while (pos < s.size() && isdigit(s[pos])) token += s[pos++];\n    x2 = stoi(token);\n    token.clear();\n    while (pos < s.size() && s[pos] != 'y') pos++;\n    pos++;\n    while (pos < s.size() && isdigit(s[pos])) token += s[pos++];\n    y2 = stoi(token);\n    token.clear();\n\n    while (pos < s.size() && s[pos] != '>') pos++;\n    pos++;\n\n    Panel* panel = new Panel(name, x1, y1, x2, y2);\n\n    while (true) {\n        Panel* child = parsePanel(s, pos);\n        if (!child) break;\n        child->parent = panel;\n        panel->children.push_back(child);\n    }\n\n    while (pos < s.size() && s[pos] != '<') pos++;\n    if (pos < s.size() && s[pos + 1] == '/') {\n        while (pos < s.size() && s[pos] != '>') pos++;\n        pos++;\n    }\n\n    return panel;\n}\n\nvoid findPanel(Panel* panel, int x, int y, vector<Panel*>& candidates) {\n    if (panel->contains(x, y)) {\n        candidates.push_back(panel);\n        for (Panel* child : panel->children) {\n            findPanel(child, x, y, candidates);\n        }\n    }\n}\n\nint countAbove(Panel* panel) {\n    if (!panel->parent) return 0;\n    int count = 0;\n    for (Panel* sibling : panel->parent->children) {\n        if (sibling == panel) break;\n        count++;\n    }\n    return count;\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    int pos = 0;\n    Panel* root = parsePanel(input, pos);\n\n    int N;\n    cin >> N;\n    vector<pair<int, int>> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].first >> points[i].second;\n    }\n\n    for (auto& point : points) {\n        int x = point.first;\n        int y = point.second;\n        vector<Panel*> candidates;\n        findPanel(root, x, y, candidates);\n\n        if (candidates.empty()) {\n            cout << \"OUT OF MAIN PANEL\" << endl;\n        } else {\n            Panel* selected = candidates.back();\n            int above = countAbove(selected);\n            cout << selected->name << \" \" << above << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_TAG_LENGTH 50\n#define MAX_PANELS 100\n\ntypedef struct Panel {\n    char tag[MAX_TAG_LENGTH];\n    int x1, y1, x2, y2;\n    int depth;\n    struct Panel* parent;\n    struct Panel** children;\n    int child_count;\n} Panel;\n\nPanel* create_panel(const char* tag, int x1, int y1, int x2, int y2, int depth) {\n    Panel* panel = malloc(sizeof(Panel));\n    strcpy(panel->tag, tag);\n    panel->x1 = x1;\n    panel->y1 = y1;\n    panel->x2 = x2;\n    panel->y2 = y2;\n    panel->depth = depth;\n    panel->parent = NULL;\n    panel->children = NULL;\n    panel->child_count = 0;\n    return panel;\n}\n\nvoid add_child(Panel* parent, Panel* child) {\n    parent->children = realloc(parent->children, (parent->child_count + 1) * sizeof(Panel*));\n    parent->children[parent->child_count++] = child;\n    child->parent = parent;\n}\n\nbool point_in_panel(Panel* panel, int x, int y) {\n    return (x >= panel->x1 && x <= panel->x2 && y >= panel->y1 && y <= panel->y2);\n}\n\nPanel* find_panel_at_point(Panel* root, int x, int y) {\n    if (!point_in_panel(root, x, y)) {\n        return NULL;\n    }\n\n    for (int i = 0; i < root->child_count; i++) {\n        Panel* child_result = find_panel_at_point(root->children[i], x, y);\n        if (child_result) {\n            return child_result;\n        }\n    }\n\n    return root;\n}\n\nint count_above_panels(Panel* panel) {\n    int count = 0;\n    Panel* current = panel->parent;\n    while (current) {\n        count++;\n        current = current->parent;\n    }\n    return count;\n}\n\nvoid free_panel_tree(Panel* panel) {\n    if (!panel) return;\n    \n    for (int i = 0; i < panel->child_count; i++) {\n        free_panel_tree(panel->children[i]);\n    }\n    \n    free(panel->children);\n    free(panel);\n}\n\nint main() {\n    int num_touch_points;\n    scanf(\"%d\", &num_touch_points);\n\n    Panel* root = NULL;\n    char tag[MAX_TAG_LENGTH];\n    int x1, y1, x2, y2, parent_depth;\n\n    while (scanf(\"%s %d %d %d %d %d\", tag, &x1, &y1, &x2, &y2, &parent_depth) == 6) {\n        if (strcmp(tag, \"END\") == 0) break;\n\n        Panel* panel = create_panel(tag, x1, y1, x2, y2, parent_depth);\n\n        if (!root) {\n            root = panel;\n        } else {\n            Panel* current = root;\n            while (current->depth != parent_depth - 1) {\n                current = current->children[current->child_count - 1];\n            }\n            add_child(current, panel);\n        }\n    }\n\n    for (int i = 0; i < num_touch_points; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n\n        Panel* selected = find_panel_at_point(root, x, y);\n\n        if (!selected) {\n            printf(\"OUT\\n\");\n        } else {\n            int above_panels = count_above_panels(selected);\n            printf(\"%s %d\\n\", selected->tag, above_panels);\n        }\n    }\n\n    free_panel_tree(root);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nstruct Panel {\n    std::string name;\n    int x1, y1, x2, y2;\n    std::vector<Panel*> children;\n    Panel* parent = nullptr;\n};\n\nclass PanelLayout {\nprivate:\n    Panel* root;\n\n    Panel* parsePanel(const std::string& tag) {\n        Panel* panel = new Panel();\n        std::istringstream iss(tag);\n        std::string token;\n        \n        std::getline(iss, panel->name, ':');\n        std::getline(iss, token, ',');\n        panel->x1 = std::stoi(token);\n        std::getline(iss, token, ',');\n        panel->y1 = std::stoi(token);\n        std::getline(iss, token, ',');\n        panel->x2 = std::stoi(token);\n        std::getline(iss, token);\n        panel->y2 = std::stoi(token);\n        \n        return panel;\n    }\n\n    void buildPanelHierarchy(std::vector<std::string>& panelTags) {\n        std::vector<Panel*> panels;\n        root = nullptr;\n\n        for (const auto& tag : panelTags) {\n            Panel* panel = parsePanel(tag);\n            panels.push_back(panel);\n        }\n\n        std::sort(panels.begin(), panels.end(), [](Panel* a, Panel* b) {\n            return a->x1 < b->x1 || (a->x1 == b->x1 && a->y1 < b->y1);\n        });\n\n        for (size_t i = 0; i < panels.size(); ++i) {\n            for (size_t j = 0; j < panels.size(); ++j) {\n                if (i != j && isParentPanel(panels[i], panels[j])) {\n                    panels[i]->children.push_back(panels[j]);\n                    panels[j]->parent = panels[i];\n                }\n            }\n        }\n\n        for (auto panel : panels) {\n            if (!panel->parent) {\n                root = panel;\n                break;\n            }\n        }\n    }\n\n    bool isParentPanel(Panel* parent, Panel* child) {\n        return parent->x1 <= child->x1 && parent->y1 <= child->y1 &&\n               parent->x2 >= child->x2 && parent->y2 >= child->y2;\n    }\n\n    Panel* findSelectedPanel(Panel* panel, int x, int y) {\n        if (!panel) return nullptr;\n\n        if (x >= panel->x1 && x <= panel->x2 && y >= panel->y1 && y <= panel->y2) {\n            for (auto child : panel->children) {\n                Panel* selected = findSelectedPanel(child, x, y);\n                if (selected) return selected;\n            }\n            return panel;\n        }\n        return nullptr;\n    }\n\n    int countParentPanels(Panel* panel) {\n        int count = 0;\n        while (panel->parent) {\n            count++;\n            panel = panel->parent;\n        }\n        return count;\n    }\n\npublic:\n    PanelLayout(std::vector<std::string>& panelTags) {\n        buildPanelHierarchy(panelTags);\n    }\n\n    std::pair<std::string, int> processTouchPoint(int x, int y) {\n        Panel* selectedPanel = findSelectedPanel(root, x, y);\n        if (!selectedPanel) {\n            return {\"Out of main panel\", -1};\n        }\n        return {selectedPanel->name, countParentPanels(selectedPanel)};\n    }\n\n    ~PanelLayout() {\n        std::vector<Panel*> allPanels;\n        collectPanels(root, allPanels);\n        for (auto panel : allPanels) {\n            delete panel;\n        }\n    }\n\nprivate:\n    void collectPanels(Panel* panel, std::vector<Panel*>& panels) {\n        if (!panel) return;\n        panels.push_back(panel);\n        for (auto child : panel->children) {\n            collectPanels(child, panels);\n        }\n    }\n};\n\nint main() {\n    int numPanels, numTouchPoints;\n    std::cin >> numPanels;\n\n    std::vector<std::string> panelTags(numPanels);\n    for (int i = 0; i < numPanels; ++i) {\n        std::cin >> panelTags[i];\n    }\n\n    PanelLayout layout(panelTags);\n\n    std::cin >> numTouchPoints;\n    for (int i = 0; i < numTouchPoints; ++i) {\n        int x, y;\n        std::cin >> x >> y;\n        auto result = layout.processTouchPoint(x, y);\n        std::cout << result.first << \" \" << result.second << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import javax.swing.*;\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class PanelSelector {\n    static class Panel {\n        String name;\n        int x1, y1, x2, y2;\n        List<Panel> children;\n\n        Panel(String name, int x1, int y1, int x2, int y2) {\n            this.name = name;\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n            this.children = new ArrayList<>();\n        }\n\n        boolean contains(int x, int y) {\n            return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n\n        String structure = scanner.nextLine().trim();\n        Panel root = parseStructure(structure);\n\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            List<Panel> path = new ArrayList<>();\n            findPanel(root, x, y, path);\n\n            if (path.isEmpty()) {\n                System.out.println(\"OUT OF MAIN PANEL\");\n            } else {\n                Panel selected = path.get(path.size() - 1);\n                System.out.print(selected.name + \" \");\n                System.out.println(path.size() - 1);\n            }\n        }\n    }\n\n    private static Panel parseStructure(String s) {\n        Stack<Panel> stack = new Stack<>();\n        StringBuilder name = new StringBuilder();\n        int[] coords = new int[4];\n        int coordIdx = 0;\n        boolean inTag = false;\n        boolean inName = false;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '<') {\n                inTag = true;\n                inName = true;\n                name.setLength(0);\n            } else if (c == '>') {\n                inTag = false;\n                String[] parts = name.toString().split(\" \");\n                String panelName = parts[0];\n                for (int j = 1; j < parts.length; j++) {\n                    coords[j - 1] = Integer.parseInt(parts[j]);\n                }\n                Panel panel = new Panel(panelName, coords[0], coords[1], coords[2], coords[3]);\n                if (!stack.isEmpty()) {\n                    stack.peek().children.add(panel);\n                }\n                stack.push(panel);\n                coordIdx = 0;\n            } else if (inTag) {\n                if (c == ' ' && inName) {\n                    inName = false;\n                }\n                name.append(c);\n            } else if (c == '/') {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                }\n            }\n        }\n        return stack.isEmpty() ? null : stack.get(0);\n    }\n\n    private static void findPanel(Panel panel, int x, int y, List<Panel> path) {\n        if (panel.contains(x, y)) {\n            path.add(panel);\n            for (Panel child : panel.children) {\n                findPanel(child, x, y, path);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:59:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import tkinter as tk\nimport re\n\nclass TouchPanelApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Touch Panel Application\")\n\n        self.input_label = tk.Label(root, text=\"Input:\")\n        self.input_label.pack()\n        \n        self.input_text = tk.Text(root, height=15, width=50)\n        self.input_text.pack()\n\n        self.result_label = tk.Label(root, text=\"Results:\")\n        self.result_label.pack()\n        \n        self.result_text = tk.Text(root, height=15, width=50, state='disabled')\n        self.result_text.pack()\n\n        self.submit_button = tk.Button(root, text=\"Submit\", command=self.process_input)\n        self.submit_button.pack()\n\n    def parse_panels(self, panel_structure):\n        panels = []\n        pattern = re.compile(r'(\\w+)\\s*\\[\\s*(\\d+),\\s*(\\d+),\\s*(\\d+),\\s*(\\d+)\\s*\\]')\n        matches = pattern.findall(panel_structure)\n        for match in matches:\n            panel_name = match[0]\n            x1, y1, x2, y2 = map(int, match[1:])\n            panels.append((panel_name, x1, y1, x2, y2))\n        return panels\n\n    def find_selected_panel(self, x, y, panels):\n        selected_panel = None\n        above_count = 0\n        for panel in panels:\n            name, x1, y1, x2, y2 = panel\n            if x1 <= x <= x2 and y1 <= y <= y2:\n                if selected_panel is None or above_count > len([p for p in panels if self.is_above(p, selected_panel)]):\n                    selected_panel = panel\n                    above_count = len([p for p in panels if self.is_above(p, selected_panel)])\n                    \n        return selected_panel, above_count\n\n    def is_above(self, panel, selected_panel):\n        return panel[1] <= selected_panel[1] and panel[2] <= selected_panel[2]\n\n    def process_input(self):\n        input_data = self.input_text.get(\"1.0\", tk.END)\n        try:\n            num_touch_points, panel_data, *touch_points = input_data.strip().splitlines()\n            num_touch_points = int(num_touch_points)\n\n            panels = self.parse_panels(panel_data)\n\n            results = []\n            for i in range(num_touch_points):\n                x, y = map(int, touch_points[i].split(','))\n                selected_panel, above_count = self.find_selected_panel(x, y, panels)\n                \n                if selected_panel:\n                    panel_name = selected_panel[0]\n                    results.append(f\"Touch Point {i+1}: Panel {panel_name}, Above: {above_count}\")\n                else:\n                    results.append(f\"Touch Point {i+1}: Out of main panel\")\n\n            self.result_text.config(state='normal')\n            self.result_text.delete(\"1.0\", tk.END)\n            self.result_text.insert(tk.END, \"\\n\".join(results))\n            self.result_text.config(state='disabled')\n        except Exception as e:\n            self.result_text.config(state='normal')\n            self.result_text.delete(\"1.0\", tk.END)\n            self.result_text.insert(tk.END, f\"Error: {str(e)}\")\n            self.result_text.config(state='disabled')\n\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    app = TouchPanelApp(root)\n    root.mainloop()",
    "timestamp": "2025-08-13 01:36:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class NestedPanelApp extends JFrame {\n\n    static class PanelDescriptor {\n        String name;\n        Rectangle bounds;\n        List<PanelDescriptor> children;\n\n        public PanelDescriptor(String name, int x, int y, int width, int height) {\n            this.name = name;\n            this.bounds = new Rectangle(x, y, width, height);\n            this.children = new ArrayList<>();\n        }\n\n        public void addChild(PanelDescriptor child) {\n            children.add(child);\n        }\n    }\n\n    private PanelDescriptor mainPanel;\n    private List<Point> touchPoints;\n\n    public NestedPanelApp(String tagStructure, List<Point> touchPoints) {\n        this.touchPoints = touchPoints;\n        parsePanelStructure(tagStructure);\n        setupGUI();\n    }\n\n    private void parsePanelStructure(String tagStructure) {\n        Stack<PanelDescriptor> stack = new Stack<>();\n        String[] tags = tagStructure.split(\"\\\\s+\");\n        \n        for (String tag : tags) {\n            if (tag.equals(\"END\")) {\n                if (stack.size() > 1) {\n                    PanelDescriptor child = stack.pop();\n                    stack.peek().addChild(child);\n                }\n            } else {\n                String[] parts = tag.split(\"[(),]\");\n                String name = parts[0];\n                int x = Integer.parseInt(parts[1]);\n                int y = Integer.parseInt(parts[2]);\n                int width = Integer.parseInt(parts[3]);\n                int height = Integer.parseInt(parts[4]);\n\n                PanelDescriptor pd = new PanelDescriptor(name, x, y, width, height);\n                if (stack.isEmpty()) {\n                    mainPanel = pd;\n                }\n                stack.push(pd);\n            }\n        }\n    }\n\n    private void setupGUI() {\n        setTitle(\"Nested Panel GUI\");\n        setSize(mainPanel.bounds.width, mainPanel.bounds.height);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        add(new JPanel() {\n            protected void paintComponent(Graphics g) {\n                super.paintComponent(g);\n                for (Point touchPoint : touchPoints) {\n                    int count = 0;\n                    String selectedPanelName = findPanel(mainPanel, touchPoint, 0, count);\n                    if (selectedPanelName == null) {\n                        selectedPanelName = \"OUT\";\n                        count = 0;\n                    }\n                    g.drawString(\"Touch at (\" + touchPoint.x + \", \" + touchPoint.y + \") -> \" + selectedPanelName + \", Panels above: \" + count, 10, 20 + touchPoints.indexOf(touchPoint) * 20);\n                }\n            }\n        });\n    }\n\n    private String findPanel(PanelDescriptor panel, Point touchPoint, int depth, int count) {\n        if (!panel.bounds.contains(touchPoint)) return null;\n        String found = panel.name;\n        count = depth;\n\n        for (PanelDescriptor child : panel.children) {\n            String childResult = findPanel(child, touchPoint, depth + 1, count);\n            if (childResult != null) {\n                found = childResult;\n                break;\n            }\n        }\n        return found;\n    }\n\n    public static void main(String[] args) {\n        List<Point> touchPoints = new ArrayList<>();\n        touchPoints.add(new Point(50, 50));\n        touchPoints.add(new Point(150, 150));\n        touchPoints.add(new Point(300, 300));\n\n        String tagStructure = \"MainPanel(0,0,400,400) SubPanelA(10,10,200,200) SubPanelB(20,20,100,100) END END\";\n\n        SwingUtilities.invokeLater(() -> {\n            NestedPanelApp app = new NestedPanelApp(tagStructure, touchPoints);\n            app.setVisible(true);\n        });\n    }\n}",
    "timestamp": "2025-08-13 01:36:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Panel {\n    char name[50];\n    int x, y, width, height;\n    struct Panel *children;\n    int child_count;\n} Panel;\n\ntypedef struct Point {\n    int x, y;\n} Point;\n\nint pointInPanel(Point point, Panel panel) {\n    return point.x >= panel.x && point.x <= panel.x + panel.width &&\n           point.y >= panel.y && point.y <= panel.y + panel.height;\n}\n\nint findSelectedPanel(Panel *panels, int panelCount, Point point, int *aboveCount, Panel *selectedPanel) {\n    for (int i = panelCount - 1; i >= 0; i--) {\n        if (pointInPanel(point, panels[i])) {\n            (*aboveCount)++;\n            if (panels[i].child_count > 0) {\n                if (findSelectedPanel(panels[i].children, panels[i].child_count, point, aboveCount, selectedPanel)) {\n                    return 1;\n                }\n            }\n            *selectedPanel = panels[i];\n            return 1;\n        }\n    }\n    return 0;\n}\n\nPanel parsePanel(char *str) {\n    Panel panel;\n    char *token = strtok(str, \",\");\n    strcpy(panel.name, token);\n    token = strtok(NULL, \",\");\n    sscanf(token, \"%d\", &(panel.x));\n    token = strtok(NULL, \",\");\n    sscanf(token, \"%d\", &(panel.y));\n    token = strtok(NULL, \",\");\n    sscanf(token, \"%d\", &(panel.width));\n    token = strtok(NULL, \",\");\n    sscanf(token, \"%d\", &(panel.height));\n    panel.child_count = 0;\n    panel.children = NULL;\n    return panel;\n}\n\nPanel* loadPanels(int *count) {\n    char input[1024];\n    printf(\"Enter number of panels: \");\n    scanf(\"%d\", count);\n    Panel *panels = malloc(sizeof(Panel) * (*count));\n\n    for (int i = 0; i < *count; i++) {\n        printf(\"Enter panel data (name,x,y,width,height): \");\n        scanf(\"%s\", input);\n        panels[i] = parsePanel(input);\n    }\n    return panels;\n}\n\nint main() {\n    int panelCount;\n    Panel *panels = loadPanels(&panelCount);\n\n    int touchCount;\n    printf(\"Enter number of touch points: \");\n    scanf(\"%d\", &touchCount);\n\n    for (int i = 0; i < touchCount; i++) {\n        int x, y;\n        printf(\"Enter touch point (x,y): \");\n        scanf(\"%d,%d\", &x, &y);\n\n        Point touchPoint = {x, y};\n        Panel selectedPanel;\n        int aboveCount = -1;\n\n        if (findSelectedPanel(panels, panelCount, touchPoint, &aboveCount, &selectedPanel)) {\n            printf(\"Selected Panel: %s, Panels Above: %d\\n\", selectedPanel.name, aboveCount);\n        } else {\n            printf(\"Touch point (%d, %d) is out of main panel\\n\", x, y);\n        }\n    }\n\n    free(panels);\n    return 0;\n}",
    "timestamp": "2025-08-13 01:36:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import tkinter as tk\nfrom tkinter import messagebox\nimport re\n\nclass PanelLayoutApp:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"Panel Layout Analyzer\")\n\n        # Input fields\n        tk.Label(master, text=\"Panel Structure:\").pack()\n        self.structure_entry = tk.Text(master, height=10, width=50)\n        self.structure_entry.pack()\n\n        tk.Label(master, text=\"Touch Points (x,y one per line):\").pack()\n        self.points_entry = tk.Text(master, height=5, width=50)\n        self.points_entry.pack()\n\n        tk.Button(master, text=\"Analyze\", command=self.analyze_layout).pack()\n\n        self.result_text = tk.Text(master, height=10, width=50)\n        self.result_text.pack()\n\n    def parse_structure(self, structure):\n        panels = {}\n        pattern = r'(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)\\]'\n        for match in re.finditer(pattern, structure):\n            name, x1, y1, x2, y2 = match.groups()\n            panels[name] = {\n                'x1': int(x1), \n                'y1': int(y1), \n                'x2': int(x2), \n                'y2': int(y2)\n            }\n        return panels\n\n    def find_selected_panel(self, panels, x, y):\n        selected = []\n        for name, panel in panels.items():\n            if (panel['x1'] <= x <= panel['x2'] and \n                panel['y1'] <= y <= panel['y2']):\n                selected.append((name, panel))\n        return selected\n\n    def count_above_panels(self, panels, selected_panel):\n        count = 0\n        for name, panel in panels.items():\n            if (panel['x1'] <= selected_panel['x1'] and \n                panel['x2'] >= selected_panel['x2'] and \n                panel['y2'] < selected_panel['y1']):\n                count += 1\n        return count\n\n    def analyze_layout(self):\n        structure = self.structure_entry.get(\"1.0\", tk.END).strip()\n        points = self.points_entry.get(\"1.0\", tk.END).strip().split('\\n')\n        \n        try:\n            panels = self.parse_structure(structure)\n            \n            results = []\n            for point in points:\n                x, y = map(int, point.split(','))\n                \n                selected = self.find_selected_panel(panels, x, y)\n                \n                if not selected:\n                    results.append(f\"Point ({x},{y}): Out of main panel\")\n                else:\n                    # If multiple panels, choose the topmost/last one\n                    selected_panel_name, selected_panel_details = selected[-1]\n                    above_count = self.count_above_panels(panels, selected_panel_details)\n                    \n                    results.append(f\"Point ({x},{y}): Panel {selected_panel_name}, {above_count} panels above\")\n            \n            self.result_text.delete(\"1.0\", tk.END)\n            self.result_text.insert(tk.END, \"\\n\".join(results))\n        \n        except Exception as e:\n            messagebox.showerror(\"Error\", str(e))\n\ndef main():\n    root = tk.Tk()\n    app = PanelLayoutApp(root)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:36:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import tkinter as tk\nfrom tkinter import simpledialog\n\nclass Panel:\n    def __init__(self, name, x1, y1, x2, y2):\n        self.name = name\n        self.x1 = x1\n        self.y1 = y1\n        self.x2 = x2\n        self.y2 = y2\n        self.children = []\n\ndef parse_tagged_structure(s):\n    stack = []\n    i = 0\n    while i < len(s):\n        if s[i] == '<':\n            i += 1\n            name_start = i\n            while i < len(s) and s[i] != ',':\n                i += 1\n            name = s[name_start:i]\n            i += 1\n            x1_start = i\n            while i < len(s) and s[i] != ',':\n                i += 1\n            x1 = int(s[x1_start:i])\n            i += 1\n            y1_start = i\n            while i < len(s) and s[i] != ',':\n                i += 1\n            y1 = int(s[y1_start:i])\n            i += 1\n            x2_start = i\n            while i < len(s) and s[i] != ',':\n                i += 1\n            x2 = int(s[x2_start:i])\n            i += 1\n            y2_start = i\n            while i < len(s) and s[i] != '>':\n                i += 1\n            y2 = int(s[y2_start:i])\n            i += 1\n            panel = Panel(name, x1, y1, x2, y2)\n            if stack:\n                stack[-1].children.append(panel)\n            stack.append(panel)\n        elif s[i] == '/':\n            if len(stack) > 1:\n                stack.pop()\n            i += 1\n        else:\n            i += 1\n    return stack[0] if stack else None\n\ndef find_selected_panel(root, x, y):\n    if not (root.x1 <= x <= root.x2 and root.y1 <= y <= root.y2):\n        return None\n    selected = root\n    stack = [(root, 0)]\n    best_depth = 0\n    while stack:\n        panel, depth = stack.pop()\n        if panel.x1 <= x <= panel.x2 and panel.y1 <= y <= panel.y2:\n            if depth > best_depth:\n                best_depth = depth\n                selected = panel\n            for child in reversed(panel.children):\n                stack.append((child, depth + 1))\n    return selected\n\ndef count_above_panels(root, selected_panel):\n    if selected_panel == root:\n        return 0\n    stack = [(root, [])]\n    path = []\n    found = False\n    while stack and not found:\n        panel, current_path = stack.pop()\n        if panel == selected_panel:\n            path = current_path\n            found = True\n        else:\n            for child in reversed(panel.children):\n                stack.append((child, current_path + [panel]))\n    return len(path)\n\ndef main():\n    root = tk.Tk()\n    root.withdraw()\n    n = simpledialog.askinteger(\"Input\", \"Number of touch points:\")\n    if n is None:\n        return\n    tagged_structure = simpledialog.askstring(\"Input\", \"Tagged structure:\")\n    if tagged_structure is None:\n        return\n    root_panel = parse_tagged_structure(tagged_structure)\n    if not root_panel:\n        print(\"Invalid tagged structure\")\n        return\n    results = []\n    for _ in range(n):\n        coords = simpledialog.askstring(\"Input\", \"Touch point (x,y):\")\n        if coords is None:\n            return\n        x, y = map(int, coords.split(','))\n        selected = find_selected_panel(root_panel, x, y)\n        if selected:\n            above = count_above_panels(root_panel, selected)\n            results.append(f\"{selected.name} {above}\")\n        else:\n            results.append(\"OUT OF MAIN PANEL\")\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:37:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <stack>\n#include <SFML/Graphics.hpp>\n\nstruct Panel {\n    std::string name;\n    int x, y, width, height;\n};\n\nbool insidePanel(const Panel& panel, int touchX, int touchY) {\n    return touchX >= panel.x && touchX <= (panel.x + panel.width) &&\n           touchY >= panel.y && touchY <= (panel.y + panel.height);\n}\n\nstd::vector<Panel> parsePanelStructure(const std::string& structure) {\n    std::vector<Panel> panels;\n    std::stack<std::pair<std::string, sf::IntRect>> panelStack;\n\n    std::istringstream iss(structure);\n    std::string token;\n    while (iss >> token) {\n        if (token == \"</panel>\") {\n            panelStack.pop();\n        } else {\n            // Parse panel tag\n            std::string name;\n            int x, y, width, height;\n            std::sscanf(token.c_str(), \"<panel name=\\\"%[^\\\"]\\\" x=\\\"%d\\\" y=\\\"%d\\\" width=\\\"%d\\\" height=\\\"%d\\\">\", \n                        &name[0], &x, &y, &width, &height);\n            sf::IntRect panelRect(x, y, width, height);\n            if (!panelStack.empty()) {\n                panelRect.left += panelStack.top().second.left;\n                panelRect.top += panelStack.top().second.top;\n            }\n            panelStack.push({name, panelRect});\n            panels.push_back(Panel{name, panelRect.left, panelRect.top, panelRect.width, panelRect.height});\n        }\n    }\n\n    return panels;\n}\n\nvoid findSelectedPanel(const std::vector<Panel>& panels, const std::vector<std::pair<int, int>>& touchPoints) {\n    for (const auto& touch : touchPoints) {\n        int touchX = touch.first;\n        int touchY = touch.second;\n\n        std::string selectedPanel;\n        int abovePanels = 0;\n\n        for (auto rit = panels.rbegin(); rit != panels.rend(); ++rit) {\n            if (insidePanel(*rit, touchX, touchY)) {\n                if (selectedPanel.empty()) {\n                    selectedPanel = rit->name;\n                } else {\n                    ++abovePanels;\n                }\n            }\n        }\n\n        if (selectedPanel.empty()) {\n            std::cout << \"Touch point (\" << touchX << \", \" << touchY << \") is out of the main panel.\" << std::endl;\n        } else {\n            std::cout << \"Selected panel: \" << selectedPanel << \", Panels directly above: \" << abovePanels << std::endl;\n        }\n    }\n}\n\nint main() {\n    sf::RenderWindow window(sf::VideoMode(800, 600), \"Panel Selector\");\n\n    std::string panelStructure = \"<panel name=\\\"main\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"800\\\" height=\\\"600\\\">\"\n                                 \"<panel name=\\\"sub1\\\" x=\\\"100\\\" y=\\\"100\\\" width=\\\"200\\\" height=\\\"200\\\">\"\n                                 \"</panel>\"\n                                 \"<panel name=\\\"sub2\\\" x=\\\"150\\\" y=\\\"150\\\" width=\\\"100\\\" height=\\\"100\\\">\"\n                                 \"</panel>\"\n                                 \"</panel>\";\n    \n    std::vector<Panel> panels = parsePanelStructure(panelStructure);\n    std::vector<std::pair<int, int>> touchPoints = {{110, 110}, {160, 160}, {300, 300}};\n\n    findSelectedPanel(panels, touchPoints);\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear(sf::Color::White);\n\n        // Draw panels\n        for (const auto& panel : panels) {\n            sf::RectangleShape rectangle;\n            rectangle.setSize(sf::Vector2f(panel.width, panel.height));\n            rectangle.setPosition(panel.x, panel.y);\n            rectangle.setOutlineColor(sf::Color::Black);\n            rectangle.setOutlineThickness(1);\n            rectangle.setFillColor(sf::Color::Transparent);\n            window.draw(rectangle);\n        }\n\n        window.display();\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:01:15"
  }
]