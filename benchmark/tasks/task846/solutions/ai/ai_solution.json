[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* graph[MAX_N];\nint visited[MAX_N];\nint subtree_hash[MAX_N];\nint n, min_colors, min_leaves;\n\nvoid add_edge(int u, int v) {\n    Node* new_node = malloc(sizeof(Node));\n    new_node->vertex = v;\n    new_node->next = graph[u];\n    graph[u] = new_node;\n}\n\nint compute_hash(int node, int parent) {\n    int hash = 1;\n    for (Node* child = graph[node]; child; child = child->next) {\n        if (child->vertex != parent) {\n            hash = hash * 31 + compute_hash(child->vertex, node);\n        }\n    }\n    return subtree_hash[node] = hash;\n}\n\nvoid dfs_count_isomorphic(int node, int* color_groups, int* group_count) {\n    visited[node] = 1;\n    int found = 0;\n    \n    for (int i = 0; i < *group_count; i++) {\n        if (subtree_hash[node] == subtree_hash[color_groups[i]]) {\n            found = 1;\n            break;\n        }\n    }\n    \n    if (!found) {\n        color_groups[(*group_count)++] = node;\n    }\n    \n    for (Node* child = graph[node]; child; child = child->next) {\n        if (!visited[child->vertex]) {\n            dfs_count_isomorphic(child->vertex, color_groups, group_count);\n        }\n    }\n}\n\nint count_leaves(int node, int parent) {\n    int leaf_count = 0, child_count = 0;\n    \n    for (Node* child = graph[node]; child; child = child->next) {\n        if (child->vertex != parent) {\n            child_count++;\n            leaf_count += count_leaves(child->vertex, node);\n        }\n    }\n    \n    return (child_count == 0) ? 1 : leaf_count;\n}\n\nvoid solve() {\n    memset(visited, 0, sizeof(visited));\n    compute_hash(1, 0);\n    \n    int color_groups[MAX_N], group_count = 0;\n    dfs_count_isomorphic(1, color_groups, &group_count);\n    \n    min_colors = group_count;\n    min_leaves = count_leaves(1, 0);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n    \n    solve();\n    \n    printf(\"%d %d\\n\", min_colors, min_leaves);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 200010\n\ntypedef struct {\n    int to, next;\n} Edge;\n\nEdge edges[MAXN * 2];\nint head[MAXN], edgeCount;\nint n, color[MAXN], parent[MAXN], deg[MAXN];\nint dp[MAXN], leaves;\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount].to = v;\n    edges[edgeCount].next = head[u];\n    head[u] = edgeCount++;\n}\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    int childCount = 0;\n    int childColors = 0;\n    int maxColor = 0;\n    int colorCount[MAXN] = {0};\n\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v == p) continue;\n        dfs(v, u);\n        childCount++;\n        colorCount[color[v]]++;\n        if (colorCount[color[v]] > maxColor) {\n            maxColor = colorCount[color[v]];\n            childColors = color[v];\n        }\n    }\n\n    if (childCount == 0) {\n        color[u] = 1;\n        leaves++;\n    } else {\n        if (maxColor == 1 && childCount > 1) {\n            color[u] = childCount + 1;\n        } else {\n            color[u] = childColors;\n        }\n    }\n}\n\nint main() {\n    memset(head, -1, sizeof(head));\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n        addEdge(v, u);\n        deg[u]++;\n        deg[v]++;\n    }\n\n    dfs(1, -1);\n\n    int maxColor = 0;\n    for (int i = 1; i <= n; i++) {\n        if (color[i] > maxColor) {\n            maxColor = color[i];\n        }\n    }\n\n    printf(\"%d %d\\n\", maxColor, leaves);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstruct Tree {\n    int n;\n    vector<vector<int>> adj;\n    vector<int> parent, depth, sz;\n    vector<vector<int>> children;\n\n    Tree(int n) : n(n), adj(n), parent(n, -1), depth(n), sz(n), children(n) {}\n\n    void add_edge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    void dfs(int u, int p) {\n        parent[u] = p;\n        depth[u] = (p == -1) ? 0 : depth[p] + 1;\n        sz[u] = 1;\n        for (int v : adj[u]) {\n            if (v != p) {\n                children[u].push_back(v);\n                dfs(v, u);\n                sz[u] += sz[v];\n            }\n        }\n    }\n\n    vector<int> get_centers() {\n        dfs(0, -1);\n        int u = max_element(depth.begin(), depth.end()) - depth.begin();\n        dfs(u, -1);\n        int v = max_element(depth.begin(), depth.end()) - depth.begin();\n        vector<int> path;\n        while (v != u) {\n            path.push_back(v);\n            v = parent[v];\n        }\n        path.push_back(u);\n        if (path.size() % 2 == 1) {\n            return {path[path.size() / 2]};\n        } else {\n            return {path[path.size() / 2 - 1], path[path.size() / 2]};\n        }\n    }\n\n    string get_hash(int u, int p) {\n        vector<string> child_hashes;\n        for (int v : adj[u]) {\n            if (v != p) {\n                child_hashes.push_back(get_hash(v, u));\n            }\n        }\n        sort(child_hashes.begin(), child_hashes.end());\n        string res = \"(\";\n        for (const string &s : child_hashes) {\n            res += s;\n        }\n        res += \")\";\n        return res;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    Tree tree(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        tree.add_edge(u - 1, v - 1);\n    }\n\n    vector<int> centers = tree.get_centers();\n    map<string, int> hash_count;\n    for (int root : centers) {\n        string h = tree.get_hash(root, -1);\n        hash_count[h]++;\n    }\n\n    int min_color = hash_count.size();\n    int min_leaves = 0;\n\n    if (min_color == 1) {\n        min_leaves = 2;\n    } else {\n        min_leaves = 1;\n    }\n\n    cout << min_color << \" \" << min_leaves << \"\\n\";\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeColorfulness {\n    static class TreeNode {\n        int id;\n        List<TreeNode> children;\n        TreeNode(int id) {\n            this.id = id;\n            this.children = new ArrayList<>();\n        }\n    }\n\n    static String getTreeHash(TreeNode node, Map<String, Integer> hashMap) {\n        if (node == null) return \"\";\n        List<String> childHashes = new ArrayList<>();\n        for (TreeNode child : node.children) {\n            childHashes.add(getTreeHash(child, hashMap));\n        }\n        Collections.sort(childHashes);\n        StringBuilder hashBuilder = new StringBuilder();\n        for (String hash : childHashes) {\n            hashBuilder.append(hash);\n        }\n        String hash = \"(\" + hashBuilder.toString() + \")\";\n        if (!hashMap.containsKey(hash)) {\n            hashMap.put(hash, hashMap.size());\n        }\n        return hash;\n    }\n\n    static int[] solve(TreeNode root) {\n        Map<String, Integer> hashMap = new HashMap<>();\n        getTreeHash(root, hashMap);\n        int colorfulness = hashMap.size();\n        \n        int minLeaves = 0;\n        if (colorfulness == 1) {\n            minLeaves = 1;\n        } else {\n            minLeaves = colorfulness;\n        }\n        \n        return new int[]{colorfulness, minLeaves};\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        TreeNode[] nodes = new TreeNode[n + 1];\n        for (int i = 1; i <= n; i++) {\n            nodes[i] = new TreeNode(i);\n        }\n        for (int i = 1; i < n; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            nodes[u].children.add(nodes[v]);\n            nodes[v].children.add(nodes[u]);\n        }\n        \n        TreeNode root = nodes[1];\n        int[] result = solve(root);\n        System.out.println(result[0] + \" \" + result[1]);\n    }\n}",
    "timestamp": "2025-08-05 23:08:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int MAX_N = 100005;\n    private static List<Integer>[] graph;\n    private static int[] subtreeSize;\n    private static int[] parent;\n    private static boolean[] isLeaf;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        \n        graph = new ArrayList[n + 1];\n        for (int i = 1; i <= n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        subtreeSize = new int[n + 1];\n        parent = new int[n + 1];\n        isLeaf = new boolean[n + 1];\n        \n        for (int i = 0; i < n - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        \n        calculateSubtreeSizes(1, 0);\n        \n        int minColors = getMinColors(1, 0);\n        int minLeaves = countMinLeaves(1, 0);\n        \n        System.out.println(minColors + \" \" + minLeaves);\n    }\n    \n    private static void calculateSubtreeSizes(int node, int par) {\n        subtreeSize[node] = 1;\n        parent[node] = par;\n        isLeaf[node] = graph[node].size() == 1 && node != 1;\n        \n        for (int child : graph[node]) {\n            if (child != par) {\n                calculateSubtreeSizes(child, node);\n                subtreeSize[node] += subtreeSize[child];\n            }\n        }\n    }\n    \n    private static int getMinColors(int node, int par) {\n        Map<Integer, Integer> subtreeSizeGroups = new HashMap<>();\n        \n        for (int child : graph[node]) {\n            if (child != par) {\n                int size = subtreeSize[child];\n                subtreeSizeGroups.put(size, subtreeSizeGroups.getOrDefault(size, 0) + 1);\n            }\n        }\n        \n        return subtreeSizeGroups.size();\n    }\n    \n    private static int countMinLeaves(int node, int par) {\n        int leafCount = 0;\n        \n        for (int child : graph[node]) {\n            if (child != par) {\n                if (isLeaf[child]) {\n                    leafCount++;\n                }\n            }\n        }\n        \n        return leafCount > 0 ? leafCount : 1;\n    }\n}",
    "timestamp": "2025-08-05 23:08:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minColorfulness(vector<vector<int>>& originalTree) {\n        int n = originalTree.size();\n        \n        // Function to check rooted tree isomorphism\n        function<bool(vector<int>&, vector<int>&)> areIsomorphic = \n        [&](vector<int>& tree1, vector<int>& tree2) {\n            if (tree1.size() != tree2.size()) return false;\n            \n            vector<vector<int>> subtrees1, subtrees2;\n            for (int v : tree1) subtrees1.push_back({v});\n            for (int v : tree2) subtrees2.push_back({v});\n            \n            return subtrees1 == subtrees2;\n        };\n        \n        // Check all possible colorings\n        int minColors = n;\n        int minLeaves = n;\n        \n        for (int colors = 1; colors <= n; colors++) {\n            vector<vector<int>> coloredVertices(colors);\n            \n            // Try all color assignments\n            bool possible = true;\n            for (int v = 0; v < n; v++) {\n                bool placed = false;\n                for (int color = 0; color < colors; color++) {\n                    // Check if current color group has isomorphic trees\n                    bool valid = true;\n                    for (int u : coloredVertices[color]) {\n                        if (!areIsomorphic(originalTree[u], originalTree[v])) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    \n                    if (valid) {\n                        coloredVertices[color].push_back(v);\n                        placed = true;\n                        break;\n                    }\n                }\n                \n                // If vertex cannot be placed in any color group\n                if (!placed) {\n                    possible = false;\n                    break;\n                }\n            }\n            \n            // If valid coloring found\n            if (possible) {\n                int leaves = 0;\n                for (auto& group : coloredVertices) {\n                    leaves += max(1, (int)group.size());\n                }\n                \n                // Update minimum colors and leaves\n                if (colors < minColors || \n                    (colors == minColors && leaves < minLeaves)) {\n                    minColors = colors;\n                    minLeaves = leaves;\n                }\n            }\n        }\n        \n        return minLeaves;\n    }\n};",
    "timestamp": "2025-08-05 23:08:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeNode:\n    def __init__(self, id):\n        self.id = id\n        self.children = []\n\ndef build_tree(n):\n    if n == 0:\n        return None\n    root = TreeNode(0)\n    nodes = [root]\n    for i in range(1, n):\n        new_node = TreeNode(i)\n        nodes.append(new_node)\n    for i in range(1, n):\n        nodes[i // 2].children.append(nodes[i])\n    return root\n\ndef count_leaves(root):\n    if root is None:\n        return 0\n    if not root.children:\n        return 1\n    leaves = 0\n    for child in root.children:\n        leaves += count_leaves(child)\n    return leaves\n\ndef isomorphic(root1, root2):\n    if not root1 and not root2:\n        return True\n    if (not root1 and root2) or (root1 and not root2) or (len(root1.children) != len(root2.children)):\n        return False\n    root1.children.sort(key=lambda x: len(x.children))\n    root2.children.sort(key=lambda x: len(x.children))\n    for c1, c2 in zip(root1.children, root2.children):\n        if not isomorphic(c1, c2):\n            return False\n    return True\n\ndef min_colorfulness_and_leaves(n):\n    if n == 0:\n        return 0, 0\n    if n == 1:\n        return 1, 1\n    root = build_tree(n)\n    k = 1\n    leaves = count_leaves(root)\n    nodes = [root]\n    while nodes:\n        node = nodes.pop()\n        if node.children:\n            node.children.sort(key=lambda x: len(x.children))\n        for child in node.children:\n            nodes.append(child)\n    return k, leaves\n\nn = int(input())\ncolorfulness, min_leaves = min_colorfulness_and_leaves(n)\nprint(colorfulness, min_leaves)",
    "timestamp": "2025-08-13 13:40:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\n\npublic class TreeColoring {\n    private Map<Integer, List<Integer>> treeMap = new HashMap<>();\n    private Map<Integer, Integer> subtreeHash = new HashMap<>();\n    private int leafCount = 0;\n\n    public void addEdge(int u, int v) {\n        treeMap.computeIfAbsent(u, k -> new ArrayList<>()).add(v);\n        treeMap.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\n    }\n\n    public int calculateColorfulness() {\n        dfs(1, -1);\n        HashSet<Integer> uniqueHashes = new HashSet<>(subtreeHash.values());\n        return uniqueHashes.size();\n    }\n\n    public int calculateMinimumLeaves() {\n        leafCount = 0;\n        dfsLeafCount(1, -1);\n        return leafCount;\n    }\n\n    private int dfs(int node, int parent) {\n        int hash = 1;\n        List<Integer> childHashes = new ArrayList<>();\n\n        for (int neighbor : treeMap.get(node)) {\n            if (neighbor == parent) continue;\n            childHashes.add(dfs(neighbor, node));\n        }\n\n        childHashes.sort(Integer::compareTo);\n        for (int childHash : childHashes) {\n            hash = 31 * hash + childHash;\n        }\n\n        subtreeHash.put(node, hash);\n        return hash;\n    }\n\n    private void dfsLeafCount(int node, int parent) {\n        boolean isLeaf = true;\n        for (int neighbor : treeMap.get(node)) {\n            if (neighbor != parent) {\n                isLeaf = false;\n                dfsLeafCount(neighbor, node);\n            }\n        }\n        if (isLeaf) leafCount++;\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        TreeColoring tree = new TreeColoring();\n        tree.addEdge(1, 2);\n        tree.addEdge(1, 3);\n        tree.addEdge(2, 4);\n        tree.addEdge(3, 5);\n\n        System.out.println(\"Minimum Colorfulness: \" + tree.calculateColorfulness());\n        System.out.println(\"Minimum Leaves: \" + tree.calculateMinimumLeaves());\n    }\n}",
    "timestamp": "2025-08-13 13:40:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 1000\n\ntypedef struct {\n    int n;\n    int *adj[MAXN];\n    int deg[MAXN];\n} Tree;\n\nTree tree;\nint used[MAXN];\nint color[MAXN];\nint leaf_count, colorfulness;\n\nvoid dfs(int v, int parent, int color_id) {\n    used[v] = 1;\n    color[v] = color_id;\n    int children[MAXN];\n    memset(children, 0, sizeof(children));\n    int child_count = 0;\n\n    for (int i = 0; i < tree.deg[v]; ++i) {\n        int u = tree.adj[v][i];\n        if (u != parent) {\n            dfs(u, v, color_id + 1);\n            children[child_count++] = color[u];\n        }\n    }\n\n    for (int i = 0; i < child_count; ++i) {\n        for (int j = i + 1; j < child_count; ++j) {\n            if (children[i] == children[j]) {\n                color[v] = color[children[i]];\n            }\n        }\n    }\n}\n\nvoid calculate(int n) {\n    memset(color, 0, sizeof(color));\n    memset(used, 0, sizeof(used));\n    leaf_count = 0;\n\n    for (int v = 0; v < n; ++v) {\n        if (tree.deg[v] == 1) {\n            leaf_count++;\n        }\n    }\n\n    dfs(0, -1, 0);\n    colorfulness = 0;\n    for (int i = 0; i < n; ++i) {\n        if (color[i] > colorfulness) {\n            colorfulness = color[i];\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        tree.adj[i] = (int *) malloc(MAXN * sizeof(int));\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        tree.adj[u][tree.deg[u]++] = v;\n        tree.adj[v][tree.deg[v]++] = u;\n    }\n\n    calculate(n);\n\n    printf(\"Minimum Colorfulness: %d\\n\", colorfulness);\n    printf(\"Minimum Leaves: %d\\n\", leaf_count);\n    \n    for (int i = 0; i < n; ++i) {\n        free(tree.adj[i]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 13:40:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\n// Helper function to perform DFS and calculate hash of subtrees\nvoid calculateHash(int node, int parent, vector<vector<int>> &tree, unordered_map<int, multiset<string>> &subtreeHash) {\n    vector<string> childHashes;\n    for (int neighbor : tree[node]) {\n        if (neighbor != parent) {\n            calculateHash(neighbor, node, tree, subtreeHash);\n            childHashes.push_back(*subtreeHash[neighbor].begin());\n        }\n    }\n    sort(childHashes.begin(), childHashes.end());\n    string hashValue = \"(\";\n    for (const string &hash : childHashes) {\n        hashValue += hash;\n    }\n    hashValue += \")\";\n    subtreeHash[node].insert(hashValue);\n}\n\n// Function to calculate the minimum colorfulness of the tree\nint calculateColorfulness(int n, vector<vector<int>> &tree) {\n    unordered_map<int, multiset<string>> subtreeHash;\n    calculateHash(0, -1, tree, subtreeHash);\n    \n    set<string> uniqueHashes;\n    for (int i = 0; i < n; ++i) {\n        uniqueHashes.insert(*subtreeHash[i].begin());\n    }\n    \n    return uniqueHashes.size();\n}\n\n// Function to count minimum number of leaves in the tree\nint minimumLeaves(int n, vector<vector<int>> &tree) {\n    int leaves = 0;\n    for (int i = 0; i < n; ++i) {\n        if (tree[i].size() == 1) {\n            leaves++;\n        }\n    }\n    return leaves;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> tree(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        tree[u - 1].push_back(v - 1);\n        tree[v - 1].push_back(u - 1);\n    }\n    \n    int minColorfulness = calculateColorfulness(n, tree);\n    int minLeaves = minimumLeaves(n, tree);\n    \n    cout << minColorfulness << \" \" << minLeaves << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:40:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\nfrom typing import List, Dict, Set\n\nclass Solution:\n    def minimumColorfulness(self, n: int, edges: List[List[int]]) -> List[int]:\n        # Build adjacency list\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Check if graph is a tree\n        if len(edges) != n - 1:\n            return [-1, -1]\n        \n        # Get subtree structure for each node\n        def get_subtree_structure(root: int) -> str:\n            visited = set()\n            subtree = defaultdict(list)\n            \n            def dfs(node: int, parent: int):\n                visited.add(node)\n                for child in graph[node]:\n                    if child != parent and child not in visited:\n                        subtree[node].append(child)\n                        dfs(child, node)\n            \n            dfs(root, -1)\n            return self.encode_subtree(root, subtree)\n        \n        def encode_subtree(root: int, subtree: Dict[int, List[int]]) -> str:\n            def canonical_form(node: int) -> str:\n                if not subtree[node]:\n                    return \"L\"\n                \n                children_codes = []\n                for child in sorted(subtree[node]):\n                    children_codes.append(canonical_form(child))\n                \n                return f\"({','.join(sorted(children_codes))})\"\n            \n            return canonical_form(root)\n        \n        # Find minimum colors and leaves\n        def solve() -> List[int]:\n            structures = defaultdict(list)\n            \n            # Group nodes with same subtree structure\n            for node in range(1, n + 1):\n                structure = get_subtree_structure(node)\n                structures[structure].append(node)\n            \n            # Minimum colors needed\n            colors = len(structures)\n            \n            # Count minimum leaves\n            leaves = 0\n            for group in structures.values():\n                leaves += max(0, 1 - len(group))\n            \n            return [colors, leaves]\n        \n        return solve()",
    "timestamp": "2025-08-13 13:40:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = map(int, input[ptr:ptr+2])\n        ptr += 2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Find the center(s) of the tree\n    def find_centers():\n        if N == 1:\n            return [1]\n        degree = [0] * (N + 1)\n        leaves = deque()\n        for u in range(1, N+1):\n            degree[u] = len(adj[u])\n            if degree[u] == 1:\n                leaves.append(u)\n        nodes_left = N\n        while nodes_left > 2:\n            for _ in range(len(leaves)):\n                u = leaves.popleft()\n                for v in adj[u]:\n                    if degree[v] > 0:\n                        degree[v] -= 1\n                        if degree[v] == 1:\n                            leaves.append(v)\n                degree[u] = 0\n                nodes_left -= 1\n        return list(leaves)\n    \n    centers = find_centers()\n    if len(centers) == 1:\n        root = centers[0]\n    else:\n        u, v = centers\n        # Add a new node to merge the two centers\n        new_node = N + 1\n        adj.append([])\n        adj[u].append(new_node)\n        adj[v].append(new_node)\n        adj[new_node].extend([u, v])\n        root = new_node\n        N += 1\n    \n    # Now compute the hash for each node\n    parent = [0] * (N + 1)\n    children = [[] for _ in range(N + 1)]\n    stack = [(root, None, False)]\n    while stack:\n        u, p, visited = stack.pop()\n        if not visited:\n            parent[u] = p\n            stack.append((u, p, True))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u, False))\n                    children[u].append(v)\n        else:\n            pass\n    \n    # Compute the canonical hashes\n    hash_dict = {}\n    next_hash = 1\n    def compute_hash(u):\n        nonlocal next_hash\n        child_hashes = []\n        for v in children[u]:\n            compute_hash(v)\n            child_hashes.append(hash_dict[v])\n        child_hashes.sort()\n        key = tuple(child_hashes)\n        if key not in hash_dict:\n            hash_dict[key] = next_hash\n            next_hash += 1\n        hash_dict[u] = hash_dict[key]\n    \n    compute_hash(root)\n    color_count = len(set(hash_dict.values()))\n    \n    # Now compute the minimal leaves\n    # The minimal leaves is the number of distinct hashes at the original leaves\n    original_leaves = [u for u in range(1, N+1) if len(adj[u]) == 1]\n    original_leaf_hashes = set()\n    for u in original_leaves:\n        original_leaf_hashes.add(hash_dict[u])\n    min_leaves = len(original_leaf_hashes)\n    \n    print(color_count, min_leaves)\n\nsolve()",
    "timestamp": "2025-08-13 13:40:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumColorfulness(n, edges) {\n    function dfs(u, parent) {\n        let subtree = new Map();\n        for (let v of tree[u]) {\n            if (v === parent) continue;\n            let childColor = dfs(v, u);\n            if (!subtree.has(childColor)) {\n                subtree.set(childColor, 0);\n            }\n            subtree.set(childColor, subtree.get(childColor) + 1);\n        }\n\n        let sig = [];\n        for (let [k, v] of subtree.entries()) {\n            sig.push([k, v]);\n        }\n        sig.sort((a, b) => a[0] - b[0]);\n        let label = JSON.stringify(sig);\n        if (!treeID.has(label)) {\n            treeID.set(label, nextID);\n            reverseLookup.set(nextID, label);\n            nextID++;\n        }\n        return treeID.get(label);\n    }\n\n    function solve() {\n        nextID = 0;\n        treeID = new Map();      // To map tree signatures to IDs\n        reverseLookup = new Map(); // To map IDs back to tree signatures\n\n        tree = Array.from({ length: n + 1 }, () => []);\n        for (const [a, b] of edges) {\n            tree[a].push(b);\n            tree[b].push(a);\n        }\n\n        dfs(1, -1);\n\n        // Calculate minimum colorfulness\n        let colorfulness = treeID.size;\n\n        // To calculate minimum leaves, reconstruct tree structure\n        let structure = Array.from({ length: colorfulness + 1 }, () => 0);\n        for (let i = 0; i < colorfulness; i++) {\n            let label = reverseLookup.get(i);\n            if (label === '[]') {\n                structure[0]++;\n            } else {\n                let count = 0;\n                let pairs = JSON.parse(label);\n                pairs.forEach(pair => count += pair[1]);\n                structure[count]++;\n            }\n        }\n\n        let minLeaves = 0;\n        for (let i = 1; i <= colorfulness; i++) {\n            if (structure[i] > 0) {\n                minLeaves += Math.min(structure[i], Math.floor((i * structure[i]) / (i + 1)));\n            }\n        }\n\n        return {\n            colorfulness,\n            minLeaves\n        };\n    }\n\n    return solve();\n}\n\n// Example usage:\nconst n = 3;\nconst edges = [[1, 2], [1, 3]];\nconsole.log(minimumColorfulness(n, edges));",
    "timestamp": "2025-08-13 13:41:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class Node {\n    constructor() {\n        this.children = [];\n    }\n}\n\nfunction areTreesIsomorphic(tree1, tree2) {\n    function getCanonicalForm(node) {\n        if (!node) return '';\n        const childrenForms = node.children.map(getCanonicalForm).sort();\n        return `(${childrenForms.join('')})`;\n    }\n    return getCanonicalForm(tree1) === getCanonicalForm(tree2);\n}\n\nfunction minimumColorfulness(originalTree) {\n    function cloneTree(node) {\n        if (!node) return null;\n        const newNode = new Node();\n        newNode.children = node.children.map(cloneTree);\n        return newNode;\n    }\n\n    function generateColorings(tree, colors) {\n        const colorGroups = new Map();\n        const coloredTree = cloneTree(tree);\n\n        for (let color of colors) {\n            const canonicalForm = getCanonicalForm(coloredTree);\n            if (!colorGroups.has(canonicalForm)) {\n                colorGroups.set(canonicalForm, []);\n            }\n            colorGroups.get(canonicalForm).push(color);\n        }\n\n        return colorGroups;\n    }\n\n    function getCanonicalForm(node) {\n        if (!node) return '';\n        const childrenForms = node.children.map(getCanonicalForm).sort();\n        return `(${childrenForms.join('')})`;\n    }\n\n    function countLeaves(node) {\n        if (!node) return 0;\n        if (node.children.length === 0) return 1;\n        return node.children.reduce((sum, child) => sum + countLeaves(child), 0);\n    }\n\n    let minColors = Infinity;\n    let minLeaves = Infinity;\n\n    // Try different color combinations\n    function backtrack(currentColors) {\n        const colorGroups = generateColorings(originalTree, currentColors);\n\n        // Check if coloring is valid\n        const uniqueCanonicalForms = new Set(colorGroups.keys());\n        if (uniqueCanonicalForms.size === currentColors.length) {\n            if (currentColors.length < minColors) {\n                minColors = currentColors.length;\n                minLeaves = countLeaves(originalTree);\n            } else if (currentColors.length === minColors) {\n                minLeaves = Math.min(minLeaves, countLeaves(originalTree));\n            }\n        }\n\n        // Continue backtracking\n        for (let i = 1; i <= currentColors.length + 1; i++) {\n            if (!currentColors.includes(i)) {\n                backtrack([...currentColors, i]);\n            }\n        }\n    }\n\n    backtrack([]);\n\n    return [minColors, minLeaves];\n}\n\n// Example usage\nconst tree = new Node();\nconst result = minimumColorfulness(tree);\nconsole.log(result);",
    "timestamp": "2025-08-13 13:41:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let n = 0;\n    let edges = [];\n    let adjacency = [];\n\n    rl.on('line', (line) => {\n        if (n === 0) {\n            n = parseInt(line.trim());\n            adjacency = Array.from({ length: n + 1 }, () => []);\n        } else {\n            const [u, v] = line.trim().split(' ').map(Number);\n            edges.push([u, v]);\n            adjacency[u].push(v);\n            adjacency[v].push(u);\n        }\n    });\n\n    rl.on('close', () => {\n        if (n === 1) {\n            console.log('1 1');\n            return;\n        }\n\n        const tree = new Tree(n, adjacency);\n        const [minColor, minLeaves] = tree.compute();\n        console.log(`${minColor} ${minLeaves}`);\n    });\n}\n\nclass Tree {\n    constructor(n, adjacency) {\n        this.n = n;\n        this.adjacency = adjacency;\n        this.dp = Array(n + 1).fill(0);\n        this.isLeaf = Array(n + 1).fill(false);\n    }\n\n    dfs(u, parent) {\n        const children = [];\n        for (const v of this.adjacency[u]) {\n            if (v !== parent) {\n                children.push(v);\n                this.dfs(v, u);\n            }\n        }\n\n        if (children.length === 0) {\n            this.dp[u] = 1;\n            this.isLeaf[u] = true;\n        } else {\n            const childColors = children.map(v => this.dp[v]);\n            const uniqueColors = new Set(childColors);\n            this.dp[u] = uniqueColors.size;\n        }\n    }\n\n    compute() {\n        this.dfs(1, -1);\n        const minColor = this.dp[1];\n        \n        let leavesCount = 0;\n        for (let i = 1; i <= this.n; i++) {\n            if (this.isLeaf[i]) {\n                leavesCount++;\n            }\n        }\n\n        return [minColor, leavesCount];\n    }\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:41:54"
  }
]